void sub_10053683C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100536860(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t sub_100536884(uint64_t a1)
{
  return sub_10000AE14(a1 + 40);
}

void sub_10053688C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = [*(id *)(v3 + 32) silo];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3321888768LL;
  v12[2] = sub_100536970;
  v12[3] = &unk_10183F500;
  uint64_t v6 = *a2;
  v5 = (std::__shared_weak_count *)a2[1];
  v12[4] = v3;
  v12[5] = v6;
  v13 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  [v4 async:v12];
  v9 = v13;
  if (v13)
  {
    v10 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

void sub_10053695C(_Unwind_Exception *a1)
{
}

void sub_100536970(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(uint64_t **)(a1 + 48);
  v8[0] = *(uint64_t **)(a1 + 40);
  v8[1] = v3;
  if (v3)
  {
    id v4 = (unint64_t *)(v3 + 1);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  sub_100536A14(v2, v8);
  if (v3)
  {
    uint64_t v6 = (unint64_t *)(v3 + 1);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      (*(void (**)(uint64_t *))(*v3 + 16))(v3);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v3);
    }
  }

void sub_100536A00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100536A14(uint64_t a1, uint64_t **a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *v2;
    uint64_t v4 = v2[1];
    if (*v2 != v4)
    {
      uint64_t v6 = a1 + 3752;
      do
      {
        uint64_t v7 = *(unsigned int *)(v3 + 8);
        double v12 = *(double *)v3;
        double v8 = v12;
        int v13 = v7;
        int v14 = 1;
        v15[0] = sub_100539078(v6, (uint64_t)&v12);
        v15[1] = v9;
        LODWORD(v12) = 5;
        (*(void (**)(uint64_t, double *, void *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v12,  v15,  0LL,  0xFFFFFFFFLL,  0LL);
        v10 = objc_autoreleasePoolPush();
        unint64_t v11 = objc_alloc_init(&OBJC_CLASS___ALActivityLog);
        -[ALActivityLog setTimestamp:](v11, "setTimestamp:", v8);
        -[ALActivityLog setCoarseElevation:]( v11,  "setCoarseElevation:",  objc_alloc_init(&OBJC_CLASS___ALCMCoarseElevation));
        -[ALCMCoarseElevation setElevationAscended:]( -[ALActivityLog coarseElevation](v11, "coarseElevation"),  "setElevationAscended:",  v7);
        -[ALCMCoarseElevation setSource:](-[ALActivityLog coarseElevation](v11, "coarseElevation"), "setSource:", 1LL);
        objc_msgSend( -[CLServiceVendor proxyForService:]( +[CLServiceVendor sharedInstance](CLServiceVendor, "sharedInstance"),  "proxyForService:",  @"CLActivityLogger"),  "logData:",  v11);
        objc_autoreleasePoolPop(v10);
        v3 += 16LL;
      }

      while (v3 != v4);
    }
  }

uint64_t sub_100536B64(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t sub_100536B88(uint64_t a1)
{
  return sub_10000AE14(a1 + 40);
}

void sub_100536B90(unsigned __int8 *a1, int a2)
{
  if (qword_101934630 != -1) {
    dispatch_once(&qword_101934630, &stru_10183F5D8);
  }
  unint64_t v4 = (os_log_s *)qword_101934638;
  if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = a1[1128];
    *(_DWORD *)buf = 67240448;
    int v12 = v5;
    __int16 v13 = 1026;
    int v14 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Update location authorization, current, %{public}d, new, %{public}d",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    int v6 = a1[1128];
    v8[0] = 67240448;
    v8[1] = v6;
    __int16 v9 = 1026;
    int v10 = a2;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  0LL,  "Update location authorization, current, %{public}d, new, %{public}d",  v8,  14);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLOdometerNotifierWatch::updateStateOnAuthorization(BOOL)", "%s\n", v7);
  }

  if (a1[1128] != a2)
  {
    sub_1005370BC((uint64_t)a1);
    sub_100536190(a1);
    a1[1128] = a2;
    (*(void (**)(unsigned __int8 *))(*(void *)a1 + 232LL))(a1);
  }

void sub_100536D8C(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10183F598);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    double v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLOdometerNotifierWatch::onMotionStateMediatorNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10183F598);
    }
    __int16 v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      v15 = "";
      __int16 v16 = 2082;
      v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLOdometerNotifierWatch::onMotionStateMediatorNotification, event:%{public, locatio n:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10053A934(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100536F44( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100536F64(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    a1[4] = v2;
    operator delete(v2);
  }

  return a1;
}

uint64_t sub_100536FA4(uint64_t a1)
{
  *(void *)a1 = off_10183F380;
  *(void *)(a1 + 920) = off_10183F490;
  sub_1005370BC(a1);
  uint64_t v2 = *(void *)(a1 + 1168);
  *(void *)(a1 + 1168) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }

  uint64_t v3 = *(void *)(a1 + 3920);
  *(void *)(a1 + 3920) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 3912);
  *(void *)(a1 + 3912) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 3904);
  *(void *)(a1 + 3904) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 3896);
  *(void *)(a1 + 3896) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 3888);
  *(void *)(a1 + 3888) = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  sub_10053AF28((uint64_t *)(a1 + 3872), 0LL);
  double v8 = *(void **)(a1 + 3824);
  if (v8)
  {
    *(void *)(a1 + 3832) = v8;
    operator delete(v8);
  }

  sub_100E57E40(a1 + 1368);
  sub_1008AF1C4(a1 + 1176);
  uint64_t v9 = *(void *)(a1 + 1168);
  *(void *)(a1 + 1168) = 0LL;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
  }
  return sub_10027D5F8(a1);
}

uint64_t sub_1005370BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 3888);
  *(void *)(a1 + 3888) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 3896);
  *(void *)(a1 + 3896) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 3912);
  *(void *)(a1 + 3912) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  [*(id *)(a1 + 1136) releaseAccuracyEnablementAssertionForClient:CLISP_ME_TOKEN];

  *(void *)(a1 + 1136) = 0LL;
  uint64_t result = *(void *)(a1 + 3920);
  if (result)
  {
    *(void *)(a1 + 3920) = 0LL;
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }

  return result;
}

uint64_t sub_100537164(uint64_t a1)
{
  return sub_100536FA4(a1 - 920);
}

void sub_10053716C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100536FA4(a1);
  operator delete(v1);
}

void sub_100537180(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100536FA4(a1 - 920);
  operator delete(v1);
}

id sub_100537198(uint64_t a1, char a2)
{
  uint64_t v2 = *(void **)(a1 + 40);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_1005371F4;
  v4[3] = &unk_101833458;
  v4[4] = a1;
  char v5 = a2;
  return [v2 async:v4];
}

id sub_1005371F4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(_BYTE *)(a1 + 40))
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_10183F5B8);
    }
    uint64_t v2 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Enabling kNotificationOdometerUpdateElevation from companion",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_10183F5B8);
      }
      v7[0] = 0;
      char v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "Enabling kNotificationOdometerUpdateElevation from companion",  v7,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLOdometerNotifierWatch::updatePhoneWorkoutElevationSubscription(BOOL)_block_invoke",  "%s\n",  v5);
    }

    *(_DWORD *)buf = 3;
    return [*(id *)(*(void *)(v1 + 1168) + 16) register:*(void *)(*(void *)(v1 + 1168) + 8) forNotification:sub_10039FE8C(buf) registrationInfo:0];
  }

  else
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_10183F5B8);
    }
    uint64_t v4 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Disabling kNotificationOdometerUpdateElevation from companion",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_10183F5B8);
      }
      v7[0] = 0;
      uint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "Disabling kNotificationOdometerUpdateElevation from companion",  v7,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLOdometerNotifierWatch::updatePhoneWorkoutElevationSubscription(BOOL)_block_invoke",  "%s\n",  v6);
    }

    *(_DWORD *)buf = 3;
    return [*(id *)(*(void *)(v1 + 1168) + 16) unregister:*(void *)(*(void *)(v1 + 1168) + 8) forNotification:sub_10039FE8C(buf)];
  }

id sub_1005374F8(uint64_t a1, uint64_t a2)
{
  if (qword_101934630 != -1) {
    dispatch_once(&qword_101934630, &stru_10183F5D8);
  }
  uint64_t v4 = (os_log_s *)qword_101934638;
  if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Added client for cycling workout distance updates",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    v7[0] = 0;
    uint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  0LL,  "Added client for cycling workout distance updates",  v7,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLOdometerNotifierWatch::registerForCyclingWorkoutDistanceUpdates(id<CLOdometerNotifierClientProtocol>)",  "%s\n",  v6);
  }

  return [*(id *)(a1 + 3880) addObject:a2];
}

id sub_100537698(uint64_t a1, uint64_t a2)
{
  if (qword_101934630 != -1) {
    dispatch_once(&qword_101934630, &stru_10183F5D8);
  }
  uint64_t v4 = (os_log_s *)qword_101934638;
  if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Removed client from cycling workout distance updates",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    v7[0] = 0;
    uint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  0LL,  "Removed client from cycling workout distance updates",  v7,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLOdometerNotifierWatch::unregisterForCyclingWorkoutDistanceUpdates(id<CLOdometerNotifierClientProtocol>)",  "%s\n",  v6);
  }

  return [*(id *)(a1 + 3880) removeObject:a2];
}

void sub_100537838(uint64_t a1)
{
  uint64_t v2 = sub_1008FA854(0);
  *(_DWORD *)buf = 5;
  if (!sub_100247620(a1, (int *)buf, 1LL))
  {
    if (v2) {
      (*(void (**)(uint64_t, void))(*(void *)(v2 + 72) + 40LL))(v2 + 72, 0LL);
    }
    *(_DWORD *)buf = 5;
    [*(id *)(*(void *)(a1 + 1168) + 16) unregister:*(void *)(*(void *)(a1 + 1168) + 8) forNotification:sub_10039FE8C(buf)];
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_10183F5B8);
    }
    uint64_t v7 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "CoarseElevation,src,phone,0,watch,0", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_10183F5B8);
      }
      LOWORD(v11[0]) = 0;
      uint64_t v6 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "CoarseElevation,src,phone,0,watch,0",  v11,  2,  v11[0]);
      goto LABEL_48;
    }

    return;
  }

  if (*(_BYTE *)(a1 + 3977))
  {
    if (v2)
    {
      uint64_t v4 = *(void *)(v2 + 72);
      uint64_t v3 = v2 + 72;
      if ((*(unsigned int (**)(uint64_t))(v4 + 16))(v3))
      {
        if ((sub_1004F97F4() & 0x1000000000LL) != 0) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 40LL))(v3, 1LL);
        }
      }
    }

    *(_DWORD *)buf = 5;
    [*(id *)(*(void *)(a1 + 1168) + 16) register:*(void *)(*(void *)(a1 + 1168) + 8) forNotification:sub_10039FE8C(buf) registrationInfo:0];
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_10183F5B8);
    }
    char v5 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "CoarseElevation,phone,1,watch,1", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_10183F5B8);
      }
      LOWORD(v11[0]) = 0;
      uint64_t v6 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "CoarseElevation,phone,1,watch,1",  v11,  2,  v11[0]);
LABEL_48:
      int v10 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOdometerNotifierWatch::updateCoarseElevationSubscription()",  "%s\n",  v6);
      if (v10 != buf) {
        free(v10);
      }
      return;
    }

    return;
  }

  if (*(_BYTE *)(a1 + 1130) || !v2)
  {
    if (!v2) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }

  if (!(*(unsigned int (**)(uint64_t))(*(void *)(v2 + 72) + 16LL))(v2 + 72)
    || (sub_1004F97F4() & 0x1000000000LL) == 0)
  {
LABEL_38:
    (*(void (**)(uint64_t, void))(*(void *)(v2 + 72) + 40LL))(v2 + 72, 0LL);
LABEL_39:
    *(_DWORD *)buf = 5;
    [*(id *)(*(void *)(a1 + 1168) + 16) register:*(void *)(*(void *)(a1 + 1168) + 8) forNotification:sub_10039FE8C(buf) registrationInfo:0];
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_10183F5B8);
    }
    uint64_t v9 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "CoarseElevation,src,phone,1,watch,0", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_10183F5B8);
      }
      LOWORD(v11[0]) = 0;
      uint64_t v6 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "CoarseElevation,src,phone,1,watch,0",  v11,  2,  v11[0]);
      goto LABEL_48;
    }

    return;
  }

  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 + 72) + 40LL))(v2 + 72, 1LL);
  *(_DWORD *)buf = 5;
  [*(id *)(*(void *)(a1 + 1168) + 16) unregister:*(void *)(*(void *)(a1 + 1168) + 8) forNotification:sub_10039FE8C(buf)];
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_10183F5B8);
  }
  double v8 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "CoarseElevation,src,phone,0,watch,1", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_10183F5B8);
    }
    LOWORD(v11[0]) = 0;
    uint64_t v6 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "CoarseElevation,src,phone,0,watch,1",  v11,  2,  v11[0]);
    goto LABEL_48;
  }

void sub_100537D98(_BYTE *a1)
{
  if (qword_101934630 != -1) {
    dispatch_once(&qword_101934630, &stru_10183F5D8);
  }
  uint64_t v2 = (os_log_s *)qword_101934638;
  if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = a1[1128];
    *(_DWORD *)buf = 2;
    int v4 = sub_100247620((uint64_t)a1, (int *)buf, 1LL);
    int v5 = a1[1131];
    *(_DWORD *)buf = 67240704;
    int v18 = v3;
    __int16 v19 = 1026;
    int v20 = v4;
    __int16 v21 = 1026;
    int v22 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Updating odometer state, authorized, %{public}d, has active clients, %{public}d, workout distance controller, %{public}d",  buf,  0x14u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    uint64_t v7 = qword_101934638;
    int v8 = a1[1128];
    v12[0] = 2;
    int v9 = sub_100247620((uint64_t)a1, v12, 1LL);
    int v10 = a1[1131];
    v12[0] = 67240704;
    v12[1] = v8;
    __int16 v13 = 1026;
    int v14 = v9;
    __int16 v15 = 1026;
    int v16 = v10;
    char v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  0LL,  "Updating odometer state, authorized, %{public}d, has active clients, %{public}d, workout distance co ntroller, %{public}d",  v12,  20);
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLOdometerNotifierWatch::updateOdometerState()", "%s\n", v11);
  }

  else {
    sub_1005383B0(a1);
  }
  *(_DWORD *)buf = 3;
  int v6 = sub_100247620((uint64_t)a1, (int *)buf, 1LL);
  sub_100E58E74((uint64_t)(a1 + 1368), v6);
  sub_100537838((uint64_t)a1);
}

void sub_10053801C(uint64_t a1)
{
  if (qword_101934630 != -1) {
    dispatch_once(&qword_101934630, &stru_10183F5D8);
  }
  uint64_t v2 = (os_log_s *)qword_101934638;
  if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Enable GPS; Start GPS subscription", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    v8[0] = 0;
    int v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  1LL,  "Enable GPS; Start GPS subscription",
                   v8,
                   2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLOdometerNotifierWatch::enableGPS()", "%s\n", v5);
  }

  uint64_t v3 = *(void *)(a1 + 3920);
  if (v3) {
    [*(id *)(v3 + 16) register:*(void *)(v3 + 8) forNotification:41 registrationInfo:0];
  }
  if (*(_BYTE *)(a1 + 1144))
  {
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    int v4 = (os_log_s *)qword_101934638;
    if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "Switching to GPS leech, rhythmic waking mode",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10183F5D8);
      }
      v8[0] = 0;
      LODWORD(v7) = 2;
      int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  1LL,  "Switching to GPS leech, rhythmic waking mode",  v8,  v7);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLOdometerNotifierWatch::enableGPS()", "%s\n", v6);
    }

    [*(id *)(a1 + 1136) releaseAccuracyEnablementAssertionForClient:CLISP_ME_TOKEN];
    [*(id *)(*(void *)(a1 + 3888) + 16) unregister:*(void *)(*(void *)(a1 + 3888) + 8) forNotification:0];
    [*(id *)(*(void *)(a1 + 3888) + 16) register:*(void *)(*(void *)(a1 + 3888) + 8) forNotification:5 registrationInfo:0];
    [*(id *)(*(void *)(a1 + 3912) + 16) register:*(void *)(*(void *)(a1 + 3912) + 8) forNotification:23 registrationInfo:0];
    sub_1008B192C(a1 + 1176, 1);
  }

  else
  {
    [*(id *)(*(void *)(a1 + 3888) + 16) unregister:*(void *)(*(void *)(a1 + 3888) + 8) forNotification:5];
    [*(id *)(*(void *)(a1 + 3912) + 16) unregister:*(void *)(*(void *)(a1 + 3912) + 8) forNotification:23];
    [*(id *)(*(void *)(a1 + 3888) + 16) register:*(void *)(*(void *)(a1 + 3888) + 8) forNotification:0 registrationInfo:0];
    sub_1008B192C(a1 + 1176, -1);
    [*(id *)(a1 + 1136) takeAccuracyEnablementAssertionForClient:CLISP_ME_TOKEN withDesiredAccuracy:-1.0];
  }

  *(_BYTE *)(a1 + 1129) = 1;
}

_BYTE *sub_1005383B0(_BYTE *result)
{
  if (result[1129])
  {
    uint64_t v1 = result;
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    uint64_t v2 = (os_log_s *)qword_101934638;
    if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Disable GPS; Stop GPS subscription", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10183F5D8);
      }
      v5[0] = 0;
      int v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  1LL,  "Disable GPS; Stop GPS subscription",
                     v5,
                     2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLOdometerNotifierWatch::disableGPS()", "%s\n", v4);
    }

    [*(id *)(*((void *)v1 + 486) + 16) unregister:*(void *)(*((void *)v1 + 486) + 8) forNotification:0];
    [*(id *)(*((void *)v1 + 486) + 16) unregister:*(void *)(*((void *)v1 + 486) + 8) forNotification:5];
    [*(id *)(*((void *)v1 + 489) + 16) unregister:*(void *)(*((void *)v1 + 489) + 8) forNotification:23];
    sub_1008B192C((uint64_t)(v1 + 1176), -1);
    uint64_t result = [*((id *)v1 + 142) releaseAccuracyEnablementAssertionForClient:CLISP_ME_TOKEN];
    uint64_t v3 = *((void *)v1 + 490);
    if (v3) {
      uint64_t result = [*(id *)(v3 + 16) unregister:*(void *)(v3 + 8) forNotification:41];
    }
    v1[1129] = 0;
    v1[1145] = 0;
  }

  return result;
}

void sub_1005385B4(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10183F598);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLOdometerNotifierWatch::onLocationNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10183F598);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLOdometerNotifierWatch::onLocationNotification, event:%{public, location:escape_on ly}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100539388((unsigned __int8 *)a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10053876C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10053878C(uint64_t a1, _DWORD *a2, int *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10183F598);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLOdometerNotifierWatch::onSignalEnvironmentNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10183F598);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLOdometerNotifierWatch::onSignalEnvironmentNotification, event:%{public, location: escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10053A8EC(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100538944( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100538964(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10183F598);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLOdometerNotifierWatch::onRhythmicGnssModeOfOperationStatusNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10183F598);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLOdometerNotifierWatch::onRhythmicGnssModeOfOperationStatusNotification, event:%{p ublic, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10053AC70((unsigned __int8 *)a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100538B1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100538B3C(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  int v6 = *a3;
  if (*a3 == 8)
  {
    *(_DWORD *)buf = 5;
    if (!sub_100247620(a1, (int *)buf, 1LL)
      || *(_BYTE *)(a1 + 3977) && (sub_1004F97F4() & 0x1000000000LL) != 0)
    {
      *(_DWORD *)buf = 5;
      [*(id *)(*(void *)(a1 + 1168) + 16) unregister:*(void *)(*(void *)(a1 + 1168) + 8) forNotification:sub_10039FE8C(buf)];
    }

    else
    {
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      __int128 v35 = 0u;
      __int128 v36 = 0u;
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v29 = 0u;
      __int128 v30 = 0u;
      __int128 v28 = 0u;
      *(void *)buf = sub_100539078(a1 + 3752, a4);
      uint64_t v27 = v12;
      LODWORD(v23[0]) = 5;
      (*(void (**)(uint64_t, _OWORD *, uint8_t *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  v23,  buf,  0LL,  0xFFFFFFFFLL,  0LL);
      int v13 = objc_autoreleasePoolPush();
      __int16 v14 = objc_alloc_init(&OBJC_CLASS___ALActivityLog);
      -[ALActivityLog setTimestamp:](v14, "setTimestamp:", *(double *)a4);
      -[ALActivityLog setCoarseElevation:]( v14,  "setCoarseElevation:",  objc_alloc_init(&OBJC_CLASS___ALCMCoarseElevation));
      -[ALCMCoarseElevation setElevationAscended:]( -[ALActivityLog coarseElevation](v14, "coarseElevation"),  "setElevationAscended:",  *(unsigned int *)(a4 + 8));
      -[ALCMCoarseElevation setSource:]( -[ALActivityLog coarseElevation](v14, "coarseElevation"),  "setSource:",  *(unsigned int *)(a4 + 12));
      objc_msgSend( -[CLServiceVendor proxyForService:]( +[CLServiceVendor sharedInstance](CLServiceVendor, "sharedInstance"),  "proxyForService:",  @"CLActivityLogger"),  "logData:",  v14);
      objc_autoreleasePoolPop(v13);
    }
  }

  else if (v6 == 6)
  {
    if (*(_BYTE *)a4) {
      BOOL v15 = *(_BYTE *)(a4 + 1) == 0;
    }
    else {
      BOOL v15 = 1;
    }
    int v16 = !v15;
    int v17 = *(unsigned __int8 *)(a4 + 16);
    if (*(_BYTE *)(a4 + 16)) {
      int v18 = v16;
    }
    else {
      int v18 = 0;
    }
    if (*(unsigned __int8 *)(a1 + 1130) != v18)
    {
      *(_BYTE *)(a1 + 1130) = v18;
      sub_100537838(a1);
    }

    sub_100E59058(a1 + 1368, v16, v17 != 0);
  }

  else if (v6 == 4)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    double v8 = Current;
    if (*(_BYTE *)(a1 + 1444))
    {
      __int128 v9 = *(_OWORD *)(a4 + 16);
      v24[0] = *(_OWORD *)a4;
      v24[1] = v9;
      __int128 v10 = *(_OWORD *)(a4 + 48);
      v24[2] = *(_OWORD *)(a4 + 32);
      v24[3] = v10;
      sub_100E57E44(a1 + 1368, (uint64_t)v24, (uint64_t)v25);
      v23[0] = v25[0];
      v23[1] = v25[1];
      v23[2] = v25[2];
      v23[3] = v25[3];
      if (v8 - *(double *)(a1 + 1152) > 15.0)
      {
        if (qword_1019345B0 != -1) {
          dispatch_once(&qword_1019345B0, &stru_10183F5B8);
        }
        char v11 = (os_log_s *)qword_1019345B8;
        if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "watch:notifying elevation entry from phone",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345B0 != -1) {
            dispatch_once(&qword_1019345B0, &stru_10183F5B8);
          }
          v22[0] = 0;
          int v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "watch:notifying elevation entry from phone",  v22,  2);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOdometerNotifierWatch::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, c onst CLCompanionNotifier_Type::NotificationData &)",  "%s\n",  v20);
        }

        *(double *)(a1 + 1152) = v8;
      }

      *(_DWORD *)buf = 7;
      (*(void (**)(uint64_t, uint8_t *, _OWORD *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  buf,  v23,  0LL,  0xFFFFFFFFLL,  0LL);
    }

    else if (Current - *(double *)(a1 + 1152) > 15.0)
    {
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_10183F5B8);
      }
      uint64_t v19 = (os_log_s *)qword_1019345B8;
      if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "elevation update from phone, source unavailable",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345B0 != -1) {
          dispatch_once(&qword_1019345B0, &stru_10183F5B8);
        }
        LOWORD(v23[0]) = 0;
        __int16 v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "elevation update from phone, source unavailable",  v23,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOdometerNotifierWatch::onCompanionNotification(int, const CLCompanionNotifier_Type::Notification &, con st CLCompanionNotifier_Type::NotificationData &)",  "%s\n",  v21);
      }

      *(double *)(a1 + 1152) = v8;
    }
  }

uint64_t sub_100539078(uint64_t a1, uint64_t a2)
{
  double v4 = *(double *)a2;
  double v5 = *(double *)(a1 + 32);
  int v6 = *(_DWORD *)(a2 + 12);
  uint64_t v7 = a1 + 16;
  if (!v6) {
    uint64_t v7 = a1;
  }
  int v8 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(v7 + 8);
  if (v8 < 0) {
    int v8 = *(_DWORD *)(v7 + 8) - *(_DWORD *)(a2 + 8);
  }
  if (v6 == *(_DWORD *)(a1 + 44))
  {
    int v9 = *(_DWORD *)(a1 + 40);
    BOOL v10 = v8 >= 0x12C;
    int v11 = 300;
  }

  else
  {
    if (v4 - *(double *)(a1 + 16LL * (v6 != 0)) <= 200.0)
    {
      unsigned int v12 = *(_DWORD *)(a1 + 40) + (fmin(v4 - v5, 180.0) * (double)v8 / 180.0);
      goto LABEL_17;
    }

    int v9 = *(_DWORD *)(a1 + 40);
    BOOL v10 = v8 >= 0xC8;
    int v11 = 200;
  }

  if (v10) {
    int v8 = v11;
  }
  unsigned int v12 = v9 + v8;
LABEL_17:
  *(double *)(a1 + 32) = v4;
  *(_DWORD *)(a1 + 40) = v12;
  *(_DWORD *)(a1 + 44) = v6;
LABEL_18:
  if (*(_DWORD *)(a2 + 12)) {
    int v13 = (_OWORD *)(a1 + 16);
  }
  else {
    int v13 = (_OWORD *)a1;
  }
  _OWORD *v13 = *(_OWORD *)a2;
  sub_1004F2598();
  if (sub_1004F8A40())
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_10183F5B8);
    }
    __int16 v14 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
    {
      double v15 = *(double *)a2;
      int v16 = *(_DWORD *)(a2 + 8);
      int v17 = *(_DWORD *)(a2 + 12);
      uint64_t v18 = *(void *)(a1 + 32);
      int v19 = *(_DWORD *)(a1 + 40);
      int v20 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)buf = 134219264;
      double v42 = v15;
      __int16 v43 = 1024;
      int v44 = v16;
      __int16 v45 = 1024;
      int v46 = v17;
      __int16 v47 = 2048;
      uint64_t v48 = v18;
      __int16 v49 = 1024;
      int v50 = v19;
      __int16 v51 = 1024;
      int v52 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "onCoarseElevation,startTime,%.3f,ascended,%d,source,%d,fused,startTime,%.3f,ascended,%d,source,%d",  buf,  0x2Eu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_10183F5B8);
      }
      double v22 = *(double *)a2;
      int v23 = *(_DWORD *)(a2 + 8);
      int v24 = *(_DWORD *)(a2 + 12);
      uint64_t v25 = *(void *)(a1 + 32);
      int v26 = *(_DWORD *)(a1 + 40);
      int v27 = *(_DWORD *)(a1 + 44);
      int v29 = 134219264;
      double v30 = v22;
      __int16 v31 = 1024;
      int v32 = v23;
      __int16 v33 = 1024;
      int v34 = v24;
      __int16 v35 = 2048;
      uint64_t v36 = v25;
      __int16 v37 = 1024;
      int v38 = v26;
      __int16 v39 = 1024;
      int v40 = v27;
      __int128 v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "onCoarseElevation,startTime,%.3f,ascended,%d,source,%d,fused,startTime,%.3f,ascended,%d,source,%d",  COERCE_DOUBLE(&v29),  46);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCoarseElevationChangeEntry CLCoarseElevationFusion::feedSample(const CLCoarseElevationChangeEntry &)",  "%s\n",  v28);
    }
  }

  return *(void *)(a1 + 32);
}

void sub_100539388(unsigned __int8 *a1, uint64_t a2, int *a3, uint64_t a4)
{
  int v7 = *a3;
  if (*a3 > 13)
  {
    if (v7 == 14)
    {
      int v16 = sub_10027E878((uint64_t)a1);
      sub_100536B90(a1, v16);
      return;
    }

    if (v7 != 23)
    {
LABEL_30:
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10183F5D8);
      }
      int v17 = (os_log_s *)qword_101934638;
      if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_ERROR))
      {
        int v18 = *a3;
        *(_DWORD *)buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "#Warning Received unhandled location provider notification, %{public}d",  buf,  8u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934630 != -1) {
          dispatch_once(&qword_101934630, &stru_10183F5D8);
        }
        int v19 = *a3;
        int v24 = 67240192;
        LODWORD(v25) = v19;
        int v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  16LL,  "#Warning Received unhandled location provider notification, %{public}d",  &v24,  8);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLOdometerNotifierWatch::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)",  "%s\n",  v20);
      }

      return;
    }

    int v8 = 2;
  }

  else
  {
    if (v7)
    {
      if (v7 == 5)
      {
        if (a1[1147])
        {
          __int128 v36 = 0u;
          __int128 v37 = 0u;
          __int128 v34 = 0u;
          __int128 v35 = 0u;
          __int128 v32 = 0u;
          __int128 v33 = 0u;
          __int128 v30 = 0u;
          __int128 v31 = 0u;
          __int128 v28 = 0u;
          __int128 v29 = 0u;
          *(_OWORD *)buf = 0u;
          __int128 v27 = 0u;
          *(_DWORD *)buf = 1;
          int v24 = 9;
          (*(void (**)(unsigned __int8 *, int *, uint8_t *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v24,  buf,  0LL,  0xFFFFFFFFLL,  0LL);
        }

        return;
      }

      goto LABEL_30;
    }

    int v8 = 1;
  }

  int v9 = *(int **)(a4 + 800);
  if (v9 && (unint64_t)sub_100CBED60(v9) >= 2)
  {
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    BOOL v10 = (os_log_s *)qword_101934638;
    if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = sub_100CBED60(*(int **)(a4 + 800));
      *(_DWORD *)buf = 134349056;
      *(void *)&uint8_t buf[4] = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "Location batch notification size %{public}ld",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10183F5D8);
      }
      uint64_t v21 = qword_101934638;
      uint64_t v22 = sub_100CBED60(*(int **)(a4 + 800));
      int v24 = 134349056;
      uint64_t v25 = v22;
      int v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  2LL,  "Location batch notification size %{public}ld",  &v24,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOdometerNotifierWatch::onLocationNotification(int, const CLLocationProvider_Type::Notification &, const C LLocationProvider_Type::NotificationData &)",  "%s\n",  v23);
    }

    if (sub_100CBED60(*(int **)(a4 + 800)))
    {
      unint64_t v12 = 0LL;
      do
      {
        sub_100CBE5DC(*(void *)(a4 + 800), v12, (uint64_t)&v24);
        sub_100CBEAEC(*(void *)(a4 + 800), v12, (uint64_t)buf);
        sub_1005398A8((uint64_t)a1, (uint64_t)&v24, (uint64_t)buf);
        int v13 = v38;
        if (v38)
        {
          p_shared_owners = (unint64_t *)&v38->__shared_owners_;
          do
            unint64_t v15 = __ldaxr(p_shared_owners);
          while (__stlxr(v15 - 1, p_shared_owners));
          if (!v15)
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }

        ++v12;
      }

      while (v12 < sub_100CBED60(*(int **)(a4 + 800)));
    }
  }

  else
  {
    sub_1005398A8((uint64_t)a1, a4, a4 + 160);
  }

  if (a1[1147])
  {
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    *(_OWORD *)buf = 0u;
    __int128 v27 = 0u;
    *(_DWORD *)buf = v8;
    int v24 = 9;
    (*(void (**)(unsigned __int8 *, int *, uint8_t *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v24,  buf,  0LL,  0xFFFFFFFFLL,  0LL);
  }

void sub_100539888(_Unwind_Exception *a1)
{
}

void sub_1005398A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (__int128 *)(a3 + 360);
  if (sub_10081C7A0())
  {
    uint64_t v7 = sub_10081C7A0();
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    uint64_t v9 = *(void *)(a3 + 24);
    *(CFAbsoluteTime *)v76 = Current;
    *((void *)&v76[0] + 1) = v9;
    v76[1] = *(_OWORD *)(a2 + 4);
    uint64_t v77 = *(void *)(a2 + 20);
    __int128 v10 = *v6;
    __int128 v78 = v6[1];
    char v79 = 0;
    __int128 v80 = v10;
    char v81 = 0;
    sub_10081C864(v7, v76);
  }

  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_10183F5B8);
  }
  uint64_t v11 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEBUG))
  {
    int v12 = *(_DWORD *)(a3 + 352);
    *(_DWORD *)buf = 68289283;
    *(_DWORD *)v131 = 0;
    *(_WORD *)&v131[4] = 2082;
    *(void *)&v131[6] = "";
    *(_WORD *)&v131[14] = 1025;
    *(_DWORD *)&v131[16] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLElevationAWDAggregator, Origin Device:%{private}d}",  buf,  0x18u);
  }

  if (sub_100F5A080())
  {
    uint64_t v13 = sub_100F5A080();
    sub_100F5DA24(v13, *(double *)(a2 + 4), *(double *)(a2 + 12), *(double *)(a3 + 376), *(double *)(a3 + 384));
  }

  if ((*(_DWORD *)(a2 + 96) | 2) != 3) {
    goto LABEL_15;
  }
  double v14 = *(double *)a3;
  if (*(_BYTE *)(a1 + 1145))
  {
    double v15 = *(double *)(a3 + 8);
    if (v15 < 0.0 || (double v16 = *(double *)(a3 + 16), v16 < 0.0))
    {
LABEL_15:
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10183F5D8);
      }
      int v17 = (os_log_s *)qword_101934638;
      if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = *(void *)(a2 + 76);
        uint64_t v19 = *(void *)(a2 + 28);
        double v21 = *(double *)a3;
        uint64_t v20 = *(void *)(a3 + 8);
        uint64_t v22 = *(void *)(a2 + 44);
        uint64_t v23 = *(void *)(a2 + 52);
        double v24 = *(double *)(a3 + 16);
        uint64_t v25 = *(void *)(a3 + 24);
        int v26 = *(_DWORD *)(a3 + 352);
        int v27 = *(_DWORD *)(a2 + 96);
        int v28 = *(_DWORD *)(a3 + 616);
        *(_DWORD *)buf = 134286337;
        *(void *)v131 = v20;
        *(_WORD *)&v131[8] = 2050;
        *(void *)&v131[10] = v18;
        *(_WORD *)&v131[18] = 2049;
        uint64_t v132 = v19;
        __int16 v133 = 2049;
        double v134 = v21;
        __int16 v135 = 2050;
        double v136 = v24;
        __int16 v137 = 2049;
        uint64_t v138 = v22;
        __int16 v139 = 2050;
        uint64_t v140 = v23;
        __int16 v141 = 2050;
        uint64_t v142 = v25;
        __int16 v143 = 2049;
        uint64_t v144 = v22;
        __int16 v145 = 1026;
        *(_DWORD *)v146 = v26;
        *(_WORD *)&v146[4] = 1026;
        *(_DWORD *)&v146[6] = v27;
        *(_WORD *)v147 = 1026;
        *(_DWORD *)&v147[2] = v28;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Drop entry! distance, %{private}.8f, startTime, %{public}.8f, gps altitude, %{private}.8f, odometer, %{private }.8f, accuracy, %{public}.8f, gpsSpeed, %{private}.8f, gpsSpeedAccuracy, %{public}.8f, timestampGps, %{public} .8f, rawSpeed, %{private}.8f, originDevice, %{public}d, locationType, %{public}d, batchedLocationFixType, %{public}d",  buf,  0x6Eu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934630 != -1) {
          dispatch_once(&qword_101934630, &stru_10183F5D8);
        }
        uint64_t v40 = *(void *)(a2 + 76);
        uint64_t v41 = *(void *)(a2 + 28);
        double v43 = *(double *)a3;
        uint64_t v42 = *(void *)(a3 + 8);
        uint64_t v44 = *(void *)(a2 + 44);
        uint64_t v45 = *(void *)(a2 + 52);
        double v46 = *(double *)(a3 + 16);
        uint64_t v47 = *(void *)(a3 + 24);
        int v48 = *(_DWORD *)(a3 + 352);
        int v49 = *(_DWORD *)(a2 + 96);
        int v50 = *(_DWORD *)(a3 + 616);
        int v82 = 134286337;
        uint64_t v83 = v42;
        __int16 v84 = 2050;
        uint64_t v85 = v40;
        __int16 v86 = 2049;
        uint64_t v87 = v41;
        __int16 v88 = 2049;
        double v89 = v43;
        __int16 v90 = 2050;
        double v91 = v46;
        __int16 v92 = 2049;
        uint64_t v93 = v44;
        __int16 v94 = 2050;
        uint64_t v95 = v45;
        __int16 v96 = 2050;
        uint64_t v97 = v47;
        __int16 v98 = 2049;
        uint64_t v99 = v44;
        __int16 v100 = 1026;
        *(_DWORD *)v101 = v48;
        *(_WORD *)&v101[4] = 1026;
        *(_DWORD *)&v101[6] = v49;
        *(_WORD *)v102 = 1026;
        *(_DWORD *)&v102[2] = v50;
        __int16 v51 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  0LL,  "Drop entry! distance, %{private}.8f, startTime, %{public}.8f, gps altitude, %{private}.8f, odome ter, %{private}.8f, accuracy, %{public}.8f, gpsSpeed, %{private}.8f, gpsSpeedAccuracy, %{public} .8f, timestampGps, %{public}.8f, rawSpeed, %{private}.8f, originDevice, %{public}d, locationType , %{public}d, batchedLocationFixType, %{public}d",  &v82,  110);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOdometerNotifierWatch::notifyLocation(const CLDaemonLocation &, const CLDaemonLocationPrivate &)",  "%s\n",  v51);
      }

      return;
    }
  }

  else
  {
    *(_BYTE *)(a1 + 1145) = 1;
    double v15 = *(double *)(a3 + 8);
    double v16 = *(double *)(a3 + 16);
  }

  *(void *)&__int128 v54 = *(void *)(a2 + 76);
  *((double *)&v54 + 1) = v15;
  uint64_t v29 = *(void *)(a2 + 28);
  double v55 = v16;
  uint64_t v56 = v29;
  uint64_t v57 = *(void *)(a2 + 44);
  uint64_t v58 = v57;
  uint64_t v30 = *(void *)(a2 + 52);
  double v59 = *(double *)a3;
  uint64_t v60 = v30;
  uint64_t v31 = *(void *)(a3 + 344);
  uint64_t v61 = *(void *)(a3 + 24);
  uint64_t v62 = v31;
  int v32 = *(_DWORD *)(a3 + 352);
  int v63 = 0;
  int v64 = v32;
  int v65 = *(_DWORD *)(a2 + 96);
  __int128 v33 = *(_OWORD *)(a3 + 496);
  __int128 v34 = *v6;
  __int128 v66 = v6[1];
  __int128 v67 = v33;
  uint64_t v35 = *(void *)(a2 + 68);
  double v68 = *(double *)(a2 + 60) * 0.0174532924;
  uint64_t v69 = v35;
  __int128 v70 = v34;
  int v36 = *(_DWORD *)(a1 + 1160);
  int v71 = *(_DWORD *)(a3 + 616);
  int v72 = v36;
  unsigned __int8 v73 = *(_BYTE *)(a3 + 288);
  int v74 = *(_DWORD *)(a3 + 276);
  uint64_t v75 = *(void *)(a3 + 280);
  double v37 = CFAbsoluteTimeGetCurrent();
  if (sub_10053A164(a1 + 928, (double *)(a1 + 1120), &v54, v37))
  {
    sub_10027EA48(a1, (uint64_t)&v54);
    uint64_t v57 = v38;
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    __int16 v39 = (os_log_s *)qword_101934638;
    if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v53 = v75;
      *(_DWORD *)buf = 134289665;
      *(void *)v131 = *((void *)&v54 + 1);
      *(_WORD *)&v131[8] = 2050;
      *(void *)&v131[10] = v54;
      *(_WORD *)&v131[18] = 2049;
      uint64_t v132 = v56;
      __int16 v133 = 2049;
      double v134 = v59;
      __int16 v135 = 2050;
      double v136 = v55;
      __int16 v137 = 2049;
      uint64_t v138 = v57;
      __int16 v139 = 2050;
      uint64_t v140 = v60;
      __int16 v141 = 2050;
      uint64_t v142 = v61;
      __int16 v143 = 2050;
      uint64_t v144 = v62;
      __int16 v145 = 2049;
      *(void *)v146 = v58;
      *(_WORD *)&v146[8] = 1026;
      *(_DWORD *)v147 = v64;
      *(_WORD *)&v147[4] = 1026;
      int v148 = v65;
      __int16 v149 = 2049;
      uint64_t v150 = v66;
      __int16 v151 = 2050;
      uint64_t v152 = *((void *)&v66 + 1);
      __int16 v153 = 2049;
      uint64_t v154 = v67;
      __int16 v155 = 2050;
      uint64_t v156 = *((void *)&v67 + 1);
      __int16 v157 = 2049;
      double v158 = v68;
      __int16 v159 = 2050;
      uint64_t v160 = v69;
      __int16 v161 = 2049;
      uint64_t v162 = v70;
      __int16 v163 = 2049;
      uint64_t v164 = *((void *)&v70 + 1);
      __int16 v165 = 1024;
      int v166 = v71;
      __int16 v167 = 1026;
      int v168 = v72;
      __int16 v169 = 1026;
      int v170 = v73;
      __int16 v171 = 1025;
      int v172 = v74;
      __int16 v173 = 2049;
      uint64_t v174 = v75;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Notifying odometer clients, distance, %{private}.8f, startTime, %{public}.8f, gps altitude, %{private}.8f, odome ter, %{private}.8f, accuracy, %{public}.8f, gpsSpeed, %{private}.8f, gpsSpeedAccuracy, %{public}.8f, timestampGp s, %{public}.8f, machContinuousTime, %{public}.8f, rawSpeed, %{private}.8f, originDevice, %{public}d, locationTy pe, %{public}d, groundAltitude, %{private}.8f, groundAltitudeUncertainty, %{public}.8f, smoothedGPSAltitude, %{p rivate}.8f, smoothedGPSAltitudeUncertainty, %{public}.8f, gpsCourseRadians, %{private}.8f, gpsCourseAccuracy, %{ public}.8f, slope, %{private}.4f, maxAbsSlope, %{private}.4f, batchedLocationFixType, %d, signalEnv, %{public}d, trackRunOdometerHasBeenCorrected, %{public}d, trackProximity, %{private}d, distanceToTrackMeters, %{private}.1f",  buf,  0xE4u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10183F5D8);
      }
      int v82 = 134289665;
      uint64_t v83 = *((void *)&v54 + 1);
      __int16 v84 = 2050;
      uint64_t v85 = v54;
      __int16 v86 = 2049;
      uint64_t v87 = v56;
      __int16 v88 = 2049;
      double v89 = v59;
      __int16 v90 = 2050;
      double v91 = v55;
      __int16 v92 = 2049;
      uint64_t v93 = v57;
      __int16 v94 = 2050;
      uint64_t v95 = v60;
      __int16 v96 = 2050;
      uint64_t v97 = v61;
      __int16 v98 = 2050;
      uint64_t v99 = v62;
      __int16 v100 = 2049;
      *(void *)v101 = v58;
      *(_WORD *)&v101[8] = 1026;
      *(_DWORD *)v102 = v64;
      *(_WORD *)&v102[4] = 1026;
      int v103 = v65;
      __int16 v104 = 2049;
      uint64_t v105 = v66;
      __int16 v106 = 2050;
      uint64_t v107 = *((void *)&v66 + 1);
      __int16 v108 = 2049;
      uint64_t v109 = v67;
      __int16 v110 = 2050;
      uint64_t v111 = *((void *)&v67 + 1);
      __int16 v112 = 2049;
      double v113 = v68;
      __int16 v114 = 2050;
      uint64_t v115 = v69;
      __int16 v116 = 2049;
      uint64_t v117 = v70;
      __int16 v118 = 2049;
      uint64_t v119 = *((void *)&v70 + 1);
      __int16 v120 = 1024;
      int v121 = v71;
      __int16 v122 = 1026;
      int v123 = v72;
      __int16 v124 = 1026;
      int v125 = v73;
      __int16 v126 = 1025;
      int v127 = v74;
      __int16 v128 = 2049;
      uint64_t v129 = v75;
      int v52 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  0LL,  "Notifying odometer clients, distance, %{private}.8f, startTime, %{public}.8f, gps altitude, %{priv ate}.8f, odometer, %{private}.8f, accuracy, %{public}.8f, gpsSpeed, %{private}.8f, gpsSpeedAccurac y, %{public}.8f, timestampGps, %{public}.8f, machContinuousTime, %{public}.8f, rawSpeed, %{private }.8f, originDevice, %{public}d, locationType, %{public}d, groundAltitude, %{private}.8f, groundAlt itudeUncertainty, %{public}.8f, smoothedGPSAltitude, %{private}.8f, smoothedGPSAltitudeUncertainty , %{public}.8f, gpsCourseRadians, %{private}.8f, gpsCourseAccuracy, %{public}.8f, slope, %{private }.4f, maxAbsSlope, %{private}.4f, batchedLocationFixType, %d, signalEnv, %{public}d, trackRunOdome terHasBeenCorrected, %{public}d, trackProximity, %{private}d, distanceToTrackMeters, %{private}.1f",  &v82,  228,  v53);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOdometerNotifierWatch::notifyLocation(const CLDaemonLocation &, const CLDaemonLocationPrivate &)",  "%s\n",  v52);
    }

    sub_100E59310(a1 + 1368, (uint64_t)&v54);
    *(_DWORD *)buf = 4;
    (*(void (**)(uint64_t, uint8_t *, __int128 *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  buf,  &v54,  0LL,  0xFFFFFFFFLL,  0LL);
    sub_100A87BAC(a1 + 3800, &v54);
  }

BOOL sub_10053A164(uint64_t a1, double *a2, __int128 *a3, double a4)
{
  if (qword_101934630 != -1) {
    dispatch_once(&qword_101934630, &stru_10183F5D8);
  }
  int v8 = (os_log_s *)qword_101934638;
  if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_INFO))
  {
    uint64_t v9 = *((void *)a3 + 6);
    *(_DWORD *)buf = 134283521;
    uint64_t v70 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Incoming odometer, %{private}.8f", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    uint64_t v59 = *((void *)a3 + 6);
    *(_DWORD *)__int128 v67 = 134283521;
    *(void *)&v67[4] = v59;
    uint64_t v60 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  1LL,  "Incoming odometer, %{private}.8f",  v67,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLOdometerNotifierWatch::updateOdometerWithEntry(CLOdometerEntry &, double &, CLOdometerEntry &, CFAbsoluteTime)",  "%s\n",  v60);
  }

  double v10 = *(double *)(a1 + 64);
  else {
    double v12 = v11 - v10;
  }
  if (v12 > 0.0 && *(double *)a3 + 15.0 >= a4)
  {
    if (*((_DWORD *)a3 + 21) == *(_DWORD *)(a1 + 84) && *((_DWORD *)a3 + 22) == *(_DWORD *)(a1 + 88))
    {
      double v28 = *((double *)a3 + 6);
      double v29 = *(double *)(a1 + 48);
      if (v28 >= v29)
      {
        double v37 = v28 - v29;
LABEL_38:
        __int128 v50 = *a3;
        __int128 v51 = a3[1];
        __int128 v52 = a3[3];
        *(_OWORD *)(a1 + 32) = a3[2];
        *(_OWORD *)(a1 + 48) = v52;
        *(_OWORD *)a1 = v50;
        *(_OWORD *)(a1 + 16) = v51;
        __int128 v53 = a3[4];
        __int128 v54 = a3[5];
        __int128 v55 = a3[7];
        *(_OWORD *)(a1 + 96) = a3[6];
        *(_OWORD *)(a1 + 112) = v55;
        *(_OWORD *)(a1 + 64) = v53;
        *(_OWORD *)(a1 + 80) = v54;
        __int128 v56 = a3[8];
        __int128 v57 = a3[9];
        __int128 v58 = a3[11];
        *(_OWORD *)(a1 + 160) = a3[10];
        *(_OWORD *)(a1 + 176) = v58;
        *(_OWORD *)(a1 + 128) = v56;
        *(_OWORD *)(a1 + 144) = v57;
        *a2 = v37 + *a2;
        *((double *)a3 + 1) = v37;
        *((double *)a3 + 6) = *a2;
        return 1LL;
      }

      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10183F5D8);
      }
      uint64_t v30 = (os_log_s *)qword_101934638;
      if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = *(void *)(a1 + 64);
        uint64_t v32 = *((void *)a3 + 8);
        double v33 = *(double *)a1;
        double v34 = *(double *)a3;
        uint64_t v35 = *(void *)(a1 + 48);
        uint64_t v36 = *((void *)a3 + 6);
        *(_DWORD *)buf = 134350337;
        uint64_t v70 = v31;
        __int16 v71 = 2050;
        uint64_t v72 = v32;
        __int16 v73 = 2050;
        *(double *)int v74 = v33;
        *(_WORD *)&v74[8] = 2050;
        double v75 = v34;
        __int16 v76 = 2049;
        uint64_t v77 = v35;
        __int16 v78 = 2049;
        uint64_t v79 = v36;
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Source may have reset. Gps,%{public}.2lf,%{public}.2lf,startTime,%{public}.2lf,%{public}.2lf,odometer,%{privat e}.2lf,%{private}.2lf",  buf,  0x3Eu);
      }

      double v37 = 0.0;
      if (!sub_1002921D0(115, 2)) {
        goto LABEL_38;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10183F5D8);
      }
      uint64_t v38 = *(void *)(a1 + 64);
      uint64_t v39 = *((void *)a3 + 8);
      double v40 = *(double *)a1;
      double v41 = *(double *)a3;
      uint64_t v42 = *(void *)(a1 + 48);
      uint64_t v43 = *((void *)a3 + 6);
      *(_DWORD *)__int128 v67 = 134350337;
      *(void *)&v67[4] = v38;
      *(_WORD *)&v67[12] = 2050;
      *(void *)&v67[14] = v39;
      *(_WORD *)&v67[22] = 2050;
      *(_WORD *)&v68[8] = 2050;
      *(double *)&v68[10] = v41;
      *(_WORD *)&v68[18] = 2049;
      *(void *)&v68[20] = v42;
      *(_WORD *)&v68[28] = 2049;
      *(void *)&v68[30] = v43;
      LODWORD(v66) = 62;
      uint64_t v44 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  0LL,  "Source may have reset. Gps,%{public}.2lf,%{public}.2lf,startTime,%{public}.2lf,%{public}.2lf ,odometer,%{private}.2lf,%{private}.2lf",  v67,  v66,  *(_OWORD *)v67,  *(void *)&v67[16],  *(void *)&v40,  *(_OWORD *)&v68[8],  *(_OWORD *)&v68[24]);
    }

    else
    {
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10183F5D8);
      }
      uint64_t v45 = (os_log_s *)qword_101934638;
      if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v46 = *(void *)(a1 + 48);
        uint64_t v47 = *((void *)a3 + 6);
        int v48 = *(_DWORD *)(a1 + 88);
        int v49 = *((_DWORD *)a3 + 22);
        *(_DWORD *)buf = 134284289;
        uint64_t v70 = v46;
        __int16 v71 = 2049;
        uint64_t v72 = v47;
        __int16 v73 = 1026;
        *(_DWORD *)int v74 = v48;
        *(_WORD *)&v74[4] = 1026;
        *(_DWORD *)&v74[6] = v49;
        _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Odometer source change,previous,%{private}lf,current,%{private}lf,previousType,%{public}d,type,%{public}d",  buf,  0x22u);
      }

      double v37 = 0.0;
      if (!sub_1002921D0(115, 2)) {
        goto LABEL_38;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10183F5D8);
      }
      uint64_t v61 = *(void *)(a1 + 48);
      uint64_t v62 = *((void *)a3 + 6);
      int v63 = *(_DWORD *)(a1 + 88);
      int v64 = *((_DWORD *)a3 + 22);
      *(_DWORD *)__int128 v67 = 134284289;
      *(void *)&v67[4] = v61;
      *(_WORD *)&v67[12] = 2049;
      *(void *)&v67[14] = v62;
      *(_WORD *)&v67[22] = 1026;
      *(_DWORD *)double v68 = v63;
      *(_WORD *)&v68[4] = 1026;
      *(_DWORD *)&v68[6] = v64;
      LODWORD(v66) = 34;
      uint64_t v44 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  0LL,  "Odometer source change,previous,%{private}lf,current,%{private}lf,previousType,%{public}d,type,%{public}d",  v67,  v66,  *(_OWORD *)v67,  *(void *)&v67[16],  *(void *)v68,  *(_OWORD *)&v68[8],  *(_OWORD *)&v68[24]);
    }

    int v65 = (uint8_t *)v44;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLOdometerNotifierWatch::updateOdometerWithEntry(CLOdometerEntry &, double &, CLOdometerEntry &, CFAbsoluteTime)",  "%s\n",  v44);
    if (v65 != buf) {
      free(v65);
    }
    goto LABEL_38;
  }

  if (qword_101934630 != -1) {
    dispatch_once(&qword_101934630, &stru_10183F5D8);
  }
  uint64_t v13 = (os_log_s *)qword_101934638;
  if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(void *)(a1 + 64);
    uint64_t v15 = *((void *)a3 + 8);
    double v16 = *(double *)a1;
    double v17 = *(double *)a3;
    uint64_t v18 = *(void *)(a1 + 48);
    uint64_t v19 = *((void *)a3 + 6);
    *(_DWORD *)buf = 134350337;
    uint64_t v70 = v14;
    __int16 v71 = 2050;
    uint64_t v72 = v15;
    __int16 v73 = 2050;
    *(double *)int v74 = v16;
    *(_WORD *)&v74[8] = 2050;
    double v75 = v17;
    __int16 v76 = 2049;
    uint64_t v77 = v18;
    __int16 v78 = 2049;
    uint64_t v79 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#Warning Current odometer sample fails time check. Gps,%{public}.2lf,%{public}.2lf,startTime,%{public}.2lf,%{publi c}.2lf,odometer,%{private}.2lf,%{private}.2lf",  buf,  0x3Eu);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    uint64_t v21 = *(void *)(a1 + 64);
    uint64_t v22 = *((void *)a3 + 8);
    double v23 = *(double *)a1;
    double v24 = *(double *)a3;
    uint64_t v25 = *(void *)(a1 + 48);
    uint64_t v26 = *((void *)a3 + 6);
    *(_DWORD *)__int128 v67 = 134350337;
    *(void *)&v67[4] = v21;
    *(_WORD *)&v67[12] = 2050;
    *(void *)&v67[14] = v22;
    *(_WORD *)&v67[22] = 2050;
    *(double *)double v68 = v23;
    *(_WORD *)&v68[8] = 2050;
    *(double *)&v68[10] = v24;
    *(_WORD *)&v68[18] = 2049;
    *(void *)&v68[20] = v25;
    *(_WORD *)&v68[28] = 2049;
    *(void *)&v68[30] = v26;
    LODWORD(v66) = 62;
    int v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  0LL,  "#Warning Current odometer sample fails time check. Gps,%{public}.2lf,%{public}.2lf,startTime,%{publi c}.2lf,%{public}.2lf,odometer,%{private}.2lf,%{private}.2lf",  v67,  v66);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLOdometerNotifierWatch::updateOdometerWithEntry(CLOdometerEntry &, double &, CLOdometerEntry &, CFAbsoluteTime)",  "%s\n",  v27);
    return 0LL;
  }

  return result;
}

void sub_10053A8EC(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  if (!*a3)
  {
    *(_DWORD *)(a1 + 1160) = *a4;
    if (sub_10081C7A0())
    {
      uint64_t v5 = sub_10081C7A0();
      sub_10081C7E4(v5, *a4);
    }
  }

uint64_t sub_10053A934(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 2)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(a4 + 16);
    if ((unint64_t)(v6 - 13) >= 2)
    {
      if (v6 == 15)
      {
        BOOL v7 = 0;
        *(_BYTE *)(result + 1144) = 0;
      }

      else
      {
        BOOL v7 = *(_BYTE *)(result + 1144) != 0;
      }
    }

    else
    {
      BOOL v7 = *(void *)(a4 + 224) == 1LL;
      *(_BYTE *)(result + 1144) = v7;
    }

    sub_100E59318(result + 1368, v7);
    sub_100A87C00(v5 + 3800, a4);
    return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 232LL))(v5);
  }

  return result;
}

uint64_t sub_10053A9D0(_BYTE *a1, char a2)
{
  a1[1131] = a2;
  return (*(uint64_t (**)(_BYTE *))(*(void *)a1 + 232LL))(a1);
}

uint64_t sub_10053A9E0(uint64_t a1, char a2)
{
  *(_BYTE *)(a1 + 211) = a2;
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 - 920) + 232LL))(a1 - 920);
}

void sub_10053A9F8(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = 0LL;
  double v16 = 0LL;
  uint64_t v17 = 0LL;
  sub_10053B280( &v15,  *(const void **)a2,  *(void *)(a2 + 8),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 6));
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  uint64_t v3 = *(void **)(a1 + 3880);
  id v4 = [v3 countByEnumeratingWithState:&v11 objects:v18 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v12;
    do
    {
      for (i = 0LL; i != v4; i = (char *)i + 1)
      {
        if (*(void *)v12 != v5) {
          objc_enumerationMutation(v3);
        }
        BOOL v7 = *(void **)(*((void *)&v11 + 1) + 8LL * (void)i);
        uint64_t v9 = 0LL;
        uint64_t v10 = 0LL;
        __p = 0LL;
        sub_10053B280(&__p, v15, (uint64_t)v16, 0xAAAAAAAAAAAAAAABLL * ((v16 - (_BYTE *)v15) >> 6));
        [v7 onCyclingDistanceUpdate:sub_10053ABAC((uint64_t)&__p)];
        if (__p)
        {
          uint64_t v9 = __p;
          operator delete(__p);
        }
      }

      id v4 = [v3 countByEnumeratingWithState:&v11 objects:v18 count:16];
    }

    while (v4);
  }

  if (v15)
  {
    double v16 = v15;
    operator delete(v15);
  }

void sub_10053AB68( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_10053ABAC(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3321888768LL;
  v3[2] = sub_10053B2F8;
  v3[3] = &unk_10183F7F8;
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  __p = 0LL;
  sub_10053B280( &__p,  *(const void **)a1,  *(void *)(a1 + 8),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 6));
  id v1 = [v3 copy];
  if (__p)
  {
    uint64_t v5 = __p;
    operator delete(__p);
  }

  return v1;
}

void sub_10053AC4C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10053AC68(uint64_t a1, uint64_t a2)
{
}

void sub_10053AC70(unsigned __int8 *a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 41)
  {
    __int128 v5 = *(_OWORD *)(a4 + 1464);
    __int128 v15 = *(_OWORD *)(a4 + 1448);
    __int128 v16 = v5;
    uint64_t v6 = a1[1146];
    v14[0] = v15;
    v14[1] = v5;
    BOOL v7 = sub_1011B42A0(v6, (uint64_t)v14);
    v13[0] = v15;
    v13[1] = v16;
    int v8 = sub_1011B42C4((uint64_t)v13);
    int v9 = sub_1011B42D0(v7, v8);
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10183F5D8);
    }
    uint64_t v10 = (os_log_s *)qword_101934638;
    if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67240704;
      *(_DWORD *)&uint8_t buf[4] = v7;
      *(_WORD *)&uint8_t buf[8] = 1026;
      *(_DWORD *)&buf[10] = v8;
      *(_WORD *)&buf[14] = 1026;
      LODWORD(v23) = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Received operation status, isRhythmicActive, %{public}d, is1HzGnssActive, %{public}d, inRhythmicMode, %{public}d",  buf,  0x14u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10183F5D8);
      }
      v17[0] = 67240704;
      v17[1] = v7;
      __int16 v18 = 1026;
      int v19 = v8;
      __int16 v20 = 1026;
      int v21 = v9;
      __int128 v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  0LL,  "Received operation status, isRhythmicActive, %{public}d, is1HzGnssActive, %{public}d, inRhythmicMode, %{public}d",  v17,  20);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOdometerNotifierWatch::onRhythmicGnssModeOfOperationStatusNotification(int, const CLLocationProvider_Type ::Notification &, const CLLocationProvider_Type::NotificationData &)",  "%s\n",  v12);
    }

    int v11 = a1[1147];
    a1[1147] = v9;
    if (!v11)
    {
      if (v9)
      {
        __int128 v32 = 0u;
        __int128 v33 = 0u;
        __int128 v30 = 0u;
        __int128 v31 = 0u;
        __int128 v28 = 0u;
        __int128 v29 = 0u;
        __int128 v26 = 0u;
        __int128 v27 = 0u;
        __int128 v24 = 0u;
        __int128 v25 = 0u;
        *(_OWORD *)buf = 0u;
        __int128 v23 = 0u;
        *(_DWORD *)buf = 3;
        v17[0] = 9;
        (*(void (**)(unsigned __int8 *, _DWORD *, uint8_t *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  v17,  buf,  0LL,  0xFFFFFFFFLL,  0LL);
      }
    }

    a1[1146] = v7;
  }

void sub_10053AEFC(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_10053AF28(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    id v4 = (void *)sub_100BD93EC();
    operator delete(v4);
  }

void sub_10053AF54(id a1)
{
  qword_1019345B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pressure");
}

void sub_10053AF80(id a1)
{
  qword_101934638 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Odometer");
}

void *sub_10053AFB4()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &off_10183F608;
  return result;
}

void sub_10053AFD8(uint64_t a1, void *a2)
{
  *a2 = &off_10183F608;
}

double sub_10053AFF0(uint64_t a1, double **a2)
{
  uint64_t v2 = *a2;
  double result = **a2;
  double v4 = 0.0;
  while (v2 != a2[1])
  {
    double v4 = v4 + v2[2];
    v2 += 3;
  }

  return result;
}

uint64_t sub_10053B01C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_10053B058()
{
}

void *sub_10053B06C()
{
  double result = operator new(0x10uLL);
  *double result = &off_10183F688;
  return result;
}

void sub_10053B090(uint64_t a1, void *a2)
{
  *a2 = &off_10183F688;
}

double sub_10053B0A8(uint64_t a1, double **a2)
{
  uint64_t v2 = a2[1];
  double result = **a2;
  double v4 = 0.0;
  if (*a2 != v2)
  {
    __int128 v5 = *a2;
    do
    {
      double v4 = v4 + v5[2];
      v5 += 3;
    }

    while (v5 != v2);
  }

  return result;
}

uint64_t sub_10053B0F8(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_10053B134()
{
}

void *sub_10053B148()
{
  double result = operator new(0x10uLL);
  *double result = &off_10183F708;
  return result;
}

void sub_10053B16C(uint64_t a1, void *a2)
{
  *a2 = &off_10183F708;
}

BOOL sub_10053B184(uint64_t a1, uint64_t a2)
{
  return *(double *)(a2 + 16) >= 0.0;
}

uint64_t sub_10053B194(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_10053B1D0()
{
}

void *sub_10053B1E4()
{
  double result = operator new(0x10uLL);
  *double result = &off_10183F788;
  return result;
}

void sub_10053B208(uint64_t a1, void *a2)
{
  *a2 = &off_10183F788;
}

BOOL sub_10053B220(uint64_t a1, uint64_t a2)
{
  return *(double *)(a2 + 16) > 2.22044605e-16;
}

uint64_t sub_10053B238(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_10053B274()
{
}

void *sub_10053B280(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    double result = sub_100149D9C(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      double result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_10053B2DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *sub_10053B2F8@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  return sub_10053B280( a2,  *(const void **)(a1 + 32),  *(void *)(a1 + 40),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 6));
}

void *sub_10053B320(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  uint64_t v2 = (void *)(a1 + 32);
  v2[2] = 0LL;
  return sub_10053B280( v2,  *(const void **)(a2 + 32),  *(void *)(a2 + 40),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 6));
}

void sub_10053B348(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }

void sub_10053B360()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_1012F0718;
      v1[3] = unk_1012F0728;
      v1[4] = xmmword_1012F0738;
      v1[0] = xmmword_1012F06F8;
      v1[1] = unk_1012F0708;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_10053B434(_Unwind_Exception *a1)
{
}

void sub_10053B44C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936068);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936068))
    {
      qword_101936050 = 0LL;
      *(void *)algn_101936058 = 0LL;
      qword_101936060 = 0LL;
      __cxa_atexit((void (*)(void *))sub_1001BA3E4, &qword_101936050, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936068);
    }
  }

void sub_10053B4B0()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936118);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936118))
    {
      std::__shared_mutex_base::__shared_mutex_base(&stru_101936070);
      __cxa_atexit((void (*)(void *))sub_1001BA414, &stru_101936070, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936118);
    }
  }

void sub_10053B524(_Unwind_Exception *a1)
{
}

uint64_t sub_10053B53C()
{
  qword_101996CC8 = (uint64_t)&off_10183F608;
  qword_101996CE0 = (uint64_t)&qword_101996CC8;
  __cxa_atexit((void (*)(void *))sub_10027C560, &qword_101996CC8, (void *)&_mh_execute_header);
  qword_101996CE8 = (uint64_t)&off_10183F688;
  qword_101996D00 = (uint64_t)&qword_101996CE8;
  __cxa_atexit((void (*)(void *))sub_10027C560, &qword_101996CE8, (void *)&_mh_execute_header);
  qword_101996D08 = (uint64_t)&off_10183F708;
  qword_101996D20 = (uint64_t)&qword_101996D08;
  __cxa_atexit((void (*)(void *))sub_10027C5AC, &qword_101996D08, (void *)&_mh_execute_header);
  qword_101996D28 = (uint64_t)&off_10183F788;
  qword_101996D40 = (uint64_t)&qword_101996D28;
  return __cxa_atexit((void (*)(void *))sub_10027C5AC, &qword_101996D28, (void *)&_mh_execute_header);
}

uint64_t sub_10053B5F8(uint64_t a1, void *a2)
{
  *(void *)a1 = *a2;
  *(void *)(a1 + 8) = 0LL;
  sub_100E03994(a1 + 16);
  *(_DWORD *)(a1 + 61680) = 16;
  return a1;
}

uint64_t sub_10053B630(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = sub_10053C05C((int *)a1, a2);
  if (!(_DWORD)v5) {
    return v5;
  }
  uint64_t v6 = (int *)(a1 + 61680);
  int v7 = *(_DWORD *)(a1 + 61680);
  if ((v7 & 1) != 0)
  {
    *(void *)__int128 v57 = &off_101826A48;
    unsigned int v8 = sub_1001B5514();
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10183F828);
    }
    int v9 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "CNNWorkoutClass,%d", buf, 8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10183F828);
      }
      int v71 = 67109120;
      unsigned int v72 = v8;
      __int128 v53 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  2LL,  "CNNWorkoutClass,%d",  &v71);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWorkoutPredictorTier2Classifier::update(const CLWorkoutPredictorDMInput &, CLWorkoutClassifier_Type::Work outClassifierResult &)",  "%s\n",  v53);
      if (v53 != buf) {
        free(v53);
      }
    }

    int v7 = *v6;
  }

  if ((v7 & 0x10) != 0)
  {
    *(void *)__int128 v57 = &off_10184E580;
    __int128 v66 = 0u;
    __int128 v67 = 0u;
    __int128 v68 = 0u;
    __int128 v69 = 0u;
    memset(&v57[8], 0, 128);
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    __int128 v63 = 0u;
    __int128 v64 = 0u;
    __int128 v65 = 0u;
    int v70 = 0;
    unsigned int v10 = sub_100784818((uint64_t)v57, a1 + 16);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10183F828);
    }
    int v11 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "GBTWorkoutClass,%d", buf, 8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10183F828);
      }
      int v71 = 67109120;
      unsigned int v72 = v10;
      __int128 v54 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  2LL,  "GBTWorkoutClass,%d",  &v71);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWorkoutPredictorTier2Classifier::update(const CLWorkoutPredictorDMInput &, CLWorkoutClassifier_Type::Work outClassifierResult &)",  "%s\n",  v54);
      if (v54 != buf) {
        free(v54);
      }
    }

    if ((*v6 & 0x100) == 0) {
      goto LABEL_23;
    }
    goto LABEL_18;
  }

  unsigned int v10 = 5;
  if ((v7 & 0x100) != 0)
  {
LABEL_18:
    sub_100F2CBDC((uint64_t)v57);
    unsigned int v12 = sub_100F2CC14((uint64_t)v57, (uint64_t *)(a1 + 16));
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10183F828);
    }
    __int128 v13 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "LRWorkoutClass,%d", buf, 8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10183F828);
      }
      int v71 = 67109120;
      unsigned int v72 = v12;
      __int128 v55 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  2LL,  "LRWorkoutClass,%d",  &v71);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWorkoutPredictorTier2Classifier::update(const CLWorkoutPredictorDMInput &, CLWorkoutClassifier_Type::Work outClassifierResult &)",  "%s\n",  v55);
      if (v55 != buf) {
        free(v55);
      }
    }
  }

uint64_t sub_10053C05C(int *a1, uint64_t a2)
{
  v26.i32[0] = sub_100833470((float *)a2);
  v26.i32[1] = v4;
  int v27 = v5;
  float32x2_t v24 = *(float32x2_t *)(a2 + 16);
  int v25 = *(_DWORD *)(a2 + 24);
  uint64_t v22 = *(void *)(a2 + 28);
  float v23 = *(float *)(a2 + 36);
  uint64_t v20 = 1065353216LL;
  int v21 = 0;
  sub_10083361C((float *)a2, v18);
  v19[0] = sub_1002B8A2C((uint64_t)v18, (float *)&v24);
  v19[1] = v6;
  v19[2] = v7;
  sub_10083361C((float *)a2, v18);
  v17[0] = sub_1002B8A2C((uint64_t)v18, (float *)&v22);
  v17[1] = v8;
  _DWORD v17[2] = v9;
  int v10 = a1[1];
  if (!v10)
  {
    sub_100833470((float *)a2);
    v26.f32[1] = -v11;
    v24.f32[1] = -v24.f32[1];
    *(float *)&uint64_t v22 = -*(float *)&v22;
    int v10 = a1[1];
  }

  int v12 = *a1;
  if (*a1 == v10)
  {
    v26.f32[0] = -sub_100833470((float *)a2);
    v24.f32[0] = -v24.f32[0];
    *((float *)&v22 + 1) = -*((float *)&v22 + 1);
    LODWORD(v20) = -1082130432;
    int v12 = *a1;
  }

  if (v12 == 1) {
    float v23 = -v23;
  }
  sub_10083361C((float *)a2, v18);
  v16[0] = sub_1002B8A2C((uint64_t)v18, (float *)&v20);
  v16[1] = v13;
  v16[2] = v14;
  return sub_100E03B44((uint64_t)(a1 + 4), &v24, (float *)&v22, &v26, v19, v17, v16);
}

void sub_10053C1E0(int *a1, void *a2)
{
  *(void *)a1 = *a2;
  if (qword_101934680 != -1) {
    dispatch_once(&qword_101934680, &stru_10183F828);
  }
  uint64_t v3 = (os_log_s *)qword_101934688;
  if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
  {
    int v4 = *a1;
    int v5 = a1[1];
    *(_DWORD *)buf = 67109376;
    int v13 = v4;
    __int16 v14 = 1024;
    int v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "DeviceOrientation,%d,%d", buf, 0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10183F828);
    }
    int v6 = *a1;
    int v7 = a1[1];
    v9[0] = 67109376;
    v9[1] = v6;
    __int16 v10 = 1024;
    int v11 = v7;
    float v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  2LL,  "DeviceOrientation,%d,%d",  v9,  14);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutPredictorTier2Classifier::setDeviceOrientation(const CLGizmoOrientation &)",  "%s\n",  v8);
  }

void sub_10053C3B0(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

void sub_10053C3DC(uint64_t *a1)
{
  if (qword_1019344E0 != -1) {
    dispatch_once(&qword_1019344E0, &stru_10183F848);
  }
  uint64_t v2 = (os_log_s *)qword_1019344E8;
  if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *a1;
    uint64_t v4 = a1[1];
    int v5 = *((_DWORD *)a1 + 4);
    int v6 = *((_DWORD *)a1 + 5);
    int v7 = *((_DWORD *)a1 + 6);
    double v8 = *((float *)a1 + 7);
    int v10 = *((_DWORD *)a1 + 8);
    int v9 = *((_DWORD *)a1 + 9);
    int v11 = *((_DWORD *)a1 + 10);
    int v12 = *((_DWORD *)a1 + 11);
    int v14 = *((_DWORD *)a1 + 12);
    int v13 = *((_DWORD *)a1 + 13);
    *(_DWORD *)buf = 136321026;
    double v79 = "startTime";
    __int16 v80 = 2048;
    uint64_t v81 = v3;
    __int16 v82 = 2080;
    double v83 = "endTime";
    __int16 v84 = 2048;
    uint64_t v85 = v4;
    __int16 v86 = 2080;
    double v87 = "avgInterCalibrationTime";
    __int16 v88 = 1024;
    int v89 = v5;
    __int16 v90 = 2080;
    double v91 = "pctTurnsRejected";
    __int16 v92 = 1024;
    int v93 = v6;
    __int16 v94 = 2080;
    uint64_t v95 = "poolLength";
    __int16 v96 = 1024;
    int v97 = v7;
    __int16 v98 = 2080;
    uint64_t v99 = "avgLapCorrection";
    __int16 v100 = 2048;
    double v101 = v8;
    __int16 v102 = 2080;
    int v103 = "numLaps";
    __int16 v104 = 1024;
    int v105 = v10;
    __int16 v106 = 2080;
    uint64_t v107 = "numLapInsertions";
    __int16 v108 = 1024;
    int v109 = v9;
    __int16 v110 = 2080;
    uint64_t v111 = "numLapsForConvergence";
    __int16 v112 = 1024;
    int v113 = v11;
    __int16 v114 = 2080;
    uint64_t v115 = "pctStrokesFailCurvature";
    __int16 v116 = 1024;
    int v117 = v12;
    __int16 v118 = 2080;
    uint64_t v119 = "pctStrokesFailMA";
    __int16 v120 = 1024;
    int v121 = v14;
    __int16 v122 = 2080;
    int v123 = "pctStrokesFailAccel";
    __int16 v124 = 1024;
    int v125 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "SessionStats,%s,%f,%s,%f,%s,%u,%s,%u,%s,%u,%s,%f,%s,%u,%s,%u,%s,%u,%s,%u,%s,%u,%s,%u",  buf,  0xCEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10183F848);
    }
    uint64_t v15 = *a1;
    uint64_t v16 = a1[1];
    int v17 = *((_DWORD *)a1 + 4);
    int v18 = *((_DWORD *)a1 + 5);
    int v19 = *((_DWORD *)a1 + 6);
    double v20 = *((float *)a1 + 7);
    int v21 = *((_DWORD *)a1 + 8);
    int v22 = *((_DWORD *)a1 + 9);
    int v23 = *((_DWORD *)a1 + 10);
    int v24 = *((_DWORD *)a1 + 11);
    int v26 = *((_DWORD *)a1 + 12);
    int v25 = *((_DWORD *)a1 + 13);
    int v30 = 136321026;
    double v31 = "startTime";
    __int16 v32 = 2048;
    uint64_t v33 = v15;
    __int16 v34 = 2080;
    uint64_t v35 = "endTime";
    __int16 v36 = 2048;
    uint64_t v37 = v16;
    __int16 v38 = 2080;
    double v39 = "avgInterCalibrationTime";
    __int16 v40 = 1024;
    int v41 = v17;
    __int16 v42 = 2080;
    double v43 = "pctTurnsRejected";
    __int16 v44 = 1024;
    int v45 = v18;
    __int16 v46 = 2080;
    uint64_t v47 = "poolLength";
    __int16 v48 = 1024;
    int v49 = v19;
    __int16 v50 = 2080;
    uint64_t v51 = "avgLapCorrection";
    __int16 v52 = 2048;
    double v53 = v20;
    __int16 v54 = 2080;
    __int128 v55 = "numLaps";
    __int16 v56 = 1024;
    int v57 = v21;
    __int16 v58 = 2080;
    __int128 v59 = "numLapInsertions";
    __int16 v60 = 1024;
    int v61 = v22;
    __int16 v62 = 2080;
    __int128 v63 = "numLapsForConvergence";
    __int16 v64 = 1024;
    int v65 = v23;
    __int16 v66 = 2080;
    __int128 v67 = "pctStrokesFailCurvature";
    __int16 v68 = 1024;
    int v69 = v24;
    __int16 v70 = 2080;
    int v71 = "pctStrokesFailMA";
    __int16 v72 = 1024;
    int v73 = v26;
    __int16 v74 = 2080;
    double v75 = "pctStrokesFailAccel";
    __int16 v76 = 1024;
    int v77 = v25;
    LODWORD(v29) = 206;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  0LL,  "SessionStats,%s,%f,%s,%f,%s,%u,%s,%u,%s,%u,%s,%f,%s,%u,%s,%u,%s,%u,%s,%u,%s,%u,%s,%u",  (const char *)&v30,  v29);
    uint64_t v28 = (uint8_t *)v27;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLMetricCollectorBase::logStats(const CLSwimSessionStats &)",  "%s\n",  v27);
    if (v28 != buf) {
      free(v28);
    }
  }

void sub_10053C814(id a1)
{
  qword_1019344E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Swimming");
}

uint64_t sub_10053C844(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }

  return a1;
}

uint64_t sub_10053C874(int a1)
{
  void v3[4] = 0LL;
  v3[5] = 0LL;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10053C918;
  v3[3] = &unk_101830538;
  if (qword_101996DA0 != -1) {
    dispatch_once(&qword_101996DA0, v3);
  }
  if (a1 == 4) {
    return qword_101996D98;
  }
  if (a1 == 5) {
    return qword_101996D90;
  }
  return 0LL;
}

CLClientManagerAuthorizationContext *sub_10053C918(uint64_t a1)
{
  LOBYTE(v3) = 0;
  qword_101996D90 = -[CLClientManagerAuthorizationContext initWithInUseLevel:registrationResult:transientAwareRegistrationResult:serviceMaskTuple:diagnosticMask:authorizedForWidgetUpdates:]( objc_alloc(&OBJC_CLASS___CLClientManagerAuthorizationContext),  "initWithInUseLevel:registrationResult:transientAwareRegistrationResult:serviceMaskTuple:diagnostic Mask:authorizedForWidgetUpdates:",  0LL,  5LL,  5LL,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  0LL,  v3);
  LOBYTE(v4) = 0;
  double result = -[CLClientManagerAuthorizationContext initWithInUseLevel:registrationResult:transientAwareRegistrationResult:serviceMaskTuple:diagnosticMask:authorizedForWidgetUpdates:]( objc_alloc(&OBJC_CLASS___CLClientManagerAuthorizationContext),  "initWithInUseLevel:registrationResult:transientAwareRegistrationResult:serviceMaskTuple:diagnosticMask:auth orizedForWidgetUpdates:",  0LL,  4LL,  4LL,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  0LL,  v4);
  qword_101996D98 = (uint64_t)result;
  return result;
}

BOOL sub_10053C998(void *a1)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_101996DD8);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_101996DD8))
  {
    sub_1010DDBC0(&qword_101996DA8, "com.apple.NanoUniverse.AegirProxyApp");
    sub_1010DDBC0(qword_101996DC0, "com.apple.weather");
    __cxa_atexit((void (*)(void *))sub_10053CAA8, &qword_101996DA8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101996DD8);
  }

  uint64_t v3 = (const char *)objc_msgSend(objc_msgSend(a1, "clientAnchor"), "UTF8String");
  uint64_t v4 = "";
  if (v3) {
    uint64_t v4 = v3;
  }
  int v6 = v4;
}

void sub_10053CA78(_Unwind_Exception *a1)
{
  if (byte_101996DBF < 0) {
    sub_10123C950();
  }
  __cxa_guard_abort(&qword_101996DD8);
  _Unwind_Resume(a1);
}

uint64_t sub_10053CAA8(uint64_t a1)
{
  for (uint64_t i = 0LL; i != -48; i -= 24LL)
  {
  }

  return a1;
}

uint64_t sub_10053D590(uint64_t a1)
{
  *(void *)a1 = off_10183F878;
  sub_100585EA0(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_10053D5C4(void **a1)
{
  *a1 = off_10183F878;
  sub_100585EA0((uint64_t)(a1 + 2), a1[3]);
  operator delete(a1);
}

id sub_10053D5F8(uint64_t a1, void *a2, NSMutableDictionary *a3)
{
  id v4 = a2;
  unsigned int v6 = [a2 isValidCKP];
  if (a3 && v6)
  {
    id v4 = sub_10053D6E0(a1, (uint64_t)v4);
    BOOL v7 = sub_10053D890(a1, (uint64_t)v4);
    uint64_t v8 = sub_1008FE810(*(void *)(a1 + 376), v4);
    a3 = +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  a3);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( a3,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v7),  @"BigSwitchState");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( a3,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v8),  @"InUseLevel");
  }

  return objc_msgSend( *(id *)(a1 + 1008),  "setPersistentStoreDictionary:forClient:",  a3,  objc_msgSend(v4, "legacyClientKey"));
}

id sub_10053D6E0(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if (([v3 isValidCKP] & 1) == 0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v4 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      int v7 = 68289282;
      int v8 = 0;
      __int16 v9 = 2082;
      int v10 = "";
      __int16 v11 = 2114;
      uint64_t v12 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:resolveCKPToRegisteredCKPOrLogError: the passed ckp must resolve to a registered ckp. Res olving to #nullCKP, InputCKP:%{public, location:escape_only}@}",  (uint8_t *)&v7,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    int v5 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      int v7 = 68289282;
      int v8 = 0;
      __int16 v9 = 2082;
      int v10 = "";
      __int16 v11 = 2114;
      uint64_t v12 = a2;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v5,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "resolveCKPToRegisteredCKPOrLogError: the passed ckp must resolve to a registered ckp. Resolving to #nullCKP",  "{msg%{public}.0s:resolveCKPToRegisteredCKPOrLogError: the passed ckp must resolve to a registered ckp. Res olving to #nullCKP, InputCKP:%{public, location:escape_only}@}",  (uint8_t *)&v7,  0x1Cu);
    }

    return +[CLClientKeyPath nullClientKeyPath](&OBJC_CLASS___CLClientKeyPath, "nullClientKeyPath");
  }

  return v3;
}

BOOL sub_10053D890(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  int v4 = sub_100295844();
  if ([*(id *)(a1 + 120) locationServicesEnabledStatus] != 1)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138543362;
      *(void *)((char *)&buf + 4) = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "location disabled system-wide, denying executable %{public}@",  (uint8_t *)&buf,  0xCu);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(&buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v13 = 138543362;
    id v14 = v3;
    int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "location disabled system-wide, denying executable %{public}@",  &v13,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::bigSwitchEnabledForClient(CLClientKeyPath *)",  "%s\n",  v7);
LABEL_33:
    return 0LL;
  }

  if (v4 == 1) {
    return 1LL;
  }
  if ([v3 isValidCKP])
  {
    if (v3)
    {
      [v3 cppClientKey];
    }

    else
    {
      __int128 buf = 0uLL;
      uint64_t v16 = 0LL;
    }

    uint64_t v8 = sub_10008E8D0(a1 + 616, (const void **)&buf);
    uint64_t v9 = a1 + 624;
    if (SHIBYTE(v16) < 0) {
      operator delete((void *)buf);
    }
    if (v9 != v8)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v10 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v3;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "location emergency-enablement explicitly benefits %{public}@, not denying",  (uint8_t *)&buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        int v13 = 138543362;
        id v14 = v3;
        uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "location emergency-enablement explicitly benefits %{public}@, not denying",  &v13,  12);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::bigSwitchEnabledForClient(CLClientKeyPath *)",  "%s\n",  v12);
      }

      return 1LL;
    }
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  __int16 v11 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "location emergency-enabled with explicit beneficiaries, denying executable %{public}@",  (uint8_t *)&buf,  0xCu);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v13 = 138543362;
    id v14 = v3;
    int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "location emergency-enabled with explicit beneficiaries, denying executable %{public}@",  &v13,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::bigSwitchEnabledForClient(CLClientKeyPath *)",  "%s\n",  v7);
    goto LABEL_33;
  }

  return result;
}

void sub_10053DD48( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_10053DD6C(uint64_t a1, _OWORD *a2)
{
  int v4 = objc_alloc(&OBJC_CLASS___CLLocation);
  __int128 v5 = a2[7];
  v10[6] = a2[6];
  v10[7] = v5;
  v11[0] = a2[8];
  *(_OWORD *)((char *)v11 + 12) = *(_OWORD *)((char *)a2 + 140);
  __int128 v6 = a2[3];
  v10[2] = a2[2];
  v10[3] = v6;
  __int128 v7 = a2[5];
  v10[4] = a2[4];
  v10[5] = v7;
  __int128 v8 = a2[1];
  v10[0] = *a2;
  v10[1] = v8;
  return objc_msgSend( *(id *)(a1 + 1008),  "updateCurrentLocation:",  -[CLLocation initWithClientLocation:](v4, "initWithClientLocation:", v10));
}

void sub_10053DDE8(uint64_t a1, void *a2)
{
  uint64_t v4 = *a2;
  if (*(char *)(*a2 + 95LL) < 0)
  {
    sub_1010DD48C(__dst, *(void **)(v4 + 72), *(void *)(v4 + 80));
  }

  else
  {
    *(_OWORD *)__dst = *(_OWORD *)(v4 + 72);
    uint64_t v19 = *(void *)(v4 + 88);
  }

  if (*(char *)(v4 + 119) < 0)
  {
    sub_1010DD48C(&__p, *(void **)(v4 + 96), *(void *)(v4 + 104));
  }

  else
  {
    __int128 __p = *(_OWORD *)(v4 + 96);
    uint64_t v21 = *(void *)(v4 + 112);
  }

  uint64_t v22 = *(void *)(v4 + 120);
  if (v19 >= 0) {
    __int128 v5 = __dst;
  }
  else {
    __int128 v5 = (void **)__dst[0];
  }
  id v6 = objc_msgSend( *(id *)(*(void *)(a1 + 8) + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithClientKey:]( CLClientKeyPath,  "clientKeyPathWithClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v5)));
  if (v21 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = (__int128 *)__p;
  }
  __int128 v8 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v9 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289538;
    int v24 = 0;
    __int16 v25 = 2082;
    int v26 = "";
    __int16 v27 = 2114;
    id v28 = v6;
    __int16 v29 = 2114;
    int v30 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#PersistentSubscription PersistenceBackend removeAllPersistedDataForSubscription, clien t:%{public, location:escape_only}@, storageName:%{public, location:escape_only}@}",  buf,  0x26u);
  }

  int v10 = (std::__shared_weak_count *)a2[1];
  unint64_t v16 = *a2;
  int v17 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  sub_100585EE8(a1 + 16, &v16);
  int v13 = v17;
  if (v17)
  {
    id v14 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }

  if (SHIBYTE(v21) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_10053E05C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_10053E0A4(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
}

void sub_10053E0B0(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6 = *a2;
  if (*(char *)(*a2 + 95LL) < 0)
  {
    sub_1010DD48C(__dst, *(void **)(v6 + 72), *(void *)(v6 + 80));
  }

  else
  {
    *(_OWORD *)__dst = *(_OWORD *)(v6 + 72);
    uint64_t v25 = *(void *)(v6 + 88);
  }

  if (*(char *)(v6 + 119) < 0)
  {
    sub_1010DD48C(&__p, *(void **)(v6 + 96), *(void *)(v6 + 104));
  }

  else
  {
    __int128 __p = *(_OWORD *)(v6 + 96);
    uint64_t v27 = *(void *)(v6 + 112);
  }

  uint64_t v28 = *(void *)(v6 + 120);
  if (v25 >= 0) {
    __int128 v7 = __dst;
  }
  else {
    __int128 v7 = (void **)__dst[0];
  }
  id v8 = sub_10053D6E0( *(void *)(a1 + 8),  (uint64_t)+[CLClientKeyPath clientKeyPathWithClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v7)));
  if (v27 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = (__int128 *)__p;
  }
  int v10 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  __int16 v11 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    id v12 = [a3 UTF8String];
    *(_DWORD *)__int128 buf = 68289795;
    int v30 = 0;
    __int16 v31 = 2082;
    __int16 v32 = "";
    __int16 v33 = 2114;
    id v34 = v8;
    __int16 v35 = 2114;
    __int16 v36 = v10;
    __int16 v37 = 2081;
    id v38 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#PersistentSubscription PersistenceBackend clearObjectForKeyForSubscription, client:% {public, location:escape_only}@, storageName:%{public, location:escape_only}@, storageKey:%{private, locat ion:escape_only}s}",  buf,  0x30u);
  }

  int v13 = +[NSMutableDictionary dictionaryWithDictionary:]( NSMutableDictionary,  "dictionaryWithDictionary:",  [*(id *)(*(void *)(a1 + 8) + 136) dictionaryForKey:v10 atKeyPath:v8 defaultValue:&__NSDictionary0__struct]);
  -[NSMutableDictionary removeObjectForKey:](v13, "removeObjectForKey:", a3);
  id v14 = -[NSMutableDictionary count](v13, "count");
  unint64_t v15 = *(void **)(*(void *)(a1 + 8) + 136LL);
  if (v14)
  {
    [v15 setDictionary:v13 forKey:v10 atKeyPath:v8];
  }

  else
  {
    [v15 removeValueForKey:v10 atKeyPath:v8];
    unint64_t v16 = (std::__shared_weak_count *)a2[1];
    unint64_t v22 = *a2;
    int v23 = v16;
    if (v16)
    {
      p_shared_owners = (unint64_t *)&v16->__shared_owners_;
      do
        unint64_t v18 = __ldxr(p_shared_owners);
      while (__stxr(v18 + 1, p_shared_owners));
    }

    sub_100585EE8(a1 + 16, &v22);
    uint64_t v19 = v23;
    if (v23)
    {
      double v20 = (unint64_t *)&v23->__shared_owners_;
      do
        unint64_t v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }

  if (SHIBYTE(v27) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v25) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_10053E398( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_10053E3E8(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v8 = *a2;
    if (*(char *)(*a2 + 95LL) < 0)
    {
      sub_1010DD48C(__dst, *(void **)(v8 + 72), *(void *)(v8 + 80));
    }

    else
    {
      *(_OWORD *)__dst = *(_OWORD *)(v8 + 72);
      uint64_t v30 = *(void *)(v8 + 88);
    }

    if (*(char *)(v8 + 119) < 0)
    {
      sub_1010DD48C(&__p, *(void **)(v8 + 96), *(void *)(v8 + 104));
    }

    else
    {
      __int128 __p = *(_OWORD *)(v8 + 96);
      uint64_t v32 = *(void *)(v8 + 112);
    }

    uint64_t v33 = *(void *)(v8 + 120);
    if (v30 >= 0) {
      id v14 = __dst;
    }
    else {
      id v14 = (void **)__dst[0];
    }
    id v15 = sub_10053D6E0( *(void *)(a1 + 8),  (uint64_t)+[CLClientKeyPath clientKeyPathWithClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v14)));
    if (v32 >= 0) {
      p_p = &__p;
    }
    else {
      p_p = (__int128 *)__p;
    }
    int v17 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unint64_t v18 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      id v19 = [a3 UTF8String];
      *(_DWORD *)__int128 buf = 68290051;
      int v36 = 0;
      __int16 v37 = 2082;
      id v38 = "";
      __int16 v39 = 2114;
      id v40 = v15;
      __int16 v41 = 2114;
      __int16 v42 = v17;
      __int16 v43 = 2081;
      id v44 = v19;
      __int16 v45 = 2113;
      uint64_t v46 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#PersistentSubscription PersistenceBackend setObjectForKeyForSubscription, client:% {public, location:escape_only}@, storageName:%{public, location:escape_only}@, storageKey:%{private, loc ation:escape_only}s, storageValue:%{private, location:escape_only}@}",  buf,  0x3Au);
    }

    double v20 = (std::__shared_weak_count *)a2[1];
    uint64_t v27 = *a2;
    uint64_t v28 = v20;
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        unint64_t v22 = __ldxr(p_shared_owners);
      while (__stxr(v22 + 1, p_shared_owners));
    }

    sub_100585F6C((uint64_t **)(a1 + 16), (unint64_t *)&v27, &v27);
    int v23 = v28;
    if (v28)
    {
      int v24 = (unint64_t *)&v28->__shared_owners_;
      do
        unint64_t v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }

    int v26 = +[NSMutableDictionary dictionaryWithDictionary:]( NSMutableDictionary,  "dictionaryWithDictionary:",  objc_msgSend( *(id *)(*(void *)(a1 + 8) + 136),  "dictionaryForKey:atKeyPath:defaultValue:",  v17,  v15,  &__NSDictionary0__struct,  v27));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v26, "setObject:forKeyedSubscript:", a4, a3);
    [*(id *)(*(void *)(a1 + 8) + 136) setDictionary:v26 forKey:v17 atKeyPath:v15];
    if (SHIBYTE(v32) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v30) < 0) {
      operator delete(__dst[0]);
    }
  }

  else
  {
    uint64_t v9 = (std::__shared_weak_count *)a2[1];
    v34[0] = *a2;
    v34[1] = v9;
    if (v9)
    {
      int v10 = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v11 = __ldxr(v10);
      while (__stxr(v11 + 1, v10));
    }

    sub_10053E0B0(a1, v34, a3);
    if (v9)
    {
      id v12 = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(v12);
      while (__stlxr(v13 - 1, v12));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }

void sub_10053E760( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_10053E7C0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *a2;
  if (*(char *)(*a2 + 95) < 0)
  {
    sub_1010DD48C(v11, *(void **)(v5 + 72), *(void *)(v5 + 80));
  }

  else
  {
    *(_OWORD *)unint64_t v11 = *(_OWORD *)(v5 + 72);
    uint64_t v12 = *(void *)(v5 + 88);
  }

  if (*(char *)(v5 + 119) < 0)
  {
    sub_1010DD48C(&__p, *(void **)(v5 + 96), *(void *)(v5 + 104));
  }

  else
  {
    __int128 __p = *(_OWORD *)(v5 + 96);
    uint64_t v14 = *(void *)(v5 + 112);
  }

  uint64_t v15 = *(void *)(v5 + 120);
  if (v12 >= 0) {
    uint64_t v6 = v11;
  }
  else {
    uint64_t v6 = (void **)v11[0];
  }
  id v7 = sub_10053D6E0( *(void *)(a1 + 8),  (uint64_t)+[CLClientKeyPath clientKeyPathWithClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientKey:",  +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v6,  v11[0],  v11[1],  v12)));
  if (v14 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = (__int128 *)__p;
  }
  id v9 = objc_msgSend( objc_msgSend( *(id *)(*(void *)(a1 + 8) + 136),  "dictionaryForKey:atKeyPath:defaultValue:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", p_p),  v7,  &__NSDictionary0__struct),  "objectForKeyedSubscript:",  a3);
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  return v9;
}

void sub_10053E910( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_10053E944(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 8) + 136) persist];
}

void sub_10053E950(uint64_t a1, unint64_t *a2)
{
  unint64_t v2 = a2[1];
  unint64_t v8 = *a2;
  id v9 = (std::__shared_weak_count *)v2;
  if (v2)
  {
    id v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  sub_100585EE8(a1 + 16, &v8);
  uint64_t v5 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

void sub_10053E9D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id sub_10053E9E8(void *a1)
{
  unint64_t v2 = a1 + 3;
  sub_100585EA0((uint64_t)(a1 + 2), (void *)a1[3]);
  a1[2] = v2;
  a1[4] = 0LL;
  *unint64_t v2 = 0LL;
  id v3 = *(void **)(a1[1] + 136LL);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_10053EA68;
  v5[3] = &unk_10183F8B0;
  v5[4] = a1;
  return [v3 iterateAllAnchorKeyPathsWithBlock:v5];
}

void sub_10053EA68(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  sub_10053EAA4(v3, a2);
  sub_10053EBB8(v3, a2);
  sub_10053ECCC(v3, a2);
}

void sub_10053EAA4(uint64_t a1, uint64_t a2)
{
  if (sub_1005860A4(a1, a2))
  {
    sub_10058616C(*(uint64_t **)(a1 + 8), a2, &v14);
    if ((sub_1005860A4(a1, a2) & 1) != 0)
    {
      uint64_t v12 = v14;
      unint64_t v13 = v15;
      if (v15)
      {
        p_shared_owners = (unint64_t *)&v15->__shared_owners_;
        do
          unint64_t v5 = __ldxr(p_shared_owners);
        while (__stxr(v5 + 1, p_shared_owners));
      }

      sub_100585F6C((uint64_t **)(a1 + 16), (unint64_t *)&v12, &v12);
      uint64_t v6 = v13;
      if (v13)
      {
        unint64_t v7 = (unint64_t *)&v13->__shared_owners_;
        do
          unint64_t v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
    }

    id v9 = v15;
    if (v15)
    {
      int v10 = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }

void sub_10053EB94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_10053EBB8(uint64_t a1, uint64_t a2)
{
  if (sub_100587080(a1, a2))
  {
    sub_100587148(*(uint64_t **)(a1 + 8), a2, &v14);
    if ((sub_100587080(a1, a2) & 1) != 0)
    {
      uint64_t v12 = v14;
      unint64_t v13 = v15;
      if (v15)
      {
        p_shared_owners = (unint64_t *)&v15->__shared_owners_;
        do
          unint64_t v5 = __ldxr(p_shared_owners);
        while (__stxr(v5 + 1, p_shared_owners));
      }

      sub_100585F6C((uint64_t **)(a1 + 16), (unint64_t *)&v12, &v12);
      uint64_t v6 = v13;
      if (v13)
      {
        unint64_t v7 = (unint64_t *)&v13->__shared_owners_;
        do
          unint64_t v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
    }

    id v9 = v15;
    if (v15)
    {
      int v10 = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }

void sub_10053ECA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_10053ECCC(uint64_t a1, uint64_t a2)
{
  if (sub_100587898(a1, a2))
  {
    sub_1005551F8(*(uint64_t **)(a1 + 8), a2, &v14);
    if ((sub_100587898(a1, a2) & 1) != 0)
    {
      uint64_t v12 = v14;
      unint64_t v13 = v15;
      if (v15)
      {
        p_shared_owners = (unint64_t *)&v15->__shared_owners_;
        do
          unint64_t v5 = __ldxr(p_shared_owners);
        while (__stxr(v5 + 1, p_shared_owners));
      }

      sub_100585F6C((uint64_t **)(a1 + 16), (unint64_t *)&v12, &v12);
      uint64_t v6 = v13;
      if (v13)
      {
        unint64_t v7 = (unint64_t *)&v13->__shared_owners_;
        do
          unint64_t v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
    }

    id v9 = v15;
    if (v15)
    {
      int v10 = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }

void sub_10053EDBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_10053EDE0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  unint64_t v2 = (void *)(a1 + 24);
  if (v1 != (void *)(a1 + 24))
  {
    do
    {
      uint64_t v3 = (std::__shared_weak_count *)v1[5];
      if (v3)
      {
        p_shared_owners = (unint64_t *)&v3->__shared_owners_;
        do
          unint64_t v5 = __ldxr(p_shared_owners);
        while (__stxr(v5 + 1, p_shared_owners));
        do
          unint64_t v6 = __ldaxr(p_shared_owners);
        while (__stlxr(v6 - 1, p_shared_owners));
        if (!v6)
        {
          ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
          std::__shared_weak_count::__release_weak(v3);
        }
      }

      unint64_t v7 = (void *)v1[1];
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          unint64_t v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          unint64_t v8 = (void *)v1[2];
          BOOL v9 = *v8 == (void)v1;
          uint64_t v1 = v8;
        }

        while (!v9);
      }

      uint64_t v1 = v8;
    }

    while (v8 != v2);
  }

uint64_t sub_10053EE90(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10053EF04;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_101996DE0 != -1) {
    dispatch_once(&qword_101996DE0, block);
  }
  return qword_1019A1168;
}

std::string::size_type sub_10053EF04(uint64_t a1)
{
  unint64_t v2 = operator new(0x5E8uLL);
  std::string::size_type result = sub_100575A50((std::string::size_type)v2, *(void **)(a1 + 32));
  qword_1019A1168 = (uint64_t)v2;
  return result;
}

void sub_10053EF3C(_Unwind_Exception *a1)
{
}

void sub_10053EF50(uint64_t a1, CLConnection *a2, CLConnectionMessage **a3)
{
  unint64_t v6 = (const std::string *)CLConnectionMessage::name(*a3);
  unint64_t v7 = __p;
  sub_1010DDBC0(__p, "/");
  int64_t size = v6->__r_.__value_.__s.__size_;
  if ((size & 0x80u) == 0LL) {
    BOOL v9 = v6;
  }
  else {
    BOOL v9 = (const std::string *)v6->__r_.__value_.__r.__words[0];
  }
  if ((v152 & 0x80u) == 0)
  {
    int64_t v10 = v152;
  }

  else
  {
    unint64_t v7 = (void **)__p[0];
    int64_t v10 = (int64_t)__p[1];
  }

  if (v10)
  {
    if ((size & 0x80u) != 0LL) {
      int64_t size = v6->__r_.__value_.__l.__size_;
    }
    unint64_t v11 = (char *)v9 + size;
    if (size >= v10)
    {
      int v28 = *(char *)v7;
      __int16 v29 = v9;
      do
      {
        int64_t v30 = size - v10;
        if (v30 == -1) {
          break;
        }
        __int16 v31 = (char *)memchr(v29, v28, v30 + 1);
        if (!v31) {
          break;
        }
        uint64_t v12 = v31;
        if (!memcmp(v31, v7, v10)) {
          goto LABEL_12;
        }
        __int16 v29 = (const std::string *)(v12 + 1);
        int64_t size = v11 - (v12 + 1);
      }

      while (size >= v10);
    }

    uint64_t v12 = v11;
LABEL_12:
    if (v12 == v11) {
      std::string::size_type v13 = -1LL;
    }
    else {
      std::string::size_type v13 = v12 - (char *)v9;
    }
  }

  else
  {
    std::string::size_type v13 = 0LL;
  }

  std::string::basic_string(&v150, v6, 0LL, v13, (std::allocator<char> *)buf);
  if ((v150.__r_.__value_.__s.__size_ & 0x80) != 0)
  {
    std::string::size_type v15 = v150.__r_.__value_.__l.__size_;
    if (v150.__r_.__value_.__l.__size_ == 15
      && *(void *)v150.__r_.__value_.__l.__data_ == 0x6E6F697461636F4CLL
      && *(void *)(v150.__r_.__value_.__r.__words[0] + 7) == 0x726567616E614D6ELL)
    {
      goto LABEL_149;
    }

    if (v150.__r_.__value_.__l.__size_ == 19)
    {
      if (*(void *)v150.__r_.__value_.__l.__data_ == 0x6E6F697461636F4CLL
        && *(void *)(v150.__r_.__value_.__r.__words[0] + 8) == 0x4C72657461647055LL
        && *(void *)(v150.__r_.__value_.__r.__words[0] + 11) == 0x6576694C72657461LL)
      {
        goto LABEL_131;
      }

      std::string::size_type v15 = v150.__r_.__value_.__l.__size_;
    }

    if (v15 != 25) {
      goto LABEL_63;
    }
    if (*(void *)v150.__r_.__value_.__l.__data_ == 0x6E6F697461636F4CLL
      && *(void *)(v150.__r_.__value_.__r.__words[0] + 8) == 0x4872657461647055LL
      && *(void *)(v150.__r_.__value_.__r.__words[0] + 16) == 0x616369726F747369LL
      && *(_BYTE *)(v150.__r_.__value_.__r.__words[0] + 24) == 108)
    {
      goto LABEL_131;
    }

    std::string::size_type v15 = v150.__r_.__value_.__l.__size_;
    if (v150.__r_.__value_.__l.__size_ != 25) {
      goto LABEL_63;
    }
    if (*(void *)v150.__r_.__value_.__l.__data_ == 0x756F72676B636142LL
      && *(void *)(v150.__r_.__value_.__r.__words[0] + 8) == 0x697669746341646ELL
      && *(void *)(v150.__r_.__value_.__r.__words[0] + 16) == 0x6F69737365537974LL
      && *(_BYTE *)(v150.__r_.__value_.__r.__words[0] + 24) == 110)
    {
      goto LABEL_131;
    }

    if ((v150.__r_.__value_.__s.__size_ & 0x80) != 0)
    {
LABEL_63:
      if (v15 == 19)
      {
        if (*(void *)v150.__r_.__value_.__l.__data_ == 0x756363416C6C7546LL
          && *(void *)(v150.__r_.__value_.__r.__words[0] + 8) == 0x7373655379636172LL
          && *(void *)(v150.__r_.__value_.__r.__words[0] + 11) == 0x6E6F697373655379LL)
        {
          goto LABEL_131;
        }

        std::string::size_type v15 = v150.__r_.__value_.__l.__size_;
      }

      if (v15 != 14) {
        goto LABEL_126;
      }
      uint64_t v27 = (std::string *)v150.__r_.__value_.__r.__words[0];
      goto LABEL_122;
    }
  }

  else
  {
    if (v150.__r_.__value_.__s.__size_ <= 0x12u)
    {
      if (v150.__r_.__value_.__s.__size_ != 14)
      {
        if (v150.__r_.__value_.__s.__size_ != 15) {
          goto LABEL_126;
        }
        if (v150.__r_.__value_.__r.__words[0] != 0x6E6F697461636F4CLL
          || *(std::string::size_type *)((char *)v150.__r_.__value_.__r.__words + 7) != 0x726567616E614D6ELL)
        {
          goto LABEL_126;
        }

LABEL_149:
        int v61 = *a3;
        __int16 v50 = a3[1];
        v149[0] = v61;
        v149[1] = v50;
        if (v50)
        {
          __int16 v62 = (unint64_t *)((char *)v50 + 8);
          do
            unint64_t v63 = __ldxr(v62);
          while (__stxr(v63 + 1, v62));
        }

        sub_100540418(a1, a2, v149);
        if (v50)
        {
          __int16 v64 = (unint64_t *)((char *)v50 + 8);
          do
            unint64_t v54 = __ldaxr(v64);
          while (__stlxr(v54 - 1, v64));
          goto LABEL_137;
        }

        goto LABEL_187;
      }

      goto LABEL_121;
    }

    if (v150.__r_.__value_.__s.__size_ != 19)
    {
      if (v150.__r_.__value_.__s.__size_ == 25)
      {
        BOOL v32 = v150.__r_.__value_.__r.__words[0] == 0x6E6F697461636F4CLL
           && v150.__r_.__value_.__l.__size_ == 0x4872657461647055LL;
        BOOL v33 = v32 && v150.__r_.__value_.__l.__cap_ == 0x616369726F747369LL;
        if (v33 && LOBYTE(__p[0]) == 108) {
          goto LABEL_131;
        }
        BOOL v35 = v150.__r_.__value_.__r.__words[0] == 0x756F72676B636142LL
           && v150.__r_.__value_.__l.__size_ == 0x697669746341646ELL;
        BOOL v36 = v35 && v150.__r_.__value_.__l.__cap_ == 0x6F69737365537974LL;
        if (v36 && LOBYTE(__p[0]) == 110) {
          goto LABEL_131;
        }
      }

      goto LABEL_126;
    }

    if (v150.__r_.__value_.__r.__words[0] == 0x6E6F697461636F4CLL
      && v150.__r_.__value_.__l.__size_ == 0x4C72657461647055LL
      && *(std::string::size_type *)((char *)&v150.__r_.__value_.__r.__words[1] + 3) == 0x6576694C72657461LL)
    {
      goto LABEL_131;
    }
  }

  if (v150.__r_.__value_.__s.__size_ != 14)
  {
    if (v150.__r_.__value_.__s.__size_ == 19)
    {
      BOOL v40 = v150.__r_.__value_.__r.__words[0] == 0x756363416C6C7546LL
         && v150.__r_.__value_.__l.__size_ == 0x7373655379636172LL;
    }

          *(_DWORD *)(a1 + 120) = v34;
          goto LABEL_101;
        case 2u:
          *(_BYTE *)(a1 + 132) |= 2u;
          __int16 v37 = *((void *)this + 1);
          id v38 = *((void *)this + 2);
          __int16 v39 = *(void *)this;
          if (v37 <= 0xFFFFFFFFFFFFFFF5LL && v37 + 10 <= v38)
          {
            BOOL v40 = 0;
            __int16 v41 = 0;
            std::string::size_type v42 = 0LL;
            do
            {
              uint64_t v43 = v37 + 1;
              *((void *)this + 1) = v37 + 1;
              id v44 = *(_BYTE *)(v39 + v37);
              v42 |= (unint64_t)(v44 & 0x7F) << v40;
              if ((v44 & 0x80) == 0) {
                goto LABEL_152;
              }
              v40 += 7;
              __int16 v37 = v43;
              unint64_t v22 = v41++ > 8;
            }

            while (!v22);
LABEL_119:
            LODWORD(v42) = 0;
            goto LABEL_152;
          }

          uint64_t v92 = 0;
          int v93 = 0;
          std::string::size_type v42 = 0LL;
          if (v38 <= v37) {
            id v38 = *((void *)this + 1);
          }
          while (2)
          {
            if (v38 == v37)
            {
              LODWORD(v42) = 0;
              *((_BYTE *)this + 24) = 1;
            }

            else
            {
              unint64_t v94 = v37 + 1;
              uint64_t v95 = *(_BYTE *)(v39 + v37);
              *((void *)this + 1) = v94;
              v42 |= (unint64_t)(v95 & 0x7F) << v92;
              if (v95 < 0)
              {
                v92 += 7;
                __int16 v37 = v94;
                unint64_t v22 = v93++ > 8;
                if (v22) {
                  goto LABEL_119;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v42) = 0;
              }
            }

            break;
          }

  std::string::size_type result = *(float *)(a2 + 212);
  v5 |= 0x4000000000000uLL;
  *unint64_t v2 = v5;
  *(_WORD *)(a1 + 288) = v6;
  *(float *)(a1 + 212) = result;
  unint64_t v4 = *v3;
  unint64_t v7 = *(_WORD *)(a2 + 288);
  if ((*v3 & 0x800000000000000LL) == 0)
  {
LABEL_76:
    if ((v7 & 0x400) == 0) {
      goto LABEL_77;
    }
    goto LABEL_151;
  }

  PB::TextFormatter::format(this, "peakPressure", *(float *)(a1 + 252));
  unint64_t v6 = *v5;
  unint64_t v7 = *(_WORD *)(a1 + 288);
  if ((*v5 & 0x2000000000000000LL) == 0)
  {
LABEL_75:
    if ((v7 & 0x400) == 0) {
      goto LABEL_76;
    }
    goto LABEL_151;
  }

  std::string::size_type result = PB::Writer::write(this, *(_BYTE *)(v3 + 278), 0x46u);
  unint64_t v5 = *v4;
  if ((*v4 & 0x4000000000000000LL) == 0)
  {
LABEL_75:
    if ((v5 & 0x8000000000000000LL) == 0) {
      goto LABEL_76;
    }
    goto LABEL_151;
  }

  std::string::size_type result = *(float *)(a2 + 180);
  v5 |= 0x40000000000uLL;
  *unint64_t v2 = v5;
  *(_WORD *)(a1 + 324) = v6;
  *(_BYTE *)(a1 + 326) = BYTE2(v6);
  *(float *)(a1 + 180) = result;
  LOWORD(v8) = *(_WORD *)(a2 + 324);
  unint64_t v4 = *v3;
  if ((*v3 & 0x2000000000000LL) == 0)
  {
LABEL_69:
    if ((v4 & 0x4000000000000LL) == 0) {
      goto LABEL_70;
    }
    goto LABEL_151;
  }

  PB::TextFormatter::format(this, "lowSenseWithoutAudioPeakPressureThreshold", *(float *)(a1 + 232));
  unint64_t v7 = *(unsigned __int16 *)(a1 + 324) | (*(unsigned __int8 *)(a1 + 326) << 16);
  unint64_t v6 = *v5;
  if ((*v5 & 0x100000000000000LL) == 0)
  {
LABEL_68:
    if ((v6 & 0x200000000000000LL) == 0) {
      goto LABEL_69;
    }
    goto LABEL_151;
  }

  std::string::size_type result = PB::Writer::write(this, *(float *)(v3 + 180), 0x103u);
  LOWORD(v7) = *((_WORD *)v4 + 4);
  unint64_t v5 = *v4;
  if ((*v4 & 0x2000000000000LL) == 0)
  {
LABEL_69:
    if ((v5 & 0x4000000000000LL) == 0) {
      goto LABEL_70;
    }
    goto LABEL_151;
  }

  id v38 = *(_BYTE *)(a2 + 345);
  v6 |= 0x400000000uLL;
  *unint64_t v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(_BYTE *)(a1 + 345) = v38;
  unint64_t v4 = *v3;
  unint64_t v7 = *(void *)(a2 + 364);
  if ((v7 & 0x40000000) == 0)
  {
LABEL_44:
    if ((v7 & 0x1000000) == 0) {
      goto LABEL_45;
    }
    goto LABEL_151;
  }

  PB::TextFormatter::format(this, "maxPulseHarmonicMean", *(float *)(a1 + 124));
  unint64_t v7 = *v5;
  unint64_t v6 = *(void *)(a1 + 364);
  if ((*v5 & 0x400000) == 0)
  {
LABEL_48:
    if ((v7 & 0x800000) == 0) {
      goto LABEL_49;
    }
    goto LABEL_151;
  }

  std::string::size_type result = PB::Writer::write(this, *(_BYTE *)(v3 + 345), 0x133u);
  unint64_t v5 = *v4;
  unint64_t v6 = v4[1];
  if ((v6 & 0x40000000) == 0)
  {
LABEL_44:
    if ((v6 & 0x1000000) == 0) {
      goto LABEL_45;
    }
    goto LABEL_151;
  }

  id v84 = *(_DWORD *)(a2 + 108);
  v3 |= 0x200000uLL;
  *(void *)(result + 204) = v3;
  *(_WORD *)(result + 212) = v4;
  *(_BYTE *)(result + 214) = BYTE2(v4);
  *(_DWORD *)(result + 108) = v84;
  LOWORD(v5) = *(_WORD *)(a2 + 212);
  unint64_t v2 = *(void *)(a2 + 204);
  if ((v2 & 0x20000) == 0)
  {
LABEL_71:
    if ((v2 & 0x20000000) == 0) {
      goto LABEL_72;
    }
    goto LABEL_151;
  }

  PB::TextFormatter::format(this, "maxRMS2", *(float *)(a1 + 136));
  unint64_t v6 = *(unsigned __int16 *)(a1 + 212) | (*(unsigned __int8 *)(a1 + 214) << 16);
  unint64_t v5 = *(void *)(a1 + 204);
  if ((v5 & 0x20000000) == 0)
  {
LABEL_70:
    if ((v5 & 0x40000000) == 0) {
      goto LABEL_71;
    }
    goto LABEL_151;
  }

  std::string::size_type result = PB::Writer::write(this, *(float *)(v3 + 152), 0x4B7u);
  unint64_t v5 = *(unsigned __int16 *)(v3 + 212) | (*(unsigned __int8 *)(v3 + 214) << 16);
  unint64_t v4 = *(void *)(v3 + 204);
  if ((v4 & 0x1000000000000LL) == 0)
  {
LABEL_71:
    if ((v4 & 0x1000000000LL) == 0) {
      goto LABEL_72;
    }
    goto LABEL_151;
  }

LABEL_187:
}

      [v50[431] numberWithBool:v44 == 1];
      __int16 v29 = 0LL;
LABEL_168:
      std::string::size_type v42 = -1.0;
LABEL_169:
      uint64_t v71 = -1.0;
LABEL_170:
      v86[0] = @"ClientKey";
      v87[0] = [v5 userlessClientKeyPath];
      v86[1] = @"Special";
      v87[1] = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v23);
      v86[2] = @"RequestType";
      v87[2] = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v8);
      v86[3] = @"GrantedStatus";
      v87[3] = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v82);
      v86[4] = @"CCStatus";
      v87[4] = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v29);
      v86[5] = @"OnDeckDuration";
      v87[5] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v71);
      v86[6] = @"ProvisionalMonitoringDuration";
      v87[6] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v42);
      AnalyticsSendEvent( @"com.apple.locationd.client.prompt.response",  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v87,  v86,  7LL));
      sub_10056AF30(a1, (uint64_t)v5, v82, v29, v72, 1, 1);
      sub_10057E760(*v4);
      sub_10057D1B4((uint64_t *)v4, 0LL);
      goto LABEL_171;
    case 12:
      __int16 v39 = a2 & 3;
      if (v39 == 1) {
        BOOL v40 = 3LL;
      }
      else {
        BOOL v40 = 2LL;
      }
      if ((a2 & 3) == 1LL) {
        int v23 = 6LL;
      }
      else {
        int v23 = 7LL;
      }
      [*(id *)(a1 + 136) setInt:v40 forKey:@"IncidentalUseMode" atKeyPath:v5];
      +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v39 == 1);
      [*(id *)(a1 + 1032) removeObject:v5];
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int16 v41 = (os_log_s *)qword_101934988;
      std::string::size_type v42 = -1.0;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = "Disallowed";
        *(_DWORD *)__int128 buf = 68289538;
        *(void *)&v91[2] = "";
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v91 = 2082;
        if (v39 == 1) {
          uint64_t v43 = "Allowed";
        }
        *(_WORD *)&v91[10] = 2114;
        *(void *)&v91[12] = v5;
        *(_WORD *)&v91[20] = 2082;
        *(void *)&v91[22] = v43;
        _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt response, ClientKey:%{public, location:escape_only}@, IncidentalUse Mode:%{public, location:escape_only}s}",  buf,  0x26u);
      }

      __int16 v29 = 0LL;
      unint64_t v82 = 4;
      goto LABEL_169;
    case 13:
    case 14:
      if (v10 == 2)
      {
        unint64_t v16 = 0;
        std::string::size_type v15 = 0LL;
LABEL_126:
        [*(id *)(a1 + 136) setInt:v15 forKey:@"LocationButtonUseMode" atKeyPath:v5];
        unint64_t v52 = *(void **)(a1 + 136);
        if (v16)
        {
          sub_1005527D4(v52, (uint64_t)v5, 1, 1);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          double v53 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)unint64_t v91 = 2082;
            *(void *)&v91[2] = "";
            *(_WORD *)&v91[10] = 2114;
            *(void *)&v91[12] = v5;
            _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#TemporaryAuth granted temporary auth , allowed chosen on #LocationButtonUse prompt , Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
          }

          unint64_t v82 = 0;
          int v23 = 8LL;
        }

        else
        {
          __int16 v64 = sub_100AE00C4(objc_msgSend(objc_msgSend(v52, "readonlyStoreAtKeyPath:", v5), "dictionary"));
          if (v64 >= 5)
          {
            int v23 = 9LL;
            unint64_t v82 = 2;
          }

          else
          {
            unint64_t v82 = dword_1012F102C[v64];
            int v23 = 9LL;
          }
        }

        int v69 = *(_DWORD *)(a1 + 312) - 1;
        else {
          unint64_t v70 = dword_1012F1020[v69];
        }
        if ((_DWORD)v8 == 13) {
          __int16 v29 = 2LL;
        }
        else {
          __int16 v29 = v70;
        }
LABEL_167:
        *(_DWORD *)(a1 + 312) = 0;
        goto LABEL_168;
      }

      if (v10 == 1)
      {
        std::string::size_type v15 = 2LL;
        unint64_t v16 = 1;
        goto LABEL_126;
      }

      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      unint64_t v76 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v91 = 2082;
        *(void *)&v91[2] = "";
        *(_WORD *)&v91[10] = 2114;
        *(void *)&v91[12] = v5;
        *(_WORD *)&v91[20] = 1026;
        *(_DWORD *)&v91[22] = a2 & 3;
        *(_WORD *)&v91[26] = 2082;
        *(void *)&v91[28] = "assert";
        uint64_t v92 = 2081;
        int v93 = "false";
        _os_log_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Impossible response to LocationButtonUse prompt, client:%{public, location:escape _only}@, flags:%{public}d, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x36u);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      uint64_t v77 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v91 = 2082;
        *(void *)&v91[2] = "";
        *(_WORD *)&v91[10] = 2114;
        *(void *)&v91[12] = v5;
        *(_WORD *)&v91[20] = 1026;
        *(_DWORD *)&v91[22] = a2 & 3;
        *(_WORD *)&v91[26] = 2082;
        *(void *)&v91[28] = "assert";
        uint64_t v92 = 2081;
        int v93 = "false";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v77,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Impossible response to LocationButtonUse prompt",  "{msg%{public}.0s:Impossible response to LocationButtonUse prompt, client:%{public, location:escape _only}@, flags:%{public}d, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x36u);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      p_vtable = (void **)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v91 = 2082;
        *(void *)&v91[2] = "";
        *(_WORD *)&v91[10] = 2114;
        *(void *)&v91[12] = v5;
        *(_WORD *)&v91[20] = 1026;
        *(_DWORD *)&v91[22] = a2 & 3;
        *(_WORD *)&v91[26] = 2082;
        *(void *)&v91[28] = "assert";
        uint64_t v92 = 2081;
        int v93 = "false";
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)p_vtable,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Impossible response to LocationButtonUse prompt, client:%{public, location:escape _only}@, flags:%{public}d, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x36u);
      }

      __int16 v78 = 4841;
LABEL_210:
      abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/CLClientManager.mm",  v78,  "onClientUserNotification");
      __break(1u);
LABEL_211:
      dispatch_once(&qword_101934980, &stru_1018401A0);
LABEL_94:
      __int16 v37 = p_vtable[305];
      v88[0] = 67240448;
      v88[1] = a2 & 3;
      uint64_t v89 = 1026;
      *(_DWORD *)((char *)v5 + 10) = v8;
      LODWORD(v81) = 14;
      id v38 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v37,  17LL,  "#AuthPrompt Received response (%{public}d) for invalid/unrecognized response type (%{public}d)",  v88,  v81);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLClientManager::onClientUserNotification(CFOptionFlags)",  "%s\n",  v38);
LABEL_171:
      if (SHIBYTE(v85) < 0) {
        operator delete(__p[0]);
      }
      return;
    case 16:
      BOOL v32 = a2 & 3;
      if (v32 == 1) {
        int v23 = 10LL;
      }
      else {
        int v23 = 11LL;
      }
      BOOL v33 = sub_100AE00C4(objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v5), "dictionary"));
      if (v33 > 4) {
        id v34 = 2;
      }
      else {
        id v34 = dword_1012F102C[v33];
      }
      unint64_t v82 = v34;
      +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v32 == 1);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      unint64_t v67 = (os_log_s *)qword_101934988;
      std::string::size_type v42 = -1.0;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v68 = "Disallowed";
        *(_DWORD *)__int128 buf = 68289538;
        *(void *)&v91[2] = "";
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v91 = 2082;
        if (v32 == 1) {
          uint64_t v68 = "Allowed";
        }
        *(_WORD *)&v91[10] = 2114;
        *(void *)&v91[12] = v5;
        *(_WORD *)&v91[20] = 2082;
        *(void *)&v91[22] = v68;
        _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt response, ClientKey:%{public, location:escape_only}@, IncidentalUse Mode:%{public, location:escape_only}s}",  buf,  0x26u);
      }

      __int16 v29 = 0LL;
      goto LABEL_169;
    default:
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
      BOOL v36 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 67240448;
        *(_DWORD *)&uint8_t buf[4] = a2 & 3;
        *(_WORD *)unint64_t v91 = 1026;
        *(_DWORD *)&v91[2] = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_FAULT,  "#AuthPrompt Received response (%{public}d) for invalid/unrecognized response type (%{public}d)",  buf,  0xEu);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_171;
      }
      unint64_t v5 = v88;
      bzero(buf, 0x65CuLL);
      if (qword_101934980 == -1) {
        goto LABEL_94;
      }
      goto LABEL_211;
  }

  *(_BYTE *)(a2 + 1) = 1;
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_101879FD0);
  }
  int v61 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
  {
    __int16 v62 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315394;
    v192 = "alertCanceledBecauseSteps";
    v193 = 2048;
    v194 = v62;
    _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_DEBUG,  "CLFallImpactMetrics: Setting %s for impact at %f",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_101879FD0);
    }
    __int16 v156 = *(void *)(a1 + 8);
    v187 = 136315394;
    v188 = "alertCanceledBecauseSteps";
    v189 = 2048;
    v190 = v156;
    LODWORD(v186) = 22;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFallImpactMetrics: Setting %s for impact at %f",  (const char *)&v187,  v186);
    __int16 v158 = (uint8_t *)v157;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallImpactMetrics::processImpactCancelReason(ImpactContext &, ImpactCandidateEvent &, AlertCandidateEvent & , SOSCandidateEvent &) const",  "%s\n",  v157);
    if (v158 != buf) {
      free(v158);
    }
  }

  a4[18] = 1;
  int64_t v10 = *(void *)(a1 + 24);
  if ((v10 & 0x4000000000000LL) == 0)
  {
LABEL_28:
    if ((v10 & 0x8000000000000LL) == 0) {
      goto LABEL_29;
    }
    goto LABEL_199;
  }

  std::string::size_type result = *(float *)(a2 + 120);
  v5 |= 0x100000uLL;
  *unint64_t v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(float *)(a1 + 120) = result;
  unint64_t v4 = *v3;
  unint64_t v7 = *(void *)(a2 + 364);
  if ((*v3 & 0x400) == 0)
  {
LABEL_82:
    if ((v4 & 0x200000) == 0) {
      goto LABEL_83;
    }
    goto LABEL_189;
  }

  PB::TextFormatter::format(this, "shouldDeescalateBecauseOfStepsCondition", *(_BYTE *)(a1 + 349));
  unint64_t v7 = *v5;
  unint64_t v6 = *(void *)(a1 + 364);
  if ((v6 & 0x8000000000LL) == 0)
  {
LABEL_86:
    if ((v6 & 0x10000000000LL) == 0) {
      goto LABEL_87;
    }
    goto LABEL_189;
  }

  std::string::size_type result = PB::Writer::write(this, *(float *)(v3 + 120), 0x321u);
  unint64_t v5 = *v4;
  unint64_t v6 = v4[1];
  if ((*v4 & 0x400) == 0)
  {
LABEL_82:
    if ((v5 & 0x200000) == 0) {
      goto LABEL_83;
    }
    goto LABEL_189;
  }

void sub_1005401E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58,void *a59,uint64_t a60,int a61,__int16 a62,char a63)
{
  if (a58 < 0) {
    operator delete(__p);
  }
  if (a64 < 0) {
    operator delete(a59);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10054038C(const char *a1, void *a2)
{
  size_t v4 = strlen(a1);
  if (*((char *)a2 + 23) < 0)
  {
    if (v4 == a2[1])
    {
      if (v4 == -1LL) {
        goto LABEL_10;
      }
      a2 = (void *)*a2;
      return memcmp(a2, a1, v4) == 0;
    }
  }

  else if (v4 == *((unsigned __int8 *)a2 + 23))
  {
    if (v4 == -1LL) {
LABEL_10:
    }
      sub_1001040F8();
    return memcmp(a2, a1, v4) == 0;
  }

  return 0LL;
}

void sub_100540418(uint64_t a1, void *a2, CLConnectionMessage **a3)
{
  unint64_t v6 = operator new(0x1A8uLL);
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t Dictionary = CLConnectionMessage::getDictionary(*a3);
  sub_10086D2C8(v6, a2, a1, v7, Dictionary);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  BOOL v9 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    int64_t v10 = (uint64_t *)CLConnectionMessage::name(*a3);
    else {
      unint64_t v11 = (uint64_t *)*v10;
    }
    __int128 __p = (void *)68290050;
    *(_WORD *)unint64_t v18 = 2082;
    *(void *)&v18[2] = "";
    __int16 v19 = 2050;
    double v20 = v6;
    __int16 v21 = 2082;
    unint64_t v22 = v11;
    __int16 v23 = 2114;
    id v24 = sub_10086D1D8((uint64_t)v6, 0);
    __int16 v25 = 1026;
    int v26 = sub_100876178((uint64_t)v6);
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Created CLDC for connecting client, CLDC:%{public}p, ConnectingMessage:%{publ ic, location:escape_only}s, ClientKeyPath:%{public, location:escape_only}@, RegistrationComplete:%{public}hhd}",  (uint8_t *)&__p,  0x36u);
  }

  __int128 __p = a2;
  *(void *)unint64_t v18 = v6;
  sub_100587A00((uint64_t **)(a1 + 752), (unint64_t *)&__p, &__p);
  if (*(void *)(a1 + 768) == 1LL) {
    [*(id *)(*(void *)(a1 + 160) + 16) register:*(void *)(*(void *)(a1 + 160) + 8) forNotification:19 registrationInfo:0];
  }
  if (sub_100876178((uint64_t)v6))
  {
    id v12 = sub_10086D1D8((uint64_t)v6, 0);
    std::string::size_type v13 = v12;
    if (!v12)
    {
      sub_10123CDE8();
      __break(1u);
    }

    if ([v12 isAuthLimited])
    {
      sub_10088F314((uint64_t)v6, &__p);
      sub_100544214(a1, v13, (uint64_t)&__p);
      if (SBYTE3(v20) < 0) {
        operator delete(__p);
      }
    }

    else
    {
      uint64_t v14 = sub_10054B60C(a1, (uint64_t)v13, &xmmword_101339630);
      sub_10054BA24((id *)a1, (uint64_t)v13, (uint64_t)v14);
      std::string::size_type v15 = sub_100544790(a1, (uint64_t)v13, &xmmword_101339630);
      sub_100877950((uint64_t)v6, v15);
    }

    char v16 = sub_100544800(a1, (uint64_t)v13);
    sub_1008785FC((uint64_t)v6, v16);
  }

void sub_100540688( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005406B8(uint64_t a1, CLConnection *a2, CLConnectionMessage **a3, void *a4)
{
  unint64_t v8 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  objc_opt_class(&OBJC_CLASS___NSDateInterval),  0LL);
  DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a3, v8);
  id v10 = [DictionaryOfClasses objectForKey:@"kCLConnectionMessageClientKeyForIdentityValidation"];
  id v11 = sub_10053D6E0( a1,  (uint64_t)+[CLClientKeyPath clientKeyPathWithClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientKey:",  v10));
  Uniqueint RemotePid = CLConnection::getUniqueRemotePid(a2);
  if ((sub_100544EB8(a1, (uint64_t)v11, UniqueRemotePid) & 1) != 0)
  {
    if ((*((char *)a4 + 23) & 0x80000000) == 0)
    {
      int v13 = *((unsigned __int8 *)a4 + 23);
      if (v13 != 14)
      {
        if (v13 != 19)
        {
          if (v13 == 25)
          {
            if (*a4 != 0x6E6F697461636F4CLL
              || a4[1] != 0x4872657461647055LL
              || a4[2] != 0x616369726F747369LL
              || *((_BYTE *)a4 + 24) != 108)
            {
              if (*a4 != 0x756F72676B636142LL
                || a4[1] != 0x697669746341646ELL
                || a4[2] != 0x6F69737365537974LL
                || *((_BYTE *)a4 + 24) != 110)
              {
                goto LABEL_81;
              }

              goto LABEL_109;
            }

void sub_100540E60( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_100540EA0(uint64_t a1, CLConnection *a2, CLConnectionMessage **a3)
{
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___CLMonitoringRecord);
  uint64_t v6 = objc_opt_class(&OBJC_CLASS___CLMonitoringEvent);
  uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSString);
  uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSDate);
  uint64_t v10 = objc_opt_class(&OBJC_CLASS___CLCircularGeographicCondition);
  uint64_t v11 = objc_opt_class(&OBJC_CLASS___CLBeaconIdentityCondition);
  uint64_t v12 = objc_opt_class(&OBJC_CLASS___CLMinimumAltitudeCondition);
  uint64_t v23 = v11;
  int v13 = a2;
  uint64_t v14 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v5,  v6,  v7,  v8,  v9,  v10,  v23,  v12,  objc_opt_class(&OBJC_CLASS___CLCondition),  0LL);
  DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses(*a3, v14);
  id v16 = [DictionaryOfClasses objectForKey:@"kCLConnectionMessageClientKeyForIdentityValidation"];
  id v17 = sub_10053D6E0( a1,  (uint64_t)+[CLClientKeyPath clientKeyPathWithClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientKey:",  v16));
  Uniqueint RemotePid = CLConnection::getUniqueRemotePid(a2);
  if ((sub_100544EB8(a1, (uint64_t)v17, UniqueRemotePid) & 1) != 0)
  {
    uint64_t v19 = operator new(0x100uLL);
    sub_100BD5DB0(v19, v17, v13, a1, DictionaryOfClasses, *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 1504));
    __int128 __p = v13;
    *(void *)int v26 = v19;
    sub_100587A00((uint64_t **)(a1 + 824), (unint64_t *)&__p, &__p);
    sub_1010DDBC0( &__p,  (char *)-[NSString UTF8String]( +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%p", v19),  "UTF8String"));
    unsigned int v20 = (*(uint64_t (**)(void *))(*(void *)v19 + 24LL))(v19);
    __int16 v21 = (void *)(*(uint64_t (**)(void *))(*(void *)v19 + 40LL))(v19);
    sub_1005450B8(a1, (uint64_t)v17, (uint64_t *)&__p, v20, v21, 1);
    if (SBYTE3(v28) < 0) {
      operator delete(__p);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unint64_t v22 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      __int128 __p = (void *)68289794;
      *(_WORD *)int v26 = 2082;
      *(void *)&v26[2] = "";
      __int16 v27 = 2082;
      id v28 = [v16 UTF8String];
      __int16 v29 = 2050;
      uint64_t v30 = UniqueRemotePid;
      __int16 v31 = 1026;
      int v32 = (unsigned __int16)UniqueRemotePid;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#warning Cannot create DaemonIdentifiableMonitor, IdentityToBeValidated:%{public, l ocation:escape_only}s, ConnectedClientUniquePid:%{public}lld, ConnectedClientPid:%{public}d}",  (uint8_t *)&__p,  0x2Cu);
    }
  }

void sub_1005411A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
}

void sub_1005411D4(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x20uLL);
  sub_10080D92C(v6, a2, *(void *)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*(void *)v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*(void *)v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    id v24 = v16;
    id v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLMo tionActivityLiteClient]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100587960;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*(void *)v6 + 16LL))(v6, &v18);
  uint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_1005414E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100541510(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x28uLL);
  sub_100AE3598(v6, (uint64_t)a2, *(void *)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    id v24 = v16;
    id v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDa emonInUseAssertion]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100587AB8;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*v6 + 16LL))(v6, &v18);
  uint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_100541820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_10054184C(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x20uLL);
  sub_100FD81C8(v6, (uint64_t)a2, *(void *)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    id v24 = v16;
    id v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDa emonLocationIndependenceAssertion]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100587B58;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*v6 + 16LL))(v6, &v18);
  uint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_100541B5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100541B88(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x18uLL);
  sub_100E74D78(v6, (uint64_t)a2, *(void *)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    id v24 = v16;
    id v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDa emonBBTimeFreqTransferCallbackAssertion]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100587BF8;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*v6 + 16LL))(v6, &v18);
  uint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_100541E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100541EC4(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x38uLL);
  sub_100FD90A0(v6, a2, *(void *)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*(void *)v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*(void *)v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    id v24 = v16;
    id v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDa emonGnssDisablementAssertion]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100587C98;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*(void *)v6 + 16LL))(v6, &v18);
  uint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_1005421D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100542200(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x68uLL);
  sub_1002CEAD8((uint64_t)v6, (uint64_t)a2, *(void *)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*(void *)v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*(void *)v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    id v24 = v16;
    id v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLGN SSStateQueryAssertion]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100587D38;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*(void *)v6 + 16LL))(v6, &v18);
  uint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_100542510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_10054253C(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x58uLL);
  sub_1008E0E18((uint64_t)v6, (uint64_t)a2, *(void *)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*(void *)v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*(void *)v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    id v24 = v16;
    id v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDa emonEmergencyEnablementAssertion]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100587DD8;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*(void *)v6 + 16LL))(v6, &v18);
  uint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_10054284C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100542878(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x18uLL);
  sub_10031CCF8(v6, (uint64_t)a2, *(void *)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    id v24 = v16;
    id v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDa emonGnssExtensionsClient]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100587E78;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*v6 + 16LL))(v6, &v18);
  uint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_100542B88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100542BB4(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x30uLL);
  sub_100CFF38C(v6, a2, *(void *)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*(void *)v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*(void *)v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    id v24 = v16;
    id v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDa emonHealthClient]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100587F18;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*(void *)v6 + 16LL))(v6, &v18);
  uint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_100542EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100542EF0(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x28uLL);
  sub_100F679B4(v6, a2, *(void *)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*(void *)v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*(void *)v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    id v24 = v16;
    id v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDa emonSpringTrackingClient]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100587FB8;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*(void *)v6 + 16LL))(v6, &v18);
  uint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_100543200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_10054322C(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x28uLL);
  sub_100CC64D4(v6, a2, *(void *)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*(void *)v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*(void *)v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    id v24 = v16;
    id v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLDi stributedSensingSubscription]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100588058;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*(void *)v6 + 16LL))(v6, &v18);
  uint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_10054353C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100543568(uint64_t a1, CLConnectionMessage **a2)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  size_t v4 = (os_log_s *)qword_101934988;
  BOOL v5 = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    uint64_t v6 = (void *)(a1 + 40);
    uint64_t v7 = (uint64_t *)CLConnectionMessage::name(*a2);
    else {
      uint64_t v8 = (uint64_t *)*v7;
    }
    *(_DWORD *)__int128 buf = 68289538;
    int v17 = 0;
    __int16 v18 = 2082;
    uint64_t v19 = "";
    __int16 v20 = 2082;
    __int16 v21 = v6;
    __int16 v22 = 2082;
    int v23 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Received message from #CoreLocationAgent, User:%{public, location:escape_only}s, me ssage:%{public, location:escape_only}s}",  buf,  0x26u);
  }

  uint64_t v9 = *a2;
  uint64_t v10 = a2[1];
  v15[0] = v9;
  v15[1] = v10;
  if (v10)
  {
    unint64_t v11 = (unint64_t *)((char *)v10 + 8);
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  sub_1005436F4(v5, v15);
  if (v10)
  {
    int v13 = (unint64_t *)((char *)v10 + 8);
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      (*(void (**)(CLConnectionMessage *))(*(void *)v10 + 16LL))(v10);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v10);
    }
  }

void sub_1005436E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005436F4(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v3 = (void *)CLConnectionMessage::name(*a2);
  int v4 = *((char *)v3 + 23);
  if (v4 < 0)
  {
    if (v3[1] != 38LL) {
      goto LABEL_7;
    }
    uint64_t v3 = (void *)*v3;
  }

  else if (v4 != 38)
  {
LABEL_7:
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      uint64_t v6 = CLConnectionMessage::name(*a2);
      uint64_t v7 = *(char *)(v6 + 23) >= 0 ? (char *)v6 : *(char **)v6;
      int v25 = 68289282;
      int v26 = 0;
      __int16 v27 = 2082;
      id v28 = "";
      __int16 v29 = 2082;
      uint64_t v30 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#CoreLocationAgent defaultMessageHandler received un-handled messaeg, message:%{pub lic, location:escape_only}s}",  (uint8_t *)&v25,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v8 = qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      uint64_t v9 = (char *)CLConnectionMessage::name(*a2);
      if (v9[23] >= 0) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = *(char **)v9;
      }
      int v25 = 68289282;
      int v26 = 0;
      __int16 v27 = 2082;
      id v28 = "";
      __int16 v29 = 2082;
      uint64_t v30 = v10;
      unint64_t v11 = "#CoreLocationAgent defaultMessageHandler received un-handled messaeg";
      unint64_t v12 = "{msg%{public}.0s:#CoreLocationAgent defaultMessageHandler received un-handled messaeg, message:%"
            "{public, location:escape_only}s}";
      int v13 = (os_log_s *)v8;
      goto LABEL_20;
    }

    return;
  }

  if (memcmp(v3, "kCLConnectionMessageAuthPromptResponse", 0x26uLL)) {
    goto LABEL_7;
  }
  uint64_t Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
  id v16 = [Dictionary allKeys];
  if ([v16 containsObject:@"uuid"]
    && [v16 containsObject:@"pid"]
    && ([v16 containsObject:@"response"] & 1) != 0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v17 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      uint64_t v18 = CLConnectionMessage::name(*a2);
      uint64_t v19 = *(char *)(v18 + 23) >= 0 ? (char *)v18 : *(char **)v18;
      int v25 = 68289538;
      int v26 = 0;
      __int16 v27 = 2082;
      id v28 = "";
      __int16 v29 = 2082;
      uint64_t v30 = v19;
      __int16 v31 = 2114;
      int v32 = Dictionary;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#AuthPrompt response from #CoreLocationAgent is not yet supported on this platform, m essage:%{public, location:escape_only}s, resposne:%{public, location:escape_only}@}",  (uint8_t *)&v25,  0x26u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v20 = qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      __int16 v21 = (char *)CLConnectionMessage::name(*a2);
      if (v21[23] >= 0) {
        __int16 v22 = v21;
      }
      else {
        __int16 v22 = *(char **)v21;
      }
      int v25 = 68289538;
      int v26 = 0;
      __int16 v27 = 2082;
      id v28 = "";
      __int16 v29 = 2082;
      uint64_t v30 = v22;
      __int16 v31 = 2114;
      int v32 = Dictionary;
      unint64_t v11 = "#AuthPrompt response from #CoreLocationAgent is not yet supported on this platform";
      unint64_t v12 = "{msg%{public}.0s:#AuthPrompt response from #CoreLocationAgent is not yet supported on this platform,"
            " message:%{public, location:escape_only}s, resposne:%{public, location:escape_only}@}";
      int v13 = (os_log_s *)v20;
      uint32_t v14 = 38;
      goto LABEL_21;
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v23 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      int v25 = 68289282;
      int v26 = 0;
      __int16 v27 = 2082;
      id v28 = "";
      __int16 v29 = 2114;
      uint64_t v30 = (char *)Dictionary;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#AuthPrompt auth response from #CoreLocationAgent is malformed. Don't apply auth-response , resposne:%{public, location:escape_only}@}",  (uint8_t *)&v25,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v24 = qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      int v25 = 68289282;
      int v26 = 0;
      __int16 v27 = 2082;
      id v28 = "";
      __int16 v29 = 2114;
      uint64_t v30 = (char *)Dictionary;
      unint64_t v11 = "#AuthPrompt auth response from #CoreLocationAgent is malformed. Don't apply auth-response";
      unint64_t v12 = "{msg%{public}.0s:#AuthPrompt auth response from #CoreLocationAgent is malformed. Don't apply auth-resp"
            "onse, resposne:%{public, location:escape_only}@}";
      int v13 = (os_log_s *)v24;
LABEL_20:
      uint32_t v14 = 28;
LABEL_21:
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v11,  v12,  (uint8_t *)&v25,  v14);
    }
  }

void sub_100543BC8(uint64_t a1, CLConnection *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x78uLL);
  sub_100213EA4((uint64_t)v6, (uint64_t)a2, *(void **)(a1 + 32));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(void **__return_ptr, void *))(*(void *)v6 + 24LL))(__p, v6);
    uint64_t v8 = v26 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client %{public}s connected", buf, 0xCu);
    if (v26 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    (*(void (**)(_BYTE *__return_ptr, void *))(*(void *)v6 + 24LL))(buf, v6);
    if (v22 >= 0) {
      id v16 = buf;
    }
    else {
      id v16 = *(_BYTE **)buf;
    }
    int v23 = 136446210;
    uint64_t v24 = v16;
    int v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "Client %{public}s connected",  &v23,  12);
    if (v22 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createGenericClient(CLConnection *, std::shared_ptr<CLConnectionMessage>) [ClientType = CLPe destrianFenceClient]",  "%s\n",  v17);
  }

  __p[0] = a2;
  __p[1] = v6;
  sub_100587A00((uint64_t **)(a1 + 776), (unint64_t *)__p, __p);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100588188;
  v20[3] = &unk_10182B3E0;
  v20[4] = v6;
  CLConnection::setDefaultMessageHandler(a2, v20);
  CLConnection::start(a2);
  uint64_t v9 = (std::__shared_weak_count *)a3[1];
  uint64_t v18 = *a3;
  uint64_t v19 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(p_shared_owners);
    while (__stxr(v11 + 1, p_shared_owners));
  }

  (*(void (**)(void *, uint64_t *))(*(void *)v6 + 16LL))(v6, &v18);
  unint64_t v12 = v19;
  if (v19)
  {
    int v13 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_100543ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100543F04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = operator new(0x1A8uLL);
  sub_10086D2C8(v6, a2, a1, *(void *)(a1 + 32), 0LL);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = sub_10086D1D8((uint64_t)v6, 0);
    uint64_t v9 = (uint64_t *)CLConnectionMessage::name(*(CLConnectionMessage **)a3);
    else {
      uint64_t v10 = (uint64_t *)*v9;
    }
    *(_DWORD *)__int128 buf = 138543618;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&_BYTE buf[12] = 2082;
    *(void *)&buf[14] = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Client %{public}@ connected with message name %{public}s.",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v17 = qword_101934988;
    id v18 = sub_10086D1D8((uint64_t)v6, 0);
    uint64_t v19 = (uint64_t *)CLConnectionMessage::name(*(CLConnectionMessage **)a3);
    else {
      uint64_t v20 = (uint64_t *)*v19;
    }
    int v24 = 138543618;
    id v25 = v18;
    __int16 v26 = 2082;
    __int16 v27 = v20;
    __int16 v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v17,  0LL,  "Client %{public}@ connected with message name %{public}s.",  &v24,  22);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::createFallbackDaemonClient(CLConnection *, std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v21);
    if (v21 != buf) {
      free(v21);
    }
  }

  *(void *)__int128 buf = a2;
  *(void *)&uint8_t buf[8] = v6;
  sub_100587A00((uint64_t **)(a1 + 752), (unint64_t *)buf, buf);
  if (*(void *)(a1 + 768) == 1LL) {
    [*(id *)(*(void *)(a1 + 160) + 16) register:*(void *)(*(void *)(a1 + 160) + 8) forNotification:19 registrationInfo:0];
  }
  unint64_t v11 = *(std::__shared_weak_count **)(a3 + 8);
  char v22 = *(CLConnectionMessage **)a3;
  int v23 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }

  sub_10086DB30((uint64_t)v6, &v22);
  unint64_t v14 = v23;
  if (v23)
  {
    uint64_t v15 = (unint64_t *)&v23->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

void sub_1005441E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100544214(uint64_t a1, void *a2, uint64_t a3)
{
  id v6 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  unsigned int v7 = [v6 isAuthLimited];
  if (v7) {
    id v6 = [*(id *)(a1 + 136) primaryKeyPathForAuthLimitedKeyPath:v6];
  }
  id v8 = sub_10054B60C(a1, (uint64_t)v6, &xmmword_101339630);
  unsigned int v40 = [v6 isValidCKP];
  if (v40)
  {
    if (((v7 | sub_10054BA24((id *)a1, (uint64_t)v6, (uint64_t)v8)) & 1) == 0)
    {
      uint64_t v9 = *(unsigned __int8 *)(a3 + 23);
      if ((v9 & 0x80u) != 0LL) {
        uint64_t v9 = *(void *)(a3 + 8);
      }
      if (!v9) {
        return 0LL;
      }
    }

    sub_10054C8BC(a1, (uint64_t)v6, (uint64_t)v8);
  }

  else
  {
    objc_msgSend(*(id *)(a1 + 1016), "removeObjectForKey:", objc_msgSend(a2, "legacyClientKey"));
    objc_msgSend( *(id *)(a1 + 1008),  "setClientsAuthorizationMap:",  objc_msgSend(*(id *)(a1 + 1016), "copy"));
    [a2 isValidCKP];
    objc_msgSend( *(id *)(a1 + 1008),  "setPersistentStoreDictionary:forClient:",  0,  objc_msgSend(a2, "legacyClientKey"));
    id v6 = a2;
  }

  uint64_t v10 = *(void **)(a1 + 752);
  if (v10 != (void *)(a1 + 760))
  {
    do
    {
      id v11 = sub_10086D1D8(v10[5], 0);
      sub_10088F314(v10[5], __p);
      if ([v11 isAuthLimited])
      {
        id v12 = [*(id *)(a1 + 136) primaryKeyPathForAuthLimitedKeyPath:v11];
        id v13 = [v11 limitingCKP];
        if (sub_100554584(a1, v6, v12))
        {
          unint64_t v14 = sub_100544790(a1, (uint64_t)v13, &xmmword_101339630);
          uint64_t v15 = v8;
          if (!v8) {
            goto LABEL_35;
          }
        }

        else
        {
          if (!sub_100554584(a1, v6, v13)) {
            goto LABEL_35;
          }
          uint64_t v15 = sub_100544790(a1, (uint64_t)v12, &xmmword_101339630);
          unint64_t v14 = v8;
          if (!v15) {
            goto LABEL_35;
          }
        }

        if (v14)
        {
          unsigned int v18 = -[CLClientManagerAuthorizationContext isAuthorizedForServiceType:]( v14,  "isAuthorizedForServiceType:",  12LL);
          int v19 = -[CLClientManagerAuthorizationContext transientAwareRegistrationResult]( v14,  "transientAwareRegistrationResult");
          int v20 = v18 ? 1 : 2;
          uint64_t v21 = sub_10029764C(v19, 5, v20, 0, 0LL, 0, 0);
          int v23 = -[CLClientManagerAuthorizationContext authorizationContextByANDingServiceMaskTuple:]( v15,  "authorizationContextByANDingServiceMaskTuple:",  v21,  v22);
          if (v23 != v15)
          {
            if (qword_101934970 != -1) {
              dispatch_once(&qword_101934970, &stru_101840220);
            }
            int v24 = (os_log_s *)qword_101934978;
            if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEBUG))
            {
              id v25 = __p;
              if (v42 < 0) {
                id v25 = (void **)__p[0];
              }
              *(_DWORD *)__int128 buf = 68289538;
              *(_DWORD *)&uint8_t buf[4] = 0;
              *(_WORD *)id v44 = 2082;
              *(void *)&v44[2] = "";
              *(_WORD *)&v44[10] = 2114;
              *(void *)&v44[12] = v11;
              *(_WORD *)&v44[20] = 2082;
              *(void *)&v44[22] = v25;
              _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Limiting identity's service-mask imposed on specified identity, AffectedIdent ity:%{public, location:escape_only}@, AffectedSubIdentity:%{public, location:escape_only}s}",  buf,  0x26u);
            }

            uint64_t v15 = v23;
          }
        }
      }

      else
      {
        BOOL v16 = sub_100554584(a1, v6, v11);
        if (v8) {
          BOOL v17 = v16;
        }
        else {
          BOOL v17 = 0;
        }
        uint64_t v15 = v8;
        if (!v17) {
          goto LABEL_35;
        }
      }

      sub_100877950(v10[5], v15);
LABEL_35:
      if (v42 < 0) {
        operator delete(__p[0]);
      }
      __int16 v26 = (void *)v10[1];
      if (v26)
      {
        do
        {
          __int16 v27 = v26;
          __int16 v26 = (void *)*v26;
        }

        while (v26);
      }

      else
      {
        do
        {
          __int16 v27 = (void *)v10[2];
          BOOL v28 = *v27 == (void)v10;
          uint64_t v10 = v27;
        }

        while (!v28);
      }

      uint64_t v10 = v27;
    }

    while (v27 != (void *)(a1 + 760));
  }

  __int16 v29 = *(void **)(a1 + 824);
  if (v29 != (void *)(a1 + 832))
  {
    do
    {
      uint64_t v30 = (void *)sub_100019240(v29[5]);
      if (sub_100554584(a1, v6, v30)) {
        sub_100D558A8((id *)v29[5], v8);
      }
      __int16 v31 = (void *)v29[1];
      if (v31)
      {
        do
        {
          int v32 = v31;
          __int16 v31 = (void *)*v31;
        }

        while (v31);
      }

      else
      {
        do
        {
          int v32 = (void *)v29[2];
          BOOL v28 = *v32 == (void)v29;
          __int16 v29 = v32;
        }

        while (!v28);
      }

      __int16 v29 = v32;
    }

    while (v32 != (void *)(a1 + 832));
  }

  uint64_t v33 = *(void **)(a1 + 848);
  if (v33 != (void *)(a1 + 856))
  {
    do
    {
      uint64_t v34 = (id *)v33[4];
      BOOL v35 = (void *)sub_100019240((uint64_t)v34);
      if (sub_100554584(a1, v6, v35)) {
        sub_100D558A8(v34, v8);
      }
      BOOL v36 = (void *)v33[1];
      if (v36)
      {
        do
        {
          __int16 v37 = v36;
          BOOL v36 = (void *)*v36;
        }

        while (v36);
      }

      else
      {
        do
        {
          __int16 v37 = (void *)v33[2];
          BOOL v28 = *v37 == (void)v33;
          uint64_t v33 = v37;
        }

        while (!v28);
      }

      uint64_t v33 = v37;
    }

    while (v37 != (void *)(a1 + 856));
  }

  if ((v40 & 1) != 0)
  {
    id v38 = *(void **)(a1 + 136);
    *(void *)__int128 buf = _NSConcreteStackBlock;
    *(void *)id v44 = 3221225472LL;
    *(void *)&v44[8] = sub_100554B60;
    *(void *)&v44[16] = &unk_10183FB60;
    *(void *)&v44[24] = v6;
    uint64_t v45 = a1;
    [v38 iterateIdentitiesRelatedToKeyPath:v6 withBlock:buf];
    sub_10055478C(a1, (uint64_t)v6);
  }

  return 1LL;
}

void sub_100544720( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100544758(id *a1, uint64_t a2)
{
  int v4 = sub_10054B60C((uint64_t)a1, a2, &xmmword_101339630);
  return sub_10054BA24(a1, a2, (uint64_t)v4);
}

CLClientManagerAuthorizationContext *sub_100544790(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  id v5 = sub_10053D6E0(a1, a2);
  else {
    return (CLClientManagerAuthorizationContext *)objc_msgSend( *(id *)(a1 + 1016),  "objectForKeyedSubscript:",  objc_msgSend(v5, "legacyClientKey"));
  }
}

uint64_t sub_100544800(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if ([v3 bundleId] || objc_msgSend(v3, "bundlePath"))
  {
    if ([v3 isValidCKP]) {
      return (uint64_t)[*(id *)(a1 + 136) BOOLForKey:@"BackgroundIndicatorEnabled" atKeyPath:v3 defaultValue:1];
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138543362;
      id v10 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#Error no bundle ID or bundle path found - enabling background indicator %{public}@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v7 = 138543362;
      id v8 = v3;
      id v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#Error no bundle ID or bundle path found - enabling background indicator %{public}@",  &v7,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::getClientBackgroundIndicatorEnabled(CLClientKeyPath *)",  "%s\n",  v6);
    }
  }

  return 1LL;
}

void sub_100544A24(uint64_t a1, CLConnection *a2, CLConnectionMessage **a3)
{
  id v6 = *(void **)(a1 + 760);
  if (!v6) {
    goto LABEL_12;
  }
  id v5 = a3;
  id v3 = a2;
  uint64_t v4 = a1;
  int v7 = (void *)(a1 + 760);
  do
  {
    unint64_t v8 = v6[4];
    BOOL v9 = v8 >= (unint64_t)a2;
    else {
      id v10 = v6 + 1;
    }
    if (v9) {
      int v7 = v6;
    }
    id v6 = (void *)*v10;
  }

  while (*v10);
  if (v7 == (void *)(a1 + 760) || v7[4] > (unint64_t)a2) {
LABEL_12:
  }
    sub_10123CF5C();
  if (!sub_100876168(v7[5]))
  {
    BOOL v17 = (_Unwind_Exception *)sub_10123D0D0();
    sub_10000AE14((uint64_t)v18);
    _Unwind_Resume(v17);
  }

  sub_100544B40(v4, v3);
  id v11 = *v5;
  id v12 = v5[1];
  v18[0] = v11;
  v18[1] = v12;
  if (v12)
  {
    id v13 = (unint64_t *)((char *)v12 + 8);
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  sub_10053EF50(v4, v3, v18);
  if (v12)
  {
    uint64_t v15 = (unint64_t *)((char *)v12 + 8);
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      (*(void (**)(CLConnectionMessage *))(*(void *)v12 + 16LL))(v12);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v12);
    }
  }

void sub_100544B40(uint64_t a1, CLConnection *a2)
{
  id v6 = *(void **)(a1 + 760);
  if (!v6) {
    goto LABEL_12;
  }
  id v5 = a2;
  uint64_t v2 = a1;
  id v3 = (uint64_t **)(a1 + 752);
  uint64_t v4 = (uint64_t *)(a1 + 760);
  do
  {
    unint64_t v7 = v6[4];
    BOOL v8 = v7 >= (unint64_t)a2;
    else {
      BOOL v9 = v6 + 1;
    }
    if (v8) {
      uint64_t v4 = v6;
    }
    id v6 = (void *)*v9;
  }

  while (*v9);
  if (v4 == (uint64_t *)(a1 + 760) || v4[4] > (unint64_t)a2)
  {
LABEL_12:
    sub_10123D244();
    __break(1u);
  }

  uint64_t v10 = v4[5];
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v11 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138543362;
    *(void *)uint64_t v22 = sub_10086D1D8(v10, 0);
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Client %{public}@ disconnected", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v17 = qword_101934988;
    int v19 = 138543362;
    id v20 = sub_10086D1D8(v10, 0);
    unsigned int v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v17,  0LL,  "Client %{public}@ disconnected",  &v19,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::handleDaemonClientDisconnection(CLConnection *)",  "%s\n",  v18);
  }

  if (sub_100876178(v10))
  {
    id v12 = sub_10086D1D8(v10, 0);
    Uniqueint RemotePid = CLConnection::getUniqueRemotePid(v5);
    sub_100561D58(v2, (uint64_t)v12, UniqueRemotePid, 0);
  }

  if (sub_100876178(v10))
  {
    id v14 = sub_10086D1D8(v10, 0);
    if (([v14 isValidCKP] & 1) == 0)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v15 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 68289282;
        *(_DWORD *)uint64_t v22 = 0;
        *(_WORD *)&v22[4] = 2082;
        *(void *)&v22[6] = "";
        __int16 v23 = 2050;
        uint64_t v24 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning Disconnecting client has successful registration, but no valid CKP, CLDC :%{public}p}",  buf,  0x1Cu);
      }
    }

    sub_10054B118(v2, (uint64_t)v14, v10);
    sub_10054B0AC(v2, v10, 0);
  }

  uint64_t v16 = v4[5];
  sub_1000087E8(v3, v4);
  operator delete(v4);
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
  }
  if (!*(void *)(v2 + 768)) {
    [*(id *)(*(void *)(v2 + 160) + 16) unregister:*(void *)(*(void *)(v2 + 160) + 8) forNotification:19];
  }
}

id sub_100544EB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = sub_10053D6E0(a1, a2);
  id v6 = [*(id *)(a1 + 360) objectForKey:v5];
  id v7 = objc_msgSend( v6,  "containsObject:",  +[NSNumber numberWithLongLong:](NSNumber, "numberWithLongLong:", a3));
  if ((v7 & 1) != 0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v8 = qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 68289794;
      int v15 = 0;
      __int16 v16 = 2082;
      uint64_t v17 = "";
      __int16 v18 = 2114;
      id v19 = v5;
      __int16 v20 = 2050;
      uint64_t v21 = a3;
      __int16 v22 = 1026;
      int v23 = (unsigned __int16)a3;
      BOOL v9 = "{msg%{public}.0s:#identityValidation successful, Identity:%{public, location:escape_only}@, Con"
           "nectedClientUniquePid:%{public}lld, ConnectedClientPid:%{public}d}";
      uint64_t v10 = (os_log_s *)v8;
      uint32_t v11 = 44;
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v14, v11);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v12 = qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 68290050;
      int v15 = 0;
      __int16 v16 = 2082;
      uint64_t v17 = "";
      __int16 v18 = 2114;
      id v19 = v5;
      __int16 v20 = 2050;
      uint64_t v21 = a3;
      __int16 v22 = 1026;
      int v23 = (unsigned __int16)a3;
      __int16 v24 = 2114;
      id v25 = v6;
      BOOL v9 = "{msg%{public}.0s:#warning #identityValidation Identity invalid for connected client, Identity:%{p"
           "ublic, location:escape_only}@, ConnectedClientUniquePid:%{public}lld, ConnectedClientPid:%{public}d, "
           "AllowedUniquePids:%{public, location:escape_only}@}";
      uint64_t v10 = (os_log_s *)v12;
      uint32_t v11 = 54;
      goto LABEL_10;
    }
  }

  return v7;
}

void sub_1005450B8(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int a4, void *a5, int a6)
{
  __int16 v29 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  id v11 = sub_10053D6E0(a1, a2);
  if (([*(id *)(a1 + 136) dictionaryExistsAtKeyPath:v11] & 1) == 0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_38;
    }
    else {
      __int16 v16 = (uint64_t *)*a3;
    }
    *(_DWORD *)__int128 buf = 68289794;
    int v31 = 0;
    __int16 v32 = 2082;
    uint64_t v33 = "";
    __int16 v34 = 2114;
    id v35 = v11;
    __int16 v36 = 2082;
    __int16 v37 = v16;
    __int16 v38 = 1026;
    unsigned int v39 = a4;
    uint64_t v17 = "{msg%{public}.0s:skip persisting #dic for rehydration. Client not found, Client:%{public, location"
          ":escape_only}@, dic:%{public, location:escape_only}s, dicType:%{public}d}";
LABEL_13:
    __int16 v18 = (os_log_s *)v15;
    uint32_t v19 = 44;
LABEL_37:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
    goto LABEL_38;
  }

  if (a6 && ![a5 count])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = qword_101934988;
    if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_38;
    }
    else {
      __int16 v27 = (uint64_t *)*a3;
    }
    *(_DWORD *)__int128 buf = 68289794;
    int v31 = 0;
    __int16 v32 = 2082;
    uint64_t v33 = "";
    __int16 v34 = 2114;
    id v35 = v11;
    __int16 v36 = 2082;
    __int16 v37 = v27;
    __int16 v38 = 1026;
    unsigned int v39 = a4;
    uint64_t v17 = "{msg%{public}.0s:skip persisting #dic for rehydration, payload is empty, Client:%{public, location"
          ":escape_only}@, dic:%{public, location:escape_only}s, dicType:%{public}d}";
    goto LABEL_13;
  }

  uint64_t v12 = -[NSNumber stringValue]( +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a4),  "stringValue");
  id v13 =  objc_msgSend( objc_msgSend( *(id *)(a1 + 136),  "dictionaryForKey:atKeyPath:defaultValue:",  @"DIC",  v11,  +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary")),  "mutableCopy");
  if ([v13 objectForKeyedSubscript:v12]) {
    id v14 = objc_msgSend(objc_msgSend(v13, "objectForKeyedSubscript:", v12), "mutableCopy");
  }
  else {
    id v14 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  }
  __int16 v20 = v14;
  else {
    uint64_t v21 = (uint64_t *)*a3;
  }
  if (a6)
  {
    objc_msgSend( v14,  "removeObjectForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v21));
    else {
      __int16 v22 = (uint64_t *)*a3;
    }
    objc_msgSend( v20,  "setObject:forKeyedSubscript:",  a5,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v22));
  }

  else
  {
    objc_msgSend( v14,  "removeObjectForKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v21));
  }

  if ([v20 count]) {
    [v13 setObject:v20 forKeyedSubscript:v12];
  }
  else {
    [v13 removeObjectForKey:v12];
  }
  id v23 = [v13 count];
  __int16 v24 = *(void **)(a1 + 136);
  if (v23) {
    [v24 setDictionary:v13 forKey:@"DIC" atKeyPath:v11];
  }
  else {
    [v24 removeValueForKey:@"DIC" atKeyPath:v11];
  }
  [*(id *)(a1 + 136) persist];
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v25 = qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    else {
      __int16 v26 = (uint64_t *)*a3;
    }
    *(_DWORD *)__int128 buf = 68290306;
    int v31 = 0;
    __int16 v32 = 2082;
    uint64_t v33 = "";
    __int16 v34 = 2114;
    id v35 = v11;
    __int16 v36 = 2082;
    __int16 v37 = v26;
    __int16 v38 = 1026;
    unsigned int v39 = a4;
    __int16 v40 = 1026;
    int v41 = a6;
    __int16 v42 = 2114;
    uint64_t v43 = a5;
    uint64_t v17 = "{msg%{public}.0s:updated persistent-store for #dic rehydration, Client:%{public, location:escape_o"
          "nly}@, dic:%{public, location:escape_only}s, dicType:%{public}d, coming:%{public}hhd, Rehydratio"
          "nPayload:%{public, location:escape_only}@}";
    __int16 v18 = (os_log_s *)v25;
    uint32_t v19 = 60;
    goto LABEL_37;
  }

void sub_10054550C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_100545548(uint64_t a1)
{
  uint64_t v2 = *(CLConnectionServer **)(a1 + 744);
  if (v2)
  {
    CLConnectionServer::~CLConnectionServer(v2);
    operator delete(v3);
  }

  sub_1005455A0(a1);
  uint64_t v4 = *(CLConnection **)(a1 + 872);
  if (v4)
  {
    CLConnection::deferredDelete(v4);
    *(void *)(a1 + 872) = 0LL;
  }

  [*(id *)(a1 + 248) invalidate];

  *(void *)(a1 + 248) = 0LL;
}

void sub_1005455A0(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  id v3 = *(void **)(a1 + 752);
  if (v3 != (void *)(a1 + 760))
  {
    do
    {
      uint64_t v4 = (void *)v3[1];
      id v5 = v3;
      if (v4)
      {
        do
        {
          id v6 = v4;
          uint64_t v4 = (void *)*v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          id v6 = (void *)v5[2];
          BOOL v7 = *v6 == (void)v5;
          id v5 = v6;
        }

        while (!v7);
      }

      sub_1005456DC(a1, (CLConnection *)v3[4]);
      id v3 = v6;
    }

    while (v6 != (void *)(a1 + 760));
  }

  objc_autoreleasePoolPop(v2);
}

void sub_100545628(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if ([v3 isValidCKP])
  {
    uint64_t v4 = *(void **)(a1 + 752);
    if (v4 != (void *)(a1 + 760))
    {
      do
      {
        id v5 = (void *)v4[1];
        id v6 = v4;
        if (v5)
        {
          do
          {
            BOOL v7 = v5;
            id v5 = (void *)*v5;
          }

          while (v5);
        }

        else
        {
          do
          {
            BOOL v7 = (void *)v6[2];
            BOOL v8 = *v7 == (void)v6;
            id v6 = v7;
          }

          while (!v8);
        }

        BOOL v9 = (CLConnection *)v4[4];
        uint64_t v4 = v7;
      }

      while (v7 != (void *)(a1 + 760));
    }
  }

void sub_1005456DC(uint64_t a1, CLConnection *this)
{
  uint64_t v4 = *(void **)(a1 + 760);
  if (v4)
  {
    uint64_t v5 = a1 + 760;
    do
    {
      unint64_t v6 = v4[4];
      BOOL v7 = v6 >= (unint64_t)this;
      else {
        BOOL v8 = v4 + 1;
      }
      if (v7) {
        uint64_t v5 = (uint64_t)v4;
      }
      uint64_t v4 = (void *)*v8;
    }

    while (*v8);
    if (v5 != a1 + 760 && *(void *)(v5 + 32) <= (unint64_t)this)
    {
      sub_100544B40(a1, this);
      return;
    }
  }

  BOOL v9 = *(void **)(a1 + 784);
  if (v9)
  {
    uint64_t v10 = a1 + 784;
    do
    {
      unint64_t v11 = v9[4];
      BOOL v12 = v11 >= (unint64_t)this;
      else {
        id v13 = v9 + 1;
      }
      if (v12) {
        uint64_t v10 = (uint64_t)v9;
      }
      BOOL v9 = (void *)*v13;
    }

    while (*v13);
    if (v10 != a1 + 784 && *(void *)(v10 + 32) <= (unint64_t)this)
    {
      sub_100558B8C(a1, this);
      return;
    }
  }

  id v14 = *(void **)(a1 + 832);
  if (v14)
  {
    uint64_t v15 = a1 + 832;
    do
    {
      unint64_t v16 = v14[4];
      BOOL v17 = v16 >= (unint64_t)this;
      else {
        __int16 v18 = v14 + 1;
      }
      if (v17) {
        uint64_t v15 = (uint64_t)v14;
      }
      id v14 = (void *)*v18;
    }

    while (*v18);
    if (v15 != a1 + 832 && *(void *)(v15 + 32) <= (unint64_t)this)
    {
      __int128 __p = *(void **)(v15 + 40);
      sub_100D56550(__p);
      sub_1001145B0((uint64_t **)(a1 + 848), (unint64_t *)&__p, (uint64_t *)&__p);
      sub_1000087E8((uint64_t **)(a1 + 824), (uint64_t *)v15);
      uint64_t v30 = (void *)v15;
LABEL_78:
      operator delete(v30);
      return;
    }
  }

  if (*(CLConnection **)(a1 + 872) == this)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v28 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      CLConnection::getName(*(CLConnection **)(a1 + 872));
      __int16 v29 = SBYTE3(v46) >= 0 ? &__p : (void **)__p;
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Client %{public}s disconnected", buf, 0xCu);
      if (SBYTE3(v46) < 0) {
        operator delete(__p);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v35 = qword_101934988;
      CLConnection::getName(*(CLConnection **)(a1 + 872));
      if (v41 >= 0) {
        __int16 v36 = buf;
      }
      else {
        __int16 v36 = *(_BYTE **)buf;
      }
      *(_DWORD *)__int16 v38 = 136446210;
      *(void *)&v38[4] = v36;
      __int16 v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v35,  0LL,  "Client %{public}s disconnected",  v38,  12);
      if (v41 < 0) {
        operator delete(*(void **)buf);
      }
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::handleDisconnection(CLConnection *)", "%s\n", v37);
    }

    CLConnection::deferredDelete(*(CLConnection **)(a1 + 872));
    *(void *)(a1 + 872) = 0LL;
  }

  else
  {
    CLConnection::getUserName(this);
    uint32_t v19 = (uint64_t **)(a1 + 800);
    uint64_t v20 = sub_10008E8D0(a1 + 800, (const void **)&__p);
    uint64_t v21 = a1 + 808;
    if (SBYTE3(v46) < 0) {
      operator delete(__p);
    }
    if (v21 != v20)
    {
      CLConnection::getUserName(this);
      uint64_t v22 = sub_10008E8D0((uint64_t)v19, (const void **)buf);
      sub_1003F9708(v19, v22);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v23 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = v41;
        uint64_t v25 = *(_BYTE **)buf;
        CLConnection::getName(this);
        __int16 v26 = buf;
        if (v24 < 0) {
          __int16 v26 = v25;
        }
        if (v39 >= 0) {
          __int16 v27 = v38;
        }
        else {
          __int16 v27 = *(_BYTE **)v38;
        }
        __int128 __p = (void *)68289538;
        __int16 v43 = 2082;
        id v44 = "";
        __int16 v45 = 2082;
        uint64_t v46 = v26;
        __int16 v47 = 2082;
        __int16 v48 = v27;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#CoreLocationAgent disconnected, UserName:%{public, location:escape_only}s, Con nection:%{public, location:escape_only}s}",  (uint8_t *)&__p,  0x26u);
        if (v39 < 0) {
          operator delete(*(void **)v38);
        }
      }

      goto LABEL_76;
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v31 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      CLConnection::getName(this);
      if (v41 >= 0) {
        __int16 v32 = buf;
      }
      else {
        __int16 v32 = *(_BYTE **)buf;
      }
      __int128 __p = (void *)68289282;
      __int16 v43 = 2082;
      id v44 = "";
      __int16 v45 = 2082;
      uint64_t v46 = v32;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Got disconnection for unknown client, Connection:%{public, location:escape_only}s}",  (uint8_t *)&__p,  0x1Cu);
      if (v41 < 0) {
        operator delete(*(void **)buf);
      }
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v33 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      CLConnection::getName(this);
      if (v41 >= 0) {
        __int16 v34 = buf;
      }
      else {
        __int16 v34 = *(_BYTE **)buf;
      }
      __int128 __p = (void *)68289282;
      __int16 v43 = 2082;
      id v44 = "";
      __int16 v45 = 2082;
      uint64_t v46 = v34;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v33,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Got disconnection for unknown client",  "{msg%{public}.0s:Got disconnection for unknown client, Connection:%{public, location:escape_only}s}",  (uint8_t *)&__p,  0x1Cu);
LABEL_76:
      if ((v41 & 0x80000000) == 0) {
        return;
      }
      uint64_t v30 = *(void **)buf;
      goto LABEL_78;
    }
  }

void sub_100545D38( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100545D74(uint64_t a1, char a2, uint64_t *a3)
{
  char v15 = a2;
  sub_1002F0B04(&v13);
  sub_1002AB464(v13, @"LocationServicesEnabledIn8.0", &v15);
  uint64_t v5 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  sub_1002F0B04(&v13);
  sub_1002F13B4(v13);
  BOOL v8 = v14;
  if (v14)
  {
    BOOL v9 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  sub_1002F1454((uint64_t)&v13, @"com.apple.locationd.notbackedup", 0, (uint64_t)@"mobile");
  sub_1002AB464((uint64_t)&v13, @"LocationServicesEnabledIn8.0", &v15);
  sub_1002F13B4((uint64_t)&v13);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterPostNotification(DarwinNotifyCenter, @"com.apple.locationd/Prefs", 0LL, 0LL, 1u);
  sub_100545EE8(a1, a3, 1);
  return sub_1002F14C8(&v13);
}

void sub_100545EC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100545EE8(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v6 = sub_1002958AC();
  int v7 = sub_100295918();
  if ([*(id *)(a1 + 120) locationServicesEnabledStatus] != (_DWORD)v6
    || *(unsigned __int8 *)(a1 + 736) != v7)
  {
    [*(id *)(a1 + 120) setLocationServicesEnabledStatus:v6];
    *(_BYTE *)(a1 + 736) = v7;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v9 = [*(id *)(a1 + 120) locationServicesEnabledStatus];
      *(_DWORD *)__int128 buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v9;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "GPS_NETWORK: currentStatus(%d) isGpsControlledByNetwork(%d)",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v22 = qword_101934988;
      unsigned int v23 = [*(id *)(a1 + 120) locationServicesEnabledStatus];
      *(_DWORD *)__int16 v37 = 67109376;
      *(_DWORD *)&v37[4] = v23;
      *(_WORD *)__int16 v38 = 1024;
      *(_DWORD *)&v38[2] = v7;
      int v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v22,  2LL,  "GPS_NETWORK: currentStatus(%d) isGpsControlledByNetwork(%d)",  v37,  14);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::checkLocationServicesEnabledState(const std::string &, BOOL)",  "%s\n",  v24);
    }

    if (a3)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      unint64_t v10 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 68289026;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#authsync sending kNotificationLocationServicesStatus}",  buf,  0x12u);
      }

      [*(id *)(a1 + 1472) sendGlobalAuthStatus:sub_100295844()];
    }

    sub_10054C7F4(a1);
    *(_OWORD *)uint64_t v30 = 0u;
    memset(v31, 0, 19);
    __int128 v28 = 0u;
    *(_OWORD *)__int16 v29 = 0u;
    memset(buf, 0, sizeof(buf));
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    memset(__p, 0, 27);
    unsigned int v36 = [*(id *)(a1 + 120) locationServicesEnabledStatus];
    *(_DWORD *)__int16 v37 = 4;
    (*(void (**)(uint64_t, uint8_t *, uint8_t *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  v37,  buf,  1LL,  0xFFFFFFFFLL,  0LL);
    sub_1005455A0(a1);
    for (uint64_t i = *(uint64_t **)(a1 + 928); i; uint64_t i = (uint64_t *)*i)
    {
      BOOL v12 = i + 2;
      id v13 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithClientKey:]( CLClientKeyPath,  "clientKeyPathWithClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12)));
      if ([v13 isValidCKP])
      {
        id v14 = sub_100544790(a1, (uint64_t)v13, &xmmword_101339630);
        sub_10054C8BC(a1, (uint64_t)v13, (uint64_t)v14);
      }
    }

    char v15 = *(void **)(a1 + 136);
    *(void *)__int16 v37 = _NSConcreteStackBlock;
    *(void *)__int16 v38 = 3221225472LL;
    *(void *)&v38[8] = sub_10057DCFC;
    *(void *)&v38[16] = &unk_101840050;
    uint64_t v39 = a1;
    LOBYTE(v40) = 0;
    [v15 iterateAllAnchorKeyPathsWithBlock:v37];
    id v16 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "proxyForService:", @"CLBTLEFenceManager");
    BOOL v17 = *(void **)(a1 + 136);
    *(void *)__int16 v37 = _NSConcreteStackBlock;
    *(void *)__int16 v38 = 3221225472LL;
    *(void *)&v38[8] = sub_1005473CC;
    *(void *)&v38[16] = &unk_10183F9D0;
    uint64_t v39 = (uint64_t)v16;
    uint64_t v40 = a1;
    [v17 iterateAllAnchorKeyPathsWithBlock:v37];
    sub_100547A3C(a1);
    v26[0] = &__kCFBooleanFalse;
    v25[0] = @"IsResetEvent";
    v25[1] = @"EventSource";
    else {
      __int16 v18 = (uint64_t *)*a2;
    }
    v26[1] = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v18);
    v25[2] = @"Enabled";
    v26[2] = +[NSNumber numberWithBool:]( NSNumber,  "numberWithBool:",  [*(id *)(a1 + 120) locationServicesEnabledStatus] == 1);
    uint32_t v19 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v26,  v25,  3LL);
    if (qword_101934A60 != -1) {
      dispatch_once(&qword_101934A60, &stru_101840200);
    }
    uint64_t v20 = (os_log_s *)qword_101934A68;
    if (os_log_type_enabled((os_log_t)qword_101934A68, OS_LOG_TYPE_DEBUG))
    {
      *(void *)__int16 v37 = 68289282LL;
      *(_WORD *)__int16 v38 = 2082;
      *(void *)&v38[2] = "";
      *(_WORD *)&v38[10] = 2114;
      *(void *)&_BYTE v38[12] = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#checkLocationServicesEnabledState #CoreAnalytics, Bigswitch Analytics:%{public, lo cation:escape_only}@}",  v37,  0x1Cu);
    }

    AnalyticsSendEvent(@"com.apple.locationd.bigswitch", v19);
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterPostNotification(DarwinNotifyCenter, CLAuthorizationStatusChangedNotification, 0LL, 0LL, 0);
    if (SHIBYTE(__p[2]) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v34) < 0) {
      operator delete(*((void **)&v33 + 1));
    }
    if (SBYTE7(v33) < 0) {
      operator delete((void *)v32);
    }
    if ((v31[15] & 0x80000000) != 0) {
      operator delete(v30[1]);
    }
    if (SHIBYTE(v30[0]) < 0) {
      operator delete(v29[0]);
    }
    if (SHIBYTE(v28) < 0) {
      operator delete(*(void **)&buf[24]);
    }
  }

void sub_1005464F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

BOOL sub_100546524(uint64_t a1, uint64_t a2)
{
  id v3 = sub_10053D6E0(a1, a2);
  id v4 = v3;
  if (v3)
  {
    [v3 cppClientKey];
  }

  else
  {
    __int128 __p = 0LL;
    *(void *)unint64_t v10 = 0LL;
    *(void *)&_OWORD v10[8] = 0LL;
  }

  uint64_t v5 = sub_10008E8D0(a1 + 640, (const void **)&__p);
  uint64_t v6 = a1 + 648;
  if ((v10[15] & 0x80000000) != 0) {
    operator delete(__p);
  }
  if (v6 != v5)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      __int128 __p = (void *)68289282;
      *(_WORD *)unint64_t v10 = 2082;
      *(void *)&v10[2] = "";
      *(_WORD *)&v10[10] = 2114;
      *(void *)&v10[12] = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#CLEPTO deauthorization overriding allowed, Client:%{public, location:escape_only}@}",  (uint8_t *)&__p,  0x1Cu);
    }
  }

  return v6 != v5;
}

void sub_100546668( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

BOOL sub_10054668C(uint64_t a1)
{
  return *(void *)(a1 + 272) != 0LL;
}

uint64_t sub_10054669C(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 272);
  if (v1) {
    return *v1;
  }
  else {
    return 5LL;
  }
}

id sub_1005466B4(uint64_t a1)
{
  id result = +[CLClientKeyPath nullClientKeyPath](&OBJC_CLASS___CLClientKeyPath, "nullClientKeyPath");
  uint64_t v3 = *(void *)(a1 + 272);
  if (v3) {
    return *(id *)(v3 + 8);
  }
  return result;
}

id sub_1005466E8(uint64_t a1, uint64_t a2)
{
  id v3 = objc_msgSend( -[NSArray objectAtIndexedSubscript:](sub_1005467FC(a1, a2), "objectAtIndexedSubscript:", 0),  "intValue");
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v4 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    v6[0] = 68289538;
    v6[1] = 0;
    __int16 v7 = 2082;
    BOOL v8 = "";
    __int16 v9 = 2114;
    uint64_t v10 = a2;
    __int16 v11 = 2050;
    uint64_t v12 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Client static registration result, Client:%{public, location:escape_only}@, registr ation:%{public, location:CLClientRegistrationResult}lld}",  (uint8_t *)v6,  0x26u);
  }

  return v3;
}

NSArray *sub_1005467FC(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  BOOL v4 = sub_10053D890(a1, (uint64_t)v3);
  if ([v3 isValidCKP])
  {
    BOOL v5 = sub_100546524(a1, (uint64_t)v3);
    uint64_t v6 = sub_100AE0E60( objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v3), "dictionary"),  (int)objc_msgSend(*(id *)(a1 + 136), "isKeyPathRegisteredSystemService:", v3),  v4,  v5);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289794;
      int v15 = 0;
      __int16 v16 = 2082;
      BOOL v17 = "";
      __int16 v18 = 2114;
      id v19 = v3;
      __int16 v20 = 1026;
      BOOL v21 = v4;
      __int16 v22 = 2114;
      unsigned int v23 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:client RegistrationResults, Client:%{public, location:escape_only}@, bigSwitchEna bled:%{public}hhd, RegistrationResults:%{public, location:escape_only}@}",  buf,  0x2Cu);
    }

    return v6;
  }

  if (!sub_1004F76B8()
    || ![v3 bundlePath]
    || !sub_1002965E4((__CFString *)[v3 bundlePath]))
  {
    uint64_t v9 = 4LL;
LABEL_14:
    if (v4) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 2LL;
    }
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    goto LABEL_19;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  BOOL v8 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289282;
    int v15 = 0;
    __int16 v16 = 2082;
    BOOL v17 = "";
    __int16 v18 = 2114;
    id v19 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#OSXThinksDifferent system service not found in persistent store is allowed by default,  Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    uint64_t v9 = 0LL;
    goto LABEL_14;
  }

  uint64_t v9 = 0LL;
  if (v4) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = 2LL;
  }
LABEL_19:
  __int16 v11 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 68290306;
    int v15 = 0;
    __int16 v16 = 2082;
    BOOL v17 = "";
    __int16 v18 = 2114;
    id v19 = v3;
    __int16 v20 = 1026;
    BOOL v21 = v4;
    __int16 v22 = 2050;
    unsigned int v23 = (NSArray *)v9;
    __int16 v24 = 2050;
    uint64_t v25 = v10;
    __int16 v26 = 2050;
    uint64_t v27 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:client(does not exists) RegistrationResults, Client:%{public, location:escape_only}@, bigSwitchEnabled:%{public}hhd, static:%{public, location:CLClientRegistrationResult}lld, effective:%{ public, location:CLClientRegistrationResult}lld, transient:%{public, location:CLClientRegistrationResult}lld}",  buf,  0x40u);
  }

  v13[0] = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v9);
  v13[1] = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v10);
  _OWORD v13[2] = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v10);
  return +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v13, 3LL);
}

id sub_100546B6C(uint64_t a1, uint64_t a2)
{
  id v3 = objc_msgSend( -[NSArray objectAtIndexedSubscript:](sub_1005467FC(a1, a2), "objectAtIndexedSubscript:", 1),  "intValue");
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  BOOL v4 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    v6[0] = 68289538;
    v6[1] = 0;
    __int16 v7 = 2082;
    BOOL v8 = "";
    __int16 v9 = 2114;
    uint64_t v10 = a2;
    __int16 v11 = 2050;
    uint64_t v12 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Client Effective registration result, Client:%{public, location:escape_only}@, regi stration:%{public, location:CLClientRegistrationResult}lld}",  (uint8_t *)v6,  0x26u);
  }

  return v3;
}

id sub_100546C80(uint64_t a1, uint64_t a2)
{
  id v3 = objc_msgSend( -[NSArray objectAtIndexedSubscript:](sub_1005467FC(a1, a2), "objectAtIndexedSubscript:", 2),  "intValue");
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  BOOL v4 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    v6[0] = 68289538;
    v6[1] = 0;
    __int16 v7 = 2082;
    BOOL v8 = "";
    __int16 v9 = 2114;
    uint64_t v10 = a2;
    __int16 v11 = 2050;
    uint64_t v12 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Client Effective registration result with TransientAwareness, Client:%{public, locati on:escape_only}@, registration:%{public, location:CLClientRegistrationResult}lld}",  (uint8_t *)v6,  0x26u);
  }

  return v3;
}

id sub_100546D94(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 136) isKeyPathRegisteredSystemService:a2];
}

id sub_100546DA0(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289026;
    int v7 = 0;
    __int16 v8 = 2082;
    __int16 v9 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:checkVisitMonitoringStopped}",  buf,  0x12u);
  }

  id v3 = *(void **)(a1 + 136);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100546EB4;
  v5[3] = &unk_10183F8B0;
  v5[4] = a1;
  return [v3 iterateAllAnchorKeyPathsWithBlock:v5];
}

uint64_t sub_100546EB4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  BOOL v4 = *(void **)(v3 + 136);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = sub_100546FF4;
  v7[3] = &unk_10183F900;
  v7[4] = v3;
  [v4 iterateIdentitiesRelatedToKeyPath:a2 withBlock:v7];
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  BOOL v5 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289282;
    int v9 = 0;
    __int16 v10 = 2082;
    __int16 v11 = "";
    __int16 v12 = 2114;
    uint64_t v13 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:stop visit monitoring for client, ckp:%{public, location:escape_only}@}",  buf,  0x1Cu);
  }

  return sub_1005470F4(v3, a2, 6LL);
}

uint64_t sub_100546FF4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  BOOL v4 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 68289282;
    v6[1] = 0;
    __int16 v7 = 2082;
    __int16 v8 = "";
    __int16 v9 = 2114;
    uint64_t v10 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:stop visit monitoring for related client, relatedCkp:%{public, location:escape_only}@}",  (uint8_t *)v6,  0x1Cu);
  }

  return sub_1005470F4(v3, a2, 6LL);
}

uint64_t sub_1005470F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  uint64_t result = (uint64_t)[v5 isValidCKP];
  if ((_DWORD)result)
  {
    BOOL v17 = 0LL;
    uint64_t v18 = 0LL;
    sub_100547724(a3, &v18, &v17);
    int v7 = [*(id *)(a1 + 136) intForKey:v18 atKeyPath:v5 defaultValue:0xFFFFFFFFLL];
    int v8 = [*(id *)(a1 + 136) intForKey:v17 atKeyPath:v5 defaultValue:0xFFFFFFFFLL];
    if (v7 != -1 && ((double v9 = (double)v7, v10 = (double)v8, v8 == -1) || v10 < v9))
    {
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int16 v12 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = off_10183F920[a3];
        *(_DWORD *)__int128 buf = 136447234;
        uint64_t v30 = v13;
        __int16 v31 = 2050;
        double v32 = v9;
        __int16 v33 = 2050;
        double v34 = v10;
        __int16 v35 = 2114;
        id v36 = v5;
        __int16 v37 = 2050;
        CFAbsoluteTime v38 = Current;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "#warning %{public}s time started exists (%{public}.2f), but time stopped (%{public}.2f) doesn't exist or is ea rlier for %{public}@ - setting to %{public}.2f",  buf,  0x34u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        int v15 = off_10183F920[a3];
        int v19 = 136447234;
        __int16 v20 = v15;
        __int16 v21 = 2050;
        double v22 = v9;
        __int16 v23 = 2050;
        double v24 = v10;
        __int16 v25 = 2114;
        id v26 = v5;
        __int16 v27 = 2050;
        CFAbsoluteTime v28 = Current;
        __int16 v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#warning %{public}s time started exists (%{public}.2f), but time stopped (%{public}.2f) doesn't exist or is earlier for %{public}@ - setting to %{public}.2f",  &v19,  52);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::checkServiceStopped(CLClientKeyPath *, CLClientServiceType)",  "%s\n",  v16);
      }

      double v14 = CFAbsoluteTimeGetCurrent();
      sub_10056CADC(a1, (uint64_t)v5, a3, 0, 0, 0, v14);
      return 1LL;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1005473CC(uint64_t a1, void *a2)
{
  unsigned int v4 = 0;
  uint64_t v5 = *(void *)(a1 + 40);
  do
  {
    double v22 = 0LL;
    uint64_t v23 = 0LL;
    uint64_t v6 = sub_100547A14(v4);
    sub_100547724(v6, &v23, &v22);
    [*(id *)(v5 + 136) doubleForKey:v23 atKeyPath:a2 defaultValue:-1.0];
    double v8 = v7;
    uint64_t result = (uint64_t)[*(id *)(v5 + 136) doubleForKey:v22 atKeyPath:a2 defaultValue:-1.0];
    if (v8 != -1.0)
    {
      double v11 = v10;
      if (v10 == -1.0 || v10 < v8)
      {
        if (v4 - 1 >= 3)
        {
          if (v4) {
            goto LABEL_18;
          }
          uint64_t result = (uint64_t)objc_msgSend( *(id *)(a1 + 32),  "syncgetHasMonitoredRegions:",  objc_msgSend(a2, "legacyClientKey"));
          if ((result & 1) != 0) {
            goto LABEL_18;
          }
        }

        else
        {
          objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(v5 + 32), "vendor"), "proxyForService:", @"CLFenceManager"),  "syncgetHasMonitoredFences:",  objc_msgSend(a2, "legacyClientKey"));
        }

        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        double v14 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          int v15 = off_10183F920[sub_100547A14(v4)];
          *(_DWORD *)__int128 buf = 136447234;
          __int16 v35 = v15;
          __int16 v36 = 2050;
          double v37 = v8;
          __int16 v38 = 2050;
          double v39 = v11;
          __int16 v40 = 2114;
          char v41 = a2;
          __int16 v42 = 2050;
          CFAbsoluteTime v43 = Current;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#warning %{public}s region time started exists (%{public}.2f), but time stopped (%{public}.2f) doesn't exist or is earlier for %{public}@ - setting to %{public}.2f",  buf,  0x34u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          uint64_t v18 = qword_101934988;
          int v19 = off_10183F920[sub_100547A14(v4)];
          int v24 = 136447234;
          __int16 v25 = v19;
          __int16 v26 = 2050;
          double v27 = v8;
          __int16 v28 = 2050;
          double v29 = v11;
          __int16 v30 = 2114;
          __int16 v31 = a2;
          __int16 v32 = 2050;
          CFAbsoluteTime v33 = Current;
          LODWORD(v21) = 52;
          __int16 v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v18,  0LL,  "#warning %{public}s region time started exists (%{public}.2f), but time stopped (%{public}.2f) doesn't exist or is earlier for %{public}@ - setting to %{public}.2f",  &v24,  v21);
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::checkRegionsStopped()_block_invoke", "%s\n", v20);
        }

        uint64_t v16 = sub_100547A14(v4);
        double v17 = CFAbsoluteTimeGetCurrent();
        uint64_t result = sub_10056CADC(v5, (uint64_t)a2, v16, 0, 0, 0, v17);
      }
    }

void sub_100547724(uint64_t a1, void *a2, __CFString **a3)
{
  *a2 = 0LL;
  switch(a1)
  {
    case 0LL:
      *a2 = @"BeaconRegionTimeStarted";
      unsigned int v4 = &off_10188DA60;
      goto LABEL_17;
    case 1LL:
      *a2 = @"FenceTimeStarted";
      unsigned int v4 = &off_10188DA70;
      goto LABEL_17;
    case 2LL:
      *a2 = @"RangeTimeStarted";
      unsigned int v4 = &off_10188DA80;
      goto LABEL_17;
    case 3LL:
      *a2 = @"SignificantTimeStarted";
      unsigned int v4 = &off_10188DA90;
      goto LABEL_17;
    case 4LL:
      *a2 = @"LocationTimeStarted";
      unsigned int v4 = &off_10188DAA0;
      goto LABEL_17;
    case 5LL:
      *a2 = @"BackgroundLocationTimeStarted";
      unsigned int v4 = &off_10188DAB0;
      goto LABEL_17;
    case 6LL:
      *a2 = @"VisitTimeStarted";
      unsigned int v4 = &off_10188DAC0;
      goto LABEL_17;
    case 7LL:
      *a2 = @"RemoteLocationTimeStarted";
      unsigned int v4 = &off_10188DB58;
      goto LABEL_17;
    case 8LL:
      *a2 = @"MicroLocationTimeStarted";
      unsigned int v4 = &off_10188DB78;
      goto LABEL_17;
    case 9LL:
      *a2 = @"RemoteFenceTimeStarted";
      unsigned int v4 = &off_10188DB68;
      goto LABEL_17;
    case 10LL:
      *a2 = @"ReceivingLocationInformationTimeStarted";
      unsigned int v4 = &off_10188DAD0;
      goto LABEL_17;
    case 11LL:
      *a2 = @"NonPersistentSignificantTimeStarted";
      unsigned int v4 = &off_10188DAE0;
      goto LABEL_17;
    case 15LL:
      *a2 = @"PushTimeStarted";
      unsigned int v4 = &off_10188DAF0;
      goto LABEL_17;
    case 16LL:
      *a2 = @"TranscriptTimeStarted";
      unsigned int v4 = &off_10188DB00;
LABEL_17:
      uint64_t v5 = *v4;
      *a3 = v5;
      break;
    default:
      uint64_t v5 = *a3;
      break;
  }

  if (*a2) {
    BOOL v6 = v5 == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    double v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      v8[0] = 68289282;
      v8[1] = 0;
      __int16 v9 = 2082;
      double v10 = "";
      __int16 v11 = 2050;
      uint64_t v12 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Unsupported CLClientServiceType, serviceType:%{public}lu}",  (uint8_t *)v8,  0x1Cu);
    }
  }

uint64_t sub_100547A14(unsigned int a1)
{
  if (a1 < 4) {
    return qword_1012F1000[a1];
  }
  uint64_t v2 = sub_10123D3B8();
  return sub_100547A3C(v2);
}

void sub_100547A3C(uint64_t a1)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = (int *)&v4;
  uint64_t v6 = 0x2020000000LL;
  int v7 = 0;
  uint64_t v2 = *(void **)(a1 + 136);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100547AF0;
  v3[3] = &unk_10183F9F8;
  void v3[4] = &v4;
  v3[5] = a1;
  [v2 iterateAllAnchorKeyPathsWithBlock:v3];
  if (v5[6] >= 1) {
    sub_100547C58(a1);
  }
  _Block_object_dispose(&v4, 8);
}

void sub_100547AD8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id sub_100547AF0(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  id result = [*(id *)(v4 + 136) hasValueForKey:@"RangeTimeStarted" atKeyPath:a2];
  if ((_DWORD)result)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      v7[0] = 68289282;
      v7[1] = 0;
      __int16 v8 = 2082;
      __int16 v9 = "";
      __int16 v10 = 2114;
      id v11 = [a2 legacyClientKey];
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:stop range for client, client:%{public, location:escape_only}@}",  (uint8_t *)v7,  0x1Cu);
    }

    [*(id *)(v4 + 136) removeValueForKey:@"RangeTimeStarted" atKeyPath:a2];
    id result = [*(id *)(v4 + 136) setDouble:@"RangeTimeStopped" forKey:a2 atKeyPath:CFAbsoluteTimeGetCurrent()];
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  return result;
}

id sub_100547C58(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 68289026;
    int v9 = 0;
    __int16 v10 = 2082;
    id v11 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Scheduling pending app status event}",  buf,  0x12u);
  }

  uint64_t v3 = *(void **)(a1 + 40);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  _DWORD v7[2] = sub_10057E5E4;
  v7[3] = &unk_10181D3D0;
  v7[4] = a1;
  [v3 afterInterval:v7 async:sub_100AE0164(1)];
  uint64_t v4 = *(void **)(a1 + 40);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_10057E5EC;
  v6[3] = &unk_10181D3D0;
  v6[4] = a1;
  return [v4 afterInterval:v6 async:sub_100AE0164(2)];
}

uint64_t sub_100547DB8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  sub_1005470F4(v3, a2, 11LL);
  return sub_1005470F4(v3, a2, 3LL);
}

uint64_t sub_100547DF0(uint64_t a1, uint64_t a2)
{
  id v4 = sub_10086D1D8(a2, 0);
  unsigned int v5 = sub_10054801C(a1, (uint64_t)v4, 5LL, 10.0);
  id v6 = sub_10086D1D8(a2, 0);
  unsigned int v7 = sub_10054801C(a1, (uint64_t)v6, 3LL, -1.0);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v8 = v5 | v7;
  int v9 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 67109632;
    int v19 = v5 | v7;
    __int16 v20 = 1024;
    unsigned int v21 = v5;
    __int16 v22 = 1024;
    unsigned int v23 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "mayTakeProcessAssertion,%d,background,%d,slc,%d",  buf,  0x14u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v14 = 1024;
    unsigned int v15 = v5;
    __int16 v16 = 1024;
    unsigned int v17 = v7;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "mayTakeProcessAssertion,%d,background,%d,slc,%d",  &v13,  20,  67109632);
    uint64_t v12 = (uint8_t *)v11;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::mayTakeProcessAssertion(CLDaemonClient *)",  "%s\n",  v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  return v8;
}

id sub_10054801C(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  id v7 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  id result = [v7 isValidCKP];
  if ((_DWORD)result)
  {
    int v13 = 0LL;
    uint64_t v14 = 0LL;
    sub_100547724(a3, &v14, &v13);
    [*(id *)(a1 + 136) doubleForKey:v14 atKeyPath:v7 defaultValue:-1.0];
    double v10 = v9;
    [*(id *)(a1 + 136) doubleForKey:v13 atKeyPath:v7 defaultValue:-1.0];
    result = (id)(v10 != -1.0 && (v11 != -1.0 ? (BOOL v12 = v11 < v10) : (BOOL v12 = 1), v12)
               || vabdd_f64(v11, CFAbsoluteTimeGetCurrent()) < a4);
  }

  return result;
}

void sub_1005480F0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  id v9 = sub_1005486B8(a1, a2);
  double v10 = sub_100544790(a1, (uint64_t)v9, &xmmword_101339630);
  if (-[CLClientManagerAuthorizationContext isAuthorizedForServiceTypeMask:]( v10,  "isAuthorizedForServiceTypeMask:",  4112LL))
  {
    if ([*(id *)(a1 + 120) locationRestricted])
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      double v11 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 68289282;
        int v27 = 0;
        __int16 v28 = 2082;
        double v29 = "";
        __int16 v30 = 2114;
        id v31 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#transcriptSession skip prompting. Restrictions enabled, Client:%{public, locatio n:escape_only}@}",  buf,  0x1Cu);
      }

      NSErrorUserInfoKey v36 = NSDebugDescriptionErrorKey;
      double v37 = @"Restrictions are enabled.  Changing authorization isn't allowed";
      (*(void (**)(uint64_t, void, NSError *))(a5 + 16))( a5,  0LL,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kCLErrorDomain,  18LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v37,  &v36,  1LL)));
    }

    else if (*(void *)(a1 + 272))
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v13 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = *(unsigned int **)(a1 + 272);
        uint64_t v15 = *((void *)v14 + 1);
        uint64_t v16 = *v14;
        *(_DWORD *)__int128 buf = 68289794;
        int v27 = 0;
        __int16 v28 = 2082;
        double v29 = "";
        __int16 v30 = 2114;
        id v31 = v9;
        __int16 v32 = 2114;
        uint64_t v33 = v15;
        __int16 v34 = 2050;
        uint64_t v35 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#transcriptSession skip prompting. InflightPromptAuthorizationRequest found., Clien t:%{public, location:escape_only}@, inflightClient:%{public, location:escape_only}@, inflightRequestTy pe:%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}",  buf,  0x30u);
      }

      NSErrorUserInfoKey v24 = NSDebugDescriptionErrorKey;
      __int16 v25 = @"App is already presenting the user with an authorization prompt";
      (*(void (**)(uint64_t, void, NSError *))(a5 + 16))( a5,  0LL,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kCLErrorDomain,  18LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v25,  &v24,  1LL)));
    }

    else
    {
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 3221225472LL;
      v23[2] = sub_100548780;
      v23[3] = &unk_10183FA20;
      v23[4] = a5;
      sub_1010DDBC0(__p, "");
      sub_1005857F0((uint64_t)v22, a4, (uint64_t)v9, v23, (__int128 *)__p);
      BOOL v17 = sub_10054878C(a1, (uint64_t)v9, 0LL, (uint64_t)v22, a3);
      sub_1005858A0((uint64_t)v22);
      if (v21 < 0) {
        operator delete(__p[0]);
      }
      if (!v17)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v18 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 68289282;
          int v27 = 0;
          __int16 v28 = 2082;
          double v29 = "";
          __int16 v30 = 2114;
          id v31 = v9;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Warning Could not post #transcriptSession, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
        }

        int v19 = (os_log_s *)qword_101934988;
        if (os_signpost_enabled((os_log_t)qword_101934988))
        {
          *(_DWORD *)__int128 buf = 68289282;
          int v27 = 0;
          __int16 v28 = 2082;
          double v29 = "";
          __int16 v30 = 2114;
          id v31 = v9;
          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Warning Could not post #transcriptSession",  "{msg%{public}.0s:#Warning Could not post #transcriptSession, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
        }
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v12 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v27 = 0;
      __int16 v28 = 2082;
      double v29 = "";
      __int16 v30 = 2114;
      id v31 = v9;
      __int16 v32 = 1026;
      LODWORD(v33) = -[CLClientManagerAuthorizationContext registrationResult](v10, "registrationResult");
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#transcriptSession #Warning skip prompting .No point in prompting if the user doesn't wan t them to get access to precise current location , Client:%{public, location:escape_only}@, Registration Result:%{public}d}",  buf,  0x22u);
    }

    NSErrorUserInfoKey v38 = NSDebugDescriptionErrorKey;
    double v39 = @"Registration Result should be WIU or Always to enable Transcript Session";
    (*(void (**)(uint64_t, void, NSError *))(a5 + 16))( a5,  0LL,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kCLErrorDomain,  18LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v39,  &v38,  1LL)));
  }

void sub_100548684( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

id sub_1005486B8(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if (![v4 isValidCKP]
    || [*(id *)(a1 + 136) hasValueForKey:@"TimeMissing" atKeyPath:v4])
  {
    id v4 = [*(id *)(a1 + 136) registerClient:a2 fromAuthSync:0];
    sub_1010DDBC0(__p, "");
    sub_100544214(a1, v4, __p);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
  }

  return v4;
}

void sub_100548764( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100548780(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

BOOL sub_10054878C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v9 = sub_10053D6E0(a1, a2);
  id v10 = sub_1005486B8(a1, (uint64_t)v9);
  sub_100564EF4(a1, v10, 1);
  if (&SBUserNotificationPendInSetupIfNotAllowedKey) {
    BOOL v11 = &SBUserNotificationHideOnClonedDisplay == 0LL;
  }
  else {
    BOOL v11 = 1;
  }
  if (v11
    || &SBUserNotificationDefaultButtonTag == 0LL
    || &SBUserNotificationExtensionItemsKey == 0LL
    || &SBUserNotificationExtensionIdentifierKey == 0LL)
  {
    return 0LL;
  }

  unsigned int v15 = *(_DWORD *)a4;
  cf = sub_10055DBB0(a1, v9, a3);
  if (!cf)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v17 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2114;
      *(void *)&buf[20] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:createClientUserNotification: BundleDisplayName nil, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v18 = (os_log_s *)qword_101934988;
    BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
    if (result)
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2114;
      *(void *)&buf[20] = v9;
      __int16 v20 = "createClientUserNotification: BundleDisplayName nil";
      char v21 = "{msg%{public}.0s:createClientUserNotification: BundleDisplayName nil, Client:%{public, location:escape_only}@}";
      goto LABEL_28;
    }

    return result;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v16 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2114;
    *(void *)&buf[20] = v9;
    __int16 v138 = 1026;
    LODWORD(v139) = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#CUN Creating client user notification for client, Client:%{public, location:escape_o nly}@, requestType:%{public}d}",  buf,  0x22u);
  }

  v131 = +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  a5);
  if (*(char *)(a4 + 39) < 0)
  {
    sub_1010DD48C(buf, *(void **)(a4 + 16), *(void *)(a4 + 24));
  }

  else
  {
    *(_OWORD *)__int128 buf = *(_OWORD *)(a4 + 16);
    *(void *)&uint8_t buf[16] = *(void *)(a4 + 32);
  }

  if (buf[23] >= 0) {
    __int16 v22 = buf;
  }
  else {
    __int16 v22 = *(_BYTE **)buf;
  }
  unsigned int v23 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v22);
  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  CFErrorRef errorPtr = 0LL;
  sub_1004F2598();
  if (sub_1004F7000())
  {
    NSErrorUserInfoKey v24 = (const __CFURL *)sub_100D95A64([v9 bundleId]);
    __int16 v25 = CFBundleCreate(kCFAllocatorDefault, v24);
    if (v25)
    {
      uint64_t v26 = sub_10059CEEC();
      int v27 = sub_10059D310(v26, v25, @"NSLocationUsageDescriptionCarplay", 0);
      CFRelease(v25);
      if (v27) {
        CFRelease(v27);
      }
    }
  }

  int v28 = _os_feature_enabled_impl("CoreLocation", "CLNotThisTime");
  if (v28) {
    unsigned int v29 = [*(id *)(a1 + 136) BOOLForKey:@"AuthorizationPromptOptionTypeNegative" atKeyPath:v9 defaultValue:0];
  }
  else {
    unsigned int v29 = 0;
  }
  int v30 = 0;
  uint64_t v31 = 0LL;
  switch(v15)
  {
    case 0u:
    case 0xAu:
    case 0xFu:
      CFRelease(cf);
      return 0LL;
    case 1u:
    case 3u:
      int v124 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "com.apple.corelocation.CoreLocationTemporaryPreciseAuthPromptPlugin");
      uint64_t v43 = sub_10059CEEC();
      CFStringRef format = (CFStringRef)sub_10059E10C(v43, @"LOCATION_CLIENT_PERMISSION_PLAIN_WHEN_IN_USE_TITLE");
      alloc = kCFAllocatorDefault;
      CFStringRef value = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0LL, @"%@", format, &errorPtr, cf);
      uint64_t v44 = sub_10059CEEC();
      __int16 v45 = @"LOCATION_CLIENT_PERMISSION_WHENINUSE_BUTTON";
      if (v28) {
        uint64_t v46 = @"LOCATION_CLIENT_PERMISSION_WHENINUSE_BUTTON";
      }
      else {
        uint64_t v46 = @"LOCATION_CLIENT_PERMISSION_ONETIME_BUTTON";
      }
      if (v28)
      {
        __int16 v45 = @"LOCATION_CLIENT_PERMISSION_ONETIME_BUTTON";
        __int16 v47 = @"LOCATION_CLIENT_PERMISSION_NOT_THIS_TIME_BUTTON";
      }

      else
      {
        __int16 v47 = @"LOCATION_CLIENT_PERMISSION_NEVER_BUTTON";
      }

      if (v29) {
        __int16 v48 = @"LOCATION_CLIENT_PERMISSION_ONETIME_BUTTON";
      }
      else {
        __int16 v48 = v46;
      }
      if (v29) {
        int v49 = @"LOCATION_CLIENT_PERMISSION_NOT_THIS_TIME_BUTTON";
      }
      else {
        int v49 = v45;
      }
      if (v29) {
        __int16 v50 = @"LOCATION_CLIENT_PERMISSION_NEVER_BUTTON";
      }
      else {
        __int16 v50 = v47;
      }
      CFTypeRef v130 = (CFTypeRef)sub_10059E10C(v44, v48);
      uint64_t v51 = sub_10059CEEC();
      CFTypeRef v125 = (CFTypeRef)sub_10059E10C(v51, v49);
      uint64_t v52 = sub_10059CEEC();
      __int16 v53 = (const void *)sub_10059E10C(v52, v50);
      uint64_t v54 = (__CFBundle *)sub_10055E270(a1, (uint64_t)v9);
      if (v54)
      {
        int v127 = sub_10055E324(a1, v9, v54, 1u, 0, v23);
        CFRelease(v54);
        int v30 = 0;
        goto LABEL_113;
      }

      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_101840220);
      }
      uint64_t v92 = (os_log_s *)qword_101934978;
      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2114;
        *(void *)&buf[20] = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#AuthPrompt couldn't get bundle for client, ClientKeyPath:%{public, location:escape_only}@}",  buf,  0x1Cu);
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_101840220);
        }
      }

      uint64_t v18 = (os_log_s *)qword_101934978;
      BOOL result = os_signpost_enabled((os_log_t)qword_101934978);
      if (result) {
        goto LABEL_210;
      }
      return result;
    case 2u:
    case 4u:
    case 5u:
      uint64_t v32 = sub_10059CEEC();
      uint64_t v33 = @"LOCATION_CLIENT_PERMISSION_WHENINUSE_BUTTON";
      if (!v28) {
        uint64_t v33 = @"LOCATION_CLIENT_PERMISSION_ONETIME_BUTTON";
      }
      if (v29) {
        __int16 v34 = @"LOCATION_CLIENT_PERMISSION_ONETIME_BUTTON";
      }
      else {
        __int16 v34 = v33;
      }
      uint64_t v31 = sub_10059E10C(v32, v34);
      uint64_t v35 = sub_10059CEEC();
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v131,  "setObject:forKeyedSubscript:",  (id)sub_10059E10C(v35, @"PRECISE_ON_PILL_BUTTON_TITLE"),  @"PreciseButtonOnTitle");
      uint64_t v36 = sub_10059CEEC();
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v131,  "setObject:forKeyedSubscript:",  (id)sub_10059E10C(v36, @"PRECISE_OFF_PILL_BUTTON_TITLE"),  @"PreciseButtonOffTitle");
      uint64_t v37 = sub_10059CEEC();
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v131,  "setObject:forKeyedSubscript:",  (id)sub_10059E10C(v37, @"ONLY_HERE_PILL_BUTTON_TITLE"),  @"OnlyHereTitle");
      int v30 = 1;
      goto LABEL_50;
    case 6u:
      int v124 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "com.apple.corelocation.CoreLocationRepromptAlwaysAuthPromptPlugin");
      id v61 = objc_msgSend( -[NSMutableDictionary objectForKey:](v131, "objectForKey:", @"LocationCount"),  "unsignedLongValue");
      __int16 v62 = (void *)sub_10059CEEC();
      if (v61)
      {
        CFStringRef format = sub_10059E110(v62, @"LOCATION_CLIENT_PERMISSION_REPROMPT_OTHER");
        alloc = kCFAllocatorDefault;
        CFStringRef value = CFStringCreateStringWithValidatedFormat( kCFAllocatorDefault,  0LL,  @"%lu %@",  format,  &errorPtr,  v61,  cf);
      }

      else
      {
        CFStringRef format = sub_10059E110(v62, @"LOCATION_REPROMPT_ALWAYS_TITLE");
        alloc = kCFAllocatorDefault;
        CFStringRef value = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0LL, @"%@", format, &errorPtr, cf);
      }

      uint64_t v96 = sub_10059CEEC();
      CFTypeRef v130 = (CFTypeRef)sub_10059E10C(v96, @"LOCATION_CLIENT_PERMISSION_WHENINUSE_ONLY_BUTTON");
      uint64_t v97 = sub_10059CEEC();
      CFTypeRef v125 = (CFTypeRef)sub_10059E10C(v97, @"LOCATION_CLIENT_PERMISSION_KEEP_ALWAYS_BUTTON");
      int v127 = sub_10055DE60(a1, (uint64_t)v9);
      goto LABEL_123;
    case 7u:
    case 8u:
      uint64_t v55 = sub_10059CEEC();
      CFStringRef format = (CFStringRef)sub_10059E10C(v55, @"LOCATION_CLIENT_PERMISSION_UPGRADE_WHENINUSE_ALWAYS");
      alloc = kCFAllocatorDefault;
      CFStringRef value = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0LL, @"%@", format, &errorPtr, cf);
      uint64_t v56 = sub_10059CEEC();
      CFTypeRef v130 = (CFTypeRef)sub_10059E10C(v56, @"LOCATION_CLIENT_PERMISSION_KEEP_WHENINUSE_BUTTON");
      uint64_t v57 = sub_10059CEEC();
      CFTypeRef v125 = (CFTypeRef)sub_10059E10C(v57, @"LOCATION_CLIENT_PERMISSION_ALWAYS_BUTTON");
      int v127 = sub_10055DE60(a1, (uint64_t)v9);
      goto LABEL_94;
    case 9u:
      int v124 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "com.apple.corelocation.CoreLocationTemporaryPreciseAuthPromptPlugin");
      uint64_t v63 = sub_10059CEEC();
      CFStringRef format = (CFStringRef)sub_10059E10C(v63, @"LOCATION_CLIENT_PERMISSION_TEMPORARY_PRECISE_TITLE");
      alloc = kCFAllocatorDefault;
      CFStringRef value = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0LL, @"%@", format, &errorPtr, cf);
      uint64_t v64 = sub_10059CEEC();
      CFTypeRef v130 = (CFTypeRef)sub_10059E10C(v64, @"LOCATION_CLIENT_PERMISSION_TEMPORARY_PRECISE_YES_BUTTON");
      uint64_t v65 = sub_10059CEEC();
      CFTypeRef v125 = (CFTypeRef)sub_10059E10C(v65, @"LOCATION_CLIENT_PERMISSION_TEMPORARY_PRECISE_NO_BUTTON");
      int v127 = (__CFString *)objc_msgSend( -[NSMutableDictionary objectForKey:](v131, "objectForKey:", @"UsageDescription"),  "copy");
      if (v127 || !v23) {
        goto LABEL_92;
      }
      __int16 v66 = (__CFBundle *)sub_10055E270(a1, (uint64_t)v9);
      unint64_t v67 = v66;
      if (v66)
      {
        CFAutorelease(v66);
        id v68 = -[__CFDictionary objectForKeyedSubscript:]( CFBundleGetInfoDictionary(v67),  "objectForKeyedSubscript:",  @"NSLocationTemporaryUsageDescriptionDictionary");
        if (!v68)
        {
          sub_10055E8F4( (unsigned int *)a4,  (uint64_t)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Info.plist is missing the %@ key",  @"NSLocationTemporaryUsageDescriptionDictionary"));
          return 0LL;
        }

        uint64_t v69 = objc_opt_class(&OBJC_CLASS___NSDictionary);
        if ((objc_opt_isKindOfClass(v68, v69) & 1) == 0)
        {
          sub_10055E8F4( (unsigned int *)a4,  (uint64_t)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Info.plist value for %@ key is not a dictionary",  @"NSLocationTemporaryUsageDescriptionDictionary"));
          return 0LL;
        }

        id v70 = [v68 objectForKeyedSubscript:v23];
        if (!v70)
        {
          sub_10055E8F4( (unsigned int *)a4,  (uint64_t)@"The purposeKey provided isn't present in the app's Info.plist dictionary of temporary usage descriptions");
          return 0LL;
        }

        uint64_t v71 = objc_opt_class(&OBJC_CLASS___NSString);
        if ((objc_opt_isKindOfClass(v70, v71) & 1) == 0)
        {
          sub_10055E8F4( (unsigned int *)a4,  (uint64_t)@"The purposeKey provided names an entry in Info.plist which isn't a string");
          return 0LL;
        }

        uint64_t v72 = sub_10059CEEC();
        int v127 = (__CFString *)sub_10059D310(v72, v67, v23, 1);
        if (!v127) {
          int v127 = (__CFString *)[v70 copy];
        }
LABEL_92:
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v131,  "setObject:forKeyedSubscript:",  @"UserLocationIsPrecise",  @"UserLocationIsPrecise");
LABEL_123:
        int v30 = 0;
        __int16 v53 = 0LL;
        goto LABEL_124;
      }

      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_101840220);
      }
      __int16 v122 = (os_log_s *)qword_101934978;
      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2114;
        *(void *)&buf[20] = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v122,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#AuthPrompt couldn't get bundle for client, ClientKeyPath:%{public, location:escape_only}@}",  buf,  0x1Cu);
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_101840220);
        }
      }

      uint64_t v18 = (os_log_s *)qword_101934978;
      BOOL result = os_signpost_enabled((os_log_t)qword_101934978);
      if (!result) {
        return result;
      }
      goto LABEL_210;
    case 0xBu:
LABEL_50:
      CFTypeRef v130 = (CFTypeRef)v31;
      int v124 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "com.apple.corelocation.CoreLocationVanillaWhenInUseAuthPromptPlugin");
      uint64_t v38 = sub_10059CEEC();
      CFStringRef format = (CFStringRef)sub_10059E10C(v38, @"LOCATION_CLIENT_PERMISSION_WHENINUSE");
      alloc = kCFAllocatorDefault;
      CFStringRef value = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0LL, @"%@", format, &errorPtr, cf);
      if (![*(id *)(a1 + 136) BOOLForKey:@"IsAppClip" atKeyPath:v9 defaultValue:0])
      {
        uint64_t v58 = sub_10059CEEC();
        if (v29)
        {
          CFTypeRef v125 = (CFTypeRef)sub_10059E10C(v58, @"LOCATION_CLIENT_PERMISSION_NOT_THIS_TIME_BUTTON");
        }

        else
        {
          if (v28)
          {
            CFTypeRef v125 = (CFTypeRef)sub_10059E10C(v58, @"LOCATION_CLIENT_PERMISSION_ONETIME_BUTTON");
            __int16 v42 = @"LOCATION_CLIENT_PERMISSION_NOT_THIS_TIME_BUTTON";
            goto LABEL_111;
          }

          CFTypeRef v125 = (CFTypeRef)sub_10059E10C(v58, @"LOCATION_CLIENT_PERMISSION_WHENINUSE_BUTTON");
        }

        goto LABEL_110;
      }

      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      double v39 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2114;
        *(void *)&buf[20] = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Client is #appclip, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      }

      uint64_t v40 = sub_10059CEEC();
      CFTypeRef v125 = (CFTypeRef)sub_10059E10C(v40, @"LOCATION_CLIENT_PERMISSION_WHENINUSE_UNTIL_TOMORROW_BUTTON");
      char v41 = v29 | v28;
      if (v29) {
        __int16 v42 = @"LOCATION_CLIENT_PERMISSION_NEVER_BUTTON";
      }
      else {
        __int16 v42 = @"LOCATION_CLIENT_PERMISSION_NOT_THIS_TIME_BUTTON";
      }
      if ((v41 & 1) == 0) {
LABEL_110:
      }
        __int16 v42 = @"LOCATION_CLIENT_PERMISSION_NEVER_BUTTON";
LABEL_111:
      uint64_t v93 = sub_10059CEEC();
      __int16 v53 = (const void *)sub_10059E10C(v93, v42);
      unint64_t v94 = (__CFBundle *)sub_10055E270(a1, (uint64_t)v9);
      if (v94)
      {
        int v127 = sub_10055E324(a1, v9, v94, 1u, 0, v23);
        CFRelease(v94);
LABEL_113:
        *(_BYTE *)(a4 + 4) = v29;
LABEL_124:
        CFTypeRef v60 = v130;
        if (errorPtr)
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          uint64_t v98 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
          {
            id v99 = objc_msgSend(-[__CFError localizedDescription](errorPtr, "localizedDescription"), "UTF8String");
            *(_DWORD *)__int128 buf = 68289538;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            *(_WORD *)&buf[18] = 2114;
            *(void *)&buf[20] = v9;
            __int16 v138 = 2082;
            id v139 = v99;
            _os_log_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#Error, couldn't create prompt for client due to error returned by CFStringCreateSt ringWithValidatedFormat., Client:%{public, location:escape_only}@, error:%{public, location:escape_only}s}",  buf,  0x26u);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
          }

          unint64_t v100 = (os_log_s *)qword_101934988;
          if (os_signpost_enabled((os_log_t)qword_101934988))
          {
            id v101 = objc_msgSend(-[__CFError localizedDescription](errorPtr, "localizedDescription"), "UTF8String");
            *(_DWORD *)__int128 buf = 68289538;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            *(_WORD *)&buf[18] = 2114;
            *(void *)&buf[20] = v9;
            __int16 v138 = 2082;
            id v139 = v101;
            _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v100,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Error, couldn't create prompt for client due to error returned by CFStringCreateStringWithValidatedFormat.",  "{msg%{public}.0s:#Error, couldn't create prompt for client due to error returned by CFStringCreateSt ringWithValidatedFormat., Client:%{public, location:escape_only}@, error:%{public, location:escape_only}s}",  buf,  0x26u);
          }

          return 0LL;
        }

        uint64_t v59 = 32LL;
        if (v127)
        {
          char v123 = 0;
LABEL_147:
          Mutable = CFDictionaryCreateMutable( alloc,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
          CFDictionarySetValue(Mutable, SBUserNotificationPendInSetupIfNotAllowedKey, kCFBooleanTrue);
          if (!*(_BYTE *)(a1 + 232)) {
            CFDictionarySetValue(Mutable, SBUserNotificationHideOnClonedDisplay, kCFBooleanTrue);
          }
          if (value)
          {
            CFDictionarySetValue(Mutable, kCFUserNotificationAlertHeaderKey, value);
            CFRelease(value);
          }

          if (format) {
            CFRelease(format);
          }
          if (v130)
          {
            CFDictionarySetValue(Mutable, kCFUserNotificationAlternateButtonTitleKey, v130);
            CFRelease(v130);
          }

          if (v125)
          {
            CFDictionarySetValue(Mutable, kCFUserNotificationOtherButtonTitleKey, v125);
            CFRelease(v125);
          }

          if (v53)
          {
            CFDictionarySetValue(Mutable, kCFUserNotificationDefaultButtonTitleKey, v53);
            CFRelease(v53);
          }

          if (v15 <= 0x10)
          {
            if (((1 << v15) & 0x1EEBF) != 0)
            {
              sub_1004F2598();
              if (!sub_1004F75F8()
                || (objc_msgSend( objc_msgSend(v9, "clientAnchor"),  "isEqualToString:",  @"com.apple.weather") & 1) == 0)
              {
                if (a3)
                {
                  if (sub_10053C998(v9))
                  {
                    CFDictionarySetValue(Mutable, kCFUserNotificationAlertTopMostKey, &__kCFBooleanTrue);
                    CFDictionarySetValue(Mutable, SBUserNotificationForcesModalAlertAppearance, &__kCFBooleanTrue);
                    CFDictionarySetValue(Mutable, SBUserNotificationDisplayActionButtonOnLockScreen, &__kCFBooleanTrue);
                  }
                }

                else if ([v9 bundleId] {
                       && (objc_msgSend( -[NSMutableDictionary objectForKeyedSubscript:]( v131,  "objectForKeyedSubscript:",  @"IsWebClip"),  "BOOLValue") & 1) == 0)
                }
                {
                  id v136 = [v9 bundleId];
                  __int16 v106 = +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v136,  1LL);
                  CFDictionarySetValue(Mutable, SBUserNotificationAllowedApplicationsKey, v106);
                }
              }
            }

            else
            {
              CFDictionarySetValue(Mutable, SBUserNotificationAllowedApplicationsKey, &off_1018D6D00);
            }
          }

          CFDictionarySetValue( Mutable,  SBUserNotificationDefaultButtonTag,  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v59));
          if ((v30 & _os_feature_enabled_impl("CoreLocation", "cl_zoth")) == 1) {
            -[NSMutableDictionary setObject:forKeyedSubscript:]( v131,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"CLAuthPromptShowOnlyHerePill");
          }
          if (v124 && sub_1002958D8())
          {
            id v107 = +[NSExtensionItem extensionItemForDict:withName:withPayload:]( NSExtensionItem,  "extensionItemForDict:withName:withPayload:",  objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v9), "dictionary"),  cf,  v131);
            *(void *)error = 0LL;
            id v135 = v107;
            __int16 v108 = +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v135, 1LL),  1LL,  error);
            if (*(void *)error)
            {
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              int v109 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)__int128 buf = 68289283;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)&uint8_t buf[8] = 2082;
                *(void *)&buf[10] = "";
                *(_WORD *)&buf[18] = 2113;
                *(void *)&buf[20] = *(void *)error;
                _os_log_impl( (void *)&_mh_execute_header,  v109,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Failed archiving extension item, error:%{private, location:escape_only}@}",  buf,  0x1Cu);
              }
            }

            else
            {
              __int16 v110 = v108;
              CFDictionarySetValue(Mutable, SBUserNotificationExtensionIdentifierKey, v124);
              CFDictionarySetValue(Mutable, SBUserNotificationExtensionItemsKey, v110);
            }
          }

          if ((v123 & 1) == 0)
          {
            CFDictionarySetValue(Mutable, kCFUserNotificationAlertMessageKey, v127);
            CFRelease(v127);
          }

          CFRelease(cf);
          [*(id *)(a1 + 40) currentLatchedAbsoluteTimestamp];
          double v112 = v111;
          unsigned int v113 = *(_DWORD *)a4;
          __int16 v114 = CFUserNotificationCreate(alloc, 0.0, 0x20uLL, error, Mutable);
          CFRelease(Mutable);
          if (v114)
          {
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
            uint64_t v115 = (os_log_s *)qword_101934988;
            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 68289538;
              *(_DWORD *)&uint8_t buf[4] = 0;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = "";
              *(_WORD *)&buf[18] = 2114;
              *(void *)&buf[20] = v9;
              __int16 v138 = 1026;
              LODWORD(v139) = v113;
              _os_log_impl( (void *)&_mh_execute_header,  v115,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#CUN Created client user notification for client, Client:%{public, location :escape_only}@, requestType:%{public}d}",  buf,  0x22u);
            }

            RunLoopSource = CFUserNotificationCreateRunLoopSource( alloc,  v114,  (CFUserNotificationCallBack)sub_10057D288,  0LL);
            if (RunLoopSource)
            {
              sub_10057D2F4(a4, v114, v112);
              CFRelease(v114);
              int v117 = (__CFRunLoop *)sub_10029228C();
              CFRunLoopAddSource(v117, RunLoopSource, kCFRunLoopCommonModes);
              CFRelease(RunLoopSource);
              __int16 v118 = operator new(0x48uLL);
              sub_1005859E4((uint64_t)v118, a4);
              sub_10057D1B4((uint64_t *)(a1 + 272), (uint64_t)v118);
              sub_10055E9A8((uint64_t)[*(id *)(a1 + 32) vendor]);
              return 1LL;
            }

            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
            __int16 v120 = (os_log_s *)qword_101934988;
            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)__int128 buf = 68289282;
              *(_DWORD *)&uint8_t buf[4] = 0;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = "";
              *(_WORD *)&buf[18] = 2114;
              *(void *)&buf[20] = v9;
              _os_log_impl( (void *)&_mh_execute_header,  v120,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#CUN Could not create runloop source for  CFUserNotification, Client:%{publ ic, location:escape_only}@}",  buf,  0x1Cu);
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
            }

            int v121 = (os_log_s *)qword_101934988;
            if (os_signpost_enabled((os_log_t)qword_101934988))
            {
              *(_DWORD *)__int128 buf = 68289282;
              *(_DWORD *)&uint8_t buf[4] = 0;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = "";
              *(_WORD *)&buf[18] = 2114;
              *(void *)&buf[20] = v9;
              _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v121,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#CUN Could not create runloop source for  CFUserNotification",  "{msg%{public}.0s:#CUN Could not create runloop source for  CFUserNotification, Client:%{publ ic, location:escape_only}@}",  buf,  0x1Cu);
            }

            CFRelease(v114);
            return 0LL;
          }

          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          int v119 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)__int128 buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            *(_WORD *)&buf[18] = 2114;
            *(void *)&buf[20] = v9;
            _os_log_impl( (void *)&_mh_execute_header,  v119,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#CUN Could not create CFUserNotification, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
          }

          uint64_t v18 = (os_log_s *)qword_101934988;
          if (!os_signpost_enabled((os_log_t)qword_101934988)) {
            return 0LL;
          }
          *(_DWORD *)__int128 buf = 68289282;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2114;
          *(void *)&buf[20] = v9;
          __int16 v20 = "#CUN Could not create CFUserNotification";
          char v21 = "{msg%{public}.0s:#CUN Could not create CFUserNotification, Client:%{public, location:escape_only}@}";
LABEL_28:
          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v20,  v21,  buf,  0x1Cu);
          return 0LL;
        }

void sub_10054A424( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *__p, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
}

void sub_10054A498(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if ([v3 isValidCKP])
  {
    id v4 = (void *)(a1 + 912);
    if (v3)
    {
      [v3 cppClientKey];
    }

    else
    {
      __int128 __p = 0LL;
      unsigned int v15 = 0LL;
      uint64_t v16 = 0LL;
    }

    unsigned int v5 = sub_100121918(v4, (unsigned __int8 *)&__p);
    id v6 = v5;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      if (!v6) {
        return;
      }
    }

    else if (!v5)
    {
      return;
    }

    for (uint64_t i = (void *)*((void *)v6 + 7); i; uint64_t i = (void *)*i)
    {
      uint64_t v8 = (std::__shared_weak_count *)i[4];
      if (v8)
      {
        id v9 = std::__shared_weak_count::lock(v8);
        unsigned int v15 = v9;
        if (v9)
        {
          id v10 = v9;
          BOOL v11 = (void *)i[3];
          __int128 __p = v11;
          if (v11) {
            sub_1004C6C00((uint64_t)v11);
          }
          p_shared_owners = (unint64_t *)&v10->__shared_owners_;
          do
            unint64_t v13 = __ldaxr(p_shared_owners);
          while (__stlxr(v13 - 1, p_shared_owners));
          if (!v13)
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
          }
        }
      }
    }

    sub_10005BEB8(v4, v6, (uint64_t)&__p);
    sub_100586930((uint64_t)&__p, 0LL);
  }

void sub_10054A5AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10054A5D8(uint64_t a1)
{
  for (uint64_t i = *(void **)(a1 + 928); i; uint64_t i = (void *)*i)
  {
    for (j = (void *)i[7]; j; j = (void *)*j)
    {
      id v4 = (std::__shared_weak_count *)j[4];
      if (v4)
      {
        unsigned int v5 = std::__shared_weak_count::lock(v4);
        if (v5)
        {
          id v6 = v5;
          uint64_t v7 = j[3];
          if (v7) {
            sub_1004C6C00(v7);
          }
          p_shared_owners = (unint64_t *)&v6->__shared_owners_;
          do
            unint64_t v9 = __ldaxr(p_shared_owners);
          while (__stlxr(v9 - 1, p_shared_owners));
          if (!v9)
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
        }
      }
    }
  }

  sub_100588228(a1 + 912);
}

void sub_10054A680( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10054A694(uint64_t a1, uint64_t *a2)
{
  else {
    id v4 = (uint64_t *)*a2;
  }
  if (objc_msgSend( objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithClientKey:]( CLClientKeyPath,  "clientKeyPathWithClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v4))),  "isValidCKP"))
  {
    unsigned int v5 = (void *)(a1 + 912);
    id v6 = sub_100121918(v5, (unsigned __int8 *)a2);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = v6 + 40;
      unint64_t v9 = sub_1005882B8((void *)v6 + 5, a2 + 6);
      if (v9)
      {
        id v10 = v9;
        BOOL v11 = (std::__shared_weak_count *)v9[4];
        if (v11)
        {
          uint64_t v12 = v9[3];
          p_shared_weak_owners = (unint64_t *)&v11->__shared_weak_owners_;
          do
            unint64_t v14 = __ldxr(p_shared_weak_owners);
          while (__stxr(v14 + 1, p_shared_weak_owners));
          unsigned int v15 = std::__shared_weak_count::lock(v11);
          if (v15)
          {
            uint64_t v16 = v15;
            if (v12)
            {
              p_shared_owners = (unint64_t *)&v15->__shared_owners_;
              do
                unint64_t v18 = __ldaxr(p_shared_owners);
              while (__stlxr(v18 - 1, p_shared_owners));
              if (!v18)
              {
                ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
                std::__shared_weak_count::__release_weak(v16);
              }

              std::__shared_weak_count::__release_weak(v11);
              return;
            }

            sub_1005883C8(v8, v10);
            int v19 = (unint64_t *)&v16->__shared_owners_;
            do
              unint64_t v20 = __ldaxr(v19);
            while (__stlxr(v20 - 1, v19));
            if (!v20)
            {
              ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
              std::__shared_weak_count::__release_weak(v16);
            }
          }

          else
          {
            sub_1005883C8(v8, v10);
          }

          std::__shared_weak_count::__release_weak(v11);
        }

        else
        {
          sub_1005883C8(v8, v9);
        }
      }

      if (!*((void *)v7 + 8))
      {
        sub_10005BEB8(v5, v7, (uint64_t)v21);
        sub_100586930((uint64_t)v21, 0LL);
      }
    }
  }

void sub_10054A854(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned __int8 *a4@<X8>)
{
  *a4 = 0;
  *(int64x2_t *)(a4 + _Block_object_dispose(va, 8) = vdupq_n_s64(0x7FF0000000000000uLL);
  *((_DWORD *)a4 + 6) = 0;
  *(_DWORD *)(a4 + 27) = 0;
  uint64_t v7 = (void *)a1[94];
  uint64_t v8 = a1 + 95;
  if (v7 == a1 + 95)
  {
    int v10 = 0;
  }

  else
  {
    int v10 = 0;
    do
    {
      uint64_t v11 = v7[5];
      unsigned int v12 = objc_msgSend(sub_10086D1D8(v11, 0), "isEqual:", a2);
      BOOL v13 = v11 != a3 || a3 == 0;
      if (v13 && v12 != 0)
      {
        sub_100878DE4(v11, (uint64_t)buf);
        if ((_BYTE)v76) {
          sub_100FE3EF4((double *)a4, (double *)buf);
        }
        ++v10;
      }

      unsigned int v15 = (void *)v7[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          unsigned int v15 = (void *)*v15;
        }

        while (v15);
      }

      else
      {
        do
        {
          uint64_t v16 = (void *)v7[2];
          BOOL v13 = *v16 == (void)v7;
          uint64_t v7 = v16;
        }

        while (!v13);
      }

      uint64_t v7 = v16;
    }

    while (v16 != v8);
  }

  BOOL v17 = (void *)a1[103];
  if (v17 == a1 + 104)
  {
    BOOL v20 = 0;
    int v19 = 0;
    int v18 = 0;
  }

  else
  {
    int v18 = 0;
    int v19 = 0;
    BOOL v20 = 0;
    do
    {
      uint64_t v21 = v17[5];
      if ([(id)sub_100019240(v21) isEqual:a2])
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v21 + 24LL))(v21) == 1)
        {
          ++v18;
          sub_1003FF1C4(v21, (uint64_t)buf);
          BOOL v20 = (buf[0] | v20) != 0;
          sub_100FE3EF4((double *)a4, (double *)buf);
        }

        else if ((*(unsigned int (**)(uint64_t))(*(void *)v21 + 24LL))(v21) == 3)
        {
          ++v19;
        }
      }

      __int16 v22 = (void *)v17[1];
      if (v22)
      {
        do
        {
          unsigned int v23 = v22;
          __int16 v22 = (void *)*v22;
        }

        while (v22);
      }

      else
      {
        do
        {
          unsigned int v23 = (void *)v17[2];
          BOOL v13 = *v23 == (void)v17;
          BOOL v17 = v23;
        }

        while (!v13);
      }

      BOOL v17 = v23;
    }

    while (v23 != a1 + 104);
  }

  HIDWORD(v44) = v18;
  NSErrorUserInfoKey v24 = (void *)a1[106];
  __int16 v25 = a1 + 107;
  if (v24 == a1 + 107)
  {
    int v27 = 0;
    int v26 = 0;
  }

  else
  {
    int v26 = 0;
    int v27 = 0;
    do
    {
      uint64_t v28 = v24[4];
      if ([(id)sub_100019240(v28) isEqual:a2])
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)v28 + 24LL))(v28) == 1)
        {
          ++v26;
          sub_1003FF1C4(v28, (uint64_t)buf);
          BOOL v20 = (buf[0] | v20) != 0;
          sub_100FE3EF4((double *)a4, (double *)buf);
        }

        else if ((*(unsigned int (**)(uint64_t))(*(void *)v28 + 24LL))(v28) == 3)
        {
          ++v27;
        }
      }

      unsigned int v29 = (void *)v24[1];
      if (v29)
      {
        do
        {
          int v30 = v29;
          unsigned int v29 = (void *)*v29;
        }

        while (v29);
      }

      else
      {
        do
        {
          int v30 = (void *)v24[2];
          BOOL v13 = *v30 == (void)v24;
          NSErrorUserInfoKey v24 = v30;
        }

        while (!v13);
      }

      NSErrorUserInfoKey v24 = v30;
    }

    while (v30 != v25);
  }

  if ((v27 + v19 < 0) ^ __OFADD__(v27, v19) | (v27 + v19 == 0)) {
    char v31 = 0;
  }
  else {
    char v31 = 1;
  }
  a4[30] |= v20 & v31;
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v32 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    int v33 = *a4;
    int v34 = a4[29];
    int v35 = a4[28];
    uint64_t v36 = *((void *)a4 + 1);
    uint64_t v37 = *((void *)a4 + 2);
    *(_DWORD *)__int128 buf = 138414850;
    uint64_t v68 = a2;
    __int16 v69 = 1024;
    int v70 = v10;
    __int16 v71 = 1024;
    int v72 = HIDWORD(v44);
    __int16 v73 = 1024;
    int v74 = v19;
    __int16 v75 = 1024;
    int v76 = v26;
    __int16 v77 = 1024;
    int v78 = v27;
    __int16 v79 = 1024;
    int v80 = v33;
    __int16 v81 = 1024;
    int v82 = v34;
    __int16 v83 = 1024;
    int v84 = v35;
    __int16 v85 = 2048;
    uint64_t v86 = v36;
    __int16 v87 = 2048;
    uint64_t v88 = v37;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "client, '%@', app's CLDC cnt, %d, DICLU cnt[connected: %d, disconnected: %d], DICBAS cnt[connected: %d, disconnect ed: %d], active, %d, spectator, %d, batchEnabled, %d, desiredAccuracy, %.2f, distanceFilter, %.2f",  buf,  0x50u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v38 = *a4;
    int v39 = a4[29];
    int v40 = a4[28];
    uint64_t v41 = *((void *)a4 + 1);
    uint64_t v42 = *((void *)a4 + 2);
    int v45 = 138414850;
    uint64_t v46 = a2;
    __int16 v47 = 1024;
    int v48 = v10;
    __int16 v49 = 1024;
    int v50 = HIDWORD(v44);
    __int16 v51 = 1024;
    int v52 = v19;
    __int16 v53 = 1024;
    int v54 = v26;
    __int16 v55 = 1024;
    int v56 = v27;
    __int16 v57 = 1024;
    int v58 = v38;
    __int16 v59 = 1024;
    int v60 = v39;
    __int16 v61 = 1024;
    int v62 = v40;
    __int16 v63 = 2048;
    uint64_t v64 = v41;
    __int16 v65 = 2048;
    uint64_t v66 = v42;
    LODWORD(v44) = 80;
    uint64_t v43 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "client, '%@', app's CLDC cnt, %d, DICLU cnt[connected: %d, disconnected: %d], DICBAS cnt[connected: %d, disconnected: %d], active, %d, spectator, %d, batchEnabled, %d, desiredAccuracy, %.2f, distanceFilter, %.2f",  &v45,  v44);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLClientManager_Type::ClientState CLClientManager::getAggregateLocationAppInfo(CLClientKeyPath *, CLDaemonClient *)",  "%s\n",  v43);
  }

void sub_10054AD80(uint64_t a1, uint64_t a2, int a3, _BYTE *a4)
{
  *a4 = 0;
  id v8 = sub_10086D1D8(a2, 0);
  unint64_t v9 = *(void **)(a1 + 752);
  if (v9 != (void *)(a1 + 760))
  {
    id v10 = v8;
    int v11 = 0;
    while (1)
    {
      uint64_t v12 = v9[5];
      unsigned int v13 = objc_msgSend(sub_10086D1D8(v12, 0), "isEqual:", v10);
      if (v12 == a2) {
        int v14 = a3;
      }
      else {
        int v14 = 1;
      }
      if ((v13 & v14) != 1) {
        goto LABEL_11;
      }
      ++v11;
      sub_1010DDBC0(__p, "kCLConnectionMessageRanging");
      char v15 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)v12 + 48LL))(v12, __p);
      char v16 = v15;
      if (SHIBYTE(v37) < 0) {
        break;
      }
      if ((v15 & 1) != 0) {
        goto LABEL_10;
      }
LABEL_11:
      BOOL v17 = (void *)v9[1];
      if (v17)
      {
        do
        {
          int v18 = v17;
          BOOL v17 = (void *)*v17;
        }

        while (v17);
      }

      else
      {
        do
        {
          int v18 = (void *)v9[2];
          BOOL v19 = *v18 == (void)v9;
          unint64_t v9 = v18;
        }

        while (!v19);
      }

      unint64_t v9 = v18;
      if (v18 == (void *)(a1 + 760)) {
        goto LABEL_21;
      }
    }

    operator delete(*(void **)__p);
    if ((v16 & 1) == 0) {
      goto LABEL_11;
    }
LABEL_10:
    *a4 = 1;
    goto LABEL_11;
  }

  int v11 = 0;
LABEL_21:
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  BOOL v20 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    id v21 = sub_10086D1D8(a2, 0);
    int v22 = *a4;
    *(_DWORD *)__int128 __p = 138412802;
    *(void *)&__p[4] = v21;
    __int16 v34 = 1024;
    int v35 = v11;
    __int16 v36 = 1024;
    int v37 = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "client, '%@', app's client cnt, %d, active, %d",  __p,  0x18u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v23 = qword_101934988;
    id v24 = sub_10086D1D8(a2, 0);
    int v25 = *a4;
    int v27 = 138412802;
    id v28 = v24;
    __int16 v29 = 1024;
    int v30 = v11;
    __int16 v31 = 1024;
    int v32 = v25;
    int v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v23,  2LL,  "client, '%@', app's client cnt, %d, active, %d",  &v27,  24);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::getAggregateRangeAppInfo(CLDaemonClient *, BOOL, BOOL &)",  "%s\n",  v26);
    if (v26 != __p) {
      free(v26);
    }
  }

void sub_10054B088( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10054B0AC(uint64_t a1, uint64_t a2, int a3)
{
  unsigned __int8 v9 = 0;
  sub_10054AD80(a1, a2, a3, &v9);
  id v5 = sub_10086D1D8(a2, 0);
  uint64_t v6 = v9;
  double Current = CFAbsoluteTimeGetCurrent();
  return sub_10056CADC(a1, v5, 2LL, v6, 0LL, 0LL, Current);
}

id sub_10054B118(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = sub_10053D6E0(a1, a2);
  sub_10054A854((void *)a1, (uint64_t)v5, a3, v9);
  sub_10054B1A4(a1, (uint64_t)v5, v9);
  uint64_t v6 = v9[30];
  double Current = CFAbsoluteTimeGetCurrent();
  id result = (id)sub_10056CADC(a1, v5, 5LL, v6, 0LL, 0LL, Current);
  if ((_DWORD)result) {
    return [*(id *)(a1 + 136) persist];
  }
  return result;
}

void sub_10054B1A4(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  id v5 = sub_1005486B8(a1, a2);
  uint64_t v6 = (uint64_t)v5;
  if (v5)
  {
    [v5 cppClientKey];
  }

  else
  {
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v18 = 0LL;
  }

  if (*a3)
  {
    if (sub_10057CA70(a1, v6, (uint64_t)a3))
    {
      sub_10002276C((uint64_t **)(a1 + 664), (const void **)__p, (uint64_t)__p);
    }

    if (*((double *)a3 + 1) == INFINITY)
    {
      if (*((_DWORD *)a3 + 6))
      {
        if (a3[29]) {
          double v8 = 2147483650.0;
        }
        else {
          double v8 = -1.0;
        }
        [*(id *)(a1 + 136) setDouble:@"LocationDesiredAccuracy" forKey:v6 atKeyPath:v8];
        unsigned __int8 v9 = sub_10057C950(v8);
        [*(id *)(a1 + 136) setArray:v9 forKey:@"LocationTechnologiesInUse" atKeyPath:v6];
        CFRelease(v9);
      }

      else
      {
        [*(id *)(a1 + 136) removeValueForKey:@"LocationDesiredAccuracy" atKeyPath:v6];
        [*(id *)(a1 + 136) removeValueForKey:@"LocationTechnologiesInUse" atKeyPath:v6];
      }
    }

    else
    {
      objc_msgSend(*(id *)(a1 + 136), "setDouble:forKey:atKeyPath:", @"LocationDesiredAccuracy", v6);
      uint64_t v7 = sub_10057C950(*((double *)a3 + 1));
      [*(id *)(a1 + 136) setArray:v7 forKey:@"LocationTechnologiesInUse" atKeyPath:v6];
      CFRelease(v7);
    }

    id v10 = *(void **)(a1 + 136);
    else {
      objc_msgSend(v10, "setDouble:forKey:atKeyPath:", @"LocationDistanceFilter", v6);
    }
    [*(id *)(a1 + 136) setBool:a3[28] forKey:@"BatchEnabled" atKeyPath:v6];
  }

  else
  {
    sub_100588FC8((uint64_t **)(a1 + 664), (const void **)__p);
    sub_100588FC8((uint64_t **)(a1 + 688), (const void **)__p);
    [*(id *)(a1 + 136) removeValueForKey:@"LocationTechnologiesInUse" atKeyPath:v6];
    [*(id *)(a1 + 136) removeValueForKey:@"LocationDesiredAccuracy" atKeyPath:v6];
    [*(id *)(a1 + 136) removeValueForKey:@"LocationDistanceFilter" atKeyPath:v6];
    [*(id *)(a1 + 136) removeValueForKey:@"BatchEnabled" atKeyPath:v6];
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  int v11 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v12 = *(void *)(a1 + 680);
    *(_DWORD *)__int128 buf = 134349056;
    uint64_t v22 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "currently %{public}lu non-system location clients",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = *(void *)(a1 + 680);
    int v19 = 134349056;
    uint64_t v20 = v15;
    char v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "currently %{public}lu non-system location clients",  &v19,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::setClientState(CLClientKeyPath *, const CLClientManager_Type::ClientState &)",  "%s\n",  v16);
  }

  int v13 = *a3;
  double Current = CFAbsoluteTimeGetCurrent();
  sub_10056CADC(a1, v6, 4LL, v13 != 0, 0LL, 0LL, Current);
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[0]);
  }
}

void sub_10054B5D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CLClientManagerAuthorizationContext *sub_10054B60C(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  id v5 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  BOOL v6 = sub_10053D890(a1, (uint64_t)v5);
  uint64_t v7 = sub_1008FE810(*(void *)(a1 + 376), v5);
  double v8 = +[NSMutableDictionary dictionaryWithDictionary:]( NSMutableDictionary,  "dictionaryWithDictionary:",  objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v5), "dictionary"));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v8,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v7),  @"InUseLevel");
  if ([*(id *)(a1 + 120) locationRestricted]) {
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v8,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"LocationRestricted");
  }
  sub_100553E64(a1, v5, v8);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  unsigned __int8 v9 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68290050;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2114;
    *(void *)&buf[20] = v5;
    *(_WORD *)&_BYTE buf[28] = 2114;
    *(void *)&buf[30] = v8;
    *(_WORD *)&_BYTE buf[38] = 1026;
    *(_DWORD *)&buf[40] = v6;
    *(_WORD *)&buf[44] = 2050;
    *(void *)&buf[46] = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:computing freshAuthorizationContext, Client:%{public, location:escape_only}@, Clien tDictionary:%{public, location:escape_only}@, BigSwitch:%{public}hhd, InUseLevel:%{public, location:CLCl ientInUseLevel}lld}",  buf,  0x36u);
  }

  id v10 = sub_1005467FC(a1, (uint64_t)v5);
  unsigned int v11 = objc_msgSend( -[NSArray objectAtIndexedSubscript:](v10, "objectAtIndexedSubscript:", 1),  "intValue");
  unsigned int v12 = objc_msgSend( -[NSArray objectAtIndexedSubscript:](v10, "objectAtIndexedSubscript:", 2),  "intValue");
  __int128 v13 = a3[7];
  __int128 v31 = a3[6];
  __int128 v32 = v13;
  v33[0] = a3[8];
  *(_OWORD *)((char *)v33 + 12) = *(_OWORD *)((char *)a3 + 140);
  __int128 v14 = a3[3];
  *(_OWORD *)&uint8_t buf[32] = a3[2];
  *(_OWORD *)&buf[48] = v14;
  __int128 v15 = a3[5];
  __int128 v29 = a3[4];
  __int128 v30 = v15;
  __int128 v16 = a3[1];
  *(_OWORD *)__int128 buf = *a3;
  *(_OWORD *)&uint8_t buf[16] = v16;
  if (sub_100553FBC(a1, (uint64_t)v5) && *(double *)&buf[20] < 0.0)
  {
    BOOL v17 = *(void **)(a1 + 352);
    if (v17)
    {
      objc_msgSend(v17, "currentLocation", *(double *)&buf[20]);
    }

    else
    {
      __int128 v26 = 0u;
      memset(v27, 0, 28);
      __int128 v24 = 0u;
      __int128 v25 = 0u;
      __int128 v23 = 0u;
      memset(v22, 0, sizeof(v22));
    }

    __int128 v31 = v25;
    __int128 v32 = v26;
    v33[0] = v27[0];
    *(_OWORD *)((char *)v33 + 12) = *(_OWORD *)((char *)v27 + 12);
    *(_OWORD *)&uint8_t buf[32] = *(_OWORD *)&v22[32];
    *(_OWORD *)&buf[48] = *(_OWORD *)&v22[48];
    __int128 v29 = v23;
    __int128 v30 = v24;
    *(_OWORD *)__int128 buf = *(_OWORD *)v22;
    *(_OWORD *)&uint8_t buf[16] = *(_OWORD *)&v22[16];
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v19 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v22 = 68290307;
      *(_DWORD *)&v22[4] = 0;
      *(_WORD *)&_WORD v22[8] = 2082;
      *(void *)&v22[10] = "";
      *(_WORD *)&v22[18] = 2114;
      *(void *)&v22[20] = v5;
      *(_WORD *)&v22[28] = 1040;
      *(_DWORD *)&v22[30] = 156;
      *(_WORD *)&v22[34] = 2097;
      *(void *)&v22[36] = a3;
      *(_WORD *)&v22[44] = 1040;
      *(_DWORD *)&v22[46] = 156;
      *(_WORD *)&v22[50] = 2097;
      *(void *)&v22[52] = buf;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#pla freshAuthorizationContext location updated, Client:%{public, location:escape_o nly}@, provided-location:%{private, location:CLClientLocation}.*P, fetched-location-ZRT:%{private, locat ion:CLClientLocation}.*P}",  v22,  0x3Cu);
    }
  }

  v20[6] = v31;
  v20[7] = v32;
  v21[0] = v33[0];
  *(_OWORD *)((char *)v21 + 12) = *(_OWORD *)((char *)v33 + 12);
  v20[2] = *(_OWORD *)&buf[32];
  v20[3] = *(_OWORD *)&buf[48];
  v20[4] = v29;
  void v20[5] = v30;
  v20[0] = *(_OWORD *)buf;
  v20[1] = *(_OWORD *)&buf[16];
  return sub_100AE1A9C(v8, v11, v12, v6, (uint64_t)v20);
}

uint64_t sub_10054BA24(id *a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  id v7 = sub_10053D6E0((uint64_t)a1, a2);
  id v8 = [v7 legacyClientKey];
  unsigned int v9 = sub_100553FBC((uint64_t)a1, (uint64_t)v7);
  id v10 = a1[127];
  if (v9)
  {
    if ([v10 objectForKeyedSubscript:v8])
    {
      [a1[127] removeObjectForKey:v8];
      objc_msgSend(a1[126], "setClientsAuthorizationMap:", objc_msgSend(a1[127], "copy"));
    }

    sub_10053D5F8( (uint64_t)a1,  v7,  (NSMutableDictionary *)objc_msgSend(objc_msgSend(a1[17], "readonlyStoreAtKeyPath:", v7), "dictionary"));
    uint64_t v11 = 1LL;
  }

  else
  {
    unsigned int v12 = objc_msgSend(objc_msgSend(v10, "objectForKeyedSubscript:", v8), "isEqual:", a3);
    if ((v12 & 1) == 0)
    {
      id v13 = a1[17];
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472LL;
      v15[2] = sub_10056013C;
      v15[3] = &unk_10183FC80;
      v15[4] = v7;
      v15[5] = a3;
      v15[6] = v8;
      v15[7] = a1;
      [v13 iterateIdentitiesRelatedToKeyPath:v7 withBlock:v15];
      objc_msgSend(a1[126], "setClientsAuthorizationMap:", objc_msgSend(a1[127], "copy"));
    }

    uint64_t v11 = v12 ^ 1;
  }

  return v11;
}

void sub_10054BB84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_10054BBA4(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v7 = sub_100547A14(a3);
  double Current = CFAbsoluteTimeGetCurrent();
  return sub_10056CADC(a1, a2, v7, a4, 0, 0, Current);
}

uint64_t sub_10054BBF8(uint64_t a1, uint64_t a2, int a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  return sub_10056CADC(a1, a2, 6LL, a3, 0, 0, Current);
}

void sub_10054BC40(id *a1, uint64_t a2, double *a3)
{
  id v6 = [a1[17] registeredKeyPathForClientIdentifier:a2];
  if ([v6 isValidCKP])
  {
    [a1[17] setDouble:@"TimeMissing" forKey:v6 atKeyPath:*a3];
    uint64_t v7 = sub_10054B60C((uint64_t)a1, (uint64_t)v6, &xmmword_101339630);
    sub_10054BA24(a1, (uint64_t)v6, (uint64_t)v7);
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      int v10 = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      id v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:How can an app be missing if we don't have an entry for it?, Client:%{public, locat ion:escape_only}@}",  (uint8_t *)&v10,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    unsigned int v9 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      int v10 = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      id v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = a2;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "How can an app be missing if we don't have an entry for it?",  "{msg%{public}.0s:How can an app be missing if we don't have an entry for it?, Client:%{public, locat ion:escape_only}@}",  (uint8_t *)&v10,  0x1Cu);
    }
  }

id sub_10054BE50(id *a1, uint64_t a2)
{
  id v3 = [a1[17] registeredKeyPathForClientIdentifier:a2];
  id result = [v3 isValidCKP];
  if ((_DWORD)result)
  {
    [a1[17] removeValueForKey:@"TimeMissing" atKeyPath:v3];
    id v5 = sub_10054B60C((uint64_t)a1, (uint64_t)v3, &xmmword_101339630);
    return (id)sub_10054BA24(a1, (uint64_t)v3, (uint64_t)v5);
  }

  return result;
}

id sub_10054BEC8(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  id result = [v3 isValidCKP];
  if ((_DWORD)result) {
    return [*(id *)(a1 + 136) intForKey:@"PromptedSettings" atKeyPath:v3 defaultValue:0];
  }
  return result;
}

id sub_10054BF20(uint64_t a1, uint64_t a2)
{
  id v3 = sub_10053D6E0(a1, a2);
  objc_msgSend( *(id *)(a1 + 136),  "setInt:forKey:atKeyPath:",  objc_msgSend( *(id *)(a1 + 136),  "intForKey:atKeyPath:defaultValue:",  @"PromptedSettings",  v3,  0)
  + 1,
    @"PromptedSettings",
    v3);
  [*(id *)(a1 + 136) persist];
  id v4 = *(void **)(a1 + 136);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_100554B60;
  v6[3] = &unk_10183FB60;
  v6[4] = v3;
  void v6[5] = a1;
  return [v4 iterateIdentitiesRelatedToKeyPath:v3 withBlock:v6];
}

void sub_10054BFD4(uint64_t a1, void *a2, int a3, uint64_t *a4)
{
  if ([*(id *)(a1 + 136) isKeyPathRegisteredSystemService:a2])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      __int128 __p = (void *)68289282;
      *(_WORD *)id v21 = 2082;
      *(void *)&_OWORD v21[2] = "";
      *(_WORD *)&v21[10] = 2114;
      *(void *)&v21[12] = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#ClearClient removing client entry for System Service, Client:%{public, location:escape_only}@}",  (uint8_t *)&__p,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    unsigned int v9 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      __int128 __p = (void *)68289282;
      *(_WORD *)id v21 = 2082;
      *(void *)&_OWORD v21[2] = "";
      *(_WORD *)&v21[10] = 2114;
      *(void *)&v21[12] = a2;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#ClearClient removing client entry for System Service",  "{msg%{public}.0s:#ClearClient removing client entry for System Service, Client:%{public, location:escape_only}@}",  (uint8_t *)&__p,  0x1Cu);
    }

    return;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  int v10 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    __int128 __p = (void *)68289282;
    *(_WORD *)id v21 = 2082;
    *(void *)&_OWORD v21[2] = "";
    *(_WORD *)&v21[10] = 2114;
    *(void *)&v21[12] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#ClearClient removing client entry, Client:%{public, location:escape_only}@}",  (uint8_t *)&__p,  0x1Cu);
  }

  sub_10054A498(a1, (uint64_t)a2);
  if (a3)
  {
    int v11 = (const char *)objc_msgSend(objc_msgSend(a2, "legacyClientKey"), "UTF8String");
    __int16 v12 = v11 ? (char *)v11 : "";
    sub_1010DDBC0(&__p, v12);
    sub_10054C4B0(a1, (uint64_t *)&__p, a4);
    if ((v21[15] & 0x80000000) != 0) {
      operator delete(__p);
    }
  }

  id v13 = (char *)objc_msgSend(objc_msgSend(a2, "clientAnchor"), "UTF8String");
  if (v13) {
    __int16 v14 = v13;
  }
  else {
    __int16 v14 = "";
  }
  sub_1010DDBC0(&__p, v14);
  uint64_t v15 = sub_100121918(qword_101996D48, (unsigned __int8 *)&__p);
  __int128 v16 = v15;
  if ((v21[15] & 0x80000000) != 0)
  {
    operator delete(__p);
    if (v16) {
      goto LABEL_25;
    }
LABEL_30:
    id v19 = [*(id *)(a1 + 416) objectForKey:a2];
    if (v19)
    {
      sub_10054C700(a1, a2, v19, 1);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      BOOL v17 = (os_log_s *)qword_101934988;
      if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_40;
      }
      __int128 __p = (void *)68289282;
      *(_WORD *)id v21 = 2082;
      *(void *)&_OWORD v21[2] = "";
      *(_WORD *)&v21[10] = 2114;
      *(void *)&v21[12] = a2;
      uint64_t v18 = "{msg%{public}.0s:#ClearClient Completely removed attribution for client, Client:%{public, locati"
            "on:escape_only}@}";
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      BOOL v17 = (os_log_s *)qword_101934988;
      if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_40;
      }
      __int128 __p = (void *)68289282;
      *(_WORD *)id v21 = 2082;
      *(void *)&_OWORD v21[2] = "";
      *(_WORD *)&v21[10] = 2114;
      *(void *)&v21[12] = a2;
      uint64_t v18 = "{msg%{public}.0s:#ClearClient client is not attributed. No special deattribution needed, Client:"
            "%{public, location:escape_only}@}";
    }

    goto LABEL_39;
  }

  if (!v15) {
    goto LABEL_30;
  }
LABEL_25:
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  BOOL v17 = (os_log_s *)qword_101934988;
  if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_40;
  }
  __int128 __p = (void *)68289282;
  *(_WORD *)id v21 = 2082;
  *(void *)&_OWORD v21[2] = "";
  *(_WORD *)&v21[10] = 2114;
  *(void *)&v21[12] = a2;
  uint64_t v18 = "{msg%{public}.0s:#ClearClient attribution unavailable client, Client:%{public, location:escape_only}@}";
LABEL_39:
  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&__p, 0x1Cu);
LABEL_40:
  objc_msgSend(*(id *)(a1 + 136), "removeDictionaryAtKeyPath:", a2, __p, *(_OWORD *)v21, *(void *)&v21[16]);
  [*(id *)(a1 + 136) persist];
  sub_1010DDBC0(&__p, "");
  sub_100544214(a1, a2, (uint64_t)&__p);
  if ((v21[15] & 0x80000000) != 0) {
    operator delete(__p);
  }
}

void sub_10054C488( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10054C4B0(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  if (sub_1004F7500())
  {
    id v6 = objc_alloc_init(&OBJC_CLASS___CLCompanionSyncAuthObject);
    else {
      uint64_t v7 = (uint64_t *)*a2;
    }
    -[CLCompanionSyncAuthObject setClientKey:]( v6,  "setClientKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v7));
    -[CLCompanionSyncAuthObject setOperationType:](v6, "setOperationType:", 3LL);
    id v8 = *(void **)(a1 + 1472);
    else {
      unsigned int v9 = (uint64_t *)*a3;
    }
    objc_msgSend( v8,  "deleteObject:withSyncSessionReason:",  v6,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9));
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      else {
        int v11 = (uint64_t *)*a2;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "#authsync deleteObject: %{public}s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      else {
        __int16 v12 = (uint64_t *)*a2;
      }
      int v14 = 136446210;
      uint64_t v15 = v12;
      id v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#authsync deleteObject: %{public}s",  &v14,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::synchronizeAuthorizationChangeTypeDelete(const std::string &, const std::string &)",  "%s\n",  v13);
    }
  }

id sub_10054C700(uint64_t a1, void *a2, void *a3, char a4)
{
  double v9 = v8;
  objc_msgSend(objc_msgSend(a3, "attributionTimer"), "invalidate");
  if (v9 < 1.79769313e308) {
    sub_100550924(a1, a2, (uint64_t)[a3 attributionIdentifier], a4);
  }
  return [*(id *)(a1 + 416) removeObjectForKey:a2];
}

id sub_10054C788(id *a1)
{
  return objc_msgSend(a1[126], "setPersistentStoreDictionary:forClient:", 0, objc_msgSend(0, "legacyClientKey"));
}

id sub_10054C7F4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 136);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_10054C880;
  v4[3] = &unk_10183F8B0;
  v4[4] = a1;
  return [v2 iterateAllAnchorKeyPathsWithBlock:v4];
}

uint64_t sub_10054C880(uint64_t a1, uint64_t a2)
{
  id v3 = *(id **)(a1 + 32);
  id v4 = sub_10054B60C((uint64_t)v3, a2, &xmmword_101339630);
  return sub_10054BA24(v3, a2, (uint64_t)v4);
}

id sub_10054C8BC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  id result = [v5 isValidCKP];
  if ((_DWORD)result)
  {
    uint64_t v7 = *(void **)(a1 + 136);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    _DWORD v8[2] = sub_100554458;
    v8[3] = &unk_10183FB38;
    v8[5] = a3;
    v8[6] = a1;
    v8[4] = v5;
    return [v7 iterateIdentitiesRelatedToKeyPath:v5 withBlock:v8];
  }

  return result;
}

void sub_10054C948( uint64_t a1@<X0>, uint64_t a2@<X1>, std::string *a3@<X2>, int a4@<W3>, std::string *a5@<X8>)
{
  id v9 = sub_1005486B8(a1, a2);
  if (a4 == 1)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2114;
      *(void *)&buf[20] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#IncidentalPrompt CLCM:InUseAssertion IncidentalPresence, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    sub_10054CC18(a1, v9);
  }

  int v11 = *(void **)(a1 + 376);
  if (v9)
  {
    [v9 cppClientKey];
  }

  else
  {
    v18[0] = 0LL;
    v18[1] = 0LL;
    uint64_t v19 = 0LL;
  }

  std::string __p = *a3;
  a3->__r_.__value_.__l.__size_ = 0LL;
  a3->__r_.__value_.__l.__cap_ = 0LL;
  a3->__r_.__value_.__r.__words[0] = 0LL;
  sub_1008FDE6C(&__p, v11, (uint64_t)v18, a4, (uint64_t *)a5);
  if (SHIBYTE(v19) < 0) {
    operator delete(v18[0]);
  }
  __int16 v12 = (char *)objc_msgSend(objc_msgSend(v9, "legacyClientKey"), "UTF8String");
  if (v12) {
    id v13 = v12;
  }
  else {
    id v13 = "";
  }
  sub_1010DDBC0(buf, v13);
  if (sub_1008FF190(a5))
  {
    sub_1000B9764(a1 + 552, buf, (uint64_t)buf);
    id v14 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:v9];
    if (v14)
    {
      if ([*(id *)(a1 + 392) objectForKeyedSubscript:v14])
      {
        if ((buf[23] & 0x80000000) != 0)
        {
          sub_1010DD48C(v15, *(void **)buf, *(unint64_t *)&buf[8]);
        }

        else
        {
          *(_OWORD *)uint64_t v15 = *(_OWORD *)buf;
          uint64_t v16 = *(void *)&buf[16];
        }

        sub_10054D494(a1, (uint64_t *)v15);
        if (SHIBYTE(v16) < 0) {
          operator delete(v15[0]);
        }
        sub_10054D6C8();
      }
    }
  }

  if ((buf[23] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
}

void sub_10054CBA4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  sub_1008FDB5C(v33);
  _Unwind_Resume(a1);
}

BOOL sub_10054CC18(uint64_t a1, void *a2)
{
  id v2 = a2;
  if (([a2 isValidCKP] & 1) == 0 && !objc_msgSend(*(id *)(a1 + 1032), "count"))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v18 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "#IncidentalPrompt skip prompting. No client for incidental prompt",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      v32[0] = 0;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#IncidentalPrompt skip prompting. No client for incidental prompt",  v32,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::considerPromptingForIncidentalUse(CLClientKeyPath *)",  "%s\n",  v19);
      return 0LL;
    }

    return result;
  }

  id v4 = sub_10053D6E0(a1, (uint64_t)v2);
  unsigned int v5 = sub_100AE0C24(objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v4), "dictionary"));
  if (v5 != 1)
  {
    unsigned int v6 = v5;
    if (v5)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v12 = qword_101934988;
      BOOL result = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO);
      if (!result) {
        return result;
      }
      *(_DWORD *)__int128 buf = 68289538;
      int v34 = 0;
      __int16 v35 = 2082;
      __int16 v36 = "";
      __int16 v37 = 2114;
      id v38 = v4;
      __int16 v39 = 2050;
      uint64_t v40 = v6;
      int v11 = "{msg%{public}.0s:#IncidentalPrompt skip prompting. IncidentalUseMode should be UnDetermined, Clien"
            "t:%{public, location:escape_only}@, IncidentalUseMode:%{public, location:CLClientIncidentalUseMode}lld}";
      id v13 = (os_log_s *)v12;
      os_log_type_t v14 = OS_LOG_TYPE_INFO;
      uint32_t v15 = 38;
      goto LABEL_52;
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v34 = 0;
      __int16 v35 = 2082;
      __int16 v36 = "";
      __int16 v37 = 2114;
      id v38 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#IncidentalPrompt Ineligible marking as NotDetermined, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    sub_10054F5AC(a1, 1LL, (uint64_t)v4);
  }

  double v8 = sub_100544790(a1, (uint64_t)v4, &xmmword_101339630);
  if (-[CLClientManagerAuthorizationContext registrationResult](v8, "registrationResult") != 1)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v16 = qword_101934988;
    BOOL result = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO);
    if (!result) {
      return result;
    }
    unsigned int v17 = -[CLClientManagerAuthorizationContext registrationResult](v8, "registrationResult");
    *(_DWORD *)__int128 buf = 68289538;
    int v34 = 0;
    __int16 v35 = 2082;
    __int16 v36 = "";
    __int16 v37 = 2114;
    id v38 = v4;
    __int16 v39 = 1026;
    LODWORD(v40) = v17;
    int v11 = "{msg%{public}.0s:#IncidentalPrompt skip prompting. Registration Result should be WIU, Client:%{pub"
          "lic, location:escape_only}@, RegistrationResult:%{public}d}";
    id v13 = (os_log_s *)v16;
    os_log_type_t v14 = OS_LOG_TYPE_INFO;
    uint32_t v15 = 34;
    goto LABEL_52;
  }

  if ([*(id *)(a1 + 120) locationRestricted])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v9 = qword_101934988;
    BOOL result = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO);
    if (result)
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v34 = 0;
      __int16 v35 = 2082;
      __int16 v36 = "";
      __int16 v37 = 2114;
      id v38 = v4;
      int v11 = "{msg%{public}.0s:#IncidentalPrompt skip prompting. Restrictions enabled, Client:%{public, locati"
            "on:escape_only}@}";
LABEL_51:
      id v13 = (os_log_s *)v9;
      os_log_type_t v14 = OS_LOG_TYPE_INFO;
      uint32_t v15 = 28;
      goto LABEL_52;
    }

    return result;
  }

  if (([*(id *)(a1 + 1032) containsObject:v4] & 1) == 0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v20 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v34 = 0;
      __int16 v35 = 2082;
      __int16 v36 = "";
      __int16 v37 = 2114;
      id v38 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#IncidentalPrompt client queued, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    [*(id *)(a1 + 1032) addObject:v4];
  }

  if (*(_BYTE *)(a1 + 996))
  {
    if (!*(void *)(a1 + 272))
    {
      sub_1010DDBC0(__p, "");
      sub_1005857F0((uint64_t)v31, 12, (uint64_t)v4, 0LL, (__int128 *)__p);
      BOOL v26 = sub_10054878C(a1, (uint64_t)v4, 0LL, (uint64_t)v31, 0LL);
      sub_1005858A0((uint64_t)v31);
      if (v30 < 0) {
        operator delete(__p[0]);
      }
      if (v26) {
        return 1LL;
      }
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v27 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 68289282;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2114;
        id v38 = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Warning Could not post #IncidentalUsePrompt, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      id v28 = (os_log_s *)qword_101934988;
      BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
      if (result)
      {
        *(_DWORD *)__int128 buf = 68289282;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2114;
        id v38 = v4;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v28,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Warning Could not post #IncidentalUsePrompt",  "{msg%{public}.0s:#Warning Could not post #IncidentalUsePrompt, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
        return 0LL;
      }

      return result;
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v21 = qword_101934988;
    BOOL v22 = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0LL;
    if (!v22) {
      return result;
    }
    __int128 v23 = *(unsigned int **)(a1 + 272);
    uint64_t v24 = *((void *)v23 + 1);
    uint64_t v25 = *v23;
    *(_DWORD *)__int128 buf = 68289794;
    int v34 = 0;
    __int16 v35 = 2082;
    __int16 v36 = "";
    __int16 v37 = 2114;
    id v38 = v4;
    __int16 v39 = 2114;
    uint64_t v40 = v24;
    __int16 v41 = 2050;
    uint64_t v42 = v25;
    int v11 = "{msg%{public}.0s:#IncidentalPrompt skip prompting. InflightPromptAuthorizationRequest found., Client"
          ":%{public, location:escape_only}@, inflightClient:%{public, location:escape_only}@, inflightRequestTyp"
          "e:%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}";
    id v13 = (os_log_s *)v21;
    os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
    uint32_t v15 = 48;
LABEL_52:
    _os_log_impl((void *)&_mh_execute_header, v13, v14, v11, buf, v15);
    return 0LL;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v9 = qword_101934988;
  BOOL result = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO);
  if (result)
  {
    *(_DWORD *)__int128 buf = 68289282;
    int v34 = 0;
    __int16 v35 = 2082;
    __int16 v36 = "";
    __int16 v37 = 2114;
    id v38 = v4;
    int v11 = "{msg%{public}.0s:#IncidentalPrompt skip prompting. Not at homescreen., Client:%{public, location:escape_only}@}";
    goto LABEL_51;
  }

  return result;
}

void sub_10054D460( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

id sub_10054D494(uint64_t a1, uint64_t *a2)
{
  id v4 = a2;
  unsigned int v5 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v4);
  id v6 = [*(id *)(a1 + 520) objectForKey:v5];
  if (v6)
  {
    [v6 doubleValue];
    double Current = v7;
  }

  else
  {
    double Current = CFAbsoluteTimeGetCurrent();
    objc_msgSend( *(id *)(a1 + 520),  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"),  v5);
  }

  id v9 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary", v5);
  int v11 = (uint64_t *)qword_101996D70;
  for (uint64_t i = qword_101996D78; v11 != (uint64_t *)i; ++v11)
  {
    uint64_t v12 = *v11;
    uint64_t v18 = 0LL;
    uint64_t v19 = 0LL;
    sub_100547724(v12, &v19, &v18);
    uint64_t v13 = v19;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    os_log_type_t v14 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      uint32_t v15 = a2;
      *(_DWORD *)__int128 buf = 68289794;
      int v21 = 0;
      __int16 v22 = 2082;
      __int128 v23 = "";
      __int16 v24 = 2082;
      uint64_t v25 = v15;
      __int16 v26 = 2050;
      uint64_t v27 = v12;
      __int16 v28 = 1026;
      int v29 = 1;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#usesync munged starttime for watch, client:%{public, location:escape_only}s, ser vice:%{public, location:CLClientServiceType}lld, isReceivingLocation:%{public}hhd}",  buf,  0x2Cu);
    }

    objc_msgSend( v9,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", Current),  v13);
  }

  sub_10054D6C8();
  return [*(id *)(a1 + 1464) client:v17 didChangeUsageData:v9];
}

uint64_t sub_10054D6C8()
{
  uint64_t v0 = sub_1002F8DDC();
  sub_1002AB3DC(v0);
  uint64_t v1 = sub_1002F8DDC();
  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 944LL))(v1);
}

uint64_t sub_10054D704(uint64_t a1, uint64_t a2)
{
  id v3 = objc_msgSend(sub_10053D6E0(a1, a2), "legacyClientKey");
  sub_1010DDBC0(__p, (char *)[v3 UTF8String]);
  sub_10054D7E0(a1, (uint64_t *)__p);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  [*(id *)(a1 + 520) removeObjectForKey:v3];
  sub_1010DDBC0(v5, (char *)[v3 UTF8String]);
  sub_100588F4C((void *)(a1 + 552), (unsigned __int8 *)v5);
  if (v6 < 0) {
    operator delete(v5[0]);
  }
  return sub_10054D6C8();
}

void sub_10054D7B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_10054D7E0(uint64_t a1, uint64_t *a2)
{
  id v3 = a2;
  id v4 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v3);
  id v5 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  char v8 = (uint64_t *)qword_101996D70;
  uint64_t v7 = qword_101996D78;
  if (qword_101996D70 != qword_101996D78)
  {
    *(void *)&__int128 v6 = 68289026LL;
    __int128 v19 = v6;
    do
    {
      uint64_t v9 = *v8;
      int v21 = 0LL;
      uint64_t v22 = 0LL;
      sub_100547724(v9, &v22, &v21);
      int v11 = v21;
      uint64_t v10 = v22;
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v12 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v13 = a2;
        *(_DWORD *)__int128 buf = 68289538;
        int v24 = 0;
        __int16 v25 = 2082;
        __int16 v26 = "";
        __int16 v27 = 2082;
        __int16 v28 = v13;
        __int16 v29 = 2050;
        uint64_t v30 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#usesync send stoptime due to expiry of temp assertion, client:%{public, location :escape_only}s, service:%{public, location:CLClientServiceType}lld}",  buf,  0x26u);
      }

      double Current = CFAbsoluteTimeGetCurrent();
      id v15 = [*(id *)(a1 + 520) objectForKey:v4];
      if (v15)
      {
        [v15 doubleValue];
      }

      else
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v17 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = v19;
          int v24 = 0;
          __int16 v25 = 2082;
          __int16 v26 = "";
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#usesync #Warning Missing start time but stop location usage sync is called}",  buf,  0x12u);
        }

        double v16 = Current + -10.0;
      }

      objc_msgSend( v5,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v16, v19),  v10);
      objc_msgSend( v5,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", Current),  v11);
      ++v8;
    }

    while (v8 != (uint64_t *)v7);
  }

  return [*(id *)(a1 + 1464) client:v4 didChangeUsageData:v5];
}

BOOL sub_10054DA88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = sub_10053D6E0(a1, a2);
  __int128 v6 = *(void **)(a1 + 136);
  if ((_DWORD)a3)
  {
    [v6 setInt:a3 forKey:@"InUseLevel" atKeyPath:v5];
    if ((int)a3 >= 3)
    {
      BOOL v7 = 0LL;
      *(void *)__int128 buf = 0LL;
      *(void *)id v15 = buf;
      *(void *)&void v15[8] = 0x2020000000LL;
      v15[16] = 0;
      goto LABEL_13;
    }
  }

  else
  {
    [v6 removeValueForKey:@"InUseLevel" atKeyPath:v5];
  }

  unsigned int v8 = [*(id *)(a1 + 136) hasValueForKey:@"TemporaryAuthorization" atKeyPath:v5];
  char v9 = v8;
  if (v8)
  {
    [*(id *)(a1 + 136) removeValueForKey:@"TemporaryAuthorization" atKeyPath:v5];
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)id v15 = 2082;
      *(void *)&v15[2] = "";
      *(_WORD *)&v15[10] = 2114;
      *(void *)&v15[12] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#TemporaryAuth Client has dropped below in-use-ness threshold, losing WIU status, Cli entKeyPath:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }
  }

  *(void *)__int128 buf = 0LL;
  *(void *)id v15 = buf;
  *(void *)&void v15[8] = 0x2020000000LL;
  v15[16] = 0;
  int v11 = *(void **)(a1 + 136);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _OWORD v13[2] = sub_10054DCA4;
  void v13[3] = &unk_10183FA48;
  v13[4] = buf;
  v13[5] = a1;
  [v11 iterateIdentitiesRelatedToKeyPath:v5 withBlock:v13];
  BOOL v7 = (v9 & 1) != 0 || *(_BYTE *)(*(void *)v15 + 24LL) != 0;
LABEL_13:
  _Block_object_dispose(buf, 8);
  return v7;
}

void sub_10054DC8C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10054DCA4(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if ([a2 subIdentityType] == 122)
  {
    unsigned int v5 = [*(id *)(v4 + 136) intForKey:@"TemporaryAuthorization" atKeyPath:a2 defaultValue:0];
    if (v5)
    {
      if ((v5 & 5) != 0)
      {
        sub_1010DDBC0(__p, "ClientRemoved");
        sub_10054BFD4(v4, a2, 1, (uint64_t *)__p);
        if (v9 < 0) {
          operator delete(__p[0]);
        }
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        __int128 v6 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 68289282;
          int v11 = 0;
          __int16 v12 = 2082;
          uint64_t v13 = "";
          __int16 v14 = 2114;
          id v15 = a2;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#TemporaryAuth  tmp authorized zone deleted, ClientKeyPath:%{public, location:escape_only}@}",  buf,  0x1Cu);
        }
      }

      else
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        BOOL v7 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 68289282;
          int v11 = 0;
          __int16 v12 = 2082;
          uint64_t v13 = "";
          __int16 v14 = 2114;
          id v15 = a2;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#TemporaryAuth key deleted for zone, ClientKeyPath:%{public, location:escape_only}@}",  buf,  0x1Cu);
        }

        [*(id *)(v4 + 136) removeValueForKey:@"TemporaryAuthorization" atKeyPath:a2];
      }

      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    }
  }

void sub_10054DECC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10054DEF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if ([v5 isValidCKP])
  {
    id v6 = objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v5), "dictionary");
    id v9 = [v5 legacyClientKey];
    id v10 = v6;
    sub_100E57638( (uint64_t)+[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v10,  &v9,  1LL),  (uint64_t)"clientStatus");
    sub_1010DDBC0(__p, "");
    sub_100544214(a1, v5, (uint64_t)__p);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }

void sub_10054DFF4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10054E018(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_10054E020(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if ([v5 isValidCKP])
  {
    id v6 = [*(id *)(a1 + 136) intForKey:@"IncidentalUseMode" atKeyPath:v5 defaultValue:0];
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "#IncidentalUseMode able to get client's incidental use mode",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      LOWORD(v12[0]) = 0;
      char v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#IncidentalUseMode able to get client's incidental use mode",  v12,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::getIncidentalUseMode(CLClientKeyPath *, void (^)(CLClientIncidentalUseMode))",  "%s\n",  v8);
    }
  }

  else
  {
    id v6 = 0LL;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v9 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67109120;
    int v14 = (int)v6;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#IncidentalUseMode  returning with value:%d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    v12[0] = 67109120;
    v12[1] = (_DWORD)v6;
    int v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#IncidentalUseMode  returning with value:%d",  v12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::getIncidentalUseMode(CLClientKeyPath *, void (^)(CLClientIncidentalUseMode))",  "%s\n",  v11);
  }

  return (*(uint64_t (**)(uint64_t, id))(a3 + 16))(a3, v6);
}

void sub_10054E348(uint64_t a1, int a2, void *a3)
{
  if (objc_opt_class(&OBJC_CLASS___CLPLocationConsumptionScoreInfo))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(v16) = 2082;
      *(void *)((char *)&v16 + 2) = "";
      WORD5(v16) = 1026;
      HIDWORD(v16) = a2;
      LOWORD(v17) = 2114;
      *(void *)((char *)&v17 + 2) = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LocationUtilityEvent Reported, utility:%{public}d, date:%{public, location:escape_only}@}",  buf,  0x22u);
    }

    BOOL v7 = (const __CFDate *)[a3 dateByAddingTimeInterval:-600.0];
    char v8 =  -[NSDateInterval initWithStartDate:endDate:]( objc_alloc(&OBJC_CLASS___NSDateInterval),  "initWithStartDate:endDate:",  v7,  a3);
    double AbsoluteTime = CFDateGetAbsoluteTime(v7);
    if (AbsoluteTime < CFAbsoluteTimeGetCurrent())
    {
      id v10 =  [[RTStoredLocationEnumerationOptions alloc] initWithDateInterval:v8 horizontalAccuracy:0 batchSize:0 boundingBoxLocation:14 type:0.0];
      [v10 setSmoothingRequired:1];
      *(void *)__int128 buf = 0LL;
      *(void *)&__int128 v16 = buf;
      *((void *)&v16 + 1) = 0x3052000000LL;
      *(void *)&__int128 v17 = sub_10054E61C;
      *((void *)&v17 + 1) = sub_10054E62C;
      uint64_t v18 = 0LL;
      id v11 = objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "proxyForService:forClient:",  @"CLRoutineMonitor",  @"CLClientManager");
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472LL;
      _OWORD v13[2] = sub_10054E638;
      void v13[3] = &unk_10183FA70;
      v13[5] = buf;
      void v13[6] = a1;
      v13[4] = v8;
      int v14 = a2;
      [v11 enumerateStoredLocationsWithOptions:v10 withReply:v13];
      _Block_object_dispose(buf, 8);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v12 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(v16) = 2082;
      *(void *)((char *)&v16 + 2) = "";
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLPLocationConsumptionScoreInfo doesn't exist in this platform.}",  buf,  0x12u);
    }
  }

void sub_10054E5FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10054E61C(uint64_t a1, uint64_t a2)
{
}

void sub_10054E62C(uint64_t a1)
{
}

void sub_10054E638(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  if (a3)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      int v29 = 68289282;
      int v30 = 0;
      __int16 v31 = 2082;
      __int128 v32 = "";
      __int16 v33 = 2114;
      *(void *)int v34 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LocationUtilityEvent Got error fetching locations from CoreRoutine, error:%{public , location:escape_only}@}",  (uint8_t *)&v29,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    id v6 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      int v29 = 68289282;
      int v30 = 0;
      __int16 v31 = 2082;
      __int128 v32 = "";
      __int16 v33 = 2114;
      *(void *)int v34 = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LocationUtilityEvent Got error fetching locations from CoreRoutine",  "{msg%{public}.0s:#LocationUtilityEvent Got error fetching locations from CoreRoutine, error:%{public , location:escape_only}@}",  (uint8_t *)&v29,  0x1Cu);
    }
  }

  else
  {
    uint64_t v10 = *(void *)(a1 + 48);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v11 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      int v29 = 68289538;
      int v30 = 0;
      __int16 v31 = 2082;
      __int128 v32 = "";
      __int16 v33 = 1026;
      *(_DWORD *)int v34 = a4;
      *(_WORD *)&v34[4] = 1026;
      *(_DWORD *)&v34[6] = [a2 count];
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LocationUtilityEvent Reply back from CoreRoutine, enumerationCompleted:%{public}d, count:%{public}d}",  (uint8_t *)&v29,  0x1Eu);
    }

    if ((a4 & 1) != 0)
    {
      if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL))
      {
        objc_msgSend(objc_msgSend(*(id *)(v10 + 496), "startDate"), "timeIntervalSinceReferenceDate");
        double v13 = v12;
        objc_msgSend(objc_msgSend(*(id *)(v10 + 496), "endDate"), "timeIntervalSinceReferenceDate");
        double v15 = v14;
        double v16 = v13 + (v14 - v13) * 0.5;
        objc_msgSend( objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), "timestamp"),  "timeIntervalSinceReferenceDate");
        if (v17 <= v16)
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          __int16 v25 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
          {
            id v26 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) timestamp];
            int v29 = 68290050;
            __int16 v31 = 2082;
            int v30 = 0;
            __int128 v32 = "";
            __int16 v33 = 2114;
            *(void *)int v34 = v26;
            *(_WORD *)&v34[8] = 2050;
            double v35 = v16;
            __int16 v36 = 2050;
            double v37 = v13;
            __int16 v38 = 2050;
            double v39 = v15;
            _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LocationUtilityEvent Location timestamp is earlier than or equal to last interval in archive. Will not persist., lastLocation.timestamp:%{public, location:escape_only}@, lastLocati onUtilityEventIntervalInArchiveMidPoint:%{public}.6f, lastLocationUtilityEventIntervalInArchiveSta rtTime:%{public}.6f, lastLocationUtilityEventIntervalInArchiveEndTime:%{public}.6f}",  (uint8_t *)&v29,  0x3Au);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
          }

          __int16 v27 = (os_log_s *)qword_101934988;
          if (os_signpost_enabled((os_log_t)qword_101934988))
          {
            id v28 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) timestamp];
            int v29 = 68290050;
            __int16 v31 = 2082;
            int v30 = 0;
            __int128 v32 = "";
            __int16 v33 = 2114;
            *(void *)int v34 = v28;
            *(_WORD *)&v34[8] = 2050;
            double v35 = v16;
            __int16 v36 = 2050;
            double v37 = v13;
            __int16 v38 = 2050;
            double v39 = v15;
            _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v27,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LocationUtilityEvent Location timestamp is earlier than or equal to last interval in archive. Will not persist.",  "{msg%{public}.0s:#LocationUtilityEvent Location timestamp is earlier than or equal to last interval in archive. Will not persist., lastLocation.timestamp:%{public, location:escape_only}@, lastLocati onUtilityEventIntervalInArchiveMidPoint:%{public}.6f, lastLocationUtilityEventIntervalInArchiveSta rtTime:%{public}.6f, lastLocationUtilityEventIntervalInArchiveEndTime:%{public}.6f}",  (uint8_t *)&v29,  0x3Au);
          }
        }

        else
        {
          *(double *)&uint64_t v18 = COERCE_DOUBLE( objc_msgSend( objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), "timestamp"),  "dateByAddingTimeInterval:",  -0.5));
          *(double *)&__int128 v19 = COERCE_DOUBLE( objc_msgSend( objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), "timestamp"),  "dateByAddingTimeInterval:",  0.5));
          id v20 = objc_alloc_init(&OBJC_CLASS___CLPLocationConsumptionScoreInfo);
          [v20 setStartTime:CFDateGetAbsoluteTime(v18)];
          [v20 setStopTime:CFDateGetAbsoluteTime(v19)];
          [v20 setScore:*(unsigned int *)(a1 + 56)];
          [*(id *)(v10 + 488) writeSecondaryObject:v20 toField:1];
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          int v21 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
          {
            id v22 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) timestamp];
            int v29 = 68289794;
            int v30 = 0;
            __int16 v31 = 2082;
            __int128 v32 = "";
            __int16 v33 = 2114;
            *(void *)int v34 = v22;
            *(_WORD *)&v34[8] = 2114;
            double v35 = *(double *)&v18;
            __int16 v36 = 2114;
            double v37 = *(double *)&v19;
            _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LocationUtilityEvent Persist utility event interval, lastLocation.timestamp: %{public, location:escape_only}@, locationUtilityEventIntervalStart:%{public, location:escape_only}@, locationUtilityEventIntervalEnd:%{public, location:escape_only}@}",  (uint8_t *)&v29,  0x30u);
          }

          *(void *)(v10 + 496) = -[NSDateInterval initWithStartDate:endDate:]( objc_alloc(&OBJC_CLASS___NSDateInterval),  "initWithStartDate:endDate:",  v18,  v19);
        }
      }

      else
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        __int128 v23 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v24 = *(void *)(a1 + 32);
          int v29 = 68289282;
          int v30 = 0;
          __int16 v31 = 2082;
          __int128 v32 = "";
          __int16 v33 = 2114;
          *(void *)int v34 = v24;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LocationUtilityEvent No locations in interval., interval:%{public, location:escape_only}@}",  (uint8_t *)&v29,  0x1Cu);
        }
      }
    }

    else if ([a2 count])
    {

      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [a2 lastObject];
    }
  }

id sub_10054EC9C(uint64_t a1, uint64_t a2)
{
  if (objc_opt_class(&OBJC_CLASS___CLPLocationConsumptionScoreInfo))
  {
    id obj = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v4 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v23 = 0;
      __int16 v24 = 2082;
      __int16 v25 = "";
      __int16 v26 = 2114;
      uint64_t v27 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LocationUtilityEvent Retrieval request, lookBackWindowStartDate:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    if (a2)
    {
      id v5 = *(void **)(a1 + 488);
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472LL;
      _OWORD v21[2] = sub_10054F19C;
      v21[3] = &unk_10183FA98;
      v21[4] = a2;
      v21[5] = obj;
      sub_10054EFE4(v5, 0LL, (uint64_t)v21);
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      __int128 v17 = 0u;
      __int128 v18 = 0u;
      id v6 = [obj countByEnumeratingWithState:&v17 objects:v32 count:16];
      if (v6)
      {
        id v7 = v6;
        uint64_t v8 = *(void *)v18;
        do
        {
          id v9 = 0LL;
          do
          {
            if (*(void *)v18 != v8) {
              objc_enumerationMutation(obj);
            }
            uint64_t v10 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)v9);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
            id v11 = (os_log_s *)qword_101934988;
            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
            {
              id v12 = [v10 startDate];
              id v13 = [v10 endDate];
              *(_DWORD *)__int128 buf = 68289794;
              int v23 = 0;
              __int16 v24 = 2082;
              __int16 v25 = "";
              __int16 v26 = 2114;
              uint64_t v27 = a2;
              __int16 v28 = 2114;
              id v29 = v12;
              __int16 v30 = 2114;
              id v31 = v13;
              _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LocationUtilityEvent Retrieved interval, lookBackWindowStartDate:%{public, location:escape_only}@, intervalStartDate:%{public, location:escape_only}@, intervalEndDate:%{p ublic, location:escape_only}@}",  buf,  0x30u);
            }

            id v9 = (char *)v9 + 1;
          }

          while (v7 != v9);
          id v7 = [obj countByEnumeratingWithState:&v17 objects:v32 count:16];
        }

        while (v7);
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    double v14 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      int v23 = 0;
      __int16 v24 = 2082;
      __int16 v25 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLPLocationConsumptionScoreInfo doesn't exist in this platform.}",  buf,  0x12u);
    }

    return 0LL;
  }

  return obj;
}

void sub_10054EFE4(void *a1, uint64_t a2, uint64_t a3)
{
  if (objc_opt_class(&OBJC_CLASS___CLPLocationConsumptionScoreInfo))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&__int128 v10 = buf;
    *((void *)&v10 + 1) = 0x2020000000LL;
    uint64_t v11 = 0LL;
    v8[0] = 0LL;
    v8[1] = v8;
    _DWORD v8[2] = 0x2020000000LL;
    v8[3] = 0LL;
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    _DWORD v7[2] = sub_100562A40;
    v7[3] = &unk_10183FCF0;
    v7[6] = buf;
    v7[7] = v8;
    v7[4] = a2;
    void v7[5] = a3;
    objc_msgSend(a1, "iterateSecondaryData:forField:withHandler:", objc_msgSend(a1, "mappedSecondaryData"), 1, v7);
    _Block_object_dispose(v8, 8);
    _Block_object_dispose(buf, 8);
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(v10) = 2082;
      *(void *)((char *)&v10 + 2) = "";
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLPLocationConsumptionScoreInfo doesn't exist in this platform.}",  buf,  0x12u);
    }
  }

void sub_10054F178( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10054F19C(uint64_t a1, double a2, double a3)
{
  if ((a3 - a2) * 0.5 + a2 >= v6)
  {
    objc_msgSend( *(id *)(a1 + 40),  "addObject:",   -[NSDateInterval initWithStartDate:endDate:]( [NSDateInterval alloc],  "initWithStartDate:endDate:",   -[NSDate initWithTimeIntervalSinceReferenceDate:]( [NSDate alloc],  "initWithTimeIntervalSinceReferenceDate:",  a2),   -[NSDate initWithTimeIntervalSinceReferenceDate:]( [NSDate alloc],  "initWithTimeIntervalSinceReferenceDate:",  a3)));
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      v9[0] = 68289794;
      v9[1] = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = v8;
      __int16 v14 = 1026;
      int v15 = (int)a2;
      __int16 v16 = 1026;
      int v17 = (int)a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LocationUtilityEvent Retrieved interval prior, lookBackWindowStartDate:%{public, l ocation:escape_only}@, startTime:%{public}d, endTime:%{public}d}",  (uint8_t *)v9,  0x28u);
    }
  }

void sub_10054F334(uint64_t a1, uint64_t a2)
{
  id v3 = sub_10053D6E0(a1, a2);
  if (![*(id *)(a1 + 120) locationRestricted])
  {
LABEL_6:
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    goto LABEL_8;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v4 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)id v9 = 2082;
    *(void *)&_DWORD v9[2] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning location services settings are frozen by restrictions - resetting}",  buf,  0x12u);
    goto LABEL_6;
  }

void sub_10054F570( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_10054F5AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = objc_msgSend(*(id *)(a1 + 136), "registeredKeyPathForClientIdentifier:");
  id v7 = [v6 isValidCKP];
  if ((_DWORD)v7)
  {
    [*(id *)(a1 + 136) setInt:a2 forKey:@"IncidentalUseMode" atKeyPath:v6];
    [*(id *)(a1 + 136) persist];
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#IncidentalUseMode able to SET client's incidental use mode:%d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      v13[0] = 67109120;
      v13[1] = a2;
      __int16 v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#IncidentalUseMode able to SET client's incidental use mode:%d",  v13);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::setIncidentalUseMode(CLClientIncidentalUseMode, CLClientKeyPath *)",  "%s\n",  v12);
    }

    sub_1010DDBC0(buf, "");
    sub_100544214(a1, v6, (uint64_t)buf);
    if (SBYTE3(v18) < 0) {
      operator delete(*(void **)buf);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v9 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2114;
      uint64_t v18 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unable to find client to update #IncidentalUseMode, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    __int16 v10 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2114;
      uint64_t v18 = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unable to find client to update #IncidentalUseMode",  "{msg%{public}.0s:Unable to find client to update #IncidentalUseMode, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }
  }

  return v7;
}

void sub_10054F908( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10054F92C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = sub_1005486B8(a1, a3);
  [*(id *)(a1 + 136) setInt:a2 forKey:@"LocationButtonUseMode" atKeyPath:v5];
  [*(id *)(a1 + 136) persist];
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
  {
    v8[0] = 68289538;
    v8[1] = 0;
    __int16 v9 = 2082;
    __int16 v10 = "";
    __int16 v11 = 2114;
    id v12 = v5;
    __int16 v13 = 2050;
    uint64_t v14 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#LocationButtonUseMode updated, Client:%{public, location:escape_only}@, Mode:%{p ublic, location:CLClientLocationButtonUseMode}lld}",  (uint8_t *)v8,  0x26u);
  }

  return 1LL;
}

id sub_10054FA60(uint64_t a1, void *a2, void *a3)
{
  if (sub_1004F7A04())
  {
    uint64_t v5 = sub_10054FD40(a2, a3);
    if (v5)
    {
      unint64_t v6 = v5;
      if (v5 == 2)
      {
        id v7 = objc_alloc(&OBJC_CLASS___STExecutableIdentity);
        uint64_t v8 = @"/System/Library/LocationBundles/Traffic.bundle";
LABEL_7:
        id v11 = [v7 initWithBundlePath:v8];
        return -[STLocationStatusDomainLocationAttribution initWithLocationState:activityAttribution:eligibleDisplayModes:]( [STLocationStatusDomainLocationAttribution alloc],  "initWithLocationState:activityAttribution:eligibleDisplayModes:",  1,   objc_msgSend( [STActivityAttribution alloc],  "initWithAttributedEntity:",   objc_msgSend( [STAttributedEntity alloc],  "initWithExecutableIdentity:website:systemService:",  v11,  objc_msgSend(a2, "website"),  (v6 >> 1) & 1)),  v6);
      }

      __int16 v9 = (const __CFString *)[a2 bundlePath];
      if (v9)
      {
        __int16 v10 = v9;
        id v7 = objc_alloc(&OBJC_CLASS___STExecutableIdentity);
        uint64_t v8 = v10;
        goto LABEL_7;
      }

      id v12 = [a2 executablePath];
      if (v12)
      {
        id v11 = [[STExecutableIdentity alloc] initWithExecutablePath:v12];
        return -[STLocationStatusDomainLocationAttribution initWithLocationState:activityAttribution:eligibleDisplayModes:]( [STLocationStatusDomainLocationAttribution alloc],  "initWithLocationState:activityAttribution:eligibleDisplayModes:",  1,   objc_msgSend( [STActivityAttribution alloc],  "initWithAttributedEntity:",   objc_msgSend( [STAttributedEntity alloc],  "initWithExecutableIdentity:website:systemService:",  v11,  objc_msgSend(a2, "website"),  (v6 >> 1) & 1)),  v6);
      }

      id v13 = [a2 bundleId];
      if (v13)
      {
        id v11 = [[STExecutableIdentity alloc] initWithApplicationBundleIdentifier:v13];
        return -[STLocationStatusDomainLocationAttribution initWithLocationState:activityAttribution:eligibleDisplayModes:]( [STLocationStatusDomainLocationAttribution alloc],  "initWithLocationState:activityAttribution:eligibleDisplayModes:",  1,   objc_msgSend( [STActivityAttribution alloc],  "initWithAttributedEntity:",   objc_msgSend( [STAttributedEntity alloc],  "initWithExecutableIdentity:website:systemService:",  v11,  objc_msgSend(a2, "website"),  (v6 >> 1) & 1)),  v6);
      }

      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v14 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        int v17 = 68289282;
        int v18 = 0;
        __int16 v19 = 2082;
        __int128 v20 = "";
        __int16 v21 = 2114;
        id v22 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#CreateAttribution CLClientKeyPath identity did not return a valid anchor type, Cli ent:%{public, location:escape_only}@}",  (uint8_t *)&v17,  0x1Cu);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      __int16 v15 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        int v17 = 68289282;
        int v18 = 0;
        __int16 v19 = 2082;
        __int128 v20 = "";
        __int16 v21 = 2114;
        id v22 = a2;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#CreateAttribution CLClientKeyPath identity did not return a valid anchor type",  "{msg%{public}.0s:#CreateAttribution CLClientKeyPath identity did not return a valid anchor type, Cli ent:%{public, location:escape_only}@}",  (uint8_t *)&v17,  0x1Cu);
      }
    }
  }

  return 0LL;
}

uint64_t sub_10054FD40(void *a1, void *a2)
{
  int v3 = sub_100AE0758(a2);
  uint64_t v4 = 1LL;
  int v5 = v3;
  uint64_t result = 0LL;
  switch(v5)
  {
    case 0:
      else {
        return 1LL;
      }
    case 3:
    case 5:
      return 2LL;
    case 4:
      return 6LL;
    case 7:
      return 10LL;
    case 8:
      return result;
    case 9:
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v7 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        int v9 = 68289282;
        int v10 = 0;
        __int16 v11 = 2082;
        id v12 = "";
        __int16 v13 = 2114;
        uint64_t v14 = a1;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#SystemStatus failed to determine eligibleModes, Client:%{public, location:escape_only}@}",  (uint8_t *)&v9,  0x1Cu);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      uint64_t v8 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        int v9 = 68289282;
        int v10 = 0;
        __int16 v11 = 2082;
        id v12 = "";
        __int16 v13 = 2114;
        uint64_t v14 = a1;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v8,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#SystemStatus failed to determine eligibleModes",  "{msg%{public}.0s:#SystemStatus failed to determine eligibleModes, Client:%{public, location:escape_only}@}",  (uint8_t *)&v9,  0x1Cu);
      }

      return 0LL;
    default:
      return v4;
  }

void sub_10054FF68(uint64_t a1, uint64_t a2, uint64_t a3, int a4, double a5)
{
  if (!sub_1004F7A04()) {
    return;
  }
  id v10 = sub_10053D6E0(a1, a2);
  id v11 = [v10 clientAnchor];
  if (!v11) {
    goto LABEL_5;
  }
  sub_1010DDBC0(buf, (char *)[v11 UTF8String]);
  id v12 = sub_100121918(qword_101996D48, buf);
  __int16 v13 = v12;
  if ((v43[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (v13) {
      goto LABEL_5;
    }
  }

  else if (v12)
  {
LABEL_5:
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v14 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v40 = 2082;
      __int16 v41 = "";
      __int16 v42 = 2114;
      *(void *)uint64_t v43 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#SystemStatusAttribution attempting attribution for attribution-unavailable client, C lient:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    __int16 v15 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v40 = 2082;
      __int16 v41 = "";
      __int16 v42 = 2114;
      *(void *)uint64_t v43 = v10;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#SystemStatusAttribution attempting attribution for attribution-unavailable client",  "{msg%{public}.0s:#SystemStatusAttribution attempting attribution for attribution-unavailable client, C lient:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    return;
  }

  id v16 = objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v10), "dictionary");
  uint64_t v17 = sub_10054FD40(v10, v16);
  if (!v17) {
    return;
  }
  if (v17 == 2)
  {
    int v18 = (void *)qword_101996DE8;
    if (*(void *)(a1 + 424) == 1LL)
    {
      int v19 = 0;
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int128 v20 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v40 = 2082;
        __int16 v41 = "";
        __int16 v42 = 2114;
        *(void *)uint64_t v43 = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#SystemStatusAttribution attribution to System Service; defaulting to Traffic for recor"
          "d keeping, SystemService:%{public, location:escape_only}@}",
          buf,
          0x1Cu);
      }

      int v19 = 1;
    }
  }

  else
  {
    int v19 = 1;
    int v18 = v10;
  }

  __int16 v21 = (CLAttributionRecord *)[*(id *)(a1 + 416) objectForKey:v18];
  if (v21) {
    goto LABEL_25;
  }
  id v23 = sub_10054FA60(0LL, v18, v16);
  id v24 = [*(id *)(a1 + 40) newTimer];
  if (!v23) {
    return;
  }
  __int16 v21 =  -[CLAttributionRecord initWithAttributionId:andTimer:]( objc_alloc(&OBJC_CLASS___CLAttributionRecord),  "initWithAttributionId:andTimer:",  v23,  v24);
  [*(id *)(a1 + 416) setObject:v21 forKey:v18];
  uint64_t v25 = *(void *)(a1 + 416);
  v37[0] = _NSConcreteStackBlock;
  v37[1] = 3221225472LL;
  v37[2] = sub_100550734;
  v37[3] = &unk_10183FAC0;
  v37[7] = v25;
  uint8_t v37[8] = a1;
  char v38 = v19;
  v37[4] = v18;
  v37[5] = v21;
  v37[6] = v10;
  -[CLTimer setHandler:](-[CLAttributionRecord attributionTimer](v21, "attributionTimer"), "setHandler:", v37);
  if (v19)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v26 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v40 = 2082;
      __int16 v41 = "";
      __int16 v42 = 2114;
      *(void *)uint64_t v43 = v18;
      *(_WORD *)&v43[8] = 2114;
      *(void *)&v43[10] = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#SystemStatusAttribution Created new AttributionRecord for client, Client:%{public, location:escape_only}@, Record:%{public, location:escape_only}@}",  buf,  0x26u);
    }

void sub_100550734(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (*(_BYTE *)(a1 + 72))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v3 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      uint64_t v5 = *(void *)(a1 + 40);
      int v9 = 68289538;
      int v10 = 0;
      __int16 v11 = 2082;
      id v12 = "";
      __int16 v13 = 2114;
      uint64_t v14 = v4;
      __int16 v15 = 2114;
      uint64_t v16 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#SystemStatusAttribution Attribution timer fired, Client:%{public, location:escape_ only}@, Record:%{public, location:escape_only}@}",  (uint8_t *)&v9,  0x26u);
    }
  }

  sub_100550924(v2, *(void **)(a1 + 48), (uint64_t)[*(id *)(a1 + 40) attributionIdentifier], 0);
  if (![*(id *)(a1 + 40) totalAttributionCount])
  {
    objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "attributionTimer"), "invalidate");
    [*(id *)(a1 + 56) removeObjectForKey:*(void *)(a1 + 32)];
    if (*(_BYTE *)(a1 + 72))
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      unint64_t v6 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = *(void *)(a1 + 40);
        int v9 = 68289538;
        int v10 = 0;
        __int16 v11 = 2082;
        id v12 = "";
        __int16 v13 = 2114;
        uint64_t v14 = v7;
        __int16 v15 = 2114;
        uint64_t v16 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#SystemStatusAttribution No subscriptions remaining; removing AttributionRecord for cli"
          "ent, Client:%{public, location:escape_only}@, Record:%{public, location:escape_only}@}",
          (uint8_t *)&v9,
          0x26u);
      }
    }
  }

void sub_100550924(uint64_t a1, void *a2, uint64_t a3, char a4)
{
  if (sub_1004F7A04())
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      int v9 = -[NSUUID UUIDString](+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"), "UUIDString");
      *(_DWORD *)__int128 buf = 68289794;
      int v15 = 0;
      __int16 v16 = 2082;
      uint64_t v17 = "";
      __int16 v18 = 2114;
      int v19 = a2;
      __int16 v20 = 2114;
      uint64_t v21 = a3;
      __int16 v22 = 2082;
      id v23 = -[NSString UTF8String](v9, "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#SystemStatus Publishing receiving location interval end, Client:%{public, location :escape_only}@, AttributionIdentifier:%{public, location:escape_only}@, MessageUUID:%{public, location:escape_only}s}",  buf,  0x30u);
    }

    else
    {
      int v9 = 0LL;
    }

    int v10 = *(void **)(a1 + 400);
    v11[4] = v9;
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    int v12[2] = sub_10055180C;
    v12[3] = &unk_10183FB10;
    _DWORD v12[4] = a3;
    char v13 = a4;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    _OWORD v11[2] = sub_100551B1C;
    v11[3] = &unk_10181A288;
    [v10 updateVolatileData:v12 completion:v11];
  }

void sub_100550AEC(uint64_t a1, void *a2, uint64_t a3)
{
  if (sub_1004F7A04())
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unint64_t v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      uint64_t v7 = -[NSUUID UUIDString](+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"), "UUIDString");
      *(_DWORD *)__int128 buf = 68289794;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 2114;
      __int16 v16 = a2;
      __int16 v17 = 2114;
      uint64_t v18 = a3;
      __int16 v19 = 2082;
      __int16 v20 = -[NSString UTF8String](v7, "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#SystemStatus Publishing receiving location interval begin, Client:%{public, locati on:escape_only}@, AttributionIdentifier:%{public, location:escape_only}@, MessageUUID:%{public, location:escape_only}s}",  buf,  0x30u);
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    uint64_t v8 = *(void **)(a1 + 400);
    v9[4] = v7;
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    v10[2] = sub_100551258;
    v10[3] = &unk_10183FAE8;
    v10[4] = a3;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    _DWORD v9[2] = sub_100551434;
    v9[3] = &unk_10181A288;
    [v8 updateVolatileData:v10 completion:v9];
  }

void sub_100550CAC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!sub_1004F7A04()) {
    return;
  }
  id v6 = sub_10053D6E0(a1, a2);
  id v7 = [v6 clientAnchor];
  if (!v7) {
    goto LABEL_5;
  }
  sub_1010DDBC0(&__p, (char *)[v7 UTF8String]);
  uint64_t v8 = sub_100121918(qword_101996D48, (unsigned __int8 *)&__p);
  int v9 = v8;
  if ((v28[3] & 0x80000000) != 0)
  {
    operator delete(__p);
    if (v9)
    {
LABEL_5:
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v10 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
      {
        std::string __p = (void *)68289282;
        __int16 v25 = 2082;
        __int16 v26 = "";
        __int16 v27 = 2114;
        *(void *)int v28 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#SystemStatusAttribution attempting deattribution for attribution-unavailable client. A borting deattribution, Client:%{public, location:escape_only}@}",  (uint8_t *)&__p,  0x1Cu);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      __int16 v11 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        std::string __p = (void *)68289282;
        __int16 v25 = 2082;
        __int16 v26 = "";
        __int16 v27 = 2114;
        *(void *)int v28 = v6;
        int v12 = "#SystemStatusAttribution attempting deattribution for attribution-unavailable client. Aborting deattribution";
        __int16 v13 = "{msg%{public}.0s:#SystemStatusAttribution attempting deattribution for attribution-unavailable clien"
              "t. Aborting deattribution, Client:%{public, location:escape_only}@}";
LABEL_12:
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v11,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v12,  v13,  (uint8_t *)&__p,  0x1Cu);
        return;
      }

      return;
    }
  }

  else if (v8)
  {
    goto LABEL_5;
  }

  id v14 = objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v6), "dictionary");
  uint64_t v15 = sub_10054FD40(v6, v14);
  if (!v15) {
    return;
  }
  if (v15 != 2) {
    goto LABEL_23;
  }
  id v6 = (id)qword_101996DE8;
  if (*(void *)(a1 + 424) != 1LL)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v17 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      std::string __p = (void *)68289282;
      __int16 v25 = 2082;
      __int16 v26 = "";
      __int16 v27 = 2114;
      *(void *)int v28 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#SystemStatusAttribution deattribution for System Service; defaulting to Traffic for reco"
        "rd keeping, SystemService:%{public, location:escape_only}@}",
        (uint8_t *)&__p,
        0x1Cu);
    }

void sub_100551258(uint64_t a1, void *a2)
{
  if (objc_msgSend(objc_msgSend(a2, "attributions"), "containsObject:", *(void *)(a1 + 32)))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v4 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#SystemStatus adding attribution; already exists!, AttributionIdentifier:%{public, "
        "location:escape_only}@}",
        (uint8_t *)&v8,
        0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    id v6 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      __int16 v12 = 2114;
      uint64_t v13 = v7;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#SystemStatus adding attribution; already exists!",
        "{msg%{public}.0s:#SystemStatus adding attribution; already exists!, AttributionIdentifier:%{public, "
        "location:escape_only}@}",
        (uint8_t *)&v8,
        0x1Cu);
    }
  }

  else
  {
    _[a2 addAttribution:*(void *)(a1 + 32)];
  }

void sub_100551434(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    id v3 = [*(id *)(a1 + 32) UTF8String];
    v4[0] = 68289282;
    v4[1] = 0;
    __int16 v5 = 2082;
    id v6 = "";
    __int16 v7 = 2082;
    id v8 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#SystemStatus Received and processed interval beginning message, MessageUUID:%{public , location:escape_only}s}",  (uint8_t *)v4,  0x1Cu);
  }

void sub_10055151C(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  if (objc_opt_class(&OBJC_CLASS___CLPLocationConsumptionScoreInfo))
  {
    memset(&__p, 0, sizeof(__p));
    if ([a4 isValidCKP])
    {
      id v8 = sub_10053D6E0(a1, (uint64_t)a4);
      if (v8) {
        [v8 cppClientKey];
      }
      else {
        memset(buf, 0, 24);
      }
      std::string __p = *(std::string *)buf;
    }

    else
    {
      std::string::assign( &__p,  (const std::string::value_type *)[@"com.apple.locationd.all-location-clients-stop" UTF8String]);
    }

    *(void *)__int128 buf = &__p;
    __int16 v10 = sub_100150EA4(a3, (unsigned __int8 *)&__p, (uint64_t)&unk_1012CF090, (__int128 **)buf);
    if (*((double *)v10 + 5) == 0.0)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int16 v11 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        p_p = &__p;
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 buf = 68289283;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(void *)&buf[20] = p_p;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Updating location consumption info on start, Client:%{private, location:escape_only}s}",  buf,  0x1Cu);
      }

      *((CFAbsoluteTime *)v10 + 5) = CFAbsoluteTimeGetCurrent();
      id v13 = objc_alloc_init(&OBJC_CLASS___CLPLocationConsumptionScoreInfo);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        id v14 = &__p;
      }
      else {
        id v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      objc_msgSend( v13,  "setClientKey:",  +[NSString stringWithUTF8String:]( NSString,  "stringWithUTF8String:",  v14,  __p.__r_.__value_.__r.__words[0],  __p.__r_.__value_.__l.__size_,  __p.__r_.__value_.__l.__cap_));
      [v13 setStartTime:*((double *)v10 + 5)];
      [a2 writeSecondaryObject:v13 toField:1];
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v9 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLPLocationConsumptionScoreInfo doesn't exist in this platform.}",  buf,  0x12u);
    }
  }

void sub_1005517E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10055180C(uint64_t a1, void *a2, void *a3)
{
  if (objc_msgSend(objc_msgSend(a2, "attributions"), "containsObject:", *(void *)(a1 + 32)))
  {
    [a2 removeAttribution:*(void *)(a1 + 32)];
    [a3 setUserInitiated:*(unsigned __int8 *)(a1 + 40)];
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v14 = 68289282;
      int v15 = 0;
      __int16 v16 = 2082;
      __int16 v17 = "";
      __int16 v18 = 2114;
      uint64_t v19 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#SystemStatus removing attribution that doesn't exist!, AttributionIdentifier:%{pub lic, location:escape_only}@}",  (uint8_t *)&v14,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    id v8 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      int v14 = 68289282;
      int v15 = 0;
      __int16 v16 = 2082;
      __int16 v17 = "";
      __int16 v18 = 2114;
      uint64_t v19 = v9;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v8,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#SystemStatus removing attribution that doesn't exist!",  "{msg%{public}.0s:#SystemStatus removing attribution that doesn't exist!, AttributionIdentifier:%{pub lic, location:escape_only}@}",  (uint8_t *)&v14,  0x1Cu);
    }
  }

  if (objc_msgSend(objc_msgSend(a2, "attributions"), "containsObject:", *(void *)(a1 + 32)))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      int v14 = 68289282;
      int v15 = 0;
      __int16 v16 = 2082;
      __int16 v17 = "";
      __int16 v18 = 2114;
      uint64_t v19 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#SystemStatus removed attribution but it still exists!, AttributionIdentifier:%{pub lic, location:escape_only}@}",  (uint8_t *)&v14,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    __int16 v12 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      uint64_t v13 = *(void *)(a1 + 32);
      int v14 = 68289282;
      int v15 = 0;
      __int16 v16 = 2082;
      __int16 v17 = "";
      __int16 v18 = 2114;
      uint64_t v19 = v13;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#SystemStatus removed attribution but it still exists!",  "{msg%{public}.0s:#SystemStatus removed attribution but it still exists!, AttributionIdentifier:%{pub lic, location:escape_only}@}",  (uint8_t *)&v14,  0x1Cu);
    }
  }

void sub_100551B1C(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    id v3 = [*(id *)(a1 + 32) UTF8String];
    v4[0] = 68289282;
    v4[1] = 0;
    __int16 v5 = 2082;
    id v6 = "";
    __int16 v7 = 2082;
    id v8 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#SystemStatus Received and processed interval end message, MessageUUID:%{public, loca tion:escape_only}s}",  (uint8_t *)v4,  0x1Cu);
  }

void sub_100551C04(uint64_t a1, void *a2, void *a3, void *a4)
{
  if (objc_opt_class(&OBJC_CLASS___CLPLocationConsumptionScoreInfo))
  {
    memset(&__p, 0, sizeof(__p));
    if ([a4 isValidCKP])
    {
      id v8 = sub_10053D6E0(a1, (uint64_t)a4);
      if (v8) {
        [v8 cppClientKey];
      }
      else {
        memset(buf, 0, 24);
      }
      std::string __p = *(std::string *)buf;
    }

    else
    {
      std::string::assign( &__p,  (const std::string::value_type *)[@"com.apple.locationd.all-location-clients-stop" UTF8String]);
    }

    __int16 v10 = sub_100121918(a3, (unsigned __int8 *)&__p);
    uint64_t v11 = v10;
    if (v10 && *((double *)v10 + 5) > 0.0)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int16 v12 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        p_p = &__p;
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 buf = 68289283;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&buf[18] = 2081;
        *(void *)&buf[20] = p_p;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Updating location consumption info on stop, Client:%{private, location:escape_only}s}",  buf,  0x1Cu);
      }

      double Current = CFAbsoluteTimeGetCurrent();
      double v15 = *((double *)v11 + 5);
      if (Current <= v15)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        __int16 v17 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
        {
          uint64_t v18 = *((void *)v11 + 5);
          *(_DWORD *)__int128 buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2050;
          *(void *)&buf[20] = v18;
          __int16 v25 = 2050;
          double v26 = Current;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Detected CFAbsoluteTime rollback when writing usage score, PreviousTimestamp: %{public}f, Timestamp:%{public}f}",  buf,  0x26u);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
        }

        uint64_t v19 = (os_log_s *)qword_101934988;
        if (os_signpost_enabled((os_log_t)qword_101934988))
        {
          uint64_t v20 = *((void *)v11 + 5);
          *(_DWORD *)__int128 buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2050;
          *(void *)&buf[20] = v20;
          __int16 v25 = 2050;
          double v26 = Current;
          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Detected CFAbsoluteTime rollback when writing usage score",  "{msg%{public}.0s:Detected CFAbsoluteTime rollback when writing usage score, PreviousTimestamp: %{public}f, Timestamp:%{public}f}",  buf,  0x26u);
        }

        uint64_t v16 = 0LL;
      }

      else
      {
        uint64_t v16 = (int)(Current - v15);
      }

      *((_DWORD *)v11 + 12) += v16;
      *((void *)v11 + 5) = 0LL;
      id v21 = objc_alloc_init(&OBJC_CLASS___CLPLocationConsumptionScoreInfo);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v22 = &__p;
      }
      else {
        __int16 v22 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      objc_msgSend( v21,  "setClientKey:",  +[NSString stringWithUTF8String:]( NSString,  "stringWithUTF8String:",  v22,  __p.__r_.__value_.__r.__words[0],  __p.__r_.__value_.__l.__size_,  __p.__r_.__value_.__l.__cap_));
      [v21 setStopTime:Current];
      [v21 setScore:v16];
      [a2 writeSecondaryObject:v21 toField:1];
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v9 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLPLocationConsumptionScoreInfo doesn't exist in this platform.}",  buf,  0x12u);
    }
  }

void sub_100552038( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100552064(uint64_t a1, uint64_t a2)
{
  if ([*(id *)(a1 + 120) locationRestricted])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v4 = qword_101934988;
    BOOL result = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO);
    if (result)
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v23 = 0;
      __int16 v24 = 2082;
      __int16 v25 = "";
      __int16 v26 = 2114;
      uint64_t v27 = a2;
      id v6 = "{msg%{public}.0s:#LocationButtonFirstUsage skip prompting. Restrictions enabled, Client:%{public,"
           " location:escape_only}@}";
      __int16 v7 = (os_log_s *)v4;
      os_log_type_t v8 = OS_LOG_TYPE_INFO;
      uint32_t v9 = 28;
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v7, v8, v6, buf, v9);
      return 0LL;
    }

    return result;
  }

  if (!*(void *)(a1 + 272))
  {
    if (objc_msgSend( objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", a2),  "BOOLForKey:defaultValue:",  @"DefaultAccuracyReduced",  0)) {
      int v15 = 13;
    }
    else {
      int v15 = 14;
    }
    sub_1010DDBC0(__p, "");
    sub_1005857F0((uint64_t)v21, v15, a2, 0LL, (__int128 *)__p);
    BOOL v16 = sub_10054878C(a1, a2, 0LL, (uint64_t)v21, 0LL);
    sub_1005858A0((uint64_t)v21);
    if (v20 < 0)
    {
      operator delete(__p[0]);
      if (v16) {
        return 1LL;
      }
    }

    else if (v16)
    {
      return 1LL;
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v17 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v23 = 0;
      __int16 v24 = 2082;
      __int16 v25 = "";
      __int16 v26 = 2114;
      uint64_t v27 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Warning Could not post #LocationButtonFirstUsage, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v18 = (os_log_s *)qword_101934988;
    BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
    if (result)
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v23 = 0;
      __int16 v24 = 2082;
      __int16 v25 = "";
      __int16 v26 = 2114;
      uint64_t v27 = a2;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Warning Could not post #LocationButtonFirstUsage",  "{msg%{public}.0s:#Warning Could not post #LocationButtonFirstUsage, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      return 0LL;
    }

    return result;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v10 = qword_101934988;
  BOOL v11 = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT);
  BOOL result = 0LL;
  if (v11)
  {
    __int16 v12 = *(unsigned int **)(a1 + 272);
    uint64_t v13 = *((void *)v12 + 1);
    uint64_t v14 = *v12;
    *(_DWORD *)__int128 buf = 68289794;
    int v23 = 0;
    __int16 v24 = 2082;
    __int16 v25 = "";
    __int16 v26 = 2114;
    uint64_t v27 = a2;
    __int16 v28 = 2114;
    uint64_t v29 = v13;
    __int16 v30 = 2050;
    uint64_t v31 = v14;
    id v6 = "{msg%{public}.0s:#LocationButtonFirstUsage skip prompting. InflightPromptAuthorizationRequest found., "
         "Client:%{public, location:escape_only}@, inflightClient:%{public, location:escape_only}@, inflightReque"
         "stType:%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}";
    __int16 v7 = (os_log_s *)v10;
    os_log_type_t v8 = OS_LOG_TYPE_DEFAULT;
    uint32_t v9 = 48;
    goto LABEL_11;
  }

  return result;
}

void sub_1005523F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

id sub_100552424(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 136) readonlyStoreAtKeyPath:a2];
}

void sub_100552430(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6)
{
  id v10 = sub_1005486B8(a1, a2);
  unsigned int v11 = [*(id *)(a1 + 136) intForKey:@"LocationButtonUseMode" atKeyPath:v10 defaultValue:0];
  unsigned int v12 = -[CLClientManagerAuthorizationContext transientAwareRegistrationResult]( sub_100544790(a1, (uint64_t)v10, &xmmword_101339630),  "transientAwareRegistrationResult");
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v13 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    std::string __p = (void *)68290562;
    __int16 v22 = 2082;
    int v23 = "";
    __int16 v24 = 2114;
    id v25 = v10;
    __int16 v26 = 1026;
    int v27 = a4;
    __int16 v28 = 1026;
    int v29 = a5;
    __int16 v30 = 1026;
    int v31 = a6;
    __int16 v32 = 2050;
    uint64_t v33 = v11;
    __int16 v34 = 1026;
    unsigned int v35 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#TemporaryAuth Explicit temporary authorization request received, Client:%{public, lo cation:escape_only}@, Granted:%{public}hhd, UsingLocationButton:%{public}hhd, VoiceInteractionEnabled: %{public}hhd, LocationButtonUseMode:%{public, location:CLClientLocationButtonUseMode}lld, TransientAwareRegi strationResult:%{public}d}",  (uint8_t *)&__p,  0x3Eu);
  }

  if (a5 && (a4 & 1) == 0)
  {
    sub_10123D524();
    __break(1u);
    goto LABEL_29;
  }

  if (!a5) {
    goto LABEL_16;
  }
  if (v12 != 4 && v12 != 2 || (a6 & 1) == 0 && v11)
  {
    if (v11 == 1)
    {
      if (qword_101934980 == -1)
      {
LABEL_14:
        uint64_t v14 = qword_101934988;
        if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        std::string __p = (void *)68289282;
        __int16 v22 = 2082;
        int v23 = "";
        __int16 v24 = 2114;
        id v25 = v10;
        int v15 = "{msg%{public}.0s:#TemporaryAuth could not be granted , #LocationButtonUse denied, Client:%{pub"
              "lic, location:escape_only}@}";
        BOOL v16 = (os_log_s *)v14;
        uint32_t v17 = 28;
        goto LABEL_26;
      }

void sub_1005527B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_1005527D4(void *a1, uint64_t a2, int a3, int a4)
{
  if (![a1 registeredKeyPathForClientIdentifier:a2]) {
    [a1 registerClient:a2 fromAuthSync:0];
  }
  unsigned int v8 = [a1 intForKey:@"TemporaryAuthorization" atKeyPath:a2 defaultValue:0];
  if (a4)
  {
    uint64_t v9 = v8 | a3;
    return [a1 setInt:v9 forKey:@"TemporaryAuthorization" atKeyPath:a2];
  }

  uint64_t v9 = v8 & ~a3;
  if ((v8 & ~a3) != 0) {
    return [a1 setInt:v9 forKey:@"TemporaryAuthorization" atKeyPath:a2];
  }
  return [a1 removeValueForKey:@"TemporaryAuthorization" atKeyPath:a2];
}

void sub_100552888(uint64_t a1, void *a2, int a3)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    std::string __p = (void *)68289538;
    __int16 v11 = 2082;
    unsigned int v12 = "";
    __int16 v13 = 2114;
    uint64_t v14 = a2;
    __int16 v15 = 1026;
    int v16 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#TemporaryAuth-Precise, Client:%{public, location:escape_only}@, granted:%{public}hhd}",  (uint8_t *)&__p,  0x22u);
  }

  __int16 v7 = (void **)(a1 + 136);
  if (a3) {
    int v8 = 2;
  }
  else {
    int v8 = 8;
  }
  if (a3) {
    int v9 = 8;
  }
  else {
    int v9 = 2;
  }
  sub_1005527D4(*(void **)(a1 + 136), (uint64_t)a2, v8, 1);
  sub_1005527D4(*v7, (uint64_t)a2, v9, 0);
  [*v7 persist];
  sub_1010DDBC0(&__p, "");
  sub_100544214(a1, a2, (uint64_t)&__p);
  if (SBYTE3(v14) < 0) {
    operator delete(__p);
  }
}

void sub_1005529FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100552A20(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  if (a4)
  {
    id v7 = sub_1005486B8(a1, a4);
    id v8 = v7;
    if (v7) {
      [v7 cppClientKey];
    }
    else {
      memset(buf, 0, 24);
    }
    std::string v88 = *(std::string *)buf;
  }

  else
  {
    std::string::assign(&v88, "*nobody*");
    id v8 = 0LL;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  int v9 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    id v10 = "-";
    uint64_t v11 = *(void *)(a1 + 632);
    if (a2) {
      id v10 = "+";
    }
    *(_DWORD *)__int128 buf = 67109378;
    *(_DWORD *)&uint8_t buf[4] = v11;
    *(_WORD *)&uint8_t buf[8] = 2080;
    *(void *)&buf[10] = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "#CLEEA Emergency clients %d %s 1", buf, 0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v76 = "-";
    uint64_t v77 = *(void *)(a1 + 632);
    if (a2) {
      int v76 = "+";
    }
    int v89 = 67109378;
    LODWORD(v90[0]) = v77;
    WORD2(v90[0]) = 2080;
    *(void *)((char *)v90 + 6) = v76;
    LODWORD(v85) = 18;
    int v78 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#CLEEA Emergency clients %d %s 1",  &v89,  v85);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::markClientEmergencyEnablementTransition(BOOL, BOOL, CLClientKeyPath *)",  "%s\n",  v78);
    if (v78 != buf) {
      free(v78);
    }
  }

  if (a2)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unsigned int v12 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v13 = &v88;
      if ((v88.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int16 v13 = (std::string *)v88.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "#CLEEA adding emergency client,%{public}s",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int16 v79 = &v88;
      if ((v88.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int16 v79 = (std::string *)v88.__r_.__value_.__r.__words[0];
      }
      int v89 = 136446210;
      v90[0] = v79;
      LODWORD(v85) = 12;
      int v80 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#CLEEA adding emergency client,%{public}s",  &v89,  v85);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::markClientEmergencyEnablementTransition(BOOL, BOOL, CLClientKeyPath *)",  "%s\n",  v80);
      if (v80 != buf) {
        free(v80);
      }
    }

    uint64_t v14 = *(void *)(a1 + 632);
    BOOL v86 = v14 == 0;
    unsigned int v87 = a2;
    if (v14)
    {
      __int16 v15 = v8;
      int v16 = *(void **)(a1 + 616);
      if (v16 != (void *)(a1 + 624))
      {
        do
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          uint32_t v17 = v16 + 4;
          uint64_t v18 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
          {
            BOOL v19 = v16 + 4;
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = v19;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "#CLEEA %{public}s is still an emergency client",  buf,  0xCu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
            int v89 = 136446210;
            v90[0] = v17;
            LODWORD(v85) = 12;
            int v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#CLEEA %{public}s is still an emergency client",  &v89,  v85);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::markClientEmergencyEnablementTransition(BOOL, BOOL, CLClientKeyPath *)",  "%s\n",  v23);
            if (v23 != buf) {
              free(v23);
            }
          }

          uint64_t v20 = (void *)v16[1];
          if (v20)
          {
            do
            {
              id v21 = v20;
              uint64_t v20 = (void *)*v20;
            }

            while (v20);
          }

          else
          {
            do
            {
              id v21 = (void *)v16[2];
              BOOL v22 = *v21 == (void)v16;
              int v16 = v21;
            }

            while (!v22);
          }

          int v16 = v21;
        }

        while (v21 != (void *)(a1 + 624));
      }
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      char v38 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "#CLEEA First emergency client connected",  buf,  2u);
      }

      __int16 v15 = v8;
      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        LOWORD(v89) = 0;
        LODWORD(v85) = 2;
        __int16 v83 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#CLEEA First emergency client connected",  &v89,  v85);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::markClientEmergencyEnablementTransition(BOOL, BOOL, CLClientKeyPath *)",  "%s\n",  v83);
        if (v83 != buf) {
          free(v83);
        }
      }
    }

    sub_1005182C0((uint64_t **)(a1 + 616), (uint64_t)&v88);
    double v39 = v15;
    uint64_t v40 = v87;
    if (!a3) {
      goto LABEL_155;
    }
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v41 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v42 = &v88;
      if ((v88.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int16 v42 = (std::string *)v88.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v42;
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#CLEPTO adding beneficiary for deauthorization override , Client:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    sub_1005182C0((uint64_t **)(a1 + 640), (uint64_t)&v88);
    __int16 v30 = v39;
    uint64_t v43 = *(void **)(a1 + 640);
    if (v43 != (void *)(a1 + 648))
    {
      do
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v44 = v43 + 4;
        int v45 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v46 = v43 + 4;
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = v46;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "#CLEPTO (+) : %{public}s is still a beneficiary for deauthorization override",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          int v89 = 136446210;
          v90[0] = v44;
          LODWORD(v85) = 12;
          __int16 v49 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#CLEPTO (+) : %{public}s is still a beneficiary for deauthorization override",  &v89,  v85);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::markClientEmergencyEnablementTransition(BOOL, BOOL, CLClientKeyPath *)",  "%s\n",  v49);
          if (v49 != buf) {
            free(v49);
          }
        }

        __int16 v47 = (void *)v43[1];
        if (v47)
        {
          do
          {
            int v48 = v47;
            __int16 v47 = (void *)*v47;
          }

          while (v47);
        }

        else
        {
          do
          {
            int v48 = (void *)v43[2];
            BOOL v22 = *v48 == (void)v43;
            uint64_t v43 = v48;
          }

          while (!v22);
        }

        uint64_t v43 = v48;
      }

      while (v48 != (void *)(a1 + 648));
    }

void sub_100553DE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100553E64(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = a1 + 1048;
  sub_1010DDBC0(__p, (char *)objc_msgSend(objc_msgSend(a2, "clientAnchor"), "UTF8String"));
  id v6 = (_DWORD *)sub_10008E8D0(v5, (const void **)__p);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  if ((_DWORD *)(a1 + 1056) == v6)
  {
    BOOL v10 = 0LL;
    BOOL v11 = 0LL;
    BOOL v9 = 0LL;
    BOOL v8 = 0LL;
  }

  else
  {
    int v7 = v6[17];
    BOOL v8 = v6[14] != 0;
    BOOL v9 = v6[15] != 0;
    BOOL v10 = v6[16] != 0;
    BOOL v11 = v7 != 0;
  }

  objc_msgSend( a3,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v8),  @"PassiveServiceSession");
  objc_msgSend( a3,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v9),  @"WhenInUseServiceSession");
  objc_msgSend( a3,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v10),  @"AlwaysServiceSession");
  return objc_msgSend( a3,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v11),  @"SessionWithOldLinking");
}

void sub_100553FA0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100553FBC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  id v5 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  else {
    id v6 = 0LL;
  }

  return v6;
}

void sub_100554038(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100554050(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = sub_10053D6E0(a1, a2);
  if ([a4 isAuthorizedForServiceTypeMask:a3]
    && ![a4 registrationResult])
  {
    id v8 = objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v7), "dictionary");
    int v9 = sub_100AE0BD4(v8);
    LODWORD(v_Block_object_dispose(va, 8) = sub_100AE0C24(v8);
  }

void sub_10055411C(uint64_t a1, uint64_t a2)
{
  if ((sub_1004F76B8() & 1) == 0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v4 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v19 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Considering whether to mark client, %@, for always power use",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v14 = 138412290;
      uint64_t v15 = a2;
      int v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "Considering whether to mark client, %@, for always power use",  &v14,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::markAlwaysAuthorizationUsedForClient(CLClientKeyPath *)",  "%s\n",  v9);
    }

    unsigned int v5 = sub_100546B6C(a1, a2);
    if (v5)
    {
      unsigned int v6 = v5;
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v7 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        id v8 = sub_100297524(v6);
        *(_DWORD *)__int128 buf = 138412546;
        uint64_t v19 = a2;
        __int16 v20 = 2080;
        id v21 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "Not marking client %@ as having used Always-powers (not Always authorized (%s))",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v10 = qword_101934988;
        BOOL v11 = sub_100297524(v6);
        int v14 = 138412546;
        uint64_t v15 = a2;
        __int16 v16 = 2080;
        uint32_t v17 = v11;
        LODWORD(v13) = 22;
        unsigned int v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  2LL,  "Not marking client %@ as having used Always-powers (not Always authorized (%s))",  &v14,  v13);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::markAlwaysAuthorizationUsedForClient(CLClientKeyPath *)",  "%s\n",  v12);
      }
    }
  }

void sub_100554458(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  if (sub_100554584(v4, *(void **)(a1 + 32), a2))
  {
    unsigned int v5 = (void *)(v4 + 912);
    if (a2)
    {
      [a2 cppClientKey];
    }

    else
    {
      std::string __p = 0LL;
      __int16 v16 = 0LL;
      uint64_t v17 = 0LL;
    }

    unsigned int v6 = sub_100121918(v5, (unsigned __int8 *)&__p);
    id v7 = v6;
    if (SHIBYTE(v17) < 0)
    {
      operator delete(__p);
      if (!v7) {
        return;
      }
    }

    else if (!v6)
    {
      return;
    }

    for (uint64_t i = (void *)*((void *)v7 + 7); i; uint64_t i = (void *)*i)
    {
      int v9 = (std::__shared_weak_count *)i[4];
      if (v9)
      {
        uint64_t v10 = std::__shared_weak_count::lock(v9);
        __int16 v16 = v10;
        if (v10)
        {
          BOOL v11 = v10;
          unsigned int v12 = (void *)i[3];
          std::string __p = v12;
          if (v12) {
            sub_1004C6A4C((id *)v12, *(void **)(a1 + 40));
          }
          p_shared_owners = (unint64_t *)&v11->__shared_owners_;
          do
            unint64_t v14 = __ldaxr(p_shared_owners);
          while (__stlxr(v14 - 1, p_shared_owners));
          if (!v14)
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
        }
      }
    }
  }

void sub_100554558( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100554584(uint64_t a1, void *a2, void *a3)
{
  BOOL result = 0LL;
  if (a2)
  {
    if (a3)
    {
      BOOL result = +[CLAuthorizationDatabase keyPath:sharesAuthWithKeyPath:]( &OBJC_CLASS___CLAuthorizationDatabase,  "keyPath:sharesAuthWithKeyPath:",  a2,  a3);
      if (result)
      {
        [a2 cppClientKey];
        uint64_t v7 = sub_10008E8D0(a1 + 616, (const void **)&__p);
        if (SBYTE3(v16) < 0) {
          operator delete(__p);
        }
        [a3 cppClientKey];
        uint64_t v8 = sub_10008E8D0(a1 + 616, (const void **)&__p);
        uint64_t v9 = a1 + 624;
        if (SBYTE3(v16) < 0) {
          operator delete(__p);
        }
        if (v9 == v7 && v9 == v8)
        {
          return 1LL;
        }

        else
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          uint64_t v10 = (os_log_s *)qword_101934988;
          BOOL v11 = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT);
          BOOL result = 0LL;
          if (v11)
          {
            std::string __p = (void *)68290050;
            __int16 v13 = 2082;
            unint64_t v14 = "";
            __int16 v15 = 2114;
            __int16 v16 = a2;
            __int16 v17 = 1026;
            BOOL v18 = v9 != v7;
            __int16 v19 = 2114;
            __int16 v20 = a3;
            __int16 v21 = 1026;
            BOOL v22 = v9 != v8;
            _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning Auth sharing overridden, ckpA:%{public, location:escape_only}@, ck pAIsBeneficiary:%{public}hhd, ckpB:%{public, location:escape_only}@, ckpBIsBeneficiary:%{public}hhd}",  (uint8_t *)&__p,  0x32u);
            return 0LL;
          }
        }
      }
    }
  }

  return result;
}

void sub_100554764( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10055478C(uint64_t a1, uint64_t a2)
{
  id v3 = sub_10053D6E0(a1, a2);
  id v4 = objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v3), "dictionary");
  if (v3)
  {
    [v3 cppClientKey];
  }

  else
  {
    std::string __p = 0LL;
    *(void *)__int16 v17 = 0LL;
    *(void *)&v17[8] = 0LL;
  }

  unsigned int v5 = sub_100121918((void *)(a1 + 1264), (unsigned __int8 *)&__p);
  unsigned int v6 = v5;
  if ((v17[15] & 0x80000000) == 0)
  {
    if (v5) {
      goto LABEL_6;
    }
LABEL_9:
    uint64_t v9 = sub_100AE0AB0(v4);
    unint64_t v7 = 0LL;
    goto LABEL_15;
  }

  operator delete(__p);
  if (!v6) {
    goto LABEL_9;
  }
LABEL_6:
  unint64_t v7 = *((void *)v6 + 5);
  uint64_t v8 = *((unsigned int *)v6 + 12);
  uint64_t v9 = sub_100AE0AB0(v4);
  if ((_DWORD)v9 == (_DWORD)v8)
  {
    uint64_t v9 = v8;
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      std::string __p = (void *)68290050;
      *(_WORD *)__int16 v17 = 2082;
      *(void *)&_DWORD v17[2] = "";
      *(_WORD *)&v17[10] = 2114;
      *(void *)&v17[12] = v3;
      __int16 v18 = 2050;
      uint64_t v19 = v8;
      __int16 v20 = 2050;
      unint64_t v21 = v9;
      __int16 v22 = 2050;
      unint64_t v23 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#sbim moving arrow retain count between entity classes, Client:%{public, location:e scape_only}@, oldEntityClass:%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld, newEntityCla ss:%{public, location:CLLocationDictionaryUtilitiesEntityClass}lld, arrowState:%{public, location:CLLocati onDictionaryUtilitiesArrowState}lld}",  (uint8_t *)&__p,  0x3Au);
    }

    sub_1005592F0(a1, v9, v7, 1, 0);
    sub_1005592F0(a1, v8, v7, 0, 0);
  }

void sub_100554B34( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100554B60(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (sub_100554584(v3, *(void **)(a1 + 32), a2))
  {
    memset(v14, 0, 35);
    *(_OWORD *)__int16 v13 = 0u;
    *(_OWORD *)std::string __p = 0u;
    memset(v12, 0, sizeof(v12));
    __int128 v15 = 0u;
    memset(v16, 0, 59);
    if (a2)
    {
      [a2 clientName];
      if (SHIBYTE(v12[0]) < 0) {
        operator delete(__p[0]);
      }
    }

    else
    {
      uint64_t v10 = 0LL;
      memset(v9, 0, sizeof(v9));
      *(_OWORD *)uint64_t v8 = 0uLL;
      *(_OWORD *)unsigned int v6 = 0uLL;
      memset(v7, 0, sizeof(v7));
      memset(v5, 0, sizeof(v5));
      *(_OWORD *)id v4 = 0uLL;
    }

    *(_OWORD *)std::string __p = *(_OWORD *)v4;
    v12[0] = v5[0];
    HIBYTE(v5[0]) = 0;
    LOBYTE(v4[0]) = 0;
    if (SHIBYTE(v12[3]) < 0) {
      operator delete(v12[1]);
    }
    *(_OWORD *)&v12[1] = *(_OWORD *)&v5[1];
    v12[3] = v5[3];
    HIBYTE(v5[3]) = 0;
    LOBYTE(v5[1]) = 0;
    if (SHIBYTE(v14[0]) < 0) {
      operator delete(v13[0]);
    }
    *(_OWORD *)__int16 v13 = *(_OWORD *)v6;
    v14[0] = v7[0];
    HIBYTE(v7[0]) = 0;
    LOBYTE(v6[0]) = 0;
    if (SHIBYTE(v14[3]) < 0) {
      operator delete(v14[1]);
    }
    *(_OWORD *)&v14[1] = *(_OWORD *)&v7[1];
    v14[3] = v7[3];
    HIBYTE(v7[3]) = 0;
    LOBYTE(v7[1]) = 0;
    LOWORD(v14[4]) = v7[4];
    BYTE2(v14[4]) = BYTE2(v7[4]);
    if (SBYTE7(v16[0]) < 0) {
      operator delete((void *)v15);
    }
    __int128 v15 = *(_OWORD *)&v7[5];
    *(void **)&v16[0] = v7[7];
    HIBYTE(v7[7]) = 0;
    LOBYTE(v7[5]) = 0;
    if (SHIBYTE(v16[1]) < 0) {
      operator delete(*((void **)&v16[0] + 1));
    }
    *(_OWORD *)((char *)v16 + _Block_object_dispose(va, 8) = *(_OWORD *)v8;
    *((void *)&v16[1] + 1) = *(void *)&v9[0];
    BYTE7(v9[0]) = 0;
    LOBYTE(v8[0]) = 0;
    if (SBYTE7(v16[3]) < 0)
    {
      operator delete(*(void **)&v16[2]);
      v16[2] = *(_OWORD *)((char *)v9 + 8);
      *(void *)&float v16[3] = *((void *)&v9[1] + 1);
      HIBYTE(v9[1]) = 0;
      BYTE8(v9[0]) = 0;
      WORD4(v16[3]) = v10;
      BYTE10(v16[3]) = BYTE2(v10);
      if (SBYTE7(v9[0]) < 0) {
        operator delete(v8[0]);
      }
    }

    else
    {
      v16[2] = *(_OWORD *)((char *)v9 + 8);
      *(void *)&float v16[3] = *((void *)&v9[1] + 1);
      HIBYTE(v9[1]) = 0;
      BYTE8(v9[0]) = 0;
      WORD4(v16[3]) = v10;
      BYTE10(v16[3]) = BYTE2(v10);
    }

    if (SHIBYTE(v7[7]) < 0) {
      operator delete(v7[5]);
    }
    if (SHIBYTE(v7[3]) < 0) {
      operator delete(v7[1]);
    }
    if (SHIBYTE(v7[0]) < 0) {
      operator delete(v6[0]);
    }
    if (SHIBYTE(v5[3]) < 0) {
      operator delete(v5[1]);
    }
    if (SHIBYTE(v5[0]) < 0) {
      operator delete(v4[0]);
    }
    LODWORD(v4[0]) = 2;
    (*(void (**)(uint64_t, void **, void **, void, uint64_t, void))(*(void *)v3 + 152LL))( v3,  v4,  __p,  0LL,  0xFFFFFFFFLL,  0LL);
    if (SBYTE7(v16[3]) < 0) {
      operator delete(*(void **)&v16[2]);
    }
    if (SHIBYTE(v16[1]) < 0) {
      operator delete(*((void **)&v16[0] + 1));
    }
    if (SBYTE7(v16[0]) < 0) {
      operator delete((void *)v15);
    }
    if (SHIBYTE(v14[3]) < 0) {
      operator delete(v14[1]);
    }
    if (SHIBYTE(v14[0]) < 0) {
      operator delete(v13[0]);
    }
    if (SHIBYTE(v12[3]) < 0) {
      operator delete(v12[1]);
    }
    if (SHIBYTE(v12[0]) < 0) {
      operator delete(__p[0]);
    }
  }

void sub_100554EB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
}

void sub_100554ECC(uint64_t a1)
{
  if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    size_t size = v39.__r_.__value_.__s.__size_;
  }
  else {
    size_t size = v39.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    sub_10123D698( v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v25,  v26,  v27,  v28,  v29,  (uint64_t)v30,  v31,  *((uint64_t *)&v31 + 1),  v32,  *((uint64_t *)&v32 + 1),  v33,  *((uint64_t *)&v33 + 1),  v34,  *((uint64_t *)&v34 + 1),  v35,  v36[0]);
    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/CLClientManager_Unified.mm",  3165,  "migrateLegacySLCSubscriptions");
    __break(1u);
  }

  sub_1000392EC((uint64_t)__p, size + 17);
  if (v38 >= 0) {
    unint64_t v11 = __p;
  }
  else {
    unint64_t v11 = (void **)__p[0];
  }
  if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    BOOL v12 = &v39;
  }
  else {
    BOOL v12 = (std::string *)v39.__r_.__value_.__r.__words[0];
  }
  memmove(v11, v12, size);
  strcpy((char *)v11 + size, "significant.plist");
  if (v38 >= 0) {
    __int16 v13 = __p;
  }
  else {
    __int16 v13 = (void **)__p[0];
  }
  if (sub_100292D28((const char *)v13))
  {
    sub_1002A5370(v36);
    if (v38 >= 0) {
      unint64_t v14 = __p;
    }
    else {
      unint64_t v14 = (void **)__p[0];
    }
    sub_1002A59D4((uint64_t)v36, (uint64_t)v14);
    __int128 v15 = (void *)sub_1002A59CC((uint64_t)v36);
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    id v16 = [v15 countByEnumeratingWithState:&v31 objects:v40 count:16];
    if (v16)
    {
      uint64_t v17 = *(void *)v32;
      do
      {
        for (uint64_t i = 0LL; i != v16; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v32 != v17) {
            objc_enumerationMutation(v15);
          }
          uint64_t v19 = *(void *)(*((void *)&v31 + 1) + 8LL * (void)i);
          id v20 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  v19));
          if ([v20 isValidCKP])
          {
            sub_1005551F8((uint64_t *)a1, (uint64_t)v20, &v29);
            sub_100C72B50(v29, [v15 objectForKeyedSubscript:v19]);
            unint64_t v21 = v30;
            if (v30)
            {
              p_shared_owners = (unint64_t *)&v30->__shared_owners_;
              do
                unint64_t v23 = __ldaxr(p_shared_owners);
              while (__stlxr(v23 - 1, p_shared_owners));
              if (!v23)
              {
                ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
                std::__shared_weak_count::__release_weak(v21);
              }
            }
          }
        }

        id v16 = [v15 countByEnumeratingWithState:&v31 objects:v40 count:16];
      }

      while (v16);
    }

    if (v38 >= 0) {
      __int16 v24 = __p;
    }
    else {
      __int16 v24 = (void **)__p[0];
    }
    sub_100292D50((const char *)v24);
    sub_1002A5590(v36);
  }

  if (v38 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10055517C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, void *__p, uint64_t a27, int a28, __int16 a29, char a30, char a31, void *a32, uint64_t a33, int a34, __int16 a35, char a36, char a37)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a37 < 0) {
    operator delete(a32);
  }
  _Unwind_Resume(a1);
}

void sub_1005551F8(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  id v5 = sub_10053D6E0((uint64_t)a1, a2);
  id v61 = v5;
  *a3 = 0LL;
  a3[1] = 0LL;
  if (v5)
  {
    [v5 cppClientKey];
  }

  else
  {
    *(void *)__int128 buf = 0LL;
    *(void *)__int16 v63 = 0LL;
    *(void *)&v63[8] = 0LL;
  }

  int v58 = buf;
  uint64_t v6 = sub_100586680((uint64_t)(a1 + 114), buf, (uint64_t)&unk_1012CF090, (__int128 **)&v58) + 40;
  if ((v63[15] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  *(void *)__int128 buf = &v60;
  uint64_t v7 = sub_100586A28((uint64_t)v6, (uint64_t *)&v60, (uint64_t)&unk_1012CF090, (uint64_t **)buf);
  int v58 = 0LL;
  __int16 v59 = 0LL;
  uint64_t v8 = (std::__shared_weak_count *)v7[4];
  if (v8
    && (uint64_t v9 = std::__shared_weak_count::lock(v8), (v59 = v9) != 0LL)
    && (v10 = v9, unint64_t v11 = (void *)v7[3], (v58 = (uint8_t *)v11) != 0LL))
  {
    if (v12)
    {
      *(void *)__int128 buf = v12;
      *(void *)__int16 v63 = v10;
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        unint64_t v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }

    else
    {
      *(void *)__int128 buf = 0LL;
      *(void *)__int16 v63 = 0LL;
    }

    uint64_t v32 = sub_10005F550((uint64_t)a3, (__int128 *)buf);
    uint64_t v40 = *(std::__shared_weak_count **)v63;
    if (*(void *)v63)
    {
      __int16 v41 = (unint64_t *)(*(void *)v63 + 8LL);
      do
        unint64_t v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }

    if (!*a3)
    {
      sub_10123D7E0( v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v46,  v47,  v48,  v49,  v50,  (uint64_t)v51,  v52,  *((uint64_t *)&v52 + 1),  __p,  *((uint64_t *)&__p + 1),  v54,  v55,  *((uint64_t *)&v55 + 1),  v56,  (uint64_t)v57,  (uint64_t)v58);
      abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/CLClientManager.h",  362,  "getOrCreatePersistentSubscriptionForClient");
      __break(1u);
    }
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101840220);
    }
    __int128 v15 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_INFO))
    {
      *(void *)__int128 buf = 68289538LL;
      *(_WORD *)__int16 v63 = 2082;
      *(void *)&v63[2] = "";
      *(_WORD *)&v63[10] = 2082;
      *(void *)&v63[12] = (unint64_t)"17CLSLCSubscription" & 0x7FFFFFFFFFFFFFFFLL;
      *(_WORD *)&v63[20] = 2114;
      *(void *)&v63[22] = v61;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Creating persistent subscription due to demand, type:%{public, location:escape_only }s, clientKeyPath:%{public, location:escape_only}@}",  buf,  0x26u);
    }

    __int16 v57 = sub_10054B60C((uint64_t)a1, (uint64_t)v61, &xmmword_101339630);
    if (v61)
    {
      [v61 cppClientKey];
    }

    else
    {
      __int128 v55 = 0uLL;
      uint64_t v56 = 0LL;
    }

    sub_100C72880(&__p);
    sub_100586CF0((char *)buf, &v55, &__p, (uint64_t)v60);
    if (SHIBYTE(v54) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v56) < 0) {
      operator delete((void *)v55);
    }
    sub_10058900C(a1 + 4, (uint64_t *)&v57, (uint64_t *)&v61, (uint64_t)buf, &v52);
    sub_10005F550((uint64_t)a3, &v52);
    id v16 = (std::__shared_weak_count *)*((void *)&v52 + 1);
    if (*((void *)&v52 + 1))
    {
      uint64_t v17 = (unint64_t *)(*((void *)&v52 + 1) + 8LL);
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }

    *(void *)&__int128 v52 = &v60;
    uint64_t v19 = sub_100586A28((uint64_t)v6, (uint64_t *)&v60, (uint64_t)&unk_1012CF090, (uint64_t **)&v52);
    unint64_t v21 = (void *)*a3;
    uint64_t v20 = a3[1];
    if (v20)
    {
      __int16 v22 = (unint64_t *)(v20 + 16);
      do
        unint64_t v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }

    __int16 v24 = (std::__shared_weak_count *)v19[4];
    float v19[3] = v21;
    v19[4] = v20;
    if (v24) {
      std::__shared_weak_count::__release_weak(v24);
    }
    uint8_t v25 = (void *)*a3;
    uint64_t v26 = a1[120];
    uint64_t v50 = a1[119];
    __int16 v51 = (std::__shared_weak_count *)v26;
    if (v26)
    {
      uint64_t v27 = (unint64_t *)(v26 + 8);
      do
        unint64_t v28 = __ldxr(v27);
      while (__stxr(v28 + 1, v27));
    }

    sub_1004C6738(v25, &v50);
    uint64_t v29 = v51;
    if (v51)
    {
      __int16 v30 = (unint64_t *)&v51->__shared_owners_;
      do
        unint64_t v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }

    if (v64 < 0) {
      operator delete(*(void **)&v63[16]);
    }
    if ((v63[15] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

  uint64_t v43 = v59;
  if (v59)
  {
    uint64_t v44 = (unint64_t *)&v59->__shared_owners_;
    do
      unint64_t v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }

void sub_100555668( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, char a30)
{
}

uint64_t sub_10055570C(uint64_t a1)
{
  uint64_t result = sub_1001B9A1C();
  if ((result & 1) == 0)
  {
    id v3 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
    uint64_t v4 = *(void **)(a1 + 136);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    _DWORD v7[2] = sub_1005557E0;
    v7[3] = &unk_10183FB88;
    v7[4] = v3;
    [v4 iterateAllAnchorKeyPathsWithBlock:v7];
    id v5 = objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "proxyForService:forClient:",  @"CLAppMonitor",  @"CLClientManager");
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472LL;
    _DWORD v6[2] = sub_10055582C;
    v6[3] = &unk_10183FBA8;
    v6[4] = a1;
    return (uint64_t)[v5 checkApplications:v3 withReply:v6];
  }

  return result;
}

id sub_1005557E0(uint64_t a1, void *a2)
{
  id result = [a2 bundleId];
  if (result) {
    return objc_msgSend(*(id *)(a1 + 32), "addObject:", objc_msgSend(a2, "legacyClientKey"));
  }
  return result;
}

_BYTE *sub_10055582C(uint64_t a1, void *a2, void *a3, void *a4)
{
  return sub_100555834(*(double **)(a1 + 32), a2, a3, a4);
}

_BYTE *sub_100555834(double *a1, void *a2, void *a3, void *a4)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v5 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [a2 count];
    uint64_t v7 = (char *)[a2 count];
    uint64_t v8 = &v7[(void)[a3 count]];
    *(_DWORD *)__int128 buf = 134218240;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = (char *)[a4 count] + (void)v8;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#ClearClient installation check found %ld uninstalled apps (amongst %ld bundle IDs)",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v52 = qword_101934988;
    id v53 = [a2 count];
    uint64_t v54 = (char *)[a2 count];
    id v55 = [a3 count];
    LODWORD(v80[0]) = 134218240;
    *(void **)((char *)v80 + 4) = v53;
    WORD2(v80[1]) = 2048;
    *(void **)((char *)&v80[1] + 6) = &v54[(void)v55 + (unint64_t)[a4 count]];
    uint64_t v56 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v52,  0LL,  "#ClearClient installation check found %ld uninstalled apps (amongst %ld bundle IDs)",  v80,  22);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::handleAppInstallationStatus(NSArray<NSString *> *, NSArray<NSString *> *, NSArray<NSString *> *)",  "%s\n",  v56);
  }

  double Current = CFAbsoluteTimeGetCurrent();
  __int128 v72 = 0u;
  __int128 v73 = 0u;
  __int128 v74 = 0u;
  __int128 v75 = 0u;
  id v9 = [a2 countByEnumeratingWithState:&v72 objects:v86 count:16];
  if (!v9)
  {
    double v11 = -1.0;
    goto LABEL_96;
  }

  uint64_t v10 = *(void *)v73;
  double v11 = -1.0;
  do
  {
    BOOL v12 = 0LL;
    do
    {
      if (*(void *)v73 != v10) {
        objc_enumerationMutation(a2);
      }
      uint64_t v13 = *(void *)(*((void *)&v72 + 1) + 8LL * (void)v12);
      unint64_t v14 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
      id v15 = sub_10053D6E0( (uint64_t)a1,  (uint64_t)+[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  v13,  105LL));
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v16 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)&uint8_t buf[4] = v15;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "#ClearClient %@ is missing ", buf, 0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        LODWORD(v80[0]) = 138412290;
        *(void **)((char *)v80 + 4) = v15;
        LODWORD(v5_Block_object_dispose(va, 8) = 12;
        uint64_t v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "#ClearClient %@ is missing ",  v80,  v58);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::handleAppInstallationStatus(NSArray<NSString *> *, NSArray<NSString *> *, NSArray<NSString *> *)",  "%s\n",  v27);
      }

      double v76 = 2.22507386e-308;
      if (sub_100556968((uint64_t)a1, (uint64_t)v15, &v76))
      {
        double v17 = v76;
        double v18 = Current - v76;
        if (Current - v76 >= a1[30])
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          uint64_t v19 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v20 = *((void *)a1 + 30);
            *(_DWORD *)__int128 buf = 68289794;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            *(_WORD *)&buf[18] = 2114;
            *(void *)&buf[20] = v15;
            *(_WORD *)&_BYTE buf[28] = 2050;
            *(double *)&buf[30] = v18;
            *(_WORD *)&_BYTE buf[38] = 2050;
            *(void *)&uint8_t buf[40] = v20;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#ClearClient Deleting entry as client has been missing beyond safe harbor threshold , Client:%{public, location:escape_only}@, missingTimeDuration_s:%{public}.09f, safe harbo r threshold_s:%{public}.09f}",  buf,  0x30u);
          }

          sub_1010DDBC0(__p, "ClientRemoved");
          sub_10054BFD4((uint64_t)a1, v15, 1, (uint64_t *)__p);
          if (v71 < 0) {
            operator delete(__p[0]);
          }
          memset(v89, 0, 35);
          *(_OWORD *)std::string v88 = 0u;
          memset(buf, 0, sizeof(buf));
          __int128 v90 = 0u;
          memset(v91, 0, 59);
          if (v15)
          {
            [v15 clientName];
          }

          else
          {
            uint64_t v85 = 0LL;
            memset(v84, 0, sizeof(v84));
            *(_OWORD *)__int16 v83 = 0uLL;
            *(_OWORD *)__int16 v81 = 0uLL;
            memset(v82, 0, sizeof(v82));
            memset(v80, 0, sizeof(v80));
          }

          *(_OWORD *)__int128 buf = *(_OWORD *)v80;
          *(void **)&uint8_t buf[16] = v80[2];
          HIBYTE(v80[2]) = 0;
          LOBYTE(v80[0]) = 0;
          *(_OWORD *)&buf[24] = *(_OWORD *)&v80[3];
          *(void **)&uint8_t buf[40] = v80[5];
          HIBYTE(v80[5]) = 0;
          LOBYTE(v80[3]) = 0;
          if (SHIBYTE(v89[0]) < 0) {
            operator delete(v88[0]);
          }
          *(_OWORD *)std::string v88 = *(_OWORD *)v81;
          v89[0] = v82[0];
          HIBYTE(v82[0]) = 0;
          LOBYTE(v81[0]) = 0;
          if (SHIBYTE(v89[3]) < 0) {
            operator delete(v89[1]);
          }
          *(_OWORD *)&v89[1] = *(_OWORD *)&v82[1];
          v89[3] = v82[3];
          HIBYTE(v82[3]) = 0;
          LOBYTE(v82[1]) = 0;
          LOWORD(v89[4]) = v82[4];
          BYTE2(v89[4]) = BYTE2(v82[4]);
          if (SBYTE7(v91[0]) < 0) {
            operator delete((void *)v90);
          }
          __int128 v90 = *(_OWORD *)&v82[5];
          *(void **)&v91[0] = v82[7];
          HIBYTE(v82[7]) = 0;
          LOBYTE(v82[5]) = 0;
          if (SHIBYTE(v91[1]) < 0) {
            operator delete(*((void **)&v91[0] + 1));
          }
          char v26 = 0;
          *(_OWORD *)((char *)v91 + _Block_object_dispose(va, 8) = *(_OWORD *)v83;
          *((void *)&v91[1] + 1) = *(void *)&v84[0];
          BYTE7(v84[0]) = 0;
          LOBYTE(v83[0]) = 0;
          if (SBYTE7(v91[3]) < 0)
          {
            operator delete(*(void **)&v91[2]);
            char v26 = BYTE7(v84[0]);
          }

          v91[2] = *(_OWORD *)((char *)v84 + 8);
          *(void *)&v91[3] = *((void *)&v84[1] + 1);
          HIBYTE(v84[1]) = 0;
          BYTE8(v84[0]) = 0;
          WORD4(v91[3]) = v85;
          BYTE10(v91[3]) = BYTE2(v85);
          if (v26 < 0) {
            operator delete(v83[0]);
          }
          if (SHIBYTE(v82[7]) < 0) {
            operator delete(v82[5]);
          }
          if (SHIBYTE(v82[3]) < 0) {
            operator delete(v82[1]);
          }
          if (SHIBYTE(v82[0]) < 0) {
            operator delete(v81[0]);
          }
          if (SHIBYTE(v80[5]) < 0) {
            operator delete(v80[3]);
          }
          if (SHIBYTE(v80[2]) < 0) {
            operator delete(v80[0]);
          }
          LODWORD(v80[0]) = 1;
          (*(void (**)(double *, void **, uint8_t *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  v80,  buf,  0LL,  0xFFFFFFFFLL,  0LL);
          if (SBYTE7(v91[3]) < 0) {
            operator delete(*(void **)&v91[2]);
          }
          if (SHIBYTE(v91[1]) < 0) {
            operator delete(*((void **)&v91[0] + 1));
          }
          if (SBYTE7(v91[0]) < 0) {
            operator delete((void *)v90);
          }
          if (SHIBYTE(v89[3]) < 0) {
            operator delete(v89[1]);
          }
          if (SHIBYTE(v89[0]) < 0) {
            operator delete(v88[0]);
          }
          goto LABEL_44;
        }
      }

      else
      {
        double v18 = 0.0;
        double v17 = v76;
      }

      if (v17 == 2.22507386e-308)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        unint64_t v21 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2114;
          *(void *)&buf[20] = v15;
          *(_WORD *)&_BYTE buf[28] = 2050;
          *(double *)&buf[30] = Current;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#ClearClient Marking client as missing, Client:%{public, location:escape_only}@ , missingTime_s:%{public}.09f}",  buf,  0x26u);
        }

        sub_10054BC40((id *)a1, (uint64_t)v15, &Current);
        __int16 v22 = (void *)*((void *)a1 + 17);
        *(void *)__int128 buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 3221225472LL;
        *(void *)&uint8_t buf[16] = sub_100554B60;
        *(void *)&buf[24] = &unk_10183FB60;
        *(void *)&uint8_t buf[40] = a1;
        *(void *)&uint8_t buf[32] = v15;
        [v22 iterateIdentitiesRelatedToKeyPath:v15 withBlock:buf];
      }

      if (a1[30] - v18 < v11 || v11 == -1.0) {
        double v11 = a1[30] - v18;
      }
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int16 v24 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v25 = *((void *)a1 + 30);
        *(_DWORD *)__int128 buf = 138412802;
        *(void *)&uint8_t buf[4] = v15;
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(double *)&buf[14] = v18;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&buf[24] = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "%@ has been missing for %.3fs (safe harbor threshold: %.3fs)",  buf,  0x20u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        unint64_t v28 = (void *)*((void *)a1 + 30);
        LODWORD(v80[0]) = 138412802;
        *(void **)((char *)v80 + 4) = v15;
        WORD2(v80[1]) = 2048;
        *(void **)((char *)&v80[1] + 6) = *(void **)&v18;
        HIWORD(v80[2]) = 2048;
        v80[3] = v28;
        LODWORD(v5_Block_object_dispose(va, 8) = 32;
        uint64_t v29 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "%@ has been missing for %.3fs (safe harbor threshold: %.3fs)",  v80,  v58);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::handleAppInstallationStatus(NSArray<NSString *> *, NSArray<NSString *> *, NSArray<NSString *> *)",  "%s\n",  v29);
      }

void sub_1005568D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL sub_100556968(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  *a3 = 0x10000000000000LL;
  return 0LL;
}

_BYTE *sub_1005569D8(_BYTE *result)
{
  if (!result[1072])
  {
    result[1072] = 1;
    uint64_t v1 = (void *)*((void *)result + 5);
    v2[0] = _NSConcreteStackBlock;
    v2[1] = 3221225472LL;
    v2[2] = sub_10057B3BC;
    v2[3] = &unk_10181D3D0;
    v2[4] = result;
    return [v1 afterInterval:v2 async:0.1];
  }

  return result;
}

void sub_100556A48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((sub_1001B9A1C() & 1) != 0 || *(_BYTE *)(a1 + 992)) {
    return;
  }
  uint64_t v6 = *(void *)(a1 + 968);
  uint64_t v7 = *(void *)(a1 + 976);
  if (v6 != v7)
  {
    while (*(void *)v6 != a2)
    {
      v6 += 32LL;
      if (v6 == v7) {
        goto LABEL_18;
      }
    }
  }

  if (v6 == v7)
  {
LABEL_18:
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      double v11 = "Unknown";
      if (a2 == 1) {
        double v11 = "Bluetooth";
      }
      if (a2) {
        BOOL v12 = (char *)v11;
      }
      else {
        BOOL v12 = "Wifi";
      }
      sub_1010DDBC0(&__p, v12);
      if (v47 >= 0) {
        p_p = &__p;
      }
      else {
        p_p = __p;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "ImproveAccuracyNotification object not created for technology, %{public}s",  buf,  0xCu);
      if (SHIBYTE(v47) < 0) {
        operator delete(__p);
      }
    }

    if (!sub_1002921D0(115, 0)) {
      return;
    }
    bzero(&__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v14 = qword_101934988;
    id v15 = "Unknown";
    if (a2 == 1) {
      id v15 = "Bluetooth";
    }
    if (a2) {
      id v16 = (char *)v15;
    }
    else {
      id v16 = "Wifi";
    }
    sub_1010DDBC0(buf, v16);
    if (SBYTE3(v41) >= 0) {
      double v17 = buf;
    }
    else {
      double v17 = *(_BYTE **)buf;
    }
    *(_DWORD *)uint64_t v37 = 136446210;
    *(void *)&v37[4] = v17;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v14,  17LL,  "ImproveAccuracyNotification object not created for technology, %{public}s",  v37,  12);
    uint64_t v19 = v18;
    if (SBYTE3(v41) < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLClientManager::ensureTechnologyEnabled(CLClientManagerTechnology, CLDaemonClient *)",  "%s\n",  v19);
    goto LABEL_102;
  }

  if (*(double *)(v6 + 16) < 0.0 || CFAbsoluteTimeGetCurrent() - *(double *)(v6 + 8) <= *(double *)(v6 + 16))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v20 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v21 = "Unknown";
      if (a2 == 1) {
        unint64_t v21 = "Bluetooth";
      }
      if (a2) {
        __int16 v22 = (char *)v21;
      }
      else {
        __int16 v22 = "Wifi";
      }
      sub_1010DDBC0(&__p, v22);
      if (v47 >= 0) {
        unint64_t v23 = &__p;
      }
      else {
        unint64_t v23 = __p;
      }
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "improve accuracy notification for %s is not eligible to post.",  buf,  0xCu);
      if (SHIBYTE(v47) < 0) {
        operator delete(__p);
      }
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(&__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v32 = qword_101934988;
    uint64_t v33 = "Unknown";
    if (a2 == 1) {
      uint64_t v33 = "Bluetooth";
    }
    if (a2) {
      uint64_t v34 = (char *)v33;
    }
    else {
      uint64_t v34 = "Wifi";
    }
    sub_1010DDBC0(buf, v34);
    if (SBYTE3(v41) >= 0) {
      uint64_t v35 = buf;
    }
    else {
      uint64_t v35 = *(_BYTE **)buf;
    }
    *(_DWORD *)uint64_t v37 = 136315138;
    *(void *)&v37[4] = v35;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v32,  2LL,  "improve accuracy notification for %s is not eligible to post.",  v37);
    uint64_t v19 = v36;
    if (SBYTE3(v41) < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::ensureTechnologyEnabled(CLClientManagerTechnology, CLDaemonClient *)",  "%s\n",  v19);
LABEL_102:
    return;
  }

  if (*(void *)v6 != 1LL)
  {
    if (*(void *)v6 || !*(_BYTE *)(a1 + 993)) {
      return;
    }
    if (sub_1004F9E7C())
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v8 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        __int128 __p = (void *)68289026;
        LOWORD(v47) = 2082;
        *(void *)((char *)&v47 + 2) = "";
        id v9 = "{msg%{public}.0s:WiFi is disabled, but the prompt will be suppressed because we're in demo mode}";
LABEL_88:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, v9, (uint8_t *)&__p, 0x12u);
        return;
      }

      return;
    }

    if (!*(_BYTE *)(a1 + 1504))
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v8 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        __int128 __p = (void *)68289026;
        LOWORD(v47) = 2082;
        *(void *)((char *)&v47 + 2) = "";
        id v9 = "{msg%{public}.0s:WiFi is disabled, but the device has yet to be unlocked, so we will suppress the prompt for now}";
        goto LABEL_88;
      }

      return;
    }

void sub_10055724C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

BOOL sub_100557274(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v7 = sub_10053D6E0(a1, a2);
  if (!&SBUserNotificationPendInSetupIfNotAllowedKey) {
    return 0LL;
  }
  uint64_t v9 = (uint64_t)v7;
  uint64_t v10 = sub_10059CEEC();
  double v11 = (void *)sub_10059E10C(v10, @"LOCATION_ACCURACY");
  if (a3 == 1)
  {
    uint64_t v13 = sub_10059CEEC();
    uint64_t v14 = @"IMPROVE_LOCATION_ACCURACY_BLUETOOTH";
LABEL_10:
    id v15 = (void *)sub_10059E10C(v13, v14);
    goto LABEL_11;
  }

  if (!a3)
  {
    int v12 = MGGetBoolAnswer(@"wapi");
    uint64_t v13 = sub_10059CEEC();
    if (v12) {
      uint64_t v14 = @"IMPROVE_LOCATION_ACCURACY_WLAN";
    }
    else {
      uint64_t v14 = @"IMPROVE_LOCATION_ACCURACY_WIFI";
    }
    goto LABEL_10;
  }

  id v15 = 0LL;
LABEL_11:
  uint64_t v16 = sub_10059CEEC();
  double v17 = (void *)sub_10059E10C(v16, @"OK");
  uint64_t v18 = sub_10059CEEC();
  uint64_t v19 = (void *)sub_10059E10C(v18, @"SETTINGS");
  uint64_t v20 = v19;
  if (v11 && v15 && v17 && v19)
  {
    keys = (void *)SBUserNotificationPendInSetupIfNotAllowedKey;
    *(void *)id v36 = kCFUserNotificationAlertHeaderKey;
    *(void *)&v36[8] = kCFUserNotificationAlertMessageKey;
    *(void *)&v36[16] = kCFUserNotificationDefaultButtonTitleKey;
    CFStringRef v37 = kCFUserNotificationAlternateButtonTitleKey;
    values[0] = kCFBooleanTrue;
    values[1] = v11;
    values[2] = v15;
    values[3] = v17;
    values[4] = v19;
    unint64_t v21 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)&keys,  (const void **)values,  5LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    if (v21)
    {
      __int16 v22 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0LL, &error, v21);
      CFRelease(v21);
    }

    else
    {
      __int16 v22 = 0LL;
    }

    goto LABEL_20;
  }

  __int16 v22 = 0LL;
  if (v19) {
LABEL_20:
  }
    CFRelease(v20);
  if (v17) {
    CFRelease(v17);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v22)
  {
    RunLoopSource = CFUserNotificationCreateRunLoopSource( kCFAllocatorDefault,  v22,  (CFUserNotificationCallBack)sub_10057D288,  0LL);
    if (!RunLoopSource)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v30 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        keys = (void *)68289282;
        *(_WORD *)id v36 = 2082;
        *(void *)&uint64_t v36[2] = "";
        *(_WORD *)&v36[10] = 2114;
        *(void *)&v36[12] = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Could not create runloop source for ImproveAccuracyPrefs notification, Client:%{p ublic, location:escape_only}@}",  (uint8_t *)&keys,  0x1Cu);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      id v31 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        keys = (void *)68289282;
        *(_WORD *)id v36 = 2082;
        *(void *)&uint64_t v36[2] = "";
        *(_WORD *)&v36[10] = 2114;
        *(void *)&v36[12] = v9;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v31,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Could not create runloop source for ImproveAccuracyPrefs notification",  "{msg%{public}.0s:Could not create runloop source for ImproveAccuracyPrefs notification, Client:%{p ublic, location:escape_only}@}",  (uint8_t *)&keys,  0x1Cu);
      }

      CFRelease(v22);
      return 0LL;
    }

    int v24 = (__CFRunLoop *)sub_10029228C();
    CFRunLoopAddSource(v24, RunLoopSource, kCFRunLoopCommonModes);
    CFRelease(RunLoopSource);
    CFRetain(v22);
    sub_100575938(a4);
    *(void *)(a4 + 24) = v22;
    sub_1010DDBC0(__p, "");
    sub_1005857F0((uint64_t)&keys, 15, v9, 0LL, (__int128 *)__p);
    if (v33 < 0) {
      operator delete(__p[0]);
    }
    [*(id *)(a1 + 40) currentLatchedAbsoluteTimestamp];
    uint64_t v26 = v25;
    CFRetain(v22);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = v22;
    uint64_t v39 = v26;
    uint64_t v27 = operator new(0x48uLL);
    sub_1005859E4((uint64_t)v27, (uint64_t)&keys);
    sub_10057D1B4((uint64_t *)(a1 + 272), (uint64_t)v27);
    CFRelease(v22);
    sub_10055E9A8((uint64_t)[*(id *)(a1 + 32) vendor]);
    sub_1005858A0((uint64_t)&keys);
    return 1LL;
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v28 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      keys = (void *)68289282;
      *(_WORD *)id v36 = 2082;
      *(void *)&uint64_t v36[2] = "";
      *(_WORD *)&v36[10] = 2114;
      *(void *)&v36[12] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Could not create ImproveAccuracyPrefs notification, Client:%{public, location:escape_only}@}",  (uint8_t *)&keys,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v29 = (os_log_s *)qword_101934988;
    BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
    if (result)
    {
      keys = (void *)68289282;
      *(_WORD *)id v36 = 2082;
      *(void *)&uint64_t v36[2] = "";
      *(_WORD *)&v36[10] = 2114;
      *(void *)&v36[12] = v9;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v29,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Could not create ImproveAccuracyPrefs notification",  "{msg%{public}.0s:Could not create ImproveAccuracyPrefs notification, Client:%{public, location:escape_only}@}",  (uint8_t *)&keys,  0x1Cu);
      return 0LL;
    }
  }

  return result;
}

void sub_100557814( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16)
{
}

id sub_10055785C(uint64_t a1, __int128 *a2, uint64_t a3)
{
  if (*(void *)(a1 + 1080)) {
    goto LABEL_50;
  }
  uint64_t v6 = objc_alloc(&OBJC_CLASS___NSDictionary);
  sub_10030A238(&v81);
  sub_1010DDBC0(&v74, off_101938700);
  if ((v74.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    id v7 = &v74;
  }
  else {
    id v7 = (std::string *)v74.__r_.__value_.__r.__words[0];
  }
  if ((v74.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type size = v74.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type size = v74.__r_.__value_.__l.__size_;
  }
  uint64_t v9 = std::string::append(&v81, (const std::string::value_type *)v7, size);
  __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  int64_t cap = v9->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v10;
  v9->__r_.__value_.__l.__size_ = 0LL;
  v9->__r_.__value_.__l.__cap_ = 0LL;
  v9->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    double v11 = __p;
  }
  else {
    double v11 = (void **)__p[0];
  }
  *(void *)(a1 + 1080) = -[NSDictionary initWithContentsOfFile:]( v6,  "initWithContentsOfFile:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v11));
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  int v12 = *(void **)(a1 + 1080);
  if (v12)
  {
    *(void *)(a1 + 108_Block_object_dispose(va, 8) =  objc_msgSend( objc_msgSend(v12, "allKeys"),  "sortedArrayUsingComparator:",  &stru_10183FBE8);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v13 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      id v14 = objc_msgSend(objc_msgSend(*(id *)(a1 + 1080), "description"), "UTF8String");
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "DAR map: %s", (uint8_t *)__p, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v46 = qword_101934988;
      id v47 = objc_msgSend(objc_msgSend(*(id *)(a1 + 1080), "description"), "UTF8String");
      LODWORD(v81.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v81.__r_.__value_.__r.__words + 4) = (std::string::size_type)v47;
      __int128 v48 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v46,  2LL,  "DAR map: %s",  (const char *)&v81);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::reduceAccuracy(const CLClientLocation &, CLClientManagerReduceAccuracyReplyBlock)",  "%s\n",  v48);
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v15 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      id v16 = objc_msgSend(objc_msgSend(*(id *)(a1 + 1088), "description"), "UTF8String");
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "DAR map sorted keys: %s", (uint8_t *)__p, 0xCu);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_50;
    }
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v17 = qword_101934988;
    id v18 = objc_msgSend(objc_msgSend(*(id *)(a1 + 1088), "description"), "UTF8String");
    LODWORD(v81.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v81.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
    uint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v17,  2LL,  "DAR map sorted keys: %s",  (const char *)&v81);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::reduceAccuracy(const CLClientLocation &, CLClientManagerReduceAccuracyReplyBlock)",  "%s\n",  v19);
LABEL_92:
    free(v19);
    goto LABEL_50;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v20 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
  {
    sub_10030A238(&v81);
    sub_1010DDBC0(&v74, off_101938700);
    if ((v74.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unint64_t v21 = &v74;
    }
    else {
      unint64_t v21 = (std::string *)v74.__r_.__value_.__r.__words[0];
    }
    if ((v74.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v22 = v74.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v22 = v74.__r_.__value_.__l.__size_;
    }
    unint64_t v23 = std::string::append(&v81, (const std::string::value_type *)v21, v22);
    __int128 v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    int64_t cap = v23->__r_.__value_.__l.__cap_;
    *(_OWORD *)__int128 __p = v24;
    v23->__r_.__value_.__l.__size_ = 0LL;
    v23->__r_.__value_.__l.__cap_ = 0LL;
    v23->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v25 = __p;
    if (cap < 0) {
      uint64_t v25 = (void **)__p[0];
    }
    LODWORD(buf) = 136446210;
    *(void *)((char *)&buf + 4) = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_FAULT,  "DAR: could not read map file %{public}s",  (uint8_t *)&buf,  0xCu);
    if (SHIBYTE(cap) < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v49 = qword_101934988;
    sub_10030A238(&v74);
    sub_1010DDBC0(&buf, off_101938700);
    if ((v76 & 0x80u) == 0) {
      p___int128 buf = (const std::string::value_type *)&buf;
    }
    else {
      p___int128 buf = (const std::string::value_type *)buf;
    }
    if ((v76 & 0x80u) == 0) {
      std::string::size_type v51 = v76;
    }
    else {
      std::string::size_type v51 = *((void *)&buf + 1);
    }
    __int128 v52 = std::string::append(&v74, p_buf, v51);
    __int128 v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v81.__r_.__value_.__l.__cap_ = v52->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v81.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0LL;
    v52->__r_.__value_.__l.__cap_ = 0LL;
    v52->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v54 = &v81;
    if ((v81.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v54 = (std::string *)v81.__r_.__value_.__r.__words[0];
    }
    int v77 = 136446210;
    int v78 = v54;
    uint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v49,  17LL,  "DAR: could not read map file %{public}s",  &v77,  12);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLClientManager::reduceAccuracy(const CLClientLocation &, CLClientManagerReduceAccuracyReplyBlock)",  "%s\n",  v19);
  }

void sub_100558350(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x277]) < 0) {
    operator delete((void *)STACK[0x260]);
  }
  if (SLOBYTE(STACK[0x25F]) < 0) {
    operator delete((void *)STACK[0x248]);
  }
  _Unwind_Resume(a1);
}

int64_t sub_1005583D8(id a1, id a2, id a3)
{
  id v5 = [a2 integerValue];
  id v7 = [a2 integerValue];
  else {
    return -1LL;
  }
}

uint64_t sub_100558440(uint64_t a1, uint64_t a2, double a3)
{
  double v29 = a3;
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v5 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = *(void *)(a2 + 4);
    uint64_t v7 = *(void *)(a2 + 12);
    uint64_t v8 = *(void *)(a2 + 20);
    *(_DWORD *)__int128 buf = 134218496;
    uint64_t v39 = v6;
    __int16 v40 = 2048;
    uint64_t v41 = v7;
    __int16 v42 = 2048;
    uint64_t v43 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "DAR: original location: %.8f, %.8f, %.2f",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v20 = *(void *)(a2 + 4);
    uint64_t v21 = *(void *)(a2 + 12);
    uint64_t v22 = *(void *)(a2 + 20);
    int v32 = 134218496;
    uint64_t v33 = v20;
    __int16 v34 = 2048;
    uint64_t v35 = v21;
    __int16 v36 = 2048;
    uint64_t v37 = v22;
    LODWORD(v2_Block_object_dispose(va, 8) = 32;
    unint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "DAR: original location: %.8f, %.8f, %.2f",  COERCE_DOUBLE(&v32),  v28,  v29);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::reduceAccuracy(const CLClientLocation &, CLClientManagerReduceAccuracyReplyBlock)_block_invoke",  "%s\n",  v23);
  }

  *(float64x2_t *)(a2 + 4) = vmulq_n_f64( vrndaq_f64(vdivq_f64(*(float64x2_t *)(a2 + 4), (float64x2_t)vdupq_lane_s64( *(uint64_t *)&v29,  0))),  v29);
  *(double *)(a2 + 20) = sqrt(v29 * v29 * 5000000000.0 + *(double *)(a2 + 20) * *(double *)(a2 + 20));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v9 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v10 = *(void *)(a2 + 4);
    uint64_t v11 = *(void *)(a2 + 12);
    uint64_t v12 = *(void *)(a2 + 20);
    *(_DWORD *)__int128 buf = 134218496;
    uint64_t v39 = v10;
    __int16 v40 = 2048;
    uint64_t v41 = v11;
    __int16 v42 = 2048;
    uint64_t v43 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "DAR:  reduced location: %.8f, %.8f, %.2f",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v24 = *(void *)(a2 + 4);
    uint64_t v25 = *(void *)(a2 + 12);
    uint64_t v26 = *(void *)(a2 + 20);
    int v32 = 134218496;
    uint64_t v33 = v24;
    __int16 v34 = 2048;
    uint64_t v35 = v25;
    __int16 v36 = 2048;
    uint64_t v37 = v26;
    LODWORD(v2_Block_object_dispose(va, 8) = 32;
    __int128 v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "DAR:  reduced location: %.8f, %.8f, %.2f",  COERCE_DOUBLE(&v32),  v28,  v29);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::reduceAccuracy(const CLClientLocation &, CLClientManagerReduceAccuracyReplyBlock)_block_invoke",  "%s\n",  v27);
  }

  uint64_t v13 = *(void *)(a1 + 32);
  id v14 = objc_alloc(&OBJC_CLASS___CLLocation);
  __int128 v15 = *(_OWORD *)(a2 + 112);
  v30[6] = *(_OWORD *)(a2 + 96);
  v30[7] = v15;
  v31[0] = *(_OWORD *)(a2 + 128);
  *(_OWORD *)((char *)v31 + 12) = *(_OWORD *)(a2 + 140);
  __int128 v16 = *(_OWORD *)(a2 + 48);
  v30[2] = *(_OWORD *)(a2 + 32);
  v30[3] = v16;
  __int128 v17 = *(_OWORD *)(a2 + 80);
  v30[4] = *(_OWORD *)(a2 + 64);
  v30[5] = v17;
  __int128 v18 = *(_OWORD *)(a2 + 16);
  v30[0] = *(_OWORD *)a2;
  v30[1] = v18;
  return (*(uint64_t (**)(uint64_t, CLLocation *))(v13 + 16))( v13,  -[CLLocation initWithClientLocation:](v14, "initWithClientLocation:", v30));
}

uint64_t sub_100558854(void *a1, uint64_t a2)
{
  int v2 = a2;
  uint64_t v4 = a1[5];
  id v5 = (char *)objc_msgSend( *(id *)(v4 + 1088),  "indexOfObject:inSortedRange:options:usingComparator:",  -[NSNumber stringValue]( +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", a2),  "stringValue"),  0,  objc_msgSend(*(id *)(v4 + 1088), "count"),  1024,  &stru_10183FC30);
  if (v5 == [*(id *)(v4 + 1088) count]
    || objc_msgSend(objc_msgSend(*(id *)(v4 + 1088), "objectAtIndex:", v5), "integerValue") != (id)v2)
  {
    --v5;
  }

  objc_msgSend( objc_msgSend(*(id *)(v4 + 1080), "objectForKey:", objc_msgSend(*(id *)(v4 + 1088), "objectAtIndex:", v5)),  "doubleValue");
  double v7 = v6;
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v8 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 134218240;
    double v16 = v7;
    __int16 v17 = 1024;
    int v18 = v2;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "DAR: applying new quantization %f based on ap count %d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v11 = 134218240;
    double v12 = v7;
    __int16 v13 = 1024;
    int v14 = v2;
    uint64_t v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "DAR: applying new quantization %f based on ap count %d",  COERCE_DOUBLE(&v11),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::reduceAccuracy(const CLClientLocation &, CLClientManagerReduceAccuracyReplyBlock)_block_invoke",  "%s\n",  v10);
  }

  if (v2)
  {
    memmove((void *)(v4 + 1096), a1 + 6, 0x9CuLL);
    *(double *)(v4 + 1256) = v7;
  }

  return (*(uint64_t (**)(double))(a1[4] + 16LL))(v7);
}

int64_t sub_100558B24(id a1, id a2, id a3)
{
  id v5 = [a2 integerValue];
  id v7 = [a2 integerValue];
  else {
    return -1LL;
  }
}

void sub_100558B8C(uint64_t a1, CLConnection *a2)
{
  id v5 = *(void **)(a1 + 784);
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v4 = a2;
  int v2 = (uint64_t **)(a1 + 776);
  id v3 = (uint64_t *)(a1 + 784);
  do
  {
    unint64_t v6 = v5[4];
    BOOL v7 = v6 >= (unint64_t)a2;
    else {
      uint64_t v8 = v5 + 1;
    }
    if (v7) {
      id v3 = v5;
    }
    id v5 = (void *)*v8;
  }

  while (*v8);
  if (v3 == (uint64_t *)(a1 + 784) || v3[4] > (unint64_t)a2)
  {
LABEL_12:
    sub_10123D928();
    __break(1u);
  }

  uint64_t v9 = v3[5];
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v10 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    CLConnection::getName(v4);
    int v11 = v20 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Client %{public}s disconnected", buf, 0xCu);
    if (v20 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v12 = qword_101934988;
    CLConnection::getName(v4);
    if (v16 >= 0) {
      __int16 v13 = buf;
    }
    else {
      __int16 v13 = *(_BYTE **)buf;
    }
    int v17 = 136446210;
    int v18 = v13;
    int v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v12,  0LL,  "Client %{public}s disconnected",  &v17,  12);
    if (v16 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::destroyGenericClient(CLConnection *)", "%s\n", v14);
  }

  sub_1000087E8(v2, v3);
  operator delete(v3);
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
  }
}

void sub_100558E24(uint64_t a1, uint64_t a2)
{
  int v2 = *(void **)(a1 + 848);
  id v3 = (void *)(a1 + 856);
  if (v2 != (void *)(a1 + 856))
  {
    while (1)
    {
      unint64_t v6 = v2[4];
      BOOL v7 = (void *)v2[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          BOOL v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (void *)v2[2];
          BOOL v9 = *v8 == (void)v2;
          int v2 = v8;
        }

        while (!v9);
      }

      int v2 = v8;
      if (v8 == v3) {
        return;
      }
    }

    *(void *)(v6 + _Block_object_dispose(va, 8) = mach_continuous_time();
    sub_100559024(a1, v6);
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101840220);
    }
    uint64_t v10 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 68289282;
      int v13 = 0;
      __int16 v14 = 2082;
      __int128 v15 = "";
      __int16 v16 = 2050;
      unint64_t v17 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#dic consuming a matching butterfly, eaten:%{public}p}",  (uint8_t *)&v12,  0x1Cu);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_101840220);
      }
    }

    int v11 = (os_log_s *)qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      int v12 = 68289282;
      int v13 = 0;
      __int16 v14 = 2082;
      __int128 v15 = "";
      __int16 v16 = 2050;
      unint64_t v17 = v6;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v11,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#dic consuming a matching butterfly",  "{msg%{public}.0s:#dic consuming a matching butterfly, eaten:%{public}p}",  (uint8_t *)&v12,  0x1Cu);
    }
  }

void sub_100559024(uint64_t a1, unint64_t a2)
{
  id v3 = *(void **)(a1 + 856);
  if (!v3) {
    goto LABEL_12;
  }
  id v5 = (uint64_t **)(a1 + 848);
  unint64_t v6 = (uint64_t *)(a1 + 856);
  do
  {
    unint64_t v7 = v3[4];
    BOOL v8 = v7 >= a2;
    if (v7 >= a2) {
      BOOL v9 = v3;
    }
    else {
      BOOL v9 = v3 + 1;
    }
    if (v8) {
      unint64_t v6 = v3;
    }
    id v3 = (void *)*v9;
  }

  while (*v9);
  if (v6 == (uint64_t *)(a1 + 856) || v6[4] > a2) {
LABEL_12:
  }
    sub_10123DA9C();
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v10 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v16 = 2082;
    unint64_t v17 = "";
    __int16 v18 = 2114;
    uint64_t v19 = sub_100019240(a2);
    __int16 v20 = 2050;
    unint64_t v21 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:destroying #dic, ClientKeyPath:%{public, location:escape_only}@, this:%{public}p}",  buf,  0x26u);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
  }

  int v11 = (os_log_s *)qword_101934988;
  if (os_signpost_enabled((os_log_t)qword_101934988))
  {
    uint64_t v12 = sub_100019240(a2);
    *(_DWORD *)__int128 buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v16 = 2082;
    unint64_t v17 = "";
    __int16 v18 = 2114;
    uint64_t v19 = v12;
    __int16 v20 = 2050;
    unint64_t v21 = a2;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v11,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "destroying #dic",  "{msg%{public}.0s:destroying #dic, ClientKeyPath:%{public, location:escape_only}@, this:%{public}p}",  buf,  0x26u);
  }

  sub_1010DDBC0( buf,  (char *)-[NSString UTF8String]( +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%p", a2),  "UTF8String"));
  uint64_t v13 = sub_100019240(a2);
  unsigned int v14 = (*(uint64_t (**)(unint64_t))(*(void *)a2 + 24LL))(a2);
  sub_1005450B8(a1, v13, (uint64_t *)buf, v14, 0LL, 0);
  sub_1000087E8(v5, v6);
  operator delete(v6);
  (*(void (**)(unint64_t))(*(void *)a2 + 8LL))(a2);
  if (SBYTE3(v19) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1005592CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005592F0(uint64_t a1, uint64_t a2, unint64_t a3, int a4, int a5)
{
  if (a2 >= 9)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unint64_t v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      uint64_t v37 = 68289282LL;
      *(_WORD *)__int128 v38 = 2082;
      *(void *)&v38[2] = "";
      *(_WORD *)&v38[10] = 2050;
      *(void *)&_BYTE v38[12] = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#sbim Out of bounds access -- entity class too large, entityClass:%{public, locatio n:CLLocationDictionaryUtilitiesEntityClass}lld}",  (uint8_t *)&v37,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v7 = qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      uint64_t v37 = 68289282LL;
      *(_WORD *)__int128 v38 = 2082;
      *(void *)&v38[2] = "";
      *(_WORD *)&v38[10] = 2050;
      *(void *)&_BYTE v38[12] = a2;
      BOOL v8 = "#sbim Out of bounds access -- entity class too large";
      BOOL v9 = "{msg%{public}.0s:#sbim Out of bounds access -- entity class too large, entityClass:%{public, loca"
           "tion:CLLocationDictionaryUtilitiesEntityClass}lld}";
      uint64_t v10 = (os_log_s *)v7;
LABEL_17:
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v8,  v9,  (uint8_t *)&v37,  0x1Cu);
      return;
    }

    return;
  }

  if (a3 < 3)
  {
    if (!a3) {
      return;
    }
    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    unsigned int v19 = a2;
    do
    {
      ++v17;
    }

    while (v17 != 3);
    __int16 v20 = (int *)(a1 + 12LL * a2 + 4 * a3 + 1304);
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    uint64_t v22 = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (a4)
    {
      if (a4 != 1) {
        goto LABEL_45;
      }
      if (*v20 != -1)
      {
        int v23 = *v20 + 1;
LABEL_29:
        *__int16 v20 = v23;
        goto LABEL_45;
      }

      if (qword_101934980 != -1)
      {
        dispatch_once(&qword_101934980, &stru_1018401A0);
        uint64_t v22 = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
      }

      uint64_t v24 = (os_log_s *)v22[305];
      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
      {
        uint64_t v37 = 68289538LL;
        *(_WORD *)__int128 v38 = 2082;
        *(void *)&v38[2] = "";
        *(_WORD *)&v38[10] = 2050;
        *(void *)&_BYTE v38[12] = a2;
        *(_WORD *)&v38[20] = 2050;
        *(void *)&v38[22] = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#sbim Count overflow!, entityClass:%{public, location:CLLocationDictionaryUtiliti esEntityClass}lld, arrowState:%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}",  (uint8_t *)&v37,  0x26u);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      uint64_t v25 = (os_log_s *)qword_101934988;
      BOOL v26 = os_signpost_enabled((os_log_t)qword_101934988);
      uint64_t v22 = &OBJC_METACLASS___CLPrivacyManager.vtable;
      p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
      if (!v26) {
        goto LABEL_45;
      }
      uint64_t v37 = 68289538LL;
      *(_WORD *)__int128 v38 = 2082;
      *(void *)&v38[2] = "";
      *(_WORD *)&v38[10] = 2050;
      *(void *)&_BYTE v38[12] = a2;
      *(_WORD *)&v38[20] = 2050;
      *(void *)&v38[22] = a3;
      __int128 v27 = "#sbim Count overflow!";
      double v28 = "{msg%{public}.0s:#sbim Count overflow!, entityClass:%{public, location:CLLocationDictionaryUtili"
            "tiesEntityClass}lld, arrowState:%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}";
    }

    else
    {
      if (*v20)
      {
        int v23 = *v20 - 1;
        goto LABEL_29;
      }

      if (qword_101934980 != -1)
      {
        dispatch_once(&qword_101934980, &stru_1018401A0);
        uint64_t v22 = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
      }

      double v29 = (os_log_s *)v22[305];
      if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
      {
        uint64_t v37 = 68289538LL;
        *(_WORD *)__int128 v38 = 2082;
        *(void *)&v38[2] = "";
        *(_WORD *)&v38[10] = 2050;
        *(void *)&_BYTE v38[12] = a2;
        *(_WORD *)&v38[20] = 2050;
        *(void *)&v38[22] = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#sbim Count underflow!, entityClass:%{public, location:CLLocationDictionaryUtilit iesEntityClass}lld, arrowState:%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}",  (uint8_t *)&v37,  0x26u);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      uint64_t v25 = (os_log_s *)qword_101934988;
      BOOL v30 = os_signpost_enabled((os_log_t)qword_101934988);
      uint64_t v22 = &OBJC_METACLASS___CLPrivacyManager.vtable;
      p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
      if (!v30) {
        goto LABEL_45;
      }
      uint64_t v37 = 68289538LL;
      *(_WORD *)__int128 v38 = 2082;
      *(void *)&v38[2] = "";
      *(_WORD *)&v38[10] = 2050;
      *(void *)&_BYTE v38[12] = a2;
      *(_WORD *)&v38[20] = 2050;
      *(void *)&v38[22] = a3;
      __int128 v27 = "#sbim Count underflow!";
      double v28 = "{msg%{public}.0s:#sbim Count underflow!, entityClass:%{public, location:CLLocationDictionaryUtil"
            "itiesEntityClass}lld, arrowState:%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}";
    }

    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v25,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v27,  v28,  (uint8_t *)&v37,  0x26u);
    uint64_t v22 = &OBJC_METACLASS___CLPrivacyManager.vtable;
LABEL_45:
    uint64_t v31 = 0LL;
    uint64_t v32 = 0LL;
    do
    {
      if (*(_DWORD *)(a1 + 12LL * v19 + 1304 + 4 * v31)) {
        uint64_t v32 = v31;
      }
      ++v31;
    }

    while (v31 != 3);
    if (p_vtable[304] != (void *)-1LL)
    {
      dispatch_once(&qword_101934980, &stru_1018401A0);
      uint64_t v22 = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
    }

    uint64_t v33 = (os_log_s *)v22[305];
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
    {
      int v34 = *v20;
      if (a4 == 1) {
        int v35 = 1;
      }
      else {
        int v35 = -1;
      }
      uint64_t v37 = 68290562LL;
      *(_WORD *)__int128 v38 = 2082;
      *(void *)&v38[2] = "";
      *(_WORD *)&v38[10] = 2050;
      *(void *)&_BYTE v38[12] = a2;
      *(_WORD *)&v38[20] = 1026;
      *(_DWORD *)&v38[22] = v35;
      *(_WORD *)&v38[26] = 2050;
      *(void *)&v38[28] = a3;
      *(_WORD *)&v38[36] = 1026;
      *(_DWORD *)&v38[38] = v34;
      *(_WORD *)uint64_t v39 = 2050;
      *(void *)&v39[2] = v18;
      __int16 v40 = 2050;
      uint64_t v41 = v32;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#sbim entity class count updated, entityClass:%{public, location:CLLocationDictiona ryUtilitiesEntityClass}lld, change:%{public}d, arrowStateBeingChanged:%{public, location:CLLocationDicti onaryUtilitiesArrowState}lld, newCount:%{public}u, oldArrowState:%{public, location:CLLocationDictionary UtilitiesArrowState}lld, newArrowState:%{public, location:CLLocationDictionaryUtilitiesArrowState}lld}",  (uint8_t *)&v37,  0x46u);
    }

    if (v18 != v32)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int16 v36 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v37 = 68290050LL;
        *(_WORD *)__int128 v38 = 2082;
        *(void *)&v38[2] = "";
        *(_WORD *)&v38[10] = 2050;
        *(void *)&_BYTE v38[12] = a2;
        *(_WORD *)&v38[20] = 2050;
        *(void *)&v38[22] = v18;
        *(_WORD *)&v38[30] = 2050;
        *(void *)&v38[32] = v32;
        *(_WORD *)&v38[40] = 1026;
        *(_DWORD *)uint64_t v39 = a5 == 1;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#sbim entity class arrow state changed, entityClass:%{public, location:CLLocation DictionaryUtilitiesEntityClass}lld, oldArrowState:%{public, location:CLLocationDictionaryUtilitiesArrowSta te}lld, newArrowState:%{public, location:CLLocationDictionaryUtilitiesArrowState}lld, dueToDeauthorizati on:%{public}hhd}",  (uint8_t *)&v37,  0x36u);
      }

      objc_msgSend( *(id *)(a1 + 1416),  "entityClass:didChangeArrowState:dueToDeauthorization:",  a2,  v32,  a5 == 1,  v37,  *(_OWORD *)v38,  *(_OWORD *)&v38[16]);
    }

    return;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v12 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
  {
    uint64_t v37 = 68289282LL;
    *(_WORD *)__int128 v38 = 2082;
    *(void *)&v38[2] = "";
    *(_WORD *)&v38[10] = 2050;
    *(void *)&_BYTE v38[12] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#sbim Out of bounds access -- arrow state too large, arrowState:%{public}lu}",  (uint8_t *)&v37,  0x1Cu);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
  }

  uint64_t v13 = qword_101934988;
  if (os_signpost_enabled((os_log_t)qword_101934988))
  {
    uint64_t v37 = 68289282LL;
    *(_WORD *)__int128 v38 = 2082;
    *(void *)&v38[2] = "";
    *(_WORD *)&v38[10] = 2050;
    *(void *)&_BYTE v38[12] = a3;
    BOOL v8 = "#sbim Out of bounds access -- arrow state too large";
    BOOL v9 = "{msg%{public}.0s:#sbim Out of bounds access -- arrow state too large, arrowState:%{public}lu}";
    uint64_t v10 = (os_log_s *)v13;
    goto LABEL_17;
  }

BOOL sub_100559A98(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 872);
  if (v3)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *((char *)a2 + 23) >= 0 ? (uint64_t)a2 : *a2;
      CLConnection::getName(*(CLConnection **)(a1 + 872));
      uint64_t v7 = v35 >= 0 ? __p : *(_BYTE **)__p;
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = v6;
      __int16 v27 = 2082;
      double v28 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Sending kCLConnectionMessageWakeClient for %{public}s to client '%{public}s'",  buf,  0x16u);
      if (v35 < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v16 = qword_101934988;
      else {
        uint64_t v17 = (uint64_t *)*a2;
      }
      CLConnection::getName(*(CLConnection **)(a1 + 872));
      if (v29 >= 0) {
        uint64_t v18 = buf;
      }
      else {
        uint64_t v18 = *(_BYTE **)buf;
      }
      int v30 = 136446466;
      uint64_t v31 = v17;
      __int16 v32 = 2082;
      uint64_t v33 = v18;
      unsigned int v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v16,  0LL,  "Sending kCLConnectionMessageWakeClient for %{public}s to client '%{public}s'",  &v30,  22);
      if (v29 < 0) {
        operator delete(*(void **)buf);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::wakeupLaunchdManagedClient(const std::string &)",  "%s\n",  v19);
      if (v19 != __p) {
        free(v19);
      }
    }

    uint64_t v24 = @"kCLConnectionMessageClientNameKey";
    else {
      BOOL v8 = (uint64_t *)*a2;
    }
    uint64_t v25 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v8);
    *(void *)__int128 __p = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v25,  &v24,  1LL);
    uint64_t v9 = *(void *)(a1 + 872);
    sub_1005894D0("kCLConnectionMessageWakeClient", __p, &v22);
    CLConnection::sendMessage(v9, &v22);
    uint64_t v10 = v23;
    if (v23)
    {
      p_shared_owners = (unint64_t *)&v23->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(p_shared_owners);
      while (__stlxr(v12 - 1, p_shared_owners));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v13 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      else {
        unsigned int v14 = (uint64_t *)*a2;
      }
      *(_DWORD *)__int128 __p = 136315138;
      *(void *)&__p[4] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "#Warning Can't find /usr/libexec/UserEventAgent connection for waking Client: <%s>",  __p,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      else {
        __int16 v20 = (uint64_t *)*a2;
      }
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = v20;
      unint64_t v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#Warning Can't find /usr/libexec/UserEventAgent connection for waking Client: <%s>",  buf);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::wakeupLaunchdManagedClient(const std::string &)",  "%s\n",  v21);
      if (v21 != __p) {
        free(v21);
      }
    }
  }

  return v3 != 0;
}

void sub_100559F0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

id sub_100559F28(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 40) newTimer];
  *(void *)(a1 + 144) = v2;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_100559FA4;
  v4[3] = &unk_10181D3D0;
  v4[4] = a1;
  [v2 setHandler:v4];
  return [*(id *)(a1 + 144) setNextFireDelay:600.0];
}

id sub_100559FA4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  [*(id *)(v1 + 136) persist];
  return [*(id *)(v1 + 144) setNextFireDelay:600.0];
}

void *sub_100559FD4@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

uint64_t sub_10055A04C()
{
  return 1LL;
}

uint64_t sub_10055A054()
{
  return 1LL;
}

id sub_10055A05C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NSNumber);
  uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSString);
  return +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v4,  v5,  v6,  objc_opt_class(&OBJC_CLASS___NSArray),  0LL),  a1,  a2);
}

NSData *sub_10055A100(uint64_t a1)
{
  id v2 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  [v2 setObject:&off_1018D3530 forKeyedSubscript:@"version"];
  id v3 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  uint64_t v4 = *(void **)(a1 + 136);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  _OWORD v9[2] = sub_10055A360;
  v9[3] = &unk_10183F9D0;
  v9[4] = v3;
  void v9[5] = a1;
  [v4 iterateAllAnchorKeyPathsWithBlock:v9];
  [v2 setObject:v3 forKeyedSubscript:@"clients"];
  objc_msgSend( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_100295844() == 1),  @"global");
  uint64_t v8 = 0LL;
  BOOL result = +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v2,  1LL,  &v8);
  if (v8)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:failed to archive authorization decisions, error:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v7 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = v8;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "failed to archive authorization decisions",  "{msg%{public}.0s:failed to archive authorization decisions, error:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    return 0LL;
  }

  return result;
}

void sub_10055A360(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (a2)
  {
    [a2 clientName];
  }

  else
  {
    uint64_t v19 = 0LL;
    *(_OWORD *)__int128 __p = 0u;
    __int128 v18 = 0u;
    __int128 v15 = 0u;
    *(_OWORD *)uint64_t v16 = 0u;
    __int128 v13 = 0u;
    *(_OWORD *)__int16 v14 = 0u;
    *(_OWORD *)int v11 = 0u;
    *(_OWORD *)__int16 v12 = 0u;
    *(_OWORD *)uint64_t v9 = 0u;
    __int128 v10 = 0u;
    *(_OWORD *)uint64_t v8 = 0u;
  }

  id v5 = objc_msgSend(a2, "legacyClientKey", v8[0], v8[1], v9[0]);
  sub_100FE370C((uint64_t)v8);
  if (v15 >= 0) {
    uint64_t v6 = &v14[1];
  }
  else {
    uint64_t v6 = (void **)v14[1];
  }
  if (-[NSString hasPrefix:]( +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v6),  "hasPrefix:",  @"com.apple."))
  {
    goto LABEL_11;
  }

  uint64_t v7 = (void *)HIBYTE(v12[0]);
  if (SHIBYTE(v12[0]) < 0) {
    uint64_t v7 = v11[1];
  }
  if (v7) {
LABEL_11:
  }
    objc_msgSend( *(id *)(a1 + 32),  "setObject:forKeyedSubscript:",  objc_msgSend(objc_msgSend(*(id *)(v4 + 136), "readonlyStoreAtKeyPath:", a2), "dictionary"),  v5);
  if (SHIBYTE(v18) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v16[0]);
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(v14[1]);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[1]);
  }
  if (SHIBYTE(v12[0]) < 0) {
    operator delete(v11[0]);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[1]);
  }
  if (SHIBYTE(v9[0]) < 0) {
    operator delete(v8[0]);
  }
}

void sub_10055A4CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

NSError *sub_10055A4E0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = sub_1002F8DDC();
  uint64_t v6 = (const char *)objc_msgSend(objc_msgSend(a3, "UUIDString"), "UTF8String");
  size_t v7 = strlen(v6);
  size_t v8 = v7;
  unsigned __int8 size = __s1.__r_.__value_.__s.__size_;
  if (((char)__s1.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    if (v7 != __s1.__r_.__value_.__s.__size_) {
      goto LABEL_10;
    }
    if (v7 != -1LL)
    {
      p_s1 = &__s1;
      goto LABEL_9;
    }

void sub_10055A748( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_10055A77C(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, void (**a5)(void, void))
{
  id v9 = sub_10053D6E0(a1, a3);
  __int128 v10 = a4[7];
  __int128 v62 = a4[6];
  __int128 v63 = v10;
  v64[0] = a4[8];
  *(_OWORD *)((char *)v64 + 12) = *(_OWORD *)((char *)a4 + 140);
  __int128 v11 = a4[3];
  *(_OWORD *)&uint8_t buf[32] = a4[2];
  __int128 v59 = v11;
  __int128 v12 = a4[5];
  __int128 v60 = a4[4];
  __int128 v61 = v12;
  __int128 v13 = a4[1];
  *(_OWORD *)__int128 buf = *a4;
  *(_OWORD *)&uint8_t buf[16] = v13;
  __int16 v14 = sub_100544790(a1, (uint64_t)v9, buf);
  if (!-[CLClientManagerAuthorizationContext isAuthorizedForServiceType:](v14, "isAuthorizedForServiceType:", a2))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int128 v15 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2114;
      *(void *)&buf[20] = v9;
      *(_WORD *)&_BYTE buf[28] = 2114;
      *(void *)&buf[30] = v14;
      *(_WORD *)&_BYTE buf[38] = 2050;
      *(void *)&uint8_t buf[40] = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#provisional intermediation Client not authorized for serviceType, Client:%{public, location:escape_only}@, AuthContext:%{public, location:escape_only}@, serviceType:%{public}lu}",  buf,  0x30u);
    }

void sub_10055AF74( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10055AF98(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  id v6 = sub_10053D6E0(a1, a2);
  size_t v7 = (dispatch_source_s *)[*(id *)(a1 + 392) objectForKeyedSubscript:v6];
  if (qword_101996E30 != -1) {
    dispatch_once(&qword_101996E30, &stru_101840240);
  }
  size_t v8 = (os_log_s *)qword_101996E28;
  if (os_log_type_enabled((os_log_t)qword_101996E28, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)uint64_t v16 = v6;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Delivered location information to '%@'", buf, 0xCu);
  }

  id v9 = v7;
  if (!v7)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    sub_10056CADC(a1, (uint64_t)v6, 10LL, 1, 0, 0, Current);
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101840220);
    }
    __int128 v11 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)uint64_t v16 = 0;
      *(_WORD *)&_OWORD v16[4] = 2082;
      *(void *)&v16[6] = "";
      __int16 v17 = 2114;
      id v18 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:started receiving location information, client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    id v9 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0,  0,  (dispatch_queue_t)[*(id *)(a1 + 40) queue]);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472LL;
    _OWORD v14[2] = sub_10055B218;
    v14[3] = &unk_10181FA90;
    v14[4] = v6;
    v14[5] = a1;
    dispatch_source_set_event_handler(v9, v14);
    [*(id *)(a1 + 392) setObject:v9 forKeyedSubscript:v6];
  }

  dispatch_time_t v12 = dispatch_time(0LL, 10000000000LL);
  dispatch_source_set_timer(v9, v12, 0xFFFFFFFFFFFFFFFFLL, 0xBEBC200uLL);
  if (!v7)
  {
    dispatch_resume(v9);
    if ((a4 & 1) != 0) {
      return v7 == 0LL;
    }
    goto LABEL_13;
  }

  if ((a4 & 1) == 0) {
LABEL_13:
  }
    sub_10054FF68(a1, (uint64_t)v6, -1LL, 0, 0.0);
  return v7 == 0LL;
}

uint64_t sub_10055B218(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_101840220);
  }
  id v3 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_INFO))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    v8[0] = 68289282;
    v8[1] = 0;
    __int16 v9 = 2082;
    __int128 v10 = "";
    __int16 v11 = 2114;
    uint64_t v12 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:stopped receiving location information, client:%{public, location:escape_only}@}",  (uint8_t *)v8,  0x1Cu);
  }

  dispatch_source_cancel((dispatch_source_t)[*(id *)(v2 + 392) objectForKeyedSubscript:*(void *)(a1 + 32)]);
  [*(id *)(v2 + 392) removeObjectForKey:*(void *)(a1 + 32)];
  uint64_t v5 = *(void *)(a1 + 32);
  double Current = CFAbsoluteTimeGetCurrent();
  return sub_10056CADC(v2, v5, 10LL, 0, 0, 0, Current);
}

void sub_10055B34C(uint64_t a1, char a2)
{
  uint64_t v2 = *(int **)(a1 + 272);
  if (!v2)
  {
LABEL_5:
    sub_10055BB48(a1, a2);
    return;
  }

  int v3 = *v2;
  if (v3 != 15)
  {
    if (v3 == 10)
    {
      sub_10055B374(a1, a2);
      return;
    }

    goto LABEL_5;
  }

  sub_10055B640((void *)a1, a2);
}

void sub_10055B374(uint64_t a1, char a2)
{
  id v4 = sub_10053D6E0(a1, *(void *)(*(void *)(a1 + 272) + 8LL));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v5 = (os_log_s *)qword_101934988;
  BOOL v6 = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    *(_DWORD *)__int128 buf = 68289538;
    *(_DWORD *)uint64_t v16 = 0;
    *(_WORD *)&_OWORD v16[4] = 2082;
    *(void *)&v16[6] = "";
    *(_WORD *)&_BYTE v16[14] = 2114;
    *(void *)&v16[16] = v4;
    __int16 v17 = 1026;
    int v18 = a2 & 3;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt User responded on BigSwitch prompt, Client:%{public, location:escape_only }@, response:%{public}d}",  buf,  0x22u);
  }

  size_t v7 = (unsigned int **)(a1 + 272);
  uint64_t v8 = a2 & 3;
  if (!v8 || v8 == 2) {
    goto LABEL_9;
  }
  if (v8 == 1)
  {
    sub_10057EA1C(v6, "prefs:root=Privacy&path=LOCATION");
LABEL_9:
    sub_10054BF20(a1, (uint64_t)v4);
    goto LABEL_15;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  __int16 v9 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138543618;
    *(void *)uint64_t v16 = v4;
    *(_WORD *)&v16[8] = 2050;
    *(void *)&v16[10] = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#warning no user response to client %{public}@ (flags 0x%{public}lx)",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v11 = 138543618;
    id v12 = v4;
    __int16 v13 = 2050;
    uint64_t v14 = v8;
    __int128 v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#warning no user response to client %{public}@ (flags 0x%{public}lx)",  &v11,  22);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::onClientPrefsNotification(CFOptionFlags)", "%s\n", v10);
  }

void sub_10055B640(void *a1, char a2)
{
  id v4 = sub_10053D6E0((uint64_t)a1, *(void *)(a1[34] + 8LL));
  uint64_t v5 = *(const void **)(a1[34] + 48LL);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  BOOL v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v35 = 2082;
    uint64_t v36 = "";
    __int16 v37 = 2114;
    id v38 = v4;
    __int16 v39 = 1026;
    int v40 = a2 & 3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt User responded on ImproveAccuracyPrefs prompt, Client:%{public, location: escape_only}@, response:%{public}d}",  buf,  0x22u);
  }

  uint64_t v7 = a1[121];
  uint64_t v8 = a1[122];
  if (v7 != v8)
  {
    __int16 v9 = (unsigned int **)(a1 + 34);
    while (1)
    {
      __int128 v10 = *(const void **)(v7 + 24);
      if (v10)
      {
        uint64_t v11 = CFEqual(v10, v5);
        uint64_t v8 = a1[122];
        if ((_DWORD)v11) {
          break;
        }
      }

      v7 += 32LL;
      if (v7 == v8) {
        goto LABEL_10;
      }
    }

    if (v7 != v8)
    {
      uint64_t v14 = a2 & 3;
      if (!v14 || v14 == 2) {
        goto LABEL_54;
      }
      if (v14 != 1)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v16 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v17 = "Unknown";
          if (*(void *)v7 == 1LL) {
            __int16 v17 = "Bluetooth";
          }
          if (*(void *)v7) {
            int v18 = (char *)v17;
          }
          else {
            int v18 = "Wifi";
          }
          sub_1010DDBC0(buf, v18);
          if (SBYTE3(v38) >= 0) {
            uint64_t v19 = buf;
          }
          else {
            uint64_t v19 = *(uint8_t **)buf;
          }
          *(_DWORD *)int v26 = 136446466;
          *(void *)&v26[4] = v19;
          __int16 v27 = 2050;
          uint64_t v28 = v14;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#warning no user response for improve accuracy prefs notification %{public}s (flags 0x%{public}lx)",  v26,  0x16u);
          if (SBYTE3(v38) < 0) {
            operator delete(*(void **)buf);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          uint64_t v20 = qword_101934988;
          uint64_t v21 = "Unknown";
          if (*(void *)v7 == 1LL) {
            uint64_t v21 = "Bluetooth";
          }
          if (*(void *)v7) {
            uint64_t v22 = (char *)v21;
          }
          else {
            uint64_t v22 = "Wifi";
          }
          sub_1010DDBC0(v26, v22);
          if (v29 >= 0) {
            id v23 = v26;
          }
          else {
            id v23 = *(_BYTE **)v26;
          }
          int v30 = 136446466;
          uint64_t v31 = v23;
          __int16 v32 = 2050;
          uint64_t v33 = v14;
          uint64_t v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  0LL,  "#warning no user response for improve accuracy prefs notification %{public}s (flags 0x%{public}lx)",  &v30,  22);
          if (v29 < 0) {
            operator delete(*(void **)v26);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::onImproveAccuracyPrefsNotification(CFOptionFlags)",  "%s\n",  v24);
        }

        goto LABEL_55;
      }

      if (*(void *)v7)
      {
        if (*(void *)v7 != 1LL)
        {
LABEL_54:
          double Current = CFAbsoluteTimeGetCurrent();
          sub_1005759B8((double *)v7, Current);
LABEL_55:
          sub_100575938(v7);
          sub_10057E760(*v9);
          sub_10057D1B4((uint64_t *)v9, 0LL);
          return;
        }

        __int128 v15 = "prefs:root=Bluetooth";
      }

      else
      {
        __int128 v15 = "prefs:root=WIFI";
      }

      sub_10057EA1C(v11, v15);
      goto LABEL_54;
    }
  }

void sub_10055BB48(uint64_t a1, char a2)
{
  id v4 = (unsigned int **)(a1 + 272);
  uint64_t v5 = sub_10053D6E0(a1, *(void *)(*(void *)(a1 + 272) + 8LL));
  if ([v5 isValidCKP])
  {
LABEL_6:
    uint64_t v8 = **v4;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    goto LABEL_9;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  BOOL v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *((void *)*v4 + 1);
    *(_DWORD *)__int128 buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)uint64_t v91 = 2082;
    *(void *)&v91[2] = "";
    *(_WORD *)&v91[10] = 2114;
    *(void *)&v91[12] = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning onClientUserNotification fInflightPromptAuthorizationRequest failed to evaluate to a real, registered client, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    goto LABEL_6;
  }

  uint64_t v8 = **v4;
LABEL_9:
  __int16 v9 = (os_log_s *)qword_101934988;
  int v10 = a2 & 3;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)uint64_t v91 = 2082;
    *(void *)&v91[2] = "";
    *(_WORD *)&v91[10] = 2114;
    *(void *)&v91[12] = v5;
    *(_WORD *)&v91[20] = 1026;
    *(_DWORD *)&v91[22] = v8;
    *(_WORD *)&v91[26] = 1026;
    *(_DWORD *)&v91[28] = a2 & 3;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt User responded to prompt for client, client:%{public, location:escape_onl y}@, requestType:%{public}d, response:%{public}d}",  buf,  0x28u);
  }

  if (v10 == 3)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v11 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v91 = 2082;
      *(void *)&v91[2] = "";
      *(_WORD *)&v91[10] = 2114;
      *(void *)&v91[12] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt User dismissed prompt for client, client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    v94[0] = @"ClientKey";
    v95[0] = [v5 userlessClientKeyPath];
    v94[1] = @"RequestType";
    v95[1] = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v8);
    v94[2] = @"Dismissed";
    v95[2] = &__kCFBooleanTrue;
    AnalyticsSendEvent( @"com.apple.locationd.client.prompt.response",  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v95,  v94,  3LL));
    sub_10055E8F4(*v4, (uint64_t)@"The user dismissed the prompt");
    sub_10057D1B4((uint64_t *)v4, 0LL);
    return;
  }

  int v12 = *((unsigned __int8 *)*v4 + 4);
  int v13 = _os_feature_enabled_impl("CoreLocation", "CLNotThisTime");
  uint64_t v14 = *v4;
  if (*((char *)*v4 + 39) < 0)
  {
    sub_1010DD48C(__p, *((void **)v14 + 2), *((void *)v14 + 3));
  }

  else
  {
    *(_OWORD *)__int128 __p = *((_OWORD *)v14 + 1);
    uint64_t v85 = *((void *)v14 + 4);
  }

  switch((int)v8)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 11:
      if (v12)
      {
        if ((a2 & 3) != 0)
        {
          if (v10 != 1) {
            goto LABEL_35;
          }
          goto LABEL_39;
        }

void sub_10055DAEC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, char a42)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10055DB84(uint64_t a1, uint64_t a2)
{
  id v3 = sub_1005486B8(a1, a2);
  sub_100564EF4(a1, v3, 1);
}

CFStringRef sub_10055DBB0(uint64_t a1, void *a2, void *a3)
{
  int v6 = sub_1001B9A1C();
  if (!a3 || !v6) {
    goto LABEL_5;
  }
  sub_1010DDBC0(&__p, (char *)[a3 UTF8String]);
  BOOL v7 = sub_100D96020((uint64_t **)&__p);
  BOOL v8 = v7;
  if (SBYTE3(v28) < 0)
  {
    operator delete(__p);
    if (!v8) {
      goto LABEL_8;
    }
LABEL_5:
    id v9 = [*(id *)(a1 + 136) stringForKey:@"PlatformSpecificBundleId" atKeyPath:a2 defaultValue:0];
    if (!v9) {
      id v9 = [a2 bundleId];
    }
LABEL_11:
    id v13 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
    uint64_t v14 = sub_10059CEEC();
    uint64_t v15 = (void *)sub_10059E244(v14);
    if (v15) {
      [v13 addObject:v15];
    }
    if (v9)
    {
      uint64_t v23 = 0LL;
      id v16 =  [[LSApplicationRecord alloc] initWithBundleIdentifier:v9 allowPlaceholder:0 error:&v23];
      if (v23)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v17 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
        {
          id v18 = [v9 UTF8String];
          __int128 __p = (void *)68289538;
          __int16 v25 = 2082;
          id v26 = "";
          __int16 v27 = 2082;
          id v28 = v18;
          __int16 v29 = 2114;
          uint64_t v30 = v23;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Could not get LSApplicationRecord from cfDisplayIdentifier, cfDisplayIdentifier :%{public, location:escape_only}s, error:%{public, location:escape_only}@}",  (uint8_t *)&__p,  0x26u);
        }
      }

      if (v16)
      {
        char v19 = (const __CFString *)[v16 localizedNameWithPreferredLocalizations:v13];
        int v12 = v19;
        if (v19)
        {
          CFRetain(v19);
LABEL_26:

          return v12;
        }
      }

      uint64_t v20 = (__CFString *)sub_100D95B24(v9);
      uint64_t v21 = sub_10057BC70(v20);
    }

    else
    {
      if (![a2 bundlePath])
      {
        int v12 = 0LL;
        goto LABEL_26;
      }

      uint64_t v21 = sub_10057BC70((__CFString *)[a2 bundlePath]);
    }

    int v12 = v21;
    goto LABEL_26;
  }

  if (v7) {
    goto LABEL_5;
  }
LABEL_8:
  int v10 = sub_100D95B88(a3);
  if (!v10)
  {
    id v9 = 0LL;
    goto LABEL_11;
  }

  uint64_t v11 = sub_10059CEEC();
  int v12 = sub_10059D310(v11, v10, _kCFBundleDisplayNameKey, 0);
  CFRelease(v10);
  return v12;
}

void sub_10055DE3C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CFString *sub_10055DE60(uint64_t a1, uint64_t a2)
{
  id v3 = sub_10053D6E0(a1, a2);
  CFErrorRef errorPtr = 0LL;
  id v4 = (__CFBundle *)sub_10055E270(a1, (uint64_t)v3);
  if (!v4)
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101840220);
    }
    uint64_t v5 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v20 = 0;
      __int16 v21 = 2082;
      char v22 = "";
      __int16 v23 = 2114;
      id v24 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:copyCombinedClientPurpose couldn't get bundle for client, ClientKeyPath:%{public, l ocation:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_101840220);
      }
    }

    int v6 = (os_log_s *)qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v20 = 0;
      __int16 v21 = 2082;
      char v22 = "";
      __int16 v23 = 2114;
      id v24 = v3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "copyCombinedClientPurpose couldn't get bundle for client",  "{msg%{public}.0s:copyCombinedClientPurpose couldn't get bundle for client, ClientKeyPath:%{public, l ocation:escape_only}@}",  buf,  0x1Cu);
    }
  }

  BOOL v7 = sub_10055E324(a1, v3, v4, 0, 1, 0LL);
  if (v7)
  {
    BOOL v8 = v7;
    goto LABEL_11;
  }

  BOOL v8 = sub_10055E324(a1, v3, v4, 0, 0, 0LL);
  if (!v8)
  {
LABEL_11:
    id v9 = 0LL;
    if (!v4) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  uint64_t v15 = sub_10055E324(a1, v3, v4, 1u, 0, 0LL);
  uint64_t v16 = sub_10059CEEC();
  if (v15)
  {
    id v9 = (const __CFString *)sub_10059E10C(v16, @"LOCATION_CLIENT_PERMISSION_MESSAGE");
    CFStringRef v17 = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0LL, @"%@ %@", v9, &errorPtr, v8, v15);
  }

  else
  {
    id v9 = (const __CFString *)sub_10059E10C(v16, @"LOCATION_CLIENT_PERMISSION_MESSAGE_REDUCED");
    CFStringRef v17 = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0LL, @"%@", v9, &errorPtr, v8);
  }

  BOOL v8 = (__CFString *)v17;
  if (v4) {
LABEL_12:
  }
    CFRelease(v4);
LABEL_13:
  if (v9) {
    CFRelease(v9);
  }
  if (errorPtr)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      id v11 = objc_msgSend(-[__CFError localizedDescription](errorPtr, "localizedDescription"), "UTF8String");
      *(_DWORD *)__int128 buf = 68289538;
      int v20 = 0;
      __int16 v21 = 2082;
      char v22 = "";
      __int16 v23 = 2114;
      id v24 = v3;
      __int16 v25 = 2082;
      id v26 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#Error, couldn't copyCombinedClientPurpose for client due to error returned by CFStringCr eateStringWithValidatedFormat., client:%{public, location:escape_only}@, error:%{public, location:escape_only}s}",  buf,  0x26u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    int v12 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      id v13 = objc_msgSend(-[__CFError localizedDescription](errorPtr, "localizedDescription"), "UTF8String");
      *(_DWORD *)__int128 buf = 68289538;
      int v20 = 0;
      __int16 v21 = 2082;
      char v22 = "";
      __int16 v23 = 2114;
      id v24 = v3;
      __int16 v25 = 2082;
      id v26 = v13;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Error, couldn't copyCombinedClientPurpose for client due to error returned by CFStringCreateStringWithValidatedFormat.",  "{msg%{public}.0s:#Error, couldn't copyCombinedClientPurpose for client due to error returned by CFStringCr eateStringWithValidatedFormat., client:%{public, location:escape_only}@, error:%{public, location:escape_only}s}",  buf,  0x26u);
    }
  }

  return v8;
}

id sub_10055E270(uint64_t a1, uint64_t a2)
{
  id result = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if (result) {
    return (id)sub_100D96750( [*(id *)(a1 + 136) stringForKey:@"PlatformSpecificBundleId" atKeyPath:result defaultValue:0],  objc_msgSend(*(id *)(a1 + 136), "stringForKey:atKeyPath:defaultValue:", @"BundleId", result, 0),  (const __CFString *)objc_msgSend( *(id *)(a1 + 136),  "stringForKey:atKeyPath:defaultValue:",  @"BundlePath",  result,  0),  0);
  }
  return result;
}

__CFString *sub_10055E324(uint64_t a1, void *a2, __CFBundle *a3, unsigned int a4, int a5, __CFString *a6)
{
  if (!a3) {
    return 0LL;
  }
  if (a4 >= 2)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138543618;
      id v34 = a2;
      __int16 v35 = 1026;
      LODWORD(v36) = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Requesting client (%{public}@) purpose for unsupported registration type %{public}d",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v29 = 138543618;
      id v30 = a2;
      __int16 v31 = 1026;
      LODWORD(v32) = a4;
      id v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "Requesting client (%{public}@) purpose for unsupported registration type %{public}d",  &v29,  18);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CFStringRef CLClientManager::copyClientPurposeForRegistrationResult(CLClientKeyPath *, CFBundleRef, CLClientRegi strationResult, BOOL, CFStringRef)",  "%s\n",  v24);
    }

    return 0LL;
  }

  if (a5)
  {
    uint64_t v12 = sub_10059CEEC();
    id v13 = &off_10182E1D0;
LABEL_11:
    uint64_t v14 = sub_10059D310(v12, a3, *v13, 0);
    goto LABEL_15;
  }

  if (!a4)
  {
    uint64_t v23 = sub_10059CEEC();
    id v9 = (__CFString *)sub_10059D310(v23, a3, @"NSLocationAlwaysUsageDescription", 0);
    if (v9) {
      goto LABEL_16;
    }
    uint64_t v12 = sub_10059CEEC();
    id v13 = &off_10182E1B8;
    goto LABEL_11;
  }

  id v16 = -[__CFString length](a6, "length");
  uint64_t v12 = sub_10059CEEC();
  if (!v16)
  {
    id v13 = &off_10182E1C8;
    goto LABEL_11;
  }

  uint64_t v14 = sub_10059DB74(v12, a3, @"NSLocationAuthorizationPurposeDescriptionDictionary", a6, 0);
LABEL_15:
  id v9 = (__CFString *)v14;
  if (v14)
  {
LABEL_16:
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    CFStringRef v17 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412546;
      id v34 = a2;
      __int16 v35 = 2080;
      id v36 = -[__CFString UTF8String](v9, "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "purpose string from %@'s bundle: '%s'",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v25 = qword_101934988;
      int v29 = 138412546;
      id v30 = a2;
      __int16 v31 = 2080;
      id v32 = -[__CFString UTF8String](v9, "UTF8String");
      id v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v25,  2LL,  "purpose string from %@'s bundle: '%s'",  &v29,  22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CFStringRef CLClientManager::copyClientPurposeForRegistrationResult(CLClientKeyPath *, CFBundleRef, CLClientRegi strationResult, BOOL, CFStringRef)",  "%s\n",  v26);
    }

    return v9;
  }

  id v19 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  id v20 = [*(id *)(a1 + 136) stringForKey:@"Purpose" atKeyPath:v19 defaultValue:0];
  id v9 = 0LL;
  if (a4 != 1)
  {
    __int16 v21 = v20;
    if (v20)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      char v22 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 138412546;
        id v34 = v19;
        __int16 v35 = 2080;
        id v36 = [v21 UTF8String];
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "purpose string from %@'s property: '%s'",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v27 = qword_101934988;
        int v29 = 138412546;
        id v30 = v19;
        __int16 v31 = 2080;
        id v32 = [v21 UTF8String];
        id v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v27,  2LL,  "purpose string from %@'s property: '%s'",  &v29,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CFStringRef CLClientManager::copyClientPurposeForRegistrationResult(CLClientKeyPath *, CFBundleRef, CLClientRe gistrationResult, BOOL, CFStringRef)",  "%s\n",  v28);
      }

      CFRetain(v21);
      return (__CFString *)v21;
    }
  }

  return v9;
}

void sub_10055E8F4(unsigned int *a1, uint64_t a2)
{
  if (a2)
  {
    NSErrorUserInfoKey v4 = NSDebugDescriptionErrorKey;
    uint64_t v5 = a2;
    id v3 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v5,  &v4,  1LL);
  }

  else
  {
    id v3 = 0LL;
  }

  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kCLErrorDomain,  18LL,  v3);
  sub_10057E760(a1);
}

void sub_10055E9A8(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1005859B8;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_101996E38 != -1) {
    dispatch_once(&qword_101996E38, block);
  }
}

uint64_t sub_10055EA14(uint64_t a1, uint64_t a2, unsigned int *a3, NSDictionary *a4)
{
  uint64_t v8 = *a3;
  id v9 = sub_10086D1D8(a2, 0);
  int v10 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 96LL))(a2);
  id v11 = sub_1005467FC(a1, (uint64_t)v9);
  uint64_t v12 = (uint64_t)objc_msgSend(-[NSArray objectAtIndexedSubscript:](v11, "objectAtIndexedSubscript:", 0), "intValue");
  id v13 = objc_msgSend(-[NSArray objectAtIndexedSubscript:](v11, "objectAtIndexedSubscript:", 1), "intValue");
  int v14 = sub_100878DC4(a2);
  if ((_DWORD)v12 == 2 && (sub_100878DBC(a2) & v14 & 1) == 0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v20 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int128 v50 = 2082;
      *(void *)&v50[2] = "";
      *(_WORD *)&_BYTE v50[10] = 2114;
      *(void *)&v50[12] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt Not showing prompt because the client asked us not to, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    goto LABEL_24;
  }

  if ([*(id *)(a1 + 120) locationRestricted])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v15 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int128 v50 = 2082;
      *(void *)&v50[2] = "";
      *(_WORD *)&_BYTE v50[10] = 2114;
      *(void *)&v50[12] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt location services settings are frozen by restrictions - denying, Client :%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    sub_10055E8F4(a3, (uint64_t)@"Restrictions are enabled.  Changing authorization isn't allowed");
    uint64_t v12 = 2LL;
    return v12;
  }

  if ([*(id *)(a1 + 120) locationServicesEnabledStatus])
  {
    if (*(void *)(a1 + 272))
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v16 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        id v17 = +[CLClientKeyPath nullClientKeyPath](&OBJC_CLASS___CLClientKeyPath, "nullClientKeyPath");
        id v18 = *(unsigned int **)(a1 + 272);
        if (v18)
        {
          id v17 = (id)*((void *)v18 + 1);
          uint64_t v19 = *v18;
        }

        else
        {
          uint64_t v19 = 5LL;
        }

        *(_DWORD *)__int128 buf = 68290050;
        *(_WORD *)__int128 v50 = 2082;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(void *)&v50[2] = "";
        *(_WORD *)&_BYTE v50[10] = 2114;
        *(void *)&v50[12] = v9;
        *(_WORD *)&v50[20] = 2050;
        *(void *)&v50[22] = v8;
        *(_WORD *)&v50[30] = 2114;
        uint64_t v51 = (uint64_t)v17;
        __int16 v52 = 2050;
        uint64_t v53 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt Ignoring request because authorization in progress, Client:%{public, location:escape_only}@, requestType:%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, inflightClientKey:%{public, location:escape_only}@, inflightRequestType:%{public, location:CLClientMa nager_Type::AuthorizationRequestType}lld}",  buf,  0x3Au);
      }

      sub_10055E8F4(a3, (uint64_t)@"App is already presenting the user with an authorization prompt");
      return v12;
    }

    if (v8 <= 0xB)
    {
      if (((1 << v8) & 0xB9E) != 0)
      {
        if (sub_10088FDB0(a2))
        {
          sub_100876150(a2);
          char v22 = sub_10055FF18(&v44);
          unsigned int v23 = sub_100D95AD4(-[CLClientKeyPath bundleId](v22, "bundleId"));
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          id v24 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 68289794;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)__int128 v50 = 2082;
            *(void *)&v50[2] = "";
            *(_WORD *)&_BYTE v50[10] = 2114;
            *(void *)&v50[12] = v22;
            *(_WORD *)&v50[20] = 2114;
            *(void *)&v50[22] = v9;
            *(_WORD *)&v50[30] = 1026;
            LODWORD(v51) = v23;
            _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt check if #webClip, NaturalIdentity:%{public, location:escape_only }@, Client:%{public, location:escape_only}@, isWebClip:%{public}hhd}",  buf,  0x2Cu);
          }

          if (v23)
          {
            uint64_t v46 = @"IsWebClip";
            int v47 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL);
            a4 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL);
          }
        }

        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v25 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)__int128 v50 = 2082;
          *(void *)&v50[2] = "";
          *(_WORD *)&_BYTE v50[10] = 1026;
          *(_DWORD *)&v50[12] = v8;
          *(_WORD *)&v50[16] = 2114;
          *(void *)&v50[18] = v9;
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Showing #AuthPrompt, requestType:%{public}d, Client:%{public, location:escape_only}@}",  buf,  0x22u);
        }

        sub_1005859E4((uint64_t)v43, (uint64_t)a3);
        BOOL v26 = sub_10054878C(a1, (uint64_t)v9, v10, (uint64_t)v43, (uint64_t)a4);
        sub_1005858A0((uint64_t)v43);
        if (v26) {
          goto LABEL_77;
        }
        return v12;
      }

      if ((_DWORD)v8 == 5)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        id v38 = (os_log_s *)qword_101934988;
        if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
          return v12;
        }
        *(_DWORD *)__int128 buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)__int128 v50 = 2082;
        *(void *)&v50[2] = "";
        *(_WORD *)&_BYTE v50[10] = 2114;
        *(void *)&v50[12] = v9;
        uint64_t v39 = "{msg%{public}.0s:#AuthPrompt #Notice ERROR: Client is depending on legacy on-demand authorization, w"
              "hich is not supported for new apps, Client:%{public, location:escape_only}@}";
LABEL_92:
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v39, buf, 0x1Cu);
        return v12;
      }

      if ((_DWORD)v8 == 10)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        id v38 = (os_log_s *)qword_101934988;
        if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
          return v12;
        }
        *(_DWORD *)__int128 buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)__int128 v50 = 2082;
        *(void *)&v50[2] = "";
        *(_WORD *)&_BYTE v50[10] = 2114;
        *(void *)&v50[12] = v9;
        uint64_t v39 = "{msg%{public}.0s:#AuthPrompt Client requested a big switch prompt, but the big switch is already on"
              ", Client:%{public, location:escape_only}@}";
        goto LABEL_92;
      }
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v40 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_FAULT,  "#AuthPrompt Unrecognized/invalid request type: %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      v48[0] = 67240192;
      v48[1] = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "#AuthPrompt Unrecognized/invalid request type: %{public}d",  v48,  8);
      double v42 = (uint8_t *)v41;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLTypeRegistrationResult CLClientManager::requestClientAuthorization(CLDaemonClient *, CLClientManager_Type::Aut horizationRequest, NSDictionary *)",  "%s\n",  v41);
      if (v42 != buf) {
        free(v42);
      }
    }

    return v12;
  }

  if (sub_1004F76B8())
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v21 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int128 v50 = 2082;
      *(void *)&v50[2] = "";
      *(_WORD *)&_BYTE v50[10] = 2114;
      *(void *)&v50[12] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt Not showing big switch re-enable prompt on OSX, Client:%{public, locati on:escape_only}@}",  buf,  0x1Cu);
    }

    return 2LL;
  }

  if ((sub_100878DBC(a2) & 1) == 0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v31 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int128 v50 = 2082;
      *(void *)&v50[2] = "";
      *(_WORD *)&_BYTE v50[10] = 2114;
      *(void *)&v50[12] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt Not showing big switch re-enable prompt because the client asked us not to, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

void sub_10055F728( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
}

BOOL sub_10055F750(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7 = sub_10053D6E0(a1, a2);
  if (!&SBUserNotificationPendInSetupIfNotAllowedKey) {
    return 0LL;
  }
  id v8 = v7;
  id v9 = sub_10055DBB0(a1, v7, a3);
  if (!v9)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v18 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)BOOL v43 = 0;
      *(_WORD *)&v43[4] = 2082;
      *(void *)&v43[6] = "";
      __int16 v44 = 2114;
      id v45 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:createClientPrefsNotification: BundleDisplayName nil, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v19 = (os_log_s *)qword_101934988;
    BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
    if (!result) {
      return result;
    }
    *(_DWORD *)__int128 buf = 68289282;
    *(_DWORD *)BOOL v43 = 0;
    *(_WORD *)&v43[4] = 2082;
    *(void *)&v43[6] = "";
    __int16 v44 = 2114;
    id v45 = v8;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "createClientPrefsNotification: BundleDisplayName nil",  "{msg%{public}.0s:createClientPrefsNotification: BundleDisplayName nil, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    return 0LL;
  }

  int v10 = v9;
  CFErrorRef errorPtr = 0LL;
  uint64_t v11 = sub_10059CEEC();
  uint64_t v12 = (const __CFString *)sub_10059E10C(v11, @"LOCATION_DISABLED");
  CFStringRef v13 = CFStringCreateStringWithValidatedFormat(kCFAllocatorDefault, 0LL, @"%@", v12, &errorPtr, v10);
  if (errorPtr)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v14 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      id v15 = objc_msgSend(-[__CFError localizedDescription](errorPtr, "localizedDescription"), "UTF8String");
      *(_DWORD *)__int128 buf = 68289538;
      *(_DWORD *)BOOL v43 = 0;
      *(_WORD *)&v43[4] = 2082;
      *(void *)&v43[6] = "";
      __int16 v44 = 2114;
      id v45 = v8;
      __int16 v46 = 2082;
      id v47 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#Error, couldn't createAndPostClientPrefsNotification for client due to error returned by CFStringCreateStringWithValidatedFormat., Client:%{public, location:escape_only}@, error:%{public, lo cation:escape_only}s}",  buf,  0x26u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    id v16 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      id v17 = objc_msgSend(-[__CFError localizedDescription](errorPtr, "localizedDescription"), "UTF8String");
      *(_DWORD *)__int128 buf = 68289538;
      *(_DWORD *)BOOL v43 = 0;
      *(_WORD *)&v43[4] = 2082;
      *(void *)&v43[6] = "";
      __int16 v44 = 2114;
      id v45 = v8;
      __int16 v46 = 2082;
      id v47 = v17;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Error, couldn't createAndPostClientPrefsNotification for client due to error returned by CFStringCreateStringWi thValidatedFormat.",  "{msg%{public}.0s:#Error, couldn't createAndPostClientPrefsNotification for client due to error returned by CFStringCreateStringWithValidatedFormat., Client:%{public, location:escape_only}@, error:%{public, lo cation:escape_only}s}",  buf,  0x26u);
    }

    return 0LL;
  }

  CFStringRef v21 = v13;
  uint64_t v22 = sub_10059CEEC();
  unsigned int v23 = (void *)sub_10059E10C(v22, @"LOCATION_DISABLED_SETTINGS");
  uint64_t v24 = sub_10059CEEC();
  uint64_t v25 = (void *)sub_10059E10C(v24, @"LOCATION_DISABLED_CANCEL");
  keys[0] = (void *)SBUserNotificationPendInSetupIfNotAllowedKey;
  keys[1] = (void *)kCFUserNotificationAlertHeaderKey;
  keys[2] = (void *)kCFUserNotificationAlternateButtonTitleKey;
  keys[3] = (void *)kCFUserNotificationDefaultButtonTitleKey;
  values[0] = kCFBooleanTrue;
  values[1] = (void *)v21;
  values[2] = v23;
  values[3] = v25;
  BOOL v26 = CFDictionaryCreate( kCFAllocatorDefault,  (const void **)keys,  (const void **)values,  4LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (v12) {
    CFRelease(v12);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v23) {
    CFRelease(v23);
  }
  if (v25) {
    CFRelease(v25);
  }
  CFRelease(v10);
  uint64_t v27 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0LL, &error, v26);
  CFRelease(v26);
  if (v27)
  {
    RunLoopSource = CFUserNotificationCreateRunLoopSource( kCFAllocatorDefault,  v27,  (CFUserNotificationCallBack)sub_10057D288,  0LL);
    if (RunLoopSource)
    {
      int v29 = (__CFRunLoop *)sub_10029228C();
      CFRunLoopAddSource(v29, RunLoopSource, kCFRunLoopCommonModes);
      CFRelease(RunLoopSource);
      [*(id *)(a1 + 40) currentLatchedAbsoluteTimestamp];
      sub_10057D2F4(a4, v27, v30);
      CFRelease(v27);
      __int16 v31 = operator new(0x48uLL);
      sub_1005859E4((uint64_t)v31, a4);
      sub_10057D1B4((uint64_t *)(a1 + 272), (uint64_t)v31);
      sub_10055E9A8((uint64_t)[*(id *)(a1 + 32) vendor]);
      return 1LL;
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v35 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 138543362;
      *(void *)BOOL v43 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_FAULT,  "Could not create runloop source for client prefs notification for %{public}@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v40 = 138543362;
      id v41 = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Could not create runloop source for client prefs notification for %{public}@",  &v40,  12);
      __int16 v37 = (uint8_t *)v36;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLClientManager::createAndPostClientPrefsNotification(CLClientKeyPath *, NSString *, CLClientManager_Type:: AuthorizationRequest)",  "%s\n",  v36);
      if (v37 != buf) {
        free(v37);
      }
    }

    CFRelease(v27);
    return 0LL;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v32 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 138543362;
    *(void *)BOOL v43 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_FAULT,  "Could not create client prefs notification for %{public}@",  buf,  0xCu);
  }

  BOOL result = sub_1002921D0(115, 0);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v40 = 138543362;
    id v41 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Could not create client prefs notification for %{public}@",  &v40,  12);
    id v34 = (uint8_t *)v33;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLClientManager::createAndPostClientPrefsNotification(CLClientKeyPath *, NSString *, CLClientManager_Type::Au thorizationRequest)",  "%s\n",  v33);
    if (v34 != buf) {
      free(v34);
    }
    return 0LL;
  }

  return result;
}

void sub_10055FEFC(_Unwind_Exception *a1)
{
}

CLClientKeyPath *sub_10055FF18(audit_token_t *a1)
{
  char v8 = 0;
  sub_100F4B568(a1, &v8, (std::string *)&__p);
  if (SBYTE3(v13) >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  uint64_t v2 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p);
  if (SBYTE3(v13) < 0) {
    operator delete(__p);
  }
  if (-[NSString length](v2, "length"))
  {
    if (v8) {
      uint64_t v3 = 101LL;
    }
    else {
      uint64_t v3 = 105LL;
    }
    NSErrorUserInfoKey v4 = +[CLClientKeyPath clientKeyPathWithUserName:clientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithUserName:clientAnchor:anchorType:",  0LL,  v2,  v3);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      __int128 __p = (void *)68289282;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2114;
      CFStringRef v13 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Determined clientKeyPath from audit token, clientKeyPath:%{public, location:escape_only}@}",  (uint8_t *)&__p,  0x1Cu);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      __int128 __p = (void *)68289026;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Failed to get client info from audit token to create clientKeyPath. Returning #nullCKP}",  (uint8_t *)&__p,  0x12u);
    }

    return (CLClientKeyPath *)+[CLClientKeyPath nullClientKeyPath](&OBJC_CLASS___CLClientKeyPath, "nullClientKeyPath");
  }

  return v4;
}

void sub_100560118( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056013C(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (sub_100554584(v4, *(void **)(a1 + 32), a2))
  {
    id v5 = [a2 legacyClientKey];
    if (v5 && *(void *)(a1 + 40))
    {
      objc_msgSend(*(id *)(v4 + 1016), "setObject:forKeyedSubscript:");
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v6 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 40);
        uint64_t v7 = *(void *)(a1 + 48);
        int v12 = 68289794;
        int v13 = 0;
        __int16 v14 = 2082;
        id v15 = "";
        __int16 v16 = 2114;
        uint64_t v17 = v7;
        __int16 v18 = 2114;
        id v19 = v5;
        __int16 v20 = 2114;
        uint64_t v21 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:cacheAuthorizationContextForClient attempting to set auth context for client, but one i s nil, legacyClientKey:%{public, location:escape_only}@, authSharedlegacyClientKey:%{public, locatio n:escape_only}@, authContext:%{public, location:escape_only}@}",  (uint8_t *)&v12,  0x30u);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      id v9 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        uint64_t v11 = *(void *)(a1 + 40);
        uint64_t v10 = *(void *)(a1 + 48);
        int v12 = 68289794;
        int v13 = 0;
        __int16 v14 = 2082;
        id v15 = "";
        __int16 v16 = 2114;
        uint64_t v17 = v10;
        __int16 v18 = 2114;
        id v19 = v5;
        __int16 v20 = 2114;
        uint64_t v21 = v11;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "cacheAuthorizationContextForClient attempting to set auth context for client, but one is nil",  "{msg%{public}.0s:cacheAuthorizationContextForClient attempting to set auth context for client, but one i s nil, legacyClientKey:%{public, location:escape_only}@, authSharedlegacyClientKey:%{public, locatio n:escape_only}@, authContext:%{public, location:escape_only}@}",  (uint8_t *)&v12,  0x30u);
      }
    }
  }

NSDictionary *sub_100560360(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = sub_100295844();
  uint64_t v30 = 0LL;
  __int16 v31 = &v30;
  uint64_t v32 = 0x2020000000LL;
  char v33 = 1;
  uint64_t v26 = 0LL;
  uint64_t v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  char v29 = 1;
  uint64_t v22 = 0LL;
  unsigned int v23 = &v22;
  uint64_t v24 = 0x2020000000LL;
  char v25 = 1;
  uint64_t v18 = 0LL;
  id v19 = &v18;
  uint64_t v20 = 0x2020000000LL;
  char v21 = 1;
  uint64_t v14 = 0LL;
  id v15 = &v14;
  uint64_t v16 = 0x2020000000LL;
  char v17 = 1;
  id v3 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
  uint64_t v4 = *(void **)(v1 + 136);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _OWORD v13[2] = sub_100560778;
  void v13[3] = &unk_10183FCA8;
  _DWORD v13[4] = v3;
  v13[5] = @"Authorization";
  void v13[6] = &v30;
  void v13[7] = &v26;
  v13[8] = &v22;
  v13[9] = &v18;
  v13[10] = &v14;
  v13[11] = v1;
  [v4 iterateAllAnchorKeyPathsWithBlock:v13];
  double v5 = log2((double)(int)[*(id *)(v1 + 136) clientCount]);
  if ([v3 count])
  {
    [*(id *)(v1 + 40) currentLatchedAbsoluteTimestamp];
    id v7 = objc_msgSend(v3, "objectAtIndexedSubscript:", (int)v6 % (int)objc_msgSend(v3, "count"));
    id v8 = [*(id *)(v1 + 136) intForKey:@"Authorization" atKeyPath:v7 defaultValue:0];
    id v9 = [*(id *)(v1 + 136) intForKey:@"CorrectiveCompensationEnabled" atKeyPath:v7 defaultValue:0];
    id v10 = [*(id *)(v1 + 136) intForKey:@"IncidentalUseMode" atKeyPath:v7 defaultValue:0];
    v34[0] = @"BigSwitchEnabled";
    v35[0] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v2 == 1);
    v34[1] = @"AggLog2ClientCount";
    v35[1] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (int)v5);
    void v34[2] = @"AggNoSSDisabled";
    v35[2] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *((unsigned __int8 *)v23 + 24));
    v34[3] = @"ClientKey";
    v35[3] = +[NSString stringWithUTF8String:]( NSString,  "stringWithUTF8String:",  objc_msgSend(objc_msgSend(v7, "userlessClientKeyPath"), "UTF8String"));
    v34[4] = @"AuthMask";
    v35[4] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v8);
    v34[5] = @"AggNoIUEligible";
    v35[5] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *((unsigned __int8 *)v19 + 24));
    v34[6] = @"AggNoIUDenied";
    v35[6] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *((unsigned __int8 *)v15 + 24));
    v34[7] = @"IUMode";
    v35[7] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v10);
    v34[8] = @"AggNoAlwaysApps";
    v35[8] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *((unsigned __int8 *)v31 + 24));
    v34[9] = @"AggNoChosenCCOn";
    v35[9] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *((unsigned __int8 *)v27 + 24));
    _BYTE v34[10] = @"CCStatus";
    v35[10] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v9);
    uint64_t v11 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v35,  v34,  11LL);
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  return v11;
}

void sub_100560710( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34, uint64_t a35, uint64_t a36, uint64_t a37, char a38)
{
}

void sub_100560778(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 88);
  id v5 = [a2 legacyClientKey];
  if ([*(id *)(v4 + 136) hasValueForKey:@"SupportedAuthorizationMask" atKeyPath:a2]
    && ([*(id *)(v4 + 136) hasValueForKey:@"TimeMissing" atKeyPath:a2] & 1) == 0)
  {
    [*(id *)(a1 + 32) addObject:a2];
  }

  unsigned int v6 = [*(id *)(v4 + 136) intForKey:*(void *)(a1 + 40) atKeyPath:a2 defaultValue:0];
  unsigned int v7 = [*(id *)(v4 + 136) intForKey:@"CorrectiveCompensationEnabled" atKeyPath:a2 defaultValue:0];
  unsigned int v8 = [*(id *)(v4 + 136) intForKey:@"IncidentalUseMode" atKeyPath:a2 defaultValue:0];
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)) {
    BOOL v9 = v6 == 4;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    if (a2)
    {
      [a2 clientName];
      if (BYTE1(v20))
      {
LABEL_14:
        if (SHIBYTE(v24) < 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(__p[0]) < 0) {
          operator delete(v22[0]);
        }
        if (SHIBYTE(v21) < 0) {
          operator delete(*((void **)&v20 + 1));
        }
        if (SHIBYTE(v19) < 0) {
          operator delete(v18[1]);
        }
        if (SHIBYTE(v18[0]) < 0) {
          operator delete(v17[0]);
        }
        if (SHIBYTE(v16) < 0) {
          operator delete(v15[1]);
        }
        if (SHIBYTE(v15[0]) < 0) {
          operator delete(v14[0]);
        }
        goto LABEL_28;
      }
    }

    else
    {
      uint64_t v25 = 0LL;
      *(_OWORD *)__int128 __p = 0u;
      __int128 v24 = 0u;
      __int128 v21 = 0u;
      *(_OWORD *)uint64_t v22 = 0u;
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      *(_OWORD *)char v17 = 0u;
      *(_OWORD *)uint64_t v18 = 0u;
      *(_OWORD *)id v15 = 0u;
      __int128 v16 = 0u;
      *(_OWORD *)uint64_t v14 = 0u;
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0;
    goto LABEL_14;
  }

void sub_100560ACC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100560AE8(uint64_t a1)
{
  double v59 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CLClientManager::getInternalState");
  id v63 = objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "getStateSummary"), "cl_deepMutableCopy");
  id v2 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  id obj = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
  __int128 v72 = 0u;
  __int128 v73 = 0u;
  __int128 v74 = 0u;
  __int128 v75 = 0u;
  id v3 = *(void **)(a1 + 1016);
  id v4 = [v3 countByEnumeratingWithState:&v72 objects:v77 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v73;
    do
    {
      for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v73 != v5) {
          objc_enumerationMutation(v3);
        }
        uint64_t v7 = *(void *)(*((void *)&v72 + 1) + 8LL * (void)i);
        unsigned int v8 = +[NSNumber numberWithUnsignedLong:]( NSNumber,  "numberWithUnsignedLong:",  [*(id *)(a1 + 1016) objectForKeyedSubscript:v7]);
        objc_msgSend( v2,  "setObject:forKeyedSubscript:",  objc_msgSend(objc_msgSend(*(id *)(a1 + 1016), "objectForKeyedSubscript:", v7), "getStateSummary"),  v8);
        id v9 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  v7));
        if ([v9 isValidCKP]) {
          objc_msgSend( objc_msgSend(v63, "objectForKeyedSubscript:", objc_msgSend(v9, "clientKey")),  "setObject:forKeyedSubscript:",  v8,  @"AuthContext");
        }
      }

      id v4 = [v3 countByEnumeratingWithState:&v72 objects:v77 count:16];
    }

    while (v4);
  }

  id v62 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  BOOL v10 = *(void **)(a1 + 752);
  if (v10 != (void *)(a1 + 760))
  {
    do
    {
      uint64_t v11 = v10[5];
      BOOL v12 = +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v11);
      [v62 setObject:sub_10088FDB8(v11) forKeyedSubscript:v12];
      id v13 = objc_msgSend( objc_msgSend(v62, "objectForKeyedSubscript:", v12),  "objectForKeyedSubscript:",  @"AuthContext");
      if (v13 && ![v2 objectForKeyedSubscript:v13]) {
        [obj addObject:sub_100878564(v11)];
      }
      uint64_t v14 = (void *)v10[1];
      if (v14)
      {
        do
        {
          id v15 = v14;
          uint64_t v14 = (void *)*v14;
        }

        while (v14);
      }

      else
      {
        do
        {
          id v15 = (void *)v10[2];
          BOOL v16 = *v15 == (void)v10;
          BOOL v10 = v15;
        }

        while (!v16);
      }

      BOOL v10 = v15;
    }

    while (v15 != (void *)(a1 + 760));
  }

  id v61 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  char v17 = *(void **)(a1 + 824);
  if (v17 != (void *)(a1 + 832))
  {
    do
    {
      uint64_t v18 = v17[5];
      __int128 v19 = +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v18);
      [v61 setObject:sub_100D5575C((CLConnection **)v18) forKeyedSubscript:v19];
      id v20 = objc_msgSend( objc_msgSend(v61, "objectForKeyedSubscript:", v19),  "objectForKeyedSubscript:",  @"AuthContext");
      if (v20 && ![v2 objectForKeyedSubscript:v20]) {
        [obj addObject:*(void *)(v18 + 40)];
      }
      __int128 v21 = (void *)v17[1];
      if (v21)
      {
        do
        {
          uint64_t v22 = v21;
          __int128 v21 = (void *)*v21;
        }

        while (v21);
      }

      else
      {
        do
        {
          uint64_t v22 = (void *)v17[2];
          BOOL v16 = *v22 == (void)v17;
          char v17 = v22;
        }

        while (!v16);
      }

      char v17 = v22;
    }

    while (v22 != (void *)(a1 + 832));
  }

  id v23 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  __int128 v24 = *(void **)(a1 + 848);
  if (v24 != (void *)(a1 + 856))
  {
    do
    {
      uint64_t v25 = v24[4];
      uint64_t v26 = +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v25);
      [v23 setObject:sub_100D5575C((CLConnection **)v25) forKeyedSubscript:v26];
      id v27 = objc_msgSend( objc_msgSend(v23, "objectForKeyedSubscript:", v26),  "objectForKeyedSubscript:",  @"AuthContext");
      if (v27 && ![v2 objectForKeyedSubscript:v27]) {
        [obj addObject:*(void *)(v25 + 40)];
      }
      uint64_t v28 = (void *)v24[1];
      if (v28)
      {
        do
        {
          char v29 = v28;
          uint64_t v28 = (void *)*v28;
        }

        while (v28);
      }

      else
      {
        do
        {
          char v29 = (void *)v24[2];
          BOOL v16 = *v29 == (void)v24;
          __int128 v24 = v29;
        }

        while (!v16);
      }

      __int128 v24 = v29;
    }

    while (v29 != (void *)(a1 + 856));
  }

  id v30 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  for (j = *(void **)(a1 + 928); j; j = (void *)*j)
  {
    for (k = (void *)j[7]; k; k = (void *)*k)
    {
      char v33 = (std::__shared_weak_count *)k[4];
      if (v33)
      {
        id v34 = std::__shared_weak_count::lock(v33);
        double v71 = v34;
        if (v34)
        {
          BOOL v35 = v34;
          id v36 = (void *)k[3];
          unsigned int v70 = v36;
          if (v36)
          {
            __int16 v37 = +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v36);
            [v30 setObject:(*(uint64_t (**)(void *))(*v36 + 32))(v36) forKeyedSubscript:v37];
            id v38 = objc_msgSend( objc_msgSend(v30, "objectForKeyedSubscript:", v37),  "objectForKeyedSubscript:",  @"AuthContext");
            if (v38)
            {
              if (![v2 objectForKeyedSubscript:v38]) {
                [obj addObject:v36[17]];
              }
            }
          }

          p_shared_owners = (unint64_t *)&v35->__shared_owners_;
          do
            unint64_t v40 = __ldaxr(p_shared_owners);
          while (__stlxr(v40 - 1, p_shared_owners));
          if (!v40)
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
        }
      }
    }
  }

  __int128 v68 = 0u;
  __int128 v69 = 0u;
  __int128 v66 = 0u;
  __int128 v67 = 0u;
  id v41 = [obj countByEnumeratingWithState:&v66 objects:v76 count:16];
  if (v41)
  {
    uint64_t v42 = *(void *)v67;
    do
    {
      for (m = 0LL; m != v41; m = (char *)m + 1)
      {
        if (*(void *)v67 != v42) {
          objc_enumerationMutation(obj);
        }
        __int16 v44 = *(void **)(*((void *)&v66 + 1) + 8LL * (void)m);
        id v45 = +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v44);
        if (![v2 objectForKeyedSubscript:v45]) {
          objc_msgSend(v2, "setObject:forKeyedSubscript:", objc_msgSend(v44, "getStateSummary"), v45);
        }
      }

      id v41 = [obj countByEnumeratingWithState:&v66 objects:v76 count:16];
    }

    while (v41);
  }

  id v60 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  id obja = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  __int16 v46 = *(void **)(a1 + 776);
  if (v46 != (void *)(a1 + 784))
  {
    do
    {
      id v47 = (const void *)v46[5];
      uint64_t v48 = (*(uint64_t (**)(const void *))(*(void *)v47 + 32LL))(v47);
      if (v48)
      {
        uint64_t v49 = +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v47);
        uint64_t v51 = obja;
        if (v50
        {
          [v51 setObject:v48 forKeyedSubscript:v49];
        }
      }

      uint64_t v53 = (void *)v46[1];
      if (v53)
      {
        do
        {
          uint64_t v54 = v53;
          uint64_t v53 = (void *)*v53;
        }

        while (v53);
      }

      else
      {
        do
        {
          uint64_t v54 = (void *)v46[2];
          BOOL v16 = *v54 == (void)v46;
          __int16 v46 = v54;
        }

        while (!v16);
      }

      __int16 v46 = v54;
    }

    while (v54 != (void *)(a1 + 784));
  }

  id v55 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  objc_msgSend( v55,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", CFAbsoluteTimeGetCurrent()),  @"CollectTimestamp");
  double v56 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  -[NSDateFormatter setDateFormat:](v56, "setDateFormat:", @"yyyy-MM-dd HH:mm:ssZ");
  objc_msgSend( v55,  "setObject:forKeyedSubscript:",  -[NSDateFormatter stringFromDate:]( v56,  "stringFromDate:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  CFAbsoluteTimeGetCurrent())),  @"CollectTime");
  objc_msgSend( v55,  "setObject:forKeyedSubscript:",  -[NSProcessInfo operatingSystemVersionString]( +[NSProcessInfo processInfo](NSProcessInfo, "processInfo"),  "operatingSystemVersionString"),  @"BuildVersion");
  id v57 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  [v57 setObject:v63 forKeyedSubscript:@"AuthorizationDatabaseState"];
  [v57 setObject:sub_1008FE900(*(void *)(a1 + 376)) forKeyedSubscript:@"InUseLevelTrackerState"];
  [v57 setObject:v2 forKeyedSubscript:@"AuthorizationContextStates"];
  [v57 setObject:v62 forKeyedSubscript:@"DaemonClientStates"];
  [v57 setObject:v61 forKeyedSubscript:@"DaemonIdentifiableClientStates"];
  [v57 setObject:v23 forKeyedSubscript:@"DaemonIdentifiableClientWithoutConnectionStates"];
  [v57 setObject:v30 forKeyedSubscript:@"PersistentSubscriptionStates"];
  [v57 setObject:v60 forKeyedSubscript:@"InUseAssertionStates"];
  [v57 setObject:obja forKeyedSubscript:@"EmergencyAssertionStates"];
  [v57 setObject:v55 forKeyedSubscript:@"CollectionMetadata"];

  return v57;
}

void sub_100561348( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_100561368(uint64_t a1, void *a2, void *a3)
{
  id v6 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if (v6)
  {
    uint64_t v7 = v6;
    __int16 v37 = a3;
    if (qword_101996E00 != -1) {
      dispatch_once(&qword_101996E00, &stru_10183FCC8);
    }
    [*(id *)(a1 + 40) currentLatchedAbsoluteTimestamp];
    double v9 = v8 / 86400.0;
    unint64_t v10 = (unint64_t)v9;
    qword_101996DF0 = (unint64_t)v9;
    [(id)qword_101996DF8 removeAllObjects];
    id v11 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
    BOOL v12 = *(void **)(a1 + 136);
    v46[0] = _NSConcreteStackBlock;
    v46[1] = 3221225472LL;
    v46[2] = sub_100561D00;
    v46[3] = &unk_10183F9D0;
    v46[4] = v11;
    v46[5] = a1;
    [v12 iterateAllAnchorKeyPathsWithBlock:v46];
    id v13 = [v11 count];
    if (v13)
    {
      unint64_t v14 = (unint64_t)v13;
      uint64_t v15 = 5LL;
      unint64_t v16 = v10;
      do
      {
        id v17 = [v11 objectAtIndex:v16 % v14];
        [(id)qword_101996DF8 addObject:v17];
        v16 += v10;
        --v15;
      }

      while (v15);
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v42 = 0u;
      __int128 v43 = 0u;
      uint64_t v18 = (void *)qword_101996DF8;
      id v19 = [(id)qword_101996DF8 countByEnumeratingWithState:&v42 objects:v56 count:16];
      if (v19)
      {
        id v20 = v19;
        uint64_t v21 = *(void *)v43;
        do
        {
          uint64_t v22 = 0LL;
          do
          {
            if (*(void *)v43 != v21) {
              objc_enumerationMutation(v18);
            }
            id v23 = *(void **)(*((void *)&v42 + 1) + 8LL * (void)v22);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
            __int128 v24 = (os_log_s *)qword_101934988;
            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 68289538;
              int v49 = 0;
              __int16 v50 = 2082;
              uint64_t v51 = "";
              __int16 v52 = 2114;
              uint64_t v53 = v23;
              __int16 v54 = 1026;
              int v55 = v14;
              _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MetricForFunctionCalls: adding client of the day, ckp:%{public, location:es cape_only}@, totalClients:%{public}d}",  buf,  0x22u);
            }

            uint64_t v22 = (char *)v22 + 1;
          }

          while (v20 != v22);
          id v20 = [v18 countByEnumeratingWithState:&v42 objects:v56 count:16];
        }

        while (v20);
      }

void sub_100561CD8(id a1)
{
  qword_101996DF8 = (uint64_t)+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set");
}

id sub_100561D00(uint64_t a1, uint64_t a2)
{
  id result = [*(id *)(*(void *)(a1 + 40) + 136) BOOLForKey:@"isSystemService" atKeyPath:a2 defaultValue:0];
  return result;
}

void sub_100561D58(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  id v7 = sub_10053D6E0(a1, a2);
  double v8 = (NSMutableArray *)[*(id *)(a1 + 360) objectForKey:v7];
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  double v9 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    int v12 = 68290306;
    int v13 = 0;
    __int16 v14 = 2082;
    uint64_t v15 = "";
    __int16 v16 = 2114;
    id v17 = v7;
    __int16 v18 = 2050;
    uint64_t v19 = a3;
    __int16 v20 = 1026;
    int v21 = (unsigned __int16)a3;
    __int16 v22 = 1026;
    int v23 = a4;
    __int16 v24 = 2114;
    uint64_t v25 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#identityValidation cache updating, Client:%{public, location:escape_only}@, upid :%{public}lld, pid:%{public}d, coming:%{public}hhd, AllowedUniquePids:%{public, location:escape_only}@}",  (uint8_t *)&v12,  0x3Cu);
  }

  if (a4)
  {
    if (!v8)
    {
      double v8 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
      [*(id *)(a1 + 360) setObject:v8 forKeyedSubscript:v7];
    }

    -[NSMutableArray addObject:]( v8,  "addObject:",  +[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", a3));
  }

  else
  {
    id v10 = -[NSMutableArray indexOfObject:]( v8,  "indexOfObject:",  +[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", a3));
    if (v10 != (id)0x7FFFFFFFFFFFFFFFLL)
    {
      -[NSMutableArray removeObjectAtIndex:](v8, "removeObjectAtIndex:", v10);
      if (!-[NSMutableArray count](v8, "count"))
      {
        [*(id *)(a1 + 360) removeObjectForKey:v7];
        double v8 = 0LL;
      }
    }
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v11 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    int v12 = 68290306;
    int v13 = 0;
    __int16 v14 = 2082;
    uint64_t v15 = "";
    __int16 v16 = 2114;
    id v17 = v7;
    __int16 v18 = 2050;
    uint64_t v19 = a3;
    __int16 v20 = 1026;
    int v21 = (unsigned __int16)a3;
    __int16 v22 = 1026;
    int v23 = a4;
    __int16 v24 = 2114;
    uint64_t v25 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#identityValidation cache updated, Client:%{public, location:escape_only}@, upid: %{public}lld, pid:%{public}d, coming:%{public}hhd, AllowedUniquePids:%{public, location:escape_only}@}",  (uint8_t *)&v12,  0x3Cu);
  }

void sub_100561FF0(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6)
{
  id v12 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if ([v12 isValidCKP])
  {
    sub_100562164(a1, (uint64_t)v12, a3, a4, a5, a6);
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v13 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      v14[0] = 68289282;
      v14[1] = 0;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2114;
      uint64_t v18 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#luHistorical client not found - fetching dateIntervals, Client:%{public, location:escape_only}@}",  (uint8_t *)v14,  0x1Cu);
    }
  }

void sub_100562164(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6)
{
  if (objc_opt_class(&OBJC_CLASS___CLPLocationConsumptionScoreInfo))
  {
    id v54 = sub_10053D6E0(a1, a2);
    if (objc_msgSend( objc_msgSend( a4,  "objectForKeyedSubscript:",  @"com.apple.developer.corelocation.wilderness-safety"),  "BOOLValue"))
    {
      id obj = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
      id v12 = a3;
    }

    else
    {
      unsigned int v14 = objc_msgSend( objc_msgSend( a4,  "objectForKeyedSubscript:",  @"com.apple.locationd.transcript-session"),  "BOOLValue");
      id obj = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
      id v12 = a3;
      if (!v14)
      {
        int v15 = 0;
        id v53 = 0LL;
        goto LABEL_11;
      }
    }

    id v53 = sub_10054EC9C(a1, a5);
    int v15 = 1;
LABEL_11:
    id v16 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
    uint64_t v51 = a1;
    __int16 v17 = sub_1005648B4(a1, (uint64_t)v54);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v18 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t buf = 68290306LL;
      __int16 v67 = 2082;
      __int128 v68 = "";
      __int16 v69 = 2114;
      *(void *)unsigned int v70 = a5;
      *(_WORD *)&v70[8] = 2114;
      *(void *)&v70[10] = v17;
      __int16 v71 = 2114;
      id v72 = [v12 startDate];
      __int16 v73 = 2114;
      id v74 = [v12 endDate];
      __int16 v75 = 2114;
      id v76 = v54;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LocationAttributionInfo #luHistorical calculateCheeseCoverage, lookbackWindowStartDa te:%{public, location:escape_only}@, transcriptStartDate:%{public, location:escape_only}@, interestStart Date:%{public, location:escape_only}@, interestEndDate:%{public, location:escape_only}@, Client:%{publ ic, location:escape_only}@}",  (uint8_t *)&buf,  0x44u);
    }

    char v19 = v15 ^ 1;
    if (!v17) {
      char v19 = 1;
    }
    if ((v19 & 1) != 0)
    {
      id v52 = 0LL;
      if (!v15)
      {
LABEL_35:
        uint64_t v61 = 0LL;
        id v62 = &v61;
        uint64_t v63 = 0x2020000000LL;
        int v64 = 0;
        if ((_os_feature_enabled_impl("CoreLocation", "CLSwissLocationAttribution") & 1) != 0)
        {
          char v29 = *(void **)(v51 + 480);
          v60[0] = _NSConcreteStackBlock;
          v60[1] = 3221225472LL;
          v60[2] = sub_100564C90;
          v60[3] = &unk_10183FD88;
          v60[6] = &v61;
          v60[7] = v51;
          v60[4] = v16;
          v60[5] = obj;
          sub_10054EFE4(v29, (uint64_t)v54, (uint64_t)v60);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          id v30 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v31 = [obj count];
            uint64_t buf = 68289538LL;
            __int16 v67 = 2082;
            __int128 v68 = "";
            __int16 v69 = 1026;
            *(_DWORD *)unsigned int v70 = v31;
            *(_WORD *)&v70[4] = 2114;
            *(void *)&v70[6] = v54;
            _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LocationAttributionInfo finished iterating through swiss cheese archive, resul tCount:%{public}d, Client:%{public, location:escape_only}@}",  (uint8_t *)&buf,  0x22u);
          }
        }

        while (1)
        {
          id v32 = objc_msgSend(v16, "count", v51);
          objc_msgSend(obj, "addObject:", objc_msgSend(v16, "objectAtIndexedSubscript:"));
          ++*((_DWORD *)v62 + 6);
        }

        objc_msgSend(objc_msgSend(v12, "startDate"), "timeIntervalSinceReferenceDate");
        double v34 = v33;
        objc_msgSend(objc_msgSend(v12, "endDate"), "timeIntervalSinceReferenceDate");
        double v36 = v35;
        __int16 v37 = (char *)[obj count];
        if (v37)
        {
          __int128 v38 = v37 - 1;
          do
          {
            objc_msgSend( objc_msgSend(objc_msgSend(obj, "objectAtIndexedSubscript:", v38), "startDate"),  "timeIntervalSinceReferenceDate");
            double v40 = v39;
            objc_msgSend( objc_msgSend(objc_msgSend(obj, "objectAtIndexedSubscript:", v38), "endDate"),  "timeIntervalSinceReferenceDate");
            double v42 = v41;
            unsigned __int8 v43 = objc_msgSend( objc_msgSend(obj, "objectAtIndexedSubscript:", v38),  "intersectsDateInterval:",  v12);
            if (v40 < v34 || v42 > v36)
            {
              if ((v43 & 1) != 0)
              {
                if (v40 < v34 || v42 <= v36 || v40 >= v36)
                {
                  if (v40 < v34 && v42 <= v36) {
                    objc_msgSend( obj,  "replaceObjectAtIndex:withObject:",  v38,   -[NSDateInterval initWithStartDate:endDate:]( [NSDateInterval alloc],  "initWithStartDate:endDate:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  v34),  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  v42)));
                  }
                }

                else
                {
                  objc_msgSend( obj,  "replaceObjectAtIndex:withObject:",  v38,   -[NSDateInterval initWithStartDate:endDate:]( [NSDateInterval alloc],  "initWithStartDate:endDate:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  v40),  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  v36)));
                }
              }

              else
              {
                [obj removeObjectAtIndex:v38];
              }
            }

            --v38;
          }

          while (v38 != (char *)-1LL);
        }

        __int128 v58 = 0u;
        __int128 v59 = 0u;
        __int128 v56 = 0u;
        __int128 v57 = 0u;
        id v44 = [obj countByEnumeratingWithState:&v56 objects:v65 count:16];
        if (v44)
        {
          uint64_t v45 = *(void *)v57;
          do
          {
            for (uint64_t i = 0LL; i != v44; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v57 != v45) {
                objc_enumerationMutation(obj);
              }
              id v47 = *(void **)(*((void *)&v56 + 1) + 8LL * (void)i);
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              uint64_t v48 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
              {
                id v49 = [v47 startDate];
                id v50 = [v47 endDate];
                uint64_t buf = 68289794LL;
                __int16 v67 = 2082;
                __int128 v68 = "";
                __int16 v69 = 2114;
                *(void *)unsigned int v70 = v49;
                *(_WORD *)&v70[8] = 2114;
                *(void *)&v70[10] = v50;
                __int16 v71 = 2114;
                id v72 = v54;
                _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LocationAttributionInfo #luHistorical cheeseCoverage calculated and includes t his interval, startDate:%{public, location:escape_only}@, endDate:%{public, location:escape_ only}@, Client:%{public, location:escape_only}@}",  (uint8_t *)&buf,  0x30u);
              }
            }

            id v44 = [obj countByEnumeratingWithState:&v56 objects:v65 count:16];
          }

          while (v44);
        }

        (*(void (**)(uint64_t, id))(a6 + 16))(a6, obj);
        _Block_object_dispose(&v61, 8);
        return;
      }
    }

    else
    {
      id v52 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
      objc_msgSend( v52,  "addObject:",   -[NSDateInterval initWithStartDate:endDate:]( [NSDateInterval alloc],  "initWithStartDate:endDate:",  v17,  +[NSDate now](NSDate, "now")));
      if (!v15) {
        goto LABEL_35;
      }
    }

    int v20 = 0;
    int v21 = 0;
    while (1)
    {
      if ((unint64_t)objc_msgSend(v53, "count", v51) <= v21)
      {
        unint64_t v22 = v20;
      }

      else
      {
        unint64_t v22 = v20;
      }

      id v23 = [v53 count];
      id v24 = [v52 count];
      unint64_t v25 = (unint64_t)v24;
      if ((unint64_t)v24 <= v22)
      {
        double v27 = 0.0;
      }

      else
      {
        objc_msgSend( objc_msgSend(objc_msgSend(v52, "objectAtIndexedSubscript:", v22), "startDate"),  "timeIntervalSinceReferenceDate");
        double v27 = v26;
      }

      objc_msgSend( objc_msgSend(objc_msgSend(v53, "objectAtIndexedSubscript:", v21), "startDate"),  "timeIntervalSinceReferenceDate");
      if (v28 > v27 && v25 > v22)
      {
LABEL_32:
        id v24 = objc_msgSend(v16, "addObject:", objc_msgSend(v52, "objectAtIndexedSubscript:", v22));
        ++v20;
        goto LABEL_34;
      }

      id v24 = objc_msgSend(v16, "addObject:", objc_msgSend(v53, "objectAtIndexedSubscript:", v21++));
LABEL_34:
      sub_100564B38((uint64_t)v24, v16);
    }
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  int v13 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t buf = 68289026LL;
    __int16 v67 = 2082;
    __int128 v68 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLPLocationConsumptionScoreInfo doesn't exist in this platform.}",  (uint8_t *)&buf,  0x12u);
  }

void sub_1005629E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_100562A40(uint64_t a1, uint64_t a2)
{
  id v3 = [[CLPLocationConsumptionScoreInfo alloc] initWithData:a2];
  if (objc_msgSend( @"com.apple.locationd.all-location-clients-stop",  "isEqualToString:",  objc_msgSend(v3, "clientKey")))
  {
    double v4 = *(double *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
    *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0LL;
    goto LABEL_6;
  }

  if (([*(id *)(a1 + 32) isValidCKP] & 1) == 0)
  {
LABEL_11:
    uint64_t v7 = *(void *)(a1 + 40);
    [v3 startTime];
    double v9 = v8;
    [v3 stopTime];
    (*(void (**)(uint64_t, double, double))(v7 + 16))(v7, v9, v10);
    goto LABEL_19;
  }

  unsigned __int8 v5 = objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "clientKey"),  "isEqualToString:",  objc_msgSend(v3, "clientKey"));
  unsigned int v6 = [v3 hasStartTime];
  if ((v5 & 1) == 0)
  {
    if (v6) {
      [v3 startTime];
    }
    else {
      [v3 stopTime];
    }
    uint64_t v12 = *(void *)(a1 + 56);
    goto LABEL_18;
  }

  if ([v3 hasStartTime])
  {
    [v3 startTime];
    uint64_t v12 = *(void *)(a1 + 48);
LABEL_18:
    *(void *)(*(void *)(v12 + 8) + 24LL) = v11;
    goto LABEL_19;
  }

  if ([v3 hasStopTime])
  {
    double v13 = *(double *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
    if (v13 > 0.0)
    {
      [v3 stopTime];
      if (v13 < v14)
      {
        uint64_t v15 = *(void *)(a1 + 40);
        double v16 = *(double *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
        [v3 stopTime];
        (*(void (**)(uint64_t, double, double))(v15 + 16))(v15, v16, v17);
LABEL_6:
        *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0LL;
        goto LABEL_19;
      }
    }
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v18 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
  {
    uint64_t v19 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
    int v22 = 68289538;
    int v23 = 0;
    __int16 v24 = 2082;
    unint64_t v25 = "";
    __int16 v26 = 2050;
    uint64_t v27 = v19;
    __int16 v28 = 2114;
    id v29 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Invalid ConsumptionScore interval, startTime:%{public}f, scoreInfo:%{public, location:escape_only}@}",  (uint8_t *)&v22,  0x26u);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
  }

  int v20 = (os_log_s *)qword_101934988;
  if (os_signpost_enabled((os_log_t)qword_101934988))
  {
    uint64_t v21 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
    int v22 = 68289538;
    int v23 = 0;
    __int16 v24 = 2082;
    unint64_t v25 = "";
    __int16 v26 = 2050;
    uint64_t v27 = v21;
    __int16 v28 = 2114;
    id v29 = v3;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Invalid ConsumptionScore interval",  "{msg%{public}.0s:Invalid ConsumptionScore interval, startTime:%{public}f, scoreInfo:%{public, location:escape_only}@}",  (uint8_t *)&v22,  0x26u);
  }

void sub_100562DB0(uint64_t a1)
{
  p_p = &__p;
  id v2 = (double *)sub_100589248(a1, (unsigned __int8 *)&__p, (uint64_t)&unk_1012CF090, (__int128 **)&p_p);
  if (SBYTE3(v15) < 0) {
    operator delete(__p);
  }
  id v3 = *(double **)(a1 + 16);
  if (v3)
  {
    double v4 = v2[5] + 10.0;
    do
    {
      double v5 = v3[5];
      if (v5 > 0.0)
      {
        if (v5 <= v4)
        {
          *((_DWORD *)v3 + 12) += (int)(v4 - v5);
        }

        else
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          unsigned int v6 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
          {
            uint64_t v7 = *((void *)v3 + 5);
            __int128 __p = (void *)68289538;
            __int16 v12 = 2082;
            double v13 = "";
            __int16 v14 = 2050;
            uint64_t v15 = v7;
            __int16 v16 = 2050;
            double v17 = v4;
            _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Detected CFAbsoluteTime rollback when reading usage score, PreviousTimestamp: %{public}f, Timestamp:%{public}f}",  (uint8_t *)&__p,  0x26u);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
          }

          double v8 = (os_log_s *)qword_101934988;
          if (os_signpost_enabled((os_log_t)qword_101934988))
          {
            uint64_t v9 = *((void *)v3 + 5);
            __int128 __p = (void *)68289538;
            __int16 v12 = 2082;
            double v13 = "";
            __int16 v14 = 2050;
            uint64_t v15 = v9;
            __int16 v16 = 2050;
            double v17 = v4;
            _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v8,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Detected CFAbsoluteTime rollback when reading usage score",  "{msg%{public}.0s:Detected CFAbsoluteTime rollback when reading usage score, PreviousTimestamp: %{public}f, Timestamp:%{public}f}",  (uint8_t *)&__p,  0x26u);
          }
        }
      }

      v3[5] = 0.0;
      id v3 = *(double **)v3;
    }

    while (v3);
  }

void sub_10056300C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100563030(uint64_t a1, void *a2, uint64_t a3)
{
  if (objc_opt_class(&OBJC_CLASS___CLPLocationConsumptionScoreInfo))
  {
    [a2 pruneSecondaryDataOlderThan:CFAbsoluteTimeGetCurrent() + -432000.0];
    double v5 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "com.apple.locationd.reading-score-archive");
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unsigned int v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Updating the #reprompt location consumption score info from archive}",  buf,  0x12u);
    }

    uint64_t v7 = objc_autoreleasePoolPush();
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    v10[2] = sub_1005632C8;
    v10[3] = &unk_10183FD10;
    v10[4] = a3;
    objc_msgSend(a2, "iterateSecondaryData:forField:withHandler:", objc_msgSend(a2, "mappedSecondaryData"), 1, v10);
    objc_autoreleasePoolPop(v7);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    double v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Finished - Updating the #reprompt location consumption score info from archive}",  buf,  0x12u);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v9 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLPLocationConsumptionScoreInfo doesn't exist in this platform.}",  buf,  0x12u);
    }
  }

void sub_1005632C8(uint64_t a1, uint64_t a2)
{
  id v3 = [[CLPLocationConsumptionScoreInfo alloc] initWithData:a2];
  sub_100563318(*(void *)(a1 + 32), v3);
}

void sub_100563318(uint64_t a1, void *a2)
{
  if (!objc_opt_class(&OBJC_CLASS___CLPLocationConsumptionScoreInfo))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v5 = qword_101934988;
    if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v16 = 2082;
    double v17 = "";
    unsigned int v6 = "{msg%{public}.0s:CLPLocationConsumptionScoreInfo doesn't exist in this platform.}";
    uint64_t v7 = (os_log_s *)v5;
    os_log_type_t v8 = OS_LOG_TYPE_DEFAULT;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v7, v8, v6, buf, 0x12u);
    return;
  }

  if (objc_msgSend( @"com.apple.locationd.all-location-clients-stop",  "isEqualToString:",  objc_msgSend(a2, "clientKey")))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    double v4 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v16 = 2082;
      double v17 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Detected locationd startup; marking all historical clients as stopped}",
        buf,
        0x12u);
    }

    sub_100562DB0(a1);
    return;
  }

  if (![a2 clientKey])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v13 = qword_101934988;
    if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG)) {
      return;
    }
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v16 = 2082;
    double v17 = "";
    unsigned int v6 = "{msg%{public}.0s:Detected clientKey is empty}";
    uint64_t v7 = (os_log_s *)v13;
    os_log_type_t v8 = OS_LOG_TYPE_DEBUG;
    goto LABEL_26;
  }

  sub_1010DDBC0(buf, (char *)objc_msgSend(objc_msgSend(a2, "clientKey"), "UTF8String"));
  __int16 v14 = buf;
  uint64_t v9 = sub_100589248(a1, buf, (uint64_t)&unk_1012CF090, (__int128 **)&v14);
  if (v18 < 0) {
    operator delete(*(void **)buf);
  }
  sub_1010DDBC0(buf, (char *)[@"com.apple.locationd.all-location-clients-stop" UTF8String]);
  __int16 v14 = buf;
  double v10 = sub_100589248(a1, buf, (uint64_t)&unk_1012CF090, (__int128 **)&v14);
  if (v18 < 0) {
    operator delete(*(void **)buf);
  }
  if ([a2 hasStartTime] && objc_msgSend(a2, "hasStopTime"))
  {
    v9[12] += 500;
    [a2 stopTime];
  }

  else if ([a2 hasStartTime])
  {
    [a2 startTime];
    *((void *)v9 + 5) = v12;
    [a2 startTime];
  }

  else
  {
    v9[12] += [a2 score];
    *((void *)v9 + 5) = 0LL;
    [a2 stopTime];
  }

  void v10[5] = v11;
}

void sub_100563674( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056369C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (objc_opt_class(&OBJC_CLASS___CLPLocationConsumptionScoreInfo))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unsigned int v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Registering pruning activity with check-in criteria for location consumption score info archive.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      v11[0] = 0;
      uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "Registering pruning activity with check-in criteria for location consumption score info archive.",  v11,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::registerPruningActivityForLocationConsumptionScoreInfoArchive(CLHRequestArchive *, ConsumptionScoreMap &)",  "%s\n",  v9);
    }

    xpc_object_t v7 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_BOOL(v7, XPC_ACTIVITY_REPEATING, 1);
    xpc_dictionary_set_string(v7, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_MAINTENANCE);
    xpc_dictionary_set_int64(v7, XPC_ACTIVITY_INTERVAL, 86400LL);
    xpc_dictionary_set_int64(v7, XPC_ACTIVITY_GRACE_PERIOD, 14400LL);
    xpc_dictionary_set_BOOL(v7, XPC_ACTIVITY_ALLOW_BATTERY, 1);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_1005639B0;
    handler[3] = &unk_10183D2B0;
    handler[4] = a2;
    handler[5] = a1;
    handler[6] = a3;
    xpc_activity_register("CLClientManager.loc-consumption-pruning", v7, handler);
    xpc_release(v7);
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    os_log_type_t v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLPLocationConsumptionScoreInfo doesn't exist in this platform.}",  buf,  0x12u);
    }
  }

void sub_1005639B0(void *a1, xpc_activity_t activity)
{
  uint64_t v3 = a1[5];
  xpc_activity_state_t state = xpc_activity_get_state(activity);
  if (state == 2)
  {
    uint64_t v5 = *(void **)(v3 + 40);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    _DWORD v8[2] = sub_100563B00;
    v8[3] = &unk_10183FD38;
    void v8[4] = a1[4];
    v8[5] = v3;
    v8[6] = a1[6];
    [v5 async:v8];
  }

  else
  {
    xpc_activity_state_t v6 = state;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    xpc_object_t v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      int v10 = 0;
      __int16 v11 = 2082;
      uint64_t v12 = "";
      __int16 v13 = 2050;
      xpc_activity_state_t v14 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:skip consumption score pruning activity, Current State:%{public}ld}",  buf,  0x1Cu);
    }
  }

void sub_100563B00(uint64_t a1)
{
}

void sub_100563B10(uint64_t a1, void *a2, uint64_t a3)
{
  if (objc_opt_class(&OBJC_CLASS___CLPLocationConsumptionScoreInfo))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    xpc_activity_state_t v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(v49) = 2082;
      *(void *)((char *)&v49 + 2) = "";
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Pruning location consumption score info archive.}",  buf,  0x12u);
    }

    xpc_object_t v7 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "com.apple.locationd.pruning-score-archive");
    context = objc_autoreleasePoolPush();
    sub_100589530((uint64_t)v45, a3);
    id v8 = [a2 pruneAndGetSecondaryDataOlderThan:CFAbsoluteTimeGetCurrent() + -259200.0];
    if ([v8 length])
    {
      *(void *)uint64_t buf = 0LL;
      *(void *)&__int128 v49 = buf;
      *((void *)&v49 + 1) = 0x5812000000LL;
      id v50 = sub_1005644D8;
      uint64_t v51 = sub_1005644E4;
      memset(v52, 0, sizeof(v52));
      uint64_t v53 = 0LL;
      int v54 = 1065353216;
      v44[0] = _NSConcreteStackBlock;
      v44[1] = 3221225472LL;
      v44[2] = sub_1005644EC;
      v44[3] = &unk_10183FD60;
      v44[4] = buf;
      [a2 iterateSecondaryData:v8 forField:1 withHandler:v44];
      sub_100562DB0(v49 + 48);
      for (uint64_t i = *(uint64_t **)(v49 + 64); i; uint64_t i = (uint64_t *)*i)
      {
        int v10 = i + 2;
        __int16 v11 = sub_100121918(v45, (unsigned __int8 *)i + 16);
        uint64_t v12 = v11;
        if (v11)
        {
          *((_DWORD *)v11 + 12) -= *((_DWORD *)i + 12);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          uint64_t v13 = qword_101934988;
          if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG)) {
            continue;
          }
          int v14 = -*((_DWORD *)i + 12);
          int v15 = *((_DWORD *)v12 + 12);
          uint64_t v55 = 68289794LL;
          __int16 v56 = 2082;
          __int128 v57 = "";
          __int16 v58 = 2082;
          __int128 v59 = v10;
          __int16 v60 = 1026;
          int v61 = v14;
          __int16 v62 = 1026;
          int v63 = v15;
          __int16 v16 = (os_log_s *)v13;
          os_log_type_t v17 = OS_LOG_TYPE_DEBUG;
          char v18 = "{msg%{public}.0s:Pruning LocationConsumptionUsageScore, Client:%{public, location:escape_onl"
                "y}s, ScoreAdjustment:%{public}d, NewScore:%{public}d}";
          uint32_t v19 = 40;
        }

        else
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          uint64_t v20 = qword_101934988;
          if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
            continue;
          }
          uint64_t v55 = 68289026LL;
          __int16 v56 = 2082;
          __int128 v57 = "";
          __int16 v16 = (os_log_s *)v20;
          os_log_type_t v17 = OS_LOG_TYPE_DEFAULT;
          char v18 = "{msg%{public}.0s:#Warning Found a client in pruned data, that does not exist in memory.}";
          uint32_t v19 = 18;
        }

        _os_log_impl((void *)&_mh_execute_header, v16, v17, v18, (uint8_t *)&v55, v19);
      }

      _Block_object_dispose(buf, 8);
      sub_10004AD90((uint64_t)&v52[8]);
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v21 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "Before rotation stopping the active clients",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      LOWORD(v55) = 0;
      double v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "Before rotation stopping the active clients",  &v55,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::pruneAndRotateLocationConsumptionScoreArchiveAndUpdateTheStateAccordingly(CLHRequestArchiv e *, ConsumptionScoreMap &)",  "%s\n",  v35);
    }

    int v22 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    for (j = v46; j; j = (uint64_t *)*j)
    {
      if (*((double *)j + 5) > 0.0)
      {
        __int16 v24 = j + 2;
        unint64_t v25 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v24);
        if (-[NSString isEqualToString:]( v25,  "isEqualToString:",  @"com.apple.locationd.all-location-clients-stop"))
        {
          sub_100551C04(a1, a2, v45, 0LL);
          -[NSMutableArray addObject:](v22, "addObject:", +[NSNull null](&OBJC_CLASS___NSNull, "null"));
        }

        else
        {
          __int16 v26 = +[CLClientKeyPath clientKeyPathWithClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientKey:",  v25);
          sub_100551C04(a1, a2, v45, v26);
          -[NSMutableArray addObject:](v22, "addObject:", v26);
        }
      }
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v27 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Rotating location consumption score info archive.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      LOWORD(v55) = 0;
      LODWORD(v3_Block_object_dispose(va, 8) = 2;
      double v36 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "Rotating location consumption score info archive.",  &v55,  v38);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::pruneAndRotateLocationConsumptionScoreArchiveAndUpdateTheStateAccordingly(CLHRequestArchiv e *, ConsumptionScoreMap &)",  "%s\n",  v36);
    }

    [a2 rotateSecondaryFile];
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v28 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_INFO,  "After rotation resuming the stopped clients",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      LOWORD(v55) = 0;
      LODWORD(v3_Block_object_dispose(va, 8) = 2;
      __int16 v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "After rotation resuming the stopped clients",  &v55,  v38);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::pruneAndRotateLocationConsumptionScoreArchiveAndUpdateTheStateAccordingly(CLHRequestArchiv e *, ConsumptionScoreMap &)",  "%s\n",  v37);
    }

    __int128 v42 = 0u;
    __int128 v43 = 0u;
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    id v29 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v40,  v47,  16LL);
    if (v29)
    {
      uint64_t v30 = *(void *)v41;
      do
      {
        for (k = 0LL; k != v29; k = (char *)k + 1)
        {
          if (*(void *)v41 != v30) {
            objc_enumerationMutation(v22);
          }
          id v32 = *(void **)(*((void *)&v40 + 1) + 8LL * (void)k);
          else {
            double v33 = v32;
          }
          sub_10055151C(a1, a2, (uint64_t)v45, v33);
        }

        id v29 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v40,  v47,  16LL);
      }

      while (v29);
    }

    sub_10004AD90((uint64_t)v45);
    objc_autoreleasePoolPop(context);
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    double v34 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(v49) = 2082;
      *(void *)((char *)&v49 + 2) = "";
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLPLocationConsumptionScoreInfo doesn't exist in this platform.}",  buf,  0x12u);
    }
  }

void sub_100564478( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32)
{
}

uint64_t sub_1005644D8(uint64_t a1, uint64_t a2)
{
  return sub_10001B9CC(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t sub_1005644E4(uint64_t a1)
{
  return sub_10004AD90(a1 + 48);
}

void sub_1005644EC(uint64_t a1, uint64_t a2)
{
  id v3 = [[CLPLocationConsumptionScoreInfo alloc] initWithData:a2];
  sub_100563318(*(void *)(*(void *)(a1 + 32) + 8LL) + 48LL, v3);
}

void sub_100564544(uint64_t a1)
{
  if (objc_opt_class(&OBJC_CLASS___CLPLocationConsumptionScoreInfo))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v2 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Resetting resetLocationAttributionIntervalArchive",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      LOWORD(v12.__r_.__value_.__l.__data_) = 0;
      __int16 v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "Resetting resetLocationAttributionIntervalArchive",  &v12,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::resetLocationAttributionIntervalArchive()",  "%s\n",  v11);
      if (v11 != buf) {
        free(v11);
      }
    }

    id v3 = objc_alloc(&OBJC_CLASS___CLHRequestArchive);
    sub_100309D64(0, &v12);
    double v4 = std::string::append(&v12, "locationAttributionInfo/");
    __int128 v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    *(void *)&uint8_t buf[16] = v4->__r_.__value_.__l.__cap_;
    *(_OWORD *)uint64_t buf = v5;
    v4->__r_.__value_.__l.__size_ = 0LL;
    v4->__r_.__value_.__l.__cap_ = 0LL;
    v4->__r_.__value_.__r.__words[0] = 0LL;
    if (buf[23] >= 0) {
      xpc_activity_state_t v6 = buf;
    }
    else {
      xpc_activity_state_t v6 = *(_BYTE **)buf;
    }
    *(void *)(a1 + 480) = -[CLHRequestArchive initWithDirectory:itemCountThresholdForAutoCleanUp:]( v3,  "initWithDirectory:itemCountThresholdForAutoCleanUp:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v6),  500LL);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
    [*(id *)(a1 + 480) setRotationInterval:-1.0];
    xpc_object_t v7 = (id *)(a1 + 480);
    sub_10056369C(a1, *(void *)(a1 + 480), a1 + 440);
    double Current = CFAbsoluteTimeGetCurrent();
    id v9 = objc_alloc_init(&OBJC_CLASS___CLPLocationConsumptionScoreInfo);
    [v9 setClientKey:@"com.apple.locationd.all-location-clients-stop"];
    [v9 setStopTime:Current];
    [v9 setScore:0];
    [*v7 writeSecondaryObject:v9 toField:1];
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLPLocationConsumptionScoreInfo doesn't exist in this platform.}",  buf,  0x12u);
    }
  }

void sub_100564878( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

NSDate *sub_1005648B4(uint64_t a1, uint64_t a2)
{
  id v3 = objc_msgSend( *(id *)(a1 + 136),  "dictionaryForKey:atKeyPath:defaultValue:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_101936DD8),  a2,  0);
  if (!v3)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v7 = qword_101934988;
    if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG)) {
      return 0LL;
    }
    int v13 = 68289282;
    int v14 = 0;
    __int16 v15 = 2082;
    __int16 v16 = "";
    __int16 v17 = 2114;
    uint64_t v18 = a2;
    id v8 = "{msg%{public}.0s:#luHistorical TranscriptSession not found - fetching dateIntervals, Client:%{publi"
         "c, location:escape_only}@}";
    id v9 = (os_log_s *)v7;
    os_log_type_t v10 = OS_LOG_TYPE_DEBUG;
    goto LABEL_15;
  }

  id v4 = [v3 objectForKeyedSubscript:@"startDate"];
  if (!v4)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v11 = qword_101934988;
    if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
      return 0LL;
    }
    int v13 = 68289282;
    int v14 = 0;
    __int16 v15 = 2082;
    __int16 v16 = "";
    __int16 v17 = 2114;
    uint64_t v18 = a2;
    id v8 = "{msg%{public}.0s:#luHistorical transcriptStartDate not found, Client:%{public, location:escape_only}@}";
    id v9 = (os_log_s *)v11;
    os_log_type_t v10 = OS_LOG_TYPE_DEFAULT;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v9, v10, v8, (uint8_t *)&v13, 0x1Cu);
    return 0LL;
  }

  [v4 doubleValue];
  __int128 v5 = +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:");
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  xpc_activity_state_t v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 68289538;
    int v14 = 0;
    __int16 v15 = 2082;
    __int16 v16 = "";
    __int16 v17 = 2114;
    uint64_t v18 = a2;
    __int16 v19 = 2114;
    uint64_t v20 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#luHistorical transcriptStartDate, Client:%{public, location:escape_only}@, startDa te:%{public, location:escape_only}@}",  (uint8_t *)&v13,  0x26u);
  }

  return v5;
}

void sub_100564B38(uint64_t a1, void *a2)
{
  id v3 = (char *)[a2 count];
  id v4 = v3 - 2;
  if ((unint64_t)v3 >= 2)
  {
    __int128 v5 = v3 - 1;
    id v6 = [a2 objectAtIndexedSubscript:v4];
    id v14 = [a2 objectAtIndexedSubscript:v5];
    objc_msgSend(objc_msgSend(v6, "endDate"), "timeIntervalSinceReferenceDate");
    double v8 = v7;
    objc_msgSend(objc_msgSend(v14, "startDate"), "timeIntervalSinceReferenceDate");
    if (v8 >= v9)
    {
      objc_msgSend(objc_msgSend(v6, "startDate"), "timeIntervalSinceReferenceDate");
      os_log_type_t v10 = +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:");
      objc_msgSend(objc_msgSend(v6, "endDate"), "timeIntervalSinceReferenceDate");
      double v12 = v11;
      objc_msgSend(objc_msgSend(v14, "endDate"), "timeIntervalSinceReferenceDate");
      if (v12 < v13)
      {
        objc_msgSend(objc_msgSend(v14, "endDate"), "timeIntervalSinceReferenceDate");
        objc_msgSend( a2,  "replaceObjectAtIndex:withObject:",  v4,   -[NSDateInterval initWithStartDate:endDate:]( [NSDateInterval alloc],  "initWithStartDate:endDate:",  v10,  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( NSDate,  "dateWithTimeIntervalSinceReferenceDate:")));
      }

      [a2 removeObjectAtIndex:v5];
    }
  }

void sub_100564C90(uint64_t a1, double a2, double a3)
{
  if ((unint64_t)[*(id *)(a1 + 32) count] > *(int *)(*(void *)(*(void *)(a1 + 48) + 8)
                                                                          + 24LL)
    && (id v6 = objc_msgSend(*(id *)(a1 + 32), "objectAtIndexedSubscript:")) != 0
    && (id v7 = v6, objc_msgSend(objc_msgSend(v6, "startDate"), "timeIntervalSinceReferenceDate"), v8 <= a2))
  {
    id v9 = [*(id *)(a1 + 40) addObject:v7];
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  }

  else
  {
    id v9 = objc_msgSend( *(id *)(a1 + 40),  "addObject:",   -[NSDateInterval initWithStartDate:endDate:]( [NSDateInterval alloc],  "initWithStartDate:endDate:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  a2),  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  a3)));
  }

  sub_100564B38((uint64_t)v9, *(void **)(a1 + 40));
}

id sub_100564D78(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 136) primaryKeyPathForAuthLimitedKeyPath:a2];
}

id sub_100564D84(uint64_t a1, void *a2)
{
  if ([*(id *)(a1 + 136) hasValueForKey:@"isHarvestableSystemService" atKeyPath:a2]) {
    return [*(id *)(a1 + 136) BOOLForKey:@"isHarvestableSystemService" atKeyPath:a2 defaultValue:0];
  }
  __int128 v5 = (const __CFString *)[a2 bundlePath];
  if (!v5) {
    return 0LL;
  }
  BOOL v6 = sub_1002967F4(v5);
  [*(id *)(a1 + 136) setBool:v6 forKey:@"isHarvestableSystemService" atKeyPath:a2];
  return (id)v6;
}

id sub_100564E24(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 136) dataForKey:@"ClientStorageToken" atKeyPath:a2 defaultValue:0];
}

NSMutableData *sub_100564E40(uint64_t a1, uint64_t a2)
{
  id v4 = (NSMutableData *)[*(id *)(a1 + 136) dataForKey:@"ClientStorageToken" atKeyPath:a2 defaultValue:0];
  if (!v4)
  {
    id v4 = -[NSMutableData initWithLength:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithLength:", 32LL);
    if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, -[NSMutableData mutableBytes](v4, "mutableBytes"))) {
      sub_10123DC68();
    }
    [*(id *)(a1 + 136) setData:v4 forKey:@"ClientStorageToken" atKeyPath:a2];
  }

  return v4;
}

void sub_100564EF4(uint64_t a1, void *a2, int a3)
{
  id v4 = a2;
  if ([a2 website]) {
    id v4 = [v4 anchorKeyPath];
  }
  unsigned int v6 = [*(id *)(a1 + 136) BOOLForKey:@"SuppressShowingInSettings" atKeyPath:v4 defaultValue:0];
  [*(id *)(a1 + 136) removeValueForKey:@"SuppressShowingInSettings" atKeyPath:v4];
  [*(id *)(a1 + 136) setBool:1 forKey:@"Registered" atKeyPath:v4];
  if (v6)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2114;
      id v18 = v4;
      __int16 v19 = 1026;
      int v20 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Client will now show up in settings, Client:%{public, location:escape_only}@, sho uldSync:%{public}hhd}",  buf,  0x22u);
    }

    if (a3)
    {
      sub_1004F2598();
      if (sub_1004F7500() || (sub_1004F2598(), sub_1001B9A1C()))
      {
        id v8 = [*(id *)(a1 + 136) intForKey:@"Authorization" atKeyPath:v4 defaultValue:0];
        unsigned int v9 = [*(id *)(a1 + 136) intForKey:@"CorrectiveCompensationEnabled" atKeyPath:v4 defaultValue:0];
        os_log_type_t v10 = (char *)objc_msgSend(objc_msgSend(v4, "legacyClientKey"), "UTF8String");
        if (v10) {
          double v11 = v10;
        }
        else {
          double v11 = "";
        }
        sub_1010DDBC0(buf, v11);
        sub_1010DDBC0(__p, "ShowingClientInSettings");
        sub_10056517C( a1,  (uint64_t)buf,  0LL,  (uint64_t)v8,  v9 | (unint64_t)&_mh_execute_header,  0LL,  (uint64_t *)__p);
        if (v13 < 0) {
          operator delete(__p[0]);
        }
        if (SBYTE3(v18) < 0) {
          operator delete(*(void **)buf);
        }
      }
    }
  }

void sub_100565140( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056517C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  if (!sub_1004F7500())
  {
    sub_1004F2598();
  }

  uint64_t v14 = a3 ? 0LL : a6;
  __int16 v15 = sub_10056A300(a1, (uint64_t *)a2, v14, 1LL);
  if (!v15) {
    return;
  }
  __int16 v16 = v15;
  if (a3)
  {
    int v34 = BYTE4(a5);
    uint64_t v35 = a2;
    uint64_t v36 = a5;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int16 v17 = -[CLCompanionSyncAuthObject interestZones](v15, "interestZones");
    id v18 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v37,  v57,  16LL);
    if (v18)
    {
      id v19 = v18;
      unsigned int v32 = a4;
      unsigned int v33 = a6;
      uint64_t v20 = *(void *)v38;
LABEL_10:
      uint64_t v21 = 0LL;
      while (1)
      {
        if (*(void *)v38 != v20) {
          objc_enumerationMutation(v17);
        }
        int v22 = *(CLCompanionSyncAuthObject **)(*((void *)&v37 + 1) + 8 * v21);
        if (objc_msgSend( -[CLCompanionSyncAuthObject zoneIdentifier](v22, "zoneIdentifier"),  "isEqualToString:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a3))) {
          break;
        }
        if (v19 == (id)++v21)
        {
          id v19 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v37,  v57,  16LL);
          if (v19) {
            goto LABEL_10;
          }
          int v22 = 0LL;
          break;
        }
      }

      a4 = v32;
      a6 = v33;
    }

    else
    {
      int v22 = 0LL;
    }

    -[CLCompanionSyncAuthObject setClearClient:](v22, "setClearClient:", a6);
    -[CLCompanionSyncAuthObject setAuthMask:](v22, "setAuthMask:", a4);
    a2 = v35;
    a5 = v36;
    int v23 = v34;
    if (!v34) {
      goto LABEL_24;
    }
    __int16 v24 = v22;
    goto LABEL_23;
  }

  -[CLCompanionSyncAuthObject setAuthMask:](v15, "setAuthMask:", a4);
  int v23 = BYTE4(a5);
  if (BYTE4(a5))
  {
    __int16 v24 = v16;
LABEL_23:
    -[CLCompanionSyncAuthObject setCorrectiveCompensationMask:](v24, "setCorrectiveCompensationMask:", a5);
  }

void sub_100565540(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*(_BYTE *)(a1 + 1504)) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = *a3 == 1;
  }
  if (v7)
  {
    int v8 = *(unsigned __int8 *)(a4 + 4);
    *(_BYTE *)(a1 + 1504) = v8;
    if (v8)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      unsigned int v9 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        v10[0] = 68289026;
        v10[1] = 0;
        __int16 v11 = 2082;
        double v12 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#dic rehydration on device first unlock}",  (uint8_t *)v10,  0x12u);
      }

      [*(id *)(*(void *)(a1 + 1496) + 16) unregister:*(void *)(*(void *)(a1 + 1496) + 8) forNotification:1];
      sub_100565668((void *)a1);
    }
  }

void sub_100565668(void *a1)
{
  __int128 __p = 0LL;
  uint64_t v29 = 0LL;
  int v30 = 0LL;
  id v2 = (void *)a1[103];
  id v3 = a1 + 104;
  if (v2 != a1 + 104)
  {
    id v4 = 0LL;
    do
    {
      if (v4 >= v30)
      {
        uint64_t v5 = (v4 - (_BYTE *)__p) >> 3;
        unint64_t v6 = (v30 - (_BYTE *)__p) >> 2;
        if (v6 <= v5 + 1) {
          unint64_t v6 = v5 + 1;
        }
        else {
          unint64_t v7 = v6;
        }
        if (v7) {
          int v8 = (char *)sub_1000071BC((uint64_t)&v30, v7);
        }
        else {
          int v8 = 0LL;
        }
        unsigned int v9 = &v8[8 * v5];
        *(void *)unsigned int v9 = v2[4];
        id v4 = v9 + 8;
        __int16 v11 = (char *)__p;
        os_log_type_t v10 = v29;
        if (v29 != __p)
        {
          do
          {
            uint64_t v12 = *((void *)v10 - 1);
            v10 -= 8;
            *((void *)v9 - 1) = v12;
            v9 -= 8;
          }

          while (v10 != v11);
          os_log_type_t v10 = (char *)__p;
        }

        __int128 __p = v9;
        uint64_t v29 = v4;
        int v30 = &v8[8 * v7];
        if (v10) {
          operator delete(v10);
        }
      }

      else
      {
        *(void *)id v4 = v2[4];
        v4 += 8;
      }

      uint64_t v29 = v4;
      char v13 = (void *)v2[1];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          char v13 = (void *)*v13;
        }

        while (v13);
      }

      else
      {
        do
        {
          uint64_t v14 = (void *)v2[2];
          BOOL v15 = *v14 == (void)v2;
          id v2 = v14;
        }

        while (!v15);
      }

      id v2 = v14;
    }

    while (v14 != v3);
    for (uint64_t i = (CLConnection **)__p; i != (CLConnection **)v4; ++i)
      sub_1005456DC((uint64_t)a1, *i);
  }

  __int16 v17 = (void *)a1[106];
  if (v17 != a1 + 107)
  {
    do
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v18 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = sub_100019240(v17[4]);
        uint64_t v20 = v17[4];
        *(_DWORD *)uint64_t buf = 68289538;
        int v32 = 0;
        __int16 v33 = 2082;
        int v34 = "";
        __int16 v35 = 2114;
        uint64_t v36 = v19;
        __int16 v37 = 2050;
        uint64_t v38 = v20;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#dic triggerRetirement due to rehydration, ClientKeyPath:%{public, location:escap e_only}@, this:%{public}p}",  buf,  0x26u);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      uint64_t v21 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        uint64_t v22 = sub_100019240(v17[4]);
        uint64_t v23 = v17[4];
        *(_DWORD *)uint64_t buf = 68289538;
        int v32 = 0;
        __int16 v33 = 2082;
        int v34 = "";
        __int16 v35 = 2114;
        uint64_t v36 = v22;
        __int16 v37 = 2050;
        uint64_t v38 = v23;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v21,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#dic triggerRetirement due to rehydration",  "{msg%{public}.0s:#dic triggerRetirement due to rehydration, ClientKeyPath:%{public, location:escap e_only}@, this:%{public}p}",  buf,  0x26u);
      }

      sub_100D56908(v17[4]);
      __int16 v24 = (void *)v17[1];
      if (v24)
      {
        do
        {
          unint64_t v25 = v24;
          __int16 v24 = (void *)*v24;
        }

        while (v24);
      }

      else
      {
        do
        {
          unint64_t v25 = (void *)v17[2];
          BOOL v15 = *v25 == (void)v17;
          __int16 v17 = v25;
        }

        while (!v15);
      }

      __int16 v17 = v25;
    }

    while (v25 != a1 + 107);
  }

  __int16 v26 = (void *)a1[17];
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472LL;
  _OWORD v27[2] = sub_100566240;
  v27[3] = &unk_10183F8B0;
  v27[4] = a1;
  [v26 iterateAllAnchorKeyPathsWithBlock:v27];
  if (__p)
  {
    uint64_t v29 = (char *)__p;
    operator delete(__p);
  }

void sub_100565A08( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100565A3C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = sub_10053D6E0(a1, a2);
  id v8 = objc_msgSend( objc_msgSend(a4, "dictionaryForKey:defaultValue:", @"DIC", 0),  "objectForKeyedSubscript:",  -[NSNumber stringValue]( +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a3),  "stringValue"));
  if (v8)
  {
    int v28 = v8;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    id obj = [v8 allKeys];
    id v9 = [obj countByEnumeratingWithState:&v32 objects:v49 count:16];
    if (v9)
    {
      uint64_t v27 = *(void *)v33;
LABEL_4:
      uint64_t v10 = 0LL;
      while (2)
      {
        if (*(void *)v33 != v27) {
          objc_enumerationMutation(obj);
        }
        __int16 v11 = *(void **)(*((void *)&v32 + 1) + 8 * v10);
        id v12 = [v28 objectForKeyedSubscript:v11];
        unsigned int v31 = 0LL;
        char v13 = v12;
        switch((int)a3)
        {
          case 1:
            uint64_t v14 = operator new(0x108uLL);
            sub_1003FEB04((uint64_t)v14, v7, 0LL, v13, a1, *(void *)(a1 + 32));
            goto LABEL_20;
          case 2:
            uint64_t v14 = operator new(0x130uLL);
            sub_100D45D2C(v14, v7, 0LL, v13, a1, *(void *)(a1 + 32));
            goto LABEL_20;
          case 3:
            if (objc_msgSend(objc_msgSend(v12, "objectForKey:", @"SessionActive"), "BOOLValue"))
            {
              uint64_t v14 = operator new(0xC8uLL);
              sub_101023410(v14, v7, 0LL, v13, a1, *(void *)(a1 + 32));
              goto LABEL_20;
            }

            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
            uint64_t v23 = qword_101934988;
            if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_44;
            }
            __int128 __p = (void *)68289538;
            __int16 v37 = 2082;
            uint64_t v38 = "";
            __int16 v39 = 2114;
            id v40 = v7;
            __int16 v41 = 1026;
            int v42 = 3;
            __int16 v16 = (os_log_s *)v23;
            __int16 v17 = "{msg%{public}.0s:#dic CLDaemonBackgroundActivitySession session is not active. Will skip on bein"
                  "g a butterfly, Client:%{public, location:escape_only}@, dicType:%{public}d}";
            goto LABEL_43;
          case 4:
            uint64_t v14 = operator new(0x100uLL);
            sub_100BD5DB0(v14, v7, 0LL, a1, v13, *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 1504));
            goto LABEL_20;
          case 5:
            uint64_t v14 = operator new(0xD0uLL);
            sub_100BD2E80(v14, v7, 0LL, v13, a1, *(void *)(a1 + 32));
            goto LABEL_20;
          case 6:
            if (objc_msgSend(objc_msgSend(v12, "objectForKey:", @"SessionActive"), "BOOLValue"))
            {
              uint64_t v14 = operator new(0xC8uLL);
              sub_100D4CB90(v14, v7, 0LL, v13, a1, *(void *)(a1 + 32));
LABEL_20:
              unsigned int v31 = v14;
              sub_1010DDBC0(&__p, (char *)[v11 UTF8String]);
              sub_1005450B8(a1, (uint64_t)v7, (uint64_t *)&__p, a3, 0LL, 0);
              if (SBYTE3(v40) < 0) {
                operator delete(__p);
              }
              sub_1010DDBC0( v29,  (char *)-[NSString UTF8String]( +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%p", v31),  "UTF8String"));
              id v18 = (void *)(*(uint64_t (**)(void *))(*(void *)v31 + 40LL))(v31);
              sub_1005450B8(a1, (uint64_t)v7, (uint64_t *)v29, a3, v18, 1);
              sub_1001145B0((uint64_t **)(a1 + 848), (unint64_t *)&v31, (uint64_t *)&v31);
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              uint64_t v19 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v20 = v29;
                if (v30 < 0) {
                  uint64_t v20 = (void **)v29[0];
                }
                __int128 __p = (void *)68290306;
                __int16 v37 = 2082;
                uint64_t v38 = "";
                __int16 v39 = 2114;
                id v40 = v7;
                __int16 v41 = 1026;
                int v42 = a3;
                __int16 v43 = 2114;
                int v44 = v11;
                __int16 v45 = 2114;
                int v46 = v13;
                __int16 v47 = 2082;
                int v48 = v20;
                _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#dic rehydrated, Client:%{public, location:escape_only}@, dicType:%{p ublic}d, CreatedFromDIC:%{public, location:escape_only}@, DICDetails:%{public, location:escape _only}@, NewDIC:%{public, location:escape_only}s}",  (uint8_t *)&__p,  0x40u);
                if (qword_101934980 != -1) {
                  dispatch_once(&qword_101934980, &stru_1018401A0);
                }
              }

              uint64_t v21 = (os_log_s *)qword_101934988;
              if (os_signpost_enabled((os_log_t)qword_101934988))
              {
                uint64_t v22 = v29;
                if (v30 < 0) {
                  uint64_t v22 = (void **)v29[0];
                }
                __int128 __p = (void *)68290306;
                __int16 v37 = 2082;
                uint64_t v38 = "";
                __int16 v39 = 2114;
                id v40 = v7;
                __int16 v41 = 1026;
                int v42 = a3;
                __int16 v43 = 2114;
                int v44 = v11;
                __int16 v45 = 2114;
                int v46 = v13;
                __int16 v47 = 2082;
                int v48 = v22;
                _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v21,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#dic rehydrated",  "{msg%{public}.0s:#dic rehydrated, Client:%{public, location:escape_only}@, dicType:%{p ublic}d, CreatedFromDIC:%{public, location:escape_only}@, DICDetails:%{public, location:escape _only}@, NewDIC:%{public, location:escape_only}s}",  (uint8_t *)&__p,  0x40u);
              }

              if (v30 < 0) {
                operator delete(v29[0]);
              }
            }

            else
            {
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              uint64_t v24 = qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
              {
                __int128 __p = (void *)68289538;
                __int16 v37 = 2082;
                uint64_t v38 = "";
                __int16 v39 = 2114;
                id v40 = v7;
                __int16 v41 = 1026;
                int v42 = 6;
                __int16 v16 = (os_log_s *)v24;
                __int16 v17 = "{msg%{public}.0s:#dic CLDaemonServiceSession session is not active. Will skip on being a but"
                      "terfly, Client:%{public, location:escape_only}@, dicType:%{public}d}";
LABEL_43:
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&__p, 0x22u);
              }
            }

void sub_1005661D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, int a38, __int16 a39, char a40, char a41)
{
}

id sub_100566240(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void **)(v2 + 136);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_10056629C;
  v5[3] = &unk_10183F900;
  v5[4] = v2;
  return [v3 iterateIdentitiesRelatedToKeyPath:a2 withBlock:v5];
}

void sub_10056629C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v4 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    int v11 = 68289282;
    int v12 = 0;
    __int16 v13 = 2082;
    uint64_t v14 = "";
    __int16 v15 = 2114;
    uint64_t v16 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#dic #rehydration started, Client:%{public, location:escape_only}@}",  (uint8_t *)&v11,  0x1Cu);
  }

  if ([*(id *)(v3 + 136) hasValueForKey:@"DIC" atKeyPath:a2])
  {
    id v5 = [*(id *)(v3 + 136) readonlyStoreAtKeyPath:a2];
    sub_100565A3C(v3, a2, 3LL, v5);
    sub_100565A3C(v3, a2, 1LL, v5);
    sub_100565A3C(v3, a2, 2LL, v5);
    sub_100565A3C(v3, a2, 4LL, v5);
    sub_100565A3C(v3, a2, 6LL, v5);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v6 = qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 68289282;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 2114;
      uint64_t v16 = a2;
      id v7 = "{msg%{public}.0s:#dic #rehydration completed, Client:%{public, location:escape_only}@}";
      id v8 = (os_log_s *)v6;
      os_log_type_t v9 = OS_LOG_TYPE_DEFAULT;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v8, v9, v7, (uint8_t *)&v11, 0x1Cu);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v10 = qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      int v11 = 68289282;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 2114;
      uint64_t v16 = a2;
      id v7 = "{msg%{public}.0s:skip #rehydration No #dic, Client:%{public, location:escape_only}@}";
      id v8 = (os_log_s *)v10;
      os_log_type_t v9 = OS_LOG_TYPE_DEBUG;
      goto LABEL_14;
    }
  }

void sub_100566538(uint64_t a1, void *a2, int a3, int a4, int a5, int a6, int a7)
{
  if ((a3 & 1) != 0 || (a4 & 1) != 0 || (a5 & 1) != 0 || a6)
  {
    sub_1010DDBC0(__p, (char *)objc_msgSend(objc_msgSend(a2, "clientAnchor"), "UTF8String"));
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v14 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v15 = __p;
      if (v59 < 0) {
        __int16 v15 = (void **)__p[0];
      }
      *(_DWORD *)uint64_t buf = 68290818;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v61 = 2082;
      __int16 v62 = "";
      __int16 v63 = 2114;
      int v64 = (void **)a2;
      __int16 v65 = 2082;
      __int128 v66 = (const char *)v15;
      __int16 v67 = 1026;
      *(_DWORD *)__int128 v68 = a3;
      *(_WORD *)&v68[4] = 1026;
      *(_DWORD *)&v68[6] = a4;
      __int16 v69 = 1026;
      int v70 = a5;
      __int16 v71 = 1026;
      int v72 = a6;
      __int16 v73 = 1026;
      int v74 = a7;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:updating ClientServiceSessionInfo cache, Client:%{public, location:escape_only}@,  anchor:%{public, location:escape_only}s, adjustRefCountForPassiveServiceSession:%{public}hhd, adjustRefC ountForWhenInUseServiceSession:%{public}hhd, adjustRefCountForAlwaysServiceSession:%{public}hhd, adjustR efCountForOldSDKLinking:%{public}hhd, coming:%{public}hhd}",  buf,  0x44u);
    }

    uint64_t v16 = (_DWORD *)sub_10008E8D0(a1 + 1048, (const void **)__p);
    __int16 v17 = (_DWORD *)(a1 + 1056);
    if (a7)
    {
      if (v17 == v16)
      {
        *(void *)uint64_t buf = __p;
        id v18 = sub_1005895A4((uint64_t **)(a1 + 1048), (const void **)__p, (uint64_t)&unk_1012CF090, (__int128 **)buf);
        v18[7] = 0LL;
        v18[8] = 0LL;
      }

      uint64_t v19 = (_DWORD *)sub_10008E8D0(a1 + 1048, (const void **)__p);
      if (a3)
      {
        ++v19[14];
        if (!a4)
        {
LABEL_16:
          if (!a5) {
            goto LABEL_17;
          }
          goto LABEL_39;
        }
      }

      else if (!a4)
      {
        goto LABEL_16;
      }

      ++v19[15];
      if (!a5)
      {
LABEL_17:
        if (!a6)
        {
LABEL_41:
          id v24 = a2;
          unint64_t v25 = *(void **)(a1 + 40);
          v57[0] = _NSConcreteStackBlock;
          v57[1] = 3221225472LL;
          _OWORD v57[2] = sub_1005673F8;
          void v57[3] = &unk_10181FA90;
          v57[4] = v24;
          v57[5] = a1;
          [v25 async:v57];
          if (v59 < 0) {
            operator delete(__p[0]);
          }
          return;
        }

void sub_1005673C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005673F8(uint64_t a1)
{
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  sub_1010DDBC0(__p, "");
  sub_100544214(v2, v3, (uint64_t)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100567460( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056747C(uint64_t a1, uint64_t a2, void *a3)
{
  if ([*(id *)(a1 + 136) hasValueForKey:@"SubIdentities" atKeyPath:a2])
  {
    if ([a3 objectForKeyedSubscript:@"RemoteUsage"])
    {
      id v4 = [a3 objectForKeyedSubscript:@"RemoteUsage"];
      id v5 = [v4 allKeys];
      __int128 v34 = 0u;
      __int128 v35 = 0u;
      __int128 v36 = 0u;
      __int128 v37 = 0u;
      id v6 = [v5 countByEnumeratingWithState:&v34 objects:v38 count:16];
      if (v6)
      {
        uint64_t v7 = *(void *)v35;
        do
        {
          for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v35 != v7) {
              objc_enumerationMutation(v5);
            }
            uint64_t v9 = *(void *)(*((void *)&v34 + 1) + 8LL * (void)i);
            id v10 = [v4 objectForKeyedSubscript:v9];
            uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSArray);
            if ((objc_opt_isKindOfClass(v10, v11) & 1) != 0) {
              objc_msgSend( objc_msgSend(a3, "objectForKeyedSubscript:", @"RemoteUsage"),  "setObject:forKeyedSubscript:",  objc_msgSend(objc_msgSend(v4, "objectForKeyedSubscript:", v9), "objectAtIndexedSubscript:", 1),  v9);
            }
          }

          id v6 = [v5 countByEnumeratingWithState:&v34 objects:v38 count:16];
        }

        while (v6);
      }
    }

    uint64_t v12 = 0LL;
    while (1)
    {
      __int128 v33 = 0uLL;
      sub_100547724(v12, (void *)&v33 + 1, (__CFString **)&v33);
      uint64_t v14 = *((void *)&v33 + 1);
      uint64_t v13 = v33;
      if (v33 != 0) {
        break;
      }
LABEL_20:
      if (++v12 == 21) {
        return;
      }
    }

    uint64_t v29 = 0LL;
    char v30 = &v29;
    uint64_t v31 = 0x2020000000LL;
    char v32 = 0;
    uint64_t v25 = 0LL;
    __int16 v26 = &v25;
    uint64_t v27 = 0x2020000000LL;
    char v28 = 0;
    uint64_t v21 = 0LL;
    int v22 = (double *)&v21;
    uint64_t v23 = 0x2020000000LL;
    uint64_t v24 = 0x7FEFFFFFFFFFFFFFLL;
    uint64_t v17 = 0LL;
    id v18 = (double *)&v17;
    uint64_t v19 = 0x2020000000LL;
    unint64_t v20 = 0xBFF0000000000000LL;
    objc_msgSend(*(id *)(a1 + 136), "iterateIdentitiesRelatedToKeyPath:withBlock:");
    if (*((_BYTE *)v30 + 24))
    {
      __int16 v15 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v22[3]);
    }

    else
    {
      if (!*((_BYTE *)v26 + 24))
      {
LABEL_19:
        _Block_object_dispose(&v17, 8);
        _Block_object_dispose(&v21, 8);
        _Block_object_dispose(&v25, 8);
        _Block_object_dispose(&v29, 8);
        goto LABEL_20;
      }

      __int16 v15 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v18[3]);
      uint64_t v14 = v13;
    }

    [a3 setObject:v15 forKeyedSubscript:v14];
    goto LABEL_19;
  }

void sub_100567778( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35)
{
}

void sub_1005677BC(void *a1, void *a2)
{
  uint64_t v4 = a1[9];
  id v5 = objc_autoreleasePoolPush();
  if (([a2 isEqual:a1[4]] & 1) == 0
    && +[CLAuthorizationDatabase keyPath:sharesAuthWithKeyPath:]( &OBJC_CLASS___CLAuthorizationDatabase,  "keyPath:sharesAuthWithKeyPath:",  a2,  a1[4]))
  {
    id v6 = [*(id *)(v4 + 136) readonlyStoreAtKeyPath:a2];
    [v6 doubleForKey:a1[10] defaultValue:-1.0];
    double v8 = v7;
    [v6 doubleForKey:a1[11] defaultValue:-1.0];
    if (v8 == -1.0)
    {
      if (v9 != -1.0)
      {
        *(_BYTE *)(*(void *)(a1[7] + 8LL) + 24LL) = 1;
        uint64_t v11 = *(void *)(a1[8] + 8LL);
      }
    }

    else
    {
      *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = 1;
      uint64_t v10 = *(void *)(a1[6] + 8LL);
    }
  }

  objc_autoreleasePoolPop(v5);
}

void sub_1005678BC(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Running #AuthDatabaseMigration_7", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    v9[0] = 0;
    id v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "Running #AuthDatabaseMigration_7",  v9,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::migrateAuthDatabase_7()", "%s\n", v5);
  }

  uint64_t v3 = *(void **)(a1 + 136);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  _DWORD v8[2] = sub_100567BB0;
  v8[3] = &unk_10183F8B0;
  void v8[4] = a1;
  [v3 iterateAllAnchorKeyPathsWithBlock:v8];
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v4 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Finished #AuthDatabaseMigration_7", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    v9[0] = 0;
    LODWORD(v7) = 2;
    id v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "Finished #AuthDatabaseMigration_7",  v9,  v7);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::migrateAuthDatabase_7()", "%s\n", v6);
  }

id sub_100567BB0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 136);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100567C0C;
  v5[3] = &unk_10183F900;
  v5[4] = v2;
  return [v3 iterateIdentitiesRelatedToKeyPath:a2 withBlock:v5];
}

id sub_100567C0C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  unsigned int v4 = [*(id *)(v3 + 136) intForKey:@"SupportedAuthorizationMask" atKeyPath:a2 defaultValue:0];
  if ((v4 & 6) == 4)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v35 = 2082;
      __int128 v36 = "";
      __int16 v37 = 2114;
      uint64_t v38 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#AuthDatabaseMigration client's authorization mask contains Always but not WhenInUse,  Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    [*(id *)(v3 + 136) setInt:v4 | 2 forKey:@"SupportedAuthorizationMask" atKeyPath:a2];
  }

  unsigned int v6 = [*(id *)(v3 + 136) hasValueForKey:@"Authorized" atKeyPath:a2];
  unsigned __int8 v7 = [*(id *)(v3 + 136) hasValueForKey:@"Authorization" atKeyPath:a2];
  if (v6 && (v7 & 1) == 0)
  {
    if ([*(id *)(v3 + 136) BOOLForKey:@"Authorized" atKeyPath:a2 defaultValue:0])
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      double v8 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v35 = 2082;
        __int128 v36 = "";
        __int16 v37 = 2114;
        uint64_t v38 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#AuthDatabaseMigration AuthMigrate: Y => Always, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      }

      unint64_t v9 = 4LL;
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v10 = (os_log_s *)qword_101934988;
      unint64_t v9 = 1LL;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v35 = 2082;
        __int128 v36 = "";
        __int16 v37 = 2114;
        uint64_t v38 = a2;
        unint64_t v9 = 1LL;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#AuthDatabaseMigration AuthMigrate: N => Never, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      }
    }

    if (v4)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v11 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v35 = 2082;
        __int128 v36 = "";
        __int16 v37 = 2114;
        uint64_t v38 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#AuthDatabaseMigration AuthMigrate: Authorization mask already available, Client: %{public, location:escape_only}@}",  buf,  0x1Cu);
      }
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v12 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v35 = 2082;
        __int128 v36 = "";
        __int16 v37 = 2114;
        uint64_t v38 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#AuthDatabaseMigration AuthMigrate: Imputing default supported authorization mask,  Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      }

      [*(id *)(v3 + 136) setInt:7 forKey:@"SupportedAuthorizationMask" atKeyPath:a2];
    }

    if ((sub_10056840C(v3, (uint64_t)a2, v9, 0LL, 0, 1, 1) & 1) == 0)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v13 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v35 = 2082;
        __int128 v36 = "";
        __int16 v37 = 2114;
        uint64_t v38 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#AuthDatabaseMigration Client missing for authorization update, but didn't we just crea te it?, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      uint64_t v14 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v35 = 2082;
        __int128 v36 = "";
        __int16 v37 = 2114;
        uint64_t v38 = a2;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v14,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#AuthDatabaseMigration Client missing for authorization update, but didn't we just create it?",  "{msg%{public}.0s:#AuthDatabaseMigration Client missing for authorization update, but didn't we just crea te it?, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      }
    }
  }

  [*(id *)(v3 + 136) removeValueForKey:@"Authorized" atKeyPath:a2];
  if (([*(id *)(v3 + 136) hasValueForKey:@"RemoteUsage" atKeyPath:a2] & 1) == 0)
  {
    id v15 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    uint64_t v16 = (uint64_t *)"\a";
    do
    {
      __int128 v33 = 0LL;
      *(void *)uint64_t buf = 0LL;
      sub_100547724(*v16, buf, &v33);
      uint64_t v31 = 0LL;
      uint64_t v32 = 0LL;
      sub_100547724(v16[1], &v32, &v31);
      uint64_t v17 = *(void *)buf;
      [*(id *)(v3 + 136) doubleForKey:*(void *)buf atKeyPath:a2 defaultValue:-1.0];
      if (v18 != -1.0)
      {
        uint64_t v19 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
        [v15 setObject:v19 forKeyedSubscript:v32];
        [*(id *)(v3 + 136) removeValueForKey:v17 atKeyPath:a2];
      }

      unint64_t v20 = v33;
      [*(id *)(v3 + 136) doubleForKey:v33 atKeyPath:a2 defaultValue:-1.0];
      if (v21 != -1.0)
      {
        int v22 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
        [v15 setObject:v22 forKeyedSubscript:v31];
        [*(id *)(v3 + 136) removeValueForKey:v20 atKeyPath:a2];
      }

      v16 += 2;
    }

    while (v16 != qword_1012F0BB0);
    if ([v15 count]) {
      [*(id *)(v3 + 136) setDictionary:v15 forKey:@"RemoteUsage" atKeyPath:a2];
    }
  }

  if ([a2 website])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v23 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      id v24 = [*(id *)(v3 + 136) readonlyStoreAtKeyPath:a2];
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v35 = 2082;
      __int128 v36 = "";
      __int16 v37 = 2114;
      uint64_t v38 = a2;
      __int16 v39 = 2114;
      id v40 = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthDatabaseMigration found website. Removing from database, client:%{public, loca tion:escape_only}@, dictionary:%{public, location:escape_only}@}",  buf,  0x26u);
    }

    [*(id *)(v3 + 136) removeDictionaryAtKeyPath:a2];
  }

  unsigned int v25 = [*(id *)(v3 + 136) hasValueForKey:@"Registered" atKeyPath:a2];
  unsigned __int8 v26 = [*(id *)(v3 + 136) hasValueForKey:@"Authorization" atKeyPath:a2];
  unsigned int v27 = [*(id *)(v3 + 136) hasValueForKey:@"SupportedAuthorizationMask" atKeyPath:a2];
  unsigned __int8 v28 = [*(id *)(v3 + 136) isKeyPathRegisteredSystemService:a2];
  uint64_t v29 = *(void **)(v3 + 136);
  if ((v26 & 1) != 0 || (v25 & v27 & 1) != 0 || (v28 & 1) != 0)
  {
    [v29 removeValueForKey:@"SuppressShowingInSettings" atKeyPath:a2];
    return [*(id *)(v3 + 136) setBool:1 forKey:@"Registered" atKeyPath:a2];
  }

  else
  {
    [v29 setBool:1 forKey:@"SuppressShowingInSettings" atKeyPath:a2];
    return [*(id *)(v3 + 136) removeValueForKey:@"Registered" atKeyPath:a2];
  }

uint64_t sub_10056840C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  if (a5)
  {
    id v12 = sub_1005486B8(a1, a2);
  }

  else
  {
    id v12 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
    uint64_t result = (uint64_t)[v12 isValidCKP];
    if (!(_DWORD)result) {
      return result;
    }
  }

  if ([v12 zoneId])
  {
    if (([*(id *)(a1 + 136) dictionaryExistsAtKeyPath:v12] & 1) == 0)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v14 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2114;
        *(void *)&buf[20] = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Zone not found - adding zone under client., Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      id v15 = (os_log_s *)qword_101934988;
      uint64_t result = os_signpost_enabled((os_log_t)qword_101934988);
      if ((_DWORD)result)
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2114;
        *(void *)&buf[20] = v12;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Zone not found - adding zone under client.",  "{msg%{public}.0s:Zone not found - adding zone under client., Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
        return 0LL;
      }

      return result;
    }
  }

  else if ([v12 website] {
         && ([*(id *)(a1 + 136) dictionaryExistsAtKeyPath:v12] & 1) == 0)
  }
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v16 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2114;
      *(void *)&buf[20] = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:website not found - added website subIdentity under client., Client:%{public, locat ion:escape_only}@}",  buf,  0x1Cu);
    }
  }

  signed int v17 = [*(id *)(a1 + 136) intForKey:@"Authorization" atKeyPath:v12 defaultValue:0];
  int v38 = objc_msgSend(*(id *)(a1 + 136), "intForKey:atKeyPath:defaultValue:");
  unint64_t v18 = v17;
  if (v17 != a3) {
    sub_100564EF4(a1, v12, 0);
  }
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v19 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68291074;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 2114;
    *(void *)&buf[20] = v12;
    __int16 v46 = 1026;
    *(_DWORD *)__int16 v47 = v17;
    *(_WORD *)&v47[4] = 2050;
    *(void *)&v47[6] = a3;
    __int16 v48 = 1026;
    int v49 = v38;
    __int16 v50 = 1026;
    int v51 = a4;
    __int16 v52 = 1026;
    int v53 = a7;
    __int16 v54 = 1026;
    int v55 = a6;
    __int16 v56 = 1026;
    BOOL v57 = v17 != a3;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:update client authorization mask, Client:%{public, location:escape_only}@, old:%{ public}d, new:%{public}lu, oldCC:%{public}d, newCC:%{public}d, localAuthorizationChange:%{public}d , mayIncreaseAuth:%{public}hhd, authStateHasChanged:%{public}hhd}",  buf,  0x4Au);
  }

  if (![v12 zoneId] && !objc_msgSend(v12, "website"))
  {
    if (a3)
    {
      id v21 = [*(id *)(a1 + 136) intForKey:@"SupportedAuthorizationMask" atKeyPath:v12 defaultValue:1];
      if ((a3 & ~(uint64_t)(int)v21) != 0)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        int v22 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 134349570;
          *(void *)&uint8_t buf[4] = a3;
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v12;
          *(_WORD *)&buf[22] = 1026;
          *(_DWORD *)&buf[24] = (_DWORD)v21;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#warning New authMask %{public}lu for client %{public}@ implicitly extends its supported mask (%{public}d) u ntil next connection & slide",  buf,  0x1Cu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          int v39 = 134349570;
          unint64_t v40 = a3;
          __int16 v41 = 2114;
          id v42 = v12;
          __int16 v43 = 1026;
          int v44 = (int)v21;
          __int16 v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#warning New authMask %{public}lu for client %{public}@ implicitly extends its supported mask (%{public}d) until next connection & slide",  &v39,  28);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::updateStaticAuthorizationMaskForClientWithCompensation(CLClientKeyPath *, CLLocationDi ctionaryUtilitiesAuthorizationMask, CLClientCorrectiveCompensation, BOOL, BOOL, BOOL, BOOL)",  "%s\n",  v37);
          if (v37 != buf) {
            free(v37);
          }
        }

        id v21 = (id)(v21 | a3);
      }

      if (a3 != 2) {
        sub_10057D7A4(a1, (uint64_t)v12, 1, a3 == 4);
      }
      goto LABEL_28;
    }

    sub_10057D7A4(a1, (uint64_t)v12, 1, 0);
LABEL_48:
    unsigned int v23 = [*(id *)(a1 + 136) isKeyPathRegisteredSystemService:v12];
    unsigned int v24 = v23;
    if (v17)
    {
      if (v23)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        unsigned int v25 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)uint64_t buf = 68289282;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&_BYTE buf[18] = 2114;
          *(void *)&buf[20] = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#ClearingAuthorization for System Service!, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
        }

        unsigned __int8 v26 = (os_log_s *)qword_101934988;
        if (os_signpost_enabled((os_log_t)qword_101934988))
        {
          *(_DWORD *)uint64_t buf = 68289282;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&_BYTE buf[18] = 2114;
          *(void *)&buf[20] = v12;
          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v26,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#ClearingAuthorization for System Service!",  "{msg%{public}.0s:#ClearingAuthorization for System Service!, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
        }

        goto LABEL_66;
      }

      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v30 = qword_101934988;
      if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_66;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2114;
      *(void *)&buf[20] = v12;
      __int16 v46 = 1026;
      *(_DWORD *)__int16 v47 = v17;
      unsigned __int8 v28 = "{msg%{public}.0s:#ClearingAuthorization updateStaticAuthorizationMask setting to not-determined, c"
            "lient:%{public, location:escape_only}@, oldAuth:%{public}d}";
      uint64_t v29 = (os_log_s *)v30;
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v27 = qword_101934988;
      if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_66;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2114;
      *(void *)&buf[20] = v12;
      __int16 v46 = 1026;
      *(_DWORD *)__int16 v47 = v24;
      unsigned __int8 v28 = "{msg%{public}.0s:#ClearingAuthorization updateStaticAuthorizationMask setting to not-determined, but i"
            "t's already set to not-determined., Client:%{public, location:escape_only}@, SystemService:%{public}hhd}";
      uint64_t v29 = (os_log_s *)v27;
    }

    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v28, buf, 0x22u);
LABEL_66:
    [*(id *)(a1 + 136) removeValueForKey:@"Authorization" atKeyPath:v12];
    a3 = 0LL;
    goto LABEL_67;
  }

  if (!a3) {
    goto LABEL_48;
  }
LABEL_28:
  if (v18 >= a3 || a6)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unint64_t v20 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2114;
      *(void *)&buf[20] = v12;
      __int16 v46 = 2050;
      *(void *)__int16 v47 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:setting authorization value, Client:%{public, location:escape_only}@, newAuth:%{public}lu}",  buf,  0x26u);
    }

    [*(id *)(a1 + 136) setInt:a3 forKey:@"Authorization" atKeyPath:v12];
    a3 = (int)[*(id *)(a1 + 136) intForKey:@"Authorization" atKeyPath:v12 defaultValue:0];
  }

void sub_1005690F4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100569118(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Running #AuthDatabaseMigration_9", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    v9[0] = 0;
    id v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "Running #AuthDatabaseMigration_9",  v9,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::migrateAuthDatabase_9()", "%s\n", v5);
  }

  uint64_t v3 = *(void **)(a1 + 136);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  _DWORD v8[2] = sub_100569414;
  v8[3] = &unk_10183F8B0;
  void v8[4] = a1;
  [v3 iterateAllAnchorKeyPathsWithBlock:v8];
  sub_10055570C(a1);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  unsigned int v4 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Finished #AuthDatabaseMigration_9", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    v9[0] = 0;
    LODWORD(v7) = 2;
    unsigned int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "Finished #AuthDatabaseMigration_9",  v9,  v7);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::migrateAuthDatabase_9()", "%s\n", v6);
  }

id sub_100569414(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if ([a2 executablePath])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v4 = qword_101934988;
    if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
      return objc_msgSend(*(id *)(v3 + 136), "removeDictionaryAtKeyPath:", a2, v12, *(_OWORD *)v13, *(_OWORD *)&v13[16]);
    }
    *(_DWORD *)uint64_t buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 2114;
    *(void *)&buf[20] = a2;
    id v5 = "{msg%{public}.0s:Removing executable client from authdb, Client:%{public, location:escape_only}@}";
    unsigned int v6 = buf;
    uint64_t v7 = (os_log_s *)v4;
    uint32_t v8 = 28;
LABEL_6:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v5, v6, v8);
    return objc_msgSend(*(id *)(v3 + 136), "removeDictionaryAtKeyPath:", a2, v12, *(_OWORD *)v13, *(_OWORD *)&v13[16]);
  }

  id result = [a2 bundleId];
  if (result)
  {
    memset(buf, 0, 41);
    id result = [*(id *)(v3 + 136) expensivelyGetIdentifyingInformation:buf forClient:a2];
    if ((_DWORD)result)
    {
      id v10 = [a2 bundleId];
      id result = [v10 isEqual:*(void *)buf];
      if ((result & 1) == 0)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v11 = qword_101934988;
        if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT)) {
          return objc_msgSend( *(id *)(v3 + 136),  "removeDictionaryAtKeyPath:",  a2,  v12,  *(_OWORD *)v13,  *(_OWORD *)&v13[16]);
        }
        uint64_t v12 = 68289538LL;
        *(_WORD *)uint64_t v13 = 2082;
        *(void *)&_OWORD v13[2] = "";
        *(_WORD *)&v13[10] = 2114;
        *(void *)&void v13[12] = [a2 bundleId];
        *(_WORD *)&v13[20] = 2114;
        *(void *)&v13[22] = *(void *)buf;
        id v5 = "{msg%{public}.0s:#Warning found alternative identity as top-level identity authdb. Removing client fr"
             "om authdb, ExistingClientBundleId:%{public, location:escape_only}@, CanonicalizedBundleId:%{publi"
             "c, location:escape_only}@}";
        unsigned int v6 = (uint8_t *)&v12;
        uint64_t v7 = (os_log_s *)v11;
        uint32_t v8 = 38;
        goto LABEL_6;
      }
    }
  }

  return result;
}

id sub_100569604(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  v32[0] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/PrivateFrameworks/Weather.framework",  112LL);
  v33[0] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"com.apple.weather",  105LL);
  v32[1] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"com.apple.Shoebox",  105LL);
  v33[1] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/PrivateFrameworks/PassKitCore.framework",  112LL);
  v32[2] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"com.apple.Passbook",  105LL);
  _OWORD v33[2] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/PrivateFrameworks/PassKitCore.framework",  112LL);
  v32[3] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/PrivateFrameworks/Parsec.framework",  112LL);
  v33[3] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/PrivateFrameworks/CoreParsec.framework",  112LL);
  uint64_t v3 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v33,  v32,  4LL);
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  id v4 = -[NSDictionary countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v24,  v31,  16LL);
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v25;
    do
    {
      for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v25 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void *)(*((void *)&v24 + 1) + 8LL * (void)i);
        if ([*(id *)(a1 + 136) dictionaryExistsAtKeyPath:v8]) {
          objc_msgSend( *(id *)(a1 + 136),  "migrateDictionaryAtKeyPath:toKeyPath:forceMigrationOnAuthCollision:",  v8,  -[NSDictionary objectForKeyedSubscript:](v3, "objectForKeyedSubscript:", v8),  0);
        }
      }

      id v5 = -[NSDictionary countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v24,  v31,  16LL);
    }

    while (v5);
  }

  objc_autoreleasePoolPop(v2);
  unint64_t v9 = objc_autoreleasePoolPush();
  v30[0] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"com.apple.webapp",  105LL);
  v30[1] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"com.apple.AdSheet",  105LL);
  v30[2] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"com.apple.AdSheetPad",  105LL);
  v30[3] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"com.apple.AdSheetPhone",  105LL);
  v30[4] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"com.apple.springboard",  105LL);
  v30[5] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"com.apple.CarPlayApp",  105LL);
  v30[6] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/PrivateFrameworks/Assistant.framework",  112LL);
  v30[7] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/PrivateFrameworks/AOSNotification.framework",  112LL);
  _OWORD v30[8] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/LocationBundles/LocationPerformance.framework",  112LL);
  v30[9] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/LocationBundles/LocationdInternal.framework",  112LL);
  v30[10] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/PrivateFrameworks/iAdCore.framework",  112LL);
  v30[11] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/Applications/AdSheet.app",  112LL);
  v30[12] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/Frameworks/Twitter.framework",  112LL);
  v30[13] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/Frameworks/Weibo.framework",  112LL);
  v30[14] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/Frameworks/Facebook.framework",  112LL);
  v30[15] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/SocialServices/Twitter.socialplugin",  112LL);
  v30[16] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/SocialServices/Weibo.socialplugin",  112LL);
  v30[17] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/SocialServices/Facebook.socialplugin",  112LL);
  v30[18] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/Frameworks/Social.framework/XPCServices/com.apple.twitter.xpc",  112LL);
  v30[19] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/Frameworks/Social.framework/XPCServices/com.apple.weibo.xpc",  112LL);
  v30[20] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/Frameworks/Social.framework/XPCServices/com.apple.facebook.xpc",  112LL);
  v30[21] = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  @"/System/Library/PrivateFrameworks/CoreSuggestions.framework",  112LL);
  id v10 = +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v30, 22LL);
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  id v11 = -[NSArray countByEnumeratingWithState:objects:count:]( v10,  "countByEnumeratingWithState:objects:count:",  &v20,  v29,  16LL);
  if (v11)
  {
    id v12 = v11;
    uint64_t v13 = *(void *)v21;
    do
    {
      for (j = 0LL; j != v12; j = (char *)j + 1)
      {
        if (*(void *)v21 != v13) {
          objc_enumerationMutation(v10);
        }
        uint64_t v15 = *(void *)(*((void *)&v20 + 1) + 8LL * (void)j);
      }

      id v12 = -[NSArray countByEnumeratingWithState:objects:count:]( v10,  "countByEnumeratingWithState:objects:count:",  &v20,  v29,  16LL);
    }

    while (v12);
  }

  objc_autoreleasePoolPop(v9);
  v28[0] = @"AttributionCount";
  v28[1] = @"AuthorizationPurposeKey";
  v28[2] = @"AppSwitcherQuitAppTime";
  v28[3] = @"TrialPeriodBegin";
  v28[4] = @"TrialPeriodNeedsReprompt";
  v28[5] = @"ExistsInLSDatabase";
  uint64_t v16 = +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v28, 6LL);
  signed int v17 = *(void **)(a1 + 136);
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472LL;
  v19[2] = sub_100569B7C;
  float v19[3] = &unk_10183F9D0;
  v19[4] = v16;
  v19[5] = a1;
  return [v17 iterateAllAnchorKeyPathsWithBlock:v19];
}

id sub_100569B7C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  id v4 = *(void **)(v2 + 136);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_100569BD8;
  v6[3] = &unk_10183FB60;
  v6[4] = v3;
  void v6[5] = v2;
  return [v4 iterateIdentitiesRelatedToKeyPath:a2 withBlock:v6];
}

void sub_100569BD8(uint64_t a1, void *a2)
{
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  uint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  id v5 = [v3 countByEnumeratingWithState:&v13 objects:v23 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v14;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v7) {
          objc_enumerationMutation(v3);
        }
        [*(id *)(v4 + 136) removeValueForKey:*(void *)(*((void *)&v13 + 1) + 8 * (void)i) atKeyPath:a2];
      }

      id v6 = [v3 countByEnumeratingWithState:&v13 objects:v23 count:16];
    }

    while (v6);
  }

  id v9 = [a2 bundlePath];
  if (v9)
  {
    id v10 = v9;
    if (-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  v9))
    {
      if ((objc_msgSend(v10, "isEqualToString:", objc_msgSend(v10, "stringByResolvingSymlinksInPath")) & 1) == 0)
      {
        [*(id *)(v4 + 136) removeDictionaryAtKeyPath:a2];
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        id v11 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t buf = 68289282;
          int v18 = 0;
          __int16 v19 = 2082;
          __int128 v20 = "";
          __int16 v21 = 2114;
          __int128 v22 = v10;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthDatabaseMigration Clearing client with symlinks in its bundlePath, BundlePat h:%{public, location:escape_only}@}",  buf,  0x1Cu);
        }
      }
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v12 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        int v18 = 0;
        __int16 v19 = 2082;
        __int128 v20 = "";
        __int16 v21 = 2114;
        __int128 v22 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthDatabaseMigration #warning bundle path does not exist on disk;  clearing., Bun"
          "dlePath:%{public, location:escape_only}@}",
          buf,
          0x1Cu);
      }

      [*(id *)(v4 + 136) removeDictionaryAtKeyPath:a2];
    }
  }

void sub_100569E50(uint64_t a1, uint64_t a2, int a3)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Starting #AuthDatabaseMigration", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    LOWORD(v21[0]) = 0;
    int v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "Starting #AuthDatabaseMigration",  v21,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::setupAndMigrateAuthDatabase(NSString *, BOOL)",  "%s\n",  v18);
  }

  uint64_t v7 =  +[CLAuthorizationDatabase authorizationDatabaseWithFilename:withDataProtectionClass:]( &OBJC_CLASS___CLAuthorizationDatabase,  "authorizationDatabaseWithFilename:withDataProtectionClass:",  a2,  2LL);
  *(void *)(a1 + 136) = v7;
  -[CLAuthorizationDatabase migrationVersionNumber](v7, "migrationVersionNumber");
  float v9 = v8;
  if (v8 < 7.0) {
    sub_1005678BC(a1);
  }
  if (v9 < 9.0) {
    sub_100569118(a1);
  }
  if (v9 < 15.0) {
    int v10 = 1;
  }
  else {
    int v10 = a3;
  }
  if (v10 == 1) {
    sub_100569604(a1);
  }
  sub_1004F2598();
  sub_1004F5A44("kern.bootsessionuuid", buf);
  if (SBYTE3(v26) >= 0) {
    id v11 = buf;
  }
  else {
    id v11 = *(uint8_t **)buf;
  }
  id v12 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v11);
  if (SBYTE3(v26) < 0) {
    operator delete(*(void **)buf);
  }
  v21[0] = 0LL;
  uint64_t v13 = sub_1002F8DDC();
  sub_1002A6F20(v13, (uint64_t)@"kLastBootSessionUUID", v21);
  if (!-[NSString isEqualToString:](v12, "isEqualToString:", v21[0]))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int128 v14 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v23 = 2082;
      __int128 v24 = "";
      __int16 v25 = 2114;
      __int128 v26 = v12;
      __int16 v27 = 2114;
      CFTypeRef v28 = v21[0];
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:First locationd run for boot session, bootSession:%{public, location:escape_only}@, lastSession:%{public, location:escape_only}@}",  buf,  0x26u);
    }

    uint64_t v15 = sub_1002F8DDC();
    sub_1002ACE4C(v15);
    uint64_t v16 = sub_1002F8DDC();
    (*(void (**)(uint64_t))(*(void *)v16 + 944LL))(v16);
    goto LABEL_28;
  }

  if (v10) {
LABEL_28:
  }
    [*(id *)(a1 + 136) performFullSystemServiceSetup];
  [*(id *)(a1 + 136) completeMigration];
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  signed int v17 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Finished #AuthDatabaseMigration", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    LOWORD(v21[0]) = 0;
    LODWORD(v20) = 2;
    __int16 v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "Finished #AuthDatabaseMigration",  v21,  v20);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::setupAndMigrateAuthDatabase(NSString *, BOOL)",  "%s\n",  v19);
  }

void sub_10056A2DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CLCompanionSyncAuthObject *sub_10056A300(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  float v8 = objc_alloc_init(&OBJC_CLASS___CLCompanionSyncAuthObject);
  else {
    float v9 = (uint64_t *)*a2;
  }
  -[CLCompanionSyncAuthObject setClientKey:]( v8,  "setClientKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v9));
  -[CLCompanionSyncAuthObject setClearClient:](v8, "setClearClient:", a3);
  -[CLCompanionSyncAuthObject setOperationType:](v8, "setOperationType:", a4);
  if (*((char *)a2 + 23) < 0)
  {
    if (!a2[1]) {
      return v8;
    }
    a2 = (uint64_t *)*a2;
  }

  else if (!*((_BYTE *)a2 + 23))
  {
    return v8;
  }

  id v10 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2)));
  if (![v10 isValidCKP]
    || ([*(id *)(a1 + 136) BOOLForKey:@"SuppressShowingInSettings" atKeyPath:v10 defaultValue:0] & 1) != 0)
  {
    return 0LL;
  }

  id v11 = [*(id *)(a1 + 136) intForKey:@"Authorization" atKeyPath:v10 defaultValue:0];
  if ((_DWORD)v11) {
    -[CLCompanionSyncAuthObject setAuthMask:](v8, "setAuthMask:", v11);
  }
  id v12 = [*(id *)(a1 + 136) intForKey:@"CorrectiveCompensationEnabled" atKeyPath:v10 defaultValue:0xFFFFFFFFLL];
  uint64_t v13 = *(void **)(a1 + 136);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472LL;
  v15[2] = sub_10056A4AC;
  v15[3] = &unk_10183FB60;
  v15[4] = v8;
  v15[5] = a1;
  [v13 iterateIdentitiesRelatedToKeyPath:v10 withBlock:v15];
  return v8;
}

id sub_10056A4AC(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  id result = [a2 subIdentityType];
  if ((_DWORD)result == 122)
  {
    id v6 = objc_alloc_init(&OBJC_CLASS___CLCompanionSyncInterestZone);
    -[CLCompanionSyncInterestZone setZoneIdentifier:](v6, "setZoneIdentifier:", [a2 zoneId]);
    id v7 = [*(id *)(v4 + 136) intForKey:@"Authorization" atKeyPath:a2 defaultValue:0];
    if ((_DWORD)v7) {
      -[CLCompanionSyncInterestZone setAuthMask:](v6, "setAuthMask:", v7);
    }
    id v8 = [*(id *)(v4 + 136) intForKey:@"CorrectiveCompensationEnabled" atKeyPath:a2 defaultValue:0];
    if ((_DWORD)v8) {
      -[CLCompanionSyncInterestZone setCorrectiveCompensationMask:](v6, "setCorrectiveCompensationMask:", v8);
    }
    id v9 = [*(id *)(v4 + 136) intForKey:@"Type" atKeyPath:a2 defaultValue:0];
    if ((_DWORD)v9) {
      -[CLCompanionSyncInterestZone setZoneType:](v6, "setZoneType:", v9);
    }
    [*(id *)(v4 + 136) doubleForKey:@"Latitude" atKeyPath:a2 defaultValue:-1.0];
    if (v10 != -1.0) {
      -[CLCompanionSyncInterestZone setLatitude:](v6, "setLatitude:");
    }
    [*(id *)(v4 + 136) doubleForKey:@"Longitude" atKeyPath:a2 defaultValue:-1.0];
    if (v11 != -1.0) {
      -[CLCompanionSyncInterestZone setLongitude:](v6, "setLongitude:");
    }
    [*(id *)(v4 + 136) doubleForKey:@"Radius" atKeyPath:a2 defaultValue:-1.0];
    if (v12 != -1.0) {
      -[CLCompanionSyncInterestZone setRadius:](v6, "setRadius:");
    }
    id v13 = [*(id *)(v4 + 136) intForKey:@"ServiceMaskOperator" atKeyPath:a2 defaultValue:0xFFFFFFFFLL];
    if ((_DWORD)v13 != -1) {
      -[CLCompanionSyncInterestZone setServiceMaskOperator:](v6, "setServiceMaskOperator:", v13);
    }
    id v14 = [*(id *)(v4 + 136) intForKey:@"Provenance" atKeyPath:a2 defaultValue:0xFFFFFFFFLL];
    if ((_DWORD)v14 != -1) {
      -[CLCompanionSyncInterestZone setProvenance:](v6, "setProvenance:", v14);
    }
    return [*(id *)(a1 + 32) addInterestZones:v6];
  }

  return result;
}

void sub_10056A6A0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 1040))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v1 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "Skipping Reset, already in progress.", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      v18[0] = 0;
      uint64_t v2 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "Skipping Reset, already in progress.",  v18,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::resetClients()", "%s\n", v2);
    }
  }

  else
  {
    sub_10057C214();
    if ([*(id *)(a1 + 120) locationRestricted])
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v4 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "#warning location services settings are frozen by restrictions - resetting",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        v18[0] = 0;
        uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "#warning location services settings are frozen by restrictions - resetting",  v18,  2);
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::resetClients()", "%s\n", v15);
      }
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "resetting and disconnecting all clients from daemon",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      v18[0] = 0;
      LODWORD(v17) = 2;
      id v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "resetting and disconnecting all clients from daemon",  v18,  v17);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::resetClients()", "%s\n", v13);
    }

    sub_1005455A0(a1);
    sub_1000229D4(a1 + 664, *(char **)(a1 + 672));
    *(void *)(a1 + 664) = a1 + 672;
    *(void *)(a1 + 680) = 0LL;
    *(void *)(a1 + 672) = 0LL;
    sub_1000229D4(a1 + 688, *(char **)(a1 + 696));
    *(void *)(a1 + 68_Block_object_dispose(va, 8) = a1 + 696;
    *(void *)(a1 + 704) = 0LL;
    *(void *)(a1 + 696) = 0LL;
    sub_10054C788((id *)a1);
    [*(id *)(a1 + 136) performFullSystemServiceSetup];
    sub_10054C7F4(a1);
    [*(id *)(a1 + 1024) removeAllObjects];
    [*(id *)(a1 + 1024) addObjectsFromArray:sub_10057C2AC(a1)];
    [*(id *)(a1 + 128) setArray:*(void *)(a1 + 1024) forKey:@"ResetIdentifiers"];
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "reset identifiers saved to settings", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      v18[0] = 0;
      LODWORD(v17) = 2;
      id v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "reset identifiers saved to settings",  v18,  v17);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::resetClients()", "%s\n", v14);
    }

    *(_DWORD *)uint64_t buf = 0;
    (*(void (**)(uint64_t, uint8_t *, void, uint64_t))(*(void *)a1 + 144LL))(a1, buf, 0LL, 0xFFFFFFFFLL);
    *(_BYTE *)(a1 + 1040) = 1;
    [*(id *)(a1 + 256) setNextFireDelay:65.0];
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterPostNotification(DarwinNotifyCenter, CLAppResetChangedNotification, 0LL, 0LL, 0);
    sub_100547C58(a1);
    sub_1005569D8((_BYTE *)a1);
    v20[0] = &__kCFBooleanTrue;
    v19[0] = @"IsResetEvent";
    v19[1] = @"EventSource";
    id v8 = (void *)(a1 + 888);
    id v9 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v8);
    v19[2] = @"Enabled";
    v20[1] = v9;
    v20[2] = &__kCFBooleanFalse;
    double v10 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v20,  v19,  3LL);
    if (qword_101934A60 != -1) {
      dispatch_once(&qword_101934A60, &stru_101840200);
    }
    double v11 = (os_log_s *)qword_101934A68;
    if (os_log_type_enabled((os_log_t)qword_101934A68, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      int v22 = 0;
      __int16 v23 = 2082;
      __int128 v24 = "";
      __int16 v25 = 2114;
      __int128 v26 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#resetClients #CoreAnalytics, Bigswitch Analytics:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    AnalyticsSendEvent(@"com.apple.locationd.bigswitch", v10);
    sub_10056DBA0(a1);
    if (_os_feature_enabled_impl("CoreLocation", "CLSwissLocationAttribution"))
    {
      [*(id *)(a1 + 480) eraseAllData];
      sub_10004B780(a1 + 440);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_101840220);
      }
      double v12 = (os_log_s *)qword_101934978;
      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Removed locationAttributionInterval and cleared consumption map for attribution.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_101840220);
        }
        v18[0] = 0;
        LODWORD(v17) = 2;
        uint64_t v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  1LL,  "Removed locationAttributionInterval and cleared consumption map for attribution.",  v18,  v17);
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::resetClients()", "%s\n", v16);
      }

      sub_100564544(a1);
    }
  }

void sub_10056AF30(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  id v12 = sub_1005486B8(a1, a2);
  [*(id *)(a1 + 224) setNextFireDelay:0.3];
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    if (a3 > 4)
    {
      id v14 = "Never(because_invalid)";
      uint64_t v15 = 1LL;
    }

    else
    {
      id v14 = (&off_1018405A8)[a3];
      uint64_t v15 = qword_1012F1040[a3];
    }

    unint64_t v24 = v15;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v18 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 138543874;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v31 = 1026;
      unsigned int v32 = a3;
      __int16 v33 = 2082;
      __int128 v34 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "Setting client: %{public}@ authorization to %{public}d (%{public}s)",  buf,  0x1Cu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      *(_DWORD *)__int128 __p = 138543874;
      *(void *)&__p[4] = v12;
      __int16 v26 = 1026;
      unsigned int v27 = a3;
      __int16 v28 = 2082;
      uint64_t v29 = v14;
      __int16 v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "Setting client: %{public}@ authorization to %{public}d (%{public}s)",  __p,  28);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::setClientAuthorization(CLClientKeyPath *, CLClientAuthorizationStatus, CLClientCorrectiveC ompensation, const char *, BOOL, BOOL, BOOL)",  "%s\n",  v23);
      if (v23 != buf) {
        free(v23);
      }
    }

    if (*(_BYTE *)(a1 + 233))
    {
      __int16 v19 = (char *)objc_msgSend(objc_msgSend(v12, "legacyClientKey"), "UTF8String");
      if (v19) {
        uint64_t v20 = v19;
      }
      else {
        uint64_t v20 = "";
      }
      sub_1010DDBC0(buf, v20);
      __int16 v21 = (char *)objc_msgSend(objc_msgSend(v12, "zoneId"), "UTF8String");
      if (v21) {
        int v22 = v21;
      }
      else {
        int v22 = "";
      }
      sub_1010DDBC0(__p, v22);
      sub_100571764( a1,  (uint64_t)buf,  (uint64_t)__p,  1LL,  0LL,  0,  3u,  1,  *(double *)(a1 + 320),  *(double *)(a1 + 328),  50.0,  1u,  0LL);
      if (SBYTE3(v29) < 0) {
        operator delete(*(void **)__p);
      }
      if (SBYTE3(v34) < 0) {
        operator delete(*(void **)buf);
      }
      *(_BYTE *)(a1 + 233) = 0;
      *(CLLocationCoordinate2D *)(a1 + 320) = kCLLocationCoordinate2DInvalid;
    }

    sub_10056840C(a1, (uint64_t)v12, v24, a4, 1, a6, a7);
    sub_1005569D8((_BYTE *)a1);
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v16 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 138543362;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "location services settings are frozen by restrictions - denying %{public}@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      *(_DWORD *)__int128 __p = 138543362;
      *(void *)&__p[4] = v12;
      uint64_t v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "location services settings are frozen by restrictions - denying %{public}@",  __p,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::setClientAuthorization(CLClientKeyPath *, CLClientAuthorizationStatus, CLClientCorrectiveC ompensation, const char *, BOOL, BOOL, BOOL)",  "%s\n",  v17);
      if (v17 != buf) {
        free(v17);
      }
    }
  }

void sub_10056B3B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10056B3F4(uint64_t a1, uint64_t a2, std::string *__str, void *a4, unsigned int a5, void *a6)
{
  if (a5 - 3 <= 0xFFFFFFFD)
  {
    sub_10123DE20(a1, a2, __str);
    goto LABEL_108;
  }

  id v8 = __str;
  memset(&v86, 0, sizeof(v86));
  memset(&v85, 0, sizeof(v85));
  if (a5 == 2)
  {
    if ((__str->__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __str = (std::string *)__str->__r_.__value_.__r.__words[0];
    }
    double v11 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", __str);
    sub_1004F2598();
    if (sub_1004F7500()) {
      id v12 = @"clpla_companion_";
    }
    else {
      id v12 = @"clpla_gizmo_";
    }
    std::string::assign( &v86,  (const std::string::value_type *)objc_msgSend( -[__CFString stringByAppendingString:](v12, "stringByAppendingString:", v11),  "UTF8String"));
    std::string::operator=(&v85, v8);
  }

  else
  {
    std::string::operator=(&v86, __str);
    if ((v8->__r_.__value_.__s.__size_ & 0x80u) == 0) {
      BOOL v13 = v8;
    }
    else {
      BOOL v13 = (std::string *)v8->__r_.__value_.__r.__words[0];
    }
    id v14 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v13);
    sub_1004F2598();
    if (sub_1004F7500()) {
      uint64_t v15 = @"clpla_companion_";
    }
    else {
      uint64_t v15 = @"clpla_gizmo_";
    }
    std::string::assign( &v85,  (const std::string::value_type *)objc_msgSend( -[__CFString stringByAppendingString:](v15, "stringByAppendingString:", v14),  "UTF8String"));
  }

  else {
    uint64_t v16 = *(void *)a2;
  }
  id v17 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v16)));
  unsigned __int8 v18 = [v17 isValidCKP];
  if ((v18 & 1) == 0)
  {
    else {
      uint64_t v19 = *(void *)a2;
    }
    id v17 = objc_msgSend( *(id *)(a1 + 136),  "registerClient:fromAuthSync:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v19)),  0);
  }

  if ((v86.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v20 = &v86;
  }
  else {
    uint64_t v20 = (std::string *)v86.__r_.__value_.__r.__words[0];
  }
  id v21 = objc_msgSend( v17,  "clientKeyPathWithReplacementSubIdentityId:subIdentityType:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v20),  122);
  if ((v85.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v22 = &v85;
  }
  else {
    int v22 = (std::string *)v85.__r_.__value_.__r.__words[0];
  }
  id v23 = objc_msgSend( v17,  "clientKeyPathWithReplacementSubIdentityId:subIdentityType:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v22),  122);
  sub_1010DDBC0(__p, "ClientRemoved");
  sub_10054BFD4(a1, v21, 1, (uint64_t *)__p);
  if (v84 < 0) {
    operator delete(__p[0]);
  }
  unsigned int v24 = objc_msgSend( objc_msgSend(a4, "objectForKeyedSubscript:", @"ServiceMaskOperator"),  "intValue");
  id v25 = objc_msgSend(objc_msgSend(a4, "objectForKeyedSubscript:", @"Type"), "intValue");
  objc_msgSend(objc_msgSend(a4, "objectForKeyedSubscript:", @"Latitude"), "doubleValue");
  double v27 = v26;
  objc_msgSend(objc_msgSend(a4, "objectForKeyedSubscript:", @"Longitude"), "doubleValue");
  double v29 = v28;
  objc_msgSend(objc_msgSend(a4, "objectForKeyedSubscript:", @"Radius"), "doubleValue");
  sub_100571764(a1, a2, (uint64_t)&v86, (uint64_t)v25, 0LL, v24, a5, 0, v27, v29, v30, 0, 0LL);
  if ((v85.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    __int16 v31 = &v85;
  }
  else {
    __int16 v31 = (std::string *)v85.__r_.__value_.__r.__words[0];
  }
  id v32 = objc_msgSend( a6,  "objectForKeyedSubscript:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v31));
  if (v32 && (sub_100582538(v32, a4) & 1) != 0)
  {
    int v78 = _NSConcreteStackBlock;
    uint64_t v79 = 3221225472LL;
    int v80 = sub_100582FB0;
    uint64_t v81 = &unk_101840108;
    uint64_t v82 = a1;
    if (v18 & 1) != 0 || ([*(id *)(a1 + 136) dictionaryExistsAtKeyPath:v23])
    {
      uint64_t v33 = sub_100582538( objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v23), "dictionary"),  a4);
      if ((v33 & 1) != 0)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        __int16 v41 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          else {
            uint64_t v42 = *(void *)a2;
          }
          __int16 v43 = &v86;
          if ((v86.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            __int16 v43 = (std::string *)v86.__r_.__value_.__r.__words[0];
          }
          int v44 = &v85;
          if ((v85.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            int v44 = (std::string *)v85.__r_.__value_.__r.__words[0];
          }
          *(void *)uint64_t buf = 68290050LL;
          __int16 v88 = 2082;
          __int16 v89 = "";
          __int16 v90 = 2082;
          uint64_t v91 = v42;
          __int16 v92 = 2082;
          int v93 = v43;
          __int16 v94 = 2082;
          uint64_t v95 = v44;
          __int16 v96 = 1026;
          BOOL v97 = a5 == 2;
          _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#pla #reconcile Collapsing, existing entry identical. Using existing entry, deleting new entry, clientKey:%{public, location:escape_only}s, zoneIdToWrite:%{public, location:escape_onl y}s, zoneIdToReconcile:%{public, location:escape_only}s, isSyncedZone:%{public}hhd}",  buf,  0x36u);
        }

        sub_1010DDBC0(&v72, "ClientRemoved");
        sub_10054BFD4(a1, v21, 1, (uint64_t *)&v72);
        if (SHIBYTE(v74) < 0) {
          operator delete(v72);
        }
        id v45 = v23;
        if (a5 == 2) {
          goto LABEL_99;
        }
        goto LABEL_85;
      }

      if (a5 == 2)
      {
        sub_1010DDBC0(&v75, "ClientRemoved");
        sub_10054BFD4(a1, v23, 1, (uint64_t *)&v75);
        if (SHIBYTE(v77) < 0) {
          operator delete(v75);
        }
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        int v51 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          else {
            uint64_t v52 = *(void *)a2;
          }
          int v53 = &v86;
          if ((v86.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            int v53 = (std::string *)v86.__r_.__value_.__r.__words[0];
          }
          __int16 v54 = &v85;
          if ((v85.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            __int16 v54 = (std::string *)v85.__r_.__value_.__r.__words[0];
          }
          *(void *)uint64_t buf = 68290050LL;
          __int16 v88 = 2082;
          __int16 v89 = "";
          __int16 v90 = 2082;
          uint64_t v91 = v52;
          __int16 v92 = 2082;
          int v93 = v53;
          __int16 v94 = 2082;
          uint64_t v95 = v54;
          __int16 v96 = 1026;
          BOOL v97 = 1;
          _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#pla #reconcile existing entry for collapsing not identical. Delete existing entry, clientKey:%{public, location:escape_only}s, zoneIdToWrite:%{public, location:escape_only}s, zoneI dToReconcile:%{public, location:escape_only}s, isSyncedZone:%{public}hhd}",  buf,  0x36u);
        }

        id v45 = v21;
        id v21 = v23;
LABEL_85:
        v80((uint64_t)&v78, v45, v21);
        goto LABEL_99;
      }

      sub_10123DF94( v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v68,  v69,  v70,  (uint64_t)a6,  (uint64_t)v72,  v73,  v74,  (uint64_t)v75,  v76,  v77,  (uint64_t)v78,  v79,  (uint64_t)v80,  (uint64_t)v81,  v82,  (uint64_t)__p[0]);
      abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/CLClientManager.mm",  6790,  "registerAndReconcileInfoPlistZone");
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v55 = (os_log_s *)qword_101934988;
      BOOL v56 = os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT);
      if (v56)
      {
        else {
          uint64_t v64 = *(void *)a2;
        }
        __int16 v65 = &v86;
        if ((v86.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          __int16 v65 = (std::string *)v86.__r_.__value_.__r.__words[0];
        }
        __int128 v66 = &v85;
        if ((v85.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          __int128 v66 = (std::string *)v85.__r_.__value_.__r.__words[0];
        }
        *(void *)uint64_t buf = 68290050LL;
        __int16 v88 = 2082;
        __int16 v89 = "";
        __int16 v90 = 2082;
        uint64_t v91 = v64;
        __int16 v92 = 2082;
        int v93 = v65;
        __int16 v94 = 2082;
        uint64_t v95 = v66;
        __int16 v96 = 1026;
        BOOL v97 = a5 == 2;
        _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#pla #reconcile existing entry for collapsing not found, clientKey:%{public, loca tion:escape_only}s, zoneIdToWrite:%{public, location:escape_only}s, zoneIdToReconcile:%{public, locati on:escape_only}s, isSyncedZone:%{public}hhd}",  buf,  0x36u);
      }

      if (a5 == 2)
      {
        v80((uint64_t)&v78, v21, v23);
        goto LABEL_99;
      }

      sub_10123E0DC( v56,  v57,  v58,  v59,  v60,  v61,  v62,  v63,  v68,  v69,  v70,  (uint64_t)a6,  (uint64_t)v72,  v73,  v74,  (uint64_t)v75,  v76,  v77,  (uint64_t)v78,  v79,  (uint64_t)v80,  (uint64_t)v81,  v82,  (uint64_t)__p[0]);
      abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/CLClientManager.mm",  6779,  "registerAndReconcileInfoPlistZone");
    }

void sub_10056BD1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, void *a36, uint64_t a37, int a38, __int16 a39, char a40, char a41, void *a42, uint64_t a43, int a44, __int16 a45, char a46, char a47)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a41 < 0) {
    operator delete(a36);
  }
  if (a47 < 0) {
    operator delete(a42);
  }
  _Unwind_Resume(exception_object);
}

id sub_10056BDC8(uint64_t a1)
{
  id v2 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  if (_os_feature_enabled_impl("CoreLocation", "CLUnfederatedUsageSync"))
  {
    CFTypeRef v25 = 0LL;
    uint64_t v3 = sub_1002F8DDC();
    if (sub_1002A6F20(v3, (uint64_t)@"CLClientManager.AssertionDueToWatchApp", &v25))
    {
      uint64_t v4 = (void *)v25;
      double Current = CFAbsoluteTimeGetCurrent();
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      id obj = [v4 allKeys];
      id v17 = [obj countByEnumeratingWithState:&v21 objects:v26 count:16];
      if (v17)
      {
        uint64_t v16 = *(void *)v22;
        do
        {
          for (uint64_t i = 0LL; i != v17; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v22 != v16) {
              objc_enumerationMutation(obj);
            }
            uint64_t v7 = *(void *)(*((void *)&v21 + 1) + 8LL * (void)i);
            id v8 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
            double v10 = (uint64_t *)qword_101996D70;
            uint64_t v9 = qword_101996D78;
            while (v10 != (uint64_t *)v9)
            {
              uint64_t v11 = *v10++;
              uint64_t v19 = 0LL;
              uint64_t v20 = 0LL;
              sub_100547724(v11, &v20, &v19);
              id v12 = v19;
              objc_msgSend(v8, "setObject:forKey:", objc_msgSend(v4, "objectForKeyedSubscript:", v7), v20);
              objc_msgSend( v8,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", Current),  v12);
            }

            [v2 setObject:v8 forKey:v7];
          }

          id v17 = [obj countByEnumeratingWithState:&v21 objects:v26 count:16];
        }

        while (v17);
      }
    }
  }

  else
  {
    BOOL v13 = *(void **)(a1 + 136);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472LL;
    v18[2] = sub_10056BFF4;
    v18[3] = &unk_10183F9D0;
    v18[4] = v2;
    v18[5] = a1;
    [v13 iterateAllAnchorKeyPathsWithBlock:v18];
  }

  return v2;
}

void sub_10056BFF4(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = [a2 legacyClientKey];
  sub_1010DDBC0(__p, (char *)[v4 UTF8String]);
  BOOL v5 = sub_10056C0DC(v3, (unsigned __int8 *)__p);
  BOOL v6 = v5;
  if (v9 < 0)
  {
    operator delete(__p[0]);
    if (!v6) {
      return;
    }
  }

  else if (!v5)
  {
    return;
  }

  sub_1010DDBC0(__p, (char *)[v4 UTF8String]);
  id v7 = sub_10056C388(v3, (uint64_t *)__p);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if ([v7 count]) {
    [*(id *)(a1 + 32) setObject:v7 forKey:v4];
  }
}

void sub_10056C0BC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10056C0DC(uint64_t a1, unsigned __int8 *a2)
{
  if (!_os_feature_enabled_impl("CoreLocation", "CLUnfederatedUsageSync"))
  {
    if ((a2[23] & 0x80u) == 0) {
      char v9 = (uint64_t *)a2;
    }
    else {
      char v9 = *(uint64_t **)a2;
    }
    id v10 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9)));
    return [v10 isValidCKP]
        && ([*(id *)(a1 + 136) isKeyPathRegisteredSystemService:v10] & 1) != 0
        || sub_10023BD04((void *)(a1 + 1424), a2) != 0LL;
  }

  if (a1 + 536 == sub_10008E8D0(a1 + 528, (const void **)a2))
  {
    BOOL v6 = sub_100121918((void *)(a1 + 552), a2) != 0LL;
  }

  else
  {
    *(void *)uint64_t buf = a2;
    uint64_t v4 = sub_1005896DC((uint64_t **)(a1 + 528), (const void **)a2, (uint64_t)&unk_1012CF090, (__int128 **)buf)[7];
    int v5 = *(unsigned __int8 *)(v4 + 72);
    BOOL v6 = *(_BYTE *)(v4 + 72) != 0;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v7 = (os_log_s *)qword_101934988;
    if (!os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_20;
    }
    if ((a2[23] & 0x80u) == 0) {
      id v8 = (uint64_t *)a2;
    }
    else {
      id v8 = *(uint64_t **)a2;
    }
    *(_DWORD *)uint64_t buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v15 = 2082;
    uint64_t v16 = "";
    __int16 v17 = 2082;
    unsigned __int8 v18 = v8;
    __int16 v19 = 1026;
    BOOL v20 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#usesync fTemporaryInUseAssertions, client:%{public, location:escape_only}s, should Sync:%{public}hhd}",  buf,  0x22u);
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
LABEL_20:
  uint64_t v11 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    if ((a2[23] & 0x80u) == 0) {
      id v12 = (uint64_t *)a2;
    }
    else {
      id v12 = *(uint64_t **)a2;
    }
    *(_DWORD *)uint64_t buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v15 = 2082;
    uint64_t v16 = "";
    __int16 v17 = 2082;
    unsigned __int8 v18 = v12;
    __int16 v19 = 1026;
    BOOL v20 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#usesync shouldSyncUsageForClient, client:%{public, location:escape_only}s, shouldS ync:%{public}hhd}",  buf,  0x22u);
  }

  return v6;
}

id sub_10056C388(uint64_t a1, uint64_t *a2)
{
  else {
    uint64_t v4 = (uint64_t *)*a2;
  }
  id v5 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v4)));
  if ([v5 isValidCKP])
  {
    id v6 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    for (uint64_t i = 0LL; i != 11; ++i)
    {
      unint64_t v8 = qword_1012F0BB0[i];
      if (_os_feature_enabled_impl("CoreLocation", "CLUnfederatedUsageSync"))
      {
        if (v8 > 0xA || ((1LL << v8) & 0x430) == 0) {
          continue;
        }
      }

      __int16 v17 = 0LL;
      *(void *)uint64_t buf = 0LL;
      sub_100547724(v8, buf, &v17);
      uint64_t v10 = *(void *)buf;
      [*(id *)(a1 + 136) doubleForKey:*(void *)buf atKeyPath:v5 defaultValue:-1.0];
      if (v11 != -1.0) {
        objc_msgSend( v6,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"),  v10);
      }
      id v12 = v17;
      [*(id *)(a1 + 136) doubleForKey:v17 atKeyPath:v5 defaultValue:-1.0];
      if (v13 != -1.0) {
        objc_msgSend( v6,  "setObject:forKey:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"),  v12);
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v14 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      else {
        __int16 v15 = (uint64_t *)*a2;
      }
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v19 = 2082;
      BOOL v20 = "";
      __int16 v21 = 2082;
      __int128 v22 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#usesync Couldn't get nvp, client:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    return 0LL;
  }

  return v6;
}

uint64_t sub_10056C5EC(uint64_t a1, uint64_t *a2, void *a3)
{
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_101934980 != -1) {
LABEL_57:
  }
    dispatch_once(&qword_101934980, &stru_1018401A0);
  id v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    else {
      unint64_t v8 = (uint64_t *)*a2;
    }
    *(_DWORD *)uint64_t buf = 68289282;
    int v45 = 0;
    __int16 v46 = 2082;
    uint64_t v47 = "";
    __int16 v48 = 2082;
    int v49 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#usesync Merging remote location usage, client:%{public, location:escape_only}s}",  buf,  0x1Cu);
  }

  else {
    char v9 = (uint64_t *)*a2;
  }
  __int16 v41 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v9);
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  for (uint64_t i = 0LL; i != 11; ++i)
  {
    unint64_t v12 = qword_1012F0BB0[i];
    uint64_t result = _os_feature_enabled_impl("CoreLocation", "CLUnfederatedUsageSync");
    if ((_DWORD)result)
    {
      if (v12 > 0xA || ((1LL << v12) & 0x430) == 0) {
        continue;
      }
    }

    uint64_t v42 = 0LL;
    uint64_t v43 = 0LL;
    sub_100547724(v12, &v43, &v42);
    unint64_t v15 = (unint64_t)[a3 objectForKeyedSubscript:v43];
    id v16 = [a3 objectForKeyedSubscript:v42];
    unint64_t v17 = (unint64_t)v16;
    if (v15) {
      BOOL v18 = v16 == 0LL;
    }
    else {
      BOOL v18 = 1;
    }
    if (!v18)
    {
      __int16 v19 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        [(id)v15 doubleValue];
        __int16 v21 = v20;
        [(id)v17 doubleValue];
        *(_DWORD *)uint64_t buf = 68289794;
        int v45 = 0;
        __int16 v46 = 2082;
        uint64_t v47 = "";
        __int16 v48 = 2050;
        int v49 = v21;
        __int16 v50 = 2050;
        uint64_t v51 = v22;
        __int16 v52 = 2050;
        unint64_t v53 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#usesync #warning Didn't expect a start time and a stop time, start time_s:%{pu blic}.09f, stop time_s:%{public}.09f, service:%{public}lu}",  buf,  0x30u);
      }

      [(id)v17 doubleValue];
      double v24 = v23;
      [(id)v15 doubleValue];
      if (v24 > v25) {
        unint64_t v15 = 0LL;
      }
      else {
        unint64_t v17 = 0LL;
      }
    }

    else {
      double v26 = (uint64_t *)*a2;
    }
    double v27 = +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v26));
    if (v15 | v17)
    {
      double v28 = p_vtable[304];
      if (v15)
      {
        double v29 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          else {
            double v30 = (uint64_t *)*a2;
          }
          [(id)v15 doubleValue];
          *(_DWORD *)uint64_t buf = 68289794;
          int v45 = 0;
          __int16 v46 = 2082;
          uint64_t v47 = "";
          __int16 v48 = 2082;
          int v49 = v30;
          p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
          __int16 v50 = 2050;
          uint64_t v51 = v31;
          __int16 v52 = 2050;
          unint64_t v53 = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#usesync Starting remote location service, client:%{public, location:escape_onl y}s, start time_s:%{public}.09f, service:%{public}lu}",  buf,  0x30u);
        }

        if (v12 == 10) {
          sub_10054FF68( a1,  (uint64_t)+[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  v41),  -1LL,  0,  0.0);
        }
        [(id)v15 doubleValue];
        uint64_t v33 = a1;
        uint64_t v34 = (uint64_t)v27;
        uint64_t v35 = v12;
        int v36 = 1;
      }

      else
      {
        if (!v17)
        {
          sub_10123E224(v28 == (void *)-1LL);
          goto LABEL_57;
        }

        uint64_t v38 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          else {
            uint64_t v39 = (uint64_t *)*a2;
          }
          [(id)v17 doubleValue];
          *(_DWORD *)uint64_t buf = 68289794;
          int v45 = 0;
          __int16 v46 = 2082;
          uint64_t v47 = "";
          __int16 v48 = 2082;
          int v49 = v39;
          p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
          __int16 v50 = 2050;
          uint64_t v51 = v40;
          __int16 v52 = 2050;
          unint64_t v53 = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#usesync Stopping remote location service, client:%{public, location:escape_onl y}s, stop time_s:%{public}.09f, service:%{public}lu}",  buf,  0x30u);
        }

        [(id)v17 doubleValue];
        uint64_t v33 = a1;
        uint64_t v34 = (uint64_t)v27;
        uint64_t v35 = v12;
        int v36 = 0;
      }

      int v37 = 1;
    }

    else
    {
      uint64_t v33 = a1;
      uint64_t v34 = (uint64_t)v27;
      uint64_t v35 = v12;
      int v36 = 0;
      int v37 = 0;
      double v32 = Current;
    }

    uint64_t result = sub_10056CADC(v33, v34, v35, v36, v37, 1, v32);
  }

  return result;
}

uint64_t sub_10056CADC(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, double a7)
{
  id v12 = sub_1005486B8(a1, a2);
  uint64_t v64 = 0LL;
  uint64_t v65 = 0LL;
  unint64_t v59 = a3;
  sub_100547724(a3, &v65, &v64);
  if (sub_10057CADC(a1, a3, (uint64_t)v12, a6 == 0))
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101840220);
    }
    double v13 = (os_log_s *)qword_101934978;
    a5 = 0;
    a4 = 0;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Non-persistent SLC usage detected}",  buf,  0x12u);
      a5 = 0;
      a4 = 0;
    }
  }

  if (a6 != 1)
  {
    uint64_t v22 = v65;
    [*(id *)(a1 + 136) doubleForKey:v65 atKeyPath:v12 defaultValue:-1.0];
    double v24 = v23;
    double v25 = v64;
    [*(id *)(a1 + 136) doubleForKey:v64 atKeyPath:v12 defaultValue:-1.0];
    if (a4)
    {
      BOOL v27 = v26 != -1.0 || v24 == -1.0;
      if (!v27 && v24 <= a7)
      {
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_101840220);
        }
        double v28 = (os_log_s *)qword_101934978;
        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)uint64_t buf = 138412290;
          *(void *)&uint8_t buf[4] = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "#Warning, new start time for %@ is after it's stored time",  buf,  0xCu);
        }

        if (!sub_1002921D0(115, 2)) {
          return 0LL;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934970 == -1) {
          goto LABEL_123;
        }
        goto LABEL_125;
      }

      [*(id *)(a1 + 136) setDouble:v22 forKey:v12 atKeyPath:a7];
      [*(id *)(a1 + 136) removeValueForKey:v25 atKeyPath:v12];
      if (!v27)
      {
LABEL_41:
        uint64_t v29 = 0LL;
        if (a6)
        {
LABEL_116:
          sub_10055478C(a1, (uint64_t)v12);
          return v29;
        }

        goto LABEL_83;
      }
    }

    else
    {
      if (v24 == -1.0) {
        int v30 = a5;
      }
      else {
        int v30 = 1;
      }
      if (v30 != 1) {
        goto LABEL_41;
      }
      [*(id *)(a1 + 136) setDouble:v25 forKey:v12 atKeyPath:a7];
      [*(id *)(a1 + 136) removeValueForKey:v22 atKeyPath:v12];
      sub_100547C58(a1);
    }

void sub_10056D7D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_10056D800(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a1 + 136);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_10056D858;
  v4[3] = &unk_10183F9D0;
  v4[4] = a2;
  void v4[5] = a1;
  return [v2 iterateAllAnchorKeyPathsWithBlock:v4];
}

void sub_10056D858(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", objc_msgSend(a2, "legacyClientKey"));
  if (v4) {
    id v5 = v4;
  }
  else {
    id v5 = &__NSDictionary0__struct;
  }
  id v6 = (char *)objc_msgSend(objc_msgSend(a2, "legacyClientKey"), "UTF8String");
  if (v6) {
    id v7 = v6;
  }
  else {
    id v7 = "";
  }
  sub_1010DDBC0(__p, v7);
  sub_10056C5EC(v3, (uint64_t *)__p, v5);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10056D8F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10056D90C(uint64_t a1, void *a2)
{
  uint64_t v3 = 0LL;
  while (1)
  {
    unint64_t v4 = qword_1012F0BB0[v3];
    if (_os_feature_enabled_impl("CoreLocation", "CLUnfederatedUsageSync"))
    {
      if (v4 > 0xA || ((1LL << v4) & 0x430) == 0) {
        goto LABEL_13;
      }
    }

    BOOL v18 = 0LL;
    uint64_t v19 = 0LL;
    sub_100547724(v4, &v19, &v18);
    id v6 = [a2 objectForKeyedSubscript:v19];
    id v7 = [a2 objectForKeyedSubscript:v18];
    if (v6 && v7 != 0LL) {
      break;
    }
    if (v6) {
      return 1LL;
    }
LABEL_13:
    if (++v3 == 11) {
      return 0LL;
    }
  }

  uint64_t v10 = v7;
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  double v11 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    [v6 doubleValue];
    uint64_t v13 = v12;
    [v10 doubleValue];
    *(_DWORD *)uint64_t buf = 68289794;
    int v21 = 0;
    __int16 v22 = 2082;
    double v23 = "";
    __int16 v24 = 2050;
    uint64_t v25 = v13;
    __int16 v26 = 2050;
    uint64_t v27 = v14;
    __int16 v28 = 2050;
    unint64_t v29 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#usesync #warning Didn't expect a start time and a stop time, start time_s:%{public }.09f, stop time_s:%{public}.09f, service:%{public}lu}",  buf,  0x30u);
  }

  [v10 doubleValue];
  double v16 = v15;
  [v6 doubleValue];
  return v16 <= v17;
}

id sub_10056DB04(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  if (sub_1004F7500() || (sub_1004F2598(), id result = (id)sub_1001B9A1C(), (_DWORD)result))
  {
    id result = sub_10056A300(a1, a2, 0LL, 1LL);
    if (result)
    {
      id v7 = *(void **)(a1 + 1472);
      else {
        unint64_t v8 = (uint64_t *)*a3;
      }
      return objc_msgSend( v7,  "addObject:withSyncSessionReason:",  result,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v8));
    }
  }

  return result;
}

void sub_10056DBA0(uint64_t a1)
{
  if (sub_1004F7500())
  {
    [*(id *)(a1 + 1472) sendNotification:0];
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v2 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "#authsync sending kNotificationReset to the watch",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      v4[0] = 0;
      uint64_t v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#authsync sending kNotificationReset to the watch",  v4,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::sendResetNotification()", "%s\n", v3);
    }
  }

id sub_10056DD40(uint64_t a1, unsigned __int8 *a2)
{
  char v4 = _os_feature_enabled_impl("CoreLocation", "CLUnfederatedUsageSync");
  sub_1004F2598();
  if ((v4 & 1) != 0)
  {
    id result = (id)sub_1004F7500();
    if (!(_DWORD)result) {
      return result;
    }
  }

  else if ((sub_1001B9A1C() & 1) == 0)
  {
    sub_1004F2598();
    id result = (id)sub_1004F7500();
  }

  id result = (id)sub_10056C0DC(a1, a2);
  if ((_DWORD)result)
  {
    id result = sub_10056C388(a1, (uint64_t *)a2);
    if (result)
    {
      id v6 = *(void **)(a1 + 1464);
      if ((a2[23] & 0x80u) == 0) {
        id v7 = (uint64_t *)a2;
      }
      else {
        id v7 = *(uint64_t **)a2;
      }
      return objc_msgSend( v6,  "client:didChangeUsageData:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7),  result);
    }
  }

  return result;
}

void sub_10056DEAC(id a1)
{
  qword_101996E08 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLClientManagerSilo");
}

void sub_10056E150(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

id sub_10056E164(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_100589898(a1);
  }
  else {
    return 0LL;
  }
}

void sub_10056E29C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10056E3AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10056E4BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10056E5CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10056E6DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10056EA18( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

CLCppContainer *sub_10056EA44(__int128 *a1)
{
  uint64_t v2 = operator new(0x50uLL);
  sub_1008FDB14(v2, a1);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_100589C44;
  v4[3] = &unk_10181D3D0;
  v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  0LL,  80LL);
}

void sub_10056EAC8(_Unwind_Exception *a1)
{
}

void sub_10056EC60(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10056ED44( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_10056EDC8(uint64_t a1)
{
  v25[0] = 0LL;
  sub_100309D64(0, &v24);
  uint64_t v2 = std::string::append(&v24, "locScoreInfo/");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  *(void *)&__p[16] = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  if (__p[23] >= 0) {
    char v4 = __p;
  }
  else {
    char v4 = *(_BYTE **)__p;
  }
  id v5 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v4);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  if (-[NSFileManager removeItemAtPath:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtPath:error:",  v5,  v25))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v6 = qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(void *)__int128 __p = 68289026LL;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&__p[10] = "";
      id v7 = "{msg%{public}.0s:Sucessfully removed file at path to locScoreInfoReport}";
      unint64_t v8 = (os_log_s *)v6;
      uint32_t v9 = 18;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, v7, __p, v9);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v10 = qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(void *)__int128 __p = 68289282LL;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&__p[10] = "";
      *(_WORD *)&__p[18] = 2114;
      *(void *)&__p[20] = v25[0];
      id v7 = "{msg%{public}.0s:Unable to remove file at path to locScoreInfoReport, error:%{public, location:escape_only}@}";
      unint64_t v8 = (os_log_s *)v10;
      uint32_t v9 = 28;
      goto LABEL_17;
    }
  }

  LODWORD(v24.__r_.__value_.__l.__data_) = 0;
  uint64_t v11 = sub_1002F8DDC();
  int v12 = sub_1002A7CB0(v11, "SystemServiceGeneration", &v24) ^ 1;
  if (SLODWORD(v24.__r_.__value_.__l.__data_) < 2) {
    int v13 = 1;
  }
  else {
    int v13 = v12;
  }
  uint64_t v14 = *(void **)(a1 + 136);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472LL;
  v22[2] = sub_1005814A0;
  v22[3] = &unk_101840050;
  v22[4] = a1;
  char v23 = v13;
  [v14 iterateAllAnchorKeyPathsWithBlock:v22];
  if (v13)
  {
    uint64_t v15 = sub_1002F8DDC();
    *(_DWORD *)__int128 __p = 2;
    sub_1002AC220(v15, "SystemServiceGeneration", __p);
    uint64_t v16 = sub_1002F8DDC();
    (*(void (**)(uint64_t))(*(void *)v16 + 944LL))(v16);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    double v17 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 __p = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "AuthMigrate: successfully resetted all SystemService authorization mask",  __p,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      LOWORD(v25[0]) = 0;
      int v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "AuthMigrate: successfully resetted all SystemService authorization mask",  v25,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::performMigration()", "%s\n", v21);
      if (v21 != __p) {
        free(v21);
      }
    }

    [*(id *)(a1 + 136) persist];
  }

  sub_100547C58(a1);
  sub_1005569D8((_BYTE *)a1);
  [*(id *)(a1 + 1472) considerPerformingAForcedFullSync];
  uint64_t v18 = sub_1002F8DDC();
  sub_1002A66DC(v18);
  uint64_t v19 = sub_1002F8DDC();
  (*(void (**)(uint64_t))(*(void *)v19 + 944LL))(v19);
  return sub_10053E9E8(*(void **)(a1 + 952));
}

void sub_10056F1EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, void *__p, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056F24C(uint64_t a1, void *a2)
{
  if (*(_BYTE *)(a1 + 1040))
  {
    if ([*(id *)(a1 + 1024) containsObject:a2])
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      char v4 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        id v5 = [a2 UTF8String];
        uint64_t v6 = *(void **)(a1 + 1024);
        *(_DWORD *)uint64_t buf = 68289794;
        *(_DWORD *)uint64_t v15 = 0;
        *(_WORD *)&v15[4] = 2082;
        *(void *)&void v15[6] = "";
        __int16 v16 = 2082;
        id v17 = v5;
        __int16 v18 = 2114;
        uint64_t v19 = v6;
        __int16 v20 = 2050;
        uint64_t v21 = (int)[v6 count];
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:reset completion reporting, Current Identifier:%{public, location:escape_only}s, ResetIdentifiers Snapshot:%{public, location:escape_only}@, Count:%{public}ld}",  buf,  0x30u);
      }

      [*(id *)(a1 + 1024) removeObject:a2];
      [*(id *)(a1 + 128) setArray:*(void *)(a1 + 1024) forKey:@"ResetIdentifiers"];
      if (![*(id *)(a1 + 1024) count])
      {
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_101840220);
        }
        id v7 = (os_log_s *)qword_101934978;
        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "Completion reported back for all Reset registered clients",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934970 != -1) {
            dispatch_once(&qword_101934970, &stru_101840220);
          }
          LOWORD(v12) = 0;
          uint64_t v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  1LL,  "Completion reported back for all Reset registered clients",  &v12,  2);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::resetNotificationConsumedForIdentifier(NSString *)",  "%s\n",  v11);
        }

        *(_BYTE *)(a1 + 1040) = 0;
        [*(id *)(a1 + 256) setNextFireDelay:0.0];
      }
    }

    else
    {
      [*(id *)(a1 + 128) setArray:0 forKey:@"ResetIdentifiers"];
      [*(id *)(a1 + 128) setInt:0 forKey:@"ResetRetrialCount"];
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint32_t v9 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t buf = 138412290;
        *(void *)uint64_t v15 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "Reset registration and completion reporting is un-balanced. Completion of Reset reported for unregistered identifier: %@",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        int v12 = 138412290;
        int v13 = a2;
        uint64_t v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Reset registration and completion reporting is un-balanced. Completion of Reset reported for unr egistered identifier: %@",  &v12,  12);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLClientManager::resetNotificationConsumedForIdentifier(NSString *)",  "%s\n",  v10);
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unint64_t v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v15 = 0;
      *(_WORD *)&v15[4] = 2082;
      *(void *)&void v15[6] = "";
      __int16 v16 = 2082;
      id v17 = [a2 UTF8String];
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Skip completion reporting. No Reset in progress, Identifier:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }
  }

void sub_10056F7F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10056F80C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 138412546;
    uint64_t v14 = a2;
    __int16 v15 = 1026;
    int v16 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Setting client:%@ background indicator to %{public}d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v9 = 138412546;
    uint64_t v10 = a2;
    __int16 v11 = 1026;
    int v12 = a3;
    unint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "Setting client:%@ background indicator to %{public}d",  &v9,  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::setClientBackgroundIndicator(CLClientKeyPath *, BOOL, const char *)",  "%s\n",  v8);
  }

  return sub_10057D340(a1, a2, a3, 1);
}

void sub_10056FB40(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10056FBB0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10056FD70(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10056FE60(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

id sub_10056FE74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = sub_1005486B8(a1, a2);
  uint64_t v6 = *(void **)(a1 + 136);
  if (a3) {
    return [v6 setString:a3 forKey:@"Purpose" atKeyPath:v5];
  }
  else {
    return [v6 removeValueForKey:@"Purpose" atKeyPath:v5];
  }
}

void sub_10056FF38( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_10056FF8C(id *a1, void *a2)
{
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  id result = [a2 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (result)
  {
    id v5 = result;
    uint64_t v6 = *(void *)v9;
    do
    {
      id v7 = 0LL;
      do
      {
        if (*(void *)v9 != v6) {
          objc_enumerationMutation(a2);
        }
        sub_10054BE50( a1,  (uint64_t)+[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  *(void *)(*((void *)&v8 + 1) + 8LL * (void)v7)));
        id v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id result = [a2 countByEnumeratingWithState:&v8 objects:v12 count:16];
      id v5 = result;
    }

    while (result);
  }

  return result;
}

void sub_1005700DC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  id v7 = sub_1005486B8(a1, a2);
  id v8 = [*(id *)(a1 + 136) intForKey:@"CorrectiveCompensationEnabled" atKeyPath:v7 defaultValue:0];
  int v9 = (int)v8;
  uint64_t v10 = (uint64_t)v8;
  if (a4 && !(_DWORD)v8)
  {
    sub_1004F2598();
    if (sub_1001B9A1C())
    {
      [*(id *)(a1 + 136) setInt:2 forKey:@"CorrectiveCompensationEnabled" atKeyPath:v7];
      uint64_t v10 = (uint64_t)[*(id *)(a1 + 136) intForKey:@"CorrectiveCompensationEnabled" atKeyPath:v7 defaultValue:0];
    }

    else
    {
      uint64_t v10 = 2LL;
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int128 v11 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)int v30 = 0;
      *(_WORD *)&v30[4] = 2082;
      *(void *)&v30[6] = "";
      *(_WORD *)&v30[14] = 2114;
      *(void *)&v30[16] = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Sliding CorrectiveCompensationUnspecified(0) to CorrectiveCompensationOn(2), Client :%{public, location:escape_only}@}",  buf,  0x1Cu);
    }
  }

  [*(id *)(a1 + 136) setInt:a3 forKey:@"SupportedAuthorizationMask" atKeyPath:v7];
  sub_1004F2598();
  if ((sub_1001B9A1C() & 1) == 0)
  {
    uint64_t v12 = sub_100AE00C4(objc_msgSend(objc_msgSend(*(id *)(a1 + 136), "readonlyStoreAtKeyPath:", v7), "dictionary"));
    if (v12 == 4) {
      unint64_t v13 = a3 & 2;
    }
    else {
      unint64_t v13 = 0LL;
    }
    if ((v12 & a3) != 0) {
      unint64_t v14 = v12;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14 == v12)
    {
      if ((_DWORD)v10 == v9) {
        return;
      }
    }

    else
    {
      uint64_t v15 = v12;
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v16 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint64_t buf = 138413058;
        *(void *)int v30 = v7;
        *(_WORD *)&_OWORD v30[8] = 2048;
        *(void *)&v30[10] = a3;
        *(_WORD *)&v30[18] = 2048;
        *(void *)&v30[20] = v15;
        __int16 v31 = 2048;
        unint64_t v32 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "Client %@ allowable mask (%lu) no longer contains authorization level (%lu) downgrading to (%lu)",  buf,  0x2Au);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        int v21 = 138413058;
        id v22 = v7;
        __int16 v23 = 2048;
        uint64_t v24 = a3;
        __int16 v25 = 2048;
        uint64_t v26 = v15;
        __int16 v27 = 2048;
        unint64_t v28 = v14;
        __int16 v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "Client %@ allowable mask (%lu) no longer contains authorization level (%lu) downgrading to (%lu)",  &v21,  42);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::updateClientAllowableAuthorizationMask(CLClientKeyPath *, CLLocationDictionaryUtilitiesA uthorizationMask, BOOL)",  "%s\n",  v18);
      }
    }

    if ((sub_10056840C(a1, (uint64_t)v7, v14, v10, 0, 1, 1) & 1) == 0)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v17 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t buf = 138543362;
        *(void *)int v30 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "Client %{public}@ missing for authorization update, but didn't we just create it?",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        int v21 = 138543362;
        id v22 = v7;
        LODWORD(v20) = 12;
        uint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Client %{public}@ missing for authorization update, but didn't we just create it?",  &v21,  v20);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLClientManager::updateClientAllowableAuthorizationMask(CLClientKeyPath *, CLLocationDictionaryUtilitiesA uthorizationMask, BOOL)",  "%s\n",  v19);
      }
    }
  }

NSMutableDictionary *sub_1005705D0(uint64_t a1, uint64_t a2, int a3)
{
  id v4 = [*(id *)(a1 + 136) dictionary];
  if (v4)
  {
    id v5 = v4;
    if ((_os_feature_enabled_impl("CoreLocation", "cl_pula") & 1) == 0)
    {
      uint64_t v6 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
      __int128 v34 = 0u;
      __int128 v35 = 0u;
      __int128 v36 = 0u;
      __int128 v37 = 0u;
      id v7 = [v5 countByEnumeratingWithState:&v34 objects:v44 count:16];
      if (!v7) {
        return v6;
      }
      id v8 = v7;
      unint64_t v28 = v6;
      int v29 = a3;
      uint64_t v9 = *(void *)v35;
LABEL_6:
      uint64_t v10 = 0LL;
      while (1)
      {
        if (*(void *)v35 != v9) {
          objc_enumerationMutation(v5);
        }
        __int128 v11 = *(void **)(*((void *)&v34 + 1) + 8 * v10);
        id v12 = [v5 objectForKeyedSubscript:v11];
        uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSDictionary);
        if ((objc_opt_isKindOfClass(v12, v13) & 1) == 0
          || ([v11 isEqualToString:@"e:"] & 1) != 0
          || ([v11 isEqualToString:@"p:"] & 1) != 0
          || objc_msgSend( objc_msgSend(v5, "objectForKeyedSubscript:", v11),  "objectForKeyedSubscript:",  @"AnchorKeyPath")
          || objc_msgSend( objc_msgSend(v5, "objectForKeyedSubscript:", v11),  "objectForKeyedSubscript:",  @"PrimaryKeyPath")
          || objc_msgSend( objc_msgSend(v5, "objectForKeyedSubscript:", v11),  "objectForKeyedSubscript:",  @"AuthLimitingKeyPath")
          || !objc_msgSend( objc_msgSend(v5, "objectForKeyedSubscript:", v11),  "objectForKeyedSubscript:",  @"Authorization")
          && objc_msgSend( objc_msgSend(v5, "objectForKeyedSubscript:", v11),  "objectForKeyedSubscript:",  @"SuppressShowingInSettings"))
        {
          goto LABEL_15;
        }

        unint64_t v14 = +[CLClientKeyPath clientKeyPathWithClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientKey:",  v11);
        id v15 = [v5 objectForKeyedSubscript:v11];
        unint64_t v32 = v14;
        if ([*(id *)(a1 + 136) isKeyPathRegisteredSystemService:v14])
        {
          int v16 = v15;
          if (sub_100AE0AB0(v15) != 8
            && sub_100AE091C((const __CFString *)-[CLClientKeyPath bundlePath](v32, "bundlePath"))
            && (!v29 || sub_100AE0760(v15)))
          {
            goto LABEL_29;
          }
        }

        else
        {
          int v16 = v15;
          if (([v15 objectForKeyedSubscript:@"Authorization"]
             || [v15 objectForKeyedSubscript:@"SupportedAuthorizationMask"]
             || [v15 objectForKeyedSubscript:@"SubIdentities"])
            && (!v29 || sub_100AE0760(v15)))
          {
LABEL_29:
            id v17 = objc_msgSend(v16, "cl_deepMutableCopy");
            int v30 = v17;
            id v31 = -[NSString copy](-[CLClientKeyPath clientAnchor](v32, "clientAnchor"), "copy");
            if (v31 && v17)
            {
              sub_10056747C(a1, (uint64_t)v32, v17);
              if ([v17 objectForKeyedSubscript:@"PlatformSpecificBundleId"]
                && [v17 objectForKeyedSubscript:@"BundleId"])
              {
                objc_msgSend( v17,  "setObject:forKeyedSubscript:",  objc_msgSend(v17, "objectForKeyedSubscript:", @"PlatformSpecificBundleId"),  @"BundleId");
              }

              if ([*(id *)(a1 + 136) BOOLForKey:@"Hidden" atKeyPath:v32 defaultValue:0]) {
                objc_msgSend( v17,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  sub_10057C8DC(a1, (uint64_t)v32)),  @"SupportedAuthorizationMask");
              }
              sub_100AE2758(v17);
              -[NSMutableDictionary setObject:forKeyedSubscript:](v28, "setObject:forKeyedSubscript:", v17, v31);
            }

            else if (v17)
            {
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              __int16 v18 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)uint64_t buf = 68289283;
                *(_DWORD *)id v41 = 0;
                *(_WORD *)&v41[4] = 2082;
                *(void *)&v41[6] = "";
                __int16 v42 = 2113;
                uint64_t v43 = v11;
                _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Client CKP key is nil in CLClientManager::copyClients, key:%{private, loc ation:escape_only}@}",  buf,  0x1Cu);
                if (qword_101934980 != -1) {
                  dispatch_once(&qword_101934980, &stru_1018401A0);
                }
              }

              uint64_t v19 = (os_log_s *)qword_101934988;
              if (os_signpost_enabled((os_log_t)qword_101934988))
              {
                *(_DWORD *)uint64_t buf = 68289283;
                *(_DWORD *)id v41 = 0;
                *(_WORD *)&v41[4] = 2082;
                *(void *)&v41[6] = "";
                __int16 v42 = 2113;
                uint64_t v43 = v11;
                _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Client CKP key is nil in CLClientManager::copyClients",  "{msg%{public}.0s:Client CKP key is nil in CLClientManager::copyClients, key:%{private, loc ation:escape_only}@}",  buf,  0x1Cu);
              }
            }

            else
            {
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              uint64_t v20 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
              {
                int v21 = -[CLClientKeyPath clientAnchor](v32, "clientAnchor");
                *(_DWORD *)uint64_t buf = 138477827;
                *(void *)id v41 = v21;
                _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_FAULT,  "Client record is nil in CLClientManager::copyClients for clientKey %{private}@",  buf,  0xCu);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934980 != -1) {
                  dispatch_once(&qword_101934980, &stru_1018401A0);
                }
                uint64_t v22 = qword_101934988;
                __int16 v23 = -[CLClientKeyPath clientAnchor](v32, "clientAnchor");
                int v38 = 138477827;
                uint64_t v39 = v23;
                LODWORD(v27) = 12;
                uint64_t v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v22,  17LL,  "Client record is nil in CLClientManager::copyClients for clientKey %{private}@",  &v38,  v27);
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "CFDictionaryRef CLClientManager::copyClients(NSString *, BOOL)",  "%s\n",  v24);
              }
            }
          }
        }

NSMutableSet *sub_100570D10(uint64_t a1)
{
  uint64_t v2 = objc_opt_new(&OBJC_CLASS___NSMutableSet);
  __int128 v3 = *(void **)(a1 + 664);
  if (v3 != (void *)(a1 + 672))
  {
    do
    {
      id v4 = v3 + 4;
      -[NSMutableSet addObject:]( v2,  "addObject:",  -[CLClientKeyPath legacyClientKey]( +[CLClientKeyPath clientKeyPathWithClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v4)),  "legacyClientKey"));
      id v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          id v5 = (void *)*v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          uint64_t v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          __int128 v3 = v6;
        }

        while (!v7);
      }

      __int128 v3 = v6;
    }

    while (v6 != (void *)(a1 + 672));
  }

  return v2;
}

NSMutableSet *sub_100570E1C(uint64_t a1)
{
  uint64_t v2 = objc_opt_new(&OBJC_CLASS___NSMutableSet);
  __int128 v3 = *(void **)(a1 + 688);
  if (v3 != (void *)(a1 + 696))
  {
    do
    {
      id v4 = v3 + 4;
      -[NSMutableSet addObject:]( v2,  "addObject:",  -[CLClientKeyPath legacyClientKey]( +[CLClientKeyPath clientKeyPathWithClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientKey:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v4)),  "legacyClientKey"));
      id v5 = (void *)v3[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          id v5 = (void *)*v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          uint64_t v6 = (void *)v3[2];
          BOOL v7 = *v6 == (void)v3;
          __int128 v3 = v6;
        }

        while (!v7);
      }

      __int128 v3 = v6;
    }

    while (v6 != (void *)(a1 + 696));
  }

  return v2;
}

void sub_100570F5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100570F78(uint64_t a1, std::string *this)
{
  uint64_t v2 = *(void *)(a1 + 704);
  if (v2)
  {
    std::string::operator=(this, (const std::string *)(*(void *)(a1 + 688) + 32LL));
    std::string::size_type size = this->__r_.__value_.__s.__size_;
    if ((size & 0x80u) != 0LL) {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
    }
    if (!size)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v5 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "retrieved empty non-system location client key",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        v8[0] = 0;
        BOOL v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "retrieved empty non-system location client key",  v8,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLClientManager::getNonSystemLocationClientKey(std::string &)",  "%s\n",  v7);
      }
    }
  }

  return v2 != 0;
}

void sub_10057122C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10057130C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100571348(uint64_t a1, int *a2)
{
  uint64_t v4 = *a2;
  if (v4 < 9 && ((0x1DFu >> v4) & 1) != 0)
  {
    uint64_t v7 = dword_1012F1068[v4];
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      int v6 = *a2;
      *(_DWORD *)uint64_t buf = 67240192;
      int v14 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "unknown registsration result %{public}d",  buf,  8u);
    }

    uint64_t v7 = 0LL;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v8 = *a2;
      v12[0] = 67240192;
      v12[1] = v8;
      uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "unknown registsration result %{public}d",  v12,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLTypeAuthorizationStatus CLClientManager::registrationResultToAuthorizationStatus(const CLTypeRegistrationResult &)",  "%s\n",  v9);
      uint64_t v7 = 0LL;
    }
  }

  else {
    unsigned int v10 = 2;
  }
  if (v10 <= 2)
  {
    else {
      return v10;
    }
  }

  return v7;
}

void sub_100571634(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100571730( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100571764( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, int a8, double a9, double a10, double a11, unsigned __int8 a12, uint64_t a13)
{
  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_101840220);
  }
  __int16 v23 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint64_t v24 = *(void *)a2;
    }
    else {
      uint64_t v25 = *(void *)a3;
    }
    *(_DWORD *)uint64_t buf = 68291331;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v67 = 2082;
    id v68 = "";
    __int16 v69 = 2082;
    uint64_t v70 = v24;
    __int16 v71 = 2050;
    uint64_t v72 = a4;
    __int16 v73 = 2082;
    uint64_t v74 = v25;
    __int16 v75 = 2049;
    double v76 = a9;
    __int16 v77 = 2049;
    double v78 = a10;
    __int16 v79 = 2050;
    double v80 = a11;
    __int16 v81 = 2050;
    uint64_t v82 = a5;
    __int16 v83 = 2050;
    uint64_t v84 = a6;
    __int16 v85 = 2050;
    uint64_t v86 = a7;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Registration for InterestZone #pla, clientKey:%{public, location:escape_only}s, typ e:%{public, location:CLClientInterestZoneType}lld, zoneIdentifier:%{public, location:escape_only}s, lat: %{private}7f, lon:%{private}7f, radius:%{public}.3f, PhenolicLocation:%{public, location:C LClientPhenolicLocation}lld, ServiceMaskOperator:%{public, location:CLClientInterestZoneServiceMaskOperator}ll d, ProvenanceType:%{public, location:CLClientInterestZoneProvenanceType}lld}",  buf,  0x6Cu);
  }

  else {
    uint64_t v26 = *(void *)a2;
  }
  id v27 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v26)));
  if (([v27 isValidCKP] | a12))
  {
    if (([v27 isValidCKP] & 1) == 0)
    {
      else {
        uint64_t v28 = *(void *)a2;
      }
      id v29 = objc_msgSend( *(id *)(a1 + 136),  "registerClient:fromAuthSync:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v28)),  0);
      else {
        uint64_t v30 = *(void *)a3;
      }
      id v27 = objc_msgSend( *(id *)(a1 + 136),  "registerSubIdentity:withType:forAnchorKeyPath:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v30),  122,  v29);
    }

    if ((_DWORD)a4 == 2)
    {
      [*(id *)(a1 + 136) setInt:a5 forKey:@"PhenolicLocation" atKeyPath:v27];
    }

    else
    {
      if ((_DWORD)a4 != 1)
      {
        NSErrorUserInfoKey v60 = NSLocalizedDescriptionKey;
        __int128 v61 = @"AuthZone registration failed. Invalid ZoneType.";
        uint64_t v43 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v61,  &v60,  1LL);
        (*(void (**)(uint64_t, NSError *))(a13 + 16))( a13,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kCLErrorDomainPrivate,  5LL,  v43));
        return;
      }

      if (a11 >= 50.0)
      {
        if (a11 > 1000.0)
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          int v44 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
          {
            else {
              uint64_t v45 = *(void *)a2;
            }
            else {
              uint64_t v46 = *(void *)a3;
            }
            *(_DWORD *)uint64_t buf = 68289794;
            *(_DWORD *)&uint8_t buf[4] = 0;
            __int16 v67 = 2082;
            id v68 = "";
            __int16 v69 = 2082;
            uint64_t v70 = v45;
            __int16 v71 = 2082;
            uint64_t v72 = v46;
            __int16 v73 = 2050;
            uint64_t v74 = 0x408F400000000000LL;
            _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Zone radius too large. Updated to max threshold, ClientKey:%{public, location :escape_only}s, ZoneIdentifier:%{public, location:escape_only}s, MaxRadiusThreshold:%{public}.3f}",  buf,  0x30u);
          }

          a11 = 1000.0;
        }
      }

      else
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        id v31 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          else {
            uint64_t v32 = *(void *)a2;
          }
          else {
            uint64_t v33 = *(void *)a3;
          }
          *(_DWORD *)uint64_t buf = 68289794;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v67 = 2082;
          id v68 = "";
          __int16 v69 = 2082;
          uint64_t v70 = v32;
          __int16 v71 = 2082;
          uint64_t v72 = v33;
          __int16 v73 = 2050;
          uint64_t v74 = 0x4049000000000000LL;
          _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Zone radius too small. Updated to min threshold, ClientKey:%{public, location:e scape_only}s, ZoneIdentifier:%{public, location:escape_only}s, MinRadiusThreshold:%{public}.3f}",  buf,  0x30u);
        }

        a11 = 50.0;
      }

      if (!sub_1002954D0(a9, a10))
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v50 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
        {
          id v51 = [@"Registration : Invalid lat/lon." UTF8String];
          uint64_t v52 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
          uint64_t v53 = *(char *)(a3 + 23) >= 0 ? a3 : *(void *)a3;
          *(_DWORD *)uint64_t buf = 68289794;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v67 = 2082;
          id v68 = "";
          __int16 v69 = 2082;
          uint64_t v70 = (uint64_t)v51;
          __int16 v71 = 2082;
          uint64_t v72 = v52;
          __int16 v73 = 2082;
          uint64_t v74 = v53;
          _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:AuthZone operation failed., Error:%{public, location:escape_only}s, ClientKey :%{public, location:escape_only}s, ZoneIdentifier:%{public, location:escape_only}s}",  buf,  0x30u);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
        }

        __int16 v54 = (os_log_s *)qword_101934988;
        if (os_signpost_enabled((os_log_t)qword_101934988))
        {
          id v55 = [@"Registration : Invalid lat/lon." UTF8String];
          else {
            uint64_t v56 = *(void *)a2;
          }
          else {
            uint64_t v57 = *(void *)a3;
          }
          *(_DWORD *)uint64_t buf = 68289794;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v67 = 2082;
          id v68 = "";
          __int16 v69 = 2082;
          uint64_t v70 = (uint64_t)v55;
          __int16 v71 = 2082;
          uint64_t v72 = v56;
          __int16 v73 = 2082;
          uint64_t v74 = v57;
          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v54,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "AuthZone operation failed.",  "{msg%{public}.0s:AuthZone operation failed., Error:%{public, location:escape_only}s, ClientKey :%{public, location:escape_only}s, ZoneIdentifier:%{public, location:escape_only}s}",  buf,  0x30u);
        }

        if (a13)
        {
          NSErrorUserInfoKey v62 = NSLocalizedDescriptionKey;
          __int128 v63 = @"Registration : Invalid lat/lon.";
          uint64_t v58 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v63,  &v62,  1LL);
          (*(void (**)(uint64_t, NSError *))(a13 + 16))( a13,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kCLErrorDomainPrivate,  5LL,  v58));
        }

        return;
      }

      [*(id *)(a1 + 136) setDouble:@"Latitude" forKey:v27 atKeyPath:a9];
      [*(id *)(a1 + 136) setDouble:@"Longitude" forKey:v27 atKeyPath:a10];
      [*(id *)(a1 + 136) setDouble:@"Radius" forKey:v27 atKeyPath:a11];
    }

    [*(id *)(a1 + 136) setInt:a4 forKey:@"Type" atKeyPath:v27];
    [*(id *)(a1 + 136) setInt:a6 forKey:@"ServiceMaskOperator" atKeyPath:v27];
    [*(id *)(a1 + 136) setInt:a7 forKey:@"Provenance" atKeyPath:v27];
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v47 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      else {
        uint64_t v48 = *(void *)a2;
      }
      else {
        uint64_t v49 = *(void *)a3;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v67 = 2082;
      id v68 = "";
      __int16 v69 = 2082;
      uint64_t v70 = v48;
      __int16 v71 = 2082;
      uint64_t v72 = v49;
      _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:InterestZone registered, ClientKey:%{public, location:escape_only}s, ZoneIdentifi er:%{public, location:escape_only}s}",  buf,  0x26u);
    }

    if (a8
      && (sub_1010DDBC0(buf, "ZoneRegistration"), sub_10056DB04(a1, (uint64_t *)a2, (uint64_t *)buf), SBYTE3(v70) < 0))
    {
      operator delete(*(void **)buf);
      if (!a13) {
        return;
      }
    }

    else if (!a13)
    {
      return;
    }

    (*(void (**)(uint64_t, void))(a13 + 16))(a13, 0LL);
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int128 v34 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      id v35 = [@"Registration : Zone already exists and overriding is not allowed." UTF8String];
      uint64_t v36 = *(char *)(a2 + 23) >= 0 ? a2 : *(void *)a2;
      uint64_t v37 = *(char *)(a3 + 23) >= 0 ? a3 : *(void *)a3;
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v67 = 2082;
      id v68 = "";
      __int16 v69 = 2082;
      uint64_t v70 = (uint64_t)v35;
      __int16 v71 = 2082;
      uint64_t v72 = v36;
      __int16 v73 = 2082;
      uint64_t v74 = v37;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:AuthZone operation failed., Error:%{public, location:escape_only}s, ClientKey:% {public, location:escape_only}s, ZoneIdentifier:%{public, location:escape_only}s}",  buf,  0x30u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    int v38 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      id v39 = [@"Registration : Zone already exists and overriding is not allowed." UTF8String];
      else {
        uint64_t v40 = *(void *)a2;
      }
      else {
        uint64_t v41 = *(void *)a3;
      }
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v67 = 2082;
      id v68 = "";
      __int16 v69 = 2082;
      uint64_t v70 = (uint64_t)v39;
      __int16 v71 = 2082;
      uint64_t v72 = v40;
      __int16 v73 = 2082;
      uint64_t v74 = v41;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v38,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "AuthZone operation failed.",  "{msg%{public}.0s:AuthZone operation failed., Error:%{public, location:escape_only}s, ClientKey:% {public, location:escape_only}s, ZoneIdentifier:%{public, location:escape_only}s}",  buf,  0x30u);
    }

    if (a13)
    {
      NSErrorUserInfoKey v64 = NSLocalizedDescriptionKey;
      uint64_t v65 = @"Registration : Zone already exists and overriding is not allowed.";
      __int16 v42 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v65,  &v64,  1LL);
      (*(void (**)(uint64_t, NSError *))(a13 + 16))( a13,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kCLErrorDomainPrivate,  5LL,  v42));
    }
  }

void sub_10057223C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100572338( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100572414( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100572448(uint64_t a1, char *a2, char *a3, uint64_t a4, uint64_t a5)
{
  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_101840220);
  }
  unsigned int v10 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[23] >= 0) {
      __int128 v11 = a2;
    }
    else {
      __int128 v11 = *(char **)a2;
    }
    if (a3[23] >= 0) {
      id v12 = a3;
    }
    else {
      id v12 = *(char **)a3;
    }
    *(_DWORD *)uint64_t buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v30 = 2082;
    id v31 = "";
    __int16 v32 = 2082;
    uint64_t v33 = v11;
    __int16 v34 = 2082;
    id v35 = v12;
    __int16 v36 = 1026;
    LODWORD(v37) = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:SetRelevanceForInterestZone, clientKey:%{public, location:escape_only}s, zoneIdenti fier:%{public, location:escape_only}s, isRelevant:%{public}hhd}",  buf,  0x2Cu);
  }

  if (a2[23] >= 0) {
    uint64_t v13 = a2;
  }
  else {
    uint64_t v13 = *(char **)a2;
  }
  id v14 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v13)));
  if ([v14 isValidCKP])
  {
    if (a3[23] >= 0) {
      id v15 = (uint64_t *)a3;
    }
    else {
      id v15 = *(uint64_t **)a3;
    }
    id v16 = objc_msgSend( v14,  "clientKeyPathWithReplacementSubIdentityId:subIdentityType:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v15),  122);
    [*(id *)(a1 + 136) setBool:a4 forKey:@"Relevant" atKeyPath:v16];
    sub_1010DDBC0(buf, "");
    sub_100544214(a1, v16, (uint64_t)buf);
    if (SBYTE3(v33) < 0)
    {
      operator delete(*(void **)buf);
      if (!a5) {
        return;
      }
    }

    else if (!a5)
    {
      return;
    }

    uint64_t v26 = 0LL;
LABEL_44:
    (*(void (**)(uint64_t, NSError *))(a5 + 16))(a5, v26);
    return;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v17 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
  {
    __int16 v18 = (char *)[@"setRelevance : Zone not found." UTF8String];
    uint64_t v19 = a2[23] >= 0 ? a2 : *(char **)a2;
    uint64_t v20 = a3[23] >= 0 ? (uint64_t *)a3 : *(uint64_t **)a3;
    *(_DWORD *)uint64_t buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v30 = 2082;
    id v31 = "";
    __int16 v32 = 2082;
    uint64_t v33 = v18;
    __int16 v34 = 2082;
    id v35 = v19;
    __int16 v36 = 2082;
    uint64_t v37 = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:AuthZone operation failed., Error:%{public, location:escape_only}s, ClientKey:%{p ublic, location:escape_only}s, ZoneIdentifier:%{public, location:escape_only}s}",  buf,  0x30u);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
  }

  int v21 = (os_log_s *)qword_101934988;
  if (os_signpost_enabled((os_log_t)qword_101934988))
  {
    uint64_t v22 = (char *)[@"setRelevance : Zone not found." UTF8String];
    if (a2[23] >= 0) {
      __int16 v23 = a2;
    }
    else {
      __int16 v23 = *(char **)a2;
    }
    if (a3[23] >= 0) {
      uint64_t v24 = a3;
    }
    else {
      uint64_t v24 = *(char **)a3;
    }
    *(_DWORD *)uint64_t buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v30 = 2082;
    id v31 = "";
    __int16 v32 = 2082;
    uint64_t v33 = v22;
    __int16 v34 = 2082;
    id v35 = v23;
    __int16 v36 = 2082;
    uint64_t v37 = (uint64_t *)v24;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v21,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "AuthZone operation failed.",  "{msg%{public}.0s:AuthZone operation failed., Error:%{public, location:escape_only}s, ClientKey:%{p ublic, location:escape_only}s, ZoneIdentifier:%{public, location:escape_only}s}",  buf,  0x30u);
  }

  if (a5)
  {
    NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
    uint64_t v28 = @"setRelevance : Zone not found.";
    uint64_t v25 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v28,  &v27,  1LL);
    uint64_t v26 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kCLErrorDomainPrivate,  5LL,  v25);
    goto LABEL_44;
  }

void sub_100572860( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100572920( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005729EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100572A20(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_101840220);
  }
  int v8 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
  {
    if (a2[23] >= 0) {
      uint64_t v9 = a2;
    }
    else {
      uint64_t v9 = *(char **)a2;
    }
    if (a3[23] >= 0) {
      unsigned int v10 = a3;
    }
    else {
      unsigned int v10 = *(char **)a3;
    }
    *(_DWORD *)uint64_t buf = 68289538;
    int v34 = 0;
    __int16 v35 = 2082;
    __int16 v36 = "";
    __int16 v37 = 2082;
    int v38 = v9;
    __int16 v39 = 2082;
    uint64_t v40 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Delete InterestZone, clientKey:%{public, location:escape_only}s, zoneIdentifier:% {public, location:escape_only}s}",  buf,  0x26u);
  }

  if (a2[23] >= 0) {
    __int128 v11 = a2;
  }
  else {
    __int128 v11 = *(char **)a2;
  }
  id v12 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v11)));
  if ([v12 isValidCKP])
  {
    if (a3[23] >= 0) {
      uint64_t v13 = (uint64_t *)a3;
    }
    else {
      uint64_t v13 = *(uint64_t **)a3;
    }
    id v14 = objc_msgSend( v12,  "clientKeyPathWithReplacementSubIdentityId:subIdentityType:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v13),  122);
    sub_1010DDBC0(__p, "ClientRemoved");
    sub_10054BFD4(a1, v14, 1, (uint64_t *)__p);
    if (v30 < 0) {
      operator delete(__p[0]);
    }
    id v15 = *(void **)(a1 + 352);
    if (a2[23] >= 0) {
      id v16 = a2;
    }
    else {
      id v16 = *(char **)a2;
    }
    id v17 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v16);
    if (a3[23] >= 0) {
      __int16 v18 = (uint64_t *)a3;
    }
    else {
      __int16 v18 = *(uint64_t **)a3;
    }
    objc_msgSend( v15,  "stopCircularZoneMonitoringForClient:withZoneId:",  v17,  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v18));
    if (a4)
    {
      uint64_t v19 = 0LL;
LABEL_49:
      (*(void (**)(uint64_t, NSError *))(a4 + 16))(a4, v19);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v20 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      int v21 = (char *)[@"deleteZone : Zone not found." UTF8String];
      uint64_t v22 = a2[23] >= 0 ? a2 : *(char **)a2;
      __int16 v23 = a3[23] >= 0 ? (uint64_t *)a3 : *(uint64_t **)a3;
      *(_DWORD *)uint64_t buf = 68289794;
      int v34 = 0;
      __int16 v35 = 2082;
      __int16 v36 = "";
      __int16 v37 = 2082;
      int v38 = v21;
      __int16 v39 = 2082;
      uint64_t v40 = v22;
      __int16 v41 = 2082;
      __int16 v42 = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:AuthZone operation failed., Error:%{public, location:escape_only}s, ClientKey:% {public, location:escape_only}s, ZoneIdentifier:%{public, location:escape_only}s}",  buf,  0x30u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v24 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      uint64_t v25 = (char *)[@"deleteZone : Zone not found." UTF8String];
      if (a2[23] >= 0) {
        uint64_t v26 = a2;
      }
      else {
        uint64_t v26 = *(char **)a2;
      }
      if (a3[23] >= 0) {
        NSErrorUserInfoKey v27 = a3;
      }
      else {
        NSErrorUserInfoKey v27 = *(char **)a3;
      }
      *(_DWORD *)uint64_t buf = 68289794;
      int v34 = 0;
      __int16 v35 = 2082;
      __int16 v36 = "";
      __int16 v37 = 2082;
      int v38 = v25;
      __int16 v39 = 2082;
      uint64_t v40 = v26;
      __int16 v41 = 2082;
      __int16 v42 = (uint64_t *)v27;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v24,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "AuthZone operation failed.",  "{msg%{public}.0s:AuthZone operation failed., Error:%{public, location:escape_only}s, ClientKey:% {public, location:escape_only}s, ZoneIdentifier:%{public, location:escape_only}s}",  buf,  0x30u);
    }

    if (a4)
    {
      NSErrorUserInfoKey v31 = NSLocalizedDescriptionKey;
      __int16 v32 = @"deleteZone : Zone not found.";
      uint64_t v28 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v32,  &v31,  1LL);
      uint64_t v19 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kCLErrorDomainPrivate,  5LL,  v28);
      goto LABEL_49;
    }
  }

void sub_100572E48( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100572F48(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100573038(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100573060(uint64_t a1)
{
  uint64_t v5 = 0LL;
  int v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  char v8 = 0;
  uint64_t v1 = *(void **)(a1 + 136);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_10057D1F4;
  v4[3] = &unk_10183F9F8;
  v4[4] = &v5;
  void v4[5] = a1;
  [v1 iterateAllAnchorKeyPathsWithBlock:v4];
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1005730F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_100573148(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if (v3)
  {
    [v3 cppClientKey];
  }

  else
  {
    __p[0] = 0LL;
    __p[1] = 0LL;
    uint64_t v7 = 0LL;
  }

  BOOL v4 = a1 + 696 != sub_10008E8D0(a1 + 688, (const void **)__p);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

void sub_1005731E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005732A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1005734C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1005734D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if (([v5 isValidCKP] & 1) == 0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v17 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      *(void *)uint64_t buf = 68289026LL;
      __int16 v70 = 2082;
      __int16 v71 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient: unknown client}",  buf,  0x12u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v18 = qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      *(void *)uint64_t buf = 68289026LL;
      __int16 v70 = 2082;
      __int16 v71 = "";
      id v14 = "#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient: unknown client";
      id v15 = "{msg%{public}.0s:#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient: unknown client}";
      id v16 = (os_log_s *)v18;
      uint32_t v19 = 18;
LABEL_31:
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v14,  v15,  buf,  v19);
      return;
    }

    return;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  int v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t buf = 68289282LL;
    __int16 v70 = 2082;
    __int16 v71 = "";
    __int16 v72 = 2114;
    *(void *)__int16 v73 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient, Client:%{public, locatio n:escape_only}@}",  buf,  0x1Cu);
  }

  id v67 = 0LL;
  if (!a3)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v20 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      *(void *)uint64_t buf = 68289282LL;
      __int16 v70 = 2082;
      __int16 v71 = "";
      __int16 v72 = 2114;
      *(void *)__int16 v73 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient may not take nil data, Cl ient:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v21 = qword_101934988;
    if (!os_signpost_enabled((os_log_t)qword_101934988)) {
      return;
    }
    *(void *)uint64_t buf = 68289282LL;
    __int16 v70 = 2082;
    __int16 v71 = "";
    __int16 v72 = 2114;
    *(void *)__int16 v73 = v5;
    id v14 = "#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient may not take nil data";
    id v15 = "{msg%{public}.0s:#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient may not take nil data, "
          "Client:%{public, location:escape_only}@}";
    goto LABEL_29;
  }

  uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSString);
  id v9 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v7,  v8,  objc_opt_class(&OBJC_CLASS___NSNumber),  0LL),  a3,  &v67);
  if (!v67)
  {
    uint64_t v22 = v9;
    id v23 = objc_msgSend( objc_msgSend( v9,  "objectsForKeys:notFoundMarker:",  &off_1018D6D18,  +[NSNull null](NSNull, "null")),  "count");
    if (v23 != [&off_1018D6D18 count])
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v29 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        id v30 = [&off_1018D6D18 count];
        *(void *)uint64_t buf = 68289538LL;
        __int16 v70 = 2082;
        __int16 v71 = "";
        __int16 v72 = 2050;
        *(void *)__int16 v73 = v30;
        *(_WORD *)&v73[8] = 2050;
        uint64_t v74 = (uint64_t)v23;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#TemporaryAuth missing one or more keys from decoded dict, target:%{public}lu,  found:%{public}lu}",  buf,  0x26u);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      uint64_t v28 = qword_101934988;
      if (!os_signpost_enabled((os_log_t)qword_101934988)) {
        return;
      }
      id v31 = [&off_1018D6D18 count];
      *(void *)uint64_t buf = 68289538LL;
      __int16 v70 = 2082;
      __int16 v71 = "";
      __int16 v72 = 2050;
      *(void *)__int16 v73 = v31;
      *(_WORD *)&v73[8] = 2050;
      uint64_t v74 = (uint64_t)v23;
      id v14 = "#TemporaryAuth missing one or more keys from decoded dict";
      id v15 = "{msg%{public}.0s:#TemporaryAuth missing one or more keys from decoded dict, target:%{public}lu, "
            "found:%{public}lu}";
LABEL_50:
      id v16 = (os_log_s *)v28;
      uint32_t v19 = 38;
      goto LABEL_31;
    }

    if ([v22 valueForKey:@"TransientInfoPayloadTimestamp"])
    {
      objc_msgSend(objc_msgSend(v22, "valueForKey:", @"TransientInfoPayloadTimestamp"), "doubleValue");
      double v25 = v24;
      double Current = CFAbsoluteTimeGetCurrent();
      if (vabdd_f64(Current, v25) <= 10.0)
      {
        int v33 = objc_msgSend( objc_msgSend(v22, "valueForKey:", @"TransientInfoPayloadHasWIU"),  "BOOLValue");
        int v34 = objc_msgSend( objc_msgSend(v22, "valueForKey:", @"TransientInfoPayloadHasPrecise"),  "BOOLValue");
        unsigned int v35 = objc_msgSend( objc_msgSend(v22, "valueForKey:", @"TransientInfoPayloadInUseness"),  "intValue");
        sub_1005527D4(*(void **)(a1 + 136), (uint64_t)v5, 2, v34);
        sub_1005527D4(*(void **)(a1 + 136), (uint64_t)v5, 1, v33);
        [*(id *)(a1 + 136) persist];
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        __int16 v36 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
        {
          *(void *)uint64_t buf = 68289794LL;
          __int16 v70 = 2082;
          __int16 v71 = "";
          __int16 v72 = 1026;
          *(_DWORD *)__int16 v73 = v34;
          *(_WORD *)&v73[4] = 1026;
          *(_DWORD *)&v73[6] = v35;
          LOWORD(v74) = 1026;
          *(_DWORD *)((char *)&v74 + 2) = v33;
          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient, hasPrecise:%{publi c}hhd, inUseInt:%{public}d, hasWIU:%{public}hhd}",  buf,  0x24u);
        }

        int v37 = sub_100FE435C(v35);
        if (v37)
        {
          id v38 = [v5 legacyClientKey];
          __int16 v39 = *(void **)(a1 + 376);
          if (v5)
          {
            [v5 cppClientKey];
          }

          else
          {
            v64[0] = 0LL;
            v64[1] = 0LL;
            uint64_t v65 = 0LL;
          }

          sub_1010DDBC0(v62, "setTemporaryAuthorizationStatusInfoForClient");
          sub_1008FDD4C(v39, (uint64_t)v64, (uint64_t)v62, v37, 1, (uint64_t *)buf);
          sub_100581594((__int128 *)buf, &v66);
          sub_1010DDBC0(__p, (char *)[v38 UTF8String]);
          id v68 = __p;
          uint64_t v40 = (uint64_t *)sub_10058A6FC( (uint64_t **)(a1 + 528),  (const void **)__p,  (uint64_t)&unk_1012CF090,  (_OWORD **)&v68);
          uint64_t v41 = v66;
          uint64_t v66 = 0LL;
          sub_10058A4D0(v40 + 7, v41);
          if (v61 < 0) {
            operator delete(__p[0]);
          }
          uint64_t v42 = v66;
          uint64_t v66 = 0LL;
          if (v42)
          {
            uint64_t v43 = (void *)sub_1008FDB5C(v42);
            operator delete(v43);
          }

          sub_1008FDB5C(buf);
          if (v63 < 0) {
            operator delete(v62[0]);
          }
          if (SHIBYTE(v65) < 0) {
            operator delete(v64[0]);
          }
          if ([*(id *)(a1 + 512) objectForKey:v5])
          {
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
            int v44 = (os_log_s *)qword_101934988;
            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
            {
              *(void *)uint64_t buf = 68289282LL;
              __int16 v70 = 2082;
              __int16 v71 = "";
              __int16 v72 = 2114;
              *(void *)__int16 v73 = v5;
              _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#TemporaryAuth #usesync release existing assertion timer, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
            }

            objc_msgSend(objc_msgSend(*(id *)(a1 + 512), "objectForKeyedSubscript:", v5), "invalidate");

            [*(id *)(a1 + 512) setObject:0 forKeyedSubscript:v5];
            id v45 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:v5];
            if ((!v45 || ![*(id *)(a1 + 392) objectForKeyedSubscript:v45])
              && [*(id *)(a1 + 520) objectForKeyedSubscript:v38])
            {
              uint64_t v46 = (char *)objc_msgSend(objc_msgSend(v5, "legacyClientKey"), "UTF8String");
              if (v46) {
                id v47 = v46;
              }
              else {
                id v47 = "";
              }
              sub_1010DDBC0(v58, v47);
              sub_10054D7E0(a1, (uint64_t *)v58);
              if (v59 < 0) {
                operator delete(v58[0]);
              }
              [*(id *)(a1 + 520) removeObjectForKey:v38];
              sub_10054D6C8();
            }
          }

          id v48 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:v5];
          if (v48 && [*(id *)(a1 + 392) objectForKeyedSubscript:v48])
          {
            uint64_t v49 = (char *)objc_msgSend(objc_msgSend(v5, "legacyClientKey"), "UTF8String");
            if (v49) {
              uint64_t v50 = v49;
            }
            else {
              uint64_t v50 = "";
            }
            sub_1010DDBC0(v56, v50);
            sub_10054D494(a1, (uint64_t *)v56);
            if (v57 < 0) {
              operator delete(v56[0]);
            }
            char v51 = 1;
          }

          else
          {
            char v51 = 0;
          }

          objc_msgSend( *(id *)(a1 + 512),  "setObject:forKeyedSubscript:",  objc_msgSend(*(id *)(a1 + 40), "newTimer"),  v5);
          id v52 = [*(id *)(a1 + 512) objectForKeyedSubscript:v5];
          objc_msgSend(objc_msgSend(*(id *)(a1 + 512), "objectForKeyedSubscript:", v5), "setNextFireDelay:", 10.0);
          id v53 = [*(id *)(a1 + 512) objectForKeyedSubscript:v5];
          v54[0] = _NSConcreteStackBlock;
          v54[1] = 3221225472LL;
          v54[2] = sub_1005815E8;
          v54[3] = &unk_1018400C0;
          v54[4] = v52;
          v54[5] = v5;
          char v55 = v51;
          v54[6] = v38;
          v54[7] = a1;
          [v53 setHandler:v54];
        }

        if ((v33 | v34) == 1)
        {
          sub_1010DDBC0(buf, "");
          sub_100544214(a1, v5, (uint64_t)buf);
          if ((v73[3] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }

        return;
      }

      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      NSErrorUserInfoKey v27 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        *(void *)uint64_t buf = 68289538LL;
        __int16 v70 = 2082;
        __int16 v71 = "";
        __int16 v72 = 2050;
        *(void *)__int16 v73 = (uint64_t)Current;
        *(_WORD *)&v73[8] = 2050;
        uint64_t v74 = (uint64_t)v25;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient stale info received, tN ow:%{public}ld, sentTime:%{public}ld}",  buf,  0x26u);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      uint64_t v28 = qword_101934988;
      if (!os_signpost_enabled((os_log_t)qword_101934988)) {
        return;
      }
      *(void *)uint64_t buf = 68289538LL;
      __int16 v70 = 2082;
      __int16 v71 = "";
      __int16 v72 = 2050;
      *(void *)__int16 v73 = (uint64_t)Current;
      *(_WORD *)&v73[8] = 2050;
      uint64_t v74 = (uint64_t)v25;
      id v14 = "#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient stale info received";
      id v15 = "{msg%{public}.0s:#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient stale info received, "
            "tNow:%{public}ld, sentTime:%{public}ld}";
      goto LABEL_50;
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v32 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      *(void *)uint64_t buf = 68289282LL;
      __int16 v70 = 2082;
      __int16 v71 = "";
      __int16 v72 = 2114;
      *(void *)__int16 v73 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient failed to find a timestamp in the packaged data. Ignoring the packet, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v21 = qword_101934988;
    if (!os_signpost_enabled((os_log_t)qword_101934988)) {
      return;
    }
    *(void *)uint64_t buf = 68289282LL;
    __int16 v70 = 2082;
    __int16 v71 = "";
    __int16 v72 = 2114;
    *(void *)__int16 v73 = v5;
    id v14 = "#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient failed to find a timestamp in the packaged data. I"
          "gnoring the packet";
    id v15 = "{msg%{public}.0s:#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient failed to find a timestamp "
          "in the packaged data. Ignoring the packet, Client:%{public, location:escape_only}@}";
LABEL_29:
    id v16 = (os_log_s *)v21;
    goto LABEL_30;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  unsigned int v10 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
  {
    id v11 = objc_msgSend(objc_msgSend(v67, "description"), "UTF8String");
    *(void *)uint64_t buf = 68289282LL;
    __int16 v70 = 2082;
    __int16 v71 = "";
    __int16 v72 = 2082;
    *(void *)__int16 v73 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#TemporaryAuth encountered error while decoding, error:%{public, location:escape_only}s}",  buf,  0x1Cu);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
  }

  uint64_t v12 = qword_101934988;
  if (os_signpost_enabled((os_log_t)qword_101934988))
  {
    id v13 = objc_msgSend(objc_msgSend(v67, "description"), "UTF8String");
    *(void *)uint64_t buf = 68289282LL;
    __int16 v70 = 2082;
    __int16 v71 = "";
    __int16 v72 = 2082;
    *(void *)__int16 v73 = v13;
    id v14 = "#TemporaryAuth encountered error while decoding";
    id v15 = "{msg%{public}.0s:#TemporaryAuth encountered error while decoding, error:%{public, location:escape_only}s}";
    id v16 = (os_log_s *)v12;
LABEL_30:
    uint32_t v19 = 28;
    goto LABEL_31;
  }

void sub_100574284( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *__p, uint64_t a29, int a30, __int16 a31, char a32, char a33, void *a34, uint64_t a35, int a36, __int16 a37, char a38, char a39, void *a40, uint64_t a41, int a42, __int16 a43, char a44, char a45, uint64_t a46, uint64_t a47, int a48, __int16 a49, char a50,char a51,uint64_t a52)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10057440C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

NSData *sub_100574420(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if ([v3 isValidCKP])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v4 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      int v23 = 0;
      __int16 v24 = 2082;
      double v25 = "";
      __int16 v26 = 2114;
      uint64_t v27 = (uint64_t)v3;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#TemporaryAuth retrieveTemporaryAuthorizationStatusInfoForClient, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    unsigned int v5 = [*(id *)(a1 + 136) intForKey:@"TemporaryAuthorization" atKeyPath:v3 defaultValue:0];
    int v21 = sub_1008FE810(*(void *)(a1 + 376), v3);
    char v6 = v5;
    int v7 = v5 & 1;
    uint64_t v8 = sub_100FE4314(&v21);
    double Current = CFAbsoluteTimeGetCurrent();
    v34[0] = @"TransientInfoPayloadTimestamp";
    v35[0] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
    v34[1] = @"TransientInfoPayloadInUseness";
    v35[1] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v8);
    void v34[2] = @"TransientInfoPayloadHasPrecise";
    v35[2] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", ((unint64_t)v5 >> 1) & 1);
    v34[3] = @"TransientInfoPayloadHasWIU";
    v35[3] = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v5 & 1);
    unsigned int v10 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v35,  v34,  4LL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v11 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68290050;
      __int16 v24 = 2082;
      int v23 = 0;
      double v25 = "";
      __int16 v26 = 2050;
      uint64_t v27 = (uint64_t)Current;
      __int16 v28 = 1026;
      int v29 = v8;
      __int16 v30 = 1026;
      int v31 = v7;
      __int16 v32 = 1026;
      int v33 = (unint64_t)(v6 & 2) >> 1;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#TemporaryAuth retrieveTemporaryAuthorizationStatusInfoForClient, tNow:%{public}ld, inUse:%{public}d, hasTempWIU:%{public}hhd, hasTempPrecise:%{public}hhd}",  buf,  0x2Eu);
    }

    id v20 = 0LL;
    uint64_t v12 = +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v10,  1LL,  &v20);
    if (v20)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v13 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        id v14 = objc_msgSend(objc_msgSend(v20, "description"), "UTF8String");
        *(_DWORD *)uint64_t buf = 68289282;
        int v23 = 0;
        __int16 v24 = 2082;
        double v25 = "";
        __int16 v26 = 2082;
        uint64_t v27 = (uint64_t)v14;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#TemporaryAuth encountered error while converting, error:%{public, location:escape_only}s}",  buf,  0x1Cu);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
      }

      id v15 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        id v16 = objc_msgSend(objc_msgSend(v20, "description"), "UTF8String");
        *(_DWORD *)uint64_t buf = 68289282;
        int v23 = 0;
        __int16 v24 = 2082;
        double v25 = "";
        __int16 v26 = 2082;
        uint64_t v27 = (uint64_t)v16;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#TemporaryAuth encountered error while converting",  "{msg%{public}.0s:#TemporaryAuth encountered error while converting, error:%{public, location:escape_only}s}",  buf,  0x1Cu);
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v17 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v23 = 0;
      __int16 v24 = 2082;
      double v25 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#TemporaryAuth retrieveTemporaryAuthorizationStatusInfoForClient: unknown client}",  buf,  0x12u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    uint64_t v18 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v23 = 0;
      __int16 v24 = 2082;
      double v25 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#TemporaryAuth retrieveTemporaryAuthorizationStatusInfoForClient: unknown client",  "{msg%{public}.0s:#TemporaryAuth retrieveTemporaryAuthorizationStatusInfoForClient: unknown client}",  buf,  0x12u);
    }

    return 0LL;
  }

  return v12;
}

void sub_100574A10(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

double sub_100574A24(uint64_t a1, void *a2, double a3)
{
  id v6 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if ([v6 isValidCKP])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 138412290;
      *(void *)uint32_t v19 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "#appclip setting for bundle ID %@", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v16 = 138412290;
      id v17 = v6;
      id v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#appclip setting for bundle ID %@",  &v16,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "double CLClientManager::setOrChangeAppClipAuthorizationTime(CLClientKeyPath *, double)",  "%s\n",  v15);
    }

    id v8 = [*(id *)(a1 + 136) doubleForKey:@"AuthorizationRegisterTime" atKeyPath:v6 defaultValue:-1.0];
    if (v9 == -1.0) {
      double v9 = TMGetKernelMonotonicClock(v8);
    }
    double v10 = v9;
    [*(id *)(a1 + 136) setDouble:@"AuthorizationRegisterTime" forKey:v6 atKeyPath:v9 + a3];
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v11 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)uint32_t v19 = 0;
      *(_WORD *)&v19[4] = 2082;
      *(void *)&void v19[6] = "";
      __int16 v20 = 2114;
      id v21 = v6;
      __int16 v22 = 2050;
      double v23 = v10;
      __int16 v24 = 2050;
      double v25 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#appclip setOrChangeAppClipAuthorizationTime, Client:%{public, location:escape_only }@, registrationTime:%{public}f, delta:%{public}f}",  buf,  0x30u);
    }

    [*(id *)(a1 + 136) persist];
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v12 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint32_t v19 = 0;
      *(_WORD *)&v19[4] = 2082;
      *(void *)&void v19[6] = "";
      __int16 v20 = 2114;
      id v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#appclip no such client, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    id v13 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint32_t v19 = 0;
      *(_WORD *)&v19[4] = 2082;
      *(void *)&void v19[6] = "";
      __int16 v20 = 2114;
      id v21 = a2;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#appclip no such client",  "{msg%{public}.0s:#appclip no such client, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }
  }

  return -1.0;
}

void sub_100574E34()
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v0 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "#warning #appclip App Clips not supported on non-iOS platforms, this call has no effect",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    v2[0] = 0;
    uint64_t v1 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#warning #appclip App Clips not supported on non-iOS platforms, this call has no effect",  v2,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::clearAppClipAuthorizationIfNecessary(CFTimeInterval)",  "%s\n",  v1);
  }

uint64_t sub_1005750B0(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = off_101840410;
  *(void *)(a1 + _Block_object_dispose(va, 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  else {
    uint64_t v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

id sub_100575184(uint64_t a1, __int128 *a2, uint64_t a3, uint64_t a4)
{
  int v7 = sub_1005751C8(a2);
  return _[*(id *)(a1 + 16) setClients:v7 regionOfType:a3 to:a4];
}

CLCppContainer *sub_1005751C8(__int128 *a1)
{
  uint64_t v2 = (char *)operator new(0xB8uLL);
  sub_1011F69B0(v2, a1);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_100589CC8;
  v4[3] = &unk_10181D3D0;
  v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  0LL,  184LL);
}

void sub_10057524C(_Unwind_Exception *a1)
{
}

id sub_100575260(uint64_t a1, __int128 *a2, uint64_t a3)
{
  return [*(id *)(a1 + 16) setClients:sub_1005751C8(a2) significantLocationVisitTo:a3];
}

void *sub_100575294(void *a1, uint64_t a2)
{
  *a1 = a2;
  *(_OWORD *)(a1 + 1) = xmmword_1012F0B10;
  BOOL v4 = a1 + 1;
  unsigned int v5 = a1 + 2;
  a1[3] = 0LL;
  if (a2 != 1)
  {
    if (a2) {
      goto LABEL_17;
    }
    uint64_t v6 = sub_1002F8DDC();
    if ((sub_1002A82BC(v6, "lastWifiImproveAccuracyNotification", v4) & 1) == 0) {
      *BOOL v4 = 0xBFF0000000000000LL;
    }
    sub_1002F0B04(buf);
    char v7 = sub_1002A82BC(*(uint64_t *)buf, "WifiImproveAccuracyNotificationInterval", v5);
    id v8 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      double v9 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      goto LABEL_14;
    }

void sub_100575660( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100575680(void *a1)
{
  if (a1[3])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v2 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      id v3 = "Unknown";
      if (*a1 == 1LL) {
        id v3 = "Bluetooth";
      }
      if (*a1) {
        BOOL v4 = (char *)v3;
      }
      else {
        BOOL v4 = "Wifi";
      }
      sub_1010DDBC0(__p, v4);
      if (v19 >= 0) {
        unsigned int v5 = __p;
      }
      else {
        unsigned int v5 = (void **)__p[0];
      }
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "clear %s improve accuracy notification",  buf,  0xCu);
      if (v19 < 0) {
        operator delete(__p[0]);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v8 = qword_101934988;
      double v9 = "Unknown";
      if (*a1 == 1LL) {
        double v9 = "Bluetooth";
      }
      if (*a1) {
        unint64_t v10 = (char *)v9;
      }
      else {
        unint64_t v10 = "Wifi";
      }
      sub_1010DDBC0(buf, v10);
      if (v15 >= 0) {
        uint64_t v11 = buf;
      }
      else {
        uint64_t v11 = *(_BYTE **)buf;
      }
      int v16 = 136315138;
      uint64_t v17 = v11;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v8,  2LL,  "clear %s improve accuracy notification",  (const char *)&v16);
      if (v15 < 0) {
        operator delete(*(void **)buf);
      }
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::ImproveAccuracyNotification::clear()", "%s\n", v12);
    }

    uint64_t v6 = a1[3];
    a1[3] = 0LL;
    char v7 = (__CFRunLoop *)sub_10029228C();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100575A18;
    block[3] = &unk_10181D3D0;
    block[4] = v6;
    CFRunLoopPerformBlock(v7, kCFRunLoopCommonModes, block);
  }

void sub_100575938(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0LL;
  uint64_t v2 = (__CFRunLoop *)sub_10029228C();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1005759A8;
  block[3] = &unk_10181D3D0;
  block[4] = v1;
  CFRunLoopPerformBlock(v2, kCFRunLoopCommonModes, block);
}

void sub_1005759A8(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t sub_1005759B8(double *a1, double a2)
{
  double v2 = *a1;
  a1[1] = a2;
  id v3 = a1 + 1;
  if (v2 == 0.0)
  {
    BOOL v4 = "lastWifiImproveAccuracyNotification";
    goto LABEL_5;
  }

  if (*(void *)&v2 == 1LL)
  {
    BOOL v4 = "lastBluetoothImproveAccuracyNotification";
LABEL_5:
    uint64_t v5 = sub_1002F8DDC();
    sub_1002AC7B8(v5, v4, v3);
  }

  uint64_t v6 = sub_1002F8DDC();
  return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 944LL))(v6);
}

void sub_100575A18(uint64_t a1)
{
  double v2 = *(__CFUserNotification **)(a1 + 32);
  if (v2)
  {
    CFUserNotificationCancel(v2);
    CFRelease(*(CFTypeRef *)(a1 + 32));
  }

std::string::size_type sub_100575A50(std::string::size_type a1, void *a2)
{
  BOOL v4 = (void *)sub_1005780FC(a1, "CLClientManager", a2);
  *BOOL v4 = off_10183FE88;
  v4[14] = &off_10183FF70;
  *(void *)(a1 + 120) = -[CLClientManagerStateTracker initInSilo:withIdentifier:state:]( [CLClientManagerStateTracker alloc],  "initInSilo:withIdentifier:state:",  [a2 silo],  a1,  &stru_10183FFA8);
  id v5 = -[CLSettingsMirror initInUniverse:]( objc_alloc(&OBJC_CLASS___CLSettingsMirror),  "initInUniverse:",  *(void *)(a1 + 32));
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = v5;
  *(void *)(a1 + 240) = 0x40F5180000000000LL;
  __int16 v161 = (void *)(a1 + 240);
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 16_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_WORD *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 24_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_BYTE *)(a1 + 280) = 0;
  *(void *)(a1 + 296) = 0LL;
  *(void *)(a1 + 304) = 0LL;
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(a1 + 312) = 0;
  *(CLLocationCoordinate2D *)(a1 + 320) = kCLLocationCoordinate2DInvalid;
  *(void *)(a1 + 336) = 0LL;
  *(void *)(a1 + 360) = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  *(void *)(a1 + 36_Block_object_dispose(va, 8) = 0LL;
  __p[0].__r_.__value_.__r.__words[0] = a1;
  sub_100589D34(__p, (void *)(a1 + 32), (void *)(a1 + 376));
  uint64_t v6 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary);
  *(void *)(a1 + 400) = 0LL;
  *(void *)(a1 + 40_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 392) = v6;
  char v7 = objc_alloc(&OBJC_CLASS___NSMapTable);
  uint64_t v8 = sub_100BE54B8();
  *(void *)(a1 + 416) = -[NSMapTable initWithKeyPointerFunctions:valuePointerFunctions:capacity:]( v7,  "initWithKeyPointerFunctions:valuePointerFunctions:capacity:",  v8,  sub_100BE5544(),  10LL);
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_DWORD *)(a1 + 472) = 1065353216;
  *(void *)(a1 + 480) = 0LL;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_BYTE *)(a1 + 504) = 0;
  *(void *)(a1 + 52_Block_object_dispose(va, 8) = a1 + 536;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 56_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(a1 + 584) = 1065353216;
  *(void *)(a1 + 592) = 0x403E000000000000LL;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 600) = 0u;
  *(void *)(a1 + 616) = a1 + 624;
  *(void *)(a1 + 64_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 656) = 0LL;
  *(void *)(a1 + 640) = a1 + 648;
  *(void *)(a1 + 680) = 0LL;
  *(void *)(a1 + 672) = 0LL;
  *(void *)(a1 + 664) = a1 + 672;
  *(void *)(a1 + 704) = 0LL;
  *(void *)(a1 + 696) = 0LL;
  *(void *)(a1 + 68_Block_object_dispose(va, 8) = a1 + 696;
  *(void *)(a1 + 720) = 0LL;
  *(void *)(a1 + 72_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 712) = a1 + 720;
  *(_BYTE *)(a1 + 736) = sub_100295918();
  *(void *)(a1 + 76_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 760) = 0LL;
  *(void *)(a1 + 752) = a1 + 760;
  *(void *)(a1 + 792) = 0LL;
  *(void *)(a1 + 784) = 0LL;
  *(void *)(a1 + 776) = a1 + 784;
  *(void *)(a1 + 816) = 0LL;
  *(void *)(a1 + 80_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 800) = a1 + 808;
  *(void *)(a1 + 840) = 0LL;
  *(void *)(a1 + 832) = 0LL;
  *(void *)(a1 + 824) = a1 + 832;
  *(void *)(a1 + 864) = 0LL;
  *(void *)(a1 + 856) = 0LL;
  *(void *)(a1 + 84_Block_object_dispose(va, 8) = a1 + 856;
  *(void *)(a1 + 872) = 0LL;
  *(_DWORD *)(a1 + 880) = 2;
  *(void *)(a1 + 936) = 0LL;
  *(_OWORD *)(a1 + 904) = 0u;
  *(_OWORD *)(a1 + 920) = 0u;
  *(_OWORD *)(a1 + 88_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(a1 + 944) = 1065353216;
  double v9 = operator new(0x40uLL);
  _OWORD v9[2] = 0LL;
  void *v9 = off_101840518;
  v9[1] = 0LL;
  v9[3] = off_10183F878;
  v9[7] = 0LL;
  void v9[6] = 0LL;
  v9[4] = a1;
  void v9[5] = v9 + 6;
  *(void *)(a1 + 952) = v9 + 3;
  *(void *)(a1 + 960) = v9;
  *(void *)(a1 + 96_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 984) = 0LL;
  *(void *)(a1 + 976) = 0LL;
  __int16 v160 = (uint64_t *)(a1 + 968);
  *(void *)(a1 + 990) = 0LL;
  *(_BYTE *)(a1 + 99_Block_object_dispose(va, 8) = sub_100ADBC30();
  *(void *)(a1 + 1000) = 0LL;
  *(void *)(a1 + 100_Block_object_dispose(va, 8) =  objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "proxyForService:",  @"CLClientAuthorizationCache");
  *(void *)(a1 + 1016) = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  *(void *)(a1 + 1024) = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  *(void *)(a1 + 1032) = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  *(_BYTE *)(a1 + 1040) = 0;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(void *)(a1 + 104_Block_object_dispose(va, 8) = a1 + 1056;
  *(_BYTE *)(a1 + 1072) = 0;
  *(_OWORD *)(a1 + 1080) = 0u;
  *(_DWORD *)(a1 + 1096) = 0xFFFF;
  *(void *)(a1 + 110_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 1100) = 0LL;
  __asm { FMOV            V2.2D, #-1.0 }

  *(_OWORD *)(a1 + 1116) = xmmword_1012E0070;
  *(_OWORD *)(a1 + 1132) = _Q2;
  *(_OWORD *)(a1 + 114_Block_object_dispose(va, 8) = _Q2;
  *(_OWORD *)(a1 + 1164) = _Q2;
  *(_DWORD *)(a1 + 1180) = 0;
  *(void *)(a1 + 1184) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 120_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 1192) = 0LL;
  *(void *)(a1 + 1200) = 0LL;
  *(void *)(a1 + 1212) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 1220) = 0x7FFFFFFF;
  *(void *)(a1 + 1240) = 0LL;
  *(void *)(a1 + 1224) = 0LL;
  *(void *)(a1 + 1232) = 0LL;
  *(_BYTE *)(a1 + 124_Block_object_dispose(va, 8) = 0;
  *(_OWORD *)(a1 + 1256) = 0u;
  *(_OWORD *)(a1 + 1272) = 0u;
  *(void *)(a1 + 128_Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(a1 + 1296) = 1065353216;
  *(void *)(a1 + 1416) =  objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "proxyForService:",  @"CLStatusBarIconManager");
  *(_OWORD *)(a1 + 1424) = 0u;
  *(_OWORD *)(a1 + 1440) = 0u;
  *(_DWORD *)(a1 + 1456) = 1065353216;
  *(_OWORD *)(a1 + 1464) = 0u;
  *(void *)(a1 + 1480) =  objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "proxyForService:forClient:",  @"CLCapabilityMonitor",  @"CLClientManager");
  *(void *)(a1 + 148_Block_object_dispose(va, 8) =  objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "proxyForService:forClient:",  @"CLWifiTilesManager",  @"CLClientManager");
  *(void *)(a1 + 1496) = 0LL;
  *(_BYTE *)(a1 + 1504) = 0;
  BOOL v175 = 0;
  uint64_t v15 = sub_1002F8DDC();
  sub_1002A6FD4(v15, (uint64_t)@"kAuthorizationDecisionsNeedsMigration", &v175);
  sub_100309D64(0, __p);
  if ((__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v16 = __p;
  }
  else {
    int v16 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
  }
  uint64_t v17 = -[NSString stringByAppendingPathComponent:]( +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v16),  "stringByAppendingPathComponent:",  @"clients.plist");
  sub_100569E50(a1, (uint64_t)v17, v175);
  if (v175) {
    sub_10056EDC8(a1);
  }
  sub_100559F28(a1);
  *(_OWORD *)(a1 + 1396) = 0u;
  *(_OWORD *)(a1 + 136_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 1384) = 0u;
  *(_OWORD *)(a1 + 1336) = 0u;
  *(_OWORD *)(a1 + 1352) = 0u;
  *(_OWORD *)(a1 + 1304) = 0u;
  *(_OWORD *)(a1 + 1320) = 0u;
  v174[0] = _NSConcreteStackBlock;
  v174[1] = 3221225472LL;
  v174[2] = sub_1005781C0;
  v174[3] = &unk_10183FFC8;
  v174[4] = a1;
  [*(id *)(a1 + 128) setSettingsChangeHandler:v174];
  *(_BYTE *)(a1 + 232) = [*(id *)(a1 + 128) BOOLForKey:@"CLCM.AllowPromptRecording" defaultValue:*(unsigned __int8 *)(a1 + 232)];
  id v18 = [*(id *)(a1 + 40) newTimer];
  *(void *)(a1 + 256) = v18;
  v173[0] = _NSConcreteStackBlock;
  v173[1] = 3221225472LL;
  v173[2] = sub_1005781F4;
  v173[3] = &unk_10181D3D0;
  v173[4] = a1;
  [v18 setHandler:v173];
  sub_100309D64(0, __p);
  if ((__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    char v19 = __p;
  }
  else {
    char v19 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
  }
  uint64_t v20 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v19);
  id v21 =  -[CLHRequestArchive initWithDirectory:itemCountThresholdForAutoCleanUp:]( objc_alloc(&OBJC_CLASS___CLHRequestArchive),  "initWithDirectory:itemCountThresholdForAutoCleanUp:",  -[NSString stringByAppendingPathComponent:]( v20,  "stringByAppendingPathComponent:",  +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "locationUtilityEventArchive")),  300LL);
  *(void *)(a1 + 48_Block_object_dispose(va, 8) = v21;
  -[CLHRequestArchive setRotationInterval:](v21, "setRotationInterval:", 86400.0);
  CFAbsoluteTime v22 = CFAbsoluteTimeGetCurrent() + -432000.0;
  [*(id *)(a1 + 488) pruneSecondaryDataOlderThan:v22];
  *(void *)(a1 + 496) =  objc_msgSend( sub_10054EC9C( a1,  (uint64_t) -[NSDate initWithTimeIntervalSinceReferenceDate:]( [NSDate alloc],  "initWithTimeIntervalSinceReferenceDate:",  v22)),  "lastObject");
  sub_1004F2598();
  double v23 = (void *)(a1 + 400);
  if (sub_1004F7A04())
  {
    *double v23 = objc_alloc_init(&OBJC_CLASS___STLocationStatusDomainPublisher);
    *(void *)(a1 + 40_Block_object_dispose(va, 8) = objc_alloc_init(&OBJC_CLASS___STBackgroundActivitiesStatusDomainPublisher);
    *(void *)(a1 + 424) = 1LL;
  }

  else
  {
    *double v23 = 0LL;
    *(void *)(a1 + 40_Block_object_dispose(va, 8) = 0LL;
  }

  id v24 = [*(id *)(a1 + 128) arrayForKey:@"ResetIdentifiers" defaultValue:0];
  __int16 v159 = (id *)(a1 + 32);
  int v25 = [*(id *)(a1 + 128) intForKey:@"ResetRetrialCount" defaultValue:0];
  if ([v24 count])
  {
    if (v25 > 1)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      double v28 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(__p[0].__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "ResetRetrialCount exhausted.",  (uint8_t *)__p,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(__p, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        LOWORD(v17_Block_object_dispose(va, 8) = 0;
        __int16 v155 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "ResetRetrialCount exhausted.",  &v178,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLClientManager::CLClientManager(id<CLIntersiloUniverse>)",  "%s\n",  (const char *)v155);
        if (v155 != __p) {
          free(v155);
        }
      }

      [*(id *)(a1 + 128) setInt:0 forKey:@"ResetRetrialCount"];
      [*(id *)(a1 + 128) setArray:0 forKey:@"ResetIdentifiers"];
    }

    else
    {
      uint64_t v26 = (v25 + 1);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      double v27 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        __p[0].__r_.__value_.__r.__words[0] = 68289538LL;
        LOWORD(__p[0].__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
        WORD1(__p[0].__r_.__value_.__r.__words[2]) = 2050;
        *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[2] + 4) = (int)v26;
        WORD2(__p[1].__r_.__value_.__r.__words[0]) = 2114;
        *(std::string::size_type *)((char *)__p[1].__r_.__value_.__r.__words + 6) = (std::string::size_type)v24;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Incomplete Reset, trying again, ResetRetrialCount:%{public}ld, Pending ResetIde ntifiers:%{public, location:escape_only}@}",  (uint8_t *)__p,  0x26u);
      }

      [*(id *)(a1 + 128) setInt:v26 forKey:@"ResetRetrialCount"];
      [*(id *)(a1 + 256) setNextFireDelay:115.0];
    }
  }

  sub_100546DA0(a1);
  int v29 = *(void **)(a1 + 136);
  __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)_NSConcreteStackBlock;
  __p[0].__r_.__value_.__l.__size_ = 3221225472LL;
  __p[0].__r_.__value_.__l.__cap_ = (std::string::size_type)sub_100547DB8;
  __p[1].__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_10183F8B0;
  __p[1].__r_.__value_.__l.__size_ = a1;
  [v29 iterateAllAnchorKeyPathsWithBlock:__p];
  char v30 = *(void **)(a1 + 136);
  __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)_NSConcreteStackBlock;
  __p[0].__r_.__value_.__l.__size_ = 3221225472LL;
  __p[0].__r_.__value_.__l.__cap_ = (std::string::size_type)sub_10057AE0C;
  __p[1].__r_.__value_.__r.__words[0] = (std::string::size_type)&unk_10183F8B0;
  __p[1].__r_.__value_.__l.__size_ = a1;
  [v30 iterateAllAnchorKeyPathsWithBlock:__p];
  [*(id *)(a1 + 136) persist];
  sub_1004F2598();
  if (sub_1004F7500() || (sub_1004F2598(), sub_1001B9A1C()))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v31 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      LOWORD(__p[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_INFO,  "#authsync initializing sync store",  (uint8_t *)__p,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      LOWORD(v17_Block_object_dispose(va, 8) = 0;
      LODWORD(v15_Block_object_dispose(va, 8) = 2;
      std::string v150 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#authsync initializing sync store",  &v178,  v158);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLClientManager::CLClientManager(id<CLIntersiloUniverse>)",  "%s\n",  (const char *)v150);
      if (v150 != __p) {
        free(v150);
      }
    }

    *(void *)(a1 + 1472) =  objc_msgSend( objc_msgSend(*v159, "vendor"),  "proxyForService:",  @"CLAuthSyncManager");
    *(void *)(a1 + 1464) =  objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "proxyForService:",  @"CLUsageSyncManager");
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  __int16 v32 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
  {
    sub_1004F2598();
    int v33 = sub_1001B9A1C();
    sub_1004F2598();
    BOOL v34 = sub_1004F7500();
    LODWORD(__p[0].__r_.__value_.__l.__data_) = 67240448;
    HIDWORD(__p[0].__r_.__value_.__r.__words[0]) = v33;
    LOWORD(__p[0].__r_.__value_.__r.__words[1]) = 1026;
    *(_DWORD *)((char *)&__p[0].__r_.__value_.__r.__words[1] + 2) = v34;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "#authsync isWatch: %{public}d, isCompanion: %{public}d",  (uint8_t *)__p,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v146 = qword_101934988;
    sub_1004F2598();
    int v147 = sub_1001B9A1C();
    sub_1004F2598();
    BOOL v148 = sub_1004F7500();
    LODWORD(v17_Block_object_dispose(va, 8) = 67240448;
    DWORD1(v17_Block_object_dispose(va, 8) = v147;
    WORD4(v17_Block_object_dispose(va, 8) = 1026;
    *(_DWORD *)((char *)&v178 + 10) = v148;
    LODWORD(v15_Block_object_dispose(va, 8) = 14;
    __int16 v149 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v146,  1LL,  "#authsync isWatch: %{public}d, isCompanion: %{public}d",  &v178,  v158);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLClientManager::CLClientManager(id<CLIntersiloUniverse>)",  "%s\n",  (const char *)v149);
    if (v149 != __p) {
      free(v149);
    }
  }

  sub_100EE2800((uint64_t)sub_100578988, a1, *(void **)(a1 + 32), __p);
  std::string::size_type v35 = __p[0].__r_.__value_.__r.__words[0];
  __p[0].__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v36 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = v35;
  if (v36)
  {
    (*(void (**)(uint64_t))(*(void *)v36 + 8LL))(v36);
    std::string::size_type v37 = __p[0].__r_.__value_.__r.__words[0];
    __p[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v37) {
      (*(void (**)(std::string::size_type))(*(void *)v37 + 8LL))(v37);
    }
  }

  [*(id *)(*(void *)(a1 + 152) + 16) register:*(void *)(*(void *)(a1 + 152) + 8) forNotification:0 registrationInfo:0];
  sub_1003CC884((uint64_t)sub_100578B58, a1, *(void **)(a1 + 32), __p);
  std::string::size_type v38 = __p[0].__r_.__value_.__r.__words[0];
  __p[0].__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v39 = *(void *)(a1 + 160);
  *(void *)(a1 + 160) = v38;
  if (v39)
  {
    (*(void (**)(uint64_t))(*(void *)v39 + 8LL))(v39);
    std::string::size_type v40 = __p[0].__r_.__value_.__r.__words[0];
    __p[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v40) {
      (*(void (**)(std::string::size_type))(*(void *)v40 + 8LL))(v40);
    }
  }

  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver( DarwinNotifyCenter,  (const void *)a1,  (CFNotificationCallback)sub_100578D0C,  @"com.apple.locationd/Restrictions",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  sub_1004F2598();
  char v42 = sub_1001B9A1C();
  if (&kSBSLockStateNotifyKey) {
    char v43 = v42;
  }
  else {
    char v43 = 1;
  }
  if ((v43 & 1) == 0)
  {
    int v44 = (const char *)kSBSLockStateNotifyKey;
    id v45 = (dispatch_queue_s *)[*(id *)(a1 + 40) queue];
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100578F2C;
    handler[3] = &unk_101832780;
    handler[4] = a1;
    uint32_t v46 = notify_register_dispatch(v44, (int *)(a1 + 1000), v45, handler);
    if (v46)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v47 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        LODWORD(__p[0].__r_.__value_.__l.__data_) = 67240192;
        HIDWORD(__p[0].__r_.__value_.__r.__words[0]) = v46;
        _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_FAULT,  "Could not register for lock state darwin notification error %{public}d",  (uint8_t *)__p,  8u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(__p, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        LODWORD(v17_Block_object_dispose(va, 8) = 67240192;
        DWORD1(v17_Block_object_dispose(va, 8) = v46;
        LODWORD(v15_Block_object_dispose(va, 8) = 8;
        __int16 v156 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Could not register for lock state darwin notification error %{public}d",  &v178,  v158);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLClientManager::CLClientManager(id<CLIntersiloUniverse>)",  "%s\n",  (const char *)v156);
        if (v156 != __p) {
          free(v156);
        }
      }
    }

    id v48 = (dispatch_queue_s *)[*(id *)(a1 + 40) queue];
    v171[0] = _NSConcreteStackBlock;
    v171[1] = 3221225472LL;
    v171[2] = sub_1005795DC;
    v171[3] = &unk_101832780;
    v171[4] = a1;
    uint32_t v49 = notify_register_dispatch("com.apple.springboard.homescreenunlocked", (int *)(a1 + 1004), v48, v171);
    if (v49)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v50 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        LODWORD(__p[0].__r_.__value_.__l.__data_) = 67240192;
        HIDWORD(__p[0].__r_.__value_.__r.__words[0]) = v49;
        _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_FAULT,  "Could not register for homescreen unlocked darwin notification error %{public}d",  (uint8_t *)__p,  8u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(__p, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        LODWORD(v17_Block_object_dispose(va, 8) = 67240192;
        DWORD1(v17_Block_object_dispose(va, 8) = v49;
        LODWORD(v15_Block_object_dispose(va, 8) = 8;
        int v157 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Could not register for homescreen unlocked darwin notification error %{public}d",  &v178,  v158);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLClientManager::CLClientManager(id<CLIntersiloUniverse>)",  "%s\n",  (const char *)v157);
        if (v157 != __p) {
          free(v157);
        }
      }
    }
  }

  uint64_t v51 = _os_feature_enabled_impl("CoreLocation", "CLSwissLocationAttribution");
  if ((_DWORD)v51 && !*(_BYTE *)(a1 + 504))
  {
    sub_100563030(v51, *(void **)(a1 + 480), a1 + 440);
    *(_BYTE *)(a1 + 504) = 1;
  }

  sub_100D96A2C((uint64_t)sub_100579630, a1, *(void **)(a1 + 32), __p);
  std::string::size_type v52 = __p[0].__r_.__value_.__r.__words[0];
  __p[0].__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v53 = *(void *)(a1 + 184);
  *(void *)(a1 + 184) = v52;
  if (v53)
  {
    (*(void (**)(uint64_t))(*(void *)v53 + 8LL))(v53);
    std::string::size_type v54 = __p[0].__r_.__value_.__r.__words[0];
    __p[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v54) {
      (*(void (**)(std::string::size_type))(*(void *)v54 + 8LL))(v54);
    }
  }

  [*(id *)(*(void *)(a1 + 184) + 16) register:*(void *)(*(void *)(a1 + 184) + 8) forNotification:2 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 184) + 16) register:*(void *)(*(void *)(a1 + 184) + 8) forNotification:4 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 184) + 16) register:*(void *)(*(void *)(a1 + 184) + 8) forNotification:6 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 184) + 16) register:*(void *)(*(void *)(a1 + 184) + 8) forNotification:3 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 184) + 16) register:*(void *)(*(void *)(a1 + 184) + 8) forNotification:10 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 184) + 16) register:*(void *)(*(void *)(a1 + 184) + 8) forNotification:11 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 184) + 16) register:*(void *)(*(void *)(a1 + 184) + 8) forNotification:1 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 184) + 16) register:*(void *)(*(void *)(a1 + 184) + 8) forNotification:12 registrationInfo:0];
  sub_100ACD980((uint64_t)sub_100579818, a1, *(void **)(a1 + 32), __p);
  std::string::size_type v55 = __p[0].__r_.__value_.__r.__words[0];
  __p[0].__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v56 = *(void *)(a1 + 1496);
  *(void *)(a1 + 1496) = v55;
  if (v56)
  {
    (*(void (**)(uint64_t))(*(void *)v56 + 8LL))(v56);
    std::string::size_type v57 = __p[0].__r_.__value_.__r.__words[0];
    __p[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v57) {
      (*(void (**)(std::string::size_type))(*(void *)v57 + 8LL))(v57);
    }
  }

  [*(id *)(*(void *)(a1 + 1496) + 16) register:*(void *)(*(void *)(a1 + 1496) + 8) forNotification:1 registrationInfo:0];
  BOOL v170 = 0;
  sub_1002F0B04(__p);
  char v58 = sub_1002A6F64((uint64_t)__p[0].__r_.__value_.__l.__data_, "DisableAppInstallationChecks", &v170);
  if (v170) {
    char v59 = v58;
  }
  else {
    char v59 = 0;
  }
  std::string::size_type size = (std::__shared_weak_count *)__p[0].__r_.__value_.__l.__size_;
  if (__p[0].__r_.__value_.__l.__size_)
  {
    char v61 = (unint64_t *)(__p[0].__r_.__value_.__l.__size_ + 8);
    do
      unint64_t v62 = __ldaxr(v61);
    while (__stlxr(v62 - 1, v61));
    if (!v62)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
      if ((v59 & 1) != 0) {
        goto LABEL_82;
      }
      goto LABEL_81;
    }
  }

  if ((v59 & 1) == 0)
  {
LABEL_81:
    id v63 = [*(id *)(a1 + 40) newTimer];
    *(void *)(a1 + 24_Block_object_dispose(va, 8) = v63;
    v169[0] = _NSConcreteStackBlock;
    v169[1] = 3221225472LL;
    v169[2] = sub_1005799F0;
    v169[3] = &unk_10181D3D0;
    v169[4] = a1;
    [v63 setHandler:v169];
    [*(id *)(a1 + 248) setNextFireDelay:60.0 interval:1.79769313e308];
  }

void sub_100577C58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12, char **a13, void **a14, void **a15, char **a16, void **a17, void **a18, char **a19, char **a20, char **a21, char **a22, char **a23, uint64_t a24, void **a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35)
{
  uint64_t v39 = *(void *)(v35 + 1496);
  *(void *)(v35 + 1496) = 0LL;
  if (v39) {
    (*(void (**)(uint64_t))(*(void *)v39 + 8LL))(v39);
  }
  sub_10004AD90(v35 + 1424);
  sub_10004AD90(v35 + 1264);
  sub_1000229D4(v35 + 1048, *a13);
  STACK[0x280] = a32;
  sub_100589EC0((void ***)&STACK[0x280]);
  sub_10000AE14(a30);
  sub_100589E88(v35 + 912);
  sub_100008390(v35 + 848, *a14);
  sub_100008390(v35 + 824, *a15);
  sub_1000229D4(v35 + 800, *a16);
  sub_100008390(v35 + 776, *a17);
  sub_100008390(v35 + 752, *a18);
  sub_1000229D4(a35, *a19);
  sub_1000229D4(v35 + 688, *a20);
  sub_1000229D4(v35 + 664, *a21);
  sub_1000229D4(v35 + 640, *a22);
  sub_1000229D4(v35 + 616, *a23);
  sub_10004AD90(a24);
  sub_100589E40(a26, *a25);
  sub_10004AD90(a28);
  sub_10000AE14(a27);
  sub_10057D1B4((uint64_t *)(v36 + 136), 0LL);
  std::string::size_type v40 = *v37;
  *std::string::size_type v37 = 0LL;
  if (v40) {
    sub_10058A4FC((int)v37, v40);
  }
  uint64_t v41 = *(void *)(v35 + 216);
  *(void *)(v35 + 216) = 0LL;
  if (v41) {
    (*(void (**)(uint64_t))(*(void *)v41 + 8LL))(v41);
  }
  uint64_t v42 = *(void *)(v35 + 208);
  *(void *)(v35 + 20_Block_object_dispose(va, 8) = 0LL;
  if (v42) {
    (*(void (**)(uint64_t))(*(void *)v42 + 8LL))(v42);
  }
  uint64_t v43 = *(void *)(v35 + 200);
  *(void *)(v35 + 200) = 0LL;
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8LL))(v43);
  }
  uint64_t v44 = *(void *)(v35 + 192);
  *(void *)(v35 + 192) = 0LL;
  if (v44) {
    (*(void (**)(uint64_t))(*(void *)v44 + 8LL))(v44);
  }
  uint64_t v45 = *(void *)(v35 + 184);
  *(void *)(v35 + 184) = 0LL;
  if (v45) {
    (*(void (**)(uint64_t))(*(void *)v45 + 8LL))(v45);
  }
  uint64_t v46 = *(void *)(v35 + 176);
  *(void *)(v35 + 176) = 0LL;
  if (v46) {
    (*(void (**)(uint64_t))(*(void *)v46 + 8LL))(v46);
  }
  uint64_t v47 = *(void *)(v35 + 168);
  *(void *)(v35 + 16_Block_object_dispose(va, 8) = 0LL;
  if (v47) {
    (*(void (**)(uint64_t))(*(void *)v47 + 8LL))(v47);
  }
  uint64_t v48 = *(void *)(v35 + 160);
  *(void *)(v35 + 160) = 0LL;
  if (v48) {
    (*(void (**)(uint64_t))(*(void *)v48 + 8LL))(v48);
  }
  uint64_t v49 = *(void *)(v35 + 152);
  *(void *)(v35 + 152) = 0LL;
  if (v49) {
    (*(void (**)(uint64_t))(*(void *)v49 + 8LL))(v49);
  }
  sub_10057AA04(v35);
  _Unwind_Resume(a1);
}

uint64_t sub_1005780FC(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_101840438;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = [a3 silo];
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 10_Block_object_dispose(va, 8) = 0;
  return a1;
}

void sub_10057817C(_Unwind_Exception *exception_object)
{
}

void sub_100578198(id a1, CLClientManagerStateTracker *a2)
{
}

id sub_1005781C0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id result = [*(id *)(v1 + 128) BOOLForKey:@"CLCM.AllowPromptRecording" defaultValue:*(unsigned __int8 *)(v1 + 232)];
  *(_BYTE *)(v1 + 232) = (_BYTE)result;
  return result;
}

void sub_1005781F4(uint64_t a1)
{
}

void sub_1005781FC(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  double v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "ResetTimer fired", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    LOWORD(v27) = 0;
    id v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "ResetTimer fired",  &v27,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::onResetTimer()", "%s\n", v18);
  }

  id v3 = [*(id *)(a1 + 128) arrayForKey:@"ResetIdentifiers" defaultValue:0];
  BOOL v4 = v3;
  if (*(_BYTE *)(a1 + 1040))
  {
    *(_BYTE *)(a1 + 1040) = 0;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 138412290;
      char v30 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "Reset registration and completion reporting is un-balanced. Completion not reported for clients: %@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v27 = 138412290;
      double v28 = v4;
      LODWORD(v21) = 12;
      char v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Reset registration and completion reporting is un-balanced. Completion not reported for clients: %@",  &v27,  v21);
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLClientManager::onResetTimer()", "%s\n", v19);
    }

    [*(id *)(a1 + 128) setArray:0 forKey:@"ResetIdentifiers"];
LABEL_13:
    [*(id *)(a1 + 128) setInt:0 forKey:@"ResetRetrialCount"];
    return;
  }

  if (![v3 count])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v16 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "Reset registration and completion reporting is balanced for all clients.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      LOWORD(v27) = 0;
      LODWORD(v21) = 2;
      uint64_t v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "Reset registration and completion reporting is balanced for all clients.",  &v27,  v21);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::onResetTimer()", "%s\n", v17);
    }

    goto LABEL_13;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "#reset-retry completing pending reset.", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    LOWORD(v27) = 0;
    LODWORD(v21) = 2;
    uint64_t v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#reset-retry completing pending reset.",  &v27,  v21);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::onResetTimer()", "%s\n", v20);
  }

  id v7 = sub_10057C2AC(a1);
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  id v8 = [v4 countByEnumeratingWithState:&v22 objects:v26 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v23;
    do
    {
      uint64_t v11 = 0LL;
      do
      {
        if (*(void *)v23 != v10) {
          objc_enumerationMutation(v4);
        }
        uint64_t v12 = *(void **)(*((void *)&v22 + 1) + 8LL * (void)v11);
        if (([v7 containsObject:v12] & 1) == 0)
        {
          if (qword_101934970 != -1) {
            dispatch_once(&qword_101934970, &stru_101840220);
          }
          id v13 = (os_log_s *)qword_101934978;
          if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t buf = 138412290;
            char v30 = v12;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "#reset-retry - service with identifier: %@ never checked in to retry handling reset after crash",  buf,  0xCu);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934970 != -1) {
              dispatch_once(&qword_101934970, &stru_101840220);
            }
            int v27 = 138412290;
            double v28 = v12;
            LODWORD(v21) = 12;
            id v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  16LL,  "#reset-retry - service with identifier: %@ never checked in to retry handling reset after crash",  &v27,  v21);
            sub_10029211C("Generic", 1LL, 0, 0LL, "void CLClientManager::onResetTimer()", "%s\n", v14);
          }
        }

        uint64_t v11 = (char *)v11 + 1;
      }

      while (v9 != v11);
      id v15 = [v4 countByEnumeratingWithState:&v22 objects:v26 count:16];
      id v9 = v15;
    }

    while (v15);
  }

  sub_10056A6A0(a1);
}

void sub_100578988(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101840260);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v10 = 1;
    id v7 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLClientManager::onDarwinNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    id v8 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v12 = 0;
      __int16 v13 = 2082;
      id v14 = "";
      __int16 v15 = 2082;
      int v16 = "activity";
      __int16 v17 = 2050;
      uint64_t v18 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLClientManager::onDarwinNotification, event:%{public, location:escape_only}s, th is:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v10 = 0;
  }

  sub_10057EF54(a4, v6, a2);
  if (v10) {
    os_activity_scope_leave(&state);
  }
}

void sub_100578B38( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100578B58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101840260);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v8 = 1;
    id v5 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLClientManager::onStatusNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v5, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    uint64_t v6 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v10 = 0;
      __int16 v11 = 2082;
      int v12 = "";
      __int16 v13 = 2082;
      id v14 = "activity";
      __int16 v15 = 2050;
      uint64_t v16 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLClientManager::onStatusNotification, event:%{public, location:escape_only}s, th is:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v8 = 0;
  }

  if (v8) {
    os_activity_scope_leave(&state);
  }
}

void sub_100578CF0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100578D0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101840260);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v15 = 1;
    int v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLClientManager::onRestrictionsChangedNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    __int16 v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v17 = 0;
      __int16 v18 = 2082;
      char v19 = "";
      __int16 v20 = 2082;
      uint64_t v21 = "activity";
      __int16 v22 = 2050;
      uint64_t v23 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLClientManager::onRestrictionsChangedNotification, event:%{public, location:escape _only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v15 = 0;
  }

  id v12 = [*(id *)(a2 + 32) silo];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _OWORD v13[2] = sub_100585B30;
  void v13[3] = &unk_10182D1B8;
  _DWORD v13[4] = a2;
  v13[5] = a1;
  void v13[6] = a3;
  void v13[7] = a4;
  v13[8] = a5;
  [v12 sync:v13];
  if (v15) {
    os_activity_scope_leave(&state);
  }
}

void sub_100578F0C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state, char a19)
{
  if (a19) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100578F2C(uint64_t a1, int token)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t state64 = 0LL;
  notify_get_state(token, &state64);
  if (state64)
  {
    *(_BYTE *)(v2 + 997) = 1;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v3 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "#AuthPrompt screen locked", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int16 v10 = 0;
      uint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#AuthPrompt screen locked",  &v10,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLClientManager::CLClientManager(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v6);
    }

    sub_100579358(v2, 0, 0LL);
  }

  else
  {
    *(_BYTE *)(v2 + 995) = 1;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v4 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "Trial period #reprompt capacitor charged",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int16 v10 = 0;
      id v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "Trial period #reprompt capacitor charged",  &v10,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLClientManager::CLClientManager(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v7);
    }

    *(_BYTE *)(v2 + 997) = 0;
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "#AuthPrompt screen unlocked", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int16 v10 = 0;
      LODWORD(v9) = 2;
      char v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#AuthPrompt screen unlocked",  &v10,  v9);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLClientManager::CLClientManager(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v8);
    }
  }

void sub_100579358(uint64_t a1, int a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 272);
  if (v3)
  {
    id v7 = (uint64_t *)(a1 + 272);
    if (a3 && ([a3 isEqual:*(void *)(v3 + 8)] & 1) == 0)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v16 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = *(void *)(*v7 + 8);
        *(_DWORD *)uint64_t buf = 68289538;
        int v20 = 0;
        __int16 v21 = 2082;
        __int16 v22 = "";
        __int16 v23 = 2114;
        uint64_t v24 = v17;
        __int16 v25 = 2114;
        uint64_t v26 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt skip Teardown Inflight Prompt - actual and expected inflight client does no t match, ActualInflightClient:%{public, location:escape_only}@, ExpectedInflightClient:%{public, loc ation:escape_only}@}",  buf,  0x26u);
      }
    }

    else
    {
      char v8 = @"TearDown SPI Invocation";
      if (a2 == 1) {
        char v8 = @"Squatting threshold(15 min) expired";
      }
      if (a2) {
        uint64_t v9 = (__CFString *)v8;
      }
      else {
        uint64_t v9 = @"ScreenLock enabled";
      }
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      __int16 v10 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(*v7 + 8);
        id v12 = (void *)*(unsigned int *)*v7;
        *(_DWORD *)uint64_t buf = 68289794;
        int v20 = 0;
        __int16 v21 = 2082;
        __int16 v22 = "";
        __int16 v23 = 2114;
        uint64_t v24 = v11;
        __int16 v25 = 2050;
        uint64_t v26 = v12;
        __int16 v27 = 2082;
        id v28 = -[__CFString UTF8String](v9, "UTF8String");
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt Teardown Inflight Prompt, Client:%{public, location:escape_only}@,  PromptType:%{public, location:CLClientManager_Type::AuthorizationRequestType}lld, Teardown Reason:%{publ ic, location:escape_only}s}",  buf,  0x30u);
      }

      __int16 v13 = (unsigned int *)*v7;
      uint64_t v14 = *(void *)(*v7 + 48);
      if (v14)
      {
        char v15 = (__CFRunLoop *)sub_10029228C();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_10057D1AC;
        block[3] = &unk_10181D3D0;
        block[4] = v14;
        CFRunLoopPerformBlock(v15, kCFRunLoopCommonModes, block);
        __int16 v13 = (unsigned int *)*v7;
      }

      sub_10055E8F4(v13, (uint64_t)v9);
      sub_10057D1B4(v7, 0LL);
      *(_DWORD *)(a1 + 312) = 0;
    }
  }

uint64_t sub_1005795DC(uint64_t a1, int token)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t state64 = 0LL;
  uint64_t result = notify_get_state(token, &state64);
  uint64_t v4 = state64;
  *(_BYTE *)(v2 + 996) = state64 != 0;
  if (v4 == 1) {
    *(_BYTE *)(v2 + 995) = 0;
  }
  return result;
}

void sub_100579630(unsigned int a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101840260);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    char v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLClientManager::onAppMonitorNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      char v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLClientManager::onAppMonitorNotification, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10057F164(a4, a1, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005797F8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100579818(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101840260);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    char v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLClientManager::onDataProtectionManagerNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      char v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLClientManager::onDataProtectionManagerNotification, event:%{public, location:esca pe_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100565540(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005799D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005799F0(uint64_t a1)
{
  return sub_10055570C(*(void *)(a1 + 32));
}

uint64_t *sub_1005799F8(uint64_t *a1, std::string *a2)
{
  if (!v20) {
    return a1;
  }
  if ((char)a2->__r_.__value_.__s.__size_ < 0)
  {
    *a2->__r_.__value_.__l.__data_ = 0;
    a2->__r_.__value_.__l.__size_ = 0LL;
  }

  else
  {
    a2->__r_.__value_.__s.__data_[0] = 0;
    a2->__r_.__value_.__s.__size_ = 0;
  }

  uint64_t v4 = *(void *)(*a1 - 24);
  uint64_t v5 = *(uint64_t *)((char *)a1 + v4 + 24);
  if (v5 <= 1) {
    uint64_t v6 = 1LL;
  }
  else {
    uint64_t v6 = *(uint64_t *)((char *)a1 + v4 + 24);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + v4));
  uint64_t v7 = std::locale::use_facet(&v19, &std::ctype<char>::id);
  std::locale::~locale(&v19);
  uint64_t v8 = 0LL;
  uint64_t v9 = a1 + 5;
  if (v5 >= 1) {
    uint64_t v10 = v6;
  }
  else {
    uint64_t v10 = 0x7FFFFFFFFFFFFFF7LL;
  }
  while (1)
  {
    char v11 = *(void **)((char *)v9 + *(void *)(*a1 - 24));
    id v12 = (_BYTE *)v11[3];
    if (v12 == (_BYTE *)v11[4]) {
      break;
    }
    LOBYTE(v13) = *v12;
LABEL_14:
    if ((v13 & 0x80) == 0 && (*((_DWORD *)&v7[1].~facet + v13) & 0x4000) != 0)
    {
      int v16 = 0;
      goto LABEL_23;
    }

    std::string::push_back(a2, v13);
    __int16 v14 = *(void **)((char *)v9 + *(void *)(*a1 - 24));
    uint64_t v15 = v14[3];
    if (v15 == v14[4]) {
      (*(void (**)(void *))(*v14 + 80LL))(v14);
    }
    else {
      v14[3] = v15 + 1;
    }
    if (v10 == ++v8)
    {
      int v16 = 0;
      uint64_t v17 = *a1;
      *(uint64_t *)((char *)a1 + *(void *)(*a1 - 24) + 24) = 0LL;
      goto LABEL_25;
    }
  }

  int v13 = (*(uint64_t (**)(void *))(*v11 + 72LL))(v11);
  if (v13 != -1) {
    goto LABEL_14;
  }
  int v16 = 2;
LABEL_23:
  uint64_t v17 = *a1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 24) + 24) = 0LL;
  if (!v8) {
    v16 |= 4u;
  }
LABEL_25:
  std::ios_base::clear( (std::ios_base *)((char *)a1 + *(void *)(v17 - 24)),  *(_DWORD *)((char *)a1 + *(void *)(v17 - 24) + 32) | v16);
  return a1;
}

void sub_100579BAC( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
  uint64_t v11 = *v9;
  *(_DWORD *)((char *)v9 + *(void *)(*v9 - 24LL) + 32) |= 1u;
  if ((*((_BYTE *)v9 + *(void *)(v11 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x100579B78LL);
  }

  __cxa_rethrow();
}

void sub_100579C10(_Unwind_Exception *a1)
{
}

void sub_100579C24(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(const char **)(v1 + 264);
    if (v3)
    {
      if (v3[23] < 0) {
        uint64_t v3 = *(const char **)v3;
      }
    }

    else
    {
      uint64_t v3 = "nobody";
    }

    v5[0] = 68289282;
    v5[1] = 0;
    __int16 v6 = 2082;
    uint64_t v7 = "";
    __int16 v8 = 2082;
    uint64_t v9 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Ending #provisional intermediation reign guarantee due to staleness, king:%{public, l ocation:escape_only}s}",  (uint8_t *)v5,  0x1Cu);
  }

  uint64_t v4 = *(void *)(v1 + 288);
  if (v4)
  {
    (*(void (**)(uint64_t, void))(v4 + 16))(v4, 0LL);

    *(void *)(v1 + 28_Block_object_dispose(va, 8) = 0LL;
  }

void sub_100579D44(uint64_t a1)
{
  if (*(void *)(a1 + 336))
  {
    __int16 v6 = (_Unwind_Exception *)sub_10123E51C();
    _Block_object_dispose(&v9, 8);
    uint64_t v17 = v1;
    sub_10058A20C(&v17);
    _Unwind_Resume(v6);
  }

  uint64_t v3 = *(void **)(a1 + 136);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = sub_10057AA78;
  float v16[3] = &unk_10183F8B0;
  _OWORD v16[4] = a1;
  [v3 iterateAllAnchorKeyPathsWithBlock:v16];
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x4812000000LL;
  id v12 = sub_10057AA94;
  int v13 = sub_10057AAB8;
  __int16 v14 = &unk_10175E27B;
  memset(v15, 0, sizeof(v15));
  uint64_t v4 = *(void **)(a1 + 136);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  _DWORD v8[2] = sub_10057AAE0;
  v8[3] = &unk_10183F9F8;
  void v8[4] = &v9;
  void v8[5] = a1;
  [v4 iterateAllAnchorKeyPathsWithBlock:v8];
  if (v10[6] != v10[7])
  {
    id v5 = [*(id *)(a1 + 40) newTimer];
    *(void *)(a1 + 336) = v5;
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    _DWORD v7[2] = sub_10057ADB4;
    v7[3] = &unk_101840030;
    v7[4] = &v9;
    void v7[5] = a1;
    [v5 setHandler:v7];
    [*(id *)(a1 + 336) setNextFireDelay:10.0];
  }

  _Block_object_dispose(&v9, 8);
  uint64_t v17 = (void **)v15;
  sub_10058A20C(&v17);
}

void sub_100579EB8(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Registering coreanalytics activity", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    v6[0] = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "Registering coreanalytics activity",  v6,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::registerAnalyticsCollectActivity()", "%s\n", v4);
  }

  id v3 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "proxyForService:", @"CLClientManager");
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_1005817E0;
  handler[3] = &unk_101831AF8;
  handler[4] = v3;
  xpc_activity_register("com.apple.locationd.CLClientManager.coreanalytics", XPC_ACTIVITY_CHECK_IN, handler);
}

_BYTE *sub_10057A0A8(uint64_t a1)
{
  return sub_10057A0B0(*(void *)(a1 + 32));
}

_BYTE *sub_10057A0B0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 136);
  __int16 v6 = _NSConcreteStackBlock;
  uint64_t v7 = 3221225472LL;
  __int16 v8 = sub_10057DCFC;
  uint64_t v9 = &unk_101840050;
  uint64_t v10 = a1;
  LOBYTE(v11) = 1;
  [v2 iterateAllAnchorKeyPathsWithBlock:&v6];
  id v3 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "proxyForService:", @"CLBTLEFenceManager");
  uint64_t v4 = *(void **)(a1 + 136);
  __int16 v6 = _NSConcreteStackBlock;
  uint64_t v7 = 3221225472LL;
  __int16 v8 = sub_1005473CC;
  uint64_t v9 = &unk_10183F9D0;
  uint64_t v10 = (uint64_t)v3;
  uint64_t v11 = a1;
  [v4 iterateAllAnchorKeyPathsWithBlock:&v6];
  sub_100547A3C(a1);
  sub_10057AE28(a1, 0);
  return sub_1005569D8((_BYTE *)a1);
}

void sub_10057A180(uint64_t a1, CLConnection **a2, CLConnectionMessage **a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = *a2;
  *a2 = 0LL;
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _OWORD v13[2] = sub_10057A26C;
  void v13[3] = &unk_101830538;
  _DWORD v13[4] = v4;
  v13[5] = v5;
  CLConnection::setDisconnectionHandler(v5, v13);
  __int16 v6 = *a3;
  uint64_t v7 = a3[1];
  v12[0] = v6;
  v12[1] = v7;
  if (v7)
  {
    __int16 v8 = (unint64_t *)((char *)v7 + 8);
    do
      unint64_t v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }

  sub_10053EF50(v4, v5, v12);
  if (v7)
  {
    uint64_t v10 = (unint64_t *)((char *)v7 + 8);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      (*(void (**)(CLConnectionMessage *))(*(void *)v7 + 16LL))(v7);
      std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v7);
    }
  }

void sub_10057A258( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10057A26C(uint64_t a1)
{
}

void sub_10057A278(uint64_t a1, _DWORD *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101840260);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    __int16 v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLClientManager::onDaemonStatusNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    unint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLClientManager::onDaemonStatusNotification, event:%{public, location:escape_only}s , this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100580B14(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10057A430( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10057A450(uint64_t a1, _DWORD *a2, unsigned __int8 *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101840260);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    __int16 v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLClientManager::onWifiServiceNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    unint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLClientManager::onWifiServiceNotification, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100580B6C(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10057A608( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10057A628(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101840260);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    __int16 v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLClientManager::onBluetoothServiceNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    unint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLClientManager::onBluetoothServiceNotification, event:%{public, location:escape_on ly}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_1005812E0(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10057A7E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10057A800(uint64_t a1, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101840260);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    __int16 v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLClientManager::onStatusBarNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    unint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLClientManager::onStatusBarNotification, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100580D28(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10057A9B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_10057A9D8(id a1)
{
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterPostNotification(DarwinNotifyCenter, CLAuthorizationStatusChangedNotification, 0LL, 0LL, 0);
}

uint64_t sub_10057AA04(uint64_t a1)
{
  *(void *)a1 = off_101840438;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100589F4C(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

id sub_10057AA78(uint64_t a1, uint64_t a2)
{
  return [*(id *)(*(void *)(a1 + 32) + 136) removeValueForKey:@"InUseLevel" atKeyPath:a2];
}

__n128 sub_10057AA94(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void sub_10057AAB8(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  sub_10058A20C(&v1);
}

void sub_10057AAE0(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  [*(id *)(v4 + 136) doubleForKey:@"BackgroundLocationTimeStarted" atKeyPath:a2 defaultValue:0.0];
  double v6 = v5;
  [*(id *)(v4 + 136) doubleForKey:@"BackgroundLocationTimeStopped" atKeyPath:a2 defaultValue:0.0];
  if (v6 <= v7)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    char v11 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      uint64_t buf = 68289282LL;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      __int16 v20 = 2114;
      __int16 v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:No BackgroundLocation found. No crash-grace CLInUseAssertion, clientKeyPath:%{publi c, location:escape_only}@}",  (uint8_t *)&buf,  0x1Cu);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    __int16 v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t buf = 68289282LL;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      __int16 v20 = 2114;
      __int16 v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Ongoing background location, taking temporary crash-grace DUE CLInUseAssertion, clien tKeyPath:%{public, location:escape_only}@}",  (uint8_t *)&buf,  0x1Cu);
    }

    unint64_t v9 = *(uint64_t **)(*(void *)(a1 + 32) + 8LL);
    uint64_t v10 = *(void **)(v4 + 376);
    if (a2)
    {
      [a2 cppClientKey];
    }

    else
    {
      v15[0] = 0LL;
      v15[1] = 0LL;
      uint64_t v16 = 0LL;
    }

    sub_1010DDBC0(&__p, "crash-grace-DUE");
    sub_1008FDE6C(&__p, v10, (uint64_t)v15, 5, &buf);
    unint64_t v12 = v9[7];
    if (v12 >= v9[8])
    {
      uint64_t v13 = sub_10058A27C(v9 + 6, (__int128 *)&buf);
    }

    else
    {
      sub_1008FDB14((_OWORD *)v9[7], (__int128 *)&buf);
      uint64_t v13 = v12 + 80;
      v9[7] = v12 + 80;
    }

    v9[7] = v13;
    sub_1008FDB5C(&buf);
    if (SHIBYTE(v16) < 0) {
      operator delete(v15[0]);
    }
  }

void sub_10057AD5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(a1);
}

void sub_10057ADB4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v4 = *(void *)(v2 + 48);
  for (uint64_t i = *(void *)(v2 + 56); i != v4; uint64_t i = sub_1008FDB5C(i - 80))
    ;
  *(void *)(v2 + 56) = v4;
  [*(id *)(v1 + 336) invalidate];

  *(void *)(v1 + 336) = 0LL;
}

id sub_10057AE0C(uint64_t a1, uint64_t a2)
{
  return [*(id *)(*(void *)(a1 + 32) + 136) removeValueForKey:@"Hidden" atKeyPath:a2];
}

void sub_10057AE28(uint64_t a1, int a2)
{
  unsigned int v4 = [*(id *)(a1 + 120) locationRestricted];
  uint64_t v5 = sub_100231608();
  int v6 = v5;
  BOOL v7 = sub_10057D9A0(v5, a2);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  __int16 v8 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 67109632;
    BOOL v27 = v6 != 0;
    __int16 v28 = 1024;
    BOOL v29 = v7;
    __int16 v30 = 1024;
    int v31 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Location services available %d; parental controls enabled %d (refresh %d)",
      buf,
      0x14u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    v21[0] = 67109632;
    v21[1] = v6 != 0;
    __int16 v22 = 1024;
    BOOL v23 = v7;
    __int16 v24 = 1024;
    int v25 = a2;
    uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "Location services available %d; parental controls enabled %d (refresh %d)",
                    v21,
                    20,
                    v19);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::checkRestrictions(BOOL)", "%s\n", v15);
  }

  if (v6) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = 1LL;
  }
  [*(id *)(a1 + 120) setLocationRestricted:v9];
  if ([*(id *)(a1 + 120) locationRestricted])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "#warning location is restricted; freezing client states",
        buf,
        2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      LOWORD(v21[0]) = 0;
      LODWORD(v1_Block_object_dispose(va, 8) = 2;
      char v11 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "#warning location is restricted; freezing client states",
                            v21,
                            v18);
LABEL_39:
      uint64_t v16 = (uint8_t *)v11;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::checkRestrictions(BOOL)", "%s\n", v11);
      if (v16 != buf) {
        free(v16);
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unint64_t v12 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "location is not restricted", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      LOWORD(v21[0]) = 0;
      LODWORD(v1_Block_object_dispose(va, 8) = 2;
      char v11 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "location is not restricted",  v21,  v18);
      goto LABEL_39;
    }
  }

  if (a2 && v4 != [*(id *)(a1 + 120) locationRestricted])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v13 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "Applying #restrictions change to all clients",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      LOWORD(v21[0]) = 0;
      LODWORD(v1_Block_object_dispose(va, 8) = 2;
      uint64_t v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "Applying #restrictions change to all clients",  v21,  v18);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::checkRestrictions(BOOL)", "%s\n", v17);
    }

    __int16 v14 = *(void **)(a1 + 136);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472LL;
    v20[2] = sub_10057DC88;
    void v20[3] = &unk_10183F8B0;
    v20[4] = a1;
    [v14 iterateAllAnchorKeyPathsWithBlock:v20];
  }

uint64_t sub_10057B3BC(uint64_t a1)
{
  uint64_t v1 = *(_BYTE **)(a1 + 32);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    v5[0] = 68289026;
    v5[1] = 0;
    __int16 v6 = 2082;
    BOOL v7 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Sending app status change notification}",  (uint8_t *)v5,  0x12u);
  }

  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterPostNotification(DarwinNotifyCenter, CLAppStatusChangedNotification, 0LL, 0LL, 0);
  v5[0] = 3;
  uint64_t result = (*(uint64_t (**)(_BYTE *, _DWORD *, void, uint64_t))(*(void *)v1 + 144LL))( v1,  v5,  0LL,  0xFFFFFFFFLL);
  v1[1072] = 0;
  return result;
}

uint64_t sub_10057B4DC(uint64_t a1)
{
  *(void *)a1 = off_10183FE88;
  *(void *)(a1 + 112) = &off_10183FF70;
  *(void *)(*(void *)(a1 + 952) + 8LL) = 0LL;
  sub_10067FEA8(*(void *)(a1 + 376));

  *(void *)(a1 + 1472) = 0LL;
  *(void *)(a1 + 1464) = 0LL;
  [*(id *)(a1 + 336) invalidate];

  *(void *)(a1 + 336) = 0LL;
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 608));

  *(void *)(a1 + 60_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 600) = 0LL;
  [*(id *)(a1 + 344) invalidate];

  *(void *)(a1 + 344) = 0LL;
  [*(id *)(a1 + 352) invalidate];

  *(void *)(a1 + 352) = 0LL;
  [*(id *)(a1 + 256) invalidate];

  *(void *)(a1 + 256) = 0LL;
  [*(id *)(a1 + 224) invalidate];

  *(void *)(a1 + 224) = 0LL;
  [*(id *)(a1 + 408) invalidate];

  *(void *)(a1 + 40_Block_object_dispose(va, 8) = 0LL;
  [*(id *)(a1 + 400) invalidate];

  *(void *)(a1 + 400) = 0LL;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  uint64_t v2 = *(void **)(a1 + 512);
  id v3 = [v2 countByEnumeratingWithState:&v53 objects:v59 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v54;
    do
    {
      for (uint64_t i = 0LL; i != v3; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v54 != v4) {
          objc_enumerationMutation(v2);
        }
        uint64_t v6 = *(void *)(*((void *)&v53 + 1) + 8LL * (void)i);
        objc_msgSend(objc_msgSend(*(id *)(a1 + 512), "objectForKeyedSubscript:", v6), "invalidate");

        [*(id *)(a1 + 512) setObject:0 forKeyedSubscript:v6];
      }

      id v3 = [v2 countByEnumeratingWithState:&v53 objects:v59 count:16];
    }

    while (v3);
  }

  BOOL v7 = *(void **)(a1 + 528);
  if (v7 != (void *)(a1 + 536))
  {
    do
    {
      sub_10058A4D0(v7 + 7, 0LL);
      __int16 v8 = (void *)v7[1];
      if (v8)
      {
        do
        {
          uint64_t v9 = v8;
          __int16 v8 = (void *)*v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          uint64_t v9 = (void *)v7[2];
          BOOL v10 = *v9 == (void)v7;
          BOOL v7 = v9;
        }

        while (!v10);
      }

      BOOL v7 = v9;
    }

    while (v9 != (void *)(a1 + 536));
  }

  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  char v11 = *(void **)(a1 + 392);
  id v12 = [v11 countByEnumeratingWithState:&v49 objects:v58 count:16];
  if (v12)
  {
    uint64_t v13 = *(void *)v50;
    do
    {
      for (j = 0LL; j != v12; j = (char *)j + 1)
      {
        if (*(void *)v50 != v13) {
          objc_enumerationMutation(v11);
        }
        dispatch_source_cancel(*(dispatch_source_t *)(*((void *)&v49 + 1) + 8LL * (void)j));
      }

      id v12 = [v11 countByEnumeratingWithState:&v49 objects:v58 count:16];
    }

    while (v12);
  }

  *(void *)(a1 + 392) = 0LL;
  *(void *)(a1 + 416) = 0LL;
  [*(id *)(a1 + 368) invalidate];

  *(void *)(a1 + 36_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 360) = 0LL;
  [*(id *)(a1 + 296) invalidate];

  *(void *)(a1 + 296) = 0LL;
  if (*(void *)(a1 + 248))
  {
    sub_10123E690( v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v45,  v46,  v47,  v48,  v49,  *((uint64_t *)&v49 + 1),  v50,  *((uint64_t *)&v50 + 1),  v51,  *((uint64_t *)&v51 + 1),  v52,  *((uint64_t *)&v52 + 1),  v53,  *((uint64_t *)&v53 + 1),  v54,  *((uint64_t *)&v54 + 1));
    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/CLClientManager.mm",  2425,  "~CLClientManager");
    __break(1u);
  }

  int v23 = *(_DWORD *)(a1 + 1000);
  if (v23) {
    notify_cancel(v23);
  }
  int v24 = *(_DWORD *)(a1 + 1004);
  if (v24) {
    notify_cancel(v24);
  }
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver( DarwinNotifyCenter,  (const void *)a1,  @"com.apple.locationd/Restrictions",  0LL);
  uint64_t v26 = *(void *)(a1 + 168);
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8LL))(v26);
  }
  uint64_t v27 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = 0LL;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 8LL))(v27);
  }
  uint64_t v28 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = 0LL;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
  }
  uint64_t v29 = *(void *)(a1 + 208);
  *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0LL;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
  }
  uint64_t v30 = *(void *)(a1 + 200);
  *(void *)(a1 + 200) = 0LL;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
  }
  uint64_t v31 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = 0LL;
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 8LL))(v31);
  }
  uint64_t v32 = *(void *)(a1 + 1496);
  *(void *)(a1 + 1496) = 0LL;
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 8LL))(v32);
  }

  *(void *)(a1 + 1080) = 0LL;
  *(void *)(a1 + 108_Block_object_dispose(va, 8) = 0LL;
  sub_100589F00(a1 + 968, *(void **)(a1 + 968));
  [*(id *)(a1 + 1480) stopMonitoringCapabilityChangeForClient:CLISP_ME_TOKEN];

  *(void *)(a1 + 1480) = 0LL;
  *(void *)(a1 + 148_Block_object_dispose(va, 8) = 0LL;

  *(void *)(a1 + 1032) = 0LL;
  *(void *)(a1 + 1024) = 0LL;

  *(void *)(a1 + 1016) = 0LL;
  *(void *)(a1 + 100_Block_object_dispose(va, 8) = 0LL;

  *(void *)(a1 + 1416) = 0LL;
  *(void *)(a1 + 120) = 0LL;

  *(void *)(a1 + 520) = 0LL;
  *(void *)(a1 + 480) = 0LL;

  *(void *)(a1 + 48_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 496) = 0LL;
  [*(id *)(a1 + 144) invalidate];

  *(void *)(a1 + 144) = 0LL;
  [*(id *)(a1 + 136) persist];

  *(void *)(a1 + 136) = 0LL;
  uint64_t v33 = *(void *)(a1 + 1496);
  *(void *)(a1 + 1496) = 0LL;
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 8LL))(v33);
  }
  sub_10004AD90(a1 + 1424);
  sub_10004AD90(a1 + 1264);
  sub_1000229D4(a1 + 1048, *(char **)(a1 + 1056));
  std::string::size_type v57 = (void **)(a1 + 968);
  sub_100589EC0(&v57);
  sub_10000AE14(a1 + 952);
  sub_100589E88(a1 + 912);
  sub_100008390(a1 + 848, *(void **)(a1 + 856));
  sub_100008390(a1 + 824, *(void **)(a1 + 832));
  sub_1000229D4(a1 + 800, *(char **)(a1 + 808));
  sub_100008390(a1 + 776, *(void **)(a1 + 784));
  sub_100008390(a1 + 752, *(void **)(a1 + 760));
  sub_1000229D4(a1 + 712, *(char **)(a1 + 720));
  sub_1000229D4(a1 + 688, *(char **)(a1 + 696));
  sub_1000229D4(a1 + 664, *(char **)(a1 + 672));
  sub_1000229D4(a1 + 640, *(char **)(a1 + 648));
  sub_1000229D4(a1 + 616, *(char **)(a1 + 624));
  sub_10004AD90(a1 + 552);
  sub_100589E40(a1 + 528, *(void **)(a1 + 536));
  sub_10004AD90(a1 + 440);
  sub_10000AE14(a1 + 376);
  sub_10057D1B4((uint64_t *)(a1 + 272), 0LL);
  BOOL v34 = *(void ***)(a1 + 264);
  *(void *)(a1 + 264) = 0LL;
  if (v34) {
    sub_10058A4FC(a1 + 264, v34);
  }
  uint64_t v35 = *(void *)(a1 + 216);
  *(void *)(a1 + 216) = 0LL;
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 8LL))(v35);
  }
  uint64_t v36 = *(void *)(a1 + 208);
  *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0LL;
  if (v36) {
    (*(void (**)(uint64_t))(*(void *)v36 + 8LL))(v36);
  }
  uint64_t v37 = *(void *)(a1 + 200);
  *(void *)(a1 + 200) = 0LL;
  if (v37) {
    (*(void (**)(uint64_t))(*(void *)v37 + 8LL))(v37);
  }
  uint64_t v38 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = 0LL;
  if (v38) {
    (*(void (**)(uint64_t))(*(void *)v38 + 8LL))(v38);
  }
  uint64_t v39 = *(void *)(a1 + 184);
  *(void *)(a1 + 184) = 0LL;
  if (v39) {
    (*(void (**)(uint64_t))(*(void *)v39 + 8LL))(v39);
  }
  uint64_t v40 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = 0LL;
  if (v40) {
    (*(void (**)(uint64_t))(*(void *)v40 + 8LL))(v40);
  }
  uint64_t v41 = *(void *)(a1 + 168);
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;
  if (v41) {
    (*(void (**)(uint64_t))(*(void *)v41 + 8LL))(v41);
  }
  uint64_t v42 = *(void *)(a1 + 160);
  *(void *)(a1 + 160) = 0LL;
  if (v42) {
    (*(void (**)(uint64_t))(*(void *)v42 + 8LL))(v42);
  }
  uint64_t v43 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = 0LL;
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8LL))(v43);
  }
  sub_10057AA04(a1);
  return a1;
}

void sub_10057BC10(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_100006BB8(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10057BC3C(uint64_t a1)
{
  return sub_10057B4DC(a1 - 112);
}

void sub_10057BC44(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10057B4DC(a1);
  operator delete(v1);
}

void sub_10057BC58(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10057B4DC(a1 - 112);
  operator delete(v1);
}

CFStringRef sub_10057BC70(__CFString *filePath)
{
  if (!filePath) {
    return 0LL;
  }
  uint64_t v2 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, filePath, kCFURLPOSIXPathStyle, 1u);
  if (!v2) {
    return 0LL;
  }
  id v3 = v2;
  CFBundleRef v4 = CFBundleCreate(kCFAllocatorDefault, v2);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = sub_10059CEEC();
    BOOL v7 = (const __CFString *)_kCFBundleDisplayNameKey;
    __int16 v8 = sub_10059D310(v6, v5, _kCFBundleDisplayNameKey, 0);
    if (!v8)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v9 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        sub_1002A6C50(v7, __p);
        BOOL v10 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
        LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#warning could not get localized string '%{public}s'!",  (uint8_t *)&buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(__p, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v15 = qword_101934988;
        sub_1002A6C50(v7, &buf);
        if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          p_std::string buf = &buf;
        }
        else {
          p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
        }
        int v23 = 136446210;
        int v24 = p_buf;
        uint64_t v17 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  0LL,  "#warning could not get localized string '%{public}s'!",  &v23,  12);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CFStringRef _copyDisplayNameFromBundlePath(CFStringRef)",  "%s\n",  (const char *)v17);
        if (v17 != __p) {
          free(v17);
        }
      }

      uint64_t v11 = sub_10059CEEC();
      __int16 v8 = sub_10059D310(v11, v5, kCFBundleNameKey, 0);
      if (!v8)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        id v12 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
        {
          id v13 = -[__CFString UTF8String](filePath, "UTF8String");
          LODWORD(__p[0].__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "could not get UN localized bundle name from bundle at '%{public}s'; soup cannot be given to them.",
            (uint8_t *)__p,
            0xCu);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(__p, 0x65CuLL);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          uint64_t v18 = qword_101934988;
          id v19 = -[__CFString UTF8String](filePath, "UTF8String");
          LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
          LODWORD(v21) = 12;
          uint64_t v20 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v18,  17LL,  "could not get UN localized bundle name from bundle at '%{public}s'; soup cannot be given to them.",
                                 &buf,
                                 v21);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CFStringRef _copyDisplayNameFromBundlePath(CFStringRef)",  "%s\n",  (const char *)v20);
          if (v20 != __p) {
            free(v20);
          }
        }

        __int16 v8 = 0LL;
      }
    }

    CFRelease(v5);
  }

  else
  {
    __int16 v8 = 0LL;
  }

  CFRelease(v3);
  return v8;
}

void sub_10057C098(uint64_t a1)
{
  if (!*(void *)(a1 + 600)) {
    *(void *)(a1 + 600) = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CLClientManager.unsubscribeGrace");
  }
  uint64_t v2 = *(dispatch_source_s **)(a1 + 608);
  if (v2)
  {
    dispatch_time_t v3 = dispatch_time(0LL, (uint64_t)(*(double *)(a1 + 592) * 1000000000.0));
    dispatch_source_set_timer( v2,  v3,  0xFFFFFFFFFFFFFFFFLL,  (unint64_t)(*(double *)(a1 + 592) * 0.5 * 1000000000.0));
  }

  else
  {
    CFBundleRef v4 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0,  0,  (dispatch_queue_t)[*(id *)(a1 + 40) queue]);
    *(void *)(a1 + 60_Block_object_dispose(va, 8) = v4;
    dispatch_time_t v5 = dispatch_time(0LL, (uint64_t)(*(double *)(a1 + 592) * 1000000000.0));
    dispatch_source_set_timer( v4,  v5,  0xFFFFFFFFFFFFFFFFLL,  (unint64_t)(*(double *)(a1 + 592) * 0.5 * 1000000000.0));
    uint64_t v6 = *(dispatch_source_s **)(a1 + 608);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_10057C1EC;
    handler[3] = &unk_10181D3D0;
    handler[4] = a1;
    dispatch_source_set_event_handler(v6, handler);
    dispatch_resume(*(dispatch_object_t *)(a1 + 608));
  }

void sub_10057C1EC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);

  *(void *)(v1 + 600) = 0LL;
}

void sub_10057C214()
{
  uint64_t v0 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CLClientManager.privacyReset");
  dispatch_time_t v1 = dispatch_time(0LL, 300000000000LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10057C2A4;
  block[3] = &unk_10181A288;
  block[4] = v0;
  dispatch_after(v1, &_dispatch_main_q, block);
}

void sub_10057C2A4(uint64_t a1)
{
}

id sub_10057C2AC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v1 = a1 + 64;
  uint64_t v2 = v3;
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = v1;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < 0;
    if (v5 >= 0) {
      BOOL v7 = (uint64_t *)v2;
    }
    else {
      BOOL v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }

  while (*v7);
  if (v4 != v1 && *(int *)(v4 + 32) <= 0 && *(void *)(v4 + 56))
  {
    BOOL v10 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
    uint64_t v11 = *(void **)(v4 + 40);
    if (v11 != (void *)(v4 + 48))
    {
      do
      {
        if (*((char *)v11 + 63) < 0)
        {
          sub_1010DD48C(__p, (void *)v11[5], v11[6]);
        }

        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)(v11 + 5);
          uint64_t v26 = v11[7];
        }

        if (SHIBYTE(v26) < 0)
        {
          if (!__p[1])
          {
LABEL_43:
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
            uint64_t v17 = (os_log_s *)qword_101934988;
            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)std::string buf = 68289026;
              *(_DWORD *)uint64_t v30 = 0;
              *(_WORD *)&v30[4] = 2082;
              *(void *)&v30[6] = "";
              _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Found registered client for kNotificationReset with empty resetIdentifier}",  buf,  0x12u);
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
            }

            uint64_t v18 = (os_log_s *)qword_101934988;
            if (os_signpost_enabled((os_log_t)qword_101934988))
            {
              *(_DWORD *)std::string buf = 68289026;
              *(_DWORD *)uint64_t v30 = 0;
              *(_WORD *)&v30[4] = 2082;
              *(void *)&v30[6] = "";
              _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Found registered client for kNotificationReset with empty resetIdentifier",  "{msg%{public}.0s:Found registered client for kNotificationReset with empty resetIdentifier}",  buf,  0x12u);
            }

            goto LABEL_54;
          }

          id v12 = (void **)__p[0];
        }

        else
        {
          if (!HIBYTE(v26)) {
            goto LABEL_43;
          }
          id v12 = __p;
        }

        if (objc_msgSend( &off_1018D6D30,  "containsObject:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12)))
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          id v13 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
          {
            if (v26 >= 0) {
              __int16 v14 = __p;
            }
            else {
              __int16 v14 = (void **)__p[0];
            }
            *(_DWORD *)std::string buf = 136315138;
            *(void *)uint64_t v30 = v14;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "Skip un-tracked resetIdentifier: %s",  buf,  0xCu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
            if (v26 >= 0) {
              uint64_t v15 = __p;
            }
            else {
              uint64_t v15 = (void **)__p[0];
            }
            int v27 = 136315138;
            uint64_t v28 = v15;
            uint64_t v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "Skip un-tracked resetIdentifier: %s",  (const char *)&v27);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "NSArray *CLClientManager::resetIdentifiersForRegisteredClients()",  "%s\n",  v16);
          }
        }

        else
        {
          if (v26 >= 0) {
            id v19 = __p;
          }
          else {
            id v19 = (void **)__p[0];
          }
          -[NSMutableSet addObject:]( v10,  "addObject:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v19));
        }

void sub_10057C8B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10057C8DC(uint64_t a1, uint64_t a2)
{
  signed int v4 = [*(id *)(a1 + 136) intForKey:@"SupportedAuthorizationMask" atKeyPath:a2 defaultValue:0];
  unsigned int v5 = [*(id *)(a1 + 136) BOOLForKey:@"Hidden" atKeyPath:a2 defaultValue:0];
  signed int v6 = v4 & 0xFFFFFFFB;
  if (!v5) {
    return v4;
  }
  return v6;
}

__CFArray *sub_10057C950(double a1)
{
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (a1 < 100.0)
  {
    int valuePtr = 1;
    CFNumberRef v3 = sub_1002AD1CC(&valuePtr);
    CFArrayAppendValue(Mutable, v3);
    CFRelease(v3);
    int valuePtr = 10;
    CFNumberRef v4 = sub_1002AD1CC(&valuePtr);
    CFArrayAppendValue(Mutable, v4);
    CFRelease(v4);
  }

  if (a1 < 1000.0)
  {
    int valuePtr = 4;
    CFNumberRef v5 = sub_1002AD1CC(&valuePtr);
    CFArrayAppendValue(Mutable, v5);
    CFRelease(v5);
  }

  if (a1 < 6378135.0)
  {
    int valuePtr = 6;
    CFNumberRef v6 = sub_1002AD1CC(&valuePtr);
    CFArrayAppendValue(Mutable, v6);
    CFRelease(v6);
  }

  return Mutable;
}

uint64_t sub_10057CA70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = sub_1005486B8(a1, a2);
  uint64_t result = (uint64_t)sub_100564D84(a1, v5);
  if ((_DWORD)result) {
    return *(double *)(a3 + 8) <= 3000.0;
  }
  return result;
}

id sub_10057CADC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  id v6 = sub_10053D6E0(a1, a3);
  if (a4 && (v7 = v6, sub_1004F2598(), int v8 = sub_1001B9A1C(), a2 == 3) && v8) {
    return objc_msgSend( objc_msgSend(v7, "bundlePath"),  "isEqualToString:",  +[NSString stringWithUTF8String:]( NSString,  "stringWithUTF8String:",  "/System/Library/LocationBundles/AppleWatchFaces.bundle"));
  }
  else {
    return 0LL;
  }
}

void sub_10057CB64(uint64_t a1, uint64_t a2, unint64_t a3)
{
  id v5 = sub_1005486B8(a1, a2);
  __int16 v14 = 0LL;
  uint64_t v15 = 0LL;
  sub_100547724(a3, &v15, &v14);
  if (([*(id *)(a1 + 136) hasValueForKey:v15 atKeyPath:v5] & 1) == 0)
  {
    id v6 = v14;
    if (([*(id *)(a1 + 136) hasValueForKey:v14 atKeyPath:v5] & 1) == 0)
    {
      [*(id *)(a1 + 136) setDouble:v6 forKey:v5 atKeyPath:14406267.0];
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      BOOL v7 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        int v8 = off_10183F920[a3];
        *(_DWORD *)std::string buf = 138412546;
        *(void *)&uint8_t buf[4] = v5;
        __int16 v21 = 2080;
        BOOL v22 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "Service: client, %@, type, %s, marked as used",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        uint64_t v11 = off_10183F920[a3];
        int v16 = 138412546;
        id v17 = v5;
        __int16 v18 = 2080;
        id v19 = v11;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "Service: client, %@, type, %s, marked as used",  &v16,  22);
        id v13 = (char *)v12;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::markClientServiceUsed(CLClientKeyPath *, CLClientServiceType)",  "%s\n",  v12);
        if (v13 != buf) {
          free(v13);
        }
      }
    }
  }

  if (!_os_feature_enabled_impl("CoreLocation", "CLUnfederatedUsageSync")
    || a3 <= 0xA && ((1LL << a3) & 0x430) != 0)
  {
    uint64_t v9 = (char *)objc_msgSend(objc_msgSend(v5, "legacyClientKey"), "UTF8String");
    if (v9) {
      BOOL v10 = v9;
    }
    else {
      BOOL v10 = "";
    }
    sub_1010DDBC0(buf, v10);
    sub_10056DD40(a1, buf);
    if (v23 < 0) {
      operator delete(*(void **)buf);
    }
  }

void sub_10057CE1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_10057CE40(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 136);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10057CE98;
  v3[3] = &unk_10183F8B0;
  void v3[4] = a1;
  return [v1 iterateAllAnchorKeyPathsWithBlock:v3];
}

uint64_t sub_10057CE98(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0LL;
  uint64_t v4 = *(void *)(a1 + 32);
  do
  {
    unint64_t v5 = qword_1012F0BB0[v3];
    uint64_t result = _os_feature_enabled_impl("CoreLocation", "CLUnfederatedUsageSync");
    if ((_DWORD)result)
    {
      if (v5 > 0xA || ((1LL << v5) & 0x430) == 0) {
        break;
      }
    }

    double Current = CFAbsoluteTimeGetCurrent();
    uint64_t result = sub_10056CADC(v4, a2, v5, 0, 0, 1, Current);
    ++v3;
  }

  while (v3 != 11);
  return result;
}

id sub_10057CF50(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  id result = [v3 isValidCKP];
  if ((_DWORD)result)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unint64_t v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      v9[0] = 68289282;
      v9[1] = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2114;
      id v13 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:clearing regions for client, client:%{public, location:escape_only}@}",  (uint8_t *)v9,  0x1Cu);
    }

    for (unsigned int i = 0; i != 4; ++i)
    {
      uint64_t v7 = sub_100547A14(i);
      double Current = CFAbsoluteTimeGetCurrent();
      id result = (id)sub_10056CADC(a1, (uint64_t)v3, v7, 0, 0, 0, Current);
    }
  }

  return result;
}

id sub_10057D090(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  id result = [v3 isValidCKP];
  if ((_DWORD)result)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unint64_t v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      v6[0] = 68289282;
      v6[1] = 0;
      __int16 v7 = 2082;
      int v8 = "";
      __int16 v9 = 2114;
      id v10 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:clearing significant location change for client, Client:%{public, location:escape_only}@}",  (uint8_t *)v6,  0x1Cu);
    }

    return [*(id *)(a1 + 136) removeValueForKey:@"SignificantTimeStarted" atKeyPath:v3];
  }

  return result;
}

uint64_t sub_10057D1AC(uint64_t a1)
{
  return CFUserNotificationCancel(*(CFUserNotificationRef *)(a1 + 32));
}

void sub_10057D1B4(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    uint64_t v4 = (void *)sub_1005858A0(v3);
    operator delete(v4);
  }

double sub_10057D1E0(uint64_t a1)
{
  return *(double *)(*(void *)(a1 + 272) + 64LL);
}

uint64_t sub_10057D1EC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 997);
}

uint64_t sub_10057D1F4(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t result = (uint64_t)[*(id *)(v6 + 136) intForKey:@"Authorization" atKeyPath:a2 defaultValue:0];
  if ((result & 6) != 0)
  {
    uint64_t result = sub_100AE0758(objc_msgSend(objc_msgSend(*(id *)(v6 + 136), "readonlyStoreAtKeyPath:", a2), "dictionary"));
    if (result > 8 || ((1 << result) & 0x1A8) == 0)
    {
      *a3 = 1;
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
    }
  }

  return result;
}

id sub_10057D288(const void *a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_100585B3C;
  v5[3] = &unk_101840280;
  v5[4] = a1;
  void v5[5] = a2;
  return [(id)qword_101996E40 doAsync:v5];
}

void sub_10057D2F4(uint64_t a1, CFTypeRef cf, double a3)
{
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v6 = *(const void **)(a1 + 48);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = cf;
  *(double *)(a1 + 64) = a3;
}

uint64_t sub_10057D340(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    id v6 = sub_1005486B8(a1, a2);
  }

  else
  {
    id v6 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
    uint64_t result = (uint64_t)[v6 isValidCKP];
    if (!(_DWORD)result) {
      return result;
    }
  }

  unsigned int v8 = [*(id *)(a1 + 136) BOOLForKey:@"BackgroundIndicatorEnabled" atKeyPath:v6 defaultValue:0];
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  __int16 v9 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    v10[0] = 68289794;
    v10[1] = 0;
    __int16 v11 = 2082;
    __int16 v12 = "";
    __int16 v13 = 2114;
    id v14 = v6;
    __int16 v15 = 1026;
    unsigned int v16 = v8;
    __int16 v17 = 2050;
    uint64_t v18 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:update client background indicator enabled, Client:%{public, location:escape_only}@, old:%{public}d, new:%{public}lu}",  (uint8_t *)v10,  0x2Cu);
  }

  [*(id *)(a1 + 136) setBool:a3 forKey:@"BackgroundIndicatorEnabled" atKeyPath:v6];
  [*(id *)(a1 + 136) persist];
  sub_10057E678(a1, (uint64_t)v6);
  return 1LL;
}

id sub_10057D4D0(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  id result = [v3 isValidCKP];
  if ((_DWORD)result) {
    return (id)(([*(id *)(a1 + 136) intForKey:@"Authorization" atKeyPath:v3 defaultValue:0] & 6) != 0);
  }
  return result;
}

void sub_10057D528(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  id v6 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if ([v6 isValidCKP])
  {
    else {
      __int16 v7 = (uint64_t *)*a3;
    }
    objc_msgSend( *(id *)(a1 + 136),  "setString:forKey:atKeyPath:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7),  @"AuthorizationPurposeKey",  v6);
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    unsigned int v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      int v10 = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      __int16 v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:setClientAuthorizationPurposeKey for an app we don't have an entry for, Client:%{pu blic, location:escape_only}@}",  (uint8_t *)&v10,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    __int16 v9 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      int v10 = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      __int16 v13 = "";
      __int16 v14 = 2114;
      uint64_t v15 = a2;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "setClientAuthorizationPurposeKey for an app we don't have an entry for",  "{msg%{public}.0s:setClientAuthorizationPurposeKey for an app we don't have an entry for, Client:%{pu blic, location:escape_only}@}",  (uint8_t *)&v10,  0x1Cu);
    }
  }

id sub_10057D734(uint64_t a1, uint64_t a2)
{
  id v3 = sub_10053D6E0(a1, a2);
  id v4 = [*(id *)(a1 + 136) BOOLForKey:@"AuthorizationUpgradeAvailable" atKeyPath:v3 defaultValue:1];
  [*(id *)(a1 + 136) setBool:0 forKey:@"AuthorizationUpgradeAvailable" atKeyPath:v3];
  [*(id *)(a1 + 136) persist];
  return v4;
}

id sub_10057D7A4(uint64_t a1, uint64_t a2, int a3, int a4)
{
  id v7 = sub_10053D6E0(a1, a2);
  unsigned int v8 = *(void **)(a1 + 136);
  if (!a3)
  {
    [v8 setBool:1 forKey:@"ProvisionalMonitoring" atKeyPath:v7];
    [*(id *)(a1 + 136) setDouble:@"ProvisionalMonitoringBegin" forKey:v7 atKeyPath:CFAbsoluteTimeGetCurrent()];
    return [*(id *)(a1 + 136) persist];
  }

  [v8 removeValueForKey:@"ProvisionalMonitoring" atKeyPath:v7];
  [*(id *)(a1 + 136) removeValueForKey:@"ProvisionalMonitoringBegin" atKeyPath:v7];
  [*(id *)(a1 + 136) setBool:0 forKey:@"AuthorizationUpgradeAvailable" atKeyPath:v7];
  __int16 v9 = *(unsigned __int8 **)(a1 + 264);
  if (v9)
  {
    if (v7)
    {
      [v7 cppClientKey];
      LODWORD(v7) = HIBYTE(v28);
      uint64_t v10 = v27;
    }

    else
    {
      uint64_t v10 = 0LL;
      std::string __p = 0LL;
      uint64_t v27 = 0LL;
      uint64_t v28 = 0LL;
    }

    uint64_t v11 = v9[23];
    if ((v11 & 0x80u) == 0LL) {
      uint64_t v12 = v9[23];
    }
    else {
      uint64_t v12 = *((void *)v9 + 1);
    }
    if (v12 != v10)
    {
      BOOL v21 = 0;
      goto LABEL_34;
    }

    else {
      p_p = (unsigned __int8 *)__p;
    }
    if ((v11 & 0x80) != 0)
    {
      BOOL v21 = memcmp(*(const void **)v9, p_p, *((void *)v9 + 1)) == 0;
    }

    else
    {
      if (!v9[23])
      {
        BOOL v21 = 1;
        if ((v7 & 0x80) == 0)
        {
LABEL_31:
          if (!v21) {
            return [*(id *)(a1 + 136) persist];
          }
LABEL_35:
          BOOL v22 = (void ***)(a1 + 264);
          if (a4)
          {
            uint64_t v23 = *(void *)(a1 + 288);
            if (v23)
            {
              (*(void (**)(uint64_t, void))(v23 + 16))(v23, 0LL);

              *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
            }
          }

          int v24 = *v22;
          *BOOL v22 = 0LL;
          if (v24) {
            sub_10058A4FC(a1 + 264, v24);
          }
          *(_BYTE *)(a1 + 280) = 0;
          return [*(id *)(a1 + 136) persist];
        }

BOOL sub_10057D9A0(uint64_t a1, int a2)
{
  BOOL v14 = 0;
  if (a2) {
    sub_1002F13B4((uint64_t)v15);
  }
  int v3 = sub_1002A6F64((uint64_t)v15, "SBParentalControlsEnabled", &v14);
  if (v14) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 == 1 && (int v5 = sub_1002AF124((uint64_t)v15, v18), v14 = 0, v5 >= 1))
  {
    int v6 = 0;
    do
    {
      if (!sub_1002A8560((uint64_t)v15, v18, &v16))
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        id v7 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "NameValuePair::get failed despite our bounds checking",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          v13[0] = 0;
          LODWORD(v12) = 2;
          uint64_t v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "NameValuePair::get failed despite our bounds checking",  v13,  v12);
          sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLClientManager::areParentalControlsEnabled(BOOL)", "%s\n", v10);
        }
      }

      int v8 = std::string::compare(&v16, "location");
      BOOL v9 = v8 == 0;
      BOOL v14 = v8 == 0;
      if (!v8) {
        break;
      }
      ++v6;
    }

    while (v6 < v5);
  }

  else
  {
    BOOL v9 = 0LL;
  }

  sub_1002F14C8(v15);
  return v9;
}

void sub_10057DC50( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *__p, uint64_t a31, int a32, __int16 a33, char a34, char a35)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10057DC88(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  sub_1010DDBC0(__p, "");
  sub_100544214(v3, a2, (uint64_t)__p);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10057DCE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10057DCFC(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  sub_1005470F4(v4, (uint64_t)a2, 10LL);
  sub_1005470F4(v4, (uint64_t)a2, 4LL);
  char v5 = (dispatch_source_s *)[*(id *)(v4 + 392) objectForKeyedSubscript:a2];
  if (v5)
  {
    dispatch_source_cancel(v5);
    [*(id *)(v4 + 392) removeObjectForKey:a2];
  }

  int v6 = sub_1005470F4(v4, (uint64_t)a2, 5LL);
  unsigned __int8 v7 = atomic_load((unsigned __int8 *)&qword_101996E20);
  if ((v7 & 1) == 0)
  {
    int v26 = v6;
    int v27 = __cxa_guard_acquire(&qword_101996E20);
    int v6 = v26;
    if (v27)
    {
      BOOL v28 = objc_opt_class(&OBJC_CLASS___RBSProcessPredicate)
         && objc_opt_class(&OBJC_CLASS___RBSProcessHandle)
         && objc_opt_class(&OBJC_CLASS___RBSAttribute)
         && objc_opt_class(&OBJC_CLASS___RBSTarget)
         && objc_opt_class(&OBJC_CLASS___RBSAssertion) != 0;
      byte_101996E18 = v28;
      __cxa_guard_release(&qword_101996E20);
      int v6 = v26;
    }
  }

  if (byte_101996E18) {
    int v8 = v6;
  }
  else {
    int v8 = 0;
  }
  if (v8 == 1 && *(_BYTE *)(a1 + 40))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v9 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2114;
      *(void *)&buf[20] = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Resuming client, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    if (a2)
    {
      [a2 clientName];
    }

    else
    {
      uint64_t v55 = 0LL;
      *(_OWORD *)std::string __p = 0u;
      __int128 v54 = 0u;
      __int128 v51 = 0u;
      *(_OWORD *)__int128 v52 = 0u;
      __int128 v49 = 0u;
      *(_OWORD *)__int128 v50 = 0u;
      *(_OWORD *)uint64_t v47 = 0u;
      *(_OWORD *)uint64_t v48 = 0u;
      __int128 v46 = 0u;
      memset(buf, 0, sizeof(buf));
    }

    if ([a2 bundleId])
    {
      id v10 = [a2 bundleId];
      uint64_t v30 = 0LL;
      id v11 = +[RBSProcessHandle handleForPredicate:error:]( &OBJC_CLASS___RBSProcessHandle,  "handleForPredicate:error:",  +[RBSProcessPredicate predicateMatchingBundleIdentifier:]( &OBJC_CLASS___RBSProcessPredicate,  "predicateMatchingBundleIdentifier:",  v10),  &v30);
      uint64_t v12 = v11;
      *(void *)uint64_t v40 = 0LL;
      *(void *)&__int128 v41 = v40;
      *((void *)&v41 + 1) = 0x3052000000LL;
      uint64_t v42 = sub_10054E61C;
      uint64_t v43 = sub_10054E62C;
      uint64_t v44 = 0LL;
      if (!v11 || ([v11 pid] & 0x80000000) != 0)
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        id v19 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
        {
          id v20 = [a2 bundleId];
          *(_DWORD *)__int16 v31 = 68289538;
          int v32 = 0;
          __int16 v33 = 2082;
          BOOL v34 = "";
          __int16 v35 = 2114;
          id v36 = v20;
          __int16 v37 = 2114;
          uint64_t v38 = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Warning Failed to get the process handle, bundleID:%{public, location:escape_o nly}@, error:%{public, location:escape_only}@}",  v31,  0x26u);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
        }

        BOOL v21 = (os_log_s *)qword_101934988;
        if (os_signpost_enabled((os_log_t)qword_101934988))
        {
          id v22 = [a2 bundleId];
          *(_DWORD *)__int16 v31 = 68289538;
          int v32 = 0;
          __int16 v33 = 2082;
          BOOL v34 = "";
          __int16 v35 = 2114;
          id v36 = v22;
          __int16 v37 = 2114;
          uint64_t v38 = v30;
          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v21,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Warning Failed to get the process handle",  "{msg%{public}.0s:#Warning Failed to get the process handle, bundleID:%{public, location:escape_o nly}@, error:%{public, location:escape_only}@}",  v31,  0x26u);
        }
      }

      else
      {
        uint64_t v39 = +[RBSDomainAttribute attributeWithDomain:name:]( &OBJC_CLASS___RBSDomainAttribute,  "attributeWithDomain:name:",  @"com.apple.locationd",  @"Location");
        id v13 = objc_msgSend( [RBSAssertion alloc],  "initWithExplanation:target:attributes:",  @"locationd-resume-on-crash",  +[RBSTarget targetWithPid:](RBSTarget, "targetWithPid:", objc_msgSend(v12, "pid")),  +[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v39, 1));
        *(void *)(v41 + 40) = v13;
        if (!v13)
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          BOOL v14 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
          {
            id v15 = [v10 UTF8String];
            *(_DWORD *)__int16 v31 = 68289538;
            int v32 = 0;
            __int16 v33 = 2082;
            BOOL v34 = "";
            __int16 v35 = 2082;
            id v36 = v15;
            __int16 v37 = 2114;
            uint64_t v38 = v30;
            _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#warning Failed to resume: init failure, client:%{public, location:escape_onl y}s, error:%{public, location:escape_only}@}",  v31,  0x26u);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
          }

          std::string v16 = (os_log_s *)qword_101934988;
          if (os_signpost_enabled((os_log_t)qword_101934988))
          {
            id v17 = [v10 UTF8String];
            *(_DWORD *)__int16 v31 = 68289538;
            int v32 = 0;
            __int16 v33 = 2082;
            BOOL v34 = "";
            __int16 v35 = 2082;
            id v36 = v17;
            __int16 v37 = 2114;
            uint64_t v38 = v30;
            _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#warning Failed to resume: init failure",  "{msg%{public}.0s:#warning Failed to resume: init failure, client:%{public, location:escape_onl y}s, error:%{public, location:escape_only}@}",  v31,  0x26u);
          }
        }

        if ([*(id *)(v41 + 40) acquireWithError:&v30])
        {
          int v18 = *(void **)(v4 + 40);
          v29[0] = _NSConcreteStackBlock;
          v29[1] = 3221225472LL;
          v29[2] = sub_10057E59C;
          v29[3] = &unk_10182EFC8;
          v29[4] = v40;
          [v18 afterInterval:v29 async:10.0];
        }

        else
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          int v24 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
          {
            id v25 = [v10 UTF8String];
            *(_DWORD *)__int16 v31 = 68289538;
            int v32 = 0;
            __int16 v33 = 2082;
            BOOL v34 = "";
            __int16 v35 = 2082;
            id v36 = v25;
            __int16 v37 = 2114;
            uint64_t v38 = v30;
            _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#warning Failed to resume: assertion not acquired, client:%{public, location: escape_only}s, error:%{public, location:escape_only}@}",  v31,  0x26u);
          }
        }
      }

      _Block_object_dispose(v40, 8);
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v23 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v40 = 68289026;
        *(_DWORD *)&v40[4] = 0;
        LOWORD(v41) = 2082;
        *(void *)((char *)&v41 + 2) = "";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Non-app client is/was a background client?}",  v40,  0x12u);
      }
    }

    if (SHIBYTE(v54) < 0) {
      operator delete(__p[1]);
    }
    if (SHIBYTE(__p[0]) < 0) {
      operator delete(v52[0]);
    }
    if (SHIBYTE(v51) < 0) {
      operator delete(v50[1]);
    }
    if (SHIBYTE(v49) < 0) {
      operator delete(v48[1]);
    }
    if (SHIBYTE(v48[0]) < 0) {
      operator delete(v47[0]);
    }
    if (SHIBYTE(v46) < 0) {
      operator delete(*(void **)&buf[24]);
    }
  }

void sub_10057E530(_Unwind_Exception *a1)
{
}

void sub_10057E59C(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) = 0LL;
}

_BYTE *sub_10057E5E4(uint64_t a1)
{
  return sub_1005569D8(*(_BYTE **)(a1 + 32));
}

_BYTE *sub_10057E5EC(uint64_t a1)
{
  return sub_1005569D8(*(_BYTE **)(a1 + 32));
}

void sub_10057E5F4(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if ([*(id *)(v3 + 136) isKeyPathRegisteredSystemService:a2])
  {
    sub_1010DDBC0(__p, "");
    sub_100544214(v3, a2, (uint64_t)__p);
    if (v5 < 0) {
      operator delete(__p[0]);
    }
  }

void sub_10057E65C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10057E678(uint64_t a1, uint64_t a2)
{
  id v3 = sub_10053D6E0(a1, a2);
  char v4 = sub_100544800(a1, (uint64_t)v3);
  char v5 = *(void **)(a1 + 752);
  int v6 = (void *)(a1 + 760);
  if (v5 != v6)
  {
    char v7 = v4;
    do
    {
      int v8 = (void *)v5[1];
      if (v8)
      {
        do
        {
          BOOL v9 = v8;
          int v8 = (void *)*v8;
        }

        while (v8);
      }

      else
      {
        do
        {
          BOOL v9 = (void *)v5[2];
          BOOL v10 = *v9 == (void)v5;
          char v5 = v9;
        }

        while (!v10);
      }

      char v5 = v9;
    }

    while (v9 != v6);
  }

id sub_10057E720(uint64_t a1, void *a2)
{
  id result = [a2 subIdentityType];
  if ((_DWORD)result == 122) {
    ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }
  return result;
}

void sub_10057E760(unsigned int *a1)
{
  if (*((void *)a1 + 5))
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101840220);
    }
    uint64_t v2 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *((void *)a1 + 1);
      uint64_t v4 = *a1;
      *(_DWORD *)std::string buf = 68289538;
      int v14 = 0;
      __int16 v15 = 2082;
      std::string v16 = "";
      __int16 v17 = 2114;
      uint64_t v18 = v3;
      __int16 v19 = 2050;
      uint64_t v20 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt AuthorizationRequest completion, ClientKey:%{public, location:escape_on ly}@, RequestType:%{public, location:CLClientManager_Type::AuthorizationRequestType}lld}",  buf,  0x26u);
    }

    (*(void (**)(void))(*((void *)a1 + 5) + 16LL))();

    *((void *)a1 + 5) = 0LL;
    *a1 = 0;

    *((void *)a1 + 1) = 0LL;
    uint64_t v5 = *((void *)a1 + 6);
    if (v5)
    {
      *((void *)a1 + 6) = 0LL;
      int v6 = (__CFRunLoop *)sub_10029228C();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100585E20;
      block[3] = &unk_10181D3D0;
      block[4] = v5;
      CFRunLoopPerformBlock(v6, kCFRunLoopCommonModes, block);
    }

    BOOL v9 = (void *)*((void *)a1 + 7);
    int v8 = a1 + 14;
    char v7 = v9;
    if (v9) {

    }
    *int v8 = 0LL;
    v8[1] = 0LL;
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v14 = 0;
      __int16 v15 = 2082;
      std::string v16 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Request was completed multiple times}",  buf,  0x12u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
    }

    id v11 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v14 = 0;
      __int16 v15 = 2082;
      std::string v16 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v11,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Request was completed multiple times",  "{msg%{public}.0s:Request was completed multiple times}",  buf,  0x12u);
    }
  }

void sub_10057EA1C(uint64_t a1, const char *a2)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v3 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = "";
    if (a2) {
      uint64_t v4 = a2;
    }
    *(_DWORD *)std::string buf = 136446210;
    __int16 v17 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "open preferences with url, %{public}s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v9 = "";
    if (a2) {
      BOOL v9 = a2;
    }
    int v14 = 136446210;
    __int16 v15 = v9;
    BOOL v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "open preferences with url, %{public}s",  &v14,  12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLClientManager::openPreferences(const char *const)", "%s\n", v10);
  }

  uint64_t v5 = +[NSURL URLWithString:]( &OBJC_CLASS___NSURL,  "URLWithString:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
  if (v5)
  {
    int v6 = v5;
    dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10057ED98;
    block[3] = &unk_10181A288;
    block[4] = v6;
    dispatch_async(global_queue, block);
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 136446210;
      __int16 v17 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "Couldn't create Preferences URL, %{public}s",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v14 = 136446210;
      __int16 v15 = a2;
      LODWORD(v12) = 12;
      id v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't create Preferences URL, %{public}s",  &v14,  v12);
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLClientManager::openPreferences(const char *const)", "%s\n", v11);
    }
  }

void sub_10057ED98(uint64_t a1)
{
  uint64_t v2 = objc_autoreleasePoolPush();
  if ((objc_msgSend( +[LSApplicationWorkspace defaultWorkspace]( LSApplicationWorkspace,  "defaultWorkspace"),  "openSensitiveURL:withOptions:",  *(void *)(a1 + 32),  0) & 1) == 0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v3 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "could not launch Preferences", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      v5[0] = 0;
      uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "could not launch Preferences",  v5,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLClientManager::openPreferences(const char *const)_block_invoke",  "%s\n",  v4);
    }
  }

  objc_autoreleasePoolPop(v2);
}

void sub_10057EF54(uint64_t a1, uint64_t a2, int *a3)
{
  if (*a3)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v4 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      int v5 = *a3;
      *(_DWORD *)std::string buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Unknown notification: %{public}d", buf, 8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v6 = *a3;
      v9[0] = 67240192;
      v9[1] = v6;
      char v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Unknown notification: %{public}d",  v9,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLClientManager::onDarwinNotification(int, const CLDarwinNotifier_Type::Notification &, const CLDarwinNotif ier_Type::NotificationData &)",  "%s\n",  v7);
    }
  }

  else
  {
    sub_1010DDBC0(buf, "com.apple.locationd.darwin_notification");
    sub_100545EE8(a1, (uint64_t *)buf, 1);
    if (v11 < 0) {
      operator delete(*(void **)buf);
    }
  }

void sub_10057F140( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10057F164(uint64_t a1, unsigned int a2, int *a3, uint64_t a4)
{
  uint64_t v7 = a4 + 8;
  else {
    uint64_t v8 = *(void *)(a4 + 8);
  }
  uint64_t v134 = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v8),  105LL);
  BOOL v9 = (CLClientKeyPath *)objc_msgSend(*(id *)(a1 + 136), "registeredKeyPathForClientIdentifier:");
  std::string::size_type v135 = (unsigned int *)a3;
  if ((*a3 - 10) >= 2)
  {
    if (*a3 == 12)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v18 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        else {
          uint64_t v19 = *(void *)(a4 + 8);
        }
        unsigned int v20 = -[CLClientKeyPath isValidCKP](v9, "isValidCKP");
        int v21 = *(unsigned __int8 *)(a4 + 105);
        *(_DWORD *)std::string buf = 68290050;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2082;
        *(void *)&buf[20] = v19;
        *(_WORD *)&_BYTE buf[28] = 2114;
        *(void *)&buf[30] = v9;
        *(_WORD *)&_BYTE buf[38] = 1026;
        *(_DWORD *)&uint8_t buf[40] = v20;
        *(_WORD *)&buf[44] = 1026;
        *(_DWORD *)&buf[46] = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:AppProtection notification, NotificationData.bundleId:%{public, location:escape_o nly}s, ckp:%{public, location:escape_only}@, isValidCkp:%{public}hhd, isAppHidden:%{public}hhd}",  buf,  0x32u);
      }

      if (-[CLClientKeyPath isValidCKP](v9, "isValidCKP"))
      {
        id v22 = *(void **)(a1 + 136);
        if (*(_BYTE *)(a4 + 105))
        {
          [v22 setBool:1 forKey:@"Hidden" atKeyPath:v9];
          unsigned __int8 v23 = [*(id *)(a1 + 136) intForKey:@"Authorization" atKeyPath:v9 defaultValue:0];
          if ((v23 & 2) != 0) {
            unsigned int v24 = [*(id *)(a1 + 136) BOOLForKey:@"ProvisionalMonitoring" atKeyPath:v9 defaultValue:0];
          }
          else {
            unsigned int v24 = 0;
          }
          if ((v23 & 4) != 0 || v24)
          {
            sub_10057D7A4(a1, (uint64_t)v9, 1, 0);
            [*(id *)(a1 + 136) removeValueForKey:@"AuthorizationUpgradeAvailable" atKeyPath:v9];
            sub_10056840C( a1,  (uint64_t)v9,  2uLL,  (uint64_t)[*(id *)(a1 + 136) intForKey:@"CorrectiveCompensationEnabled" atKeyPath:v9 defaultValue:0],  0,  1,  1);
          }
        }

        else
        {
          [v22 removeValueForKey:@"Hidden" atKeyPath:v9];
          [*(id *)(a1 + 136) persist];
        }
      }
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      id v25 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        int v26 = sub_100D943B0(a3);
        int v27 = *(_DWORD *)a4;
        else {
          uint64_t v28 = *(void *)(a4 + 8);
        }
        *(_DWORD *)std::string buf = 68289794;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2082;
        *(void *)&buf[20] = v26;
        *(_WORD *)&_BYTE buf[28] = 1026;
        *(_DWORD *)&buf[30] = v27;
        *(_WORD *)&buf[34] = 2082;
        *(void *)&buf[36] = v28;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:AppMonitor notification, notification:%{public, location:escape_only}s, pid:% {public}d, bundleId:%{public, location:escape_only}s}",  buf,  0x2Cu);
      }

      int v29 = *a3;
      if (*a3 == 2)
      {
        v137[0] = 0LL;
        v137[1] = 0LL;
        v138[0] = 0LL;
        uint64_t v30 = *(void **)(a1 + 752);
        __int16 v31 = (void *)(a1 + 760);
        if (v30 != (void *)(a1 + 760))
        {
          do
          {
            __int16 v33 = (CLConnection *)v30[4];
            uint64_t v32 = v30[5];
            if (CLConnection::getRemotePid(v33) == *(_DWORD *)a4)
            {
              id v34 = objc_msgSend(sub_10086D1D8(v32, 0), "clientKey");
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              __int16 v35 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)std::string buf = 138543362;
                *(void *)&uint8_t buf[4] = v34;
                _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_INFO,  "'%{public}@' task suspended: removing client",  buf,  0xCu);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934980 != -1) {
                  dispatch_once(&qword_101934980, &stru_1018401A0);
                }
                *(_DWORD *)uint64_t v146 = 138543362;
                *(void *)&v146[4] = v34;
                LODWORD(v132) = 12;
                uint64_t v48 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "'%{public}@' task suspended: removing client",  v146,  v132);
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CLA ppMonitor_Type::NotificationData &)",  "%s\n",  v48);
              }

              id v36 = (char *)v137[1];
              if (v137[1] >= v138[0])
              {
                int64_t v38 = ((char *)v137[1] - (char *)v137[0]) >> 3;
                unint64_t v39 = ((char *)v138[0] - (char *)v137[0]) >> 2;
                if (v39 <= v38 + 1) {
                  unint64_t v39 = v38 + 1;
                }
                else {
                  unint64_t v40 = v39;
                }
                if (v40) {
                  __int128 v41 = (char *)sub_1000071BC((uint64_t)v138, v40);
                }
                else {
                  __int128 v41 = 0LL;
                }
                uint64_t v42 = (CLConnection **)&v41[8 * v38];
                *uint64_t v42 = v33;
                __int16 v37 = v42 + 1;
                uint64_t v44 = (char *)v137[0];
                uint64_t v43 = (char *)v137[1];
                if (v137[1] != v137[0])
                {
                  do
                  {
                    uint8_t v45 = (CLConnection *)*((void *)v43 - 1);
                    v43 -= 8;
                    *--uint64_t v42 = v45;
                  }

                  while (v43 != v44);
                  uint64_t v43 = (char *)v137[0];
                }

                v137[0] = v42;
                v137[1] = v37;
                v138[0] = &v41[8 * v40];
                if (v43) {
                  operator delete(v43);
                }
              }

              else
              {
                *(void *)v137[1] = v33;
                __int16 v37 = v36 + 8;
              }

              v137[1] = v37;
            }

            __int128 v46 = (void *)v30[1];
            if (v46)
            {
              do
              {
                uint64_t v47 = v46;
                __int128 v46 = (void *)*v46;
              }

              while (v46);
            }

            else
            {
              do
              {
                uint64_t v47 = (void *)v30[2];
                BOOL v123 = *v47 == (void)v30;
                uint64_t v30 = v47;
              }

              while (!v123);
            }

            uint64_t v30 = v47;
          }

          while (v47 != v31);
        }

        __int128 v49 = *(void **)(a1 + 776);
        if (v49 != (void *)(a1 + 784))
        {
          do
          {
            __int128 v51 = (CLConnection *)v49[4];
            uint64_t v50 = v49[5];
            if (CLConnection::getRemotePid(v51) == *(_DWORD *)a4)
            {
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              __int128 v52 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
              {
                (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)v50 + 24LL))(buf, v50);
                __int128 v53 = buf;
                if ((buf[23] & 0x80u) != 0) {
                  __int128 v53 = *(uint8_t **)buf;
                }
                *(_DWORD *)uint64_t v146 = 136446210;
                *(void *)&v146[4] = v53;
                _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_INFO,  "'%{public}s' task suspended: removing client",  v146,  0xCu);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934980 != -1) {
                  dispatch_once(&qword_101934980, &stru_1018401A0);
                }
                uint64_t v66 = qword_101934988;
                (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)v50 + 24LL))(v146, v50);
                id v67 = v146;
                if (v147 < 0) {
                  id v67 = *(_BYTE **)v146;
                }
                int v148 = 136446210;
                __int16 v149 = v67;
                LODWORD(v132) = 12;
                unint64_t v68 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v66,  1LL,  "'%{public}s' task suspended: removing client",  &v148,  v132);
                if (v147 < 0) {
                  operator delete(*(void **)v146);
                }
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CLA ppMonitor_Type::NotificationData &)",  "%s\n",  v68);
              }

              __int128 v54 = (char *)v137[1];
              if (v137[1] >= v138[0])
              {
                int64_t v56 = ((char *)v137[1] - (char *)v137[0]) >> 3;
                unint64_t v57 = ((char *)v138[0] - (char *)v137[0]) >> 2;
                if (v57 <= v56 + 1) {
                  unint64_t v57 = v56 + 1;
                }
                else {
                  unint64_t v58 = v57;
                }
                if (v58) {
                  char v59 = (char *)sub_1000071BC((uint64_t)v138, v58);
                }
                else {
                  char v59 = 0LL;
                }
                NSErrorUserInfoKey v60 = (CLConnection **)&v59[8 * v56];
                *NSErrorUserInfoKey v60 = v51;
                uint64_t v55 = v60 + 1;
                unint64_t v62 = (char *)v137[0];
                char v61 = (char *)v137[1];
                if (v137[1] != v137[0])
                {
                  do
                  {
                    id v63 = (CLConnection *)*((void *)v61 - 1);
                    v61 -= 8;
                    *--NSErrorUserInfoKey v60 = v63;
                  }

                  while (v61 != v62);
                  char v61 = (char *)v137[0];
                }

                v137[0] = v60;
                v137[1] = v55;
                v138[0] = &v59[8 * v58];
                if (v61) {
                  operator delete(v61);
                }
              }

              else
              {
                *(void *)v137[1] = v51;
                uint64_t v55 = v54 + 8;
              }

              v137[1] = v55;
            }

            int v64 = (void *)v49[1];
            if (v64)
            {
              do
              {
                int v65 = v64;
                int v64 = (void *)*v64;
              }

              while (v64);
            }

            else
            {
              do
              {
                int v65 = (void *)v49[2];
                BOOL v123 = *v65 == (void)v49;
                __int128 v49 = v65;
              }

              while (!v123);
            }

            __int128 v49 = v65;
          }

          while (v65 != (void *)(a1 + 784));
        }

        __int16 v69 = *(void **)(a1 + 848);
        if (v69 != (void *)(a1 + 856))
        {
          do
          {
            uint64_t v70 = v69[4];
            if ([(id)sub_100019240(v70) isEqual:v9])
            {
              id v71 = [(id)sub_100019240(v70) clientKey];
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              int v72 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)std::string buf = 68289538;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)&uint8_t buf[8] = 2082;
                *(void *)&buf[10] = "";
                *(_WORD *)&_BYTE buf[18] = 2114;
                *(void *)&buf[20] = v71;
                *(_WORD *)&_BYTE buf[28] = 2050;
                *(void *)&buf[30] = v70;
                _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#dic task suspended: cancelling retirement, ClientKey:%{public, location: escape_only}@, this:%{public}p}",  buf,  0x26u);
              }

              sub_100D56EEC(v70);
            }

            int v73 = (void *)v69[1];
            if (v73)
            {
              do
              {
                uint64_t v74 = v73;
                int v73 = (void *)*v73;
              }

              while (v73);
            }

            else
            {
              do
              {
                uint64_t v74 = (void *)v69[2];
                BOOL v123 = *v74 == (void)v69;
                __int16 v69 = v74;
              }

              while (!v123);
            }

            __int16 v69 = v74;
          }

          while (v74 != (void *)(a1 + 856));
        }

        __int16 v75 = *(void **)(a1 + 824);
        if (v75 != (void *)(a1 + 832))
        {
          do
          {
            __int16 v77 = (CLConnection *)v75[4];
            uint64_t v76 = v75[5];
            if (CLConnection::getRemotePid(v77) == *(_DWORD *)a4)
            {
              id v78 = [(id)sub_100019240(v76) clientKey];
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              __int16 v79 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)std::string buf = 138543362;
                *(void *)&uint8_t buf[4] = v78;
                _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_INFO,  "'%{public}@' task suspended: removing daemonIdentifiableClient #dic",  buf,  0xCu);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934980 != -1) {
                  dispatch_once(&qword_101934980, &stru_1018401A0);
                }
                *(_DWORD *)uint64_t v146 = 138543362;
                *(void *)&v146[4] = v78;
                LODWORD(v132) = 12;
                __int16 v92 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "'%{public}@' task suspended: removing daemonIdentifiableClient #dic",  v146,  v132);
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CLA ppMonitor_Type::NotificationData &)",  "%s\n",  v92);
              }

              int v80 = (char *)v137[1];
              if (v137[1] >= v138[0])
              {
                int64_t v82 = ((char *)v137[1] - (char *)v137[0]) >> 3;
                unint64_t v83 = ((char *)v138[0] - (char *)v137[0]) >> 2;
                if (v83 <= v82 + 1) {
                  unint64_t v83 = v82 + 1;
                }
                else {
                  unint64_t v84 = v83;
                }
                if (v84) {
                  __int16 v85 = (char *)sub_1000071BC((uint64_t)v138, v84);
                }
                else {
                  __int16 v85 = 0LL;
                }
                std::string::size_type v86 = (CLConnection **)&v85[8 * v82];
                *std::string::size_type v86 = v77;
                int v81 = v86 + 1;
                BOOL v88 = (char *)v137[0];
                BOOL v87 = (char *)v137[1];
                if (v137[1] != v137[0])
                {
                  do
                  {
                    __int16 v89 = (CLConnection *)*((void *)v87 - 1);
                    v87 -= 8;
                    *--std::string::size_type v86 = v89;
                  }

                  while (v87 != v88);
                  BOOL v87 = (char *)v137[0];
                }

                v137[0] = v86;
                v137[1] = v81;
                v138[0] = &v85[8 * v84];
                if (v87) {
                  operator delete(v87);
                }
              }

              else
              {
                *(void *)v137[1] = v77;
                int v81 = v80 + 8;
              }

              v137[1] = v81;
            }

            __int16 v90 = (void *)v75[1];
            if (v90)
            {
              do
              {
                unint64_t v91 = v90;
                __int16 v90 = (void *)*v90;
              }

              while (v90);
            }

            else
            {
              do
              {
                unint64_t v91 = (void *)v75[2];
                BOOL v123 = *v91 == (void)v75;
                __int16 v75 = v91;
              }

              while (!v123);
            }

            __int16 v75 = v91;
          }

          while (v91 != (void *)(a1 + 832));
        }

        int v93 = (CLConnection **)v137[0];
        if (v137[0] != v137[1])
        {
          do
            sub_1005456DC(a1, *v93++);
          while (v93 != v137[1]);
          int v93 = (CLConnection **)v137[0];
        }

        if (v93)
        {
          v137[1] = v93;
          operator delete(v93);
        }

        int v29 = *a3;
      }

      if (v29 == 1 && -[CLClientKeyPath isValidCKP](v9, "isValidCKP"))
      {
        __int16 v94 = *(void **)(a1 + 848);
        uint64_t v95 = (void *)(a1 + 856);
        if (v94 != (void *)(a1 + 856))
        {
          do
          {
            uint64_t v96 = v94[4];
            if ([(id)sub_100019240(v96) isEqual:v9])
            {
              id v97 = [(id)sub_100019240(v96) clientKey];
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              id v98 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)std::string buf = 68289538;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)&uint8_t buf[8] = 2082;
                *(void *)&buf[10] = "";
                *(_WORD *)&_BYTE buf[18] = 2114;
                *(void *)&buf[20] = v97;
                *(_WORD *)&_BYTE buf[28] = 2050;
                *(void *)&buf[30] = v96;
                _os_log_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#dic cancelRetirement due to termination before actual dic death, ClientKey :%{public, location:escape_only}@, this:%{public}p}",  buf,  0x26u);
              }

              sub_100D56EEC(v96);
            }

            id v99 = (void *)v94[1];
            if (v99)
            {
              do
              {
                unint64_t v100 = v99;
                id v99 = (void *)*v99;
              }

              while (v99);
            }

            else
            {
              do
              {
                unint64_t v100 = (void *)v94[2];
                BOOL v123 = *v100 == (void)v94;
                __int16 v94 = v100;
              }

              while (!v123);
            }

            __int16 v94 = v100;
          }

          while (v100 != v95);
        }

        if (*(_BYTE *)(a4 + 104))
        {
          id v101 = *(void **)(a1 + 824);
          if (v101 != (void *)(a1 + 832))
          {
            do
            {
              uint64_t v102 = v101[5];
              if ((*(unsigned int (**)(uint64_t))(*(void *)v102 + 24LL))(v102) == 3
                && [(id)sub_100019240(v102) isEqual:v9])
              {
                id v103 = [(id)sub_100019240(v102) clientKey];
                if (qword_101934980 != -1) {
                  dispatch_once(&qword_101934980, &stru_1018401A0);
                }
                unint64_t v104 = (os_log_s *)qword_101934988;
                if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)std::string buf = 68289538;
                  *(_DWORD *)&uint8_t buf[4] = 0;
                  *(_WORD *)&uint8_t buf[8] = 2082;
                  *(void *)&buf[10] = "";
                  *(_WORD *)&_BYTE buf[18] = 2114;
                  *(void *)&buf[20] = v103;
                  *(_WORD *)&_BYTE buf[28] = 2050;
                  *(void *)&buf[30] = v102;
                  _os_log_impl( (void *)&_mh_execute_header,  v104,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#dic #bas marking eligible for destructionUponDisconnection due to UserTermin ation, ClientKeyPath:%{public, location:escape_only}@, this:%{public}p}",  buf,  0x26u);
                }

                sub_100D56894(v102);
              }

              __int128 v105 = (void *)v101[1];
              if (v105)
              {
                do
                {
                  __int16 v106 = v105;
                  __int128 v105 = (void *)*v105;
                }

                while (v105);
              }

              else
              {
                do
                {
                  __int16 v106 = (void *)v101[2];
                  BOOL v123 = *v106 == (void)v101;
                  id v101 = v106;
                }

                while (!v123);
              }

              id v101 = v106;
            }

            while (v106 != (void *)(a1 + 832));
          }

          memset(buf, 0, 24);
          uint64_t v107 = *(void **)(a1 + 848);
          if (v107 != v95)
          {
            do
            {
              uint64_t v108 = v107[4];
              if ((*(unsigned int (**)(uint64_t))(*(void *)v108 + 24LL))(v108) == 3
                && [(id)sub_100019240(v108) isEqual:v9])
              {
                uint64_t v109 = *(void *)&buf[8];
                if (*(void *)&buf[8] >= *(void *)&buf[16])
                {
                  uint64_t v111 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3;
                  unint64_t v112 = (uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 2;
                  if (v112 <= v111 + 1) {
                    unint64_t v112 = v111 + 1;
                  }
                  if (*(void *)&buf[16] - *(void *)buf >= 0x7FFFFFFFFFFFFFF8uLL) {
                    unint64_t v113 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v113 = v112;
                  }
                  if (v113) {
                    __int16 v114 = (char *)sub_1000071BC((uint64_t)&buf[16], v113);
                  }
                  else {
                    __int16 v114 = 0LL;
                  }
                  uint64_t v115 = (uint64_t *)&v114[8 * v111];
                  *uint64_t v115 = v108;
                  unint64_t v110 = v115 + 1;
                  __int128 v117 = *(char **)buf;
                  unint64_t v116 = *(char **)&buf[8];
                  if (*(void *)&buf[8] != *(void *)buf)
                  {
                    do
                    {
                      uint64_t v118 = *((void *)v116 - 1);
                      v116 -= 8;
                      *--uint64_t v115 = v118;
                    }

                    while (v116 != v117);
                    unint64_t v116 = *(char **)buf;
                  }

                  *(void *)std::string buf = v115;
                  *(void *)&uint8_t buf[8] = v110;
                  *(void *)&uint8_t buf[16] = &v114[8 * v113];
                  if (v116) {
                    operator delete(v116);
                  }
                }

                else
                {
                  **(void **)&uint8_t buf[8] = v108;
                  unint64_t v110 = (void *)(v109 + 8);
                }

                *(void *)&uint8_t buf[8] = v110;
              }

              uint64_t v119 = (void *)v107[1];
              if (v119)
              {
                do
                {
                  unint64_t v120 = v119;
                  uint64_t v119 = (void *)*v119;
                }

                while (v119);
              }

              else
              {
                do
                {
                  unint64_t v120 = (void *)v107[2];
                  BOOL v123 = *v120 == (void)v107;
                  uint64_t v107 = v120;
                }

                while (!v123);
              }

              uint64_t v107 = v120;
            }

            while (v120 != v95);
            uint64_t v121 = *(unint64_t **)buf;
            unint64_t v122 = *(unint64_t **)&buf[8];
            if (*(void *)buf != *(void *)&buf[8])
            {
              do
                sub_100559024(a1, *v121++);
              while (v121 != v122);
              unint64_t v122 = *(unint64_t **)buf;
            }

            if (v122)
            {
              *(void *)&uint8_t buf[8] = v122;
              operator delete(v122);
            }
          }
        }
      }

      BOOL v123 = *v135 > 6 || ((1 << *v135) & 0x58) == 0;
      if (!v123)
      {
        int v124 = *(void **)(a1 + 848);
        if (v124 != (void *)(a1 + 856))
        {
          do
          {
            uint64_t v125 = v124[4];
            if ([(id)sub_100019240(v125) isEqual:v9])
            {
              id v126 = [(id)sub_100019240(v125) clientKey];
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_1018401A0);
              }
              uint64_t v127 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)std::string buf = 68289538;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)&uint8_t buf[8] = 2082;
                *(void *)&buf[10] = "";
                *(_WORD *)&_BYTE buf[18] = 2114;
                *(void *)&buf[20] = v126;
                *(_WORD *)&_BYTE buf[28] = 2050;
                *(void *)&buf[30] = v125;
                _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#dic triggerRetirement, ClientKey:%{public, location:escape_only}@, thi s:%{public}p}",  buf,  0x26u);
              }

              sub_100D56908(v125);
            }

            std::string::size_type v128 = (void *)v124[1];
            if (v128)
            {
              do
              {
                uint64_t v129 = v128;
                std::string::size_type v128 = (void *)*v128;
              }

              while (v128);
            }

            else
            {
              do
              {
                uint64_t v129 = (void *)v124[2];
                BOOL v123 = *v129 == (void)v124;
                int v124 = v129;
              }

              while (!v123);
            }

            int v124 = v129;
          }

          while (v129 != (void *)(a1 + 856));
        }
      }

      if (!-[CLClientKeyPath isValidCKP](v9, "isValidCKP"))
      {
        memset(buf, 0, 41);
        [*(id *)(a1 + 136) expensivelyGetIdentifyingInformation:buf forClient:v134];
        BOOL v9 = +[CLClientKeyPath clientKeyPathWithClientAnchor:anchorType:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithClientAnchor:anchorType:",  *(void *)buf,  105LL);
      }

      sub_1008FDFA4(*(void **)(a1 + 376), a2, v135, (int *)a4, v9);
      if (*v135 == 4 && *(_BYTE *)(a1 + 995))
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        int v130 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v130,  OS_LOG_TYPE_INFO,  "Trial period #reprompt disarmed by foregrounded app",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          LOWORD(v137[0]) = 0;
          LODWORD(v132) = 2;
          v131 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "Trial period #reprompt disarmed by foregrounded app",  v137,  v132);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CLAppMoni tor_Type::NotificationData &)",  "%s\n",  v131);
        }

        *(_BYTE *)(a1 + 995) = 0;
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    BOOL v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      char v11 = sub_100D943B0(a3);
      uint64_t v14 = *(void *)(a4 + 80);
      uint64_t v13 = a4 + 80;
      uint64_t v12 = v14;
      else {
        uint64_t v15 = *(void *)(v13 - 72);
      }
      else {
        uint64_t v16 = *(void *)(v13 - 24);
      }
      *(_DWORD *)std::string buf = 68290050;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = v11;
      *(_WORD *)&_BYTE buf[28] = 2082;
      *(void *)&buf[30] = v15;
      *(_WORD *)&_BYTE buf[38] = 2082;
      *(void *)&uint8_t buf[40] = v16;
      *(_WORD *)&_BYTE buf[48] = 2082;
      *(void *)&buf[50] = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:AppMonitor - application (un)installation notification, notification:%{public, loca tion:escape_only}s, BundleId:%{public, location:escape_only}s, BundlePath:%{public, location:escape_only }s, ExecutablePath:%{public, location:escape_only}s}",  buf,  0x3Au);
    }

    if (*a3 == 10)
    {
      if (-[CLClientKeyPath isValidCKP](v9, "isValidCKP"))
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        __int16 v17 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 68289282;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&_BYTE buf[18] = 2114;
          *(void *)&buf[20] = v9;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Reregistering client key path due to app update, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
        }

        [*(id *)(a1 + 136) registerClient:v9 fromAuthSync:0];
      }
    }

    else
    {
      sub_1010DDBC0(__p, "ClientRemoved");
      sub_10054BFD4(a1, v9, 1, (uint64_t *)__p);
      if (v145 < 0) {
        operator delete(__p[0]);
      }
      memset(buf, 0, 99);
      __int128 v151 = 0u;
      memset(v152, 0, 59);
      if (v134)
      {
        -[CLClientKeyPath clientName](v134, "clientName");
      }

      else
      {
        uint64_t v143 = 0LL;
        memset(v142, 0, sizeof(v142));
        *(_OWORD *)std::string::size_type v141 = 0uLL;
        *(_OWORD *)uint64_t v139 = 0uLL;
        memset(v140, 0, sizeof(v140));
        memset(v138, 0, sizeof(v138));
        *(_OWORD *)std::string::size_type v137 = 0uLL;
      }

      *(_OWORD *)std::string buf = *(_OWORD *)v137;
      *(void **)&uint8_t buf[16] = v138[0];
      HIBYTE(v138[0]) = 0;
      LOBYTE(v137[0]) = 0;
      *(_OWORD *)&buf[24] = *(_OWORD *)&v138[1];
      *(void **)&uint8_t buf[40] = v138[3];
      HIBYTE(v138[3]) = 0;
      LOBYTE(v138[1]) = 0;
      *(_OWORD *)&_BYTE buf[48] = *(_OWORD *)v139;
      *(void **)&_BYTE buf[64] = v140[0];
      HIBYTE(v140[0]) = 0;
      LOBYTE(v139[0]) = 0;
      *(_OWORD *)&buf[72] = *(_OWORD *)&v140[1];
      *(void **)&buf[88] = v140[3];
      HIBYTE(v140[3]) = 0;
      LOBYTE(v140[1]) = 0;
      *(_WORD *)&buf[96] = v140[4];
      buf[98] = BYTE2(v140[4]);
      if (SBYTE7(v152[0]) < 0) {
        operator delete((void *)v151);
      }
      __int128 v151 = *(_OWORD *)&v140[5];
      *(void **)&v152[0] = v140[7];
      HIBYTE(v140[7]) = 0;
      LOBYTE(v140[5]) = 0;
      if (SHIBYTE(v152[1]) < 0) {
        operator delete(*((void **)&v152[0] + 1));
      }
      *(_OWORD *)((char *)v152 + _Block_object_dispose(va, 8) = *(_OWORD *)v141;
      *((void *)&v152[1] + 1) = *(void *)&v142[0];
      BYTE7(v142[0]) = 0;
      LOBYTE(v141[0]) = 0;
      if (SBYTE7(v152[3]) < 0) {
        operator delete(*(void **)&v152[2]);
      }
      v152[2] = *(_OWORD *)((char *)v142 + 8);
      *(void *)&v152[3] = *((void *)&v142[1] + 1);
      HIBYTE(v142[1]) = 0;
      BYTE8(v142[0]) = 0;
      WORD4(v152[3]) = v143;
      BYTE10(v152[3]) = BYTE2(v143);
      if (SHIBYTE(v140[7]) < 0) {
        operator delete(v140[5]);
      }
      if (SHIBYTE(v140[3]) < 0) {
        operator delete(v140[1]);
      }
      if (SHIBYTE(v140[0]) < 0) {
        operator delete(v139[0]);
      }
      if (SHIBYTE(v138[3]) < 0) {
        operator delete(v138[1]);
      }
      if (SHIBYTE(v138[0]) < 0) {
        operator delete(v137[0]);
      }
      LODWORD(v137[0]) = 1;
      (*(void (**)(uint64_t, void **, uint8_t *, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  v137,  buf,  0LL,  0xFFFFFFFFLL,  0LL);
      if (SBYTE7(v152[3]) < 0) {
        operator delete(*(void **)&v152[2]);
      }
      if (SHIBYTE(v152[1]) < 0) {
        operator delete(*((void **)&v152[0] + 1));
      }
      if (SBYTE7(v152[0]) < 0) {
        operator delete((void *)v151);
      }
    }
  }

void sub_100580A70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, int a42, __int16 a43, char a44, char a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100580B14(uint64_t result, uint64_t a2, _DWORD *a3, unsigned __int8 *a4)
{
  if (*a3 == 8)
  {
    uint64_t v4 = result;
    int v5 = *a4;
    *(_BYTE *)(result + 992) = v5;
    if (!v5)
    {
      for (unsigned int i = *(double **)(result + 968); i != *(double **)(v4 + 976); i += 4)
      {
        double Current = CFAbsoluteTimeGetCurrent();
        id result = sub_1005759B8(i, Current);
      }
    }
  }

  return result;
}

void sub_100580B6C(uint64_t a1, uint64_t a2, _DWORD *a3, unsigned __int8 *a4)
{
  if (*a3 == 1)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *a4;
      int v11 = 68289282;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 1026;
      int v16 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:wifi power state, power:%{public}d}",  (uint8_t *)&v11,  0x18u);
    }

    int v8 = *a4;
    *(_BYTE *)(a1 + 993) = v8 ^ 1;
    if (v8)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      BOOL v9 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        uint64_t v14 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:wifi enabled}",  (uint8_t *)&v11,  0x12u);
      }

      for (unsigned int i = *(void **)(a1 + 968); i != *(void **)(a1 + 976); i += 4)
      {
        if (!*i)
        {
          sub_100575680(i);
          return;
        }
      }
    }
  }

void sub_100580D28(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int *a4)
{
  if (sub_1004F7A04())
  {
    int v7 = *a3;
    if (*a3 == 2)
    {
      if (*a4 != 7) {
        sub_10123E844();
      }
      uint64_t v8 = 8LL;
    }

    else if (v7 == 1)
    {
      if (*a4 != 4) {
        sub_10123E81C();
      }
      uint64_t v8 = 4LL;
    }

    else
    {
      if (v7) {
        goto LABEL_15;
      }
      if (*a4 != 3) {
        sub_10123E7F4();
      }
      uint64_t v8 = 2LL;
    }

    if (*((_BYTE *)a4 + 4)) {
      unint64_t v9 = *(void *)(a1 + 424) | v8;
    }
    else {
      unint64_t v9 = *(void *)(a1 + 424) & ~v8;
    }
    *(void *)(a1 + 424) = v9;
    BOOL v10 = *(void **)(a1 + 400);
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 3221225472LL;
    _OWORD v27[2] = sub_1005811A4;
    v27[3] = &unk_101840098;
    v27[4] = (v9 >> 2) & 2 | v9;
    void v27[5] = v8;
    [v10 updateVolatileData:v27 completion:0];
  }

void sub_100581178( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

id sub_1005811A4(uint64_t a1, void *a2, void *a3)
{
  return [a3 setUserInitiated:*(void *)(a1 + 40) == 2];
}

NSDictionary *sub_1005811E0(uint64_t a1, uint64_t a2)
{
  id result = +[NSDictionary dictionary](&OBJC_CLASS___NSDictionary, "dictionary");
  int v5 = *(uint64_t **)(a2 + 16);
  if (v5)
  {
    int v6 = result;
    do
    {
      int v7 = v5 + 2;
      id result = (NSDictionary *)objc_msgSend( *(id *)(a1 + 1464),  "client:didChangeUsageData:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7),  v6);
      int v5 = (uint64_t *)*v5;
    }

    while (v5);
  }

  return result;
}

id sub_100581260(id result, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a2 + 16);
  if (v2)
  {
    uint64_t v3 = (uint64_t)result;
    do
    {
      uint64_t v4 = (uint64_t)(v2 + 2);
      id result = objc_msgSend( *(id *)(v3 + 1464),  "client:didChangeUsageData:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v4),  sub_10056C388(v3, v2 + 2));
      uint64_t v2 = (uint64_t *)*v2;
    }

    while (v2);
  }

  return result;
}

void sub_1005812E0(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 9)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      int v7 = *(unsigned __int8 *)(a4 + 113);
      int v11 = 68289282;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 1026;
      int v16 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:bluetooth power state, power:%{public}d}",  (uint8_t *)&v11,  0x18u);
    }

    int v8 = *(unsigned __int8 *)(a4 + 113);
    *(_BYTE *)(a1 + 994) = v8 ^ 1;
    if (v8)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      unint64_t v9 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        uint64_t v14 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:bluetooth enabled}",  (uint8_t *)&v11,  0x12u);
      }

      for (unsigned int i = *(void **)(a1 + 968); i != *(void **)(a1 + 976); i += 4)
      {
        if (*i == 1LL)
        {
          sub_100575680(i);
          return;
        }
      }
    }
  }

id sub_1005814A0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(void **)(v4 + 136);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  _DWORD v7[2] = sub_100581564;
  v7[3] = &unk_10183F900;
  v7[4] = v4;
  id result = [v5 iterateIdentitiesRelatedToKeyPath:a2 withBlock:v7];
  if (*(_BYTE *)(a1 + 40))
  {
    id result = [*(id *)(v4 + 136) isKeyPathRegisteredSystemService:a2];
    if ((_DWORD)result)
    {
      id result = [*(id *)(v4 + 136) intForKey:@"Authorization" atKeyPath:a2 defaultValue:0];
      if ((_DWORD)result == 4) {
        return [*(id *)(v4 + 136) removeValueForKey:@"Authorization" atKeyPath:a2];
      }
    }
  }

  return result;
}

id sub_100581564(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  sub_10057CF50(v3, a2);
  return sub_10057D090(v3, a2);
}

_OWORD *sub_100581594@<X0>(__int128 *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x50uLL);
  id result = sub_1008FDB14(v4, a1);
  *a2 = v4;
  return result;
}

void sub_1005815D4(_Unwind_Exception *a1)
{
}

id sub_1005815E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  id v3 = *(id *)(a1 + 32);
  id result = [*(id *)(v2 + 512) objectForKeyedSubscript:*(void *)(a1 + 40)];
  if (v3 == result)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 40);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v15 = 2082;
      int v16 = "";
      __int16 v17 = 2114;
      uint64_t v18 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#TemporaryAuth setTemporaryAuthorizationStatusInfoForClient releasing in use assertion, Client:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    if (*(_BYTE *)(a1 + 64))
    {
      int v7 = (char *)objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "legacyClientKey"), "UTF8String");
      if (v7) {
        int v8 = v7;
      }
      else {
        int v8 = "";
      }
      sub_1010DDBC0(__p, v8);
      sub_10054D7E0(v2, (uint64_t *)__p);
      if (v13 < 0) {
        operator delete(__p[0]);
      }
      [*(id *)(v2 + 520) removeObjectForKey:*(void *)(a1 + 48)];
      sub_10054D6C8();
    }

    sub_1010DDBC0(buf, (char *)[*(id *)(a1 + 48) UTF8String]);
    sub_10058A7BC((uint64_t **)(v2 + 528), (const void **)buf);
    if (SBYTE3(v18) < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v10 = *(void *)(a1 + 40);
    unint64_t v9 = (void *)(a1 + 40);
    objc_msgSend(objc_msgSend(*(id *)(v2 + 512), "objectForKeyedSubscript:", v10), "invalidate");
    int v11 = (id *)(v2 + 512);

    return [*v11 setObject:0 forKeyedSubscript:*v9];
  }

  return result;
}

void sub_1005817A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005817E0(uint64_t a1, xpc_activity_t activity)
{
  xpc_activity_state_t state = xpc_activity_get_state(activity);
  if (state)
  {
    if (state == 2)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v4 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "coreanalytics activity run", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        v8[0] = 0;
        uint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "coreanalytics activity run",  v8,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::registerAnalyticsCollectActivity()_block_invoke",  "%s\n",  v6);
      }

      [*(id *)(a1 + 32) triggerAnalyticsCollect];
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    int v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "coreanalytics activity check-in", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      v8[0] = 0;
      int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "coreanalytics activity check-in",  v8,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLClientManager::registerAnalyticsCollectActivity()_block_invoke",  "%s\n",  v7);
    }
  }

BOOL sub_100581AC0(void *a1)
{
  id v2 = [a1 objectForKeyedSubscript:@"Type"];
  if (v2)
  {
    id v3 = v2;
    objc_opt_class(&OBJC_CLASS___NSNumber);
    if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
    {
      if ([a1 objectForKeyedSubscript:@"ServiceMaskOperator"])
      {
        id v5 = [a1 objectForKeyedSubscript:@"ServiceMaskOperator"];
        if (!v5 || (id v6 = v5, objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v6, v7) & 1) == 0))
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          int v29 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
          {
            int v43 = 68289538;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)[@"ServiceMaskOperator" UTF8String];
            __int16 v49 = 2114;
            uint64_t v50 = a1;
            _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{publ ic, location:escape_only}@}",  (uint8_t *)&v43,  0x26u);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
          }

          uint64_t v30 = qword_101934988;
          BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
          if (result)
          {
            id v31 = [@"ServiceMaskOperator" UTF8String];
            int v43 = 68289538;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)v31;
            __int16 v49 = 2114;
            uint64_t v50 = a1;
            unsigned __int8 v23 = "invalid zone config";
            int v24 = "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{"
                  "public, location:escape_only}@}";
            int v27 = (os_log_s *)v30;
            goto LABEL_29;
          }

          return result;
        }
      }

      unsigned int v8 = objc_msgSend(objc_msgSend(a1, "objectForKeyedSubscript:", @"Type"), "intValue");
      if (v8 == 2)
      {
        id v32 = [a1 objectForKeyedSubscript:@"PhenolicLocation"];
        if (!v32 || (id v33 = v32, objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v33, v34) & 1) == 0))
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          int v39 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
          {
            int v43 = 68289538;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)[@"PhenolicLocation" UTF8String];
            __int16 v49 = 2114;
            uint64_t v50 = a1;
            _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{publ ic, location:escape_only}@}",  (uint8_t *)&v43,  0x26u);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
          }

          uint64_t v20 = qword_101934988;
          BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
          if (result)
          {
            id v40 = [@"PhenolicLocation" UTF8String];
            int v43 = 68289538;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)v40;
            __int16 v49 = 2114;
            uint64_t v50 = a1;
            unsigned __int8 v23 = "invalid zone config";
            int v24 = "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{"
                  "public, location:escape_only}@}";
            goto LABEL_28;
          }

          return result;
        }
      }

      else
      {
        unsigned int v9 = v8;
        if (v8 != 1)
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          __int16 v35 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
          {
            int v43 = 68289282;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2050;
            unint64_t v48 = v9;
            _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:value-type validation of Info.plist zone received un-recongnised zone type, Zon eType:%{public, location:CLClientInterestZoneType}lld}",  (uint8_t *)&v43,  0x1Cu);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
          }

          uint64_t v36 = qword_101934988;
          BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
          if (result)
          {
            int v43 = 68289282;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2050;
            unint64_t v48 = v9;
            unsigned __int8 v23 = "value-type validation of Info.plist zone received un-recongnised zone type";
            int v24 = "{msg%{public}.0s:value-type validation of Info.plist zone received un-recongnised zone type, "
                  "ZoneType:%{public, location:CLClientInterestZoneType}lld}";
            int v27 = (os_log_s *)v36;
            uint32_t v28 = 28;
            goto LABEL_30;
          }

          return result;
        }

        id v10 = [a1 objectForKeyedSubscript:@"Latitude"];
        if (!v10 || (id v11 = v10, objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v11, v12) & 1) == 0))
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          __int16 v37 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
          {
            int v43 = 68289538;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)[@"Latitude" UTF8String];
            __int16 v49 = 2114;
            uint64_t v50 = a1;
            _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{publ ic, location:escape_only}@}",  (uint8_t *)&v43,  0x26u);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
          }

          uint64_t v20 = qword_101934988;
          BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
          if (result)
          {
            id v38 = [@"Latitude" UTF8String];
            int v43 = 68289538;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)v38;
            __int16 v49 = 2114;
            uint64_t v50 = a1;
            unsigned __int8 v23 = "invalid zone config";
            int v24 = "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{"
                  "public, location:escape_only}@}";
            goto LABEL_28;
          }

          return result;
        }

        id v13 = [a1 objectForKeyedSubscript:@"Longitude"];
        if (!v13 || (id v14 = v13, objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v14, v15) & 1) == 0))
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          int v41 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
          {
            int v43 = 68289538;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)[@"Longitude" UTF8String];
            __int16 v49 = 2114;
            uint64_t v50 = a1;
            _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{publ ic, location:escape_only}@}",  (uint8_t *)&v43,  0x26u);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
          }

          uint64_t v20 = qword_101934988;
          BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
          if (result)
          {
            id v42 = [@"Longitude" UTF8String];
            int v43 = 68289538;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)v42;
            __int16 v49 = 2114;
            uint64_t v50 = a1;
            unsigned __int8 v23 = "invalid zone config";
            int v24 = "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{"
                  "public, location:escape_only}@}";
            goto LABEL_28;
          }

          return result;
        }

        id v16 = [a1 objectForKeyedSubscript:@"Radius"];
        if (!v16 || (id v17 = v16, objc_opt_class(&OBJC_CLASS___NSNumber), (objc_opt_isKindOfClass(v17, v18) & 1) == 0))
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_1018401A0);
          }
          uint64_t v19 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
          {
            int v43 = 68289538;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)[@"Radius" UTF8String];
            __int16 v49 = 2114;
            uint64_t v50 = a1;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{publ ic, location:escape_only}@}",  (uint8_t *)&v43,  0x26u);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
          }

          uint64_t v20 = qword_101934988;
          BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
          if (result)
          {
            id v22 = [@"Radius" UTF8String];
            int v43 = 68289538;
            int v44 = 0;
            __int16 v45 = 2082;
            uint64_t v46 = "";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)v22;
            __int16 v49 = 2114;
            uint64_t v50 = a1;
            unsigned __int8 v23 = "invalid zone config";
            int v24 = "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{"
                  "public, location:escape_only}@}";
LABEL_28:
            int v27 = (os_log_s *)v20;
LABEL_29:
            uint32_t v28 = 38;
LABEL_30:
            _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v27,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v23,  v24,  (uint8_t *)&v43,  v28);
            return 0LL;
          }

          return result;
        }
      }

      return 1LL;
    }
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v25 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
  {
    int v43 = 68289538;
    int v44 = 0;
    __int16 v45 = 2082;
    uint64_t v46 = "";
    __int16 v47 = 2082;
    unint64_t v48 = (unint64_t)[@"Type" UTF8String];
    __int16 v49 = 2114;
    uint64_t v50 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{public, loca tion:escape_only}@}",  (uint8_t *)&v43,  0x26u);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
  }

  uint64_t v20 = qword_101934988;
  BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
  if (result)
  {
    id v26 = [@"Type" UTF8String];
    int v43 = 68289538;
    int v44 = 0;
    __int16 v45 = 2082;
    uint64_t v46 = "";
    __int16 v47 = 2082;
    unint64_t v48 = (unint64_t)v26;
    __int16 v49 = 2114;
    uint64_t v50 = a1;
    unsigned __int8 v23 = "invalid zone config";
    int v24 = "{msg%{public}.0s:invalid zone config, ForKey:%{public, location:escape_only}s, Zone:%{public, "
          "location:escape_only}@}";
    goto LABEL_28;
  }

  return result;
}

uint64_t sub_100582538(void *a1, void *a2)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  uint64_t v4 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    v38[0] = 68289538;
    v38[1] = 0;
    __int16 v39 = 2082;
    id v40 = "";
    __int16 v41 = 2114;
    id v42 = a1;
    __int16 v43 = 2114;
    int v44 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:check #pla zones are identical, Zone1:%{public, location:escape_only}@, Zone2:%{p ublic, location:escape_only}@}",  (uint8_t *)v38,  0x26u);
  }

  id v5 = (_UNKNOWN **)[a1 objectForKeyedSubscript:@"Type"];
  if (v5) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = @"ServiceMaskOperator" != @"Type";
  }
  if (v6) {
    uint64_t v7 = v5;
  }
  else {
    uint64_t v7 = &off_1018D3560;
  }
  unsigned int v8 = (_UNKNOWN **)[a2 objectForKeyedSubscript:@"Type"];
  if (v8) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = @"ServiceMaskOperator" != @"Type";
  }
  if (v9) {
    id v10 = v8;
  }
  else {
    id v10 = &off_1018D3560;
  }
  unsigned int v11 = [v7 isEqual:v10];
  uint64_t v12 = (_UNKNOWN **)[a1 objectForKeyedSubscript:@"Latitude"];
  if (v12) {
    BOOL v13 = 1;
  }
  else {
    BOOL v13 = @"ServiceMaskOperator" != @"Latitude";
  }
  if (v13) {
    id v14 = v12;
  }
  else {
    id v14 = &off_1018D3560;
  }
  uint64_t v15 = (_UNKNOWN **)[a2 objectForKeyedSubscript:@"Latitude"];
  if (v15) {
    BOOL v16 = 1;
  }
  else {
    BOOL v16 = @"ServiceMaskOperator" != @"Latitude";
  }
  if (v16) {
    id v17 = v15;
  }
  else {
    id v17 = &off_1018D3560;
  }
  unsigned int v18 = [v14 isEqual:v17];
  uint64_t v19 = (_UNKNOWN **)[a1 objectForKeyedSubscript:@"Longitude"];
  if (v19) {
    BOOL v20 = 1;
  }
  else {
    BOOL v20 = @"ServiceMaskOperator" != @"Longitude";
  }
  if (v20) {
    uint64_t v21 = v19;
  }
  else {
    uint64_t v21 = &off_1018D3560;
  }
  id v22 = (_UNKNOWN **)[a2 objectForKeyedSubscript:@"Longitude"];
  if (v22) {
    BOOL v23 = 1;
  }
  else {
    BOOL v23 = @"ServiceMaskOperator" != @"Longitude";
  }
  if (v23) {
    int v24 = v22;
  }
  else {
    int v24 = &off_1018D3560;
  }
  unsigned int v25 = [v21 isEqual:v24];
  id v26 = (_UNKNOWN **)[a1 objectForKeyedSubscript:@"Radius"];
  if (v26) {
    BOOL v27 = 1;
  }
  else {
    BOOL v27 = @"ServiceMaskOperator" != @"Radius";
  }
  if (v27) {
    uint32_t v28 = v26;
  }
  else {
    uint32_t v28 = &off_1018D3560;
  }
  int v29 = (_UNKNOWN **)[a2 objectForKeyedSubscript:@"Radius"];
  if (v29) {
    BOOL v30 = 1;
  }
  else {
    BOOL v30 = @"ServiceMaskOperator" != @"Radius";
  }
  if (v30) {
    id v31 = v29;
  }
  else {
    id v31 = &off_1018D3560;
  }
  unsigned int v32 = [v28 isEqual:v31];
  id v33 = (_UNKNOWN **)[a1 objectForKeyedSubscript:@"ServiceMaskOperator"];
  if (v33) {
    uint64_t v34 = v33;
  }
  else {
    uint64_t v34 = &off_1018D3560;
  }
  __int16 v35 = (_UNKNOWN **)[a2 objectForKeyedSubscript:@"ServiceMaskOperator"];
  if (v35) {
    uint64_t v36 = v35;
  }
  else {
    uint64_t v36 = &off_1018D3560;
  }
  return v11 & v18 & v25 & v32 & [v34 isEqual:v36];
}

void sub_1005827FC(uint64_t a1, uint64_t a2, void *a3)
{
  else {
    uint64_t v6 = *(void *)a2;
  }
  id v7 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v6)));
  id v8 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  BOOL v9 = *(void **)(a1 + 136);
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3221225472LL;
  v30[2] = sub_100582C28;
  v30[3] = &unk_1018400E8;
  int v24 = v8;
  uint64_t v25 = a1;
  v30[4] = v8;
  v30[5] = a3;
  v30[6] = a1;
  v30[7] = a2;
  [v9 iterateIdentitiesRelatedToKeyPath:v7 withBlock:v30];
  if ([a3 count])
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      else {
        uint64_t v11 = *(void *)a2;
      }
      *(_DWORD *)std::string buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v32 = 2082;
      id v33 = "";
      __int16 v34 = 2082;
      uint64_t v35 = v11;
      __int16 v36 = 2114;
      id v37 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:final info.plist zones for #pla registeration, ClientKey:%{public, location:escape_ only}s, InfoPlistZones:%{public, location:escape_only}@}",  buf,  0x26u);
    }

    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    id v12 = [a3 countByEnumeratingWithState:&v26 objects:v40 count:16];
    if (v12)
    {
      uint64_t v14 = *(void *)v27;
      *(void *)&__int128 v13 = 68289794LL;
      __int128 v23 = v13;
      do
      {
        uint64_t v15 = 0LL;
        do
        {
          if (*(void *)v27 != v14) {
            objc_enumerationMutation(a3);
          }
          BOOL v16 = *(void **)(*((void *)&v26 + 1) + 8LL * (void)v15);
          id v17 = objc_msgSend(a3, "objectForKeyedSubscript:", v16, v23);
          if (sub_100581AC0(v17))
          {
            sub_1010DDBC0(buf, (char *)[v16 UTF8String]);
            sub_10056B3F4(v25, a2, (std::string *)buf, v17, 1u, v24);
            if (SBYTE3(v35) < 0) {
              operator delete(*(void **)buf);
            }
          }

          else
          {
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_1018401A0);
            }
            unsigned int v18 = (os_log_s *)qword_101934988;
            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
            {
              else {
                uint64_t v19 = *(void *)a2;
              }
              id v20 = [v16 UTF8String];
              *(_DWORD *)std::string buf = v23;
              *(_DWORD *)&uint8_t buf[4] = 0;
              __int16 v32 = 2082;
              id v33 = "";
              __int16 v34 = 2082;
              uint64_t v35 = v19;
              __int16 v36 = 2082;
              id v37 = v20;
              __int16 v38 = 2114;
              id v39 = v17;
              _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#warning Info.plist zone registration failed. Invalid zone., ClientKey:%{pu blic, location:escape_only}s, ZoneId:%{public, location:escape_only}s, Info.PlistZone:%{public, location:escape_only}@}",  buf,  0x30u);
            }
          }

          uint64_t v15 = (char *)v15 + 1;
        }

        while (v12 != v15);
        id v12 = [a3 countByEnumeratingWithState:&v26 objects:v40 count:16];
      }

      while (v12);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v21 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      else {
        uint64_t v22 = *(void *)a2;
      }
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v32 = 2082;
      id v33 = "";
      __int16 v34 = 2082;
      uint64_t v35 = v22;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#pla no-eligible info-plist zones for registeration, ClientKey:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }
  }

void sub_100582C04( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *__p, uint64_t a30, int a31, __int16 a32, char a33, char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100582C28(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  id v5 = [a2 zoneId];
  id v6 = objc_msgSend(objc_msgSend(*(id *)(v4 + 136), "readonlyStoreAtKeyPath:", a2), "dictionary");
  unsigned int v7 = [*(id *)(v4 + 136) intForKey:@"Provenance" atKeyPath:a2 defaultValue:0];
  if (v7 != 1)
  {
    if (v7 == 2) {
      [*(id *)(a1 + 32) setObject:v6 forKeyedSubscript:a2];
    }
    return;
  }

  id v8 = [*(id *)(a1 + 40) objectForKeyedSubscript:v5];
  if (v8)
  {
    if (sub_100582538(v8, v6))
    {
      [*(id *)(a1 + 40) removeObjectForKey:v5];
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      BOOL v9 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        std::string __p = (void *)68289282;
        __int16 v14 = 2082;
        uint64_t v15 = "";
        __int16 v16 = 2082;
        id v17 = [v5 UTF8String];
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Zone unchanged. Remove from infoPlistZones. Will skip registration, ZoneId:%{publ ic, location:escape_only}s}",  (uint8_t *)&__p,  0x1Cu);
      }

      return;
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v11 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      std::string __p = (void *)68289282;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      id v17 = [v5 UTF8String];
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Zone has been updated. Delete from clients.plist first. Will be re-registered, ZoneId :%{public, location:escape_only}s}",  (uint8_t *)&__p,  0x1Cu);
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    id v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      std::string __p = (void *)68289282;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      id v17 = [v5 UTF8String];
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:ClientsPlistZone is stale. Not found in Info.plist. Delete, ZoneId:%{public, locati on:escape_only}s}",  (uint8_t *)&__p,  0x1Cu);
    }
  }

  id v12 = *(char **)(a1 + 56);
  sub_1010DDBC0(&__p, (char *)[v5 UTF8String]);
  sub_100572A20(v4, v12, (char *)&__p, 0LL);
  if (SBYTE3(v17) < 0) {
    operator delete(__p);
  }
}

void sub_100582F88( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100582FB0(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  [*(id *)(v5 + 136) migrateDictionaryAtKeyPath:a2 toKeyPath:a3 forceMigrationOnAuthCollision:1];
  sub_1010DDBC0(__p, "ClientRemoved");
  sub_10054BFD4(v5, a2, 1, (uint64_t *)__p);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  [*(id *)(v5 + 136) setInt:1 forKey:@"Provenance" atKeyPath:a3];
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
  {
    id v7 = [a2 legacyClientKey];
    id v8 = [a3 legacyClientKey];
    *(_DWORD *)std::string buf = 138412546;
    id v21 = v7;
    __int16 v22 = 2112;
    id v23 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "#pla #reconcile SyncedInfoPlistZone:%@ collapsed to :%@",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v9 = qword_101934988;
    id v10 = [a2 legacyClientKey];
    id v11 = [a3 legacyClientKey];
    int v16 = 138412546;
    id v17 = v10;
    __int16 v18 = 2112;
    id v19 = v11;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v9,  1LL,  "#pla #reconcile SyncedInfoPlistZone:%@ collapsed to :%@",  &v16,  22);
    __int128 v13 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLClientManager::registerAndReconcileInfoPlistZone(const std::string &, const std::string &, NSDictionary *, CLClientInterestZoneProvenanceType, NSDictionary *)_block_invoke",  "%s\n",  v12);
    if (v13 != buf) {
      free(v13);
    }
  }

void sub_100583210( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100583234(uint64_t a1, uint64_t *a2, int a3)
{
  else {
    id v6 = (uint64_t *)*a2;
  }
  id v7 = objc_msgSend( *(id *)(a1 + 136),  "registeredKeyPathForClientIdentifier:",  +[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v6)));
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_1018401A0);
  }
  id v8 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint64_t v9 = (uint64_t *)*a2;
    }
    *(_DWORD *)std::string buf = 68289538;
    int v15 = 0;
    __int16 v16 = 2082;
    id v17 = "";
    __int16 v18 = 2082;
    id v19 = v9;
    __int16 v20 = 1026;
    int v21 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#pla enforce zone-monitoring, Client:%{public, location:escape_only}s, shouldStart:%{public}hhd}",  buf,  0x22u);
  }

  id v10 = *(void **)(a1 + 136);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  int v12[2] = sub_1005833CC;
  v12[3] = &unk_101840128;
  _DWORD v12[4] = a1;
  void v12[5] = a2;
  char v13 = a3;
  return [v10 iterateIdentitiesRelatedToKeyPath:v7 withBlock:v12];
}

void sub_1005833CC(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if ([a2 subIdentityType] == 122)
  {
    id v5 = [a2 zoneId];
    id v6 = objc_msgSend(objc_msgSend(*(id *)(v4 + 136), "readonlyStoreAtKeyPath:", a2), "dictionary");
    if (objc_msgSend(objc_msgSend(v6, "objectForKeyedSubscript:", @"Provenance"), "intValue") == 1)
    {
      if (objc_msgSend(objc_msgSend(v6, "objectForKeyedSubscript:", @"Type"), "intValue") == 1)
      {
        id v7 = *(void **)(v4 + 352);
        id v8 = *(uint64_t **)(a1 + 40);
        int v9 = *((char *)v8 + 23);
        if (*(_BYTE *)(a1 + 48))
        {
          if (v9 < 0) {
            id v8 = (uint64_t *)*v8;
          }
          id v10 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v8);
          objc_msgSend(objc_msgSend(v6, "objectForKeyedSubscript:", @"Latitude"), "doubleValue");
          double v12 = v11;
          objc_msgSend(objc_msgSend(v6, "objectForKeyedSubscript:", @"Longitude"), "doubleValue");
          double v14 = v13;
          objc_msgSend(objc_msgSend(v6, "objectForKeyedSubscript:", @"Radius"), "doubleValue");
          _[v7 startCircularZoneMonitoringForClient:v10 withZoneId:v5 latitude:v12 longitude:v14 radius:v17];
        }

        else
        {
          if (v9 < 0) {
            id v8 = (uint64_t *)*v8;
          }
          objc_msgSend( v7,  "stopCircularZoneMonitoringForClient:withZoneId:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v8),  v5);
        }
      }
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      int v15 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v16 = *(uint64_t **)(a1 + 40);
        v18[0] = 68289794;
        v18[1] = 0;
        __int16 v19 = 2082;
        __int16 v20 = "";
        __int16 v21 = 2082;
        __int16 v22 = v16;
        __int16 v23 = 2082;
        id v24 = [v5 UTF8String];
        __int16 v25 = 2114;
        id v26 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#pla skip zone-monitoring, provenance not eligible for monitoring, Client:%{publi c, location:escape_only}s, ZoneId:%{public, location:escape_only}s, ZoneInfo:%{public, location:escape_only}@}",  (uint8_t *)v18,  0x30u);
      }
    }
  }

void sub_100583668(uint64_t a1, void *a2, int a3)
{
  id v6 = [*(id *)(a1 + 136) registeredKeyPathForClientIdentifier:a2];
  if ([v6 isValidCKP])
  {
    id v7 = *(void **)(a1 + 136);
    if (a3) {
      [v7 setBool:1 forKey:@"BackgroundLocationCapability" atKeyPath:v6];
    }
    else {
      [v7 removeValueForKey:@"BackgroundLocationCapability" atKeyPath:v6];
    }
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v12 = qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      int v13 = 68289538;
      int v14 = 0;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2114;
      id v18 = v6;
      __int16 v19 = 1026;
      int v20 = a3;
      int v9 = "{msg%{public}.0s:updated BackgroundLocationCapability, Client:%{public, location:escape_only}@, "
           "BackgroundLocationCapability:%{public}hhd}";
      id v10 = (os_log_s *)v12;
      uint32_t v11 = 34;
      goto LABEL_13;
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v8 = qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      int v13 = 68289282;
      int v14 = 0;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2114;
      id v18 = a2;
      int v9 = "{msg%{public}.0s:skip marking BackgroundLocationCapability. Client not found, Client:%{public, lo"
           "cation:escape_only}@}";
      id v10 = (os_log_s *)v8;
      uint32_t v11 = 28;
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, v9, (uint8_t *)&v13, v11);
    }
  }

void sub_100583844(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLClientManager");
  sub_1005750B0((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  *uint64_t v8 = off_10183FE60;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005838E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

void sub_10058390C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, void *a5@<X8>)
{
  char v10 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLClientManager");
  sub_1005750B0((uint64_t)v10, a1, (uint64_t *)__p, a4, a2, a3);
  void *v10 = off_10183FE60;
  *a5 = v10;
  if (v12 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005839AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

void sub_1005839D8(uint64_t a1, uint64_t a2)
{
  HIDWORD(v14) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        int v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)std::string buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v14 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101840260);
      }
      char v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        uint32_t v11 = (void *)(a1 + 8);
        *(_DWORD *)std::string buf = 136446466;
        int v20 = v11;
        __int16 v21 = 1026;
        int v22 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101840260);
        }
        char v12 = (void *)(a1 + 8);
        int v15 = 136446466;
        __int16 v16 = v12;
        __int16 v17 = 1026;
        int v18 = a2;
        LODWORD(v14) = 18;
        int v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                        &v15,
                        v14);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLCl ientManager_Type::RegInfo>::removeClient(int) [Notification_T = CLClientManager_Type::Notification, Notificati onData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientMan ager_Type::RegInfo]",  "%s\n",  v13);
      }
    }
  }

uint64_t sub_100583C4C(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  id v7 = sub_10058A814(a4);
  if (v7)
  {
    int v10 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *, id))(*(void *)a1 + 96LL))(a1, a2, &v10, v7);
  }

  else
  {
    int v9 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 88LL))(a1, a2, &v9);
  }

uint64_t sub_100583CCC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)&qword_101938840);
  if ((v3 & 1) == 0)
  {
    uint64_t v9 = a1;
    uint64_t v8 = a3;
    unsigned int v7 = a2;
    int v5 = __cxa_guard_acquire(&qword_101938840);
    a2 = v7;
    a3 = v8;
    int v6 = v5;
    a1 = v9;
    if (v6)
    {
      qword_101938828 = 0LL;
      unk_101938830 = 0LL;
      qword_101938838 = 0LL;
      __cxa_atexit((void (*)(void *))sub_100355650, &qword_101938828, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101938840);
      a1 = v9;
      a2 = v7;
      a3 = v8;
    }
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &qword_101938828);
}

BOOL sub_100583D74(uint64_t a1, int a2, int *a3, const std::string *a4)
{
  int v40 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        int v13 = (uint64_t *)v7;
      }
      else {
        int v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      uint64_t v39 = v10;
      int v16 = *a3;
      uint64_t v19 = *(void *)(v10 + 48);
      uint64_t v18 = v10 + 48;
      uint64_t v17 = v19;
      if (!v19) {
        goto LABEL_31;
      }
      uint64_t v20 = v18;
      do
      {
        int v21 = *(_DWORD *)(v17 + 28);
        BOOL v22 = v21 < v16;
        if (v21 >= v16) {
          __int16 v23 = (uint64_t *)v17;
        }
        else {
          __int16 v23 = (uint64_t *)(v17 + 8);
        }
        if (!v22) {
          uint64_t v20 = v17;
        }
        uint64_t v17 = *v23;
      }

      while (*v23);
      if (v20 == v18 || v16 < *(_DWORD *)(v20 + 28)) {
LABEL_31:
      }
        uint64_t v20 = v18;
      uint64_t v24 = *(void *)(a1 + 64);
      if (!v24) {
        goto LABEL_42;
      }
      uint64_t v25 = a1 + 64;
      do
      {
        int v26 = *(_DWORD *)(v24 + 32);
        BOOL v27 = v26 < v16;
        if (v26 >= v16) {
          __int128 v28 = (uint64_t *)v24;
        }
        else {
          __int128 v28 = (uint64_t *)(v24 + 8);
        }
        if (!v27) {
          uint64_t v25 = v24;
        }
        uint64_t v24 = *v28;
      }

      while (*v28);
      if (v25 != a1 + 64 && v16 >= *(_DWORD *)(v25 + 32))
      {
        *(void *)__int16 v41 = v25;
        uint64_t v33 = *(void *)(v25 + 56);
        *(void *)std::string buf = &v40;
        __int16 v34 = sub_1004C2E20((uint64_t **)(v25 + 40), &v40, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        std::string::operator=((std::string *)(v34 + 5), a4);
        memset(v48, 0, sizeof(v48));
        *(_OWORD *)uint64_t v46 = 0u;
        *(_OWORD *)std::string __p = 0u;
        __int128 v45 = 0u;
        memset(buf, 0, sizeof(buf));
        __int128 v49 = 0u;
        __int128 v50 = 0u;
        __int128 v51 = 0u;
        memset(v52, 0, 27);
        char v53 = 0;
        int v54 = 0;
        if (v20 == v18
          && (*(unsigned int (**)(uint64_t, int *, uint8_t *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          uint64_t v35 = sub_10058AC0C((uint64_t)buf);
          sub_100588884((_BYTE *)a1, (uint64_t)&v39, (uint64_t)v41, v35);
        }

        if (SHIBYTE(v52[2]) < 0) {
          operator delete(v52[0]);
        }
        if (SHIBYTE(v51) < 0) {
          operator delete(*((void **)&v50 + 1));
        }
        if (SBYTE7(v50) < 0) {
          operator delete((void *)v49);
        }
        if ((v48[15] & 0x80000000) != 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(__p[0]) < 0) {
          operator delete(v46[0]);
        }
        if (SHIBYTE(v45) < 0) {
          operator delete(*(void **)&buf[24]);
        }
        if (v33) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        *(void *)__int16 v41 = a1 + 64;
        char v29 = byte_101938848;
        HIDWORD(v3_Block_object_dispose(va, 8) = v16;
        *(void *)std::string buf = (char *)&v38 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v38 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 80) = v29;
        HIDWORD(v3_Block_object_dispose(va, 8) = *a3;
        *(void *)std::string buf = (char *)&v38 + 4;
        BOOL v30 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v38 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v30 + 8);
        HIDWORD(v3_Block_object_dispose(va, 8) = *a3;
        *(void *)std::string buf = (char *)&v38 + 4;
        id v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v38 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)std::string buf = &v40;
        __int16 v32 = sub_1004C2E20(v31 + 5, &v40, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        std::string::operator=((std::string *)(v32 + 5), a4);
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v20 == v18)
      {
        *(_DWORD *)std::string buf = *a3;
        sub_10004A8FC((uint64_t **)(v39 + 40), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101840260);
  }
  uint64_t v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    int v15 = (void *)(a1 + 8);
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL result = sub_1002921D0(115, 0);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    __int16 v36 = (void *)(a1 + 8);
    *(_DWORD *)__int16 v41 = 136446466;
    *(void *)&v41[4] = v36;
    __int16 v42 = 1026;
    int v43 = v40;
    LODWORD(v3_Block_object_dispose(va, 8) = 18;
    id v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                    v41,
                    v38);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLClient Manager_Type::RegInfo>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notifica tion_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationData, Notifica tionInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]",  "%s\n",  v37);
    return 0LL;
  }

  return result;
}

void sub_100584288( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

BOOL sub_1005842A8(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        int v21 = (uint64_t *)v15;
      }
      else {
        int v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)std::string buf = 136446466;
      char v29 = v11;
      __int16 v30 = 1026;
      int v31 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101840260);
      }
      BOOL v22 = (void *)(a1 + 8);
      int v24 = 136446466;
      uint64_t v25 = v22;
      __int16 v26 = 1026;
      int v27 = a2;
      __int16 v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                      &v24,
                      18);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLClie ntManager_Type::RegInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLClientManager_Type:: Notification, NotificationData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, Registrati onInfo_T = CLClientManager_Type::RegInfo]",  "%s\n",  v23);
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100584528(char *a1, int a2, int *a3)
{
  HIDWORD(v33) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        int v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            int v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            BOOL v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                uint64_t v25 = (uint64_t *)v20;
              }
              else {
                uint64_t v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                BOOL v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_10052A02C((uint64_t)(v22 + 40), (int *)&v33 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101840260);
              }
              __int16 v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v27 = a1 + 8;
                if (a1[31] < 0) {
                  int v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v43 >= 0) {
                  __int128 v28 = __p;
                }
                else {
                  __int128 v28 = (void **)__p[0];
                }
                *(_DWORD *)std::string buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v35 = 2082;
                __int16 v36 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v43 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101840260);
                }
                char v29 = a1 + 8;
                if (a1[31] < 0) {
                  char v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v37 >= 0) {
                  int v31 = buf;
                }
                else {
                  int v31 = *(_BYTE **)buf;
                }
                int v38 = 136446466;
                uint64_t v39 = v29;
                __int16 v40 = 2082;
                __int16 v41 = v31;
                LODWORD(v33) = 22;
                __int16 v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                                &v38,
                                v33);
                if (v37 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, ch ar, CLClientManager_Type::RegInfo>::unregisterForNotification(int, const Notification_T &) [Notificati on_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationData , NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]",  "%s\n",  v32);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_1005848B0(uint64_t a1, int *a2, std::string *this)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v7 = *a2;
  uint64_t v8 = v3;
  do
  {
    int v9 = *(_DWORD *)(v4 + 32);
    BOOL v10 = v9 < v7;
    if (v9 >= v7) {
      int v11 = (uint64_t *)v4;
    }
    else {
      int v11 = (uint64_t *)(v4 + 8);
    }
    if (!v10) {
      uint64_t v8 = v4;
    }
    uint64_t v4 = *v11;
  }

  while (*v11);
  if (v8 == v3) {
    return 0LL;
  }
  if (v7 < *(_DWORD *)(v8 + 32)) {
    return 0LL;
  }
  uint64_t v12 = *(void *)(v8 + 64);
  if (!v12) {
    return 0LL;
  }
  std::string::operator=(this, *(const std::string **)(v8 + 64));
  std::string::operator=(this + 1, (const std::string *)(v12 + 24));
  std::string::operator=(this + 2, (const std::string *)(v12 + 48));
  std::string::operator=(this + 3, (const std::string *)(v12 + 72));
  std::string::value_type v13 = *(_BYTE *)(v12 + 98);
  LOWORD(this[4].__r_.__value_.__l.__data_) = *(_WORD *)(v12 + 96);
  this[4].__r_.__value_.__s.__data_[2] = v13;
  std::string::operator=((std::string *)((char *)this + 104), (const std::string *)(v12 + 104));
  std::string::operator=((std::string *)((char *)this + 128), (const std::string *)(v12 + 128));
  std::string::operator=((std::string *)((char *)this + 152), (const std::string *)(v12 + 152));
  __int16 v14 = *(_WORD *)(v12 + 176);
  this[7].__r_.__value_.__s.__data_[10] = *(_BYTE *)(v12 + 178);
  LOWORD(this[7].__r_.__value_.__r.__words[1]) = v14;
  this[7].__r_.__value_.__l.__cap_ = *(void *)(v12 + 184);
  return 1LL;
}

uint64_t sub_10058499C(uint64_t a1, int *a2, uint64_t a3)
{
  int v10 = *a2;
  uint64_t v12 = &v10;
  uint64_t v5 = sub_10023347C((uint64_t **)(a1 + 56), &v10, (uint64_t)&unk_1012CF090, &v12);
  sub_10005F550((uint64_t)(v5 + 8), &v11);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1))
  {
    int v7 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return 1LL;
}

void sub_100584A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100584A5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_OWORD *)unint64_t v8 = 0u;
  memset(v9, 0, sizeof(v9));
  __int128 v6 = 0u;
  *(_OWORD *)int v7 = 0u;
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)uint64_t v5 = 0u;
  memset(__p, 0, 27);
  *(_OWORD *)int v10 = 0u;
  *(_OWORD *)__int128 v11 = 0u;
  __int128 v12 = 0u;
  char v14 = 0;
  int v15 = 0;
  (*(void (**)(uint64_t, uint64_t, void **, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  v4,  a3,  a4,  0LL);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[1]);
  }
  if (SHIBYTE(v11[0]) < 0) {
    operator delete(v10[0]);
  }
  if ((v9[15] & 0x80000000) != 0) {
    operator delete(v8[1]);
  }
  if (SHIBYTE(v8[0]) < 0) {
    operator delete(v7[0]);
  }
  if (SHIBYTE(v6) < 0) {
    operator delete(v5[1]);
  }
  if (SHIBYTE(v5[0]) < 0) {
    operator delete(v4[0]);
  }
}

void sub_100584B3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100584B50(uint64_t a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    int v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    __int128 v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      __int128 v12 = (void *)(a1 + 8);
      std::string::value_type v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)std::string buf = 68289794;
      *(_DWORD *)int v65 = 0;
      *(_WORD *)&v65[4] = 2082;
      *(void *)&v65[6] = "";
      *(_WORD *)&v65[14] = 2082;
      *(void *)&v65[16] = "activity";
      __int16 v66 = 2082;
      id v67 = v12;
      __int16 v68 = 2050;
      __int16 v69 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    char v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      char v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)uint64_t v70 = &v70[8];
      memset(&v70[8], 0, 24);
      id v71 = 0LL;
      sub_100588960((uint64_t)buf, a2, (uint64_t)v70);
      int v17 = sub_100528470((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v69;
      if (v69)
      {
        p_shared_owners = (unint64_t *)&v69->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100528854((uint64_t)&v65[4], *(char **)&v65[12]);
      BOOL v24 = v71;
      if (v71)
      {
        uint64_t v25 = (unint64_t *)&v71->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100528854((uint64_t)v70, *(char **)&v70[8]);
    }

    if (a4)
    {
      sub_100588A10(a3, buf);
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      int v27 = *(std::__shared_weak_count **)&v65[4];
      if (*(void *)&v65[4])
      {
        __int128 v28 = (unint64_t *)(*(void *)&v65[4] + 8LL);
        do
          unint64_t v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    uint64_t v30 = sub_100588410(a3);
    if (a5 == -1)
    {
      sub_1005884B0((void *)a1, (int *)a2, v30);
    }

    else
    {
      uint64_t v31 = a1 + 88;
      uint64_t v32 = *(void *)(a1 + 88);
      if (!v32) {
        goto LABEL_48;
      }
      uint64_t v33 = a1 + 88;
      do
      {
        int v34 = *(_DWORD *)(v32 + 32);
        BOOL v35 = v34 < a5;
        if (v34 >= a5) {
          __int16 v36 = (uint64_t *)v32;
        }
        else {
          __int16 v36 = (uint64_t *)(v32 + 8);
        }
        if (!v35) {
          uint64_t v33 = v32;
        }
        uint64_t v32 = *v36;
      }

      while (*v36);
      if (v33 == v31 || *(_DWORD *)(v33 + 32) > a5) {
LABEL_48:
      }
        uint64_t v33 = a1 + 88;
      uint64_t v62 = v33;
      unint64_t v37 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v38 = *a2;
      uint64_t v39 = (__n128 *)(a1 + 64);
      do
      {
        int v40 = *(_DWORD *)(v37 + 32);
        BOOL v41 = v40 < v38;
        if (v40 >= v38) {
          __int16 v42 = (unint64_t *)v37;
        }
        else {
          __int16 v42 = (unint64_t *)(v37 + 8);
        }
        if (!v41) {
          uint64_t v39 = (__n128 *)v37;
        }
        unint64_t v37 = *v42;
      }

      while (*v42);
      if (v39 == v15 || v38 < (signed __int32)v39[2].n128_u32[0])
      {
LABEL_59:
        char v61 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101840260);
        }
        char v43 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          int v44 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v70, a1, a2);
          if (v70[23] >= 0) {
            __int128 v45 = v70;
          }
          else {
            __int128 v45 = *(_BYTE **)v70;
          }
          *(_DWORD *)std::string buf = 136315650;
          *(void *)int v65 = v44;
          *(_WORD *)&v65[8] = 1024;
          *(_DWORD *)&v65[10] = a5;
          *(_WORD *)&v65[14] = 2080;
          *(void *)&v65[16] = v45;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v70[23] & 0x80000000) != 0) {
            operator delete(*(void **)v70);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_101840260);
          }
          uint64_t v46 = (void *)(a1 + 8);
          uint64_t v47 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v60 >= 0) {
            unint64_t v48 = __p;
          }
          else {
            unint64_t v48 = (void **)__p[0];
          }
          *(_DWORD *)uint64_t v70 = 136315650;
          *(void *)&v70[4] = v46;
          *(_WORD *)&v70[12] = 1024;
          *(_DWORD *)&v70[14] = a5;
          *(_WORD *)&_BYTE v70[18] = 2080;
          *(void *)&v70[20] = v48;
          __int128 v49 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v47,  2LL,  "%s; client %d has deregistered, not notifying %s",
                          v70,
                          28,
                          v58);
          if (v60 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CL ClientManager_Type::RegInfo>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL , int, BOOL) [Notification_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type ::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]",  "%s\n",  v49);
        }

        goto LABEL_83;
      }

      char v61 = v39;
      if (v33 == v31) {
        goto LABEL_60;
      }
      uint64_t v52 = v39[3].n128_i64[0];
      __int128 v50 = v39 + 3;
      __int128 v51 = (__n128 *)v52;
      if (!v52) {
        goto LABEL_60;
      }
      int v53 = *(_DWORD *)(v33 + 32);
      int v54 = v50;
      do
      {
        int v55 = v51[2].n128_i32[0];
        BOOL v56 = v55 < v53;
        if (v55 >= v53) {
          unint64_t v57 = v51;
        }
        else {
          unint64_t v57 = (__n128 *)&v51->n128_i8[8];
        }
        if (!v56) {
          int v54 = v51;
        }
        __int128 v51 = (__n128 *)v57->n128_u64[0];
      }

      while (v57->n128_u64[0]);
      sub_100588884((_BYTE *)a1, (uint64_t)&v62, (uint64_t)&v61, v30);
    }

void sub_10058516C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_1005851B8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    id v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)std::string buf = 136315138;
      int v34 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101840260);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v29 = 136315138;
      uint64_t v30 = v4;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
                     (const char *)&v29);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLClie ntManager_Type::RegInfo>::listClients() [Notification_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]",  "%s\n",  v5);
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101840260);
    }
    __int128 v6 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      int v7 = (void *)(a1 + 8);
      uint64_t v8 = *(void *)(a1 + 96);
      *(_DWORD *)std::string buf = 136315394;
      int v34 = v7;
      __int16 v35 = 2048;
      v36[0] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101840260);
      }
      uint64_t v25 = (void *)(a1 + 8);
      uint64_t v26 = *(void *)(a1 + 96);
      int v29 = 136315394;
      uint64_t v30 = v25;
      __int16 v31 = 2048;
      v32[0] = v26;
      int v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
                      (const char *)&v29,
                      22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLClie ntManager_Type::RegInfo>::listClients() [Notification_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]",  "%s\n",  v27);
    }

    int v9 = *(void **)(a1 + 80);
    if (v9 != (void *)(a1 + 88))
    {
      int v10 = (void *)(a1 + 8);
      do
      {
        __int128 v11 = (void *)v9[5];
        if (v11 != v9 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_101840260);
            }
            __int128 v12 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              std::string::value_type v13 = (void *)(a1 + 8);
              int v14 = *((_DWORD *)v9 + 8);
              int v15 = *((_DWORD *)v11 + 7);
              *(_DWORD *)std::string buf = 136315650;
              int v34 = v13;
              __int16 v35 = 1024;
              LODWORD(v36[0]) = v14;
              WORD2(v36[0]) = 1024;
              *(_DWORD *)((char *)v36 + 6) = v15;
              _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101840260);
              }
              BOOL v19 = (void *)(a1 + 8);
              int v20 = *((_DWORD *)v9 + 8);
              int v21 = *((_DWORD *)v11 + 7);
              int v29 = 136315650;
              uint64_t v30 = v19;
              __int16 v31 = 1024;
              LODWORD(v32[0]) = v20;
              WORD2(v32[0]) = 1024;
              *(_DWORD *)((char *)v32 + 6) = v21;
              BOOL v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                              (const char *)&v29,
                              24,
                              v28);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char , CLClientManager_Type::RegInfo>::listClients() [Notification_T = CLClientManager_Type::Notification, No tificationData_T = CLClientManager_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]",  "%s\n",  v22);
            }

            signed __int32 v16 = (void *)v11[1];
            if (v16)
            {
              do
              {
                int v17 = v16;
                signed __int32 v16 = (void *)*v16;
              }

              while (v16);
            }

            else
            {
              do
              {
                int v17 = (void *)v11[2];
                BOOL v18 = *v17 == (void)v11;
                __int128 v11 = v17;
              }

              while (!v18);
            }

            __int128 v11 = v17;
          }

          while (v17 != v9 + 6);
        }

        unint64_t v23 = (void *)v9[1];
        if (v23)
        {
          do
          {
            BOOL v24 = v23;
            unint64_t v23 = (void *)*v23;
          }

          while (v23);
        }

        else
        {
          do
          {
            BOOL v24 = (void *)v9[2];
            BOOL v18 = *v24 == (void)v9;
            int v9 = v24;
          }

          while (!v18);
        }

        int v9 = v24;
      }

      while (v24 != (void *)(a1 + 88));
    }
  }

void sub_100585764(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100589C68(a1);
  operator delete(v1);
}

id sub_100585778(uint64_t a1, int a2, void *a3)
{
  id result = sub_100588B28(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_1005857C4(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

uint64_t sub_1005857F0(uint64_t a1, int a2, uint64_t a3, void *a4, __int128 *a5)
{
  *(_DWORD *)a1 = a2;
  *(_BYTE *)(a1 + 4) = 0;
  *(void *)(a1 + _Block_object_dispose(va, 8) = a3;
  if (*((char *)a5 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 16), *(void **)a5, *((void *)a5 + 1));
  }

  else
  {
    __int128 v7 = *a5;
    *(void *)(a1 + 32) = *((void *)a5 + 2);
    *(_OWORD *)(a1 + 16) = v7;
  }

  id v8 = [a4 copy];
  *(void *)(a1 + 40) = v8;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  if (!v8) {
    *(void *)(a1 + 40) = [&stru_1018401E0 copy];
  }
  id v9 = *(id *)(a1 + 8);
  return a1;
}

void sub_100585880(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1005858A0(uint64_t a1)
{
  return a1;
}

void sub_1005858D8(uint64_t a1)
{
  if (*(void *)(a1 + 40))
  {
    +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kCLErrorDomain,  18LL,  0LL);
    sub_10057E760((unsigned int *)a1);
  }

void sub_100585934(id a1)
{
  qword_101934A68 = (uint64_t)os_log_create("com.apple.locationd.Utility", "LocationMetrics");
}

void sub_100585960(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

void sub_10058598C(id a1)
{
  qword_101996E28 = (uint64_t)os_log_create("com.apple.greentea", "location");
}

id sub_1005859B8(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) proxyForService:@"CLClientManager"];
  qword_101996E40 = (uint64_t)result;
  return result;
}

uint64_t sub_1005859E4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(void *)(a1 + 64) = 0LL;
  sub_100585A44(a1, a2);
  return a1;
}

void sub_100585A28(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100585A44(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)a1;
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)a2 = v4;
  LOBYTE(v4) = *(_BYTE *)(a1 + 4);
  *(_BYTE *)(a1 + 4) = *(_BYTE *)(a2 + 4);
  *(_BYTE *)(a2 + 4) = v4;
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(a1 + _Block_object_dispose(va, 8) = *(void *)(a2 + 8);
  *(void *)(a2 + _Block_object_dispose(va, 8) = v5;
  uint64_t v6 = *(void *)(a1 + 32);
  __int128 v7 = *(_OWORD *)(a1 + 16);
  uint64_t v8 = *(void *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = v8;
  *(_OWORD *)(a2 + 16) = v7;
  *(void *)(a2 + 32) = v6;
  uint64_t v9 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v9;
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = v10;
  uint64_t v11 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v11;
  *(void *)&__int128 v7 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v7;
  return a1;
}

void sub_100585B04(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100585B30(uint64_t a1)
{
}

void sub_100585B3C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 272);
  if (v4 && *(void *)(v4 + 48) == *(void *)(a1 + 32))
  {
    sub_10055B34C(a2, *(void *)(a1 + 40));
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018401A0);
    }
    uint64_t v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(a1 + 40) & 3;
      uint64_t v7 = *(void *)(a2 + 272);
      BOOL v8 = v7 != 0;
      uint64_t v9 = *(void *)(a1 + 32);
      if (v7) {
        uint64_t v7 = *(void *)(v7 + 48);
      }
      *(_DWORD *)std::string buf = 68290050;
      __int16 v17 = 2082;
      int v16 = 0;
      BOOL v18 = "";
      __int16 v19 = 1026;
      int v20 = v6;
      __int16 v21 = 1026;
      BOOL v22 = v8;
      __int16 v23 = 2114;
      uint64_t v24 = v9;
      __int16 v25 = 2114;
      uint64_t v26 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AuthPrompt #Thunk CFUserNotification, ResponseFlag:%{public}d, HasInflightAuthPr omptRequest:%{public}hhd, ThunkCFUN:%{public, location:escape_only}@, InflightCFUN:%{public, location:escape_only}@}",  buf,  0x32u);
    }

    if ((~*(_DWORD *)(a1 + 40) & 3LL) != 0)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018401A0);
      }
      uint64_t v10 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "#AuthPrompt #Thunk InflightAuthPromptRequest has unexpected state",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_1018401A0);
        }
        v14[0] = 0;
        uint64_t v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "#AuthPrompt #Thunk InflightAuthPromptRequest has unexpected state",  v14,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void thunkDeliverCFUserNotificationUnified(CFUserNotificationRef, CFOptionFlags)_block_invoke",  "%s\n",  v11);
      }
    }
  }

  __int128 v12 = (__CFRunLoop *)sub_10029228C();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100585E18;
  block[3] = &unk_10181D3D0;
  block[4] = *(void *)(a1 + 32);
  CFRunLoopPerformBlock(v12, kCFRunLoopCommonModes, block);
}

void sub_100585E18(uint64_t a1)
{
}

void sub_100585E20(uint64_t a1)
{
}

uint64_t sub_100585E28(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 24 * a3;
    do
    {
      sub_1000B9764(a1, a2, (uint64_t)a2);
      a2 += 24;
      v5 -= 24LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100585E8C(_Unwind_Exception *a1)
{
}

void sub_100585EA0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100585EA0(a1, *a2);
    sub_100585EA0(a1, a2[1]);
    sub_10000AE14((uint64_t)(a2 + 4));
    operator delete(a2);
  }

uint64_t sub_100585EE8(uint64_t a1, unint64_t *a2)
{
  id v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  unint64_t v3 = *a2;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      uint64_t v7 = v2;
    }
    else {
      uint64_t v7 = v2 + 1;
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    id v2 = (void *)*v7;
  }

  while (*v7);
  sub_1000087E8((uint64_t **)a1, v4);
  sub_10000AE14((uint64_t)(v4 + 4));
  operator delete(v4);
  return 1LL;
}

uint64_t *sub_100585F6C(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  BOOL v6 = a1 + 1;
  unint64_t v5 = a1[1];
  uint64_t v7 = a1 + 1;
  BOOL v8 = a1 + 1;
  if (v5)
  {
    unint64_t v9 = *a2;
    while (1)
    {
      while (1)
      {
        BOOL v8 = (uint64_t **)v5;
        unint64_t v10 = v5[4];
        if (v9 >= v10) {
          break;
        }
        unint64_t v5 = *v8;
        uint64_t v7 = v8;
        if (!*v8) {
          goto LABEL_9;
        }
      }

      if (v10 >= v9) {
        return (uint64_t *)v8;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v7 = v8 + 1;
        goto LABEL_9;
      }
    }
  }

  else
  {
LABEL_9:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v16[1] = v6;
    uint64_t v12 = a3[1];
    v11[4] = *a3;
    void v11[5] = v12;
    if (v12)
    {
      std::string::value_type v13 = (unint64_t *)(v12 + 8);
      do
        unint64_t v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }

    char v17 = 1;
    sub_1000085FC(a1, (uint64_t)v8, v7, v11);
    v16[0] = 0LL;
    sub_100586060((uint64_t)v16, 0LL);
  }

  return v11;
}

void sub_100586060(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_10000AE14((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

id sub_1005860A4(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(*(void *)(a1 + 8) + 136) registeredKeyPathForClientIdentifier:a2];
  uint64_t v4 = *(void **)(*(void *)(a1 + 8) + 136LL);
  sub_100FCA488(__p);
  if (v9 >= 0) {
    unint64_t v5 = __p;
  }
  else {
    unint64_t v5 = (void **)__p[0];
  }
  id v6 = objc_msgSend( v4,  "hasValueForKey:atKeyPath:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v5),  v3);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  return v6;
}

void sub_100586150( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10058616C(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  id v5 = sub_10053D6E0((uint64_t)a1, a2);
  id v61 = v5;
  *a3 = 0LL;
  a3[1] = 0LL;
  if (v5)
  {
    [v5 cppClientKey];
  }

  else
  {
    *(void *)std::string buf = 0LL;
    *(void *)id v63 = 0LL;
    *(void *)&v63[8] = 0LL;
  }

  unint64_t v58 = buf;
  id v6 = sub_100586680((uint64_t)(a1 + 114), buf, (uint64_t)&unk_1012CF090, (__int128 **)&v58) + 40;
  if ((v63[15] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  *(void *)std::string buf = &v60;
  uint64_t v7 = sub_100586A28((uint64_t)v6, (uint64_t *)&v60, (uint64_t)&unk_1012CF090, (uint64_t **)buf);
  unint64_t v58 = 0LL;
  char v59 = 0LL;
  BOOL v8 = (std::__shared_weak_count *)v7[4];
  if (v8
    && (char v9 = std::__shared_weak_count::lock(v8), (v59 = v9) != 0LL)
    && (v10 = v9, uint64_t v11 = (void *)v7[3], (v58 = (uint8_t *)v11) != 0LL))
  {
    if (v12)
    {
      *(void *)std::string buf = v12;
      *(void *)id v63 = v10;
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        unint64_t v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }

    else
    {
      *(void *)std::string buf = 0LL;
      *(void *)id v63 = 0LL;
    }

    uint64_t v32 = sub_10005F550((uint64_t)a3, (__int128 *)buf);
    int v40 = *(std::__shared_weak_count **)v63;
    if (*(void *)v63)
    {
      BOOL v41 = (unint64_t *)(*(void *)v63 + 8LL);
      do
        unint64_t v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }

    if (!*a3)
    {
      sub_10123D7E0( v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v46,  v47,  v48,  v49,  v50,  (uint64_t)v51,  v52,  *((uint64_t *)&v52 + 1),  __p,  *((uint64_t *)&__p + 1),  v54,  v55,  *((uint64_t *)&v55 + 1),  v56,  (uint64_t)v57,  (uint64_t)v58);
      abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/CLClientManager.h",  362,  "getOrCreatePersistentSubscriptionForClient");
      __break(1u);
    }
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101840220);
    }
    int v15 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_INFO))
    {
      *(void *)std::string buf = 68289538LL;
      *(_WORD *)id v63 = 2082;
      *(void *)&v63[2] = "";
      *(_WORD *)&v63[10] = 2082;
      *(void *)&v63[12] = (unint64_t)"29CLVisitMonitoringSubscription" & 0x7FFFFFFFFFFFFFFFLL;
      *(_WORD *)&v63[20] = 2114;
      *(void *)&v63[22] = v61;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Creating persistent subscription due to demand, type:%{public, location:escape_only }s, clientKeyPath:%{public, location:escape_only}@}",  buf,  0x26u);
    }

    unint64_t v57 = sub_10054B60C((uint64_t)a1, (uint64_t)v61, &xmmword_101339630);
    if (v61)
    {
      [v61 cppClientKey];
    }

    else
    {
      __int128 v55 = 0uLL;
      uint64_t v56 = 0LL;
    }

    sub_100FCA488(&__p);
    sub_100586CF0((char *)buf, &v55, &__p, (uint64_t)v60);
    if (SHIBYTE(v54) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v56) < 0) {
      operator delete((void *)v55);
    }
    sub_100586D94(a1 + 4, (uint64_t *)&v57, (uint64_t *)&v61, (uint64_t)buf, &v52);
    sub_10005F550((uint64_t)a3, &v52);
    int v16 = (std::__shared_weak_count *)*((void *)&v52 + 1);
    if (*((void *)&v52 + 1))
    {
      char v17 = (unint64_t *)(*((void *)&v52 + 1) + 8LL);
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }

    *(void *)&__int128 v52 = &v60;
    __int16 v19 = sub_100586A28((uint64_t)v6, (uint64_t *)&v60, (uint64_t)&unk_1012CF090, (uint64_t **)&v52);
    __int16 v21 = (void *)*a3;
    uint64_t v20 = a3[1];
    if (v20)
    {
      BOOL v22 = (unint64_t *)(v20 + 16);
      do
        unint64_t v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }

    uint64_t v24 = (std::__shared_weak_count *)v19[4];
    void v19[3] = v21;
    v19[4] = v20;
    if (v24) {
      std::__shared_weak_count::__release_weak(v24);
    }
    __int16 v25 = (void *)*a3;
    uint64_t v26 = a1[120];
    uint64_t v50 = a1[119];
    __int128 v51 = (std::__shared_weak_count *)v26;
    if (v26)
    {
      int v27 = (unint64_t *)(v26 + 8);
      do
        unint64_t v28 = __ldxr(v27);
      while (__stxr(v28 + 1, v27));
    }

    sub_1004C6738(v25, &v50);
    int v29 = v51;
    if (v51)
    {
      uint64_t v30 = (unint64_t *)&v51->__shared_owners_;
      do
        unint64_t v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }

    if (v64 < 0) {
      operator delete(*(void **)&v63[16]);
    }
    if ((v63[15] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

  char v43 = v59;
  if (v59)
  {
    int v44 = (unint64_t *)&v59->__shared_owners_;
    do
      unint64_t v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }

void sub_1005865DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, char a30)
{
}

unsigned __int8 *sub_100586680(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  BOOL v8 = (void *)(a1 + 24);
  unint64_t v9 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }

    unint64_t v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (unsigned int i = *v14; i; unsigned int i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }

          else
          {
            v16 &= v11 - 1;
          }

          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }

  char v17 = (char *)operator new(0x50uLL);
  v29[0] = v17;
  v29[1] = a1 + 16;
  *(void *)char v17 = 0LL;
  *((void *)v17 + 1) = v10;
  unint64_t v18 = *a4;
  __int128 v19 = **a4;
  *((void *)v17 + 4) = *((void *)*a4 + 2);
  *((_OWORD *)v17 + 1) = v19;
  *((void *)v18 + 1) = 0LL;
  *((void *)v18 + 2) = 0LL;
  *(void *)unint64_t v18 = 0LL;
  *(_OWORD *)(v17 + 40) = 0u;
  *(_OWORD *)(v17 + 56) = 0u;
  *((_DWORD *)v17 + 1_Block_object_dispose(va, 8) = 1065353216;
  char v30 = 1;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v21 = *(float *)(a1 + 32);
  if (!v11 || (float)(v21 * (float)v11) < v20)
  {
    BOOL v22 = 1LL;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    sub_100019E10(a1, v25);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }

  uint64_t v26 = *(void **)(*(void *)a1 + 8 * v4);
  if (v26)
  {
    *(void *)v29[0] = *v26;
    *uint64_t v26 = v29[0];
  }

  else
  {
    *(void *)v29[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v29[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v29[0])
    {
      unint64_t v27 = *(void *)(*(void *)v29[0] + 8LL);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v27 >= v11) {
          v27 %= v11;
        }
      }

      else
      {
        v27 &= v11 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v27) = v29[0];
    }
  }

  unsigned int i = (unsigned __int8 *)v29[0];
  v29[0] = 0LL;
  ++*v8;
  sub_100586930((uint64_t)v29, 0LL);
  return i;
}

void sub_100586918(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100586930(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100586974((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }

void sub_100586974(uint64_t a1)
{
}

uint64_t sub_1005869B0(uint64_t a1)
{
  id v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1005869E8(int a1, void *__p)
{
  if (__p)
  {
    id v2 = __p;
    do
    {
      id v3 = (void *)*v2;
      unint64_t v4 = (std::__shared_weak_count *)v2[4];
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      operator delete(v2);
      id v2 = v3;
    }

    while (v3);
  }

void *sub_100586A28(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v8 = *(void *)(*a2 + 8);
  if ((v8 & 0x8000000000000000LL) != 0)
  {
    unint64_t v9 = (unsigned __int8 *)(v8 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v10 = 5381LL;
    do
    {
      unint64_t v8 = v10;
      unsigned int v11 = *v9++;
      uint64_t v10 = (33 * v10) ^ v11;
    }

    while (v11);
  }

  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v12) {
        unint64_t v4 = v8 % v12;
      }
    }

    else
    {
      unint64_t v4 = (v12 - 1) & v8;
    }

    int v15 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v15)
    {
      for (unsigned int i = *v15; i; unsigned int i = (void *)*i)
      {
        unint64_t v17 = i[1];
        if (v17 == v8)
        {
          if (sub_10001A4B8(i[2], *a2)) {
            return i;
          }
        }

        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }

          else
          {
            v17 &= v12 - 1;
          }

          if (v17 != v4) {
            break;
          }
        }
      }
    }
  }

  unint64_t v18 = (void *)(a1 + 16);
  unsigned int i = operator new(0x28uLL);
  void *i = 0LL;
  i[1] = v8;
  uint64_t v19 = **a4;
  i[3] = 0LL;
  i[4] = 0LL;
  i[2] = v19;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    BOOL v22 = 1LL;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    sub_100019E10(a1, v25);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v8 >= v12) {
        unint64_t v4 = v8 % v12;
      }
      else {
        unint64_t v4 = v8;
      }
    }

    else
    {
      unint64_t v4 = (v12 - 1) & v8;
    }
  }

  uint64_t v26 = *(void *)a1;
  unint64_t v27 = *(void **)(*(void *)a1 + 8 * v4);
  if (v27)
  {
    void *i = *v27;
LABEL_41:
    *unint64_t v27 = i;
    goto LABEL_42;
  }

  void *i = *v18;
  *unint64_t v18 = i;
  *(void *)(v26 + 8 * v4) = v18;
  if (*i)
  {
    unint64_t v28 = *(void *)(*i + 8LL);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12) {
        v28 %= v12;
      }
    }

    else
    {
      v28 &= v12 - 1;
    }

    unint64_t v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_41;
  }

void sub_100586C8C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void sub_100586CA8(uint64_t a1, void *__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    id v3 = (std::__shared_weak_count *)__p[4];
    if (v3) {
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

char *sub_100586CF0(char *__dst, __int128 *a2, __int128 *a3, uint64_t a4)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v7 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__dst = v7;
  }

  unint64_t v8 = __dst + 24;
  if (*((char *)a3 + 23) < 0)
  {
    sub_1010DD48C(v8, *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 v9 = *a3;
    *((void *)__dst + 5) = *((void *)a3 + 2);
    *(_OWORD *)unint64_t v8 = v9;
  }

  *((void *)__dst + 6) = a4;
  return __dst;
}

void sub_100586D78(_Unwind_Exception *exception_object)
{
}

void sub_100586D94(uint64_t *a1@<X1>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, void *a5@<X8>)
{
  uint64_t v10 = operator new(0x140uLL);
  sub_100586E14(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  sub_100586FD0((uint64_t)a5, v10 + 4, (uint64_t)(v10 + 3));
}

void sub_100586E00(_Unwind_Exception *a1)
{
}

void *sub_100586E14(void *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  a1[2] = 0LL;
  *a1 = off_1018402B0;
  a1[1] = 0LL;
  sub_100586EC8((uint64_t)&v7, (uint64_t)(a1 + 3), a2, a3, a4, a5);
  return a1;
}

void sub_100586E6C(_Unwind_Exception *a1)
{
}

void sub_100586E80(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1018402B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100586E94(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1018402B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100586EB8(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_100586EC8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v8 = *a3;
  uint64_t v9 = *a4;
  uint64_t v10 = *a5;
  if (*(char *)(a6 + 23) < 0)
  {
    sub_1010DD48C(v11, *(void **)a6, *(void *)(a6 + 8));
  }

  else
  {
    *(_OWORD *)uint64_t v11 = *(_OWORD *)a6;
    uint64_t v12 = *(void *)(a6 + 16);
  }

  if (*(char *)(a6 + 47) < 0)
  {
    sub_1010DD48C(&__p, *(void **)(a6 + 24), *(void *)(a6 + 32));
  }

  else
  {
    __int128 __p = *(_OWORD *)(a6 + 24);
    uint64_t v14 = *(void *)(a6 + 40);
  }

  uint64_t v15 = *(void *)(a6 + 48);
  sub_100FC97D8(a2, v8, v9, v10, v11);
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
}

void sub_100586FA4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100586FD0(uint64_t a1, void *a2, uint64_t a3)
{
  if (a2)
  {
    unint64_t v4 = (std::__shared_weak_count *)a2[1];
    if (!v4 || v4->__shared_owners_ == -1)
    {
      id v5 = *(std::__shared_weak_count **)(a1 + 8);
      if (v5)
      {
        p_shared_owners = (unint64_t *)&v5->__shared_owners_;
        do
          unint64_t v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        p_shared_weak_owners = (unint64_t *)&v5->__shared_weak_owners_;
        do
          unint64_t v9 = __ldxr(p_shared_weak_owners);
        while (__stxr(v9 + 1, p_shared_weak_owners));
        unint64_t v4 = (std::__shared_weak_count *)a2[1];
      }

      *a2 = a3;
      a2[1] = v5;
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      if (v5)
      {
        uint64_t v10 = (unint64_t *)&v5->__shared_owners_;
        do
          unint64_t v11 = __ldaxr(v10);
        while (__stlxr(v11 - 1, v10));
        if (!v11)
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
      }
    }
  }

id sub_100587080(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(*(void *)(a1 + 8) + 136) registeredKeyPathForClientIdentifier:a2];
  unint64_t v4 = *(void **)(*(void *)(a1 + 8) + 136LL);
  sub_100B57FC8(__p);
  if (v9 >= 0) {
    id v5 = __p;
  }
  else {
    id v5 = (void **)__p[0];
  }
  id v6 = objc_msgSend( v4,  "hasValueForKey:atKeyPath:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v5),  v3);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  return v6;
}

void sub_10058712C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100587148(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  id v5 = sub_10053D6E0((uint64_t)a1, a2);
  id v61 = v5;
  *a3 = 0LL;
  a3[1] = 0LL;
  if (v5)
  {
    [v5 cppClientKey];
  }

  else
  {
    *(void *)std::string buf = 0LL;
    *(void *)id v63 = 0LL;
    *(void *)&v63[8] = 0LL;
  }

  unint64_t v58 = buf;
  id v6 = sub_100586680((uint64_t)(a1 + 114), buf, (uint64_t)&unk_1012CF090, (__int128 **)&v58) + 40;
  if ((v63[15] & 0x80000000) != 0) {
    operator delete(*(void **)buf);
  }
  *(void *)std::string buf = &v60;
  unint64_t v7 = sub_100586A28((uint64_t)v6, (uint64_t *)&v60, (uint64_t)&unk_1012CF090, (uint64_t **)buf);
  unint64_t v58 = 0LL;
  char v59 = 0LL;
  uint64_t v8 = (std::__shared_weak_count *)v7[4];
  if (v8
    && (char v9 = std::__shared_weak_count::lock(v8), (v59 = v9) != 0LL)
    && (v10 = v9, unint64_t v11 = (void *)v7[3], (v58 = (uint8_t *)v11) != 0LL))
  {
    if (v12)
    {
      *(void *)std::string buf = v12;
      *(void *)id v63 = v10;
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        unint64_t v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }

    else
    {
      *(void *)std::string buf = 0LL;
      *(void *)id v63 = 0LL;
    }

    uint64_t v32 = sub_10005F550((uint64_t)a3, (__int128 *)buf);
    int v40 = *(std::__shared_weak_count **)v63;
    if (*(void *)v63)
    {
      BOOL v41 = (unint64_t *)(*(void *)v63 + 8LL);
      do
        unint64_t v42 = __ldaxr(v41);
      while (__stlxr(v42 - 1, v41));
      if (!v42)
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
    }

    if (!*a3)
    {
      sub_10123D7E0( v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v46,  v47,  v48,  v49,  v50,  (uint64_t)v51,  v52,  *((uint64_t *)&v52 + 1),  __p,  *((uint64_t *)&__p + 1),  v54,  v55,  *((uint64_t *)&v55 + 1),  v56,  (uint64_t)v57,  (uint64_t)v58);
      abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Core/ClientManagement/CLClientManager.h",  362,  "getOrCreatePersistentSubscriptionForClient");
      __break(1u);
    }
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101840220);
    }
    uint64_t v15 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_INFO))
    {
      *(void *)std::string buf = 68289538LL;
      *(_WORD *)id v63 = 2082;
      *(void *)&v63[2] = "";
      *(_WORD *)&v63[10] = 2082;
      *(void *)&v63[12] = (unint64_t)"18CLPushSubscription" & 0x7FFFFFFFFFFFFFFFLL;
      *(_WORD *)&v63[20] = 2114;
      *(void *)&v63[22] = v61;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Creating persistent subscription due to demand, type:%{public, location:escape_only }s, clientKeyPath:%{public, location:escape_only}@}",  buf,  0x26u);
    }

    unint64_t v57 = sub_10054B60C((uint64_t)a1, (uint64_t)v61, &xmmword_101339630);
    if (v61)
    {
      [v61 cppClientKey];
    }

    else
    {
      __int128 v55 = 0uLL;
      uint64_t v56 = 0LL;
    }

    sub_100B57FC8(&__p);
    sub_100586CF0((char *)buf, &v55, &__p, (uint64_t)v60);
    if (SHIBYTE(v54) < 0) {
      operator delete((void *)__p);
    }
    if (SHIBYTE(v56) < 0) {
      operator delete((void *)v55);
    }
    sub_10058765C(a1 + 4, (uint64_t *)&v57, (uint64_t *)&v61, (uint64_t)buf, &v52);
    sub_10005F550((uint64_t)a3, &v52);
    unint64_t v16 = (std::__shared_weak_count *)*((void *)&v52 + 1);
    if (*((void *)&v52 + 1))
    {
      unint64_t v17 = (unint64_t *)(*((void *)&v52 + 1) + 8LL);
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }

    *(void *)&__int128 v52 = &v60;
    uint64_t v19 = sub_100586A28((uint64_t)v6, (uint64_t *)&v60, (uint64_t)&unk_1012CF090, (uint64_t **)&v52);
    float v21 = (void *)*a3;
    uint64_t v20 = a3[1];
    if (v20)
    {
      BOOL v22 = (unint64_t *)(v20 + 16);
      do
        unint64_t v23 = __ldxr(v22);
      while (__stxr(v23 + 1, v22));
    }

    unint64_t v24 = (std::__shared_weak_count *)v19[4];
    void v19[3] = v21;
    v19[4] = v20;
    if (v24) {
      std::__shared_weak_count::__release_weak(v24);
    }
    size_t v25 = (void *)*a3;
    uint64_t v26 = a1[120];
    uint64_t v50 = a1[119];
    __int128 v51 = (std::__shared_weak_count *)v26;
    if (v26)
    {
      unint64_t v27 = (unint64_t *)(v26 + 8);
      do
        unint64_t v28 = __ldxr(v27);
      while (__stxr(v28 + 1, v27));
    }

    sub_1004C6738(v25, &v50);
    int v29 = v51;
    if (v51)
    {
      char v30 = (unint64_t *)&v51->__shared_owners_;
      do
        unint64_t v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }

    if (v64 < 0) {
      operator delete(*(void **)&v63[16]);
    }
    if ((v63[15] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

  char v43 = v59;
  if (v59)
  {
    int v44 = (unint64_t *)&v59->__shared_owners_;
    do
      unint64_t v45 = __ldaxr(v44);
    while (__stlxr(v45 - 1, v44));
    if (!v45)
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }

void sub_1005875B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, char a30)
{
}

void sub_10058765C(uint64_t *a1@<X1>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, void *a5@<X8>)
{
  uint64_t v10 = operator new(0x118uLL);
  sub_1005876DC(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  sub_100586FD0((uint64_t)a5, v10 + 4, (uint64_t)(v10 + 3));
}

void sub_1005876C8(_Unwind_Exception *a1)
{
}

void *sub_1005876DC(void *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  a1[2] = 0LL;
  *a1 = off_101840300;
  a1[1] = 0LL;
  sub_100587790((uint64_t)&v7, (uint64_t)(a1 + 3), a2, a3, a4, a5);
  return a1;
}

void sub_100587734(_Unwind_Exception *a1)
{
}

void sub_100587748(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101840300;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10058775C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101840300;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100587780(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_100587790(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v8 = *a3;
  uint64_t v9 = *a4;
  uint64_t v10 = *a5;
  if (*(char *)(a6 + 23) < 0)
  {
    sub_1010DD48C(v11, *(void **)a6, *(void *)(a6 + 8));
  }

  else
  {
    *(_OWORD *)unint64_t v11 = *(_OWORD *)a6;
    uint64_t v12 = *(void *)(a6 + 16);
  }

  if (*(char *)(a6 + 47) < 0)
  {
    sub_1010DD48C(&__p, *(void **)(a6 + 24), *(void *)(a6 + 32));
  }

  else
  {
    __int128 __p = *(_OWORD *)(a6 + 24);
    uint64_t v14 = *(void *)(a6 + 40);
  }

  uint64_t v15 = *(void *)(a6 + 48);
  sub_100B5773C(a2, v8, v9, v10, v11);
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
}

void sub_10058786C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100587898(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(*(void *)(a1 + 8) + 136) registeredKeyPathForClientIdentifier:a2];
  unint64_t v4 = *(void **)(*(void *)(a1 + 8) + 136LL);
  sub_100C72880(__p);
  if (v9 >= 0) {
    id v5 = __p;
  }
  else {
    id v5 = (void **)__p[0];
  }
  id v6 = objc_msgSend( v4,  "hasValueForKey:atKeyPath:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v5),  v3);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  return v6;
}

void sub_100587944( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100587960(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    char v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_1005879EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t **sub_100587A00(uint64_t **a1, unint64_t *a2, _OWORD *a3)
{
  id v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        unint64_t v5 = *v8;
        id v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        id v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    unint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v10 + 2) = *a3;
    sub_1000085FC(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }

  return v8;
}

void sub_100587AB8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100587B44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100587B58(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100587BE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100587BF8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100587C84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100587C98(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100587D24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100587D38(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100587DC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100587DD8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100587E64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100587E78(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100587F04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100587F18(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100587FA4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100587FB8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100588044( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100588058(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_1005880E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

_OWORD *sub_1005880F8(uint64_t **a1, const void **a2, uint64_t a3)
{
  unint64_t v5 = (void **)sub_1000227E8((uint64_t)a1, &v11, a2);
  id v6 = *v5;
  if (!*v5)
  {
    unint64_t v7 = (uint64_t **)v5;
    id v6 = operator new(0x40uLL);
    _DWORD v6[2] = *(_OWORD *)a3;
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    uint64_t v8 = *(void *)(a3 + 16);
    uint64_t v9 = *(void *)(a3 + 24);
    *(void *)(a3 + 16) = 0LL;
    *((void *)v6 + 6) = v8;
    *((void *)v6 + 7) = v9;
    sub_1000085FC(a1, v11, v7, (uint64_t *)v6);
  }

  return v6;
}

void sub_100588188(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    unint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100588214( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100588228(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_10058827C(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0LL;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0LL; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0LL;
    }

    *(void *)(a1 + 24) = 0LL;
  }

void sub_10058827C(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      id v3 = (void *)*v2;
      sub_100586974((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

void *sub_1005882B8(void *a1, uint64_t *a2)
{
  unint64_t v3 = *(void *)(*a2 + 8);
  if ((v3 & 0x8000000000000000LL) != 0)
  {
    unint64_t v4 = (unsigned __int8 *)(v3 & 0x7FFFFFFFFFFFFFFFLL);
    uint64_t v5 = 5381LL;
    do
    {
      unint64_t v3 = v5;
      unsigned int v6 = *v4++;
      uint64_t v5 = (33 * v5) ^ v6;
    }

    while (v6);
  }

  int8x8_t v7 = (int8x8_t)a1[1];
  if (!*(void *)&v7) {
    return 0LL;
  }
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
  v8.i16[0] = vaddlv_u8(v8);
  unint64_t v9 = v8.u32[0];
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v10 = v3;
    if (v3 >= *(void *)&v7) {
      unint64_t v10 = v3 % *(void *)&v7;
    }
  }

  else
  {
    unint64_t v10 = (*(void *)&v7 - 1LL) & v3;
  }

  uint64_t v11 = *(void **)(*a1 + 8 * v10);
  if (!v11) {
    return 0LL;
  }
  uint64_t v12 = (void *)*v11;
  if (*v11)
  {
    do
    {
      unint64_t v13 = v12[1];
      if (v13 == v3)
      {
        if (sub_10001A4B8(v12[2], *a2)) {
          return v12;
        }
      }

      else
      {
        if (v9 > 1)
        {
          if (v13 >= *(void *)&v7) {
            v13 %= *(void *)&v7;
          }
        }

        else
        {
          v13 &= *(void *)&v7 - 1LL;
        }

        if (v13 != v10) {
          return 0LL;
        }
      }

      uint64_t v12 = (void *)*v12;
    }

    while (v12);
  }

  return v12;
}

uint64_t sub_1005883C8(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  sub_10005BEB8(a1, a2, (uint64_t)&__p);
  unint64_t v3 = __p;
  __int128 __p = 0LL;
  if (v3) {
    sub_100586CA8((uint64_t)&v6, v3);
  }
  return v2;
}

CLCppContainer *sub_100588410(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0xC0uLL);
  sub_1011F69B0(v2, (__int128 *)a1);
  *((void *)v2 + 23) = *(void *)(a1 + 184);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_100588B04;
  v4[3] = &unk_10181D3D0;
  v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  0LL,  192LL);
}

void sub_10058849C(_Unwind_Exception *a1)
{
}

void sub_1005884B0(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    uint64_t v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      unint64_t v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v4;
        }
        else {
          uint64_t v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          unint64_t v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        uint64_t v50 = v9;
        id v13 = sub_100588B28(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        uint64_t v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          uint64_t v15 = a1 + 11;
          unint64_t v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 8);
            uint64_t v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                BOOL v22 = (uint64_t *)v17;
              }
              else {
                BOOL v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                uint64_t v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              uint64_t v49 = v19;
              sub_100588884(a1, (uint64_t)&v49, (uint64_t)&v50, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              int v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  uint64_t v32 = (uint64_t *)v27;
                }
                else {
                  uint64_t v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  int v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              uint64_t v50 = v29;
              uint64_t v34 = v29[6];
              uint64_t v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                uint64_t v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 32);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    uint64_t v39 = (uint64_t *)v36;
                  }
                  else {
                    uint64_t v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    uint64_t v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 8))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 32);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      unint64_t v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      unint64_t v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      uint64_t v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  char v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      uint64_t v14 = v43;
                      char v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      uint64_t v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      uint64_t v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              uint64_t v49 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101840260);
              }
              unint64_t v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                size_t v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 8);
                *(_DWORD *)std::string buf = 136446466;
                uint64_t v56 = v25;
                __int16 v57 = 1026;
                int v58 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101840260);
                }
                unint64_t v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 8);
                int v51 = 136446466;
                __int128 v52 = v45;
                __int16 v53 = 1026;
                int v54 = v46;
                LODWORD(v4_Block_object_dispose(va, 8) = 18;
                uint64_t v47 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                                &v51,
                                v48);
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLClientManager_Type::Notification, CLClientManager_Type::NotificationData, char, CLCl ientManager_Type::RegInfo>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notificat ion_T = CLClientManager_Type::Notification, NotificationData_T = CLClientManager_Type::NotificationDat a, NotificationInfo_T = char, RegistrationInfo_T = CLClientManager_Type::RegInfo]",  "%s\n",  v47);
              }
            }
          }

          while (v14 != v50 + 6);
        }
      }
    }
  }

_BYTE *sub_100588884(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    int8x8_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_100588B28(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40LL);
    uint64_t v14 = (int *)(*(void *)a2 + 32LL);
    uint64_t v12 = sub_1004C2E20(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    id result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 5);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

uint64_t sub_100588960(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)a1 = *a2;
  sub_1005889BC((uint64_t *)(a1 + 8), a3);
  uint64_t v5 = *(void *)(a3 + 32);
  *(void *)(a1 + 32) = *(void *)(a3 + 24);
  *(void *)(a1 + 40) = v5;
  if (v5)
  {
    uint64_t v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  *(_BYTE *)(a1 + 4_Block_object_dispose(va, 8) = *(_BYTE *)(a3 + 40);
  return a1;
}

uint64_t *sub_1005889BC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_10052865C(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1005889F8(_Unwind_Exception *a1)
{
}

uint64_t sub_100588A10@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0xD8uLL);
  uint64_t result = sub_100588A68((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_100588A54(_Unwind_Exception *a1)
{
}

uint64_t sub_100588A68(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_101840350;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  sub_1011F69B0((char *)(a1 + 24), (__int128 *)a2);
  *(void *)(a1 + 20_Block_object_dispose(va, 8) = *(void *)(a2 + 184);
  return a1;
}

void sub_100588AAC(_Unwind_Exception *a1)
{
}

void sub_100588AC0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101840350;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100588AD4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101840350;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100588AF8(uint64_t a1)
{
  return sub_1011F6920(a1 + 24);
}

void sub_100588B04(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = (void *)sub_1011F6920(v1);
    operator delete(v2);
  }

id sub_100588B28(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_100588B74(a1);
  }
  else {
    return 0LL;
  }
}

id sub_100588B74(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    unint64_t v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012F0E92LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    uint64_t v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012F0E92LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  unint64_t v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLClientManager_Type::NotificationData, Callback = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:228:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

void sub_100588F20(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

uint64_t *sub_100588F4C(void *a1, unsigned __int8 *a2)
{
  uint64_t result = (uint64_t *)sub_100121918(a1, a2);
  if (result)
  {
    sub_100588F80(a1, result);
    return (uint64_t *)1;
  }

  return result;
}

uint64_t sub_100588F80(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  sub_10005BEB8(a1, a2, (uint64_t)&__p);
  unint64_t v3 = (void **)__p;
  __int128 __p = 0LL;
  if (v3) {
    sub_10004B64C((uint64_t)&v6, v3);
  }
  return v2;
}

uint64_t sub_100588FC8(uint64_t **a1, const void **a2)
{
  uint64_t v3 = sub_10008E8D0((uint64_t)a1, a2);
  sub_1003F9708(a1, v3);
  return 1LL;
}

void sub_10058900C(uint64_t *a1@<X1>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, void *a5@<X8>)
{
  id v10 = operator new(0x200uLL);
  sub_10058908C(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  sub_100586FD0((uint64_t)a5, v10 + 4, (uint64_t)(v10 + 3));
}

void sub_100589078(_Unwind_Exception *a1)
{
}

void *sub_10058908C(void *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  a1[2] = 0LL;
  *a1 = off_1018403C0;
  a1[1] = 0LL;
  sub_100589140((uint64_t)&v7, (uint64_t)(a1 + 3), a2, a3, a4, a5);
  return a1;
}

void sub_1005890E4(_Unwind_Exception *a1)
{
}

void sub_1005890F8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1018403C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10058910C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1018403C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100589130(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_100589140(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v8 = *a3;
  uint64_t v9 = *a4;
  uint64_t v10 = *a5;
  if (*(char *)(a6 + 23) < 0)
  {
    sub_1010DD48C(v11, *(void **)a6, *(void *)(a6 + 8));
  }

  else
  {
    *(_OWORD *)__int16 v11 = *(_OWORD *)a6;
    uint64_t v12 = *(void *)(a6 + 16);
  }

  if (*(char *)(a6 + 47) < 0)
  {
    sub_1010DD48C(&__p, *(void **)(a6 + 24), *(void *)(a6 + 32));
  }

  else
  {
    __int128 __p = *(_OWORD *)(a6 + 24);
    uint64_t v14 = *(void *)(a6 + 40);
  }

  uint64_t v15 = *(void *)(a6 + 48);
  sub_100C71DF4(a2, v8, v9, v10, v11);
  if (SHIBYTE(v14) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
}

void sub_10058921C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100589248(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }

    uint64_t v14 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(void **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
        }

        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }

          else
          {
            v16 &= v11 - 1;
          }

          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }

  uint64_t v17 = (void *)(a1 + 16);
  uint64_t i = operator new(0x38uLL);
  *(void *)uint64_t i = 0LL;
  *((void *)i + 1) = v10;
  int v18 = *a4;
  __int128 v19 = **a4;
  *((void *)i + 4) = *((void *)*a4 + 2);
  *((_OWORD *)i + 1) = v19;
  *((void *)v18 + 1) = 0LL;
  *((void *)v18 + 2) = 0LL;
  *(void *)int v18 = 0LL;
  *((void *)i + 5) = 0LL;
  *((void *)i + 6) = 0LL;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v21 = *(float *)(a1 + 32);
  if (!v11 || (float)(v21 * (float)v11) < v20)
  {
    BOOL v22 = 1LL;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    sub_100019E10(a1, v25);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }

  uint64_t v26 = *(void *)a1;
  uint64_t v27 = *(void **)(*(void *)a1 + 8 * v4);
  if (v27)
  {
    *(void *)uint64_t i = *v27;
LABEL_38:
    *uint64_t v27 = i;
    goto LABEL_39;
  }

  *(void *)uint64_t i = *v17;
  void *v17 = i;
  *(void *)(v26 + 8 * v4) = v17;
  if (*(void *)i)
  {
    unint64_t v28 = *(void *)(*(void *)i + 8LL);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v28 >= v11) {
        v28 %= v11;
      }
    }

    else
    {
      v28 &= v11 - 1;
    }

    uint64_t v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_38;
  }

void sub_1005894B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void *sub_1005894D0@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  uint64_t result = sub_100215340(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_10058951C(_Unwind_Exception *a1)
{
}

uint64_t sub_100589530(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_100019E10(a1, *(void *)(a2 + 8));
  return a1;
}

void sub_10058958C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1005895A4(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t v6 = (uint64_t **)sub_1000227E8((uint64_t)a1, &v9, a2);
  uint64_t result = *v6;
  if (!*v6)
  {
    sub_100589638((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000085FC(a1, v9, v6, v8);
    return v8;
  }

  return result;
}

_BYTE *sub_100589638@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x48uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + _Block_object_dispose(va, 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  uint64_t result = v6 + 4;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_1010DD48C(result, *(void **)v8, *((void *)v8 + 1));
  }

  else
  {
    __int128 v9 = *v8;
    void v6[6] = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }

  v6[7] = 0LL;
  _WORD v6[8] = 0LL;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1005896C0(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0LL;
  sub_100022988(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1005896DC(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t v6 = (uint64_t **)sub_1000227E8((uint64_t)a1, &v11, a2);
  char v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    sub_100589784((uint64_t)a1, a4, (uint64_t)v10);
    sub_1000085FC(a1, v11, v8, v10[0]);
    char v7 = v10[0];
    v10[0] = 0LL;
    sub_100589814((uint64_t)v10, 0LL);
  }

  return v7;
}

_BYTE *sub_100589784@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + _Block_object_dispose(va, 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  uint64_t result = v6 + 32;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_1010DD48C(result, *(void **)v8, *((void *)v8 + 1));
  }

  else
  {
    __int128 v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }

  *((void *)v6 + 7) = 0LL;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1005897FC(_Unwind_Exception *a1)
{
}

void sub_100589814(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100589858((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

void sub_100589858(uint64_t a1)
{
}

id sub_100589898(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    uint64_t v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012F0F05LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    unint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    uint64_t v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012F0F05LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    unint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  char v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLClientManager_Type::Name, Callback = (lambda a t /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:228:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

void sub_100589C44(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    id v2 = (void *)sub_1008FDB5C(v1);
    operator delete(v2);
  }

uint64_t sub_100589C68(uint64_t a1)
{
  *(void *)a1 = off_101840410;
  id v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *id v2 = 0LL;
  *(void *)(a1 + 16) = 0LL;
  return a1;
}

void sub_100589CC8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    id v2 = (void *)sub_1011F6920(v1);
    operator delete(v2);
  }

void sub_100589CEC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101840518;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100589D00(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101840518;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100589D24(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_100589D34(void *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0xB8uLL);
  sub_100589D9C(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  sub_100586FD0((uint64_t)a3, v6 + 3, (uint64_t)(v6 + 3));
}

void sub_100589D88(_Unwind_Exception *a1)
{
}

void *sub_100589D9C(void *a1, void *a2, void *a3)
{
  a1[2] = 0LL;
  *a1 = off_101840568;
  a1[1] = 0LL;
  unint64_t v4 = a1 + 3;
  if (*a2) {
    uint64_t v5 = *a2 + 112LL;
  }
  else {
    uint64_t v5 = 0LL;
  }
  sub_1008FDC00(v4, v5, *a3);
  return a1;
}

void sub_100589DE8(_Unwind_Exception *a1)
{
}

void sub_100589DFC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101840568;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100589E10(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101840568;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100589E34(uint64_t a1)
{
  return sub_1008FDD48(a1 + 24);
}

void sub_100589E40(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100589E40(a1, *a2);
    sub_100589E40(a1, a2[1]);
    sub_100589858((uint64_t)(a2 + 4));
    operator delete(a2);
  }

uint64_t sub_100589E88(uint64_t a1)
{
  id v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100589EC0(void ***a1)
{
  id v2 = *a1;
  if (*v2)
  {
    sub_100589F00((uint64_t)v2, *v2);
    operator delete(**a1);
  }

void sub_100589F00(uint64_t a1, void *a2)
{
  for (uint64_t i = *(void **)(a1 + 8); i != a2; sub_100575680(i))
    i -= 4;
  *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
}

void sub_100589F4C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100589F4C(a1, *a2);
    sub_100589F4C(a1, a2[1]);
    sub_10000AE14((uint64_t)(a2 + 8));
    sub_100528854((uint64_t)(a2 + 5), (char *)a2[6]);
    operator delete(a2);
  }

uint64_t sub_100589FA4(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10058A018((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10058A018(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v15 = a6;
  *((void *)&v15 + 1) = a7;
  __int128 v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  int v12[2] = &v15;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      __int128 v10 = *(_OWORD *)(a3 - 16);
      *(_OWORD *)(v9 - 32) = *(_OWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 16) = v10;
      v9 -= 32LL;
      v7 -= 32LL;
      a3 -= 32LL;
    }

    while (a3 != a5);
    *((void *)&v15 + 1) = v9;
  }

  char v13 = 1;
  sub_10058A0A0((uint64_t)v12);
  return a6;
}

uint64_t sub_10058A0A0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_10058A0D4((uint64_t *)a1);
  }
  return a1;
}

void *sub_10058A0D4(uint64_t *a1)
{
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v15 = v3;
  uint64_t v16 = v2;
  uint64_t v17 = v3;
  uint64_t v18 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v10 = v7;
  uint64_t v11 = v6;
  uint64_t v12 = v7;
  uint64_t v13 = v6;
  return sub_10058A148(v4, (uint64_t)v14, (uint64_t)v9);
}

void *sub_10058A148(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t result = *(void **)(a2 + 32); result != *(void **)(a3 + 32); *(void *)(a2 + 32) = result)
  {
    sub_100575680(result);
    uint64_t result = (void *)(*(void *)(a2 + 32) + 32LL);
  }

  return result;
}

uint64_t sub_10058A198(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10058A1CC(uint64_t a1, uint64_t a2)
{
  while (1)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4 == a2) {
      break;
    }
    *(void *)(a1 + 16) = v4 - 32;
    sub_100575680((void *)(v4 - 32));
  }

void sub_10058A20C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_1008FDB5C(v4 - 80);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_10058A27C(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x333333333333333LL) {
    sub_100007008();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x199999999999999LL) {
    unint64_t v9 = 0x333333333333333LL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_10003E20C(v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t v13 = v10;
  __int128 v14 = &v10[80 * v4];
  uint64_t v16 = &v10[80 * v9];
  sub_1008FDB14(v14, a2);
  uint64_t v15 = v14 + 80;
  sub_10058A380(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10058A484((uint64_t)&v13);
  return v11;
}

void sub_10058A36C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10058A380(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10058A3F4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10058A3F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = a7 - 80;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = (_OWORD *)(v11 + v10);
    v10 -= 80LL;
    sub_1008FDB14(v12, (__int128 *)(v10 + a3));
  }

  return a6;
}

uint64_t sub_10058A484(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 80;
    sub_1008FDB5C(i - 80);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_10058A4D0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    unint64_t v4 = (void *)sub_1008FDB5C();
    operator delete(v4);
  }

void sub_10058A4FC(int a1, void **__p)
{
  if (__p)
  {
    operator delete(__p);
  }

uint64_t sub_10058A534(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_100019E10(a1, *(void *)(a2 + 8));
  return a1;
}

void sub_10058A590(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_10058A5A8@<X0>( unsigned __int8 *result@<X0>, const void ***a2@<X1>, const void ***a3@<X2>, const void ***a4@<X3>, uint64_t *a5@<X4>, uint64_t a6@<X5>, const void ***a7@<X8>)
{
  unint64_t v9 = *(const void ***)result;
  uint64_t v10 = *a2;
  if (*(const void ***)result == *a2)
  {
LABEL_14:
    uint64_t v19 = *a5;
LABEL_15:
    uint64_t v20 = a5[1];
    goto LABEL_16;
  }

  uint64_t v13 = *a3;
  if (*a3 != *a4)
  {
    uint64_t v16 = result;
    while (!sub_100022920(a6, v9 + 2, v13 + 2))
    {
      uint64_t result = (unsigned __int8 *)sub_100022920(a6, *a3 + 2, (const void **)(*(void *)v16 + 16LL));
      uint64_t v18 = (unsigned __int8 *)a3;
      if ((result & 1) == 0)
      {
        uint64_t result = *(unsigned __int8 **)v16;
        uint64_t v17 = v16;
        uint64_t v18 = (unsigned __int8 *)a3;
        goto LABEL_8;
      }

_OWORD *sub_10058A6FC(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v6 = (void **)sub_1000227E8((uint64_t)a1, &v14, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x40uLL);
    v12[1] = a1 + 1;
    unint64_t v9 = *a4;
    uint64_t v10 = *((void *)*a4 + 2);
    _DWORD v7[2] = **a4;
    *((void *)v7 + 6) = v10;
    v9[1] = 0LL;
    _DWORD v9[2] = 0LL;
    void *v9 = 0LL;
    *((void *)v7 + 7) = 0LL;
    char v13 = 1;
    sub_1000085FC(a1, v14, v8, (uint64_t *)v7);
    v12[0] = 0LL;
    sub_100589814((uint64_t)v12, 0LL);
  }

  return v7;
}

uint64_t sub_10058A7BC(uint64_t **a1, const void **a2)
{
  uint64_t v3 = (uint64_t *)sub_10008E8D0((uint64_t)a1, a2);
  unint64_t v4 = v3;
  sub_1000087E8(a1, v3);
  sub_100589858((uint64_t)(v4 + 4));
  operator delete(v4);
  return 1LL;
}

id sub_10058A814(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_10058A860(a1);
  }
  else {
    return 0LL;
  }
}

id sub_10058A860(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    uint64_t v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012F0FDDLL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    unint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    uint64_t v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012F0FDDLL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101840390);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    unint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  uint64_t v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLClientManager_Type::RegInfo, Callback = (lambd a at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:228:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

CLCppContainer *sub_10058AC0C(uint64_t a1)
{
  id v2 = (char *)operator new(0xC0uLL);
  sub_1011F69B0(v2, (__int128 *)a1);
  *((void *)v2 + 23) = *(void *)(a1 + 184);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_10058ACAC;
  v4[3] = &unk_10181D3D0;
  v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  0LL,  192LL);
}

void sub_10058AC98(_Unwind_Exception *a1)
{
}

void sub_10058ACAC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    id v2 = (void *)sub_1011F6920(v1);
    operator delete(v2);
  }

BOOL sub_10058ACD0()
{
  return os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT);
}

BOOL sub_10058ACE4()
{
  return os_log_type_enabled(*(os_log_t *)(v0 + 2440), OS_LOG_TYPE_INFO);
}

BOOL sub_10058ACF4()
{
  return os_signpost_enabled(*(os_log_t *)(v0 + 2440));
}

  ;
}

  ;
}

  ;
}

  ;
}

BOOL sub_10058AD80()
{
  return os_signpost_enabled(*(os_log_t *)(v0 + 2440));
}

  ;
}

uint64_t sub_10058ADA4()
{
  return sub_100019240(v0);
}

void sub_10058ADAC()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_1012F0B40;
      v1[3] = unk_1012F0B50;
      v1[4] = xmmword_1012F0B60;
      v1[0] = xmmword_1012F0B20;
      v1[1] = unk_1012F0B30;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_10058AE80(_Unwind_Exception *a1)
{
}

void sub_10058AE98()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936068);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936068))
    {
      qword_101936050 = 0LL;
      *(void *)algn_101936058 = 0LL;
      qword_101936060 = 0LL;
      __cxa_atexit((void (*)(void *))sub_1001BA3E4, &qword_101936050, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936068);
    }
  }

void sub_10058AEFC()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936118);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936118))
    {
      std::__shared_mutex_base::__shared_mutex_base(&stru_101936070);
      __cxa_atexit((void (*)(void *))sub_1001BA414, &stru_101936070, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936118);
    }
  }

void sub_10058AF70(_Unwind_Exception *a1)
{
}

NSArray *sub_10058AF88()
{
  for (uint64_t i = 0LL; i != -9; i -= 3LL)
  {
    if (SHIBYTE(v5[i + 2]) < 0) {
      operator delete((void *)v5[i]);
    }
  }

  __cxa_atexit((void (*)(void *))sub_10053C840, qword_101996D48, (void *)&_mh_execute_header);
  qword_101996D78 = 0LL;
  unk_101996D80 = 0LL;
  qword_101996D70 = 0LL;
  uint64_t v1 = operator new(8uLL);
  qword_101996D70 = (uint64_t)v1;
  *uint64_t v1 = 10LL;
  qword_101996D78 = (uint64_t)(v1 + 1);
  unk_101996D80 = v1 + 1;
  __cxa_atexit((void (*)(void *))sub_10053C844, &qword_101996D70, (void *)&_mh_execute_header);
  v3[0] = @"LocationTimeStarted";
  v3[1] = @"SignificantTimeStarted";
  v3[2] = @"RangeTimeStarted";
  unint64_t v4 = @"BeaconRegionTimeStarted";
  uint64_t result = +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v3, 4LL);
  qword_101996D88 = (uint64_t)result;
  return result;
}

void sub_10058B10C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = 0LL;
  while (1)
  {
    v3 -= 24LL;
    if (v3 == -72) {
      _Unwind_Resume(exception_object);
    }
  }

void sub_10058B16C(uint64_t a1)
{
  if (*(void *)(a1 + 16)) {
    sub_10123E86C();
  }
  uint64_t v2 = getpid();
  proc_disable_cpumon(v2);
  uint64_t v3 = 0LL;
  char v4 = 1;
  do
  {
    char v5 = v4;
    uint64_t v6 = operator new(0x18uLL);
    sub_1002E4C3C(v6, "CLSensorTemperatureController", 0LL, 1LL);
    uint64_t v7 = a1 + 8 * v3;
    *(void *)(v7 + 16) = v6;
    v6[4] = 0;
    *((_BYTE *)v6 + 20) = 0;
    int v8 = pthread_create((pthread_t *)v7, 0LL, (void *(__cdecl *)(void *))sub_10058B6EC, v6);
    if (v8)
    {
      if (qword_101934570 != -1) {
        dispatch_once(&qword_101934570, &stru_1018405D0);
      }
      unint64_t v9 = (os_log_s *)qword_101934578;
      if (os_log_type_enabled((os_log_t)qword_101934578, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        int v14 = v8;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "pthread_create failed.result,%d", buf, 8u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934570 != -1) {
          dispatch_once(&qword_101934570, &stru_1018405D0);
        }
        v12[0] = 67109120;
        v12[1] = v8;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934578,  17LL,  "pthread_create failed.result,%d",  v12);
        __int16 v11 = (uint8_t *)v10;
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLSensorTemperatureController::startThreads()", "%s\n", v10);
        if (v11 != buf) {
          free(v11);
        }
      }
    }

    char v4 = 0;
    uint64_t v3 = 1LL;
  }

  while ((v5 & 1) != 0);
}

void sub_10058B3B4(_Unwind_Exception *a1)
{
}

_OWORD *sub_10058B3D0(_OWORD *a1)
{
  *a1 = 0u;
  a1[1] = 0u;
  sub_10058B16C((uint64_t)a1);
  return a1;
}

uint64_t sub_10058B3FC(uint64_t a1)
{
  if (!*(void *)(a1 + 16)) {
    sub_10123E9E0();
  }
  uint64_t v2 = 0LL;
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = a1 + 8 * v2;
    uint64_t v8 = *(void *)(v5 + 16);
    uint64_t v7 = (uint64_t *)(v5 + 16);
    uint64_t v6 = v8;
    (*(void (**)(uint64_t))(*(void *)v8 + 16LL))(v8);
    uint64_t v9 = *v7;
    *(_BYTE *)(*v7 + 20) = 1;
    if (*(void *)(a1 + 8 * v2))
    {
      *(void *)(a1 + 8 * v2) = 0LL;
    }

    else
    {
      id v10 = (void *)sub_1002E4CB0(v9);
      operator delete(v10);
    }

    *uint64_t v7 = 0LL;
    (*(void (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
    char v3 = 0;
    uint64_t v2 = 1LL;
  }

  while ((v4 & 1) != 0);
  uint64_t v11 = getpid();
  return proc_set_cpumon_defaults(v11);
}

uint64_t sub_10058B4A4(uint64_t a1)
{
  return a1;
}

uint64_t sub_10058B4CC(uint64_t a1, float a2)
{
  if (qword_101934570 != -1) {
    dispatch_once(&qword_101934570, &stru_1018405D0);
  }
  char v4 = (os_log_s *)qword_101934578;
  if (os_log_type_enabled((os_log_t)qword_101934578, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 134217984;
    double v16 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "dutyCycle,%f", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934570 != -1) {
      dispatch_once(&qword_101934570, &stru_1018405D0);
    }
    int v13 = 134217984;
    double v14 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934578,  1LL,  "dutyCycle,%f",  COERCE_DOUBLE(&v13));
    uint64_t v12 = (uint8_t *)v11;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSensorTemperatureController::setLoad(float)", "%s\n", v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  if (!*(void *)(a1 + 16)) {
    sub_10123EB54();
  }
  uint64_t v5 = 0LL;
  char v6 = 1;
  do
  {
    char v7 = v6;
    uint64_t v8 = a1 + 8 * v5;
    uint64_t v9 = *(void *)(v8 + 16);
    (*(void (**)(uint64_t))(*(void *)v9 + 16LL))(v9);
    *(float *)(*(void *)(v8 + 16) + 16LL) = a2;
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 24LL))(v9);
    char v6 = 0;
    uint64_t v5 = 1LL;
  }

  while ((v7 & 1) != 0);
  return result;
}

void sub_10058B6E0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_100006BB8(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10058B6EC(uint64_t a1)
{
  char v3 = malloc(0x9007uLL);
  unint64_t v4 = ((unint64_t)v3 + 4103) & 0xFFFFFFFFFFFFF000LL;
  *(void *)(v4 - _Block_object_dispose(va, 8) = v3;
  uint64_t v5 = malloc(0x77uLL);
  char v6 = (_OWORD *)(((unint64_t)v5 + 71) & 0xFFFFFFFFFFFFFFC0LL);
  *((void *)v6 - 1) = v5;
  char v7 = malloc(0x9007uLL);
  unint64_t v8 = ((unint64_t)v7 + 4103) & 0xFFFFFFFFFFFFF000LL;
  *(void *)(v8 - _Block_object_dispose(va, 8) = v7;
  uint64_t v9 = malloc(0x247uLL);
  unint64_t v10 = 0LL;
  unint64_t v11 = ((unint64_t)v9 + 71) & 0xFFFFFFFFFFFFFFC0LL;
  *(void *)(v11 - _Block_object_dispose(va, 8) = v9;
  uint64_t v12 = (_OWORD *)(v4 | 0x20);
  *(void *)&__int128 v13 = 0x5A5A5A5A5A5A5A5ALL;
  *((void *)&v13 + 1) = 0x5A5A5A5A5A5A5A5ALL;
  *(void *)&__int128 v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  do
  {
    *(v12 - 2) = v13;
    *(v12 - 1) = v14;
    *uint64_t v12 = v14;
    v12[1] = v13;
    v12 += 4;
    v10 += 8LL;
  }

  while (v10 < 0xFF9);
  *char v6 = xmmword_1012F1090;
  v6[1] = xmmword_1012F10A0;
  _DWORD v6[2] = xmmword_1012F10B0;
  do
  {
    while (1)
    {
      (*(void (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
      int v15 = *(unsigned __int8 *)(a1 + 20);
      if (*(_BYTE *)(a1 + 20))
      {
        int v16 = 2;
      }

      else
      {
        int v16 = 0;
        float v1 = fminf(fmaxf(*(float *)(a1 + 16), 0.01), 1.0);
      }

      (*(void (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
      if (v15) {
        break;
      }
      double v17 = sub_101171D38();
      sub_100F6DE50();
      double v18 = sub_101171D38();
      usleep(((v18 - v17) * (float)(1.0 - v1) * 1000000.0 / v1));
    }
  }

  while (!v16);
  if (v4) {
    free(*(void **)(v4 - 8));
  }
  free(*((void **)v6 - 1));
  if (v8) {
    free(*(void **)(v8 - 8));
  }
  if (v11) {
    free(*(void **)(v11 - 8));
  }
  uint64_t v19 = (void *)sub_1002E4CB0(a1);
  operator delete(v19);
  return 0LL;
}

void sub_10058B8D0(id a1)
{
  qword_101934578 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Sensors");
}

BOOL sub_10058B8FC()
{
  return os_log_type_enabled((os_log_t)qword_101934578, OS_LOG_TYPE_FAULT);
}

BOOL sub_10058B910()
{
  return os_log_type_enabled(*(os_log_t *)(v0 + 1400), OS_LOG_TYPE_INFO);
}

BOOL sub_10058B920()
{
  return os_signpost_enabled(*(os_log_t *)(v0 + 1400));
}

void *sub_10058B92C(void *a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101840600;
  a1[9] = off_1018406B0;
  sub_100B14CF0(a1 + 57, 0LL, 0LL);
  sub_100B14CF0(a1 + 59, 0LL, 0LL);
  sub_100B14CF0(a1 + 61, 0LL, 0LL);
  (*(void (**)(void *))(*a1 + 112LL))(a1);
  return a1;
}

void sub_10058B9EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10058BA18(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = 0u;
  uint64_t v12 = (void *)(a1 + 8);
  *(void *)a1 = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 8));
  *uint64_t v12 = &off_10182BDA0;
  *(void *)a1 = off_101840B90;
  *(void *)(a1 + 72) = off_101840C38;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_101840B90;
  *(void *)(a1 + 72) = off_101840C38;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_DWORD *)(a1 + 240) = 3;
  *(void *)(a1 + 36_Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(a1 + 244) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 260) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 34_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(a1 + 376) = 12000;
  *(void *)(a1 + 384) = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 392));
  *(void *)(a1 + 392) = &off_10182BDA0;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v28 = a1 + 112;
  (*(void (**)(void))(v13 + 16))();
  __int16 v30 = 256;
  if (a3)
  {
    *(void *)(a1 + 232) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v28 + 24LL))(v28);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)__int128 __p = *(_OWORD *)a4;
    uint64_t v27 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  int v15 = (int *)(a1 + 376);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 376));
  double v17 = v33;
  if (v33)
  {
    p_shared_owners = (unint64_t *)&v33->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    int *v15 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101840C78);
  }
  uint64_t v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v15;
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101840C78);
    }
    int v24 = *v15;
    v31[0] = 67109120;
    v31[1] = v24;
    size_t v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v31);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::CLActivityRecorderDb(const char *, BOOL, float, const std::string &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxRetrocomputeHistory, DataProtectionPolicy = CLAc tivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v25);
  }

  int v22 = HIBYTE(v30);
  *(void *)(a1 + 232) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v30)
    {
      pthread_mutex_unlock(v29);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_10058BDEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[48] = off_10182BD58;
  sub_1001B9C98(v27);
  sub_100210A94(v26);
  sub_100D8A88C(a12);
  *int v24 = off_10182BD58;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_10058BE90()
{
}

void *sub_10058BE98(void *a1)
{
  a1[9] = off_101840C38;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_101840B90;
  a1[48] = off_10182BD58;
  sub_1001B9C98(a1 + 49);
  sub_100210A94(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_10182BD58;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_10058BF18(uint64_t a1)
{
  return sub_10058BE98((void *)(a1 - 72));
}

void sub_10058BF20(void *a1)
{
  float v1 = sub_10058BE98(a1);
  operator delete(v1);
}

void sub_10058BF34(uint64_t a1)
{
  float v1 = sub_10058BE98((void *)(a1 - 72));
  operator delete(v1);
}

uint64_t sub_10058BF4C(uint64_t a1, uint64_t a2, sqlite3_int64 a3)
{
  uint64_t v5 = a1;
  sub_100B14CF8((uint64_t *)(v5 + 472), &v31);
  uuid_unparse((const unsigned __int8 *)(a2 + 64), out);
  char v6 = (sqlite3_stmt *)sub_100019240(v31);
  char v7 = (sqlite3_stmt *)sub_100019240(v31);
  if (!sub_1003C28BC(v7, 2, *(_DWORD *)(a2 + 16))) {
    goto LABEL_24;
  }
  unint64_t v8 = (sqlite3_stmt *)sub_100019240(v31);
  if (!sub_1003C28BC(v8, 3, *(_DWORD *)(a2 + 20))) {
    goto LABEL_24;
  }
  uint64_t v9 = (sqlite3_stmt *)sub_100019240(v31);
  unint64_t v10 = (sqlite3_stmt *)sub_100019240(v31);
  unint64_t v11 = (sqlite3_stmt *)sub_100019240(v31);
  uint64_t v12 = (sqlite3_stmt *)sub_100019240(v31);
  if (!sub_1003BC1F0(v12, 7, out)) {
    goto LABEL_24;
  }
  uint64_t v13 = (sqlite3_stmt *)sub_100019240(v31);
  uint64_t v14 = (sqlite3_stmt *)sub_100019240(v31);
  int v15 = (sqlite3_stmt *)sub_100019240(v31);
  if (!sub_1003C2AF0(v15, 10, *(_DWORD *)(a2 + 96))) {
    goto LABEL_24;
  }
  char v16 = (sqlite3_stmt *)sub_100019240(v31);
  if (!sub_1003C2AF0(v16, 11, *(_DWORD *)(a2 + 100))) {
    goto LABEL_24;
  }
  double v17 = (sqlite3_stmt *)sub_100019240(v31);
  if (!sub_1003C2AF0(v17, 12, *(_DWORD *)(a2 + 104))) {
    goto LABEL_24;
  }
  double v18 = (sqlite3_stmt *)sub_100019240(v31);
  if (!sub_1003C2AF0(v18, 13, *(_DWORD *)(a2 + 108))) {
    goto LABEL_24;
  }
  unint64_t v19 = (sqlite3_stmt *)sub_100019240(v31);
  uint64_t v20 = (sqlite3_stmt *)sub_100019240(v31);
  if (sub_1003B7480(v20, 15, *(double *)(a2 + 112))
    && (int v21 = (sqlite3_stmt *)sub_100019240(v31), sub_1003B7480(v21, 16, *(double *)(a2 + 88)))
    && (int v22 = (sqlite3_stmt *)sub_100019240(v31), sub_1003B7480(v22, 17, *(double *)(a2 + 120)))
    && (unint64_t v23 = (sqlite3_stmt *)sub_100019240(v31), sub_1003B7480(v23, 18, *(double *)(a2 + 128)))
    && (int v24 = (sqlite3_stmt *)sub_100019240(v31), sub_1003C2AF0(v24, 19, *(_DWORD *)(a2 + 136)))
    && (size_t v25 = (sqlite3_stmt *)sub_100019240(v31), sub_1003B7480(v25, 20, *(double *)(a2 + 144)))
    && (uint64_t v26 = (sqlite3_stmt *)sub_100019240(v31), sub_1003C2D24(v26, 21, a3)))
  {
    uint64_t v5 = *(void *)(v5 + 80);
    uint64_t v27 = (sqlite3_stmt *)sub_100019240(v31);
    LOBYTE(v5) = sub_1003BB2BC(v5, v27);
    int v28 = 0;
  }

  else
  {
LABEL_24:
    int v28 = 1;
  }

  uint64_t v29 = v31;
  uint64_t v31 = 0LL;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
  }
  if (v28) {
LABEL_28:
  }
    LOBYTE(v5) = 0;
  return v5 & 1;
}

void sub_10058C214( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_10058C240(uint64_t a1, int a2, uint64_t a3)
{
  char v6 = (sqlite3_stmt *)sub_100019240(v32);
  if (sub_1003C28BC(v6, 1, a2))
  {
    char v7 = (sqlite3_stmt *)sub_100019240(v32);
    if (sqlite3_step(v7) == 100)
    {
      unint64_t v8 = (sqlite3_stmt *)sub_100019240(v32);
      *(void *)a3 = sqlite3_column_int(v8, 0);
      uint64_t v9 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + _Block_object_dispose(va, 8) = sqlite3_column_double(v9, 1);
      unint64_t v10 = (sqlite3_stmt *)sub_100019240(v32);
      *(_DWORD *)(a3 + 16) = sqlite3_column_int(v10, 2);
      unint64_t v11 = (sqlite3_stmt *)sub_100019240(v32);
      *(_DWORD *)(a3 + 20) = sqlite3_column_int(v11, 3);
      uint64_t v12 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + 24) = sqlite3_column_double(v12, 4);
      uint64_t v13 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + 40) = sqlite3_column_double(v13, 5);
      uint64_t v14 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + 56) = sqlite3_column_double(v14, 6);
      int v15 = (sqlite3_stmt *)sub_100019240(v32);
      char v16 = sqlite3_column_text(v15, 7);
      uuid_parse((const char *)v16, (unsigned __int8 *)(a3 + 64));
      double v17 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + 80) = sqlite3_column_double(v17, 8);
      double v18 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + 4_Block_object_dispose(va, 8) = sqlite3_column_double(v18, 9);
      unint64_t v19 = (sqlite3_stmt *)sub_100019240(v32);
      *(_DWORD *)(a3 + 96) = sqlite3_column_int(v19, 10);
      uint64_t v20 = (sqlite3_stmt *)sub_100019240(v32);
      *(_DWORD *)(a3 + 100) = sqlite3_column_int(v20, 11);
      int v21 = (sqlite3_stmt *)sub_100019240(v32);
      *(_DWORD *)(a3 + 104) = sqlite3_column_int(v21, 12);
      int v22 = (sqlite3_stmt *)sub_100019240(v32);
      *(_DWORD *)(a3 + 10_Block_object_dispose(va, 8) = sqlite3_column_int(v22, 13);
      unint64_t v23 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + 32) = sqlite3_column_double(v23, 14);
      int v24 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + sub_10004AD90(v15 - 112) = sqlite3_column_double(v24, 15);
      size_t v25 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + 8_Block_object_dispose(va, 8) = sqlite3_column_double(v25, 16);
      uint64_t v26 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + 120) = sqlite3_column_double(v26, 17);
      uint64_t v27 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + 12_Block_object_dispose(va, 8) = sqlite3_column_double(v27, 18);
      int v28 = (sqlite3_stmt *)sub_100019240(v32);
      *(_DWORD *)(a3 + 136) = sqlite3_column_int(v28, 19);
      uint64_t v29 = (sqlite3_stmt *)sub_100019240(v32);
      *(double *)(a3 + 144) = sqlite3_column_double(v29, 20);
    }
  }

  uint64_t v30 = v32;
  uint64_t v32 = 0LL;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
  }
  return 100LL;
}

void sub_10058C488( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10058C4AC(uint64_t *a1)
{
  uint64_t result = sub_1003C1048(a1[10]);
  if ((_DWORD)result)
  {
    sub_10058C53C((uint64_t)a1);
    sub_1003B59A0( a1[10],  "VO2MaxRetrocomputeHistory",  (const char **)&off_101840740,  (const std::string::value_type **)&off_101938850,  0);
    a1[61] = sub_1003BF158(a1[10], "SELECT * FROM VO2MaxRetrocomputeHistory WHERE algVersion = ? LIMIT 1");
    a1[62] = v3;
    a1[57] = sub_1003BF158( a1[10],  "INSERT INTO VO2MaxRetrocomputeHistory (startTime, algVersion, status, firstSampleDate, lastSampleDate, la stSessionTimestamp, lastSessionId, meanDelta, lastSampleDatePrevAlg, numUpdatedEstimates, numNewEstimates , numLostEstimates, numLostEstimatesAfterLastSession, firstSummaryDate, lastTimestampToHealthKit, meanPer centileDelta, highPercentileMaxDelta, estimateVariabilityDelta, unavailableReasons, availableStartTime) V ALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
    a1[58] = v4;
    uint64_t result = sub_1003BF158( a1[10],  "UPDATE VO2MaxRetrocomputeHistory SET startTime = ?, algVersion =?, status = ?, firstSampleDate = ?, lastS ampleDate = ?, lastSessionTimestamp = ?, lastSessionId = ?, meanDelta = ?, lastSampleDatePrevAlg = ?, num UpdatedEstimates = ?, numNewEstimates = ?, numLostEstimates = ?, numLostEstimatesAfterLastSession = ?, fi rstSummaryDate = ?, lastTimestampToHealthKit = ?, meanPercentileDelta = ?, highPercentileMaxDelta = ?, es timateVariabilityDelta = ?, unavailableReasons = ?, availableStartTime = ? WHERE id = ?");
    a1[59] = result;
    a1[60] = v5;
  }

  return result;
}

uint64_t sub_10058C53C(uint64_t a1)
{
  uint64_t result = sub_1003B747C(*(void *)(a1 + 80), "VO2MaxRetrocomputeHistory");
  if ((_DWORD)result)
  {
    uint64_t v3 = 0LL;
    int v4 = 0;
    unint64_t v8 = "startTime";
    do
    {
      BOOL v38 = v8;
      int v39 = 5;
      __int16 v40 = 0;
      char v41 = 0;
      char v42 = 0;
      if ((sub_1003BC790(*(void *)(a1 + 80), "VO2MaxRetrocomputeHistory", v8, (uint64_t)&v38) & 1) == 0)
      {
        sub_1003C0454(*(void *)(a1 + 80));
        sub_10000CE18((uint64_t)v34);
        uint64_t v9 = sub_10000CF44(&v35, (uint64_t)"ALTER TABLE VO2MaxRetrocomputeHistory ADD COLUMN ", 49LL);
        size_t v10 = strlen(v8);
        unint64_t v11 = sub_10000CF44(v9, (uint64_t)v8, v10);
        uint64_t v12 = sub_10000CF44(v11, (uint64_t)" ", 1LL);
        uint64_t v13 = (const char *)sub_1003BCC40((int)(&off_101840740)[v3 + 7]);
        size_t v14 = strlen(v13);
        int v15 = sub_10000CF44(v12, (uint64_t)v13, v14);
        sub_10000CF44(v15, (uint64_t)";", 1LL);
        uint64_t v16 = *(void *)(a1 + 80);
        std::stringbuf::str(&v31, &v36);
        if ((v31.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          double v17 = &v31;
        }
        else {
          double v17 = (std::stringbuf::string_type *)v31.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v16, (char *)v17, &v29);
        uint64_t v18 = v29.__r_.__value_.__r.__words[0];
        v29.__r_.__value_.__r.__words[0] = 0LL;
        uint64_t v19 = *(void *)(a1 + 80);
        uint64_t v20 = (sqlite3_stmt *)sub_100019240(v18);
        sub_1003BB2BC(v19, v20);
        sub_10000CE18((uint64_t)&v31);
        int v21 = sub_10000CF44(&v31.__r_.__value_.__l.__cap_, (uint64_t)"UPDATE VO2MaxRetrocomputeHistory SET ", 37LL);
        size_t v22 = strlen(v8);
        unint64_t v23 = sub_10000CF44(v21, (uint64_t)v8, v22);
        sub_10000CF44(v23, (uint64_t)" = 0;", 5LL);
        uint64_t v24 = *(void *)(a1 + 80);
        std::stringbuf::str(&v29, &v32);
        if ((v29.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          size_t v25 = &v29;
        }
        else {
          size_t v25 = (std::stringbuf::string_type *)v29.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v24, (char *)v25, &v30);
        uint64_t v26 = v30;
        uint64_t v30 = 0LL;
        uint64_t v27 = *(void *)(a1 + 80);
        int v28 = (sqlite3_stmt *)sub_100019240(v26);
        sub_1003BB2BC(v27, v28);
        sub_1003C05BC(*(void *)(a1 + 80));
        if (v26) {
          (*(void (**)(uint64_t))(*(void *)v26 + 8LL))(v26);
        }
        v31.__r_.__value_.__r.__words[0] = v5;
        *(std::string::size_type *)((char *)v31.__r_.__value_.__r.__words + *(void *)(v5 - 24)) = v7;
        v31.__r_.__value_.__l.__cap_ = v6;
        std::streambuf::~streambuf(&v32);
        std::ios::~ios(&v33);
        if (v18) {
          (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
        }
        v34[0] = v5;
        *(void *)((char *)v34 + *(void *)(v5 - 24)) = v7;
        std::string::size_type v35 = v6;
        std::streambuf::~streambuf(&v36);
        std::ios::~ios(&v37);
        int v4 = 1;
      }

      unint64_t v8 = (&off_101840740)[v3 + 12];
      v3 += 6LL;
    }

    while (v3 != 120);
    uint64_t result = sub_10058CE54( a1,  "VO2MaxRetrocomputeHistory",  (const char **)&off_101840740,  (const std::string::value_type **)&off_101938850);
  }

  return result;
}

void sub_10058C8E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a21);
  if (v59) {
    (*(void (**)(uint64_t))(*(void *)v59 + 8LL))(v59);
  }
  sub_1011F8850((uint64_t)&a59);
  _Unwind_Resume(a1);
}

void sub_10058C978(uint64_t a1)
{
  if (sub_100D8A92C(a1 + 72))
  {
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM VO2MaxRetrocomputeHistory", buf);
    uint64_t v2 = *(void *)buf;
    uint64_t v3 = *(void *)(a1 + 80);
    int v4 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
    sub_1003BB2BC(v3, v4);
    uint64_t v5 = *(void *)(a1 + 80);
    else {
      uint64_t v6 = *(void *)(v5 + 88);
    }
    sub_1003C1EC0(v5, v6);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  else
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_101840B60);
    }
    std::string::size_type v7 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[VO2MaxRetrocomputeHistory] Database inaccessible, unable to delete records.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_101840B60);
      }
      v9[0] = 0;
      unint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  0LL,  "[VO2MaxRetrocomputeHistory] Database inaccessible, unable to delete records.",  v9,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLVO2MaxRetrocomputeRecorderDb::deleteAllRecordsUL()",  "%s\n",  v8);
    }
  }

void sub_10058CB70(_Unwind_Exception *exception_object)
{
}

void sub_10058CB98(uint64_t a1)
{
}

uint64_t sub_10058CBA0(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_100B14CF8((uint64_t *)(a1 + 456), &v27);
    uuid_unparse((const unsigned __int8 *)(a2 + 64), out);
    uint64_t v5 = (sqlite3_stmt *)sub_100019240(v27);
    if (sub_1003B7480(v5, 1, *(double *)(a2 + 8)))
    {
      uint64_t v6 = (sqlite3_stmt *)sub_100019240(v27);
      if (sub_1003C28BC(v6, 2, *(_DWORD *)(a2 + 16)))
      {
        std::string::size_type v7 = (sqlite3_stmt *)sub_100019240(v27);
        if (sub_1003C28BC(v7, 3, *(_DWORD *)(a2 + 20)))
        {
          unint64_t v8 = (sqlite3_stmt *)sub_100019240(v27);
          if (sub_1003B7480(v8, 4, *(double *)(a2 + 24)))
          {
            uint64_t v9 = (sqlite3_stmt *)sub_100019240(v27);
            if (sub_1003B7480(v9, 5, *(double *)(a2 + 40)))
            {
              size_t v10 = (sqlite3_stmt *)sub_100019240(v27);
              if (sub_1003B7480(v10, 6, *(double *)(a2 + 56)))
              {
                unint64_t v11 = (sqlite3_stmt *)sub_100019240(v27);
                if (sub_1003BC1F0(v11, 7, out))
                {
                  uint64_t v12 = (sqlite3_stmt *)sub_100019240(v27);
                  if (sub_1003B7480(v12, 8, *(double *)(a2 + 80)))
                  {
                    uint64_t v13 = (sqlite3_stmt *)sub_100019240(v27);
                    if (sub_1003B7480(v13, 9, *(double *)(a2 + 48)))
                    {
                      size_t v14 = (sqlite3_stmt *)sub_100019240(v27);
                      if (sub_1003C2AF0(v14, 10, *(_DWORD *)(a2 + 96)))
                      {
                        int v15 = (sqlite3_stmt *)sub_100019240(v27);
                        if (sub_1003C2AF0(v15, 11, *(_DWORD *)(a2 + 100)))
                        {
                          uint64_t v16 = (sqlite3_stmt *)sub_100019240(v27);
                          if (sub_1003C2AF0(v16, 12, *(_DWORD *)(a2 + 104)))
                          {
                            double v17 = (sqlite3_stmt *)sub_100019240(v27);
                            if (sub_1003C2AF0(v17, 13, *(_DWORD *)(a2 + 108)))
                            {
                              uint64_t v18 = (sqlite3_stmt *)sub_100019240(v27);
                              if (sub_1003B7480(v18, 14, *(double *)(a2 + 32)))
                              {
                                uint64_t v19 = (sqlite3_stmt *)sub_100019240(v27);
                                if (sub_1003B7480(v19, 15, *(double *)(a2 + 112)))
                                {
                                  uint64_t v20 = (sqlite3_stmt *)sub_100019240(v27);
                                  if (sub_1003B7480(v20, 16, *(double *)(a2 + 88)))
                                  {
                                    int v21 = (sqlite3_stmt *)sub_100019240(v27);
                                    if (sub_1003B7480(v21, 17, *(double *)(a2 + 120)))
                                    {
                                      size_t v22 = (sqlite3_stmt *)sub_100019240(v27);
                                      if (sub_1003B7480(v22, 18, *(double *)(a2 + 128)))
                                      {
                                        unint64_t v23 = (sqlite3_stmt *)sub_100019240(v27);
                                        if (sub_1003C2AF0(v23, 19, *(_DWORD *)(a2 + 136)))
                                        {
                                          uint64_t v24 = (sqlite3_stmt *)sub_100019240(v27);
                                          if (sub_1003B7480(v24, 20, *(double *)(a2 + 144)))
                                          {
                                            uint64_t v25 = *(void *)(a1 + 80);
                                            uint64_t v26 = (sqlite3_stmt *)sub_100019240(v27);
                                            sub_1003BB2BC(v25, v26);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    uint64_t result = v27;
    uint64_t v27 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_10058CE28( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_10058CE54(uint64_t a1, char *a2, const char **a3, const std::string::value_type **a4)
{
  if (!sub_1003B79FC(*(void *)(a1 + 80), a2))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101840C78);
    }
    unint64_t v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s needs autoincrement migration",  (uint8_t *)buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101840C78);
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      v131 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s needs autoincrement migration",  &__p,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::migrateDbConstraints(const char *, const CLSqliteDatabase: :ColumnInfo *, const char **) [T = VO2MaxRetrocomputeHistory, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  (const char *)v131);
      if (v131 != buf) {
        free(v131);
      }
    }

    memset(&__p, 0, sizeof(__p));
    sub_1010DDBC0(buf, a2);
    uint64_t v9 = std::string::append(buf, "AutoIncr");
    __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t cap = v9->__r_.__value_.__l.__cap_;
    *(_OWORD *)std::string::size_type v140 = v10;
    v9->__r_.__value_.__l.__size_ = 0LL;
    v9->__r_.__value_.__l.__cap_ = 0LL;
    v9->__r_.__value_.__r.__words[0] = 0LL;
    sub_1010DDBC0(buf, a2);
    unint64_t v11 = std::string::append(buf, "Index");
    __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    int64_t v139 = v11->__r_.__value_.__l.__cap_;
    *(_OWORD *)std::string::size_type v138 = v12;
    v11->__r_.__value_.__l.__size_ = 0LL;
    v11->__r_.__value_.__l.__cap_ = 0LL;
    v11->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003C0454(*(void *)(a1 + 80));
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    size_t v14 = buf;
    sub_1000392EC((uint64_t)buf, size + 21);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      size_t v14 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (size)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v14, p_p, size);
    }

    strcpy((char *)v14 + size, "DROP TABLE IF EXISTS ");
    if (cap >= 0) {
      uint64_t v16 = v140;
    }
    else {
      uint64_t v16 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v17 = HIBYTE(cap);
    }
    else {
      std::string::size_type v17 = (std::string::size_type)v140[1];
    }
    uint64_t v18 = std::string::append(buf, (const std::string::value_type *)v16, v17);
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v20 = v18->__r_.__value_.__s.__size_;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v19;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v20;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v20 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v19 = __p.__r_.__value_.__r.__words[0];
    }

    if (v20 >= 0) {
      int v21 = &__p;
    }
    else {
      int v21 = (std::string *)v19;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v21, buf);
    size_t v22 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v23 = sqlite3_step(v22);
    std::string::size_type v24 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v24) {
      (*(void (**)(std::string::size_type))(*(void *)v24 + 8LL))(v24);
    }
    if (v23 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v25 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v25 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v26 = &v145;
    sub_1000392EC((uint64_t)&v145, v25 + 13);
    if ((v145.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v26 = (std::string *)v145.__r_.__value_.__r.__words[0];
    }
    if (v25)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v26, v27, v25);
    }

    strcpy((char *)v26 + v25, "CREATE TABLE ");
    if (cap >= 0) {
      int v28 = v140;
    }
    else {
      int v28 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v29 = HIBYTE(cap);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)v140[1];
    }
    uint64_t v30 = std::string::append(&v145, (const std::string::value_type *)v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v137.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    std::stringbuf v32 = std::string::append(&v137, " (");
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003BE030(a3, 1, 1, (uint64_t)&v136);
    if ((v136.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v34 = &v136;
    }
    else {
      uint64_t v34 = (std::string *)v136.__r_.__value_.__r.__words[0];
    }
    if ((v136.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v35 = v136.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v35 = v136.__r_.__value_.__l.__size_;
    }
    std::stringbuf v36 = std::string::append(&v146, (const std::string::value_type *)v34, v35);
    __int128 v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v36->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0LL;
    v36->__r_.__value_.__l.__cap_ = 0LL;
    v36->__r_.__value_.__r.__words[0] = 0LL;
    BOOL v38 = std::string::append(buf, ")");
    std::string::size_type v39 = v38->__r_.__value_.__r.__words[0];
    v143.__r_.__value_.__r.__words[0] = v38->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v143.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v40 = v38->__r_.__value_.__s.__size_;
    v38->__r_.__value_.__l.__size_ = 0LL;
    v38->__r_.__value_.__l.__cap_ = 0LL;
    v38->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v39;
    __p.__r_.__value_.__l.__size_ = v143.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v143.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v40;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      char v41 = &__p;
    }
    else {
      char v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v41, buf);
    char v42 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v43 = sqlite3_step(v42);
    std::string::size_type v44 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v44) {
      (*(void (**)(std::string::size_type))(*(void *)v44 + 8LL))(v44);
    }
    if (v43 != 101) {
      goto LABEL_234;
    }
    sub_1003BE030(a3, 0, 0, (uint64_t)buf);
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v45 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v45 = __p.__r_.__value_.__l.__size_;
    }
    int v46 = &v142;
    sub_1000392EC((uint64_t)&v142, v45 + 12);
    if ((v142.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      int v46 = (std::string *)v142.__r_.__value_.__r.__words[0];
    }
    if (v45)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v47 = &__p;
      }
      else {
        uint64_t v47 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v46, v47, v45);
    }

    strcpy((char *)v46 + v45, "INSERT INTO ");
    if (cap >= 0) {
      uint64_t v48 = v140;
    }
    else {
      uint64_t v48 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v49 = HIBYTE(cap);
    }
    else {
      std::string::size_type v49 = (std::string::size_type)v140[1];
    }
    uint64_t v50 = std::string::append(&v142, (const std::string::value_type *)v48, v49);
    __int128 v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v135.__r_.__value_.__l.__cap_ = v50->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v135.__r_.__value_.__l.__data_ = v51;
    v50->__r_.__value_.__l.__size_ = 0LL;
    v50->__r_.__value_.__l.__cap_ = 0LL;
    v50->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v52 = std::string::append(&v135, " (");
    __int128 v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v143.__r_.__value_.__l.__cap_ = v52->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v143.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0LL;
    v52->__r_.__value_.__l.__cap_ = 0LL;
    v52->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v54 = buf;
    }
    else {
      int v54 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v55 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v55 = buf[0].__r_.__value_.__l.__size_;
    }
    uint64_t v56 = std::string::append(&v143, (const std::string::value_type *)v54, v55);
    __int128 v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    v136.__r_.__value_.__l.__cap_ = v56->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v136.__r_.__value_.__l.__data_ = v57;
    v56->__r_.__value_.__l.__size_ = 0LL;
    v56->__r_.__value_.__l.__cap_ = 0LL;
    v56->__r_.__value_.__r.__words[0] = 0LL;
    int v58 = std::string::append(&v136, ") SELECT ");
    __int128 v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v145.__r_.__value_.__l.__cap_ = v58->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v145.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0LL;
    v58->__r_.__value_.__l.__cap_ = 0LL;
    v58->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      char v60 = buf;
    }
    else {
      char v60 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v61 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v61 = buf[0].__r_.__value_.__l.__size_;
    }
    uint64_t v62 = std::string::append(&v145, (const std::string::value_type *)v60, v61);
    __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v137.__r_.__value_.__l.__cap_ = v62->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0LL;
    v62->__r_.__value_.__l.__cap_ = 0LL;
    v62->__r_.__value_.__r.__words[0] = 0LL;
    char v64 = std::string::append(&v137, " FROM ");
    __int128 v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v64->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0LL;
    v64->__r_.__value_.__l.__cap_ = 0LL;
    v64->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v66 = std::string::append(&v146, a2);
    std::string::size_type v67 = v66->__r_.__value_.__r.__words[0];
    v144[0] = v66->__r_.__value_.__l.__size_;
    *(void *)((char *)v144 + 7) = *(std::string::size_type *)((char *)&v66->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v68 = v66->__r_.__value_.__s.__size_;
    v66->__r_.__value_.__l.__size_ = 0LL;
    v66->__r_.__value_.__l.__cap_ = 0LL;
    v66->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v67;
    __p.__r_.__value_.__l.__size_ = v144[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v144 + 7);
    __p.__r_.__value_.__s.__size_ = v68;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int16 v69 = &__p;
    }
    else {
      __int16 v69 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v69, &v146);
    uint64_t v70 = (sqlite3_stmt *)sub_100019240((uint64_t)v146.__r_.__value_.__l.__data_);
    int v71 = sqlite3_step(v70);
    std::string::size_type v72 = v146.__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = 0LL;
    if (v72) {
      (*(void (**)(std::string::size_type))(*(void *)v72 + 8LL))(v72);
    }
    if (v71 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v73 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v73 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v74 = buf;
    sub_1000392EC((uint64_t)buf, v73 + 11);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v74 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (v73)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v75 = &__p;
      }
      else {
        __int16 v75 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v74, v75, v73);
    }

    strcpy((char *)v74 + v73, "DROP TABLE ");
    uint64_t v76 = std::string::append(buf, a2);
    std::string::size_type v77 = v76->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v76->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v76->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v78 = v76->__r_.__value_.__s.__size_;
    v76->__r_.__value_.__l.__size_ = 0LL;
    v76->__r_.__value_.__l.__cap_ = 0LL;
    v76->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v77;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v78;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v78 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v77 = __p.__r_.__value_.__r.__words[0];
    }

    if (v78 >= 0) {
      __int16 v79 = &__p;
    }
    else {
      __int16 v79 = (std::string *)v77;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v79, buf);
    int v80 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v81 = sqlite3_step(v80);
    std::string::size_type v82 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v82) {
      (*(void (**)(std::string::size_type))(*(void *)v82 + 8LL))(v82);
    }
    if (v81 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v83 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v83 = __p.__r_.__value_.__l.__size_;
    }
    unint64_t v84 = &v137;
    sub_1000392EC((uint64_t)&v137, v83 + 12);
    if ((v137.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      unint64_t v84 = (std::string *)v137.__r_.__value_.__r.__words[0];
    }
    if (v83)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v85 = &__p;
      }
      else {
        __int16 v85 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v84, v85, v83);
    }

    strcpy((char *)v84 + v83, "ALTER TABLE ");
    if (cap >= 0) {
      std::string::size_type v86 = v140;
    }
    else {
      std::string::size_type v86 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v87 = HIBYTE(cap);
    }
    else {
      std::string::size_type v87 = (std::string::size_type)v140[1];
    }
    BOOL v88 = std::string::append(&v137, (const std::string::value_type *)v86, v87);
    __int128 v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v88->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v89;
    v88->__r_.__value_.__l.__size_ = 0LL;
    v88->__r_.__value_.__l.__cap_ = 0LL;
    v88->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v90 = std::string::append(&v146, " RENAME TO ");
    __int128 v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v90->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v91;
    v90->__r_.__value_.__l.__size_ = 0LL;
    v90->__r_.__value_.__l.__cap_ = 0LL;
    v90->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v92 = std::string::append(buf, a2);
    std::string::size_type v93 = v92->__r_.__value_.__r.__words[0];
    v145.__r_.__value_.__r.__words[0] = v92->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v94 = v92->__r_.__value_.__s.__size_;
    v92->__r_.__value_.__l.__size_ = 0LL;
    v92->__r_.__value_.__l.__cap_ = 0LL;
    v92->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v93;
    __p.__r_.__value_.__l.__size_ = v145.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v94;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v95 = &__p;
    }
    else {
      uint64_t v95 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v95, buf);
    uint64_t v96 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v97 = sqlite3_step(v96);
    std::string::size_type v98 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v98) {
      (*(void (**)(std::string::size_type))(*(void *)v98 + 8LL))(v98);
    }
    if (v97 != 101) {
      goto LABEL_234;
    }
    sub_1003BAFA4(a4, buf);
    std::string::size_type v99 = buf[0].__r_.__value_.__s.__size_;
    unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v99 = buf[0].__r_.__value_.__l.__size_;
    }
    if (v99)
    {
      std::string::assign(&__p, "");
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size_t v101 = __p.__r_.__value_.__s.__size_;
      }
      else {
        size_t v101 = __p.__r_.__value_.__l.__size_;
      }
      uint64_t v102 = &v135;
      sub_1000392EC((uint64_t)&v135, v101 + 13);
      if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v102 = (std::string *)v135.__r_.__value_.__r.__words[0];
      }
      if (v101)
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          id v103 = &__p;
        }
        else {
          id v103 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        memmove(v102, v103, v101);
      }

      strcpy((char *)v102 + v101, "CREATE INDEX ");
      if (v139 >= 0) {
        unint64_t v104 = v138;
      }
      else {
        unint64_t v104 = (void **)v138[0];
      }
      if (v139 >= 0) {
        std::string::size_type v105 = HIBYTE(v139);
      }
      else {
        std::string::size_type v105 = (std::string::size_type)v138[1];
      }
      __int16 v106 = std::string::append(&v135, (const std::string::value_type *)v104, v105);
      __int128 v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
      v143.__r_.__value_.__l.__cap_ = v106->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v143.__r_.__value_.__l.__data_ = v107;
      v106->__r_.__value_.__l.__size_ = 0LL;
      v106->__r_.__value_.__l.__cap_ = 0LL;
      v106->__r_.__value_.__r.__words[0] = 0LL;
      uint64_t v108 = std::string::append(&v143, " ON ");
      __int128 v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
      v136.__r_.__value_.__l.__cap_ = v108->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v136.__r_.__value_.__l.__data_ = v109;
      v108->__r_.__value_.__l.__size_ = 0LL;
      v108->__r_.__value_.__l.__cap_ = 0LL;
      v108->__r_.__value_.__r.__words[0] = 0LL;
      unint64_t v110 = std::string::append(&v136, a2);
      __int128 v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
      v145.__r_.__value_.__l.__cap_ = v110->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v145.__r_.__value_.__l.__data_ = v111;
      v110->__r_.__value_.__l.__size_ = 0LL;
      v110->__r_.__value_.__l.__cap_ = 0LL;
      v110->__r_.__value_.__r.__words[0] = 0LL;
      unint64_t v112 = std::string::append(&v145, " (");
      __int128 v113 = *(_OWORD *)&v112->__r_.__value_.__l.__data_;
      v137.__r_.__value_.__l.__cap_ = v112->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v113;
      v112->__r_.__value_.__l.__size_ = 0LL;
      v112->__r_.__value_.__l.__cap_ = 0LL;
      v112->__r_.__value_.__r.__words[0] = 0LL;
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v114 = buf;
      }
      else {
        __int16 v114 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
      }
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v115 = buf[0].__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v115 = buf[0].__r_.__value_.__l.__size_;
      }
      unint64_t v116 = std::string::append(&v137, (const std::string::value_type *)v114, v115);
      __int128 v117 = *(_OWORD *)&v116->__r_.__value_.__l.__data_;
      v146.__r_.__value_.__l.__cap_ = v116->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v117;
      v116->__r_.__value_.__l.__size_ = 0LL;
      v116->__r_.__value_.__l.__cap_ = 0LL;
      v116->__r_.__value_.__r.__words[0] = 0LL;
      uint64_t v118 = std::string::append(&v146, ")");
      std::string::size_type v119 = v118->__r_.__value_.__r.__words[0];
      v142.__r_.__value_.__r.__words[0] = v118->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)v142.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v118->__r_.__value_.__r.__words[1] + 7);
      unsigned __int8 v120 = v118->__r_.__value_.__s.__size_;
      v118->__r_.__value_.__l.__size_ = 0LL;
      v118->__r_.__value_.__l.__cap_ = 0LL;
      v118->__r_.__value_.__r.__words[0] = 0LL;
      __p.__r_.__value_.__r.__words[0] = v119;
      __p.__r_.__value_.__l.__size_ = v142.__r_.__value_.__r.__words[0];
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v142.__r_.__value_.__r.__words + 7);
      __p.__r_.__value_.__s.__size_ = v120;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v121 = &__p;
      }
      else {
        uint64_t v121 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(*(void *)(a1 + 80), (char *)v121, &v146);
      unint64_t v122 = (sqlite3_stmt *)sub_100019240((uint64_t)v146.__r_.__value_.__l.__data_);
      int v123 = sqlite3_step(v122);
      std::string::size_type v124 = v146.__r_.__value_.__r.__words[0];
      v146.__r_.__value_.__r.__words[0] = 0LL;
      if (v124) {
        (*(void (**)(std::string::size_type))(*(void *)v124 + 8LL))(v124);
      }
      unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    }

    else
    {
      int v123 = 101;
    }

    if ((v100 & 0x80) != 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
    if (v123 == 101)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101840C78);
      }
      uint64_t v125 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s autoincrement migration succeeded",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101840C78);
        }
        LODWORD(v146.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v134) = 12;
        uint32_t v133 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s autoincrement migration succeeded",  &v146,  v134);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::migrateDbConstraints(const char *, const CLSqliteDatabas e::ColumnInfo *, const char **) [T = VO2MaxRetrocomputeHistory, DataProtectionPolicy = CLActivityDB::ClassCDat aProtectionPolicy]",  "%s\n",  (const char *)v133);
        if (v133 != buf) {
          free(v133);
        }
      }

      sub_1003C05BC(*(void *)(a1 + 80));
      char v126 = 0;
    }

    else
    {
LABEL_234:
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101840C78);
      }
      uint64_t v127 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_FAULT,  "%{public}s autoincrement migration failed",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101840C78);
        }
        LODWORD(v146.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v134) = 12;
        uint64_t v132 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "%{public}s autoincrement migration failed",  &v146,  v134);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::migrateDbConstraints(const char *, const CLSqliteDatabas e::ColumnInfo *, const char **) [T = VO2MaxRetrocomputeHistory, DataProtectionPolicy = CLActivityDB::ClassCDat aProtectionPolicy]",  "%s\n",  (const char *)v132);
        if (v132 != buf) {
          free(v132);
        }
      }

      sub_1003C0E18(*(void *)(a1 + 80));
      char v126 = 1;
    }

    if (SHIBYTE(v139) < 0) {
      operator delete(v138[0]);
    }
    if (SHIBYTE(cap) < 0) {
      operator delete(v140[0]);
    }
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v126 & 1) != 0) {
        goto LABEL_246;
      }
    }

    else if ((v126 & 1) != 0)
    {
      goto LABEL_246;
    }

    return 1LL;
  }

void sub_10058DFEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10058E30C(uint64_t *a1, char **a2)
{
  int v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v51);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
    if (HIBYTE(v52)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_10123ECC8(v4);
    __break(1u);
  }

  uint64_t v48 = v51[1];
  operator delete(v51[0]);
  if (!v48) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v51);
    uint64_t v6 = sub_10000CF44(&v52, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 64))(v55, a1);
    if (v55[23] >= 0) {
      std::string::size_type v7 = v55;
    }
    else {
      std::string::size_type v7 = *(_BYTE **)v55;
    }
    if (v55[23] >= 0) {
      uint64_t v8 = v55[23];
    }
    else {
      uint64_t v8 = *(void *)&v55[8];
    }
    uint64_t v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    if ((v55[23] & 0x80000000) != 0) {
      operator delete(*(void **)v55);
    }
    uint64_t v10 = a1[10];
    std::stringbuf::str((std::stringbuf::string_type *)v55, &v53);
    if (v55[23] >= 0) {
      unint64_t v11 = v55;
    }
    else {
      unint64_t v11 = *(char **)v55;
    }
    sub_1003C0D54(v10, v11, &v49);
    uint64_t v12 = v49;
    uint64_t v49 = 0LL;
    uint64_t v50 = v12;
    if ((v55[23] & 0x80000000) != 0) {
      operator delete(*(void **)v55);
    }
    sub_1003C0454(a1[10]);
    *(_OWORD *)std::string::size_type v55 = 0uLL;
    *(_DWORD *)&v55[16] = 3;
    uint64_t v60 = 0LL;
    memset(&v55[20], 0, 44);
    __int128 v57 = 0u;
    __int128 v58 = 0u;
    memset(v59, 0, 28);
    while (!sub_1001BA11C((uint64_t)a1, &v50, (uint64_t)v55))
    {
      unint64_t v13 = (unint64_t)a2[1];
      unint64_t v14 = (unint64_t)a2[2];
      if (v13 >= v14)
      {
        unint64_t v23 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v13 - (void)*a2) >> 3);
        unint64_t v24 = v23 + 1;
        if (v23 + 1 > 0x1AF286BCA1AF286LL) {
          sub_100007008();
        }
        unint64_t v25 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v14 - (void)*a2) >> 3);
        if (2 * v25 > v24) {
          unint64_t v24 = 2 * v25;
        }
        if (v25 >= 0xD79435E50D7943LL) {
          unint64_t v26 = 0x1AF286BCA1AF286LL;
        }
        else {
          unint64_t v26 = v24;
        }
        if (v26) {
          uint64_t v27 = (char *)sub_1005902BC((uint64_t)(a2 + 2), v26);
        }
        else {
          uint64_t v27 = 0LL;
        }
        int v28 = &v27[152 * v23];
        __int128 v29 = *(_OWORD *)&v55[16];
        *(_OWORD *)int v28 = *(_OWORD *)v55;
        *((_OWORD *)v28 + 1) = v29;
        __int128 v30 = *(_OWORD *)&v55[32];
        __int128 v31 = *(_OWORD *)&v55[48];
        __int128 v32 = v57;
        *((_OWORD *)v28 + 4) = v56;
        *((_OWORD *)v28 + 5) = v32;
        *((_OWORD *)v28 + 2) = v30;
        *((_OWORD *)v28 + 3) = v31;
        __int128 v33 = v58;
        __int128 v34 = v59[0];
        __int128 v35 = v59[1];
        *((void *)v28 + 1_Block_object_dispose(va, 8) = v60;
        *((_OWORD *)v28 + 7) = v34;
        *((_OWORD *)v28 + _Block_object_dispose(va, 8) = v35;
        *((_OWORD *)v28 + 6) = v33;
        __int128 v37 = *a2;
        std::stringbuf v36 = a2[1];
        BOOL v38 = v28;
        if (v36 != *a2)
        {
          do
          {
            __int128 v39 = *(_OWORD *)(v36 - 152);
            *(_OWORD *)(v38 - 136) = *(_OWORD *)(v36 - 136);
            *(_OWORD *)(v38 - 152) = v39;
            __int128 v40 = *(_OWORD *)(v36 - 120);
            __int128 v41 = *(_OWORD *)(v36 - 104);
            __int128 v42 = *(_OWORD *)(v36 - 88);
            *(_OWORD *)(v38 - 72) = *(_OWORD *)(v36 - 72);
            *(_OWORD *)(v38 - 8_Block_object_dispose(va, 8) = v42;
            *(_OWORD *)(v38 - 104) = v41;
            *(_OWORD *)(v38 - 120) = v40;
            __int128 v43 = *(_OWORD *)(v36 - 56);
            __int128 v44 = *(_OWORD *)(v36 - 40);
            __int128 v45 = *(_OWORD *)(v36 - 24);
            *((void *)v38 - 1) = *((void *)v36 - 1);
            *(_OWORD *)(v38 - 24) = v45;
            *(_OWORD *)(v38 - 40) = v44;
            *(_OWORD *)(v38 - 56) = v43;
            v38 -= 152;
            v36 -= 152;
          }

          while (v36 != v37);
          std::stringbuf v36 = *a2;
        }

        size_t v22 = v28 + 152;
        *a2 = v38;
        a2[1] = v28 + 152;
        a2[2] = &v27[152 * v26];
        if (v36) {
          operator delete(v36);
        }
      }

      else
      {
        __int128 v15 = *(_OWORD *)&v55[16];
        *(_OWORD *)unint64_t v13 = *(_OWORD *)v55;
        *(_OWORD *)(v13 + 16) = v15;
        __int128 v16 = *(_OWORD *)&v55[32];
        __int128 v17 = *(_OWORD *)&v55[48];
        __int128 v18 = v57;
        *(_OWORD *)(v13 + 64) = v56;
        *(_OWORD *)(v13 + 80) = v18;
        *(_OWORD *)(v13 + 32) = v16;
        *(_OWORD *)(v13 + 4_Block_object_dispose(va, 8) = v17;
        __int128 v19 = v58;
        __int128 v20 = v59[0];
        __int128 v21 = v59[1];
        *(void *)(v13 + 144) = v60;
        *(_OWORD *)(v13 + sub_10004AD90(v15 - 112) = v20;
        *(_OWORD *)(v13 + 12_Block_object_dispose(va, 8) = v21;
        *(_OWORD *)(v13 + 96) = v19;
        size_t v22 = (char *)(v13 + 152);
      }

      a2[1] = v22;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v46 = v50;
    uint64_t v50 = 0LL;
    if (v46) {
      (*(void (**)(uint64_t))(*(void *)v46 + 8LL))(v46);
    }
    *(void **)((char *)v51
    uint64_t v52 = v47;
    std::streambuf::~streambuf(&v53);
    return std::ios::~ios(&v54);
  }

  return result;
}

void sub_10058E6FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_1011F8850((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10058E76C(void *a1, void **a2, double a3, double a4)
{
  uint64_t v8 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v57);
  if ((SHIBYTE(v58) & 0x80000000) == 0)
  {
    if (HIBYTE(v58)) {
      goto LABEL_3;
    }
LABEL_40:
    sub_10123EE34(v8);
    __break(1u);
  }

  uint64_t v52 = v57[1];
  operator delete(v57[0]);
  if (!v52) {
    goto LABEL_40;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v57);
  uint64_t v9 = sub_10000CF44(&v58, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(__int128 *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if (v62[7] >= 0) {
    p_p = &__p;
  }
  else {
    p_p = (__int128 *)__p;
  }
  if (v62[7] >= 0) {
    uint64_t v11 = v62[7];
  }
  else {
    uint64_t v11 = *((void *)&__p + 1);
  }
  uint64_t v12 = sub_10000CF44(v9, (uint64_t)p_p, v11);
  sub_10000CF44(v12, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if ((v62[7] & 0x80000000) != 0) {
    operator delete((void *)__p);
  }
  uint64_t v13 = a1[10];
  std::stringbuf::str((std::stringbuf::string_type *)&__p, &v59);
  if (v62[7] >= 0) {
    unint64_t v14 = (char *)&__p;
  }
  else {
    unint64_t v14 = (char *)__p;
  }
  sub_1003C0D54(v13, v14, &v55);
  uint64_t v15 = v55;
  uint64_t v55 = 0LL;
  uint64_t v56 = v15;
  if ((v62[7] & 0x80000000) != 0) {
    operator delete((void *)__p);
  }
  __int128 v16 = (sqlite3_stmt *)sub_100019240(v15);
  if (sub_1003B7480(v16, 1, a3) && (__int128 v17 = (sqlite3_stmt *)sub_100019240(v15), sub_1003B7480(v17, 2, a4)))
  {
    __int128 __p = 0uLL;
    *(_DWORD *)uint64_t v62 = 3;
    uint64_t v67 = 0LL;
    memset(&v62[4], 0, 44);
    __int128 v64 = 0u;
    __int128 v65 = 0u;
    memset(v66, 0, 28);
    while (1)
    {
      uint64_t v18 = sub_1001BA11C((uint64_t)a1, &v56, (uint64_t)&__p);
      if ((_DWORD)v18) {
        break;
      }
      __int128 v19 = (char *)a2[1];
      __int128 v20 = (char *)a2[2];
      if (v19 >= v20)
      {
        unint64_t v29 = 0x86BCA1AF286BCA1BLL * ((v19 - (_BYTE *)*a2) >> 3);
        unint64_t v30 = v29 + 1;
        if (v29 + 1 > 0x1AF286BCA1AF286LL) {
          sub_100007008();
        }
        unint64_t v31 = 0x86BCA1AF286BCA1BLL * ((v20 - (_BYTE *)*a2) >> 3);
        if (2 * v31 > v30) {
          unint64_t v30 = 2 * v31;
        }
        if (v31 >= 0xD79435E50D7943LL) {
          unint64_t v32 = 0x1AF286BCA1AF286LL;
        }
        else {
          unint64_t v32 = v30;
        }
        if (v32) {
          __int128 v33 = (char *)sub_1005902BC((uint64_t)(a2 + 2), v32);
        }
        else {
          __int128 v33 = 0LL;
        }
        __int128 v34 = &v33[152 * v29];
        __int128 v35 = *(_OWORD *)v62;
        *(_OWORD *)__int128 v34 = __p;
        *((_OWORD *)v34 + 1) = v35;
        __int128 v36 = *(_OWORD *)&v62[16];
        __int128 v37 = *(_OWORD *)&v62[32];
        __int128 v38 = v64;
        *((_OWORD *)v34 + 4) = v63;
        *((_OWORD *)v34 + 5) = v38;
        *((_OWORD *)v34 + 2) = v36;
        *((_OWORD *)v34 + 3) = v37;
        __int128 v39 = v65;
        __int128 v40 = v66[0];
        __int128 v41 = v66[1];
        *((void *)v34 + 1_Block_object_dispose(va, 8) = v67;
        *((_OWORD *)v34 + 7) = v40;
        *((_OWORD *)v34 + _Block_object_dispose(va, 8) = v41;
        *((_OWORD *)v34 + 6) = v39;
        __int128 v43 = (char *)*a2;
        __int128 v42 = (char *)a2[1];
        __int128 v44 = v34;
        if (v42 != *a2)
        {
          do
          {
            __int128 v45 = *(_OWORD *)(v42 - 152);
            *(_OWORD *)(v44 - 136) = *(_OWORD *)(v42 - 136);
            *(_OWORD *)(v44 - 152) = v45;
            __int128 v46 = *(_OWORD *)(v42 - 120);
            __int128 v47 = *(_OWORD *)(v42 - 104);
            __int128 v48 = *(_OWORD *)(v42 - 88);
            *(_OWORD *)(v44 - 72) = *(_OWORD *)(v42 - 72);
            *(_OWORD *)(v44 - 8_Block_object_dispose(va, 8) = v48;
            *(_OWORD *)(v44 - 104) = v47;
            *(_OWORD *)(v44 - 120) = v46;
            __int128 v49 = *(_OWORD *)(v42 - 56);
            __int128 v50 = *(_OWORD *)(v42 - 40);
            __int128 v51 = *(_OWORD *)(v42 - 24);
            *((void *)v44 - 1) = *((void *)v42 - 1);
            *(_OWORD *)(v44 - 24) = v51;
            *(_OWORD *)(v44 - 40) = v50;
            *(_OWORD *)(v44 - 56) = v49;
            v44 -= 152;
            v42 -= 152;
          }

          while (v42 != v43);
          __int128 v42 = (char *)*a2;
        }

        int v28 = v34 + 152;
        *a2 = v44;
        a2[1] = v34 + 152;
        a2[2] = &v33[152 * v32];
        if (v42) {
          operator delete(v42);
        }
      }

      else
      {
        __int128 v21 = *(_OWORD *)v62;
        *(_OWORD *)__int128 v19 = __p;
        *((_OWORD *)v19 + 1) = v21;
        __int128 v22 = *(_OWORD *)&v62[16];
        __int128 v23 = *(_OWORD *)&v62[32];
        __int128 v24 = v64;
        *((_OWORD *)v19 + 4) = v63;
        *((_OWORD *)v19 + 5) = v24;
        *((_OWORD *)v19 + 2) = v22;
        *((_OWORD *)v19 + 3) = v23;
        __int128 v25 = v65;
        __int128 v26 = v66[0];
        __int128 v27 = v66[1];
        *((void *)v19 + 1_Block_object_dispose(va, 8) = v67;
        *((_OWORD *)v19 + 7) = v26;
        *((_OWORD *)v19 + _Block_object_dispose(va, 8) = v27;
        *((_OWORD *)v19 + 6) = v25;
        int v28 = v19 + 152;
      }

      a2[1] = v28;
    }

    uint64_t v15 = v56;
  }

  else
  {
    uint64_t v18 = 2LL;
  }

  uint64_t v56 = 0LL;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
  }
  *(void **)((char *)v57
  uint64_t v58 = v53;
  std::streambuf::~streambuf(&v59);
  std::ios::~ios(&v60);
  return v18;
}

void sub_10058EBA4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, void *__p, uint64_t a47, int a48, __int16 a49, char a50,char a51)
{
  if (a51 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t sub_10058EC14(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v38 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101840C78);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)__int128 v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      __int128 v44 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101840C78);
      }
      std::string::size_type v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)std::string buf = 134349056;
        *(void *)__int128 v42 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101840C78);
        }
        uint64_t v34 = *(void *)(a1 + 216);
        int v39 = 134349056;
        uint64_t v40 = v34;
        __int128 v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v39,  12);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::setDatabaseAccessible() [T = VO2MaxRetrocomputeH istory, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v35);
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101840C78);
    }
    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)std::string buf = 68289539;
      *(_DWORD *)__int128 v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      __int128 v44 = v11;
      __int16 v45 = 2049;
      uint64_t v46 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    unint64_t v13 = *(void *)(a1 + 208);
    uint64_t v14 = *(void *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 192);
    __int128 v16 = (void *)(v14 + 8 * (v13 / 0x1A));
    unsigned int v37 = v9;
    if (v15 == v14) {
      unint64_t v17 = 0LL;
    }
    else {
      unint64_t v17 = *v16 + 152 * (v13 % 0x1A);
    }
    while (1)
    {
      if (v15 == v14)
      {
        unint64_t v23 = 0LL;
      }

      else
      {
        unint64_t v22 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        unint64_t v23 = *(void *)(v14 + 8 * (v22 / 0x1A)) + 152 * (v22 % 0x1A);
      }

      if (v17 == v23) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_101840C98);
      }
      __int128 v24 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_101840C98);
        }
        LOWORD(v39) = 0;
        LODWORD(v36) = 2;
        __int128 v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v39,  v36);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::setDatabaseAccessible() [T = VO2MaxRetrocomputeH istory, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v26);
      }

      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v17, 1LL);
      v17 += 152LL;
      if (v17 - *v16 == 3952)
      {
        unint64_t v25 = v16[1];
        ++v16;
        unint64_t v17 = v25;
      }

      uint64_t v14 = *(void *)(a1 + 184);
      uint64_t v15 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    uint64_t v9 = v37;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101840C78);
    }
    uint64_t v18 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      __int128 v19 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)__int128 v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      __int128 v44 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101840C78);
      }
    }

    __int128 v20 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      __int128 v21 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289282;
      *(_DWORD *)__int128 v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      __int128 v44 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12_Block_object_dispose(va, 8) = 1;
  }

  __int128 v27 = *(void ***)(a1 + 184);
  uint64_t v28 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v29 = v28 - (void)v27;
  if (v29 >= 0x11)
  {
    do
    {
      operator delete(*v27);
      uint64_t v30 = *(void *)(a1 + 192);
      __int128 v27 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v27;
      unint64_t v29 = v30 - (void)v27;
    }

    while (v29 > 0x10);
  }

  if (v29 >> 3 == 1)
  {
    uint64_t v31 = 13LL;
  }

  else
  {
    if (v29 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v31 = 26LL;
  }

  *(void *)(a1 + 20_Block_object_dispose(va, 8) = v31;
LABEL_61:
  unint64_t v32 = *(void **)(a1 + 144);
  if (v32)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_10058F348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

__n128 sub_10058F37C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v3 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v3;
  __int128 v4 = *(_OWORD *)(a3 + 32);
  __int128 v5 = *(_OWORD *)(a3 + 48);
  __int128 v6 = *(_OWORD *)(a3 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(a2 + 80) = v6;
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)(a2 + 4_Block_object_dispose(va, 8) = v5;
  __n128 result = *(__n128 *)(a3 + 96);
  __int128 v8 = *(_OWORD *)(a3 + 112);
  __int128 v9 = *(_OWORD *)(a3 + 128);
  *(void *)(a2 + 144) = *(void *)(a3 + 144);
  *(_OWORD *)(a2 + sub_10004AD90(v15 - 112) = v8;
  *(_OWORD *)(a2 + 12_Block_object_dispose(va, 8) = v9;
  *(__n128 *)(a2 + 96) = result;
  return result;
}

id *sub_10058F3B0(uint64_t a1, uint64_t a2, char a3)
{
  v34[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v34[1] = 0LL;
  if (*(double *)(a1 + 232) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v34);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  uint64_t v43 = 0LL;
  double v44 = 0.0;
  int v45 = 3;
  uint64_t v51 = 0LL;
  __int128 v46 = 0u;
  memset(v47, 0, sizeof(v47));
  __int128 v49 = 0u;
  memset(v50, 0, sizeof(v50));
  __int128 v48 = 0u;
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 104LL))(a1, &v43);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101840C78);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101840C78);
        }
        LOWORD(v35) = 0;
        uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v35,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = V O2MaxRetrocomputeHistory, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v15);
      }

      goto LABEL_43;
    }

    double v7 = *(double *)(a2 + 8);
    double v8 = v44;
    double v9 = v7 - v44;
    if (v7 - v44 < 0.0) {
      double v9 = -(v7 - v44);
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101840C78);
      }
      uint64_t v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a2 + 8);
        *(_DWORD *)std::string buf = 134349312;
        double v40 = v44;
        __int16 v41 = 2050;
        uint64_t v42 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101840C78);
        }
        uint64_t v28 = *(void *)(a2 + 8);
        int v35 = 134349312;
        double v36 = v44;
        __int16 v37 = 2050;
        uint64_t v38 = v28;
        unint64_t v29 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v35,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = V O2MaxRetrocomputeHistory, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v29);
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *(double *)(a2 + 8);
      double v8 = v44;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101840C78);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *(double *)(a2 + 8);
          *(_DWORD *)std::string buf = 134217984;
          double v40 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_101840C78);
          }
          double v30 = *(double *)(a2 + 8);
          int v35 = 134217984;
          double v36 = v30;
          uint64_t v31 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v35));
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = VO2MaxRetrocomputeHistory, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v31);
        }

        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v16 = v7 - v8;
      double v17 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v33 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_101840C78);
        double v17 = v33;
      }

      double v18 = v16 - v17;
      __int128 v19 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)std::string buf = 134217984;
        double v40 = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101840C78);
        }
        int v35 = 134217984;
        double v36 = v18;
        unint64_t v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v35));
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxRetrocomputeHistory>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = V O2MaxRetrocomputeHistory, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v32);
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v18);
    }

    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, &v43, a1 + 224, a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_10058FB44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_10058FB70(void *a1, uint64_t a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    __int128 v20 = (_Unwind_Exception *)sub_10123EFA0(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  __int128 v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 8)))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_10058FDD0(void *a1, double a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_10123F10C(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_100590008(void *a1, uint64_t a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_10123F278(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  __int128 v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  double v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

uint64_t sub_100590230(uint64_t a1)
{
  return sub_10058EC14(a1 - 72);
}

void sub_100590238(id a1)
{
  qword_1019346E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "VO2Max");
}

void sub_100590264(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_100590290(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

void *sub_1005902BC(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1AF286BCA1AF287LL) {
    sub_1000070D4();
  }
  return operator new(152 * a2);
}

uint64_t sub_10059081C@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  return sub_1002DC708((uint64_t)(a2 + 754), a1 + 3016);
}

void sub_100590868(_Unwind_Exception *a1)
{
}

_DWORD *sub_10059087C(_DWORD *a1, uint64_t a2)
{
  __int128 v4 = sub_1002E0454(a1);
  sub_1002DCA80((uint64_t)v4, a2);
  sub_1002DC4C4((uint64_t)(a1 + 202), a2 + 808);
  sub_1002DC708((uint64_t)(a1 + 754), a2 + 3016);
  return a1;
}

void sub_1005908C4(_Unwind_Exception *a1)
{
}

uint64_t sub_1005908D8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 6472) + 32LL))(*(void *)(a1 + 6472), a2);
}

void sub_100590924(_Unwind_Exception *a1)
{
}

uint64_t sub_100590938@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 6472) + 40LL))(*(void *)(a1 + 6472), a2);
}

void sub_100590984(_Unwind_Exception *a1)
{
}

void sub_100590998(uint64_t *a1@<X0>, int *a2@<X1>, _DWORD *a3@<X8>)
{
  uint64_t v5 = *a1;
  int v6 = (std::__shared_weak_count *)a1[1];
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  sub_1002E1330((uint64_t)v12, (uint64_t)a2);
  v14[432] = v5;
  uint64_t v15 = v6;
  sub_100590B0C(a2, (uint64_t)v12, a3);
  uint64_t v9 = v15;
  if (v15)
  {
    uint64_t v10 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  sub_1002E1244((uint64_t)v14);
  sub_1002E1094((uint64_t)&v13);
  sub_1002DDAD8((uint64_t)v12);
}

void sub_100590AE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100590B0C@<X0>(int *a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  uint64_t v3 = (uint64_t)(a1 + 2);
  switch(*a1 ^ (*a1 >> 31))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x15:
    case 0x16:
    case 0x17:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
      uint64_t result = (uint64_t)sub_10059087C(a3, a2);
      break;
    case 7:
      uint64_t result = sub_100590938(a2, v3, a3);
      break;
    case 0x14:
      uint64_t result = sub_1005908D8(a2, v3, a3);
      break;
    default:
      sub_1002DDAB0();
  }

  return result;
}

void sub_100590B70()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361B8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361B8))
    {
      qword_1019361A0 = 0LL;
      qword_1019361A8 = 0LL;
      qword_1019361B0 = 0LL;
      uint64_t v1 = operator new(6uLL);
      qword_1019361A8 = (uint64_t)(v1 + 3);
      qword_1019361B0 = (uint64_t)(v1 + 3);
      *(_DWORD *)uint64_t v1 = 151521030;
      v1[2] = 3082;
      qword_1019361A0 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1001CDCD0, &qword_1019361A0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361B8);
    }
  }

void sub_100590C0C(_Unwind_Exception *a1)
{
}

void sub_100590C24()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361D8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361D8))
    {
      qword_1019361C0 = 0LL;
      qword_1019361C8 = 0LL;
      qword_1019361D0 = 0LL;
      uint64_t v1 = operator new(2uLL);
      qword_1019361C0 = (uint64_t)v1;
      *uint64_t v1 = 256;
      qword_1019361C8 = (uint64_t)(v1 + 1);
      qword_1019361D0 = (uint64_t)(v1 + 1);
      __cxa_atexit((void (*)(void *))sub_1001CDD00, &qword_1019361C0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361D8);
    }
  }

void sub_100590CB0(_Unwind_Exception *a1)
{
}

id sub_100590E3C(id a1, SEL a2, id a3, id a4)
{
  if (a4)
  {
    if (objc_msgSend(objc_msgSend(a3, "departureDate"), "compare:", objc_msgSend(a3, "arrivalDate")) == (id)-1)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101840D40);
      }
      uint64_t v17 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        int v19 = 68289283;
        int v20 = 0;
        __int16 v21 = 2082;
        uint64_t v22 = "";
        __int16 v23 = 2113;
        id v24 = a3;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#slv Malformed visit, visit:%{private, location:escape_only}@}",  (uint8_t *)&v19,  0x1Cu);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101840D40);
        }
      }

      uint64_t v18 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        int v19 = 68289283;
        int v20 = 0;
        __int16 v21 = 2082;
        uint64_t v22 = "";
        __int16 v23 = 2113;
        id v24 = a3;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#slv Malformed visit",  "{msg%{public}.0s:#slv Malformed visit, visit:%{private, location:escape_only}@}",  (uint8_t *)&v19,  0x1Cu);
      }
    }

    else
    {
      id v6 = objc_msgSend(a4, "compare:", objc_msgSend(a3, "departureDate"));
      id v7 = objc_msgSend(a4, "compare:", objc_msgSend(a3, "arrivalDate"));
      unint64_t v8 = 0LL;
      unint64_t v9 = 0LL;
      if ([a3 hasDepartureDate])
      {
        if (v6 == (id)-1LL) {
          unint64_t v9 = (unint64_t)[a3 departureDate];
        }
      }

      if (v8 | v9)
      {
        uint64_t v10 = objc_alloc(&OBJC_CLASS___CLVisit);
        [a3 coordinate];
        double v12 = v11;
        double v14 = v13;
        [a3 horizontalAccuracy];
        return  -[CLVisit initWithCoordinate:horizontalAccuracy:arrivalDate:departureDate:detectionDate:placeInference:]( v10,  "initWithCoordinate:horizontalAccuracy:arrivalDate:departureDate:detectionDate:placeInference:",  v8,  v9,  [a3 detectionDate],  objc_msgSend(a3, "_placeInference"),  v12,  v14,  v15);
      }
    }
  }

  return 0LL;
}

void sub_1005911D0(id a1)
{
  qword_101996E60 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLSignificantVisitManagerSilo");
}

void sub_1005917DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_100591840(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(a1 + 32) settingsDidChange:a2];
}

void sub_10059184C(uint64_t a1, unsigned int *a2, uint64_t a3, void *a4)
{
  uint64_t v6 = *a2;
  sub_1011F69B0((char *)v7, (__int128 *)a3);
  uint64_t v21 = *(void *)(a3 + 184);
  [a4 onClientManagerNotification:v6 data:v7];
  if (v20 < 0) {
    operator delete(__p);
  }
  if (v18 < 0) {
    operator delete(v17);
  }
  if (v16 < 0) {
    operator delete(v15);
  }
  if (v14 < 0) {
    operator delete(v13);
  }
  if (v12 < 0) {
    operator delete(v11);
  }
  if (v10 < 0) {
    operator delete(v9);
  }
  if (v8 < 0) {
    operator delete(v7[0]);
  }
}

void sub_100591914( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id sub_100591928(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100595A94;
  void v3[3] = &unk_10181A288;
  void v3[4] = v1;
  return objc_msgSend(objc_msgSend(objc_msgSend(v1, "universe"), "silo"), "async:", v3);
}

id sub_100591990(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100595A9C;
  void v3[3] = &unk_10181A288;
  void v3[4] = v1;
  return objc_msgSend(objc_msgSend(objc_msgSend(v1, "universe"), "silo"), "async:", v3);
}

id sub_1005919F8(uint64_t a1)
{
  return [*(id *)(a1 + 32) checkForMonitoring];
}

BOOL sub_100592590(id a1, id a2, NSDictionary *a3)
{
  double v5 = v4;
  if (v4 <= -15.0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101840D40);
    }
    uint64_t v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      v8[0] = 68289283;
      v8[1] = 0;
      __int16 v9 = 2082;
      char v10 = "";
      __int16 v11 = 2113;
      id v12 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#slv Dropping old visit, visit:%{private, location:escape_only}@}",  (uint8_t *)v8,  0x1Cu);
    }
  }

  return v5 > -15.0;
}

void sub_100592C5C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) keyForClient:*(void *)(a1 + 40)];
  if (v2)
  {
    uint64_t v3 = v2;
    if ([*(id *)(a1 + 32) isClientWithKeyInterested:v2])
    {
      id v4 = [*(id *)(a1 + 32) authorizationDateForClientWithKey:v3];
      id v5 = +[CLVisit _visitWithVisit:authDate:]( &OBJC_CLASS___CLVisit,  "_visitWithVisit:authDate:",  *(void *)(a1 + 48),  v4);
      if (v5)
      {
        id v6 = v5;
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101840D40);
        }
        id v7 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          id v8 = [v3 UTF8String];
          [v4 timeIntervalSinceReferenceDate];
          int v20 = 68289795;
          int v21 = 0;
          __int16 v22 = 2082;
          __int16 v23 = "";
          __int16 v24 = 2082;
          id v25 = v8;
          __int16 v26 = 2050;
          uint64_t v27 = v9;
          __int16 v28 = 2113;
          id v29 = v6;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#slv Delivering visit to client, key:%{public, location:escape_only}s, authDa te_s:%{public}.09f, mangled:%{private, location:escape_only}@}",  (uint8_t *)&v20,  0x30u);
        }

        [*(id *)(a1 + 40) onSignificantLocationVisit:v6];
        return;
      }

      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101840D40);
      }
      uint64_t v17 = qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        id v18 = [v3 UTF8String];
        [v4 timeIntervalSinceReferenceDate];
        int v20 = 68289538;
        int v21 = 0;
        __int16 v22 = 2082;
        __int16 v23 = "";
        __int16 v24 = 2082;
        id v25 = v18;
        __int16 v26 = 2050;
        uint64_t v27 = v19;
        double v13 = "{msg%{public}.0s:#slv Client not authorized for visit, key:%{public, location:escape_only}s, "
              "authDate_s:%{public}.09f}";
        char v14 = (os_log_s *)v17;
        os_log_type_t v15 = OS_LOG_TYPE_DEFAULT;
        uint32_t v16 = 38;
        goto LABEL_24;
      }
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101840D40);
      }
      uint64_t v12 = qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        int v20 = 68289282;
        int v21 = 0;
        __int16 v22 = 2082;
        __int16 v23 = "";
        __int16 v24 = 2082;
        id v25 = [v3 UTF8String];
        double v13 = "{msg%{public}.0s:#slv Not delivering visit to client... not interested, key:%{public, location:escape_only}s}";
        char v14 = (os_log_s *)v12;
        os_log_type_t v15 = OS_LOG_TYPE_DEBUG;
        uint32_t v16 = 28;
LABEL_24:
        _os_log_impl((void *)&_mh_execute_header, v14, v15, v13, (uint8_t *)&v20, v16);
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101840D40);
    }
    char v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      int v20 = 68289026;
      int v21 = 0;
      __int16 v22 = 2082;
      __int16 v23 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#slv Cannot deliver a visit to a client without a key}",  (uint8_t *)&v20,  0x12u);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101840D40);
      }
    }

    __int16 v11 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      int v20 = 68289026;
      int v21 = 0;
      __int16 v22 = 2082;
      __int16 v23 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v11,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#slv Cannot deliver a visit to a client without a key",  "{msg%{public}.0s:#slv Cannot deliver a visit to a client without a key}",  (uint8_t *)&v20,  0x12u);
    }
  }

void sub_1005935E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100593990(uint64_t a1, uint64_t a2)
{
  return sub_10054BBF8( a2,  (uint64_t)+[CLClientKeyPath clientKeyPathWithLegacyClientKey:]( &OBJC_CLASS___CLClientKeyPath,  "clientKeyPathWithLegacyClientKey:",  *(void *)(a1 + 32)),  0);
}

id sub_1005939CC(uint64_t a1)
{
  int v3 = 0;
  id result = objc_msgSend( *(id *)(a1 + 32),  "interestForClientKey:outInterest:",  objc_msgSend(*(id *)(a1 + 40), "UTF8String"),  &v3);
  if (v3 == 2)
  {
    sub_1002A667C( (uint64_t)[*(id *)(a1 + 32) clientInterest],  (const char *)objc_msgSend(*(id *)(a1 + 40), "UTF8String"),  0xFFFFFFFFLL);
    sub_1002A667C( (uint64_t)[*(id *)(a1 + 32) clientAuthDate],  (const char *)objc_msgSend(*(id *)(a1 + 40), "UTF8String"),  0xFFFFFFFFLL);
    return [*(id *)(a1 + 32) flushAll];
  }

  return result;
}

void sub_100593C74(uint64_t a1)
{
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101840D40);
  }
  int v3 = &OBJC_METACLASS___CLPrivacyManager.vtable;
  id v4 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    *(_DWORD *)std::string buf = 68289283;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v36 = 2082;
    __int16 v37 = "";
    __int16 v38 = 2113;
    uint64_t v39 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#slv Sending out visit, visit:%{private, location:escape_only}@}",  buf,  0x1Cu);
  }

  objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "recentVisits"), "addObject:", *(void *)(a1 + 32));
  id v6 = objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "universe"), "vendor"),  "proxyForService:",  @"CLApplicationLifecycleManager");
  uint64_t v32 = 0LL;
  uint64_t v33 = 0LL;
  uint64_t v34 = 0LL;
  sub_1002A6CEC((uint64_t)[*(id *)(a1 + 40) clientInterest], &v32);
  uint64_t v8 = v32;
  if (v32 != v33)
  {
    *(void *)&__int128 v7 = 68289794LL;
    __int128 v31 = v7;
    do
    {
      uint64_t v9 = v8;
      unsigned int v10 = objc_msgSend( *(id *)(a1 + 40),  "isClientWithKeyInterested:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9, v31));
      uint64_t v11 = v8;
      id v12 = objc_msgSend( *(id *)(a1 + 40),  "authorizationDateForClientWithKey:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v11));
      if (v12) {
        unsigned int v13 = v10;
      }
      else {
        unsigned int v13 = 0;
      }
      char v14 = p_vtable[304];
      if (v13 == 1)
      {
        os_log_type_t v15 = (os_log_s *)v3[305];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
        {
          uint64_t v16 = v8;
          *(_DWORD *)std::string buf = 68289282;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v36 = 2082;
          __int16 v37 = "";
          __int16 v38 = 2082;
          uint64_t v39 = v16;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#slv Launching, key:%{public, location:escape_only}s}",  buf,  0x1Cu);
        }

        uint64_t v17 = v8;
        objc_msgSend( v6,  "launchApplication:requiringAuthForServiceMask:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v17),  64);
      }

      else
      {
        id v18 = (os_log_s *)v3[305];
        if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          id v19 = v6;
          int v20 = v3;
          int v21 = p_vtable;
          uint64_t v22 = v8;
          [v12 timeIntervalSinceReferenceDate];
          *(_DWORD *)std::string buf = v31;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v36 = 2082;
          __int16 v37 = "";
          __int16 v38 = 2082;
          uint64_t v39 = v22;
          __int16 v40 = 1026;
          unsigned int v41 = v10;
          __int16 v42 = 2050;
          uint64_t v43 = v23;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#slv Client not eligible to receive visit, key:%{public, location:escape_only}s , interested:%{public}hhd, authDate_s:%{public}.09f}",  buf,  0x2Cu);
          p_vtable = v21;
          int v3 = v20;
          id v6 = v19;
        }
      }

      v8 += 24LL;
    }

    while (v8 != v33);
  }

  __int16 v24 = (os_log_s *)v3[305];
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v25 = *(void *)(a1 + 32);
    *(_DWORD *)std::string buf = 68289283;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v36 = 2082;
    __int16 v37 = "";
    __int16 v38 = 2113;
    uint64_t v39 = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#slv Sending to clients, visit:%{private, location:escape_only}@}",  buf,  0x1Cu);
  }

  __int16 v26 = *(void **)(a1 + 40);
  uint64_t v27 = (void *)v26[2];
  if (v27 != v26 + 3)
  {
    do
    {
      [v26 deliverVisit:*(void *)(a1 + 32) toClient:v27[4]];
      __int16 v28 = (void *)v27[1];
      if (v28)
      {
        do
        {
          id v29 = v28;
          __int16 v28 = (void *)*v28;
        }

        while (v28);
      }

      else
      {
        do
        {
          id v29 = (void *)v27[2];
          BOOL v30 = *v29 == (void)v27;
          uint64_t v27 = v29;
        }

        while (!v30);
      }

      __int16 v26 = *(void **)(a1 + 40);
      uint64_t v27 = v29;
    }

    while (v29 != v26 + 3);
  }

  *(void *)std::string buf = &v32;
  sub_1000129D4((void ***)buf);
}

void sub_1005940FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void **a17)
{
  a17 = (void **)&a14;
  sub_1000129D4(&a17);
  _Unwind_Resume(a1);
}

void sub_100594914( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, char a36, uint64_t a37, uint64_t a38, void **a39)
{
  a39 = (void **)&a36;
  sub_1000129D4(&a39);
  _Unwind_Resume(a1);
}

void sub_100594EB8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, void **a19)
{
  a19 = (void **)&a16;
  sub_1000129D4(&a19);
  _Unwind_Resume(a1);
}

void sub_100595014( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005950C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100595578( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_100595A3C(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void sub_100595A68(id a1)
{
  qword_1019349F8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Simulation");
}

id sub_100595A94(uint64_t a1)
{
  return _[*(id *)(a1 + 32) onInterestStoreTimer];
}

id sub_100595A9C(uint64_t a1)
{
  return _[*(id *)(a1 + 32) onAuthDateStoreTimer];
}

uint64_t *sub_100595AA4(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  __int128 v7 = a1 + 1;
  id v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        id v6 = *v9;
        __int128 v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      id v6 = v9[1];
      if (!v6)
      {
        __int128 v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    void v11[5] = 0LL;
    sub_1000085FC(a1, (uint64_t)v9, v7, v11);
    return v11;
  }

  return (uint64_t *)v9;
}

void sub_100595B60()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_1012F11C0;
      v1[3] = unk_1012F11D0;
      v1[4] = xmmword_1012F11E0;
      v1[0] = xmmword_1012F11A0;
      v1[1] = unk_1012F11B0;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_100595C34(_Unwind_Exception *a1)
{
}

uint64_t sub_100595C4C()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, &stru_101996E48, (void *)&_mh_execute_header);
}

uint64_t sub_100595C90(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = sub_100C0CA10(a1, a2, a3, a4);
  *(void *)uint64_t v5 = off_101840D90;
  *(void *)(v5 + 304) = "";
  *(_WORD *)(v5 + 312) = 0;
  *(void *)(a1 + 320) = nullsub_10(0LL);
  return a1;
}

void sub_100595CDC(_Unwind_Exception *a1)
{
}

uint64_t sub_100595CF0(uint64_t a1, size_t *a2, int *a3)
{
  id v6 = (const std::string *)(a1 + 8);
  __int128 v7 = (const char *)(a1 + 8);
  if (sub_100292D28(v7))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    unint64_t v8 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = a1 + 8;
      *(_DWORD *)std::string buf = 136315138;
      size_t v83 = (std::string *)v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "TILE: mmapTile, prefer local file name because it exists, %s",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101840E58);
      }
      uint64_t v47 = a1 + 8;
      int v78 = 136315138;
      __int16 v79 = (std::string *)v47;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: mmapTile, prefer local file name because it exists, %s",  (const char *)&v78);
      __int128 v49 = (uint8_t *)v48;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void *CLTileFileWithTraversal::mmapTile(size_t &, int &)", "%s\n", v48);
      if (v49 != buf) {
        free(v49);
      }
    }

    std::string::operator=(&v76, v6);
  }

  if ((v76.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    unint64_t v10 = &v76;
  }
  else {
    unint64_t v10 = (std::string *)v76.__r_.__value_.__r.__words[0];
  }
  int v11 = open((const char *)v10, 0);
  *a3 = v11;
  if (v11 < 0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    uint64_t v23 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      if ((v76.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v24 = &v76;
      }
      else {
        __int16 v24 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      int v25 = *__error();
      __int16 v26 = __error();
      uint64_t v27 = strerror(*v26);
      *(_DWORD *)std::string buf = 136315650;
      size_t v83 = v24;
      __int16 v84 = 1024;
      *(_DWORD *)__int16 v85 = v25;
      *(_WORD *)&v85[4] = 2080;
      *(void *)&v85[6] = v27;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_FAULT,  "TILE: mmapTile, can't open, %s, errno, %d, %s",  buf,  0x1Cu);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_60;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    uint64_t v28 = qword_101934A78;
    if ((v76.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      id v29 = &v76;
    }
    else {
      id v29 = (std::string *)v76.__r_.__value_.__r.__words[0];
    }
    int v30 = *__error();
    __int128 v31 = __error();
    uint64_t v32 = strerror(*v31);
    int v78 = 136315650;
    __int16 v79 = v29;
    __int16 v80 = 1024;
    *(_DWORD *)int v81 = v30;
    *(_WORD *)&v81[4] = 2080;
    *(void *)&v81[6] = v32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v28,  17LL,  "TILE: mmapTile, can't open, %s, errno, %d, %s",  (const char *)&v78,  28,  v75);
    uint64_t v34 = (uint8_t *)v33;
    sub_10029211C("Generic", 1LL, 0, 0LL, "void *CLTileFileWithTraversal::mmapTile(size_t &, int &)", "%s\n", v33);
    goto LABEL_88;
  }

  if (fstat(v11, &v77) == -1)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    int v35 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      if ((v76.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v36 = &v76;
      }
      else {
        __int16 v36 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      int v37 = *__error();
      __int16 v38 = __error();
      uint64_t v39 = strerror(*v38);
      *(_DWORD *)std::string buf = 136315650;
      size_t v83 = v36;
      __int16 v84 = 1024;
      *(_DWORD *)__int16 v85 = v37;
      *(_WORD *)&v85[4] = 2080;
      *(void *)&v85[6] = v39;
      _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_FAULT,  "TILE: can't stat, %s, errno, %d, %s",  buf,  0x1Cu);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_60;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    uint64_t v50 = qword_101934A78;
    if ((v76.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v51 = &v76;
    }
    else {
      uint64_t v51 = (std::string *)v76.__r_.__value_.__r.__words[0];
    }
    int v52 = *__error();
    uint64_t v53 = __error();
    uint64_t v54 = strerror(*v53);
    int v78 = 136315650;
    __int16 v79 = v51;
    __int16 v80 = 1024;
    *(_DWORD *)int v81 = v52;
    *(_WORD *)&v81[4] = 2080;
    *(void *)&v81[6] = v54;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v50,  17LL,  "TILE: can't stat, %s, errno, %d, %s",  (const char *)&v78,  28,  v75);
    uint64_t v34 = (uint8_t *)v55;
    sub_10029211C("Generic", 1LL, 0, 0LL, "void *CLTileFileWithTraversal::mmapTile(size_t &, int &)", "%s\n", v55);
LABEL_88:
    if (v34 != buf) {
      free(v34);
    }
LABEL_60:
    uint64_t v12 = 0LL;
    *a2 = 0LL;
    goto LABEL_61;
  }

  *a2 = 0LL;
  uint64_t v12 = (uint64_t)mmap(0LL, v77.st_size, 1, 2, *a3, 0LL);
  st_uint64_t size = v77.st_size;
  int v14 = fstat(*a3, &v77);
  BOOL v15 = v14 != -1;
  if (v14 == -1)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101840E78);
    }
    uint64_t v16 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_FAULT))
    {
      if ((v76.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v17 = &v76;
      }
      else {
        uint64_t v17 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      int v18 = *__error();
      id v19 = __error();
      int v20 = strerror(*v19);
      *(_DWORD *)std::string buf = 136446722;
      size_t v83 = v17;
      __int16 v84 = 1026;
      *(_DWORD *)__int16 v85 = v18;
      *(_WORD *)&v85[4] = 2082;
      *(void *)&v85[6] = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_FAULT,  "TILE: can't stat, %{public}s, errno, %{public}d, %{public}s",  buf,  0x1Cu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101840E78);
      }
      uint64_t v59 = qword_101934858;
      if ((v76.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v60 = &v76;
      }
      else {
        uint64_t v60 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      int v61 = *__error();
      uint64_t v62 = __error();
      __int128 v63 = strerror(*v62);
      int v78 = 136446722;
      __int16 v79 = v60;
      __int16 v80 = 1026;
      *(_DWORD *)int v81 = v61;
      *(_WORD *)&v81[4] = 2082;
      *(void *)&v81[6] = v63;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v59,  17LL,  "TILE: can't stat, %{public}s, errno, %{public}d, %{public}s",  &v78,  28);
      __int128 v65 = (uint8_t *)v64;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void *CLTileFileWithTraversal::mmapTile(size_t &, int &)", "%s\n", v64);
      if (v65 != buf) {
        free(v65);
      }
    }
  }

  if (st_size != v77.st_size)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101840E78);
    }
    int v21 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_FAULT))
    {
      uint64_t v22 = &v76;
      if ((v76.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v22 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 136446722;
      size_t v83 = v22;
      __int16 v84 = 2050;
      *(void *)__int16 v85 = st_size;
      *(_WORD *)&v85[8] = 2050;
      *(void *)&v85[10] = v77.st_size;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_FAULT,  "TILE: mmap file size changed, %{public}s, size before mmap, %{public}ld, size after mmap, %{public}lld",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_101840E78);
      }
      uint64_t v56 = &v76;
      if ((v76.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v56 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      int v78 = 136446722;
      __int16 v79 = v56;
      __int16 v80 = 2050;
      *(void *)int v81 = st_size;
      *(_WORD *)&v81[8] = 2050;
      *(void *)&v81[10] = v77.st_size;
      LODWORD(v74) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  17LL,  "TILE: mmap file size changed, %{public}s, size before mmap, %{public}ld, size after mmap, %{public}lld",  &v78,  v74);
      uint64_t v58 = (uint8_t *)v57;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void *CLTileFileWithTraversal::mmapTile(size_t &, int &)", "%s\n", v57);
      if (v58 != buf) {
        free(v58);
      }
    }

    BOOL v15 = 0;
  }

  *a2 = v77.st_size;
  if (v12 == -1)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    unsigned int v41 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      if ((v76.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v42 = &v76;
      }
      else {
        __int16 v42 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      off_t v43 = v77.st_size;
      int v44 = *__error();
      int v45 = __error();
      __int128 v46 = strerror(*v45);
      *(_DWORD *)std::string buf = 136315906;
      size_t v83 = v42;
      __int16 v84 = 2048;
      *(void *)__int16 v85 = v43;
      *(_WORD *)&v85[8] = 1024;
      *(_DWORD *)&v85[10] = v44;
      *(_WORD *)&v85[14] = 2080;
      *(void *)&v85[16] = v46;
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "TILE: mmap failed, %s, size, %lld, errno, %d, %s",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101840E58);
      }
      uint64_t v66 = qword_101934A78;
      if ((v76.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v67 = &v76;
      }
      else {
        uint64_t v67 = (std::string *)v76.__r_.__value_.__r.__words[0];
      }
      off_t v68 = v77.st_size;
      int v69 = *__error();
      uint64_t v70 = __error();
      int v71 = strerror(*v70);
      int v78 = 136315906;
      __int16 v79 = v67;
      __int16 v80 = 2048;
      *(void *)int v81 = v68;
      *(_WORD *)&v81[8] = 1024;
      *(_DWORD *)&v81[10] = v69;
      *(_WORD *)&v81[14] = 2080;
      *(void *)&v81[16] = v71;
      LODWORD(v74) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v66,  17LL,  "TILE: mmap failed, %s, size, %lld, errno, %d, %s",  (const char *)&v78,  v74,  (_DWORD)v75,  v76.__r_.__value_.__l.__data_);
      size_t v73 = (uint8_t *)v72;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void *CLTileFileWithTraversal::mmapTile(size_t &, int &)", "%s\n", v72);
      if (v73 != buf) {
        free(v73);
      }
    }

    uint64_t v12 = -1LL;
  }

  else if (v15)
  {
    goto LABEL_64;
  }

void sub_1005968D4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100596934(int a1, void *a2, size_t a3, int a4)
{
  if ((a4 & 0x80000000) == 0) {
    uint64_t result = close(a4);
  }
  if (a2) {
    return munmap(a2, a3);
  }
  return result;
}

uint64_t sub_100596978(uint64_t a1, uint64_t a2)
{
  id v4 = (_OWORD *)(a2 + 24);
  uint64_t v5 = sub_100595CF0(a1, (size_t *)(a2 + 24), (int *)(a2 + 32));
  *(void *)(a2 + 40) = v5;
  if (v5) {
    BOOL v6 = *(void *)(a2 + 24) == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  uint64_t v7 = !v6;
  if (v6)
  {
    sub_1010DDBC0(&v10, "");
    *(void *)&__int128 v11 = 0LL;
    DWORD2(v11) = -1;
    __int128 v12 = 0uLL;
    *(std::string *)a2 = v10;
    __int128 v8 = v12;
    *id v4 = v11;
    v4[1] = v8;
  }

  else
  {
    *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
    sub_100C0FCEC(a1, &v10);
    *(std::string *)a2 = v10;
  }

  return v7;
}

uint64_t sub_100596A58(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a2 + 40);
  if (v2)
  {
    uint64_t v5 = (_OWORD *)(a2 + 24);
    size_t v4 = *(void *)(a2 + 24);
    int v6 = *(_DWORD *)(a2 + 32);
    if ((v6 & 0x80000000) == 0) {
      close(v6);
    }
    munmap(v2, v4);
    sub_1010DDBC0(&v9, "");
    *(void *)&__int128 v11 = 0LL;
    DWORD2(v11) = -1;
    __int128 v12 = 0uLL;
    *(_OWORD *)a2 = v9;
    *(void *)(a2 + 16) = v10;
    __int128 v7 = v12;
    _OWORD *v5 = v11;
    v5[1] = v7;
  }

  return 1LL;
}

uint64_t sub_100596B00(uint64_t a1, void *a2, _DWORD *a3)
{
  unint64_t v4 = a2[6];
  unint64_t v5 = a2[3];
  if (v4 >= v5)
  {
    uint64_t result = 0LL;
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 43962;
  }

  else if (v5 >= v4 + 12)
  {
    sub_1009831E8((unsigned __int16 *)(a2[5] + v4), (uint64_t)a3);
    a2[6] += a3[1] + (unint64_t)a3[2] + 12;
    return 1LL;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    __int128 v8 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v9 = a2[3];
      uint64_t v10 = a2[6];
      *(_DWORD *)std::string buf = 134218496;
      uint64_t v23 = v9;
      __int16 v24 = 2048;
      uint64_t v25 = v10;
      __int16 v26 = 1024;
      int v27 = 12;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "TILE: corrupt header, fileGetNextSection, size, %zd, readto, %lld, %d",  buf,  0x1Cu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101840E58);
      }
      uint64_t v12 = a2[3];
      uint64_t v13 = a2[6];
      int v16 = 134218496;
      uint64_t v17 = v12;
      __int16 v18 = 2048;
      uint64_t v19 = v13;
      __int16 v20 = 1024;
      int v21 = 12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "TILE: corrupt header, fileGetNextSection, size, %zd, readto, %lld, %d",  (size_t)&v16,  28);
      BOOL v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTileFileWithTraversal::fileGetNextSection(CLMappedFile &, CLTilesManager_Type::SectionHeader &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    sub_100C15724(a1);
    return 0LL;
  }

  return result;
}

uint64_t sub_100596D68(uint64_t a1, FILE *a2, uint64_t *a3)
{
  uint64_t v5 = a1;
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v106 = v6;
  (*(void (**)(uint64_t))(*(void *)v6 + 16LL))(v6);
  __int16 v107 = 256;
  uint64_t v7 = a3[2];
  *(_OWORD *)(v5 + 304) = *(_OWORD *)a3;
  *(void *)(v5 + 320) = v7;
  *(_BYTE *)(v5 + 296) = 1;
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  uint64_t v9 = &OBJC_METACLASS___CLPrivacyManager.vtable;
  uint64_t v10 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v11 = *a3;
    int v12 = *((unsigned __int8 *)a3 + 8);
    int v13 = *((unsigned __int8 *)a3 + 9);
    *(_DWORD *)std::string buf = 136315906;
    *(void *)v131 = v11;
    *(_WORD *)&v131[8] = 1024;
    *(_DWORD *)&v131[10] = v12;
    *(_WORD *)&v131[14] = 1024;
    *(_DWORD *)&v131[16] = v13;
    *(_WORD *)&_BYTE v131[20] = 2048;
    *(void *)&v131[22] = sub_1005B46E8((uint64_t)(a3 + 2));
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "TILE: traverseTileFile, start, message, %s, isHeadersOnly, %d, isBinarySearch, %d, macAddressToSearch, %012llx",  buf,  0x22u);
    uint64_t v9 = &OBJC_METACLASS___CLPrivacyManager.vtable;
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    uint64_t v81 = qword_101934A78;
    uint64_t v82 = *a3;
    int v83 = *((unsigned __int8 *)a3 + 8);
    int v84 = *((unsigned __int8 *)a3 + 9);
    LODWORD(v129[0]) = 136315906;
    *(void *)((char *)v129 + 4) = v82;
    WORD6(v129[0]) = 1024;
    *(_DWORD *)((char *)v129 + 14) = v83;
    WORD1(v129[1]) = 1024;
    DWORD1(v129[1]) = v84;
    WORD4(v129[1]) = 2048;
    *(void *)((char *)&v129[1] + 10) = sub_1005B46E8((uint64_t)(a3 + 2));
    __int16 v85 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v81,  2LL,  "TILE: traverseTileFile, start, message, %s, isHeadersOnly, %d, isBinarySearch, %d, macAddressToSearch, %012llx",  (const char *)v129,  34,  v94,  v96);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLTileFileWithTraversal::traverseTileFile(FILE *, const TraverseDetails &)",  "%s\n",  v85);
    uint64_t v9 = &OBJC_METACLASS___CLPrivacyManager.vtable;
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  }

  if (!a2)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    int v16 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_FAULT,  "TILE: traverseTileFile, can't open tile",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_21;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    LOWORD(v129[0]) = 0;
    LODWORD(v92) = 2;
    BOOL v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "TILE: traverseTileFile, can't open tile",  v129,  v92);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLTileFileWithTraversal::traverseTileFile(FILE *, const TraverseDetails &)",  "%s\n",  v15);
    goto LABEL_116;
  }

  if (feof(a2))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    int v14 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "TILE: traverseTileFile, file is empty",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_21;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    LOWORD(v129[0]) = 0;
    LODWORD(v92) = 2;
    BOOL v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "TILE: traverseTileFile, file is empty",  v129,  v92);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLTileFileWithTraversal::traverseTileFile(FILE *, const TraverseDetails &)",  "%s\n",  v15);
LABEL_116:
LABEL_21:
    uint64_t v17 = 0LL;
    goto LABEL_108;
  }

  *(void *)((char *)v129 + 4) = 192LL;
  LODWORD(v129[0]) = 109498;
  HIDWORD(v129[0]) = 381;
  memset(&v129[1], 0, 28);
  *(int32x2_t *)((char *)&v129[2] + 12) = vdup_n_s32(0xC47A0000);
  DWORD1(v129[3]) = -998637568;
  memset((char *)&v129[3] + 8, 0, 148);
  LODWORD(v11_Block_object_dispose(va, 8) = 306106;
  *(void *)((char *)&v118 + 4) = 176LL;
  HIDWORD(v11_Block_object_dispose(va, 8) = 381;
  *(_DWORD *)&v128[16] = 0;
  *(void *)&v128[20] = 0LL;
  __int128 v119 = 0u;
  __int128 v120 = 0u;
  uint64_t v101 = v6;
  if (!*(_BYTE *)(v5 + 296))
  {
LABEL_61:
    uint64_t v17 = 1LL;
    goto LABEL_103;
  }

  uint64_t v95 = &v138;
  int v97 = &v131[12];
  uint64_t v100 = 136316674LL;
  std::string::size_type v98 = a2;
  uint64_t v99 = v5;
  while (1)
  {
    if (feof(a2)) {
      goto LABEL_61;
    }
    uint64_t v104 = 0LL;
    unsigned int v105 = 0;
    uint64_t __ptr = 0LL;
    int v103 = 0;
    size_t v18 = fread(&__ptr, 1uLL, 0xCuLL, a2);
    sub_1009831E8((unsigned __int16 *)&__ptr, (uint64_t)&v104);
    BOOL v19 = v18 == 12;
    uint64_t v17 = v18 != 12;
    if (!v19) {
      goto LABEL_103;
    }
    __int16 v20 = (os_log_s *)v9[335];
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v21 = v17;
      uint64_t v22 = p_vtable;
      uint64_t v23 = v9;
      uint64_t v24 = *a3;
      int v25 = (unsigned __int16)v104;
      int v26 = WORD1(v104);
      int v28 = HIDWORD(v104);
      unsigned int v27 = v105;
      id v29 = sub_100C0B634(WORD1(v104));
      *(_DWORD *)std::string buf = v100;
      *(void *)v131 = v24;
      *(_WORD *)&v131[8] = 2048;
      *(void *)&v131[10] = 12LL;
      *(_WORD *)&v131[18] = 1024;
      *(_DWORD *)&_BYTE v131[20] = v25;
      *(_WORD *)&v131[24] = 1024;
      *(_DWORD *)&v131[26] = v26;
      __int16 v132 = 1024;
      unsigned int v133 = v27;
      __int16 v134 = 1024;
      int v135 = v28;
      __int16 v136 = 2080;
      std::string v137 = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "TILE: thisSection, message, %s, readBytes, %lu, section, signature, 0x%x, sectionId, %d, sizeBytes, %d, headerSi zeBytes, %d, name, %s",  buf,  0x38u);
      uint64_t v6 = v101;
      uint64_t v9 = v23;
      p_vtable = v22;
      uint64_t v17 = v21;
      a2 = v98;
      uint64_t v5 = v99;
    }

    if (sub_1002921D0(115, 2))
    {
      HIDWORD(v93) = v17;
      bzero(buf, 0x65CuLL);
      uint64_t v55 = p_vtable;
      uint64_t v56 = v9[335];
      uint64_t v57 = *a3;
      int v58 = (unsigned __int16)v104;
      int v59 = WORD1(v104);
      int v61 = HIDWORD(v104);
      unsigned int v60 = v105;
      uint64_t v62 = sub_100C0B634(WORD1(v104));
      int v108 = v100;
      *(void *)__int128 v109 = v57;
      *(_WORD *)&v109[8] = 2048;
      *(void *)&__int128 v110 = 12LL;
      WORD4(v110) = 1024;
      *(_DWORD *)((char *)&v110 + 10) = v58;
      HIWORD(v110) = 1024;
      int v111 = v59;
      __int16 v112 = 1024;
      unsigned int v113 = v60;
      __int16 v114 = 1024;
      int v115 = v61;
      __int16 v116 = 2080;
      __int128 v117 = v62;
      LODWORD(v93) = 56;
      __int128 v63 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v56,  2LL,  "TILE: thisSection, message, %s, readBytes, %lu, section, signature, 0x%x, sectionId, %d, sizeBytes , %d, headerSizeBytes, %d, name, %s",  (const char *)&v108,  v93,  (_DWORD)v95,  (_DWORD)v97,  (_DWORD)v98,  v99,  (const char *)v100);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLTileFileWithTraversal::traverseTileFile(FILE *, const TraverseDetails &)",  "%s\n",  v63);
      uint64_t v6 = v101;
      uint64_t v9 = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
      p_vtable = v55;
      uint64_t v17 = HIDWORD(v92);
    }

    size_t v30 = HIDWORD(v104);
    uint64_t v31 = HIDWORD(v104) + 12LL;
    unint64_t v32 = v31 + v105;
    if (v32 > 0x640000B)
    {
      int v71 = (os_log_s *)v9[335];
      if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)std::string buf = 134218240;
        *(void *)v131 = v32;
        *(_WORD *)&v131[8] = 2048;
        *(void *)&v131[10] = 104857612LL;
        _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_FAULT,  "TILE: invalid tile file, bad allocation size, totalBytesInSection, %lu, maxAllocationSize, %lu",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 0))
      {
        uint64_t v67 = v17;
        bzero(buf, 0x65CuLL);
        off_t v68 = p_vtable;
        std::string::size_type v72 = v9[335];
        int v108 = 134218240;
        *(void *)__int128 v109 = v32;
        *(_WORD *)&v109[8] = 2048;
        *(void *)&__int128 v110 = 104857612LL;
        LODWORD(v92) = 22;
        uint64_t v70 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v72,  17LL,  "TILE: invalid tile file, bad allocation size, totalBytesInSection, %lu, maxAllocationSize, %lu",  &v108,  v92);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLTileFileWithTraversal::traverseTileFile(FILE *, const TraverseDetails &)",  "%s\n",  v70);
LABEL_78:
        uint64_t v6 = v101;
        p_vtable = v68;
        uint64_t v5 = v99;
        uint64_t v17 = v67;
        goto LABEL_103;
      }

      goto LABEL_103;
    }

    uint64_t v33 = malloc(HIDWORD(v104) + 12LL);
    if (!v33)
    {
      size_t v73 = (os_log_s *)v9[335];
      if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        *(void *)v131 = v31;
        _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_FAULT,  "TILE: failed to allocate memory for, %lu",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        uint64_t v74 = v9[335];
        int v108 = 134217984;
        *(void *)__int128 v109 = v31;
        __int16 v75 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v74,  17LL,  "TILE: failed to allocate memory for, %lu",  &v108);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLTileFileWithTraversal::traverseTileFile(FILE *, const TraverseDetails &)",  "%s\n",  v75);
        uint64_t v6 = v101;
        uint64_t v5 = v99;
      }

      goto LABEL_103;
    }

    uint64_t v34 = v33;
    size_t v35 = fread((char *)v33 + 12, 1uLL, v30, a2);
    if (v35 != v30)
    {
      size_t v76 = v35;
      stat v77 = (os_log_s *)v9[335];
      if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)std::string buf = 134218240;
        *(void *)v131 = v76;
        *(_WORD *)&v131[8] = 2048;
        *(void *)&v131[10] = v30;
        _os_log_impl( (void *)&_mh_execute_header,  v77,  OS_LOG_TYPE_FAULT,  "TILE: failed to read pSectionH, %lu, %lu",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        BOOL v88 = v9[335];
        int v108 = 134218240;
        *(void *)__int128 v109 = v76;
        *(_WORD *)&v109[8] = 2048;
        *(void *)&__int128 v110 = v30;
        LODWORD(v92) = 22;
        __int128 v89 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v88,  17LL,  "TILE: failed to read pSectionH, %lu, %lu",  &v108,  v92);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLTileFileWithTraversal::traverseTileFile(FILE *, const TraverseDetails &)",  "%s\n",  v89);
        uint64_t v6 = v101;
        uint64_t v5 = v99;
      }

      free(v34);
      goto LABEL_102;
    }

    *uint64_t v34 = __ptr;
    *((_DWORD *)v34 + 2) = v103;
    __int16 v36 = (os_log_s *)v9[335];
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 67109888;
      *(_DWORD *)v131 = (unsigned __int16)v104;
      *(_WORD *)&v131[4] = 1024;
      *(_DWORD *)&v131[6] = WORD1(v104);
      *(_WORD *)&v131[10] = 1024;
      *(_DWORD *)&v131[12] = HIDWORD(v104);
      *(_WORD *)&v131[16] = 1024;
      *(_DWORD *)&v131[18] = v105;
      _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEBUG,  "TILE: section, signature, 0x%x, sectionId, %d, headerSizeBytes, %u, sizeBytes, %u",  buf,  0x1Au);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      __int128 v64 = v9[335];
      int v108 = 67109888;
      *(_DWORD *)__int128 v109 = (unsigned __int16)v104;
      *(_WORD *)&v109[4] = 1024;
      *(_DWORD *)&v109[6] = WORD1(v104);
      LOWORD(v110) = 1024;
      *(_DWORD *)((char *)&v110 + 2) = HIDWORD(v104);
      WORD3(v110) = 1024;
      DWORD2(v110) = v105;
      __int128 v65 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v64,  2LL,  "TILE: section, signature, 0x%x, sectionId, %d, headerSizeBytes, %u, sizeBytes, %u",  &v108,  26,  (_DWORD)v95,  (_DWORD)v97);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLTileFileWithTraversal::traverseTileFile(FILE *, const TraverseDetails &)",  "%s\n",  v65);
    }

    uint64_t v37 = ftell(a2);
    (*(void (**)(uint64_t, FILE *, uint64_t *, void *, uint64_t *))(*(void *)v5 + 112LL))( v5,  a2,  &v104,  v34,  a3);
    switch(WORD1(v104))
    {
      case 1u:
        __int128 v48 = *((_OWORD *)v34 + 11);
        v129[10] = *((_OWORD *)v34 + 10);
        v129[11] = v48;
        *(_OWORD *)((char *)&v129[11] + 12) = *(_OWORD *)((char *)v34 + 188);
        __int128 v49 = *((_OWORD *)v34 + 7);
        v129[6] = *((_OWORD *)v34 + 6);
        v129[7] = v49;
        __int128 v50 = *((_OWORD *)v34 + 9);
        v129[8] = *((_OWORD *)v34 + 8);
        v129[9] = v50;
        __int128 v51 = *((_OWORD *)v34 + 3);
        v129[2] = *((_OWORD *)v34 + 2);
        v129[3] = v51;
        __int128 v52 = *((_OWORD *)v34 + 5);
        v129[4] = *((_OWORD *)v34 + 4);
        v129[5] = v52;
        __int128 v53 = *((_OWORD *)v34 + 1);
        v129[0] = *(_OWORD *)v34;
        v129[1] = v53;
        *(int8x8_t *)&double v54 = sub_1009831EC((uint64_t)v129, (uint64_t)v129);
        (*(void (**)(uint64_t, _OWORD *, double))(*(void *)v5 + 120LL))(v5, v129, v54);
        break;
      case 4u:
        __int128 v39 = *((_OWORD *)v34 + 8);
        __int128 v40 = *((_OWORD *)v34 + 10);
        __int128 v127 = *((_OWORD *)v34 + 9);
        *(_OWORD *)uint64_t v128 = v40;
        *(_OWORD *)&v128[12] = *(_OWORD *)((char *)v34 + 172);
        __int128 v41 = *((_OWORD *)v34 + 4);
        __int128 v42 = *((_OWORD *)v34 + 6);
        __int128 v43 = *((_OWORD *)v34 + 7);
        __int128 v123 = *((_OWORD *)v34 + 5);
        __int128 v124 = v42;
        __int128 v125 = v43;
        __int128 v126 = v39;
        __int128 v44 = *((_OWORD *)v34 + 1);
        __int128 v118 = *(_OWORD *)v34;
        __int128 v45 = *((_OWORD *)v34 + 2);
        __int128 v46 = *((_OWORD *)v34 + 3);
        __int128 v119 = v44;
        __int128 v120 = v45;
        __int128 v121 = v46;
        __int128 v122 = v41;
        int8x16_t v47 = sub_100983298((unsigned __int16 *)&v118, (uint64_t)&v118);
        (*(void (**)(uint64_t, __int128 *, int8x16_t))(*(void *)v5 + 128LL))(v5, &v118, v47);
        break;
      case 5u:
        *(void *)v131 = 184LL;
        *(_DWORD *)std::string buf = 371642;
        *(_DWORD *)&v131[8] = 381;
        *int v97 = 0u;
        v97[1] = 0u;
        *uint64_t v95 = 0LL;
        v95[1] = 0LL;
        *((_DWORD *)v95 + 4) = 0;
        *(int8x8_t *)&double v38 = sub_100C0B658((uint64_t)v34, (uint64_t)buf);
        (*(void (**)(uint64_t, uint8_t *, double))(*(void *)v5 + 168LL))(v5, buf, v38);
        break;
      default:
        goto LABEL_49;
    }

    if (*((_BYTE *)a3 + 8)) {
      *(_BYTE *)(v5 + 296) = 0;
    }
LABEL_49:
    free(v34);
    if (fseek(a2, v37 + v105, 0))
    {
      int v78 = (os_log_s *)v9[335];
      if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)std::string buf = 134218240;
        *(void *)v131 = v37;
        *(_WORD *)&v131[8] = 1024;
        *(_DWORD *)&v131[10] = v105;
        _os_log_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_FAULT,  "TILE: ERROR: failed to fseek to, currentFileOffset, %lu, %u",  buf,  0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        __int16 v90 = v9[335];
        int v108 = 134218240;
        *(void *)__int128 v109 = v37;
        *(_WORD *)&v109[8] = 1024;
        LODWORD(v110) = v105;
        __int128 v91 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v90,  17LL,  "TILE: ERROR: failed to fseek to, currentFileOffset, %lu, %u",  &v108,  18);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLTileFileWithTraversal::traverseTileFile(FILE *, const TraverseDetails &)",  "%s\n",  v91);
        uint64_t v6 = v101;
        uint64_t v5 = v99;
      }

void sub_1005981EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
}

void sub_10059826C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  unint64_t v4 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    unsigned int v5 = *(unsigned __int16 *)(a3 + 2);
    *(_DWORD *)std::string buf = 67109378;
    unsigned int v15 = v5;
    __int16 v16 = 2080;
    uint64_t v17 = sub_100C0B634(v5);
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "TILE: CLTileFile, sectionId, %d, %s", buf, 0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    uint64_t v6 = qword_101934A78;
    unsigned int v7 = *(unsigned __int16 *)(a3 + 2);
    v11[0] = 67109378;
    v11[1] = v7;
    __int16 v12 = 2080;
    int v13 = sub_100C0B634(v7);
    LODWORD(sub_10004B64C(v11, v10) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v6,  2LL,  "TILE: CLTileFile, sectionId, %d, %s",  v11,  v10);
    uint64_t v9 = (uint8_t *)v8;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileFileWithTraversal::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, cons t void *, const TraverseDetails &)",  "%s\n",  v8);
    if (v9 != buf) {
      free(v9);
    }
  }

void sub_100598448(uint64_t a1, uint64_t a2)
{
  double v4 = (double)*(unint64_t *)(a2 + 56) - kCFAbsoluteTimeIntervalSince1970;
  int v5 = *(_DWORD *)(a2 + 192);
  if (v5 < 1) {
    int v5 = 1209600;
  }
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 12);
  *(int32x2_t *)(a1 + 52) = vrev64_s32(*(int32x2_t *)(a2 + 16));
  *(void *)(a1 + 64) = -1LL;
  *(double *)(a1 + 176) = v4;
  *(_DWORD *)(a1 + 200) = v5;
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  uint64_t v6 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v7 = *(_DWORD *)(a2 + 12);
    int v8 = *(_DWORD *)(a2 + 16);
    double v9 = *(float *)(a2 + 28);
    double v10 = *(float *)(a2 + 32);
    double v11 = *(float *)(a2 + 36);
    double v12 = *(float *)(a2 + 40);
    double v13 = *(float *)(a2 + 44);
    double v14 = *(float *)(a2 + 48);
    double v15 = *(float *)(a2 + 52);
    int v16 = *(_DWORD *)(a2 + 20);
    int v17 = *(_DWORD *)(a2 + 24);
    double v18 = *(double *)(a1 + 176);
    int v19 = *(_DWORD *)(a2 + 192);
    int v36 = *(_DWORD *)(a1 + 200);
    *(_DWORD *)std::string buf = 67112704;
    int v50 = v7;
    __int16 v51 = 1024;
    int v52 = v8;
    __int16 v53 = 1024;
    int v54 = v16;
    __int16 v55 = 2048;
    double v56 = v9;
    __int16 v57 = 2048;
    double v58 = v10;
    __int16 v59 = 2048;
    double v60 = v11;
    __int16 v61 = 2048;
    double v62 = v12;
    __int16 v63 = 2048;
    double v64 = v13;
    __int16 v65 = 2048;
    double v66 = v14;
    __int16 v67 = 2048;
    double v68 = v15;
    __int16 v69 = 1024;
    int v70 = v17;
    __int16 v71 = 2048;
    double v72 = v18;
    __int16 v73 = 1024;
    int v74 = v19;
    __int16 v75 = 1024;
    int v76 = v36;
    __int16 v77 = 2048;
    double v78 = CFAbsoluteTimeGetCurrent() - v18;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "TILE: tile, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, altitude, %f,  minAltitude, %f, max Altitude, %f, numOfInputPoints, %d, generationTime, %.1f, expirationAge, %d, %d, age, %.1lf",  buf,  0x80u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    uint64_t v20 = qword_101934A78;
    int v21 = *(_DWORD *)(a2 + 16);
    double v22 = *(float *)(a2 + 28);
    double v23 = *(float *)(a2 + 32);
    double v24 = *(float *)(a2 + 36);
    double v25 = *(float *)(a2 + 40);
    double v26 = *(float *)(a2 + 44);
    double v27 = *(float *)(a2 + 48);
    double v28 = *(float *)(a2 + 52);
    int v29 = *(_DWORD *)(a2 + 20);
    double v30 = *(double *)(a1 + 176);
    int v31 = *(_DWORD *)(a2 + 192);
    int v32 = *(_DWORD *)(a1 + 200);
    CFAbsoluteTime v33 = CFAbsoluteTimeGetCurrent() - v30;
    LOWORD(v3_Block_object_dispose(va, 8) = 1024;
    *(_DWORD *)((char *)&v38 + 2) = v21;
    HIWORD(v3_Block_object_dispose(va, 8) = 1024;
    LODWORD(v39) = v29;
    WORD2(v39) = 2048;
    *(double *)((char *)&v39 + 6) = v22;
    HIWORD(v39) = 2048;
    *(_WORD *)__int128 v40 = 2048;
    *(double *)&v40[2] = v24;
    *(_WORD *)&v40[10] = 2048;
    *(double *)&v40[12] = v25;
    *(_WORD *)&v40[20] = 2048;
    *(_WORD *)&v40[22] = LOWORD(v26);
    *(_WORD *)__int128 v41 = 2048;
    *(double *)&v41[2] = v28;
    *(_WORD *)&v41[10] = 1024;
    *(_WORD *)__int128 v42 = 2048;
    *(double *)&v42[2] = v30;
    __int16 v43 = 1024;
    int v44 = v31;
    __int16 v45 = 1024;
    int v46 = v32;
    __int16 v47 = 2048;
    CFAbsoluteTime v48 = v33;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  2LL,  "TILE: tile, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, altitude, %f,  minAltitude, %f, max Altitude, %f, numOfInputPoints, %d, generationTime, %.1f, expirationAge, %d, %d, age, %.1lf",  &v37,  128,  67112704,  v38,  *(double *)&v39,  *((double *)&v39 + 1),  v23,  *(double *)v40,  *(double *)&v40[8],  *(double *)&v40[16],  *(void *)&v26 >> 16,  v27,  *(_DWORD *)v41,  *(_DWORD *)&v41[8],  *(double *)v42);
    size_t v35 = (uint8_t *)v34;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileFileWithTraversal::onTraversingTileHeader(const CLTilesManager_Type::TileHeader &)",  "%s\n",  v34);
    if (v35 != buf) {
      free(v35);
    }
  }

void sub_100598818(uint64_t a1, uint64_t a2)
{
  double v4 = (double)*(unint64_t *)(a2 + 40) - kCFAbsoluteTimeIntervalSince1970;
  uint64_t v5 = *(void *)(a2 + 188);
  else {
    uint64_t v6 = -1LL;
  }
  int v7 = *(_DWORD *)(a2 + 176);
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 12);
  *(int32x2_t *)(a1 + 52) = vrev64_s32(*(int32x2_t *)(a2 + 16));
  *(void *)(a1 + 64) = v6;
  *(double *)(a1 + 176) = v4;
  *(_DWORD *)(a1 + 200) = v7;
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  int v8 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_1008AD840((unsigned int *)(a1 + 48), (std::stringbuf::string_type *)&__p);
    double v9 = (SBYTE1(v56) & 0x80u) == 0 ? &__p : (void **)__p;
    LODWORD(buf) = 136315138;
    *(void *)((char *)&buf + 4) = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "TILE: onTraversingTileHeaderKeyLatLon, tileid, %s",  (uint8_t *)&buf,  0xCu);
    if (SBYTE1(v56) < 0) {
      operator delete(__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    uint64_t v23 = qword_101934A78;
    sub_1008AD840((unsigned int *)(a1 + 48), (std::stringbuf::string_type *)&buf);
    if ((SBYTE7(v40) & 0x80u) == 0) {
      p___int128 buf = &buf;
    }
    else {
      p___int128 buf = (__int128 *)buf;
    }
    int v48 = 136315138;
    __int128 v49 = p_buf;
    double v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v23,  2LL,  "TILE: onTraversingTileHeaderKeyLatLon, tileid, %s",  (const char *)&v48);
    if (SBYTE7(v40) < 0) {
      operator delete((void *)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileFileWithTraversal::onTraversingTileHeaderKeyLatLon(const CLTilesManager_Type::TileHeaderKeyLatLon &)",  "%s\n",  v25);
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  double v10 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v12 = *(_DWORD *)(a2 + 12);
    int v11 = *(_DWORD *)(a2 + 16);
    int v13 = *(_DWORD *)(a2 + 20);
    float v14 = *(float *)(a2 + 24);
    float v15 = *(float *)(a2 + 28);
    float v16 = *(float *)(a2 + 32);
    float v17 = *(float *)(a2 + 36);
    uint64_t v18 = *(void *)(a1 + 176);
    int v19 = *(_DWORD *)(a2 + 176);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    uint64_t v21 = *(void *)(a2 + 188);
    double v22 = Current - *(double *)(a1 + 176);
    LODWORD(__p) = 67111680;
    HIDWORD(__p) = v12;
    __int16 v51 = 1024;
    int v52 = v11;
    __int16 v53 = 1024;
    int v54 = v13;
    __int16 v55 = 2048;
    double v56 = v14;
    __int16 v57 = 2048;
    double v58 = v15;
    __int16 v59 = 2048;
    double v60 = v16;
    __int16 v61 = 2048;
    double v62 = v17;
    __int16 v63 = 2048;
    uint64_t v64 = v18;
    __int16 v65 = 1024;
    int v66 = v19;
    __int16 v67 = 2048;
    double v68 = v22;
    __int16 v69 = 2048;
    uint64_t v70 = v21;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "TILE: tile.keylatlon, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, generationTime, %.1f, exp irationAge, %d, age, %.1lf, sec_key, %016llx",  (uint8_t *)&__p,  0x60u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    uint64_t v26 = qword_101934A78;
    int v27 = *(_DWORD *)(a2 + 16);
    int v28 = *(_DWORD *)(a2 + 20);
    float v30 = *(float *)(a2 + 24);
    float v29 = *(float *)(a2 + 28);
    float v32 = *(float *)(a2 + 32);
    float v31 = *(float *)(a2 + 36);
    uint64_t v33 = *(void *)(a1 + 176);
    int v34 = *(_DWORD *)(a2 + 176);
    CFAbsoluteTime v35 = CFAbsoluteTimeGetCurrent();
    uint64_t v36 = *(void *)(a2 + 188);
    double v37 = v35 - *(double *)(a1 + 176);
    WORD4(buf) = 1024;
    *(_DWORD *)((char *)&buf + 10) = v27;
    HIWORD(buf) = 1024;
    LODWORD(v40) = v28;
    WORD2(v40) = 2048;
    *(double *)((char *)&v40 + 6) = v30;
    HIWORD(v40) = 2048;
    *(_WORD *)__int128 v41 = 2048;
    *(double *)&v41[2] = v32;
    *(_WORD *)&v41[10] = 2048;
    *(double *)__int128 v42 = v31;
    *(_WORD *)&v42[8] = 2048;
    *(void *)&_BYTE v42[10] = v33;
    *(_WORD *)&v42[18] = 1024;
    int v43 = v34;
    __int16 v44 = 2048;
    double v45 = v37;
    __int16 v46 = 2048;
    uint64_t v47 = v36;
    double v38 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v26,  2LL,  "TILE: tile.keylatlon, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, generationT ime, %.1f, expirationAge, %d, age, %.1lf, sec_key, %016llx",  &buf,  96,  67111680,  *((double *)&buf + 1),  *(double *)&v40,  *((double *)&v40 + 1),  v29,  *(double *)v41,  *(_DWORD *)&v41[8],  *(double *)&v42[4],  *(void *)&v42[12]);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileFileWithTraversal::onTraversingTileHeaderKeyLatLon(const CLTilesManager_Type::TileHeaderKeyLatLon &)",  "%s\n",  v38);
  }

void sub_100598D18(uint64_t a1, uint64_t a2)
{
  double v4 = (double)*(unint64_t *)(a2 + 40) - kCFAbsoluteTimeIntervalSince1970;
  int v5 = *(_DWORD *)(a2 + 176);
  int v6 = rand();
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 12);
  *(int32x2_t *)(a1 + 52) = vrev64_s32(*(int32x2_t *)(a2 + 16));
  *(void *)(a1 + 64) = -1LL;
  *(double *)(a1 + 176) = v4;
  *(_DWORD *)(a1 + 200) = v6 % 86400 + v5;
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  int v7 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_1008AD840((unsigned int *)(a1 + 48), (std::stringbuf::string_type *)v61);
    int v8 = SBYTE1(v67);
    double v9 = *(uint8_t **)v61;
    sub_1008AE164(a1 + 48, &__p);
    double v10 = v61;
    if (v8 < 0) {
      double v10 = v9;
    }
    if ((SBYTE7(v46) & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    *(_DWORD *)__int128 buf = 136315394;
    *(void *)&uint8_t buf[4] = v10;
    __int16 v54 = 2080;
    __int16 v55 = p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TILE: tile.location, tileid, %s, serverName, %s",  buf,  0x16u);
    if (SBYTE7(v46) < 0) {
      operator delete(__p);
    }
    if (SBYTE1(v67) < 0) {
      operator delete(*(void **)v61);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(v61, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    uint64_t v24 = qword_101934A78;
    sub_1008AD840((unsigned int *)(a1 + 48), (std::stringbuf::string_type *)&__p);
    int v25 = SBYTE7(v46);
    uint64_t v26 = (void **)__p;
    sub_1008AE164(a1 + 48, buf);
    int v27 = &__p;
    if (v25 < 0) {
      int v27 = v26;
    }
    if (v56 >= 0) {
      int v28 = buf;
    }
    else {
      int v28 = *(_BYTE **)buf;
    }
    int v57 = 136315394;
    double v58 = v27;
    __int16 v59 = 2080;
    double v60 = v28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v61,  1628LL,  &_mh_execute_header,  v24,  2LL,  "TILE: tile.location, tileid, %s, serverName, %s",  (const char *)&v57,  22);
    float v30 = v29;
    if (v56 < 0) {
      operator delete(*(void **)buf);
    }
    if (SBYTE7(v46) < 0) {
      operator delete(__p);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileFileWithTraversal::onTraversingTileHeaderLocation(const CLTilesManager_Type::TileHeaderLocation &)",  "%s\n",  v30);
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  int v12 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v13 = *(_DWORD *)(a2 + 12);
    int v14 = *(_DWORD *)(a2 + 16);
    int v15 = *(_DWORD *)(a2 + 20);
    float v16 = *(float *)(a2 + 24);
    float v17 = *(float *)(a2 + 28);
    float v18 = *(float *)(a2 + 32);
    float v19 = *(float *)(a2 + 36);
    uint64_t v20 = *(void *)(a1 + 176);
    int v21 = *(_DWORD *)(a2 + 176);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)__int16 v61 = 67111424;
    double v23 = Current - *(double *)(a1 + 176);
    *(_DWORD *)&v61[4] = v13;
    __int16 v62 = 1024;
    int v63 = v14;
    __int16 v64 = 1024;
    int v65 = v15;
    __int16 v66 = 2048;
    double v67 = v16;
    __int16 v68 = 2048;
    double v69 = v17;
    __int16 v70 = 2048;
    double v71 = v18;
    __int16 v72 = 2048;
    double v73 = v19;
    __int16 v74 = 2048;
    uint64_t v75 = v20;
    __int16 v76 = 1024;
    int v77 = v21;
    __int16 v78 = 2048;
    double v79 = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "TILE: tile.location, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, generationTime, %.1f, expi rationAge, %d, age, %.1lf",  v61,  0x56u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(v61, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    uint64_t v31 = qword_101934A78;
    int v32 = *(_DWORD *)(a2 + 16);
    int v33 = *(_DWORD *)(a2 + 20);
    float v34 = *(float *)(a2 + 24);
    float v35 = *(float *)(a2 + 28);
    float v36 = *(float *)(a2 + 32);
    float v37 = *(float *)(a2 + 36);
    uint64_t v38 = *(void *)(a1 + 176);
    int v39 = *(_DWORD *)(a2 + 176);
    CFAbsoluteTime v40 = CFAbsoluteTimeGetCurrent();
    LODWORD(__p) = 67111424;
    double v41 = v40 - *(double *)(a1 + 176);
    LOWORD(v45) = 1024;
    *(_DWORD *)((char *)&v45 + 2) = v32;
    HIWORD(v45) = 1024;
    LODWORD(v46) = v33;
    WORD2(v46) = 2048;
    *(double *)((char *)&v46 + 6) = v34;
    HIWORD(v46) = 2048;
    *(_WORD *)uint64_t v47 = 2048;
    *(double *)&v47[2] = v36;
    *(_WORD *)&v47[10] = 2048;
    *(double *)int v48 = v37;
    *(_WORD *)&v48[8] = 2048;
    *(void *)&v48[10] = v38;
    __int16 v49 = 1024;
    int v50 = v39;
    __int16 v51 = 2048;
    double v52 = v41;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v61,  1628LL,  &_mh_execute_header,  v31,  2LL,  "TILE: tile.location, version, %d, y, %u, x, %u, corner, %.8f, %.8f, detlas, %.2f, %.2f, generationTime, %.1f, expi rationAge, %d, age, %.1lf",  &__p,  86,  67111424,  v45,  *(double *)&v46,  *((double *)&v46 + 1),  v35,  *(double *)v47,  *(_DWORD *)&v47[8],  *(double *)&v48[4]);
    int v43 = (uint8_t *)v42;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileFileWithTraversal::onTraversingTileHeaderLocation(const CLTilesManager_Type::TileHeaderLocation &)",  "%s\n",  v42);
    if (v43 != v61) {
      free(v43);
    }
  }

void sub_1005992A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, int a36, __int16 a37, char a38, char a39)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005992DC(uint64_t a1, _DWORD *a2)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  double v4 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v5 = a2[1];
    int v7 = a2[3];
    int v6 = a2[4];
    *(_DWORD *)__int128 buf = 67109632;
    int v18 = v5;
    __int16 v19 = 1024;
    int v20 = v6;
    __int16 v21 = 1024;
    int v22 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "TILE: tileMacIndexHeader, headerSizeBytes, %u, tileMacIndexHeader, entrySizeInBytes, %u, numOfEntries, %u",  buf,  0x14u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    int v9 = a2[3];
    int v8 = a2[4];
    __int16 v13 = 1024;
    int v14 = v8;
    __int16 v15 = 1024;
    int v16 = v9;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: tileMacIndexHeader, headerSizeBytes, %u, tileMacIndexHeader, entrySizeInBytes, %u, numOfEntries, %u",  &v12,  20,  67109632);
    int v11 = (uint8_t *)v10;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileFileWithTraversal::onTraversingTileIndexHeader(const CLTilesManager_Type::TileIndexMacHeader &)",  "%s\n",  v10);
    if (v11 != buf) {
      free(v11);
    }
  }

  *(_DWORD *)(a1 + 292) = 0;
}

void sub_1005994C4(uint64_t a1, unsigned __int8 *a2)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  double v4 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *(_DWORD *)(a1 + 292);
    int v6 = *a2;
    int v7 = a2[1];
    int v8 = a2[2];
    int v9 = a2[3];
    int v10 = a2[4];
    int v11 = a2[5];
    int v12 = *(_DWORD *)(a2 + 6);
    *(_DWORD *)__int128 buf = 67110912;
    int v26 = v5;
    __int16 v27 = 1024;
    int v28 = v6;
    __int16 v29 = 1024;
    int v30 = v7;
    __int16 v31 = 1024;
    int v32 = v8;
    __int16 v33 = 1024;
    int v34 = v9;
    __int16 v35 = 1024;
    int v36 = v10;
    __int16 v37 = 1024;
    int v38 = v11;
    __int16 v39 = 1024;
    int v40 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "TILE: idx, %3u, mac,%x:%x:%x:%x:%x:%x, offset, %u",  buf,  0x32u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    __int16 v13 = *a2;
    int v14 = a2[1];
    int v15 = a2[2];
    __int16 v16 = a2[4];
    int v17 = a2[5];
    int v18 = *(_DWORD *)(a2 + 6);
    LOWORD(v21) = 1024;
    HIWORD(v21) = v13;
    LOWORD(v22) = HIWORD(v15);
    HIWORD(v22) = 1024;
    LOWORD(v23) = 1024;
    HIWORD(v23) = v16;
    HIWORD(v24) = HIWORD(v18);
    __int16 v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: idx, %3u, mac,%x:%x:%x:%x:%x:%x, offset, %u",  &v20,  50,  67110912,  v21,  v14,  v22,  v23,  v17);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileFileWithTraversal::onTraversingTileIndexEntry(const CLTilesManager_Type::AccessPointIndexEntry &)",  "%s\n",  v19);
  }

  ++*(_DWORD *)(a1 + 292);
}

void sub_100599734(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)(a1 + 292) = 0;
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  int v3 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v4 = a2[1];
    int v6 = a2[3];
    int v5 = a2[4];
    *(_DWORD *)__int128 buf = 67109632;
    int v17 = v4;
    __int16 v18 = 1024;
    int v19 = v5;
    __int16 v20 = 1024;
    int v21 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "TILE: tileAccessPointTable, headerSizeBytes, %u, tileAccessPointTable, entrySizeInBytes, %u, numOfEntries, %u",  buf,  0x14u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    int v8 = a2[3];
    int v7 = a2[4];
    __int16 v12 = 1024;
    int v13 = v7;
    __int16 v14 = 1024;
    int v15 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: tileAccessPointTable, headerSizeBytes, %u, tileAccessPointTable, entrySizeInBytes, %u, numOfEntries, %u",  &v11,  20,  67109632);
    int v10 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileFileWithTraversal::onTraversingTileAPTableHeader(const CLTilesManager_Type::TileAccessPointTable &)",  "%s\n",  v9);
    if (v10 != buf) {
      free(v10);
    }
  }

void sub_100599918(uint64_t a1, unsigned __int8 *a2)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  int v4 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *(_DWORD *)(a1 + 292);
    int v6 = *a2;
    int v7 = a2[1];
    int v8 = a2[2];
    int v9 = a2[3];
    int v10 = a2[4];
    int v11 = a2[5];
    unsigned int v12 = *(_DWORD *)(a2 + 6);
    *(_DWORD *)__int128 buf = 67111680;
    int v32 = v5;
    __int16 v33 = 1024;
    int v34 = v6;
    __int16 v35 = 1024;
    int v36 = v7;
    __int16 v37 = 1024;
    int v38 = v8;
    __int16 v39 = 1024;
    int v40 = v9;
    __int16 v41 = 1024;
    int v42 = v10;
    __int16 v43 = 1024;
    int v44 = v11;
    __int16 v45 = 1024;
    int v46 = v12 & 0xFFF;
    __int16 v47 = 1024;
    int v48 = (v12 >> 12) & 0xFFF;
    __int16 v49 = 2048;
    uint64_t v50 = v21;
    __int16 v51 = 2048;
    uint64_t v52 = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "TILE: mac, %3u, mac,%x:%x:%x:%x:%x:%x, y, %3d, x, %3d, loc, %14.10lf, %14.10lf",  buf,  0x4Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    __int16 v13 = *a2;
    int v14 = a2[1];
    int v15 = a2[2];
    __int16 v16 = a2[4];
    int v17 = a2[5];
    unsigned int v18 = *(_DWORD *)(a2 + 6);
    LOWORD(v23) = 1024;
    HIWORD(v23) = v13;
    LOWORD(v24) = HIWORD(v15);
    HIWORD(v24) = 1024;
    LOWORD(v25) = 1024;
    HIWORD(v25) = v16;
    LODWORD(v26) = v17;
    WORD2(v26) = 1024;
    *(_DWORD *)((char *)&v26 + 6) = v18 & 0xFFF;
    WORD5(v26) = 1024;
    HIDWORD(v26) = (v18 >> 12) & 0xFFF;
    __int16 v27 = 2048;
    uint64_t v28 = v21;
    __int16 v29 = 2048;
    uint64_t v30 = v20;
    int v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: mac, %3u, mac,%x:%x:%x:%x:%x:%x, y, %3d, x, %3d, loc, %14.10lf, %14.10lf",  &v22,  76,  v20,  v21,  67111680,  v23,  v14,  v24,  v25,  *(double *)&v26,  *((double *)&v26 + 1));
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileFileWithTraversal::onTraversingTileAPTableEntry(const CLTilesManager_Type::AccessPointEntry &)",  "%s\n",  v19);
  }

  ++*(_DWORD *)(a1 + 292);
}

void *sub_100599BF4(uint64_t a1, FILE *a2, uint64_t a3, int a4, int a5, int a6)
{
  size_t v11 = (a6 * a5);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840E58);
  }
  unsigned int v12 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v13 = *(unsigned __int16 *)(a3 + 2);
    *(_DWORD *)__int128 buf = 67109632;
    int v32 = v13;
    __int16 v33 = 1024;
    int v34 = a4;
    __int16 v35 = 1024;
    int v36 = a5;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "TILE: read data, sectionId, %d, entriesOffset, %u, entriesNumToRead, %u",  buf,  0x14u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840E58);
    }
    __int16 v27 = 1024;
    int v28 = a4;
    __int16 v29 = 1024;
    int v30 = a5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: read data, sectionId, %d, entriesOffset, %u, entriesNumToRead, %u",  &v26,  20,  67109632);
    int v24 = (uint8_t *)v23;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void *CLTileFileWithTraversal::readDataEntries(FILE *, const CLTilesManager_Type::SectionHeader &, unsigned int, u nsigned int, unsigned int)",  "%s\n",  v23);
    if (v24 != buf) {
      free(v24);
    }
  }

  int v14 = malloc(v11);
  if (v14)
  {
    int v15 = fseek(a2, (a6 * a4), 1);
    if (v15)
    {
      int v16 = v15;
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101840E58);
      }
      int v17 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 67109376;
        int v32 = a4;
        __int16 v33 = 1024;
        int v34 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "TILE: ERROR: failed to skip entries pre read, %u, ret, %d",  buf,  0xEu);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_22;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101840E58);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "TILE: ERROR: failed to skip entries pre read, %u, ret, %d",  &v26);
LABEL_31:
      int v25 = (uint8_t *)v18;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void *CLTileFileWithTraversal::readDataEntries(FILE *, const CLTilesManager_Type::SectionHeader &, unsigned int, unsigned int, unsigned int)",  "%s\n",  v18);
      if (v25 != buf) {
        free(v25);
      }
LABEL_22:
      free(v14);
      return 0LL;
    }

    size_t v19 = fread(v14, 1uLL, v11, a2);
    if (v19 != v11)
    {
      int v20 = v19;
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101840E58);
      }
      uint64_t v21 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 67109376;
        int v32 = v20;
        __int16 v33 = 1024;
        int v34 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_FAULT,  "TILE: ERROR: failed to read bytes, %u, %u",  buf,  0xEu);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_22;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101840E58);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "TILE: ERROR: failed to read bytes, %u, %u",  &v26);
      goto LABEL_31;
    }
  }

  return v14;
}

void sub_10059A09C(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_10059A0C8(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

void sub_10059A254(uint64_t a1, unsigned int *a2, uint64_t a3, void *a4)
{
  uint64_t v5 = *a2;
  sub_100246C40((uint64_t)v15, a3);
  [a4 onLeechedNotification:v5 withData:v15];

  int v6 = v20;
  if (v20)
  {
    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  if (v19 < 0) {
    operator delete(__p);
  }
  int v9 = v17;
  if (v17)
  {
    int v10 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  unsigned int v12 = v16;
  if (v16)
  {
    int v13 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_10059A364(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10059AE3C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10059B8A4(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void sub_10059B8D0()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_1012F1254;
      v1[3] = unk_1012F1264;
      v1[4] = xmmword_1012F1274;
      v1[0] = xmmword_1012F1234;
      v1[1] = unk_1012F1244;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_10059B9A4(_Unwind_Exception *a1)
{
}

void sub_10059BDEC(uint64_t a1, unsigned int *a2, uint64_t a3, void *a4)
{
  uint64_t v5 = *a2;
  sub_100246C40((uint64_t)v15, a3);
  [a4 onLocationNotification:v5 data:v15];

  int v6 = v20;
  if (v20)
  {
    p_shared_owners = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  if (v19 < 0) {
    operator delete(__p);
  }
  int v9 = v17;
  if (v17)
  {
    int v10 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  unsigned int v12 = v16;
  if (v16)
  {
    int v13 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

void sub_10059BEFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10059CC44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_10059CCEC(id a1)
{
  qword_1019346A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Altimeter");
}

void sub_10059CD18(void *a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0xB8uLL);
  sub_10059CD60((uint64_t)v2);
  *a1 = v2 + 24;
  a1[1] = v2;
}

void sub_10059CD4C(_Unwind_Exception *a1)
{
}

__n128 sub_10059CD60(uint64_t a1)
{
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_101840EE8;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 176) = 0LL;
  int64x2_t v1 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(int64x2_t *)(a1 + 24) = v1;
  *(int64x2_t *)(a1 + 40) = v1;
  *(int64x2_t *)(a1 + 56) = v1;
  *(int64x2_t *)(a1 + 72) = v1;
  *(int64x2_t *)(a1 + 8_Block_object_dispose(va, 8) = v1;
  *(int64x2_t *)(a1 + 104) = v1;
  *(void *)(a1 + 120) = -1LL;
  *(_DWORD *)(a1 + 12_Block_object_dispose(va, 8) = -1;
  *(int64x2_t *)(a1 + 136) = v1;
  __asm { FMOV            V0.2D, #-1.0 }

  *(__n128 *)(a1 + 160) = result;
  return result;
}

void sub_10059CDC0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101840EE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10059CDD4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101840EE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_10059CE00()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_1012F12B8;
      v1[3] = unk_1012F12C8;
      v1[4] = xmmword_1012F12D8;
      v1[0] = xmmword_1012F1298;
      v1[1] = unk_1012F12A8;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_10059CED4(_Unwind_Exception *a1)
{
}

uint64_t sub_10059CEEC()
{
  if (qword_101996E70 != -1) {
    dispatch_once(&qword_101996E70, &stru_101840F28);
  }
  return qword_1019A1170;
}

void sub_10059CF2C(id a1)
{
  int64x2_t v1 = operator new(0x20uLL);
  sub_10059CF70(v1);
  qword_1019A1170 = (uint64_t)v1;
}

void sub_10059CF5C(_Unwind_Exception *a1)
{
}

const void *sub_10059CF70(const void *a1)
{
  uint64_t v2 = sub_1002E4C3C(a1, "CLLocalization", 1LL, 1LL);
  *(void *)(v2 + 16) = 0LL;
  *(void *)(v2 + 24) = 0LL;
  int v3 = (CFBundleRef *)(v2 + 16);
  sub_10030A2B8(&__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  CFStringRef v5 = sub_1002A6F04((char *)p_p);
  int v6 = v5;
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if (!v6) {
      goto LABEL_12;
    }
  }

  else if (!v5)
  {
    goto LABEL_12;
  }

  CFTypeID v7 = CFGetTypeID(v6);
  if (v7 == CFStringGetTypeID())
  {
    unint64_t v8 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v6, kCFURLPOSIXPathStyle, 0);
    if (v8)
    {
      CFBundleRef *v3 = CFBundleCreate(kCFAllocatorDefault, v8);
      CFRelease(v8);
    }
  }

  CFRelease(v6);
LABEL_12:
  sub_10059D0C4((uint64_t)a1);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver( DarwinNotifyCenter,  a1,  (CFNotificationCallback)sub_10059D0FC,  @"com.apple.language.changed",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  return a1;
}

void sub_10059D090( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

CFStringRef sub_10059D0C4(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    CFRelease(v2);
  }
  __n128 result = sub_10059D614(a1, *(__CFBundle **)(a1 + 16));
  *(void *)(a1 + 24) = result;
  return result;
}

uint64_t sub_10059D0FC(uint64_t a1, uint64_t a2)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840F48);
  }
  int v3 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "language changed - refreshing", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840F48);
    }
    v6[0] = 0;
    CFStringRef v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "language changed - refreshing",  v6,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLLocalization::onLanguageChanged(CFNotificationCenterRef, void *, CFStringRef, const void *, CFDictionaryRef)",  "%s\n",  v5);
  }

  *(void *)__int128 buf = a2;
  (*(void (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  __int16 v8 = 256;
  CFPreferencesSynchronize(@".GlobalPreferences", @"mobile", kCFPreferencesAnyHost);
  sub_10059D0C4(a2);
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24LL))(a2);
}

void sub_10059D2E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

CFStringRef sub_10059D310(uint64_t a1, __CFBundle *a2, const __CFString *a3, int a4)
{
  uint64_t v20 = a1;
  (*(void (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  __int16 v21 = 256;
  if (!a2) {
    goto LABEL_31;
  }
  __int16 v8 = sub_10059D614(a1, a2);
  int v9 = (const __CFString *)CFBundleCopyLocalizedStringForLocalization(a2, a3, 0LL, @"InfoPlist", v8);
  if (v8) {
    CFRelease(v8);
  }
  if (v9)
  {
    if (CFStringCompare(v9, a3, 1uLL))
    {
      int v10 = v9;
      goto LABEL_9;
    }

    CFRelease(v9);
    if (!a4)
    {
      ValueForInfoDictionaryKey = (const __CFString *)CFBundleGetValueForInfoDictionaryKey(a2, a3);
      unint64_t v11 = ValueForInfoDictionaryKey;
      if (!ValueForInfoDictionaryKey) {
        goto LABEL_32;
      }
      CFTypeID v13 = CFGetTypeID(ValueForInfoDictionaryKey);
      if (v13 == CFStringGetTypeID())
      {
        CFRetain(v11);
        goto LABEL_32;
      }

      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101840F68);
      }
      unint64_t v14 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        sub_1002A6C50(a3, &__p);
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 buf = 68289282;
        int v23 = 0;
        __int16 v24 = 2082;
        int v25 = "";
        __int16 v26 = 2082;
        __int16 v27 = p_p;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:key in bundle does not contain a string value, key:%{public, location:escape_only}s}",  buf,  0x1Cu);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101840F68);
        }
      }

      int v16 = (os_log_s *)qword_101934988;
      if (os_signpost_enabled((os_log_t)qword_101934988))
      {
        sub_1002A6C50(a3, &__p);
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v17 = &__p;
        }
        else {
          int v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 buf = 68289282;
        int v23 = 0;
        __int16 v24 = 2082;
        int v25 = "";
        __int16 v26 = 2082;
        __int16 v27 = v17;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "key in bundle does not contain a string value",  "{msg%{public}.0s:key in bundle does not contain a string value, key:%{public, location:escape_only}s}",  buf,  0x1Cu);
      }

void sub_10059D5E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

CFStringRef sub_10059D614(uint64_t a1, __CFBundle *a2)
{
  uint64_t v19 = a1;
  (*(void (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  __int16 v20 = 256;
  if (!a2)
  {
    ValueAtIndex = 0LL;
    goto LABEL_28;
  }

  int v4 = (const __CFArray *)CFPreferencesCopyValue( @"AppleLanguages",  @".GlobalPreferences",  @"mobile",  kCFPreferencesAnyHost);
  CFStringRef v5 = v4;
  if (v4 && CFArrayGetCount(v4))
  {
    int v6 = CFBundleCopyBundleLocalizations(a2);
    CFTypeID v7 = v6;
    if (v6 && CFArrayGetCount(v6))
    {
      __int16 v8 = CFBundleCopyLocalizationsForPreferences(v7, v5);
      int v9 = v8;
      if (v8 && CFArrayGetCount(v8))
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v9, 0LL);
        CFRetain(ValueAtIndex);
      }

      else
      {
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101840F48);
        }
        unint64_t v14 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#Warning could not get localizations for preferred languages, assuming english",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101840F48);
          }
          __int16 v18 = 0;
          int v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  0LL,  "#Warning could not get localizations for preferred languages, assuming english",  &v18,  2);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CFStringRef CLLocalization::copyUserPreferredLocalizationLanguage(CFBundleRef)",  "%s\n",  v17);
        }

        ValueAtIndex = @"en";
        CFRetain(@"en");
      }

      goto LABEL_24;
    }

    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840F48);
    }
    unsigned int v12 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "#Warning could not get localizations array from bundle, assuming english",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101840F48);
      }
      __int16 v18 = 0;
      int v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  0LL,  "#Warning could not get localizations array from bundle, assuming english",  &v18,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CFStringRef CLLocalization::copyUserPreferredLocalizationLanguage(CFBundleRef)",  "%s\n",  v16);
    }

    ValueAtIndex = @"en";
    CFRetain(@"en");
LABEL_23:
    int v9 = 0LL;
LABEL_24:
    CFRelease(v5);
    if (v7) {
      CFRelease(v7);
    }
    if (v9) {
      CFRelease(v9);
    }
    goto LABEL_28;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101840F48);
  }
  unint64_t v11 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning could not get apple languages array, assuming english",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840F48);
    }
    __int16 v18 = 0;
    uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  0LL,  "#Warning could not get apple languages array, assuming english",  &v18,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CFStringRef CLLocalization::copyUserPreferredLocalizationLanguage(CFBundleRef)",  "%s\n",  v15);
  }

  CFRetain(@"en");
  ValueAtIndex = @"en";
  if (v5)
  {
    CFTypeID v7 = 0LL;
    goto LABEL_23;
  }

void sub_10059DB44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

CFStringRef sub_10059DB74( uint64_t a1, __CFBundle *a2, const __CFString *a3, const __CFString *a4, int a5)
{
  if (qword_101996E70 != -1) {
    dispatch_once(&qword_101996E70, &stru_101840F28);
  }
  __n128 result = sub_10059D310(qword_1019A1170, a2, a4, a5);
  if (!a5 && !result)
  {
    id v10 = -[__CFDictionary objectForKey:](CFBundleGetInfoDictionary(a2), "objectForKey:", a3);
    uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSDictionary);
    if ((objc_opt_isKindOfClass(v10, v11) & 1) != 0)
    {
      id v12 = [v10 objectForKey:a4];
      if (v12)
      {
        CFTypeID v13 = v12;
        uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSString);
        if ((objc_opt_isKindOfClass(v13, v14) & 1) != 0) {
          return (const __CFString *)[v13 copy];
        }
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101840F68);
        }
        __int16 v26 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
        {
          sub_1002A6C50(a4, &__p);
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)__int128 buf = 68289282;
          int v31 = 0;
          __int16 v32 = 2082;
          __int16 v33 = "";
          __int16 v34 = 2082;
          __int16 v35 = p_p;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:key does not contain a string value, key:%{public, location:escape_only}s}",  buf,  0x1Cu);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_101840F68);
          }
        }

        uint64_t v24 = qword_101934988;
        if (!os_signpost_enabled((os_log_t)qword_101934988)) {
          return 0LL;
        }
        sub_1002A6C50(a4, &__p);
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v28 = &__p;
        }
        else {
          int v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 buf = 68289282;
        int v31 = 0;
        __int16 v32 = 2082;
        __int16 v33 = "";
        __int16 v34 = 2082;
        __int16 v35 = v28;
        uint64_t v19 = "key does not contain a string value";
        __int16 v20 = "{msg%{public}.0s:key does not contain a string value, key:%{public, location:escape_only}s}";
      }

      else
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101840F68);
        }
        int v22 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
        {
          sub_1002A6C50(a4, &__p);
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            int v23 = &__p;
          }
          else {
            int v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)__int128 buf = 68289282;
          int v31 = 0;
          __int16 v32 = 2082;
          __int16 v33 = "";
          __int16 v34 = 2082;
          __int16 v35 = v23;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:key is not present, key:%{public, location:escape_only}s}",  buf,  0x1Cu);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_101840F68);
          }
        }

        uint64_t v24 = qword_101934988;
        if (!os_signpost_enabled((os_log_t)qword_101934988)) {
          return 0LL;
        }
        sub_1002A6C50(a4, &__p);
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v25 = &__p;
        }
        else {
          int v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 buf = 68289282;
        int v31 = 0;
        __int16 v32 = 2082;
        __int16 v33 = "";
        __int16 v34 = 2082;
        __int16 v35 = v25;
        uint64_t v19 = "key is not present";
        __int16 v20 = "{msg%{public}.0s:key is not present, key:%{public, location:escape_only}s}";
      }

      __int16 v21 = (os_log_s *)v24;
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101840F68);
      }
      uint64_t v15 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        sub_1002A6C50(a3, &__p);
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v16 = &__p;
        }
        else {
          int v16 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 buf = 68289282;
        int v31 = 0;
        __int16 v32 = 2082;
        __int16 v33 = "";
        __int16 v34 = 2082;
        __int16 v35 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:description dictionary key does not contain a dictionary value, key:%{public, loc ation:escape_only}s}",  buf,  0x1Cu);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101840F68);
        }
      }

      uint64_t v17 = qword_101934988;
      if (!os_signpost_enabled((os_log_t)qword_101934988)) {
        return 0LL;
      }
      sub_1002A6C50(a3, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v18 = &__p;
      }
      else {
        __int16 v18 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289282;
      int v31 = 0;
      __int16 v32 = 2082;
      __int16 v33 = "";
      __int16 v34 = 2082;
      __int16 v35 = v18;
      uint64_t v19 = "description dictionary key does not contain a dictionary value";
      __int16 v20 = "{msg%{public}.0s:description dictionary key does not contain a dictionary value, key:%{public, l"
            "ocation:escape_only}s}";
      __int16 v21 = (os_log_s *)v17;
    }

    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v21,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v19,  v20,  buf,  0x1Cu);
    return 0LL;
  }

  return result;
}

CFStringRef sub_10059E110(void *a1, const __CFString *a2)
{
  uint64_t v4 = a1[3];
  (*(void (**)(void *))(*a1 + 16LL))(a1);
  uint64_t v5 = a1[2];
  if (!v5)
  {
    CFTypeID v7 = 0LL;
    goto LABEL_12;
  }

  if (!v4)
  {
    sub_10059D0C4((uint64_t)a1);
    uint64_t v5 = a1[2];
    uint64_t v4 = a1[3];
  }

  int v6 = (const __CFString *)CFBundleCopyLocalizedStringForLocalization(v5, a2, 0LL, @"locationd", v4);
  CFTypeID v7 = v6;
  if (v6)
  {
    if (CFStringCompare(v6, a2, 0x100uLL)) {
      goto LABEL_8;
    }
    CFRelease(v7);
  }

  CFTypeID v7 = (const __CFString *)CFBundleCopyLocalizedStringForLocalization(a1[2], a2, 0LL, @"locationd-private", v4);
  if (!v7)
  {
LABEL_10:
    CFTypeID v7 = (const __CFString *)CFBundleCopyLocalizedStringForLocalization( a1[2],  a2,  0LL,  @"locationd-footprint",  v4);
    goto LABEL_12;
  }

void sub_10059E230(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

const void *sub_10059E244(uint64_t a1)
{
  uint64_t v9 = a1;
  (*(void (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  __int16 v10 = 256;
  uint64_t v2 = (const __CFArray *)CFPreferencesCopyValue( @"AppleLanguages",  @".GlobalPreferences",  @"mobile",  kCFPreferencesAnyHost);
  int v3 = v2;
  if (v2)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v2, 0LL);
    CFRetain(ValueAtIndex);
    CFRelease(v3);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101840F48);
    }
    uint64_t v5 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#Warning could not get apple languages array",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101840F48);
      }
      __int16 v8 = 0;
      CFTypeID v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  0LL,  "#Warning could not get apple languages array",  &v8,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "CFStringRef CLLocalization::copyUserPreferredLanguage()", "%s\n", v7);
    }

    ValueAtIndex = 0LL;
  }

  (*(void (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  return ValueAtIndex;
}

void sub_10059E458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_10059E480(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_10059E4AC(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

uint64_t sub_10059E4D8(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 20LL;
  *(_BYTE *)(a1 + 24) = 1;
  *(void *)(a1 + 32) = &off_1018410C8;
  *(void *)a1 = &off_101841278;
  *(void *)(a1 + _Block_object_dispose(va, 8) = &off_101840F88;
  *(_DWORD *)(a1 + 40) = 1056964608;
  *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0;
  uint64_t v4 = a1 + 2528;
  bzero((void *)(a1 + 56), 0x9A8uLL);
  *(_OWORD *)(a1 + 252_Block_object_dispose(va, 8) = xmmword_1012F1420;
  *(_OWORD *)(a1 + 2544) = unk_1012F1430;
  *(_OWORD *)(a1 + 2560) = xmmword_1012F1440;
  *(_OWORD *)(v4 + 44) = *(__int128 *)((char *)&xmmword_1012F1440 + 12);
  *(void *)(a1 + 2592) = 0LL;
  *(void *)(a1 + 2600) = a2;
  *(_DWORD *)(a1 + 260_Block_object_dispose(va, 8) = 0;
  unsigned __int8 v6 = 0;
  sub_1012049AC(v7, "RunningFormBypassIsRunning", &v6, 0);
  *(_BYTE *)(a1 + 2612) = v7[1];
  *(_WORD *)(a1 + 2613) = 0;
  nullsub_10(a1 + 2615);
  *(_OWORD *)(a1 + 2632) = 0u;
  *(_OWORD *)(a1 + 264_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 2616) = 0u;
  *(void *)(a1 + 2664) = 0x200000002LL;
  return a1;
}

void sub_10059E5EC(_Unwind_Exception *a1)
{
}

void sub_10059E64C(uint64_t a1)
{
  LOBYTE(v7) = 0;
  sub_1012049AC(buf, "RunningFormBypassIsRunning", (unsigned __int8 *)&v7, 0);
  *(_BYTE *)(a1 + 2612) = buf[1];
  if (qword_101934740 != -1) {
    dispatch_once(&qword_101934740, &stru_101841208);
  }
  uint64_t v2 = (os_log_s *)qword_101934748;
  if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 2612);
    *(_DWORD *)__int128 buf = 136446466;
    id v12 = "RunningFormBypassIsRunning";
    __int16 v13 = 1026;
    int v14 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "[FormModels] default - %{public}s: %{public}d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    int v4 = *(unsigned __int8 *)(a1 + 2612);
    int v7 = 136446466;
    __int16 v8 = "RunningFormBypassIsRunning";
    __int16 v9 = 1026;
    int v10 = v4;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  0LL,  "[FormModels] default - %{public}s: %{public}d",  &v7,  18);
    unsigned __int8 v6 = (uint8_t *)v5;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLRunning::FormModels::enableFormMetrics()", "%s\n", v5);
    if (v6 != buf) {
      free(v6);
    }
  }

void sub_10059E83C(uint64_t a1)
{
  *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 40_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  bzero((void *)(a1 + 456), 0x818uLL);
  uint64_t v2 = *(void ***)(a1 + 64);
  uint64_t v3 = *(void *)(a1 + 72);
  *(void *)(a1 + 96) = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *(void *)(a1 + 72);
      uint64_t v2 = (void **)(*(void *)(a1 + 64) + 8LL);
      *(void *)(a1 + 64) = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 85LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      goto LABEL_8;
    }
    uint64_t v6 = 170LL;
  }

  *(void *)(a1 + 8_Block_object_dispose(va, 8) = v6;
LABEL_8:
  int v7 = *(void ***)(a1 + 112);
  uint64_t v8 = *(void *)(a1 + 120);
  *(void *)(a1 + 144) = 0LL;
  unint64_t v9 = v8 - (void)v7;
  if (v9 >= 0x11)
  {
    do
    {
      operator delete(*v7);
      uint64_t v10 = *(void *)(a1 + 120);
      int v7 = (void **)(*(void *)(a1 + 112) + 8LL);
      *(void *)(a1 + sub_10004AD90(v15 - 112) = v7;
      unint64_t v9 = v10 - (void)v7;
    }

    while (v9 > 0x10);
  }

  if (v9 >> 3 == 1)
  {
    uint64_t v11 = 85LL;
  }

  else
  {
    if (v9 >> 3 != 2) {
      goto LABEL_15;
    }
    uint64_t v11 = 170LL;
  }

  *(void *)(a1 + 136) = v11;
LABEL_15:
  id v12 = *(void ***)(a1 + 160);
  uint64_t v13 = *(void *)(a1 + 168);
  *(void *)(a1 + 192) = 0LL;
  unint64_t v14 = v13 - (void)v12;
  if (v14 >= 0x11)
  {
    do
    {
      operator delete(*v12);
      uint64_t v15 = *(void *)(a1 + 168);
      id v12 = (void **)(*(void *)(a1 + 160) + 8LL);
      *(void *)(a1 + 160) = v12;
      unint64_t v14 = v15 - (void)v12;
    }

    while (v14 > 0x10);
  }

  if (v14 >> 3 == 1)
  {
    uint64_t v16 = 85LL;
  }

  else
  {
    if (v14 >> 3 != 2) {
      goto LABEL_22;
    }
    uint64_t v16 = 170LL;
  }

  *(void *)(a1 + 184) = v16;
LABEL_22:
  uint64_t v17 = *(void ***)(a1 + 208);
  uint64_t v18 = *(void *)(a1 + 216);
  *(void *)(a1 + 240) = 0LL;
  unint64_t v19 = v18 - (void)v17;
  if (v19 >= 0x11)
  {
    do
    {
      operator delete(*v17);
      uint64_t v20 = *(void *)(a1 + 216);
      uint64_t v17 = (void **)(*(void *)(a1 + 208) + 8LL);
      *(void *)(a1 + 20_Block_object_dispose(va, 8) = v17;
      unint64_t v19 = v20 - (void)v17;
    }

    while (v19 > 0x10);
  }

  if (v19 >> 3 == 1)
  {
    uint64_t v21 = 128LL;
  }

  else
  {
    if (v19 >> 3 != 2) {
      goto LABEL_29;
    }
    uint64_t v21 = 256LL;
  }

  *(void *)(a1 + 232) = v21;
LABEL_29:
  int v22 = *(void ***)(a1 + 256);
  uint64_t v23 = *(void *)(a1 + 264);
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = 0LL;
  unint64_t v24 = v23 - (void)v22;
  if (v24 >= 0x11)
  {
    do
    {
      operator delete(*v22);
      uint64_t v25 = *(void *)(a1 + 264);
      int v22 = (void **)(*(void *)(a1 + 256) + 8LL);
      *(void *)(a1 + 256) = v22;
      unint64_t v24 = v25 - (void)v22;
    }

    while (v24 > 0x10);
  }

  if (v24 >> 3 == 1)
  {
    uint64_t v26 = 128LL;
  }

  else
  {
    if (v24 >> 3 != 2) {
      return;
    }
    uint64_t v26 = 256LL;
  }

  *(void *)(a1 + 280) = v26;
}

uint64_t sub_10059EA30(uint64_t result, void *a2)
{
  *(void *)(result + 2664) = *a2;
  return result;
}

void sub_10059EA3C(uint64_t a1, void *a2, void *a3)
{
  unint64_t v4 = a2;
  uint64_t v6 = a2[1];
  if (a2[2] == v6)
  {
    uint64_t v8 = a2 + 5;
    unint64_t v7 = a2[5];
    goto LABEL_11;
  }

  uint64_t v8 = a2 + 5;
  unint64_t v7 = a2[5];
  unint64_t v9 = a2[4];
  uint64_t v10 = (unint64_t *)(v6 + 8 * (v9 / 0x49));
  unint64_t v11 = *v10;
  unint64_t v12 = *v10 + 56 * (v9 % 0x49);
  unint64_t v13 = *(void *)(v6 + 8 * ((v7 + v9) / 0x49)) + 56 * ((v7 + v9) % 0x49);
  if (v12 == v13)
  {
LABEL_11:
    double v14 = 0.0;
    goto LABEL_12;
  }

  double v14 = 0.0;
  do
  {
    double v15 = *(double *)(v12 + 48) - *(double *)(v12 + 40);
    if (v15 <= 0.0) {
      double v15 = -0.0;
    }
    v12 += 56LL;
    if (v12 - v11 == 4088)
    {
      unint64_t v16 = v10[1];
      ++v10;
      unint64_t v11 = v16;
      unint64_t v12 = v16;
    }

    double v14 = v14 + v15;
  }

  while (v12 != v13);
LABEL_12:
  *(double *)(a1 + 44_Block_object_dispose(va, 8) = v14 / (double)v7;
  sub_1005A0E38(a1, a3, (double *)(a1 + 456));
  uint64_t v17 = a3[5];
  if (v17) {
    char v400 = sub_100A177A8( *(double *)(a1 + 464),  *(double *)(*(void *)(a3[1] + 8 * ((v17 + a3[4] - 1) / 0x17uLL))
  }
                       + 176 * ((v17 + a3[4] - 1) % 0x17uLL)
                       + 72),
             *(float *)(a1 + 2536));
  else {
    char v400 = 0;
  }
  int v18 = *(_DWORD *)(a1 + 48) + 1;
  *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = v18;
  if (*v8 >= 0x101uLL && (v18 & 0xF) == 0)
  {
    *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0;
    memset(v423, 0, 20);
    if (sub_1005A10C4(v4, (uint64_t)v423))
    {
      sub_1005A159C((void *)(a1 + 104), v423);
    }

    else
    {
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      unint64_t v19 = (os_log_s *)qword_101934748;
      if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "[FormModels] Failed to compute axis of rotation",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934740 != -1) {
          dispatch_once(&qword_101934740, &stru_101841208);
        }
        *(_WORD *)v418 = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  16LL,  "[FormModels] Failed to compute axis of rotation",  v418,  2);
        v339 = (char *)v338;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLRunning::FormModels::feedDeviceMotion(const DeviceMotionQueue &, const StepQueue &)",  "%s\n",  v338);
        if (v339 != buf) {
          free(v339);
        }
      }
    }
  }

  if (*(double *)(a1 + 464) > 0.0 && *v8 >= 0x201uLL)
  {
    unint64_t v20 = v4[4] + *v8;
    uint64_t v21 = v4[1];
    uint64_t v22 = v4[2];
    uint64_t v23 = (void *)(v21 + 8 * (v20 / 0x49));
    unint64_t v24 = *v23 + 56 * (v20 % 0x49);
    if (v22 == v21) {
      unint64_t v24 = 0LL;
    }
    uint64_t v25 = v24 - *v23;
    uint64_t v26 = 0x6DB6DB6DB6DB6DB7LL * (v25 >> 3);
    if (v25 < 28729)
    {
      unint64_t v45 = 585 - v26;
      int v28 = &v23[-(v45 / 0x49)];
      unint64_t v29 = *v28 + 56 * (73 * (v45 / 0x49) - v45) + 4032;
    }

    else
    {
      unint64_t v27 = v26 - 513;
      int v28 = &v23[v27 / 0x49];
      unint64_t v29 = *v28 + 56 * (v27 % 0x49);
    }

    v423[0].n128_u64[0] = (unint64_t)v28;
    v423[0].n128_u64[1] = v29;
    if (v22 == v21) {
      unint64_t v46 = 0LL;
    }
    else {
      unint64_t v46 = *v23 + 56 * (v20 % 0x49);
    }
    *(void *)v418 = v23;
    *(void *)&v418[8] = v46;
    sub_1005A1648((uint64_t)v423, (uint64_t)v418, a1 + 1500, (uint64_t)buf);
    sub_1005A17E8((void *)(a1 + 56), (__n128 *)buf);
    goto LABEL_56;
  }

  *(void *)(a1 + 440) = 0LL;
  *(_OWORD *)(a1 + 40_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  int v30 = *(void ***)(a1 + 64);
  uint64_t v31 = *(void *)(a1 + 72);
  *(void *)(a1 + 96) = 0LL;
  unint64_t v32 = v31 - (void)v30;
  if (v32 >= 0x11)
  {
    do
    {
      operator delete(*v30);
      uint64_t v33 = *(void *)(a1 + 72);
      int v30 = (void **)(*(void *)(a1 + 64) + 8LL);
      *(void *)(a1 + 64) = v30;
      unint64_t v32 = v33 - (void)v30;
    }

    while (v32 > 0x10);
  }

  if (v32 >> 3 == 1)
  {
    uint64_t v34 = 85LL;
  }

  else
  {
    if (v32 >> 3 != 2) {
      goto LABEL_37;
    }
    uint64_t v34 = 170LL;
  }

  *(void *)(a1 + 8_Block_object_dispose(va, 8) = v34;
LABEL_37:
  __int16 v35 = *(void ***)(a1 + 160);
  uint64_t v36 = *(void *)(a1 + 168);
  *(void *)(a1 + 192) = 0LL;
  unint64_t v37 = v36 - (void)v35;
  if (v37 >= 0x11)
  {
    do
    {
      operator delete(*v35);
      uint64_t v38 = *(void *)(a1 + 168);
      __int16 v35 = (void **)(*(void *)(a1 + 160) + 8LL);
      *(void *)(a1 + 160) = v35;
      unint64_t v37 = v38 - (void)v35;
    }

    while (v37 > 0x10);
  }

  if (v37 >> 3 == 1)
  {
    uint64_t v39 = 85LL;
    goto LABEL_43;
  }

  if (v37 >> 3 == 2)
  {
    uint64_t v39 = 170LL;
LABEL_43:
    *(void *)(a1 + 184) = v39;
  }

  int v40 = *(void ***)(a1 + 208);
  uint64_t v41 = *(void *)(a1 + 216);
  *(void *)(a1 + 240) = 0LL;
  unint64_t v42 = v41 - (void)v40;
  if (v42 >= 0x11)
  {
    do
    {
      operator delete(*v40);
      uint64_t v43 = *(void *)(a1 + 216);
      int v40 = (void **)(*(void *)(a1 + 208) + 8LL);
      *(void *)(a1 + 20_Block_object_dispose(va, 8) = v40;
      unint64_t v42 = v43 - (void)v40;
    }

    while (v42 > 0x10);
  }

  if (v42 >> 3 == 1)
  {
    uint64_t v44 = 128LL;
  }

  else
  {
    if (v42 >> 3 != 2) {
      goto LABEL_56;
    }
    uint64_t v44 = 256LL;
  }

  *(void *)(a1 + 232) = v44;
LABEL_56:
  unint64_t v47 = *(void *)(a1 + 96);
  v404 = v4;
  if (v47 < 2) {
    goto LABEL_70;
  }
  unint64_t v48 = *(void *)(a1 + 88);
  unint64_t v49 = v48 + v47;
  uint64_t v50 = *(void *)(a1 + 64);
  uint64_t v51 = *(void *)(a1 + 72);
  uint64_t v52 = (void *)(v50 + 8 * (v49 / 0xAA));
  unint64_t v53 = *v52 + 24 * (v49 % 0xAA);
  if (v51 == v50) {
    unint64_t v53 = 0LL;
  }
  uint64_t v54 = v53 - *v52;
  unint64_t v55 = 0xAAAAAAAAAAAAAAABLL * (v54 >> 3);
  if (v54 < 25)
  {
    unint64_t v61 = 170 - v55;
    unint64_t v62 = (170 - v55) / 0xAA;
    double v58 = &v52[-v62];
    uint64_t v59 = *v58;
    uint64_t v60 = *v58 + 24 * (170 * v62 - v61) + 4056;
  }

  else
  {
    unint64_t v56 = v55 - 1;
    unint64_t v57 = (v55 - 1) / 0xAA;
    double v58 = &v52[v57];
    uint64_t v59 = *v58;
    uint64_t v60 = *v58 + 24 * (v56 - 170 * v57);
  }

  uint64_t v63 = v60 - v59;
  unint64_t v64 = 0xAAAAAAAAAAAAAAABLL * ((v60 - v59) >> 3);
  if (v63 < 25) {
    unint64_t v65 = v58[-((170 - v64) / 0xAA)] + 24 * (170 * ((170 - v64) / 0xAA) - (170 - v64)) + 4056;
  }
  else {
    unint64_t v65 = v58[(v64 - 1) / 0xAA] + 24 * ((v64 - 1) % 0xAA);
  }
  float v66 = *(float *)(v65 + 8);
  float v67 = *(float *)(v60 + 8);
  if (v66 <= 0.0 && v67 > 0.0)
  {
    *(_OWORD *)(a1 + 392) = *(_OWORD *)(a1 + 416);
    *(void *)(a1 + 40_Block_object_dispose(va, 8) = *(void *)(a1 + 432);
    *(void *)(a1 + 416) = *(void *)v60;
    *(void *)(a1 + 424) = 0LL;
    *(void *)(a1 + 432) = 0LL;
    goto LABEL_68;
  }

  if (v66 < 0.0
    || v67 >= 0.0
    || *(double *)(a1 + 392) <= 0.0
    || *(double *)(a1 + 408) <= 0.0
    || *(double *)(a1 + 416) <= 0.0
    || *(double *)(a1 + 432) <= 0.0)
  {
    goto LABEL_68;
  }

  uint64_t v353 = v60;
  char v429 = 0;
  __int128 v427 = 0u;
  __int128 v428 = 0u;
  __int128 v425 = 0u;
  __int128 v426 = 0u;
  __int128 v424 = 0u;
  memset(v423, 0, sizeof(v423));
  __int128 v126 = (void *)(v50 + 8 * (v48 / 0xAA));
  if (v51 == v50)
  {
    __int128 v127 = 0LL;
    uint64_t v128 = 0LL;
  }

  else
  {
    __int128 v127 = (double *)(*v126 + 24 * (v48 % 0xAA));
    uint64_t v128 = (double *)(*v52 + 24 * (v49 % 0xAA));
  }

  int64_t v139 = sub_1005A1894(v126, v127, v52, v128, (double *)(a1 + 400));
  std::string::size_type v141 = v139;
  uint64_t v142 = (uint64_t)v140;
  unint64_t v143 = *(void *)(a1 + 88) + *(void *)(a1 + 96);
  uint64_t v144 = *(void *)(a1 + 64);
  std::string v145 = (void *)(v144 + 8 * (v143 / 0xAA));
  if (*(void *)(a1 + 72) == v144) {
    std::string v146 = 0LL;
  }
  else {
    std::string v146 = (double *)(*v145 + 24 * (v143 % 0xAA));
  }
  char v147 = sub_1005A1978(v139, v140, v145, v146, (double *)(a1 + 424));
  unint64_t v149 = v148;
  unint64_t v150 = v4[4];
  uint64_t v151 = v4[1];
  unsigned __int8 v152 = (void *)(v151 + 8 * (v150 / 0x49));
  if (v4[2] == v151)
  {
    uint64_t v153 = 0LL;
    uint64_t v156 = 0LL;
    __int16 v155 = (void *)(v151
                    + (((unint64_t)(((*v8 + v150) * (unsigned __int128)0x70381C0E070381C1uLL) >> 64) >> 2) & 0x1FFFFFFFFFFFFFF8LL));
  }

  else
  {
    uint64_t v153 = *(void *)(v151 + 8 * (v150 / 0x49)) + 56 * (v150 % 0x49);
    unint64_t v154 = *v8 + v150;
    __int16 v155 = (void *)(v151 + 8 * (v154 / 0x49));
    uint64_t v156 = *v155 + 56 * (v154 % 0x49);
  }

  v384 = sub_1005A1A58(v152, v153, v155, v156, (double *)(a1 + 400));
  uint64_t v158 = v157;
  int v159 = *(_DWORD *)(a1 + 2664);
  if (v159 == 1)
  {
    if (*(_DWORD *)(a1 + 2668) != 1)
    {
LABEL_167:
      __int16 v160 = sub_1005A1C04(v141, v142, (uint64_t)v147, v149, a1);
      goto LABEL_170;
    }
  }

  else if (v159 || *(_DWORD *)(a1 + 2668))
  {
    goto LABEL_167;
  }

  __int16 v160 = sub_1005A1B50(v141, v142, (uint64_t)v147, v149, a1);
LABEL_170:
  float v364 = v67;
  v355 = (double *)v142;
  v356 = (double *)v149;
  v377 = v161;
  if (v160 >= v147 && (v160 != v147 || (unint64_t)v161 >= v149) || v161 == (double *)v142)
  {
    char v163 = v147;
    char v164 = v141;
    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    uint64_t v165 = (os_log_s *)qword_101934748;
    if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_ERROR))
    {
      int v166 = *(_DWORD *)(a1 + 2664);
      int v167 = *(_DWORD *)(a1 + 2668);
      *(_DWORD *)__int128 buf = 67240448;
      *(_DWORD *)&uint8_t buf[4] = v166;
      *(_WORD *)&uint8_t buf[8] = 1026;
      *(_DWORD *)&buf[10] = v167;
      _os_log_impl( (void *)&_mh_execute_header,  v165,  OS_LOG_TYPE_ERROR,  "[FormModels] Unable to determine swing extrema. Verify correct watch orientation: Wrist=%{public}d, Crown=%{public}d",  buf,  0xEu);
    }

    std::string::size_type v141 = v164;
    char v147 = v163;
    if (sub_1002921D0(115, 0))
    {
      v342 = v141;
      bzero(buf, 0x65CuLL);
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      int v343 = *(_DWORD *)(a1 + 2664);
      int v344 = *(_DWORD *)(a1 + 2668);
      *(_DWORD *)v418 = 67240448;
      *(_DWORD *)&v418[4] = v343;
      *(_WORD *)&v418[8] = 1026;
      *(_DWORD *)&v418[10] = v344;
      LODWORD(v347) = 14;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  16LL,  "[FormModels] Unable to determine swing extrema. Verify correct watch orientation: Wrist=%{public}d, Crown=%{public}d",  v418,  *(void *)&v347);
      v346 = (char *)v345;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLRunning::FormModels::feedDeviceMotion(const DeviceMotionQueue &, const StepQueue &)",  "%s\n",  v345);
      if (v346 != buf) {
        free(v346);
      }
      std::string::size_type v141 = v342;
      char v147 = v163;
    }
  }

  else
  {
    char v429 = 1;
  }

  int v168 = 0;
  uint64_t v169 = *(void *)(a1 + 64);
  double v170 = -1.79769313e308;
  double v171 = 1.79769313e308;
  double v172 = 0.0;
  __int16 v173 = v141;
  uint64_t v174 = v142;
LABEL_181:
  uint64_t v175 = v174 - 4080;
  while (1)
  {
    if (*(void *)(a1 + 72) == v169)
    {
      unint64_t v177 = 0LL;
    }

    else
    {
      unint64_t v176 = *(void *)(a1 + 96) + *(void *)(a1 + 88);
      unint64_t v177 = *(void *)(v169 + 8 * (v176 / 0xAA)) + 24 * (v176 % 0xAA);
    }

    double v162 = *(double *)v174;
    if (*(double *)v174 >= *v377)
    {
      float v178 = fabsf(*(float *)(v174 + 8));
      double v179 = *(float *)(v174 + 12);
      if (v170 < v179) {
        double v170 = *(float *)(v174 + 12);
      }
      if (v171 > v179) {
        double v171 = *(float *)(v174 + 12);
      }
      double v162 = v178;
      double v172 = v172 + v162;
      ++v168;
    }

    v174 += 24LL;
    v175 += 24LL;
    if (*v173 == v175)
    {
      uint64_t v180 = v173[1];
      ++v173;
      uint64_t v174 = v180;
      goto LABEL_181;
    }
  }

  v416 = 0LL;
  std::string __p = 0LL;
  uint64_t v417 = 0LL;
  *(void *)__int128 buf = v141;
  *(void *)&uint8_t buf[8] = v142;
  *(void *)v418 = v147;
  *(void *)&v418[8] = v356;
  sub_1005A1CB8((uint64_t **)buf, (uint64_t)v418, (float32x2_t **)&__p, v162);
  int v352 = v168;
  else {
    uint64_t v181 = 170 * (v147 - v141)
  }
  uint64_t v354 = v181;
  unint64_t v182 = *(void *)(a1 + 136);
  uint64_t v183 = *(void *)(a1 + 112);
  __int128 v184 = (void *)(v183 + 8 * (v182 / 0xAA));
  if (*(void *)(a1 + 120) == v183) {
    __int128 v185 = 0LL;
  }
  else {
    __int128 v185 = (float *)(*v184 + 24 * (v182 % 0xAA));
  }
  v414[0] = v183 + 8 * (v182 / 0xAA);
  v414[1] = v185;
  uint64_t v186 = v4[1];
  if (v4[2] == v186)
  {
    unint64_t v188 = 0LL;
  }

  else
  {
    unint64_t v187 = v4[5] + v4[4];
    unint64_t v188 = *(void *)(v186 + 8 * (v187 / 0x49)) + 56 * (v187 % 0x49);
  }

  double v348 = v172;
  double v350 = v171;
  double v351 = v170;
  if (v188 == v158) {
    double v189 = 0.0;
  }
  else {
    double v189 = *(double *)(v158 + 40);
  }
  if (v354 < 1)
  {
    double v190 = -1.79769313e308;
    double v191 = 1.79769313e308;
    v315 = v355;
    v308 = v356;
    v312.i32[0] = *(_DWORD *)(a1 + 2536);
    double v330 = *(double *)(a1 + 448);
    double v331 = -1.0;
    goto LABEL_308;
  }

  double v349 = *(double *)&v8;
  uint64_t v407 = 0LL;
  int v376 = 0;
  double v190 = -1.79769313e308;
  double v191 = 1.79769313e308;
  double v192 = 0.0;
  double v193 = 0.0;
  double v362 = 0.0;
  double v363 = 0.0;
  double v194 = 0.0;
  double v359 = 0.0;
  double v360 = 0.0;
  double v195 = 0.0;
  double v368 = 0.0;
  double v369 = -1.79769313e308;
  double v373 = -1.79769313e308;
  double v374 = 1.79769313e308;
  double v196 = 0.0;
  double v197 = 0.0;
  double v361 = 0.0;
  double v357 = 0.0;
  double v358 = 0.0;
  double v405 = 0.0;
  double v406 = 0.0;
  double v375 = -1.79769313e308;
  double v370 = 0.0;
  double v371 = 0.0;
  double v198 = 0.0;
  uint64_t v365 = v354 & ~(v354 >> 63);
  double v403 = 0.0;
  double v366 = 0.0;
  double v367 = 0.0;
  double v372 = 0.0;
  v408 = (float *)v355;
  do
  {
    double v397 = v196;
    double v399 = v197;
    double v401 = v194;
    double v413 = *(double *)(v158 + 40);
    float v199 = sub_100833470((float *)v158);
    float v202 = v199;
    float v203 = v200;
    float v204 = v201;
    unint64_t v205 = *(void *)(a1 + 136) + *(void *)(a1 + 144);
    uint64_t v206 = *(void *)(a1 + 112);
    v207 = (void *)(v206 + 8 * (v205 / 0xAA));
    double v395 = v190;
    double v396 = v191;
    double v385 = v193;
    double v391 = v195;
    if (*(void *)(a1 + 120) == v206) {
      unint64_t v208 = 0LL;
    }
    else {
      unint64_t v208 = *v207 + 24 * (v205 % 0xAA);
    }
    float v209 = *(float *)(v158 + 28);
    float v210 = *(float *)(v158 + 32);
    float v211 = *(float *)(v158 + 36);
    double v212 = v413;
    double v392 = v198;
    if ((float *)v208 == v185
      || (unint64_t v213 = 170 * (v207 - v184)
               - 0x5555555555555555LL * ((uint64_t)(v208 - *v207) >> 3)
               + 0x5555555555555555LL * (((uint64_t)v185 - *v184) >> 3)) == 0)
    {
      float v221 = *(float *)(v158 + 36);
      float v219 = *(float *)(v158 + 32);
      float v220 = *(float *)(v158 + 28);
    }

    else
    {
      float v388 = v201;
      double v214 = v192;
      float v215 = v200;
      float v216 = v199;
      v393 = v141;
      do
      {
        unint64_t v217 = v213 >> 1;
        *(void *)__int128 buf = v184;
        *(void *)&uint8_t buf[8] = v185;
        sub_10025BC20(buf, v213 >> 1);
        uint64_t v218 = *(void *)&buf[8];
        if (**(double **)&buf[8] < *(double *)(a1 + 400))
        {
          __int128 v185 = (float *)(*(void *)&buf[8] + 24LL);
          *(void *)&buf[8] += 24LL;
          __int128 v184 = *(void **)buf;
          if (v218 + 24 - **(void **)buf == 4080)
          {
            __int128 v184 = (void *)(*(void *)buf + 8LL);
            __int128 v185 = *(float **)(*(void *)buf + 8LL);
          }

          unint64_t v217 = v213 + ~v217;
        }

        unint64_t v213 = v217;
      }

      while (v217);
      float v220 = *(float *)(v158 + 28);
      float v219 = *(float *)(v158 + 32);
      float v221 = *(float *)(v158 + 36);
      std::string::size_type v141 = v393;
      float v202 = v216;
      float v203 = v215;
      double v192 = v214;
      float v204 = v388;
    }

    double v394 = v192;
    uint64_t v222 = 0LL;
    double v381 = vabds_f32(v211, v204 * (float)((float)((float)(v204 * v211) + (float)(v203 * v210)) + (float)(v202 * v209)));
    double v382 = v211;
    double v383 = fabsf(v210);
    double v223 = v212 - v189;
    float v224 = v185[2];
    float v225 = v185[3];
    float v226 = v185[4];
    float v227 = (float)((float)(v226 * v221) + (float)(v225 * v219)) + (float)(v224 * v220);
    float v380 = v224 * v227;
    float v389 = fabsf( (float)((float)(v204 * (float)(v226 * v227)) + (float)(v203 * (float)(v225 * v227)))
           + (float)(v202 * (float)(v224 * v227)));
    float v379 = 1.0 - v389;
    float v228 = *(float *)(v158 + 16);
    float v229 = *(float *)(v158 + 20);
    float v230 = *(float *)(v158 + 24);
    float v231 = (float)((float)(v204 * v230) + (float)(v203 * v229)) + (float)(v202 * v228);
    float v378 = v228 - (float)(v202 * v231);
    *(float *)v418 = v378;
    *(float *)&v418[4] = v229 - (float)(v203 * v231);
    *(float *)&v418[8] = v230 - (float)(v204 * v231);
    float v232 = 0.0;
    do
    {
      float v232 = v232 + (float)(*(float *)&v418[v222] * *(float *)&v418[v222]);
      v222 += 4LL;
    }

    while (v222 != 12);
    float v387 = v408[2];
    float v233 = v408[4];
    float v386 = v408[3];
    unsigned __int8 v234 = atomic_load((unsigned __int8 *)&qword_101996E88);
    if ((v234 & 1) == 0)
    {
      float v304 = v202;
      float v305 = v203;
      float v306 = v204;
      int v307 = __cxa_guard_acquire(&qword_101996E88);
      float v204 = v306;
      float v203 = v305;
      float v202 = v304;
      if (v307)
      {
        qword_101996E78 = 0x3F80000000000000LL;
        dword_101996E80 = 0;
        __cxa_guard_release(&qword_101996E88);
        float v204 = v306;
        float v203 = v305;
        float v202 = v304;
      }
    }

    float v235 = v202;
    float v236 = v203;
    float v237 = v204;
    double v238 = sub_1005A20C0( *(float *)&qword_101996E78,  *((float *)&qword_101996E78 + 1),  *(float *)&dword_101996E80,  v202,  v203,  v204);
    float v239 = fabsf(v229);
    float v240 = vabds_f32(v233, v233 * (float)((float)((float)(v237 * v233) + (float)(v386 * v236)) + (float)(v387 * v235)));
    double v241 = (float)(*(float *)&v238 * 57.296);
    double v242 = v389;
    if (v223 <= 0.0) {
      double v243 = 0.0;
    }
    else {
      double v243 = v223 * (v401 + v389) * 0.5;
    }
    double v402 = v239;
    if (v223 <= 0.0) {
      double v244 = 0.0;
    }
    else {
      double v244 = v223 * (v397 + v402) * 0.5;
    }
    double v245 = v231;
    double v246 = v241;
    double v398 = v245;
    double v247 = v223 * (v399 + v245) * 0.5;
    if (v223 <= 0.0) {
      double v247 = 0.0;
    }
    double v248 = v403 + v247;
    if (v223 <= 0.0) {
      double v249 = 0.0;
    }
    else {
      double v249 = v223 * (v391 + v241) * 0.5;
    }
    double v250 = v240;
    double v403 = v403 + v247;
    double v251 = fabs(v248);
    float v252 = v235;
    float v253 = v237;
    double v390 = v389;
    if (v413 >= *v377)
    {
      float v264 = fabsf(v378);
      double v265 = v223 * (v359 + v246) * 0.5;
      if (v223 <= 0.0) {
        double v265 = 0.0;
      }
      double v370 = v370 + v265;
      double v266 = v223 * (v358 + v383) * 0.5;
      if (v223 <= 0.0) {
        double v266 = 0.0;
      }
      double v372 = v372 + v266;
      double v363 = v363 + v264;
      ++v376;
      double v267 = v223 * (v360 + v251) * 0.5;
      if (v223 <= 0.0) {
        double v267 = 0.0;
      }
      double v367 = v367 + v267;
      double v358 = v383;
      double v359 = v246;
      double v360 = v251;
    }

    else
    {
      float v254 = fabsf(sqrtf(v232));
      double v255 = (float)(v380 * v379);
      if (v375 >= v255) {
        double v256 = v375;
      }
      else {
        double v256 = (float)(v380 * v379);
      }
      double v257 = v374;
      if (v374 > v255) {
        double v257 = (float)(v380 * v379);
      }
      double v374 = v257;
      double v375 = v256;
      double v258 = v369;
      if (v369 < v381) {
        double v258 = v381;
      }
      double v369 = v258;
      double v259 = v373;
      if (v373 < v382) {
        double v259 = v382;
      }
      double v373 = v259;
      double v260 = v254;
      double v261 = v223 * (v357 + v254) * 0.5;
      if (v223 <= 0.0) {
        double v261 = 0.0;
      }
      double v371 = v371 + v261;
      double v262 = v223 * (v362 + v242) * 0.5;
      if (v223 <= 0.0) {
        double v262 = 0.0;
      }
      double v368 = v368 + v262;
      double v263 = v223 * (v361 + v251) * 0.5;
      if (v223 <= 0.0) {
        double v263 = 0.0;
      }
      double v366 = v366 + v263;
      double v357 = v260;
      double v361 = v251;
      double v362 = v242;
    }

    double v190 = v395;
    double v191 = v396;
    uint64_t v268 = 0LL;
    double v405 = v405 + v244;
    double v406 = v406 + v243;
    double v198 = v392 + v249;
    double v192 = v394 + v250;
    uint64_t v269 = v407 + 1;
    float v270 = *(float *)(v158 + 16);
    float v271 = *(float *)(v158 + 20);
    float v272 = *(float *)(v158 + 24);
    float v273 = (float)((float)(v253 * v272) + (float)(v271 * v236)) + (float)(v270 * v252);
    *(float *)&__int128 v409 = v270 - (float)(v252 * v273);
    *((float *)&v409 + 1) = v271 - (float)(v236 * v273);
    *((float *)&v409 + 2) = v272 - (float)(v253 * v273);
    float v274 = 0.0;
    do
    {
      float v274 = v274 + (float)(*(float *)((char *)&v409 + v268) * *(float *)((char *)&v409 + v268));
      v268 += 4LL;
    }

    while (v268 != 12);
    uint64_t v275 = 0LL;
    double v276 = sqrtf(v274);
    float v277 = 0.0;
    do
    {
      float v277 = v277 + (float)(*(float *)(v158 + 28 + v275) * *(float *)(v158 + 28 + v275));
      v275 += 4LL;
    }

    while (v275 != 12);
    double v278 = sqrtf(v277);
    if (v396 > v278) {
      double v191 = v278;
    }
    float v279 = (float)(v253 * *(float *)(v158 + 36)) + (float)(*(float *)(v158 + 32) * v236);
    memset(v412, 0, 12);
    unint64_t v280 = *(void *)(a1 + 136) + *(void *)(a1 + 144);
    uint64_t v281 = *(void *)(a1 + 112);
    v282 = (void *)(v281 + 8 * (v280 / 0xAA));
    if (*(void *)(a1 + 120) == v281) {
      v283 = 0LL;
    }
    else {
      v283 = (double *)(*v282 + 24 * (v280 % 0xAA));
    }
    if ((sub_1005A2288(v414, v413, (uint64_t)v282, v283, v412) & 1) == 0)
    {
      v284 = v141;
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      v285 = (os_log_s *)qword_101934748;
      if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v285,  OS_LOG_TYPE_ERROR,  "[FormModels] Failed to get primary axis of rotation",  buf,  2u);
      }

      std::string::size_type v141 = v284;
      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934740 != -1) {
          dispatch_once(&qword_101934740, &stru_101841208);
        }
        v411[0] = 0;
        LODWORD(v347) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  16LL,  "[FormModels] Failed to get primary axis of rotation",  v411,  *(void *)&v347);
        v303 = (char *)v302;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLRunning::FormModels::feedDeviceMotion(const DeviceMotionQueue &, const StepQueue &)",  "%s\n",  v302);
        if (v303 != buf) {
          free(v303);
        }
        std::string::size_type v141 = v284;
      }
    }

    v286 = (char *)__p + 12 * v407;
    float v287 = vmlas_n_f32( vmuls_lane_f32(*(float *)(v158 + 36), *(float32x2_t *)((char *)v412 + 4), 1),  *(float *)(v158 + 32),  *((float *)v412 + 1))
         + (float)(*(float *)v412 * *(float *)(v158 + 28));
    float v288 = *(float *)v412 * v287;
    int32x2_t v289 = (int32x2_t)vmul_n_f32(*(float32x2_t *)((char *)v412 + 4), v287);
    int32x2_t v290 = *(int32x2_t *)(v286 + 4);
    v291.i32[0] = vdup_lane_s32(v289, 1).u32[0];
    v291.f32[1] = v288;
    v292.i32[0] = vdup_lane_s32(v290, 1).u32[0];
    v292.i32[1] = *(_DWORD *)v286;
    float32x2_t v293 = vmla_f32(vmul_f32((float32x2_t)v290, vneg_f32(v291)), v292, (float32x2_t)v289);
    *(float32x2_t *)__int128 buf = vsub_f32(vmul_f32(*(float32x2_t *)(v158 + 16), (float32x2_t)vdup_n_s32(0x411CE80Au)), v293);
    *(_DWORD *)&uint8_t buf[8] = v289.i32[0];
    uint64_t v294 = *(void *)(a1 + 192);
    if (v294)
    {
      unint64_t v295 = v294 + *(void *)(a1 + 184) - 1;
      v296 = *(void ***)(a1 + 160);
      if (*((double *)v296[v295 / 0xAA] + 3 * (v295 % 0xAA)) - v413 > 0.1)
      {
        uint64_t v297 = *(void *)(a1 + 168);
        *(void *)(a1 + 192) = 0LL;
        unint64_t v298 = v297 - (void)v296;
        if (v298 >= 0x11)
        {
          do
          {
            operator delete(*v296);
            uint64_t v299 = *(void *)(a1 + 168);
            v296 = (void **)(*(void *)(a1 + 160) + 8LL);
            *(void *)(a1 + 160) = v296;
            unint64_t v298 = v299 - (void)v296;
          }

          while (v298 > 0x10);
        }

        if (v298 >> 3 == 1)
        {
          uint64_t v300 = 85LL;
        }

        else
        {
          if (v298 >> 3 != 2) {
            goto LABEL_286;
          }
          uint64_t v300 = 170LL;
        }

        *(void *)(a1 + 184) = v300;
      }
    }

LABEL_286:
    sub_1005A24BC((void *)(a1 + 152), &v413, (uint64_t *)buf);
    v408 += 6;
    if ((float *)((char *)v408 - *v141) == (float *)4080)
    {
      v301 = (float *)v141[1];
      ++v141;
      v408 = v301;
    }

    v158 += 56LL;
    if (v158 - *v384 == 4088)
    {
      uint64_t v158 = v384[1];
      ++v384;
    }

    double v193 = v385 + v276;
    ++v407;
    double v194 = v390;
    double v189 = v413;
    double v195 = v246;
    double v196 = v402;
    double v197 = v398;
    float v67 = v364;
  }

  while (v269 != v365);
  v308 = v356;
  *(float *)&unsigned int v309 = v367 + v366;
  *(float *)&unsigned int v310 = v366;
  *(void *)((char *)&v426 + 4) = __PAIR64__(v310, v309);
  float v311 = v367;
  *((float *)&v426 + 3) = v311;
  int32x2_t v312 = *(int32x2_t *)(a1 + 2536);
  v423[0].n128_u64[0] = (unint64_t)vrev64_s32(v312);
  double v313 = 0.0;
  double v314 = 0.0;
  v315 = v355;
  if (v352 >= 1) {
    double v314 = v348 / (double)v352;
  }
  *(float *)&unsigned int v316 = v314;
  *(float *)&unsigned int v317 = v351 - v350;
  *(void *)&__int128 v424 = __PAIR64__(v317, v316);
  float v318 = v369;
  float v319 = v375 - v374;
  v423[1].n128_f32[3] = v318;
  v423[1].n128_f32[0] = v319;
  float v320 = v405;
  *(float *)&unsigned int v321 = v368;
  *(float *)&unsigned int v322 = v406;
  v423[0].n128_u64[1] = __PAIR64__(v321, v322);
  float v323 = v370;
  *((float *)&v424 + 2) = v320;
  *((float *)&v425 + 2) = v323;
  if (v376 >= 1) {
    double v313 = v363 / (double)v376;
  }
  *(float *)&unsigned int v324 = v313;
  *(float *)&unsigned int v325 = v371;
  *(unint64_t *)((char *)v423[1].n128_u64 + 4) = __PAIR64__(v324, v325);
  float v326 = v373;
  float v327 = v372;
  *((float *)&v424 + 3) = v326;
  *(float *)&__int128 v425 = v327;
  float v328 = v198;
  *((float *)&v425 + 1) = v328;
  if ((_DWORD)v365) {
    double v329 = v192 / (double)(int)v365;
  }
  else {
    double v329 = 0.0;
  }
  float v332 = v329;
  *(float *)&__int128 v427 = v332;
  double v330 = *(double *)(a1 + 448);
  *((double *)&v427 + 1) = *v377 + v330;
  double v331 = sqrt(v193 / (double)v365);
LABEL_308:
  double v333 = *(float *)v312.i32 * 100.0;
  *(double *)&__int128 v409 = v333;
  *((double *)&v409 + 1) = v331;
  *(double *)&__int128 v410 = v191;
  *((double *)&v410 + 1) = v190;
  double v334 = *v315 + v330;
  double v335 = v330 + *v308;
  if (v335 - v334 > 0.0)
  {
    float v336 = 2.0 / (v335 - v334);
    *((float *)&v427 + 1) = v336;
  }

  v412[0] = 0.0;
  if (sub_1005A25B4((double *)&v409, v412))
  {
    *(double *)__int128 buf = v412[0];
    *(double *)&uint8_t buf[8] = v335;
    *(_OWORD *)&uint8_t buf[16] = v409;
    __int128 v431 = v410;
    sub_1005A2674((void *)(a1 + 344), (uint64_t)buf);
  }

  else
  {
    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    v337 = (os_log_s *)qword_101934748;
    if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134218752;
      *(double *)&uint8_t buf[4] = v333;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(double *)&buf[14] = v331;
      *(_WORD *)&_BYTE buf[22] = 2048;
      *(double *)&buf[24] = v191;
      LOWORD(v4sub_100231C10(v2 + 31) = 2048;
      *(double *)((char *)&v431 + 2) = v190;
      _os_log_impl( (void *)&_mh_execute_header,  v337,  OS_LOG_TYPE_ERROR,  "[FormModels] Invalid StrideLength features (%.f,%.f,%.f,%.f)",  buf,  0x2Au);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      *(_DWORD *)v418 = 134218752;
      *(double *)&v418[4] = v333;
      *(_WORD *)&v418[12] = 2048;
      *(double *)&v418[14] = v331;
      __int16 v419 = 2048;
      double v420 = v191;
      __int16 v421 = 2048;
      double v422 = v190;
      LODWORD(v347) = 42;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  16LL,  "[FormModels] Invalid StrideLength features (%.f,%.f,%.f,%.f)",  COERCE_DOUBLE(v418),  v347,  v348,  v349);
      v341 = (char *)v340;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLRunning::FormModels::feedDeviceMotion(const DeviceMotionQueue &, const StepQueue &)",  "%s\n",  v340);
      if (v341 != buf) {
        free(v341);
      }
      float v67 = v364;
    }
  }

  *(double *)&__int128 v428 = v334;
  *((double *)&v428 + 1) = v335;
  sub_1005A2720((void *)(a1 + 296), (__int128 *)v423);
  if (__p)
  {
    v416 = __p;
    operator delete(__p);
  }

  uint64_t v60 = v353;
LABEL_68:
  if (*(double *)(a1 + 432) < v67)
  {
    *(double *)(a1 + 432) = v67;
    *(void *)(a1 + 424) = *(void *)v60;
  }

void sub_1005A0DE4(_Unwind_Exception *a1)
{
  uint64_t v2 = (void *)STACK[0x238];
  if (STACK[0x238])
  {
    STACK[0x240] = (unint64_t)v2;
    operator delete(v2);
  }

  _Unwind_Resume(a1);
}

void sub_1005A0E38(uint64_t a1, void *a2, double *a3)
{
  uint64_t v4 = a2[5];
  if (v4)
  {
    unint64_t v5 = a2[4];
    uint64_t v6 = a2[1];
    double v7 = *(double *)(*(void *)(v6 + 8 * ((v4 + v5 - 1) / 0x17)) + 176 * ((v4 + v5 - 1) % 0x17) + 8);
    if (*a3 != v7)
    {
      if (a2[2] == v6)
      {
        uint64_t v8 = 0LL;
        uint64_t v11 = 0LL;
        uint64_t v10 = (void *)(v6 + 8 * ((v5 + v4) / 0x17));
      }

      else
      {
        uint64_t v8 = *(void *)(v6 + 8 * (v5 / 0x17)) + 176 * (v5 % 0x17);
        unint64_t v9 = v5 + v4;
        uint64_t v10 = (void *)(v6 + 8 * (v9 / 0x17));
        uint64_t v11 = *v10 + 176 * (v9 % 0x17);
      }

      double v12 = sub_1005A5454((void *)(v6 + 8 * (v5 / 0x17)), v8, v10, v11);
      if (v12 <= 0.0)
      {
        bzero(__src, 0x404uLL);
        bzero(v17, 0x404uLL);
      }

      else
      {
        sub_1005A5DF4(v17, v12 * 0.65);
        sub_1005A5DF4(v15, v12 * 1.15);
        sub_1005A5DF4(v14, v12 * 2.15);
        for (uint64_t i = 0LL; i != 1028; i += 4LL)
          *(float *)&__src[i] = *(float *)&v15[i] + *(float *)&v14[i];
      }

      memcpy(a3 + 2, __src, 0x404uLL);
      memcpy((char *)a3 + 1044, v17, 0x404uLL);
      *a3 = v7;
      a3[1] = v12;
    }
  }

  else
  {
    bzero(a3, 0x818uLL);
  }

BOOL sub_1005A10C4(void *a1, uint64_t a2)
{
  unint64_t v2 = a1[5];
  if (v2 >= 0x100)
  {
    std::string __p = 0LL;
    float v66 = 0LL;
    float v67 = 0LL;
    float32x2_t v63 = 0LL;
    float v64 = 0.0;
    unint64_t v4 = a1[4] + v2;
    uint64_t v5 = a1[1];
    uint64_t v6 = a1[2];
    double v7 = (uint64_t *)(v5 + 8 * (v4 / 0x49));
    uint64_t v8 = *v7;
    unint64_t v9 = *v7 + 56 * (v4 % 0x49);
    if (v6 == v5) {
      unint64_t v9 = 0LL;
    }
    uint64_t v10 = v9 - v8;
    uint64_t v11 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v9 - v8) >> 3);
    unint64_t v58 = v2;
    if (v10 < 14337)
    {
      unint64_t v15 = 328 - v11;
      unint64_t v13 = &v7[-(v15 / 0x49)];
      unint64_t v14 = *v13 + 56 * (73 * (v15 / 0x49) - v15) + 4032;
    }

    else
    {
      unint64_t v12 = v11 - 256;
      unint64_t v13 = &v7[v12 / 0x49];
      unint64_t v14 = *v13 + 56 * (v12 % 0x49);
    }

    while (1)
    {
      if (v6 == v5)
      {
        unint64_t v17 = 0LL;
      }

      else
      {
        unint64_t v16 = a1[5] + a1[4];
        unint64_t v17 = *(void *)(v5 + 8 * (v16 / 0x49)) + 56 * (v16 % 0x49);
      }

      if (v14 == v17) {
        break;
      }
      int v18 = (uint64_t *)(v14 + 28);
      unint64_t v19 = v66;
      if (v66 >= (_DWORD *)v67)
      {
        unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * (((char *)v66 - (_BYTE *)__p) >> 2);
        unint64_t v23 = v22 + 1;
        if (v22 + 1 > 0x1555555555555555LL) {
          sub_100007008();
        }
        if (0x5555555555555556LL * ((v67 - (_BYTE *)__p) >> 2) > v23) {
          unint64_t v23 = 0x5555555555555556LL * ((v67 - (_BYTE *)__p) >> 2);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v67 - (_BYTE *)__p) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
          unint64_t v24 = 0x1555555555555555LL;
        }
        else {
          unint64_t v24 = v23;
        }
        if (v24) {
          uint64_t v25 = (char *)sub_1005AADE4((uint64_t)&v67, v24);
        }
        else {
          uint64_t v25 = 0LL;
        }
        uint64_t v26 = &v25[12 * v22];
        uint64_t v27 = *v18;
        *((_DWORD *)v26 + 2) = *(_DWORD *)(v14 + 36);
        *(void *)uint64_t v26 = v27;
        unint64_t v29 = __p;
        int v28 = v66;
        int v30 = v26;
        if (v66 != __p)
        {
          do
          {
            uint64_t v31 = *(void *)(v28 - 3);
            v28 -= 3;
            int v32 = v28[2];
            *(void *)(v30 - 12) = v31;
            v30 -= 12;
            *((_DWORD *)v30 + 2) = v32;
          }

          while (v28 != v29);
          int v28 = __p;
        }

        uint64_t v21 = v26 + 12;
        std::string __p = v30;
        float v66 = v26 + 12;
        float v67 = &v25[12 * v24];
        if (v28) {
          operator delete(v28);
        }
      }

      else
      {
        uint64_t v20 = *v18;
        _OWORD v66[2] = *(_DWORD *)(v14 + 36);
        *unint64_t v19 = v20;
        uint64_t v21 = (_DWORD *)v19 + 3;
      }

      unint64_t v33 = 0LL;
      float v66 = v21;
      do
      {
        float v34 = sub_1002B8AF0(v14 + 28, v33);
        __int16 v35 = (float *)sub_1002BA24C((uint64_t)&v63, v33);
        *__int16 v35 = v34 + *v35;
        ++v33;
      }

      while (v33 != 3);
      v14 += 56LL;
      if (v14 - *v13 == 4088)
      {
        unint64_t v36 = v13[1];
        ++v13;
        unint64_t v14 = v36;
      }

      uint64_t v5 = a1[1];
      uint64_t v6 = a1[2];
    }

    float32x2_t v61 = vmul_f32(v63, (float32x2_t)vdup_n_s32(0x3B800000u));
    float v62 = v64 * 0.0039062;
    sub_1005A5CAC((uint64_t *)&__p, &v61, (uint64_t)&v59);
    unint64_t v37 = a1[4] + a1[5];
    uint64_t v38 = a1[1];
    uint64_t v39 = (uint64_t *)(v38 + 8 * (v37 / 0x49));
    uint64_t v40 = *v39;
    unint64_t v41 = *v39 + 56 * (v37 % 0x49);
    if (a1[2] == v38) {
      unint64_t v41 = 0LL;
    }
    uint64_t v42 = v41 - v40;
    uint64_t v43 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v41 - v40) >> 3);
    unint64_t v2 = v58;
    if (v42 < 7169)
    {
      uint64_t v49 = 200 - v43;
      unint64_t v50 = (200 - v43) / 0x49uLL;
      unint64_t v46 = &v39[-v50];
      uint64_t v47 = *v46;
      uint64_t v48 = *v46 + 56 * (73 * v50 - v49) + 4032;
    }

    else
    {
      uint64_t v44 = v43 - 128;
      unint64_t v45 = (v43 - 128) / 0x49uLL;
      unint64_t v46 = &v39[v45];
      uint64_t v47 = *v46;
      uint64_t v48 = *v46 + 56 * (v44 - 73 * v45);
    }

    uint64_t v51 = v59;
    int v52 = v60;
    uint64_t v53 = v48 - v47;
    uint64_t v54 = 0x6DB6DB6DB6DB6DB7LL * ((v48 - v47) >> 3);
    if (v53 < -55) {
      unint64_t v55 = v46[-((71 - v54) / 0x49uLL)] + 56 * (73 * ((71 - v54) / 0x49uLL) - (71 - v54)) + 4032;
    }
    else {
      unint64_t v55 = v46[(v54 + 1) / 0x49uLL] + 56 * ((v54 + 1) % 0x49uLL);
    }
    *(double *)a2 = (*(double *)(v48 + 40) + *(double *)(v55 + 40)) * 0.5;
    *(void *)(a2 + _Block_object_dispose(va, 8) = v51;
    *(_DWORD *)(a2 + 16) = v52;
    if (__p)
    {
      float v66 = __p;
      operator delete(__p);
    }
  }

  return v2 > 0xFF;
}

void sub_1005A1574( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1005A159C(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1005A8E1C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  uint64_t v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  *uint64_t v8 = result;
  ++a1[5];
  return result;
}

void sub_1005A1648(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v7 = *(void **)a1;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = v8 - **(void **)a1;
  uint64_t v10 = 0x6DB6DB6DB6DB6DB7LL * (v9 >> 3);
  if (v9 < -7167) {
    unint64_t v11 = v7[-((-56 - v10) / 0x49uLL)] + 56 * (73 * ((-56 - v10) / 0x49uLL) - (-56 - v10)) + 4032;
  }
  else {
    unint64_t v11 = v7[(v10 + 128) / 0x49uLL] + 56 * ((v10 + 128) % 0x49uLL);
  }
  uint64_t v12 = 0LL;
  __int128 v18 = *(unint64_t *)(v11 + 40);
  LODWORD(vsub_100210A00(v2 + 19) = 0;
  while (v8 != *(void *)(a2 + 8))
  {
    for (unint64_t i = 0LL; i != 3; ++i)
    {
      float v14 = sub_1002B8AF0(v8 + 16, i);
      float v15 = *(float *)(a3 + 4 * v12);
      unint64_t v16 = (float *)sub_1002BA24C((uint64_t)&v18 + 8, i);
      *unint64_t v16 = *v16 + (float)(v14 * v15);
    }

    v8 += 56LL;
    if (v8 - *v7 == 4088)
    {
      uint64_t v17 = v7[1];
      ++v7;
      uint64_t v8 = v17;
    }

    if (++v12 == 257)
    {
      *(_OWORD *)a4 = v18;
      *(void *)(a4 + 16) = v19;
      return;
    }
  }

  *(void *)a4 = 0LL;
  *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
}

__n128 sub_1005A17E8(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1005A91E4(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  uint64_t v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  *uint64_t v8 = result;
  ++a1[5];
  return result;
}

void *sub_1005A1894(void *a1, double *a2, void *a3, double *a4, double *a5)
{
  uint64_t v5 = a2;
  uint64_t v6 = a1;
  if (a4 != a2)
  {
    unint64_t v7 = 170 * (a3 - a1)
    if (v7)
    {
      do
      {
        unint64_t v9 = v7 >> 1;
        uint64_t v12 = v6;
        unint64_t v13 = v5;
        sub_10025BC20(&v12, v7 >> 1);
        uint64_t v10 = v13;
        if (*v13 < *a5)
        {
          uint64_t v5 = v13 + 3;
          v13 += 3;
          uint64_t v6 = v12;
          if ((double *)((char *)v10 - *v12 + 24) == (double *)4080)
          {
            uint64_t v6 = v12 + 1;
            uint64_t v5 = (double *)v12[1];
          }

          unint64_t v9 = v7 + ~v9;
        }

        unint64_t v7 = v9;
      }

      while (v9);
    }
  }

  return v6;
}

void *sub_1005A1978(void *a1, double *a2, void *a3, double *a4, double *a5)
{
  uint64_t v5 = a2;
  uint64_t v6 = a1;
  if (a4 != a2)
  {
    unint64_t v7 = 170 * (a3 - a1)
    if (v7)
    {
      do
      {
        unint64_t v9 = v7 >> 1;
        unint64_t v11 = v6;
        uint64_t v12 = v5;
        sub_10025BC20(&v11, v7 >> 1);
        if (*v12 < *a5)
        {
          uint64_t v6 = v11;
          uint64_t v5 = v12 + 3;
          if ((double *)((char *)v12 - *v11 + 24) == (double *)4080)
          {
            uint64_t v6 = v11 + 1;
            uint64_t v5 = (double *)v11[1];
          }

          unint64_t v9 = v7 + ~v9;
        }

        unint64_t v7 = v9;
      }

      while (v9);
    }
  }

  return v6;
}

void *sub_1005A1A58(void *a1, uint64_t a2, void *a3, uint64_t a4, double *a5)
{
  uint64_t v5 = a2;
  uint64_t v6 = a1;
  if (a4 != a2)
  {
    unint64_t v7 = 73 * (a3 - a1) + 0x6DB6DB6DB6DB6DB7LL * ((a4 - *a3) >> 3) - 0x6DB6DB6DB6DB6DB7LL * ((a2 - *a1) >> 3);
    if (v7)
    {
      do
      {
        unint64_t v9 = v7 >> 1;
        uint64_t v12 = v6;
        uint64_t v13 = v5;
        sub_1005A9130(&v12, v7 >> 1);
        uint64_t v10 = v13;
        if (*(double *)(v13 + 40) < *a5)
        {
          uint64_t v5 = v13 + 56;
          v13 += 56LL;
          uint64_t v6 = v12;
          if (v10 + 56 - *v12 == 4088)
          {
            uint64_t v6 = v12 + 1;
            uint64_t v5 = v12[1];
          }

          unint64_t v9 = v7 + ~v9;
        }

        unint64_t v7 = v9;
      }

      while (v9);
    }
  }

  return v6;
}

void *sub_1005A1B50(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2 != a4)
  {
    uint64_t v5 = *result;
    uint64_t v6 = a2;
    unint64_t v7 = result;
    while (1)
    {
      v6 += 24LL;
      if (v6 - v5 == 4080)
      {
        uint64_t v8 = v7[1];
        ++v7;
        uint64_t v5 = v8;
        uint64_t v6 = v8;
      }

      if (v6 == a4) {
        return result;
      }
      double v9 = *(float *)(a2 + 8);
      int v10 = *(_DWORD *)(a5 + 2664);
      if (v10 == 1)
      {
        if (*(_DWORD *)(a5 + 2668) != 1)
        {
LABEL_9:
          double v11 = *(float *)(v6 + 8);
          goto LABEL_18;
        }
      }

      else
      {
        if (v10) {
          goto LABEL_12;
        }
        if (*(_DWORD *)(a5 + 2668)) {
          goto LABEL_9;
        }
      }

      double v9 = -v9;
LABEL_12:
      double v11 = *(float *)(v6 + 8);
      if (v10 == 1)
      {
        if (*(_DWORD *)(a5 + 2668) == 1) {
          goto LABEL_17;
        }
      }

      else if (!v10 && !*(_DWORD *)(a5 + 2668))
      {
LABEL_17:
        double v11 = -v11;
      }

void *sub_1005A1C04(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2 != a4)
  {
    uint64_t v5 = *result;
    uint64_t v6 = a2;
    unint64_t v7 = result;
    while (1)
    {
      v6 += 24LL;
      if (v6 - v5 == 4080)
      {
        uint64_t v8 = v7[1];
        ++v7;
        uint64_t v5 = v8;
        uint64_t v6 = v8;
      }

      if (v6 == a4) {
        return result;
      }
      double v9 = *(float *)(v6 + 8);
      int v10 = *(_DWORD *)(a5 + 2664);
      if (v10 == 1)
      {
        if (*(_DWORD *)(a5 + 2668) != 1)
        {
LABEL_9:
          double v11 = *(float *)(a2 + 8);
          goto LABEL_18;
        }
      }

      else
      {
        if (v10) {
          goto LABEL_12;
        }
        if (*(_DWORD *)(a5 + 2668)) {
          goto LABEL_9;
        }
      }

      double v9 = -v9;
LABEL_12:
      double v11 = *(float *)(a2 + 8);
      if (v10 == 1)
      {
        if (*(_DWORD *)(a5 + 2668) == 1) {
          goto LABEL_17;
        }
      }

      else if (!v10 && !*(_DWORD *)(a5 + 2668))
      {
LABEL_17:
        double v11 = -v11;
      }

BOOL sub_1005A1CB8(uint64_t **a1, uint64_t a2, float32x2_t **a3, double a4)
{
  uint64_t v4 = a1[1];
  uint64_t v5 = *(uint64_t **)(a2 + 8);
  if (v4 != v5)
  {
    uint64_t v48 = *(uint64_t **)(a2 + 8);
    uint64_t v8 = 0LL;
    std::string __p = 0LL;
    uint64_t v51 = 0LL;
    int v52 = 0LL;
    double v9 = *a1;
    int v10 = (uint64_t *)**a1;
    float32x2_t v11 = 0LL;
    float v12 = 0.0;
    float32x2_t v13 = (float32x2_t)vdup_n_s32(0x409CE80Au);
    float v14 = 0.0;
    uint64_t v49 = v4;
    float32x2_t v15 = 0LL;
    do
    {
      uint64_t v16 = (char *)v4 - (char *)v10;
      unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (v4 - v10);
      if (v16 < 25) {
        unint64_t v18 = v9[-((170 - v17) / 0xAA)] + 24 * (170 * ((170 - v17) / 0xAA) - (170 - v17)) + 4056;
      }
      else {
        unint64_t v18 = v9[(v17 - 1) / 0xAA] + 24 * ((v17 - 1) % 0xAA);
      }
      float v19 = *(double *)v4 - *(double *)v18;
      float32x2_t v15 = vadd_f32(v15, vmul_f32(vmul_n_f32(vadd_f32(*(float32x2_t *)(v18 + 8), (float32x2_t)v4[1]), v19), v13));
      float v12 = v12 + (float)((float)((float)(*(float *)(v18 + 16) + *((float *)v4 + 4)) * v19) * 4.9033);
      if (v8 >= v52)
      {
        unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (char *)__p) >> 2);
        unint64_t v21 = v20 + 1;
        if (v20 + 1 > 0x1555555555555555LL) {
          sub_100007008();
        }
        else {
          unint64_t v22 = v21;
        }
        if (v22) {
          unint64_t v23 = (char *)sub_1005AADE4((uint64_t)&v52, v22);
        }
        else {
          unint64_t v23 = 0LL;
        }
        unint64_t v24 = (float32x2_t *)&v23[12 * v20];
        *unint64_t v24 = v15;
        v24[1].f32[0] = v12;
        uint64_t v25 = v51;
        uint64_t v26 = v24;
        if (v51 != __p)
        {
          do
          {
            float32x2_t v27 = *(float32x2_t *)((char *)v25 - 12);
            uint64_t v25 = (float32x2_t *)((char *)v25 - 12);
            __int32 v28 = v25[1].i32[0];
            *(float32x2_t *)((char *)v26 - 12) = v27;
            uint64_t v26 = (float32x2_t *)((char *)v26 - 12);
            v26[1].i32[0] = v28;
          }

          while (v25 != __p);
          uint64_t v25 = __p;
        }

        uint64_t v8 = (float32x2_t *)((char *)v24 + 12);
        std::string __p = v26;
        int v52 = (float32x2_t *)&v23[12 * v22];
        if (v25) {
          operator delete(v25);
        }
      }

      else
      {
        *uint64_t v8 = v15;
        v8[1].f32[0] = v12;
        uint64_t v8 = (float32x2_t *)((char *)v8 + 12);
      }

      uint64_t v51 = v8;
      v4 += 3;
      int v10 = (uint64_t *)*v9;
      if ((uint64_t *)((char *)v4 - *v9) == (uint64_t *)4080)
      {
        unint64_t v29 = (uint64_t *)v9[1];
        ++v9;
        int v10 = v29;
        uint64_t v4 = v29;
      }

      float32x2_t v11 = vadd_f32(v11, v15);
      float v14 = v14 + v12;
    }

    while (v4 != *(uint64_t **)(a2 + 8));
    int v30 = __p;
    if (v8 != __p)
    {
      *(float *)&a4 = (float)(0xAAAAAAAAAAAAAAABLL * (((char *)v8 - (char *)__p) >> 2));
      float32x2_t v31 = vdiv_f32(v11, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0));
      float v32 = v14 / *(float *)&a4;
      unint64_t v33 = a3 + 2;
      float v34 = a3[1];
      do
      {
        float32x2_t v35 = vsub_f32(*v30, v31);
        float v36 = v30[1].f32[0] - v32;
        if ((unint64_t)v34 >= *v33)
        {
          unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * (((char *)v34 - (char *)*a3) >> 2);
          unint64_t v38 = v37 + 1;
          if (v37 + 1 > 0x1555555555555555LL) {
            sub_100007008();
          }
          else {
            unint64_t v39 = v38;
          }
          if (v39) {
            uint64_t v40 = (char *)sub_1005AADE4((uint64_t)(a3 + 2), v39);
          }
          else {
            uint64_t v40 = 0LL;
          }
          unint64_t v41 = (float32x2_t *)&v40[12 * v37];
          *unint64_t v41 = v35;
          v41[1].f32[0] = v36;
          uint64_t v43 = *a3;
          uint64_t v42 = a3[1];
          uint64_t v44 = v41;
          if (v42 != *a3)
          {
            do
            {
              float32x2_t v45 = *(float32x2_t *)((char *)v42 - 12);
              uint64_t v42 = (float32x2_t *)((char *)v42 - 12);
              __int32 v46 = v42[1].i32[0];
              *(float32x2_t *)((char *)v44 - 12) = v45;
              uint64_t v44 = (float32x2_t *)((char *)v44 - 12);
              v44[1].i32[0] = v46;
            }

            while (v42 != v43);
            uint64_t v42 = *a3;
          }

          float v34 = (float32x2_t *)((char *)v41 + 12);
          *a3 = v44;
          a3[1] = (float32x2_t *)((char *)v41 + 12);
          a3[2] = (float32x2_t *)&v40[12 * v39];
          if (v42) {
            operator delete(v42);
          }
        }

        else
        {
          *float v34 = v35;
          v34[1].f32[0] = v36;
          float v34 = (float32x2_t *)((char *)v34 + 12);
        }

        a3[1] = v34;
        int v30 = (float32x2_t *)((char *)v30 + 12);
      }

      while (v30 != v8);
      int v30 = __p;
    }

    uint64_t v5 = v48;
    uint64_t v4 = v49;
    if (v30) {
      operator delete(v30);
    }
  }

  return v4 != v5;
}

void sub_1005A2098( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1005A20C0(float a1, float a2, float a3, float a4, float a5, float a6)
{
  float v6 = a6;
  float v7 = a5;
  float v8 = a4;
  float v9 = a3;
  float v10 = a2;
  float v11 = a1;
  uint64_t v12 = 0LL;
  float v25 = a1;
  float v26 = a2;
  float v27 = a3;
  float v13 = 0.0;
  do
  {
    float v13 = v13 + (float)(*(float *)((char *)&v25 + v12) * *(float *)((char *)&v25 + v12));
    v12 += 4LL;
  }

  while (v12 != 12);
  if (sqrtf(v13) > 0.00000011921)
  {
    uint64_t v14 = 0LL;
    float v15 = 0.0;
    do
    {
      float v15 = v15 + (float)(*(float *)((char *)&v25 + v14) * *(float *)((char *)&v25 + v14));
      v14 += 4LL;
    }

    while (v14 != 12);
    float v16 = sqrtf(v15);
    float v11 = v11 / v16;
    float v10 = a2 / v16;
    float v9 = a3 / v16;
  }

  uint64_t v17 = 0LL;
  float v25 = a4;
  float v26 = a5;
  float v18 = 0.0;
  float v27 = a6;
  do
  {
    float v18 = v18 + (float)(*(float *)((char *)&v25 + v17) * *(float *)((char *)&v25 + v17));
    v17 += 4LL;
  }

  while (v17 != 12);
  if (sqrtf(v18) > 0.00000011921)
  {
    uint64_t v19 = 0LL;
    float v20 = 0.0;
    do
    {
      float v20 = v20 + (float)(*(float *)((char *)&v25 + v19) * *(float *)((char *)&v25 + v19));
      v19 += 4LL;
    }

    while (v19 != 12);
    float v21 = sqrtf(v20);
    float v8 = a4 / v21;
    float v7 = a5 / v21;
    float v6 = a6 / v21;
  }

  *(float *)&double result = acosf(fmaxf(fminf((float)((float)(v9 * v6) + (float)(v10 * v7)) + (float)(v11 * v8), 1.0), -1.0));
  if (*(float *)&result < 0.7854)
  {
    uint64_t v23 = 0LL;
    float v25 = (float)(v10 * v6) - (float)(v9 * v7);
    float v26 = (float)(v9 * v8) - (float)(v11 * v6);
    float v27 = (float)(v11 * v7) - (float)(v10 * v8);
    float v24 = 0.0;
    do
    {
      float v24 = v24 + (float)(*(float *)((char *)&v25 + v23) * *(float *)((char *)&v25 + v23));
      v23 += 4LL;
    }

    while (v23 != 12);
    *(float *)&double result = asinf(fmaxf(fminf(sqrtf(v24), 1.0), -1.0));
  }

  return result;
}

uint64_t sub_1005A2288(void *a1, double a2, uint64_t a3, double *a4, _DWORD *a5)
{
  uint64_t v5 = (double *)a1[1];
  if (v5 == a4) {
    return 0LL;
  }
  float v8 = (void *)*a1;
  uint64_t v9 = (uint64_t)v5 - *(void *)*a1;
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 3);
  if (v9 < -23)
  {
    unint64_t v15 = 168 - v10;
    unint64_t v16 = 168 - v10;
    uint64_t v12 = &v8[-((168 - v10) / 0xAA)];
    uint64_t v13 = *v12;
    uint64_t v14 = (double *)(*v12 + 24 * (170 * (v16 / 0xAA) - v15) + 4056);
  }

  else
  {
    unint64_t v11 = v10 + 1;
    uint64_t v12 = &v8[(v10 + 1) / 0xAA];
    uint64_t v13 = *v12;
    uint64_t v14 = (double *)(*v12 + 24 * (v11 % 0xAA));
  }

  if (v14 != a4)
  {
    while (*v14 <= a2)
    {
      float v8 = v12;
      uint64_t v5 = v14;
      uint64_t v17 = (uint64_t)v14 - v13;
      unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (v17 >> 3);
      if (v17 < -23)
      {
        unint64_t v21 = 168 - v18;
        unint64_t v22 = (168 - v18) / 0xAA;
        uint64_t v12 = &v8[-v22];
        uint64_t v13 = *v12;
        uint64_t v14 = (double *)(*v12 + 24 * (170 * v22 - v21) + 4056);
      }

      else
      {
        unint64_t v19 = v18 + 1;
        unint64_t v20 = (v18 + 1) / 0xAA;
        uint64_t v12 = &v8[v20];
        uint64_t v13 = *v12;
        uint64_t v14 = (double *)(*v12 + 24 * (v19 - 170 * v20));
      }

      if (v14 == a4) {
        goto LABEL_18;
      }
    }

    *a1 = v8;
    a1[1] = v5;
    if (*v5 <= a2 && *v14 > a2)
    {
      for (unint64_t i = 0LL; i != 3; ++i)
      {
        double v24 = *v5;
        double v25 = *(float *)sub_1002BA24C((uint64_t)(v5 + 1), i);
        double v26 = *v14;
        float v27 = (float *)sub_1002BA24C((uint64_t)(v14 + 1), i);
        *(float *)&double v24 = sub_100940328(v24, v25, v26, *v27, a2);
        *(_DWORD *)sub_1002BA24C((uint64_t)a5, i) = LODWORD(v24);
      }

      return 1LL;
    }

    return 0LL;
  }

uint64_t sub_1005A24BC(void *a1, void *a2, uint64_t *a3)
{
  uint64_t v6 = a1[2];
  uint64_t v7 = a1[1];
  uint64_t v8 = 170 * ((v6 - v7) >> 3) - 1;
  if (v6 == v7) {
    uint64_t v8 = 0LL;
  }
  unint64_t v9 = a1[5] + a1[4];
  if (v8 == v9)
  {
    sub_1005A94F8(a1);
    uint64_t v7 = a1[1];
    unint64_t v9 = a1[5] + a1[4];
  }

  unint64_t v10 = *(void *)(v7 + 8 * (v9 / 0xAA)) + 24 * (v9 % 0xAA);
  int v11 = *((_DWORD *)a3 + 2);
  uint64_t v12 = *a3;
  *(void *)unint64_t v10 = *a2;
  *(void *)(v10 + _Block_object_dispose(va, 8) = v12;
  *(_DWORD *)(v10 + 16) = v11;
  uint64_t v13 = a1[4];
  uint64_t v14 = a1[5] + 1LL;
  a1[5] = v14;
  unint64_t v15 = v13 + v14;
  uint64_t v16 = a1[1];
  uint64_t v17 = (void *)(v16 + 8 * (v15 / 0xAA));
  uint64_t v18 = *v17 + 24 * (v15 % 0xAA);
  if (a1[2] == v16) {
    uint64_t v18 = 0LL;
  }
  if (v18 == *v17) {
    uint64_t v18 = *(v17 - 1) + 4080LL;
  }
  return v18 - 24;
}

uint64_t sub_1005A25B4(double *a1, double *a2)
{
  double v2 = *a1;
  if (*a1 == -1.0) {
    return 0LL;
  }
  double v3 = a1[1];
  if (v3 == -1.0) {
    return 0LL;
  }
  double v4 = a1[2];
  if (v4 == -1.0) {
    return 0LL;
  }
  double v5 = a1[3];
  if (v5 == -1.0) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  v9[0] = 0xC0013D70A3D70A3DLL;
  *(double *)&v9[1] = v2 * 0.01287;
  *(double *)&_DWORD v9[2] = v3 * 1.742;
  *(double *)&v9[3] = v4 * 0.08599;
  *(double *)&_DWORD v9[4] = v5 * -0.007325;
  double v8 = 0.0;
  do
    double v8 = v8 + *(double *)&v9[v7++];
  while (v7 != 5);
  *a2 = v8;
  return 1LL;
}

__n128 sub_1005A2674(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 85 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1005A980C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x55)) + 48 * (v7 % 0x55);
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v8 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v8 + 32) = v10;
  *(__n128 *)unint64_t v8 = result;
  ++a1[5];
  return result;
}

uint64_t sub_1005A2720(void *a1, __int128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 34 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1005A9B20(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x22)) + 120 * (v7 % 0x22);
  __int128 v9 = *a2;
  __int128 v10 = a2[1];
  __int128 v11 = a2[3];
  *(_OWORD *)(v8 + 32) = a2[2];
  *(_OWORD *)(v8 + 4_Block_object_dispose(va, 8) = v11;
  *(_OWORD *)unint64_t v8 = v9;
  *(_OWORD *)(v8 + 16) = v10;
  __int128 v12 = a2[4];
  __int128 v13 = a2[5];
  __int128 v14 = a2[6];
  *(void *)(v8 + sub_10004AD90(v15 - 112) = *((void *)a2 + 14);
  *(_OWORD *)(v8 + 80) = v13;
  *(_OWORD *)(v8 + 96) = v14;
  *(_OWORD *)(v8 + 64) = v12;
  uint64_t v15 = a1[4];
  uint64_t v16 = a1[5] + 1LL;
  a1[5] = v16;
  unint64_t v17 = v15 + v16;
  uint64_t v18 = a1[1];
  unint64_t v19 = (void *)(v18 + 8 * (v17 / 0x22));
  uint64_t v20 = *v19 + 120 * (v17 % 0x22);
  if (a1[2] == v18) {
    uint64_t v20 = 0LL;
  }
  if (v20 == *v19) {
    uint64_t v20 = *(v19 - 1) + 4080LL;
  }
  return v20 - 120;
}

void sub_1005A2820(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v7 = *(void **)a1;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = v8 - **(void **)a1;
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v9 >> 3);
  if (v9 < -3071) {
    __int128 v11 = (unint64_t *)(v7[-((41 - v10) / 0xAA)] + 24 * (170 * ((41 - v10) / 0xAA) - (41 - v10)) + 4056);
  }
  else {
    __int128 v11 = (unint64_t *)(v7[(v10 + 128) / 0xAA] + 24 * ((v10 + 128) % 0xAA));
  }
  uint64_t v12 = 0LL;
  __int128 v18 = *v11;
  LODWORD(vsub_100210A00(v2 + 19) = 0;
  while (v8 != *(void *)(a2 + 8))
  {
    for (unint64_t i = 0LL; i != 3; ++i)
    {
      float v14 = *(float *)sub_1002BA24C(v8 + 8, i);
      float v15 = *(float *)(a3 + 4 * v12);
      uint64_t v16 = (float *)sub_1002BA24C((uint64_t)&v18 + 8, i);
      *uint64_t v16 = *v16 + (float)(v14 * v15);
    }

    v8 += 24LL;
    if (v8 - *v7 == 4080)
    {
      uint64_t v17 = v7[1];
      ++v7;
      uint64_t v8 = v17;
    }

    if (++v12 == 257)
    {
      *(_OWORD *)a4 = v18;
      *(void *)(a4 + 16) = v19;
      return;
    }
  }

  *(void *)a4 = 0LL;
  *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
  *(_DWORD *)(a4 + 16) = 0;
}

float sub_1005A29A4(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 16))
  {
    unint64_t v4 = 0LL;
    float v5 = 0.0;
    do
    {
      float v5 = v5 + sub_1005A9E34((void *)a1, a2, v4++);
      unint64_t v6 = *(void *)(a1 + 16);
    }

    while (v4 < v6);
    if (v6) {
      return v5 + *(float *)(a1 + 40);
    }
  }

  else
  {
    float v5 = 0.0;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101841248);
  }
  uint64_t v8 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "Assertion failed: this->fForestSize > 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMRandomFor estXGBoostedRegression.h, line 49,fForestSize is 0.",  buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101841248);
    }
    v11[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: this->fForestSize > 0, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMRandomFor estXGBoostedRegression.h, line 49,fForestSize is 0.",  v11,  2);
    unint64_t v10 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "float CMRandomForestXGBoostedRegression<22>::evaluateForest(const float (&)[NFeat]) const [NFeat = 22]",  "%s\n",  v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  return v5 + *(float *)(a1 + 40);
}

uint64_t sub_1005A2B84(void *a1, _OWORD *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1005AA198(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  *(_OWORD *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v7) = *a2;
  uint64_t v8 = a1[4];
  uint64_t v9 = a1[5] + 1LL;
  a1[5] = v9;
  unint64_t v10 = v8 + v9;
  uint64_t v11 = a1[1];
  uint64_t v12 = (void *)(v11 + 8 * (v10 >> 8));
  uint64_t v13 = *v12 + 16LL * v10;
  if (a1[2] == v11) {
    uint64_t v13 = 0LL;
  }
  if (v13 == *v12) {
    uint64_t v13 = *(v12 - 1) + 4096LL;
  }
  return v13 - 16;
}

BOOL sub_1005A2C40(uint64_t a1, void *a2)
{
  if (a2[5] < 0x80uLL)
  {
    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    double v26 = (os_log_s *)qword_101934748;
    if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "[FormController] Has not received enough DeviceMotion samples",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      LOWORD(v93) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  2LL,  "[FormController] Has not received enough DeviceMotion samples",  &v93,  2);
      unint64_t v29 = (uint8_t *)v28;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLRunning::FormModels::calculateGroundContactTime(const DeviceMotionQueue &)",  "%s\n",  v28);
      goto LABEL_57;
    }
  }

  else
  {
    uint64_t v4 = (int *)(a1 + 2664);
    nullsub_10(a1 + 2615);
    sub_100D74900((uint64_t)buf);
    unsigned __int8 v5 = v119[16];
    if (v119[16])
    {
      unint64_t v7 = *(void **)buf;
      uint64_t v6 = *(void **)v119;
      uint64_t v8 = *(void **)&v119[8];
      if ([*(id *)v119 count])
      {
        if ([v8 count])
        {
          if ([v7 count])
          {
            objc_msgSend(objc_msgSend(v7, "objectAtIndexedSubscript:", 0), "doubleValue");
            double v10 = v9;
            objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 0), "doubleValue");
            double v12 = v11;
            objc_msgSend(objc_msgSend(v8, "objectAtIndexedSubscript:", 0), "doubleValue");
            double v13 = v12 * 0.119790152 + 0.838394225;
            double v15 = v14 * 0.10670507 + 1.08953965;
            if (v13 < v15)
            {
              v92[0] = 0LL;
              v92[1] = 0x3F80000000000000LL;
              unint64_t v16 = a2[4];
              uint64_t v17 = a2[1];
              uint64_t v18 = a2[2];
              uint64_t v19 = (uint64_t *)(v17 + 8 * (v16 / 0x49));
              unint64_t v20 = 56 * (v16 % 0x49);
              *(double *)&v92[5] = v13 + *(double *)(*v19 + v20 + 40);
              v92[6] = 0LL;
              v91[0] = 0.0;
              v91[1] = 0.0078125;
              uint64_t v21 = *v19;
              v91[5] = v15 + *(double *)(*v19 + v20 + 40);
              v91[6] = 0.0;
              if (v18 == v17)
              {
                uint64_t v22 = 0LL;
                uint64_t v25 = 0LL;
                double v24 = (void *)(v17
                               + (((unint64_t)(((a2[5] + v16) * (unsigned __int128)0x70381C0E070381C1uLL) >> 64) >> 2) & 0x1FFFFFFFFFFFFFF8LL));
              }

              else
              {
                uint64_t v22 = v21 + 56 * (v16 % 0x49);
                unint64_t v23 = a2[5] + v16;
                double v24 = (void *)(v17 + 8 * (v23 / 0x49));
                uint64_t v25 = *v24 + 56 * (v23 % 0x49);
              }

              LOBYTE(v93) = 0;
              uint64_t v40 = sub_1005AB8F4(v19, v22, v24, v25, (uint64_t)v92);
              uint64_t v42 = v40;
              uint64_t v43 = v41;
              unint64_t v44 = a2[4] + a2[5];
              uint64_t v45 = a2[1];
              __int32 v46 = (void *)(v45 + 8 * (v44 / 0x49));
              if (a2[2] == v45) {
                uint64_t v47 = 0LL;
              }
              else {
                uint64_t v47 = *v46 + 56 * (v44 % 0x49);
              }
              uint64_t v48 = sub_1005AB9EC(v40, v41, v46, v47, (uint64_t)v91);
              uint64_t v50 = v49;
              if (v43 == v49) {
                goto LABEL_71;
              }
              uint64_t v51 = v48;
              double v52 = 0.0;
              uint64_t v53 = v42;
              uint64_t v54 = v43;
              do
              {
                sub_100D74A90(v54, (uint64_t)buf);
                v54 += 56LL;
                if (v54 - *v53 == 4088)
                {
                  uint64_t v55 = v53[1];
                  ++v53;
                  uint64_t v54 = v55;
                }

                double v52 = v52 + *(float *)&v121[6];
              }

              while (v54 != v50);
              uint64_t v56 = 73 * (v51 - v42)
                  + 0x6DB6DB6DB6DB6DB7LL * ((v50 - *v51) >> 3)
                  - 0x6DB6DB6DB6DB6DB7LL * ((v43 - *v42) >> 3);
              if (!v56) {
LABEL_71:
              }
                double v57 = 0.0;
              else {
                double v57 = v52 / (double)(unint64_t)v56;
              }
              int v59 = *v4;
              if (*v4 != 2)
              {
                if (v59 == 1)
                {
                  if (v57 > 0.0) {
                    goto LABEL_76;
                  }
                  goto LABEL_81;
                }

                if (v59)
                {
                  char v61 = 0;
                  int v60 = 0;
                  goto LABEL_82;
                }
              }

              if (v57 < 0.0)
              {
LABEL_76:
                int v60 = 2;
                char v61 = 1;
LABEL_82:
                float v58 = v10 * 0.0446596108 + 0.251163363;
                double v77 = v58;
                uint64_t v62 = a2[1];
                unint64_t v63 = a2[4];
                uint64_t v64 = a2[5];
                double v65 = *(double *)(*(void *)(v62 + 8 * (v63 / 0x49)) + 56 * (v63 % 0x49) + 40);
                double v78 = v13 + v65;
                double v79 = v15 + v65;
                double v80 = v13;
                double v81 = v15;
                double v66 = *(double *)(a1 + 448);
                double v82 = v65 + v66;
                double v83 = v66
                    + *(double *)(*(void *)(v62 + 8 * ((v63 + v64 - 1) / 0x49)) + 56 * ((v63 + v64 - 1) % 0x49) + 40);
                double v84 = v57;
                int v85 = v60;
                unsigned __int8 v86 = v5;
                unsigned __int8 v87 = v61;
                unsigned __int8 v88 = 1;
                int v67 = *(_DWORD *)(a1 + 2668);
                int v89 = v59;
                int v90 = v67;
                sub_1005A8314((void *)(a1 + 2616), (uint64_t)&v77);
                if (qword_101934740 != -1) {
                  dispatch_once(&qword_101934740, &stru_101841208);
                }
                unint64_t v68 = (os_log_s *)qword_101934748;
                if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)__int128 buf = 67112192;
                  *(_DWORD *)&uint8_t buf[4] = v86;
                  *(_WORD *)uint64_t v119 = 2048;
                  *(double *)&v119[2] = v77;
                  *(_WORD *)&v119[10] = 2048;
                  *(double *)&v119[12] = v78;
                  __int16 v120 = 2048;
                  *(double *)uint64_t v121 = v79;
                  *(_WORD *)&v121[8] = 2048;
                  double v122 = v80;
                  __int16 v123 = 2048;
                  double v124 = v81;
                  __int16 v125 = 2048;
                  double v126 = v82;
                  __int16 v127 = 1024;
                  int v128 = v85;
                  __int16 v129 = 1024;
                  int v130 = v87;
                  __int16 v131 = 1024;
                  int v132 = v88;
                  __int16 v133 = 1024;
                  int v134 = v89;
                  __int16 v135 = 1024;
                  int v136 = v90;
                  __int16 v137 = 2048;
                  double v138 = v84;
                  _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_DEBUG,  "[FormController] GCT Prediction,isSuccessful,%d,groundContactTime,%.2f,initialContactTime,%.2f,toeOf fTime,%.2f,relativeInitialContactTime,%.2f,relativeToeOffTime,%.2f,windowStartTime,%.2f,stepSide,%d, isValidSide,%d,isValidToeOff,%d,wristOrientation,%d,crownOrientation,%d, meanRotationZ, %.2f",  buf,  0x6Cu);
                }

                if (sub_1002921D0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_101934740 != -1) {
                    dispatch_once(&qword_101934740, &stru_101841208);
                  }
                  LODWORD(v93) = 67112192;
                  HIDWORD(v93) = v86;
                  __int16 v94 = 2048;
                  double v95 = v77;
                  __int16 v96 = 2048;
                  double v97 = v78;
                  __int16 v98 = 2048;
                  double v99 = v79;
                  __int16 v100 = 2048;
                  double v101 = v80;
                  __int16 v102 = 2048;
                  double v103 = v81;
                  __int16 v104 = 2048;
                  double v105 = v82;
                  __int16 v106 = 1024;
                  int v107 = v85;
                  __int16 v108 = 1024;
                  int v109 = v87;
                  __int16 v110 = 1024;
                  int v111 = v88;
                  __int16 v112 = 1024;
                  int v113 = v89;
                  __int16 v114 = 1024;
                  int v115 = v90;
                  __int16 v116 = 2048;
                  double v117 = v84;
                  LODWORD(v76) = 108;
                  _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  2LL,  "[FormController] GCT Prediction,isSuccessful,%d,groundContactTime,%.2f,initialContactTime,%.2f,toeOf fTime,%.2f,relativeInitialContactTime,%.2f,relativeToeOffTime,%.2f,windowStartTime,%.2f,stepSide,%d, isValidSide,%d,isValidToeOff,%d,wristOrientation,%d,crownOrientation,%d, meanRotationZ, %.2f",  &v93,  v76,  v77,  v78,  v79,  v80,  v81,  LODWORD(v82),  LODWORD(v83),  LODWORD(v84),  v85,  v89,  v91[0]);
                  uint64_t v75 = (uint8_t *)v74;
                  sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLRunning::FormModels::calculateGroundContactTime(const DeviceMotionQueue &)",  "%s\n",  v74);
                  if (v75 != buf) {
                    free(v75);
                  }
                }

                if (sub_1005A61A4(a1))
                {
                  sub_10116FE54((uint64_t)&v77, (uint64_t)buf);
                  if (qword_1019A1D00 != -1) {
                    dispatch_once(&qword_1019A1D00, &stru_101841228);
                  }
                  uint64_t v69 = qword_1019A1D08;
                  if (qword_1019A1D08)
                  {
                    uint64_t v70 = operator new(0x60uLL);
                    sub_10108CC90((uint64_t)v70, (uint64_t)buf);
                    uint64_t v93 = v71;
                    double Current = CFAbsoluteTimeGetCurrent();
                    sub_100B50834(v69, &v93, Current);
                    uint64_t v73 = v93;
                    uint64_t v93 = 0LL;
                    if (v73) {
                      (*(void (**)(uint64_t))(*(void *)v73 + 8LL))(v73);
                    }
                  }

                  PB::Base::~Base((PB::Base *)buf);
                }

                return 1LL;
              }

void sub_1005A3A84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49)
{
}

void sub_1005A3AC0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 == v5)
  {
    int v6 = 0;
LABEL_19:
    double v12 = 0.0;
    goto LABEL_20;
  }

  int v6 = 0;
  double v7 = 0.0;
  do
  {
    int v8 = *(_DWORD *)(v4 + 64);
    if (v8 >= 1)
    {
      double v9 = *(double *)(v4 + 48) - *(double *)(v4 + 8);
      if (v9 > 0.0 && (double)*(int *)(v4 + 112) * 5.12 / v9 >= 0.5)
      {
        double v7 = v7 + *(double *)(v4 + 56) / (double)v8 - *(double *)(v4 + 104);
        ++v6;
      }
    }

    v4 += 120LL;
  }

  while (v4 != v5);
  if (v6 <= 0) {
    goto LABEL_19;
  }
  double v10 = v7 / (double)v6;
  if (v10 <= 2.0)
  {
    if (v10 >= -2.0)
    {
      double v12 = v7 / (double)v6;
      goto LABEL_20;
    }

    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    uint64_t v17 = (os_log_s *)qword_101934748;
    if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134217984;
      double v33 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "[FormModels] StrideLength: Below min bias offset (%.2f)",  buf,  0xCu);
    }

    double v12 = -2.0;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  16LL,  "[FormModels] StrideLength: Below min bias offset (%.2f)");
      goto LABEL_35;
    }
  }

  else
  {
    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    double v11 = (os_log_s *)qword_101934748;
    if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134217984;
      double v33 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "[FormModels] StrideLength: Above max bias offset (%.2f)",  buf,  0xCu);
    }

    double v12 = 2.0;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  16LL,  "[FormModels] StrideLength: Above max bias offset (%.2f)");
LABEL_35:
      uint64_t v18 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLRunning::FormModels::feedCalibrationTracks(const std::vector<CLStrideCalEntry> &)",  "%s\n",  v13);
      if (v18 != buf) {
        free(v18);
      }
    }
  }

void sub_1005A3FE4(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  uint64_t v5 = a2[5];
  if (v5)
  {
    double v47 = a4 + -3.1225;
    double v46 = a4 + -3.1225 + -5.12;
    unint64_t v8 = a2[4];
    uint64_t v9 = a2[1];
    if (a2[2] == v9)
    {
      uint64_t v10 = 0LL;
      uint64_t v13 = 0LL;
      double v12 = (void *)(v9 + 8 * ((v8 + v5) / 0x17));
    }

    else
    {
      uint64_t v10 = *(void *)(v9 + 8 * (v8 / 0x17)) + 176 * (v8 % 0x17);
      unint64_t v11 = v8 + v5;
      double v12 = (void *)(v9 + 8 * (v11 / 0x17));
      uint64_t v13 = *v12 + 176 * (v11 % 0x17);
    }

    LOBYTE(vsub_1005A8D88(v2 + 43) = 0;
    double v14 = sub_1005AACEC((void *)(v9 + 8 * (v8 / 0x17)), v10, v12, v13, &v46);
    unint64_t v16 = v14;
    unint64_t v17 = v15;
    unint64_t v18 = a2[4] + a2[5];
    uint64_t v19 = a2[1];
    unint64_t v20 = (void *)(v19 + 8 * (v18 / 0x17));
    if (a2[2] == v19) {
      uint64_t v21 = 0LL;
    }
    else {
      uint64_t v21 = *v20 + 176 * (v18 % 0x17);
    }
    LOBYTE(vsub_1005A8D88(v2 + 43) = 0;
    uint64_t v22 = sub_1005AACEC(v14, v15, v20, v21, &v47);
    unint64_t v24 = v23;
    unint64_t v25 = a2[4];
    uint64_t v26 = a2[1];
    uint64_t v27 = a2[2];
    __int16 v28 = (void *)(v26 + 8 * (v25 / 0x17));
    if (v27 == v26) {
      unint64_t v29 = 0LL;
    }
    else {
      unint64_t v29 = *v28 + 176 * (v25 % 0x17);
    }
    if (v29 == v24)
    {
      double v33 = &v47;
    }

    else
    {
      uint64_t v30 = v24 - *v22;
      uint64_t v31 = 0x2E8BA2E8BA2E8BA3LL * (v30 >> 4);
      if (v30 < 177) {
        unint64_t v32 = v22[-((23 - v31) / 0x17uLL)] + 176 * (23 * ((23 - v31) / 0x17uLL) - (23 - v31)) + 3872;
      }
      else {
        unint64_t v32 = v22[(v31 - 1) / 0x17uLL] + 176 * ((v31 - 1) % 0x17uLL);
      }
      double v33 = (double *)(v32 + 8);
    }

    if (v27 == v26) {
      uint64_t v34 = 0LL;
    }
    else {
      uint64_t v34 = *v28 + 176 * (v25 % 0x17);
    }
    uint64_t v35 = *(void *)v33;
    sub_1005A4528(a1, v28, v34, v16, v17, v22, v24, (void *)(a1 + 248), (uint64_t)&v43);
    if ((v45 - 1) < 2)
    {
      unint64_t v37 = a2[5] + a2[4] - 1LL;
      unint64_t v38 = *(void *)(a2[1] + 8 * (v37 / 0x17)) + 176 * (v37 % 0x17);
      else {
        int v36 = 3;
      }
    }

    else if (v45 == 3)
    {
      int v36 = 2;
    }

    else if (v45 == 4)
    {
      int v36 = 512;
    }

    else
    {
      int v36 = 0;
    }

    double v39 = sub_100940428(v44, 0.001);
    if (v39 < 0.0 || v39 > 0.25)
    {
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      uint64_t v40 = (os_log_s *)qword_101934748;
      if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 134217984;
        double v51 = v39;
        _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_INFO,  "[FormModels] #warning: VerticalOscillation value out of range (%.2f)",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934740 != -1) {
          dispatch_once(&qword_101934740, &stru_101841208);
        }
        int v48 = 134217984;
        double v49 = v39;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  1LL,  "[FormModels] #warning: VerticalOscillation value out of range (%.2f)",  COERCE_DOUBLE(&v48));
        uint64_t v42 = (uint8_t *)v41;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "VerticalOscillationHKResult CLRunning::FormModels::aggregatedVerticalOscillationInWindow(const StepQueue &, CF AbsoluteTime) const",  "%s\n",  v41);
        if (v42 != buf) {
          free(v42);
        }
      }

      v36 |= 8u;
    }

    *(_DWORD *)a3 = v36;
    *(double *)(a3 + _Block_object_dispose(va, 8) = v39;
    *(_OWORD *)(a3 + 16) = v43;
    *(void *)(a3 + 32) = v35;
  }

  else
  {
    *(_DWORD *)a3 = 32;
    *(_OWORD *)(a3 + _Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
  }

void sub_1005A4528( uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, unint64_t a5@<X4>, uint64_t *a6@<X5>, unint64_t a7@<X6>, void *a8@<X7>, uint64_t a9@<X8>)
{
  unint64_t v11 = a5;
  double v12 = a4;
  if (a4 < a6 || a4 == a6 && a5 < a7)
  {
    if (a8[5])
    {
      *(void *)a9 = 0LL;
      *(void *)(a9 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a9 + 16) = 0LL;
      *(_DWORD *)(a9 + 24) = 2;
      unint64_t v16 = a8[4];
      uint64_t v17 = a8[1];
      unint64_t v18 = (void *)(v17 + 8 * (v16 >> 8));
      if (a8[2] == v17) {
        uint64_t v19 = 0LL;
      }
      else {
        uint64_t v19 = *v18 + 16LL * v16;
      }
      if (a5 == a7)
      {
        uint64_t v48 = a9;
        *(void *)a9 = 0LL;
        *(void *)(a9 + _Block_object_dispose(va, 8) = 0LL;
LABEL_53:
        int v49 = 3;
LABEL_54:
        *(_DWORD *)(v48 + 24) = v49;
        return;
      }

      int v22 = 0;
      int v23 = 0;
      unint64_t v24 = *a4;
      char v55 = 1;
      BOOL v56 = 0;
      double v25 = 0.0;
      double v26 = 0.0;
      double v27 = 0.0;
      do
      {
        if (v11 != a3)
        {
          uint64_t v28 = v11 - v24;
          uint64_t v29 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(v11 - v24) >> 4);
          if (v28 < -175)
          {
            unint64_t v33 = 21 - v29;
            uint64_t v31 = &v12[-(v33 / 0x17)];
            uint64_t v32 = *v31 + 176 * (23 * (v33 / 0x17) - v33) + 3872;
          }

          else
          {
            unint64_t v30 = v29 + 1;
            uint64_t v31 = &v12[v30 / 0x17];
            uint64_t v32 = *v31 + 176 * (v30 % 0x17);
          }

          double v26 = sub_1005A5454(a2, a3, v31, v32);
          double v34 = *(double *)(v11 + 72);
          double v27 = v27 + v34;
          ++v23;
          BOOL v56 = (*(_BYTE *)(v11 + 152) & 0xFD) == 1;
          int v35 = sub_100A177A8(v26, v34, *(float *)(a1 + 2536));
          unint64_t v24 = *v12;
          if (v35)
          {
            uint64_t v36 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(v11 - v24) >> 4);
            else {
              unint64_t v37 = v12[(v36 - 1) / 0x17uLL] + 176 * ((v36 - 1) % 0x17uLL);
            }
            double v38 = *(double *)(v37 + 8);
            uint64_t v39 = a8[1];
            uint64_t v40 = (double *)v19;
            uint64_t v41 = v18;
LABEL_31:
            uint64_t v42 = v40;
            while (1)
            {
              uint64_t v43 = a8[2] == v39
                  ? 0LL
                  : *(void *)(v39 + 8LL * ((a8[5] + a8[4]) >> 8))
                  + 16LL * (*((_BYTE *)a8 + 40) + *((_BYTE *)a8 + 32));
              double v44 = *v42 + *(double *)(a1 + 448);
              if (v44 >= v38 && v44 < *(double *)(v11 + 8))
              {
                double v25 = v25 + v42[1];
                ++v22;
                unint64_t v18 = v41;
                uint64_t v19 = (uint64_t)v40;
              }

              v42 += 2;
              v40 += 2;
              if ((double *)(*v41 + 4096LL) == v40)
              {
                double v46 = (double *)v41[1];
                ++v41;
                uint64_t v40 = v46;
                goto LABEL_31;
              }
            }

            char v55 = 0;
          }
        }

        v11 += 176LL;
        if (v11 - v24 == 4048)
        {
          unint64_t v47 = v12[1];
          ++v12;
          unint64_t v24 = v47;
          unint64_t v11 = v47;
        }
      }

      while (v11 != a7);
      uint64_t v48 = a9;
      *(double *)a9 = v26;
      if (v23 <= 0) {
        *(void *)(a9 + _Block_object_dispose(va, 8) = 0LL;
      }
      else {
        *(double *)(a9 + _Block_object_dispose(va, 8) = v27 / (double)v23;
      }
      if ((v55 & 1) != 0) {
        goto LABEL_53;
      }
      if (v22 <= 0)
      {
        int v49 = 2;
        goto LABEL_54;
      }

      if (v56)
      {
        int v49 = 4;
        goto LABEL_54;
      }

      *(double *)(a9 + 16) = v25 / (double)v22;
      *(_DWORD *)(a9 + 24) = 0;
    }

    else
    {
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      unint64_t v20 = (os_log_s *)qword_101934748;
      if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "[FormModels] computeMeanBetween - Not enough metrics in window",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934740 != -1) {
          dispatch_once(&qword_101934740, &stru_101841208);
        }
        v58[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  1LL,  "[FormModels] computeMeanBetween - Not enough metrics in window",  v58,  2);
        double v51 = (uint8_t *)v50;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "FormModels::StepRangeAggregationResult CLRunning::FormModels::stepRangeMean(StepQueue::const_iterator, StepQue ue::const_iterator, StepQueue::const_iterator, const deque<Timeseries> &) const",  "%s\n",  v50);
        if (v51 != buf) {
          free(v51);
        }
      }

      *(void *)a9 = 0LL;
      *(void *)(a9 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a9 + 16) = 0LL;
      *(_DWORD *)(a9 + 24) = 2;
    }
  }

  else
  {
    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    uint64_t v21 = (os_log_s *)qword_101934748;
    if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "[FormModels] computeMeanBetween - Invalid pedometer range",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      v58[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  1LL,  "[FormModels] computeMeanBetween - Invalid pedometer range",  v58,  2);
      uint64_t v53 = (uint8_t *)v52;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "FormModels::StepRangeAggregationResult CLRunning::FormModels::stepRangeMean(StepQueue::const_iterator, StepQueue ::const_iterator, StepQueue::const_iterator, const deque<Timeseries> &) const",  "%s\n",  v52);
      if (v53 != buf) {
        free(v53);
      }
    }

    *(void *)a9 = 0LL;
    *(void *)(a9 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a9 + 16) = 0LL;
    *(_DWORD *)(a9 + 24) = 1;
  }

void sub_1005A4B98(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  uint64_t v4 = a2[5];
  if (!v4)
  {
    *(_DWORD *)a3 = 32;
    *(void *)(a3 + 4_Block_object_dispose(va, 8) = 0LL;
    *(_OWORD *)(a3 + _Block_object_dispose(va, 8) = 0u;
    *(_OWORD *)(a3 + 24) = 0u;
    *(_BYTE *)(a3 + 40) = 0;
    return;
  }

  double v93 = a4;
  double v92 = a4 + -5.12;
  unint64_t v5 = a2[4];
  uint64_t v6 = a2[1];
  if (a2[2] == v6)
  {
    uint64_t v7 = 0LL;
    uint64_t v11 = 0LL;
    uint64_t v12 = ((v5 + v4) * (unsigned __int128)0x642C8590B21642C9uLL) >> 64;
    uint64_t v10 = (void *)(v6 + 8 * ((v12 + ((v5 + v4 - v12) >> 1)) >> 4));
  }

  else
  {
    uint64_t v7 = *(void *)(v6 + 8 * (v5 / 0x17)) + 176 * (v5 % 0x17);
    uint64_t v8 = ((v5 + v4) * (unsigned __int128)0x642C8590B21642C9uLL) >> 64;
    unint64_t v9 = (v8 + ((v5 + v4 - v8) >> 1)) >> 4;
    uint64_t v10 = (void *)(v6 + 8 * v9);
    uint64_t v11 = *v10 + 176 * (v5 + v4 - 23 * v9);
  }

  LOBYTE(v106[0]) = 0;
  uint64_t v13 = sub_1005AACEC((void *)(v6 + 8 * (v5 / 0x17)), v7, v10, v11, &v92);
  uint64_t v15 = v13;
  uint64_t v16 = v14;
  unint64_t v17 = a2[4] + a2[5];
  uint64_t v18 = a2[1];
  uint64_t v19 = (void *)(v18 + 8 * (v17 / 0x17));
  if (a2[2] == v18) {
    uint64_t v20 = 0LL;
  }
  else {
    uint64_t v20 = *v19 + 176 * (v17 % 0x17);
  }
  LOBYTE(v106[0]) = 0;
  uint64_t v21 = sub_1005AACEC(v13, v14, v19, v20, &v93);
  uint64_t v88 = v22;
  int v23 = a2;
  uint64_t v24 = a2[1];
  if (a2[2] == v24) {
    unint64_t v25 = 0LL;
  }
  else {
    unint64_t v25 = *(void *)(v24 + 8 * (a2[4] / 0x17uLL)) + 176 * (a2[4] % 0x17uLL);
  }
  if (v25 == v22)
  {
    uint64_t v29 = &v93;
    unint64_t v30 = v15;
  }

  else
  {
    uint64_t v26 = v22 - *v21;
    uint64_t v27 = 0x2E8BA2E8BA2E8BA3LL * (v26 >> 4);
    if (v26 < 177) {
      unint64_t v28 = v21[-((23 - v27) / 0x17uLL)] + 176 * (23 * ((23 - v27) / 0x17uLL) - (23 - v27)) + 3872;
    }
    else {
      unint64_t v28 = v21[(v27 - 1) / 0x17uLL] + 176 * ((v27 - 1) % 0x17uLL);
    }
    unint64_t v30 = v15;
    uint64_t v29 = (double *)(v28 + 8);
  }

  uint64_t v31 = *(void *)v29;
  if (v16 != v22)
  {
    uint64_t v85 = *(void *)v29;
    int v32 = 0;
    int v33 = 0;
    int v34 = 0;
    int v35 = 0;
    uint64_t v36 = *v30;
    double v37 = 0.0;
    __asm { FMOV            V0.2D, #-1.0 }

    __int128 v87 = _Q0;
    double v43 = 0.0;
    double v44 = 0.0;
    do
    {
      uint64_t v45 = v16 - v36;
      uint64_t v46 = 0x2E8BA2E8BA2E8BA3LL * ((v16 - v36) >> 4);
      if (v45 < -175)
      {
        uint64_t v50 = ((unint64_t)(21 - v46) * (unsigned __int128)0x642C8590B21642C9uLL) >> 64;
        unint64_t v51 = (v50 + ((unint64_t)(21 - v46 - v50) >> 1)) >> 4;
        uint64_t v49 = v30[-v51] + 176 * (v46 - 21 + 23 * v51) + 3872;
      }

      else
      {
        uint64_t v47 = ((unint64_t)(v46 + 1) * (unsigned __int128)0x642C8590B21642C9uLL) >> 64;
        unint64_t v48 = (v47 + ((unint64_t)(v46 + 1 - v47) >> 1)) >> 4;
        uint64_t v49 = v30[v48] + 176 * (v46 + 1 - 23 * v48);
      }

      unint64_t v52 = v23[4];
      uint64_t v53 = v23[1];
      if (v23[2] == v53)
      {
        if (!v49) {
          break;
        }
        uint64_t v55 = 0LL;
        uint64_t v54 = (void *)(v53 + 8 * (v52 / 0x17));
      }

      else
      {
        if (v49 == *(void *)(v53 + 8 * ((v23[5] + v52) / 0x17)) + 176 * ((v23[5] + v52) % 0x17)) {
          break;
        }
        uint64_t v54 = (void *)(v53 + 8 * (v52 / 0x17));
        uint64_t v55 = *v54 + 176 * (v52 % 0x17);
      }

      double v90 = v37;
      if (v45 < -351)
      {
        unint64_t v60 = 20 - v46;
        double v57 = v30;
        float v58 = &v30[-(v60 / 0x17)];
        uint64_t v59 = *v58 + 176 * (23 * (v60 / 0x17) - v60) + 3872;
      }

      else
      {
        unint64_t v56 = v46 + 2;
        double v57 = v30;
        float v58 = &v30[v56 / 0x17];
        uint64_t v59 = *v58 + 176 * (v56 % 0x17);
      }

      uint64_t v61 = *(void *)(v16 + 8);
      double v62 = *(double *)(v16 + 72);
      double v63 = sub_1005A5454(v54, v55, v58, v59);
      __int128 v107 = 0u;
      __int128 v108 = 0u;
      memset(v106, 0, sizeof(v106));
      DWORD2(v107) = 1000;
      LODWORD(v10_Block_object_dispose(va, 8) = -1082130432;
      uint64_t v64 = *(void *)(a1 + 2600);
      double v65 = 0.0;
      double v66 = 0.0;
      if (*(_BYTE *)(v64 + 80))
      {
        int v67 = sub_1005A579C((uint64_t)v106, (void *)v64, *(double *)(v16 + 8));
        int v68 = v62 > 0.0 ? v67 : 0;
        if (v68 == 1) {
          double v66 = sub_100A178C4(1.0 / v62 * 2.23693991, *(double *)&v107 * 2.23693991);
        }
      }

      if (*(_DWORD *)(v16 + 168) == 3 && v62 > 0.0)
      {
        double v69 = 0.0;
        if (v63 > 0.0)
        {
          double v65 = 1.0 / v62;
          double v69 = 1.0 / v62 / v63 + 1.0 / v62 / v63;
        }
      }

      else
      {
        double v69 = 0.0;
      }

      uint64_t v70 = sub_100A17754(v63, 1.0 / v65, *(float *)(a1 + 2536));
      int v71 = v70;
      int v72 = 0;
      BOOL v73 = v63 <= 0.0;
      if (v65 <= 0.0) {
        BOOL v73 = 1;
      }
      if (!v73 && v69 > 0.0)
      {
        if (v69 < 6.0) {
          int v72 = v70;
        }
        else {
          int v72 = 0;
        }
      }

      *(_OWORD *)__int128 buf = v87;
      __int128 v95 = v87;
      __int128 v102 = 0u;
      uint64_t v97 = 0LL;
      __int128 v99 = 0u;
      double v100 = v69;
      double v101 = v65;
      uint64_t v103 = v61;
      *(double *)&__int128 v102 = v63;
      double v96 = v66;
      double v98 = v69;
      char v105 = v72;
      int v104 = 1;
      sub_1005A5A08(v70, (uint64_t *)buf);
      if ((*(_BYTE *)(v16 + 152) & 0xFD) == 1) {
        ++v35;
      }
      double v74 = -0.0;
      if (v72) {
        double v74 = v69;
      }
      v16 += 176LL;
      unint64_t v30 = v57;
      uint64_t v36 = *v57;
      if (v16 - *v57 == 4048)
      {
        unint64_t v30 = v57 + 1;
        uint64_t v36 = v57[1];
        uint64_t v16 = v36;
      }

      int v23 = a2;
      v32 += v71 ^ 1;
      double v43 = v43 + v63;
      double v44 = v44 + v65;
      v34 += v72;
      double v37 = v90 + v74;
      ++v33;
    }

    while (v16 != v88);
    if (v34) {
      double v75 = v37 / (double)v34;
    }
    else {
      double v75 = 0.0;
    }
    uint64_t v31 = v85;
    if (v33)
    {
      double v76 = v44 / (double)v33;
      if (v76 <= 0.0) {
        double v77 = 0.0;
      }
      else {
        double v77 = 1.0 / v76;
      }
      if (v34)
      {
        double v78 = v43 / (double)v33;
        goto LABEL_66;
      }
    }

    else
    {
      double v77 = 0.0;
      double v78 = 0.0;
      if (v34)
      {
LABEL_66:
        double v79 = 0.0;
        if (v32)
        {
          int v80 = 10;
        }

        else if (v35)
        {
          int v80 = 520;
        }

        else
        {
          int v80 = 8;
          if (v75 > 0.0 && v75 <= 6.0)
          {
            int v80 = 0;
            double v79 = v75;
            uint64_t v81 = a3;
LABEL_81:
            *(_DWORD *)uint64_t v81 = v80;
            *(void *)(v81 + _Block_object_dispose(va, 8) = 0LL;
            *(double *)(v81 + 16) = v79;
            *(double *)(v81 + 24) = v78;
            *(double *)(v81 + 32) = v77;
            goto LABEL_82;
          }

          double v79 = v75;
        }

        if (qword_101934740 != -1) {
          dispatch_once(&qword_101934740, &stru_101841208);
        }
        double v82 = (os_log_s *)qword_101934748;
        if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 134217984;
          *(double *)&uint8_t buf[4] = v79;
          _os_log_impl( (void *)&_mh_execute_header,  v82,  OS_LOG_TYPE_INFO,  "[FormModels] #warning: StrideLength value out of range (%.2f)",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934740 != -1) {
            dispatch_once(&qword_101934740, &stru_101841208);
          }
          LODWORD(v106[0]) = 134217984;
          *(double *)((char *)v106 + 4) = v79;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  1LL,  "[FormModels] #warning: StrideLength value out of range (%.2f)",  COERCE_DOUBLE(v106));
          double v84 = (uint8_t *)v83;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "StrideLengthHKResult CLRunning::FormModels::aggregatedStrideLengthInWindow(const StepQueue &, CFAbsoluteTime) const",  "%s\n",  v83);
          if (v84 != buf) {
            free(v84);
          }
        }

        uint64_t v81 = a3;
        uint64_t v31 = v85;
        goto LABEL_81;
      }
    }
  }

  uint64_t v81 = a3;
  *(_DWORD *)a3 = 1;
  *(_OWORD *)(a3 + _Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a3 + 24) = 0u;
LABEL_82:
  *(_BYTE *)(v81 + 40) = 0;
  *(void *)(v81 + 4_Block_object_dispose(va, 8) = v31;
}

double sub_1005A5454(void *a1, uint64_t a2, void *a3, uint64_t a4)
{
  double v4 = 0.0;
  if (a4 == a2) {
    return v4;
  }
  uint64_t v8 = a4 - *a3;
  uint64_t v9 = 0x2E8BA2E8BA2E8BA3LL * (v8 >> 4);
  if (v9 + 23 * (a3 - a1) - 0x2E8BA2E8BA2E8BA3LL * ((a2 - *a1) >> 4) < 4) {
    return v4;
  }
  unint64_t v10 = v9 - 1;
  if (v8 <= 176)
  {
    uint64_t v14 = ((unint64_t)(23 - v9) * (unsigned __int128)0x642C8590B21642C9uLL) >> 64;
    unint64_t v15 = (v14 + ((unint64_t)(23 - v9 - v14) >> 1)) >> 4;
    double v11 = *(double *)(a3[-v15] + 176 * (v9 - 23 + 23 * v15) + 3872);
    unint64_t v12 = v9 - 3;
    goto LABEL_7;
  }

  double v11 = *(double *)(a3[v10 / 0x17] + 176 * (v10 % 0x17));
  unint64_t v12 = v9 - 3;
  if ((unint64_t)v8 < 0x211)
  {
LABEL_7:
    uint64_t v13 = (double *)(a3[-((22 - v12) / 0x17)] + 176 * (23 * ((22 - v12) / 0x17) - (22 - v12)) + 3872);
    goto LABEL_8;
  }

  uint64_t v13 = (double *)(a3[v12 / 0x17] + 176 * (v12 % 0x17));
LABEL_8:
  if (v11 - *v13 <= 10.24)
  {
    double v16 = sub_1005A5F74(a1, a2, a3, a4);
    if (v8 < 177)
    {
      uint64_t v19 = ((unint64_t)(23 - v9) * (unsigned __int128)0x642C8590B21642C9uLL) >> 64;
      unint64_t v20 = (v19 + ((unint64_t)(23 - v9 - v19) >> 1)) >> 4;
      unint64_t v17 = &a3[-v20];
      uint64_t v18 = *v17 + 176 * (v9 - 23 + 23 * v20) + 3872;
    }

    else
    {
      unint64_t v17 = &a3[v10 / 0x17];
      uint64_t v18 = *v17 + 176 * (v10 % 0x17);
    }

    double v21 = sub_1005A5F74(a1, a2, v17, v18);
    if (v8 < 353)
    {
      uint64_t v26 = ((unint64_t)(24 - v9) * (unsigned __int128)0x642C8590B21642C9uLL) >> 64;
      unint64_t v27 = (v26 + ((unint64_t)(24 - v9 - v26) >> 1)) >> 4;
      uint64_t v24 = &a3[-v27];
      uint64_t v25 = *v24 + 176 * (v9 - 24 + 23 * v27) + 3872;
    }

    else
    {
      uint64_t v22 = ((unint64_t)(v9 - 2) * (unsigned __int128)0x642C8590B21642C9uLL) >> 64;
      unint64_t v23 = (v22 + ((unint64_t)(v9 - 2 - v22) >> 1)) >> 4;
      uint64_t v24 = &a3[v23];
      uint64_t v25 = *v24 + 176 * (v9 - 2 - 23 * v23);
    }

    double v28 = sub_1005A5F74(a1, a2, v24, v25);
    if (v16 > 0.0 && v21 > 0.0 && v28 > 0.0)
    {
      if (v16 >= v21) {
        double v29 = v21;
      }
      else {
        double v29 = v16;
      }
      if (v16 <= v21) {
        double v30 = v21;
      }
      else {
        double v30 = v16;
      }
      if (v30 < v28) {
        double v28 = v30;
      }
      if (v29 <= v28) {
        return v28;
      }
      else {
        return v29;
      }
    }
  }

  return v4;
}

uint64_t sub_1005A579C(uint64_t a1, void *a2, double a3)
{
  uint64_t v5 = (*(uint64_t (**)(void *, uint64_t))(*a2 + 24LL))(a2, a1);
  if ((v5 & 1) == 0)
  {
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    DWORD2(vsub_100210A00(v2 + 13) = 1000;
    LODWORD(v14) = -1082130432;
    int v6 = sub_1005A6134(a2, &v11);
    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    uint64_t v7 = (os_log_s *)qword_101934748;
    if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134350080;
      double v26 = a3;
      __int16 v27 = 1026;
      int v28 = v6;
      __int16 v29 = 2050;
      uint64_t v30 = *((void *)&v11 + 1);
      __int16 v31 = 1026;
      int v32 = DWORD2(v12);
      __int16 v33 = 1026;
      int v34 = DWORD2(v13);
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[FormController] #warning: Elevation lookup failed at t=%{public}.2f. lastEntry={exists,%{public}d,startTime,%{p ublic}.2f,gradeType,%{public}d,source,%{public}d}",  buf,  0x28u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      int v15 = 134350080;
      double v16 = a3;
      __int16 v17 = 1026;
      int v18 = v6;
      __int16 v19 = 2050;
      uint64_t v20 = *((void *)&v11 + 1);
      __int16 v21 = 1026;
      int v22 = DWORD2(v12);
      __int16 v23 = 1026;
      int v24 = DWORD2(v13);
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  0LL,  "[FormController] #warning: Elevation lookup failed at t=%{public}.2f. lastEntry={exists,%{public}d,startTime,%{p ublic}.2f,gradeType,%{public}d,source,%{public}d}",  &v15,  40);
      unint64_t v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLRunning::FormModels::elevationLookup(CFAbsoluteTime, CLElevationChangeEntry &, const CLNatalieInpu t<CLElevationChangeEntry> &)",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }
  }

  return v5;
}

void sub_1005A5A08(uint64_t a1, uint64_t *a2)
{
  if (qword_101934740 != -1) {
    dispatch_once(&qword_101934740, &stru_101841208);
  }
  double v3 = (os_log_s *)qword_101934748;
  if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v5 = a2[12];
    uint64_t v4 = a2[13];
    uint64_t v6 = *a2;
    uint64_t v7 = a2[1];
    uint64_t v8 = a2[2];
    uint64_t v9 = a2[3];
    uint64_t v10 = a2[7];
    uint64_t v11 = a2[8];
    uint64_t v12 = a2[4];
    uint64_t v14 = a2[10];
    uint64_t v13 = a2[11];
    uint64_t v15 = a2[9];
    *(_DWORD *)__int128 buf = 134351872;
    uint64_t v55 = v5;
    __int16 v56 = 2050;
    uint64_t v57 = v4;
    __int16 v58 = 2048;
    uint64_t v59 = v10;
    __int16 v60 = 2048;
    uint64_t v61 = v6;
    __int16 v62 = 2048;
    uint64_t v63 = v7;
    __int16 v64 = 2048;
    uint64_t v65 = v8;
    __int16 v66 = 2048;
    uint64_t v67 = v9;
    __int16 v68 = 2048;
    uint64_t v69 = v15;
    __int16 v70 = 2048;
    uint64_t v71 = v11;
    __int16 v72 = 2048;
    uint64_t v73 = v12;
    __int16 v74 = 2048;
    uint64_t v75 = v13;
    __int16 v76 = 2048;
    uint64_t v77 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "[FormModels] StrideLengthEvent,startTime,%{public}.2f,endTime,%{public}.2f,strideLengthFormBasedUncal,%.3f,heightC M,%.2f,horizontalAccelMagnitudeMeanSqrt,%.2f,rotationRateMagnitudeMin,%.2f,rotationRateGravityProjectionMax,%.2f,s trideLengthSpeedBased,%.3f,strideLengthFormBasedCalibrated,%.3f,grade,%.2f,cadence,%.2f,speed,%.2f",  buf,  0x7Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    uint64_t v17 = a2[12];
    uint64_t v16 = a2[13];
    uint64_t v18 = *a2;
    uint64_t v19 = a2[1];
    uint64_t v20 = a2[2];
    uint64_t v21 = a2[3];
    uint64_t v22 = a2[7];
    uint64_t v23 = a2[8];
    uint64_t v24 = a2[4];
    uint64_t v25 = a2[10];
    uint64_t v26 = a2[11];
    uint64_t v27 = a2[9];
    int v30 = 134351872;
    uint64_t v31 = v17;
    __int16 v32 = 2050;
    uint64_t v33 = v16;
    __int16 v34 = 2048;
    uint64_t v35 = v22;
    __int16 v36 = 2048;
    uint64_t v37 = v18;
    __int16 v38 = 2048;
    uint64_t v39 = v19;
    __int16 v40 = 2048;
    uint64_t v41 = v20;
    __int16 v42 = 2048;
    uint64_t v43 = v21;
    __int16 v44 = 2048;
    uint64_t v45 = v27;
    __int16 v46 = 2048;
    uint64_t v47 = v23;
    __int16 v48 = 2048;
    uint64_t v49 = v24;
    __int16 v50 = 2048;
    uint64_t v51 = v26;
    __int16 v52 = 2048;
    uint64_t v53 = v25;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  2LL,  "[FormModels] StrideLengthEvent,startTime,%{public}.2f,endTime,%{public}.2f,strideLengthFormBasedUncal,%.3f,heightC M,%.2f,horizontalAccelMagnitudeMeanSqrt,%.2f,rotationRateMagnitudeMin,%.2f,rotationRateGravityProjectionMax,%.2f,s trideLengthSpeedBased,%.3f,strideLengthFormBasedCalibrated,%.3f,grade,%.2f,cadence,%.2f,speed,%.2f",  &v30,  122);
    __int16 v29 = (uint8_t *)v28;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLRunning::FormModels::logStrideLengthResult(const StrideLengthResult &) const",  "%s\n",  v28);
    if (v29 != buf) {
      free(v29);
    }
  }

float sub_1005A5CAC(uint64_t *a1, float32x2_t *a2, uint64_t a3)
{
  int v17 = 0;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  uint64_t v4 = *a1;
  if (a1[1] != *a1)
  {
    unint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = (float32x2_t *)(v4 + 12 * v7);
      float v9 = v8[1].f32[0] - a2[1].f32[0];
      uint64_t v18 = (_DWORD *)vsub_f32(*v8, *a2);
      *(float *)&uint64_t v19 = v9;
      sub_1005AAE28((uint64_t)&v18, (uint64_t)v20);
      for (unint64_t i = 0LL; i != 9; ++i)
        *((float *)&v15 + i) = sub_1005AAEAC((uint64_t)v20, i) + *((float *)&v15 + i);
      ++v7;
      uint64_t v4 = *a1;
    }

    while (v7 < 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 2));
  }

  v20[0] = v15;
  v20[1] = v16;
  int v21 = v17;
  sub_1005AB084((uint64_t)v20, a3);
  v22[0] = v11;
  v22[1] = v12;
  v22[2] = v13;
  uint64_t v18 = v22;
  uint64_t v19 = a3;
  sub_1005AB644((uint64_t *)&v18, 0LL, 1uLL);
  sub_1005AB644((uint64_t *)&v18, 0LL, 2uLL);
  sub_1005AB644((uint64_t *)&v18, 1uLL, 2uLL);
  return *(float *)v22;
}

void sub_1005A5DF4(void *a1@<X8>, double a2@<D1>)
{
  double v3 = a2 * 0.02;
  bzero(v17, 0x808uLL);
  bzero(v16, 0x808uLL);
  uint64_t v4 = 0LL;
  double v5 = 0.0;
  double v6 = 0.0;
  do
  {
    double v7 = (float)((float)(cosf((float)(int)v4 * 0.024544) * -0.46) + 0.54);
    double v8 = (double)((int)v4 - 128);
    sub_100DEAB30(v15 * v8);
    double v10 = v9 * v7;
    v17[v4] = v10;
    double v5 = v5 + v10;
    sub_100DEAB30(v3 * v8);
    double v12 = v11 * v7;
    v16[v4] = v12;
    double v6 = v6 + v12;
    ++v4;
  }

  while (v4 != 257);
  bzero(a1, 0x404uLL);
  for (uint64_t i = 0LL; i != 257; ++i)
  {
    float v14 = v16[i] / v6 - v17[i] / v5;
    *((float *)a1 + i) = v14;
  }

double sub_1005A5F74(void *a1, uint64_t a2, void *a3, uint64_t a4)
{
  double result = 0.0;
  if (a4 != a2)
  {
    uint64_t v5 = a4 - *a3;
    uint64_t v6 = 0x2E8BA2E8BA2E8BA3LL * (v5 >> 4);
    if (v6 + 23 * (a3 - a1) - 0x2E8BA2E8BA2E8BA3LL * ((a2 - *a1) >> 4) >= 2)
    {
      if (v5 < 177)
      {
        unint64_t v11 = 23 - v6;
        double v8 = &a3[-(v11 / 0x17)];
        uint64_t v9 = *v8;
        unint64_t v10 = *v8 + 176 * (23 * (v11 / 0x17) - v11) + 3872;
      }

      else
      {
        unint64_t v7 = v6 - 1;
        double v8 = &a3[v7 / 0x17];
        uint64_t v9 = *v8;
        unint64_t v10 = *v8 + 176 * (v7 % 0x17);
      }

      uint64_t v12 = v10 - v9;
      uint64_t v13 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(v10 - v9) >> 4);
      if (v12 < 177) {
        unint64_t v14 = v8[-((23 - v13) / 0x17uLL)] + 176 * (23 * ((23 - v13) / 0x17uLL) - (23 - v13)) + 3872;
      }
      else {
        unint64_t v14 = v8[(v13 - 1) / 0x17uLL] + 176 * ((v13 - 1) % 0x17uLL);
      }
      double v15 = *(double *)(v10 + 88) - *(double *)(v14 + 88);
      if (v15 > 0.0) {
        return (double)(*(_DWORD *)(v10 + 24) - *(_DWORD *)(v14 + 24)) / v15;
      }
    }
  }

  return result;
}

uint64_t sub_1005A6134(void *a1, _OWORD *a2)
{
  uint64_t v2 = a1[4];
  if (a1[5] == v2) {
    return 0LL;
  }
  unint64_t v3 = a1[7] + a1[8];
  uint64_t v4 = (void *)(v2 + 8 * (v3 >> 6));
  uint64_t v5 = v3 & 0x3F;
  uint64_t v6 = *v4 + (v5 << 6);
  if (v6 == *(void *)(v2 + ((a1[7] >> 3) & 0x1FFFFFFFFFFFFFF8LL)) + ((a1[7] & 0x3FLL) << 6)) {
    return 0LL;
  }
  if (!v5) {
    uint64_t v6 = *(v4 - 1) + 4096LL;
  }
  __int128 v7 = *(_OWORD *)(v6 - 64);
  __int128 v8 = *(_OWORD *)(v6 - 48);
  __int128 v9 = *(_OWORD *)(v6 - 16);
  a2[2] = *(_OWORD *)(v6 - 32);
  a2[3] = v9;
  *a2 = v7;
  a2[1] = v8;
  return 1LL;
}

uint64_t sub_1005A61A4(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 2613))
  {
    uint64_t v2 = sub_1006E27E8();
    sub_100413284(v2, &v7);
    sub_1002A6F64(v7, "MotionLoggerLogGaitEvents", (BOOL *)(a1 + 2614));
    unint64_t v3 = v8;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        unint64_t v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }

    *(_BYTE *)(a1 + 26sub_100210A00(v2 + 13) = 1;
  }

  return *(unsigned __int8 *)(a1 + 2614);
}

void sub_1005A6238( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1005A624C(uint64_t result, uint64_t a2, _DWORD *a3, void *a4)
{
  int v5 = *(_DWORD *)(a2 + 24);
  if ((v5 - 1) < 2)
  {
    *a3 |= 1u;
    unint64_t v7 = a4[5] + a4[4] - 1LL;
    unint64_t v8 = *(void *)(a4[1] + 8 * (v7 / 0x17)) + 176 * (v7 % 0x17);
    double result = sub_100A177A8(*(double *)(v8 + 80), *(double *)(v8 + 72), *(float *)(result + 2536));
    if ((result & 1) != 0) {
      return result;
    }
  }

  else if (v5 != 3)
  {
    if (v5 != 4) {
      return result;
    }
    int v6 = 512;
    goto LABEL_7;
  }

  int v6 = 2;
LABEL_7:
  *a3 |= v6;
  return result;
}

uint64_t sub_1005A6304@<X0>(uint64_t result@<X0>, void *a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
  uint64_t v5 = a2[5];
  if (v5)
  {
    unint64_t v7 = (void *)result;
    double v91 = a4;
    double v90 = a4 + -5.12;
    unint64_t v8 = a2[4];
    uint64_t v9 = a2[1];
    if (a2[2] == v9)
    {
      uint64_t v10 = 0LL;
      uint64_t v13 = 0LL;
      uint64_t v12 = (void *)(v9 + 8 * ((v8 + v5) / 0x17));
    }

    else
    {
      uint64_t v10 = *(void *)(v9 + 8 * (v8 / 0x17)) + 176 * (v8 % 0x17);
      unint64_t v11 = v8 + v5;
      uint64_t v12 = (void *)(v9 + 8 * (v11 / 0x17));
      uint64_t v13 = *v12 + 176 * (v11 % 0x17);
    }

    LOBYTE(v86) = 0;
    unint64_t v14 = sub_1005AACEC((void *)(v9 + 8 * (v8 / 0x17)), v10, v12, v13, &v90);
    __int128 v16 = v14;
    unint64_t v17 = v15;
    unint64_t v18 = a2[4] + a2[5];
    uint64_t v19 = a2[1];
    uint64_t v20 = (void *)(v19 + 8 * (v18 / 0x17));
    if (a2[2] == v19) {
      uint64_t v21 = 0LL;
    }
    else {
      uint64_t v21 = *v20 + 176 * (v18 % 0x17);
    }
    LOBYTE(v86) = 0;
    uint64_t v22 = sub_1005AACEC(v14, v15, v20, v21, &v91);
    uint64_t v24 = v23 - *v22;
    uint64_t v25 = 0x2E8BA2E8BA2E8BA3LL * (v24 >> 4);
    if (v24 < -175)
    {
      unint64_t v29 = 21 - v25;
      uint64_t v27 = &v22[-(v29 / 0x17)];
      unint64_t v28 = *v27 + 176 * (23 * (v29 / 0x17) - v29) + 3872;
    }

    else
    {
      unint64_t v26 = v25 + 1;
      uint64_t v27 = &v22[v26 / 0x17];
      unint64_t v28 = *v27 + 176 * (v26 % 0x17);
    }

    __int128 v87 = 0u;
    memset(v88, 0, 28);
    __int128 v85 = 0u;
    __int128 v86 = 0u;
    __int128 v89 = 0uLL;
    memset(v84, 0, sizeof(v84));
    __int128 v83 = 0u;
    memset(v82, 0, sizeof(v82));
    uint64_t v30 = v7[328];
    unint64_t v31 = v7[331];
    __int16 v32 = (void *)(v30 + 8 * (v31 / 0x33));
    if (v7[329] == v30)
    {
      uint64_t v33 = 0LL;
      uint64_t v36 = 0LL;
      uint64_t v35 = (void *)(v30 + 8 * ((v7[332] + v31) / 0x33));
    }

    else
    {
      uint64_t v33 = *(void *)(v30 + 8 * (v31 / 0x33)) + 80 * (v31 % 0x33);
      unint64_t v34 = v7[332] + v31;
      uint64_t v35 = (void *)(v30 + 8 * (v34 / 0x33));
      uint64_t v36 = *v35 + 80 * (v34 % 0x33);
    }

    LOBYTE(v92) = 0;
    uint64_t v37 = sub_1005AB764(v32, v33, v35, v36, &v90);
    uint64_t v39 = v37;
    unint64_t v40 = v38;
    unint64_t v41 = v7[331] + v7[332];
    uint64_t v42 = v7[328];
    uint64_t v43 = (void *)(v42 + 8 * (v41 / 0x33));
    if (v7[329] == v42) {
      uint64_t v44 = 0LL;
    }
    else {
      uint64_t v44 = *v43 + 80 * (v41 % 0x33);
    }
    LOBYTE(v92) = 0;
    uint64_t v45 = sub_1005AB764(v37, v38, v43, v44, &v91);
    if ((sub_1005A6CFC((uint64_t)v7, v84, v82, v39, v40, v45, v46) & 1) != 0)
    {
      unint64_t v47 = a2[4];
      uint64_t v48 = a2[1];
      uint64_t v49 = (void *)(v48 + 8 * (v47 / 0x17));
      if (a2[2] == v48) {
        uint64_t v50 = 0LL;
      }
      else {
        uint64_t v50 = *v49 + 176 * (v47 % 0x17);
      }
      sub_1005A4528((uint64_t)v7, v49, v50, v16, v17, v27, v28, v84, (uint64_t)v80);
      unint64_t v52 = a2[4];
      uint64_t v53 = a2[1];
      uint64_t v54 = (void *)(v53 + 8 * (v52 / 0x17));
      if (a2[2] == v53) {
        uint64_t v55 = 0LL;
      }
      else {
        uint64_t v55 = *v54 + 176 * (v52 % 0x17);
      }
      sub_1005A4528((uint64_t)v7, v54, v55, v16, v17, v27, v28, v82, (uint64_t)v77);
      sub_1005A624C((uint64_t)v7, (uint64_t)v80, &v88[24], a2);
      sub_1005A624C((uint64_t)v7, (uint64_t)v77, &v88[24], a2);
      if ((v88[24] & 1) == 0)
      {
        double v56 = v81;
        double v57 = v79;
        double v58 = (v81 + v79) * 0.5;
        double v59 = v81 / (v81 + v79);
        *(void *)&__int128 v89 = v80[0];
        *((double *)&v89 + 1) = v78;
        double v60 = v79 / (v81 + v79);
        if (*((void *)&v85 + 1) | *((void *)&v83 + 1))
        {
          double v62 = 0.0;
          if (v78 > 0.0) {
            double v62 = 1.0 / v78;
          }
          if (v62 >= 4.0 || v58 >= 0.15 || v58 <= 0.05 || v62 <= 0.0)
          {
            if (v58 <= 0.4 && v58 > 0.05) {
              int v61 = 0;
            }
            else {
              int v61 = 8;
            }
          }

          else
          {
            int v61 = 256;
          }
        }

        else
        {
          int v61 = 1;
        }

        *((double *)&v86 + 1) = v81;
        *(double *)&__int128 v87 = v79;
        *((double *)&v87 + 1) = v81 / (v81 + v79);
        *(double *)uint64_t v88 = v79 / (v81 + v79);
        *(double *)&v88[8] = v90;
        *(double *)&v88[16] = v91;
        *(_DWORD *)&v88[24] = v61;
        double v64 = sub_100940428(v58, 0.001);
        *(double *)&__int128 v86 = v64;
        if (qword_101934740 != -1) {
          dispatch_once(&qword_101934740, &stru_101841208);
        }
        uint64_t v65 = (os_log_s *)qword_101934748;
        if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 67241472;
          int v104 = v61;
          __int16 v105 = 2048;
          double v106 = v56;
          __int16 v107 = 2048;
          double v108 = v57;
          __int16 v109 = 2048;
          double v110 = v59;
          __int16 v111 = 2048;
          double v112 = v60;
          __int16 v113 = 2048;
          double v114 = v64;
          _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_DEBUG,  "[FormController] CLGaitEvents::HealthKitResult, groundContactTimeRejectionStatus,%{public}d,leftGroundContac tTime,%.2f,rightGroundContactTime,%.2f,leftGroundContactTimePercentage,%.2f,rightGroundContactTimePercentage ,%.2f,groundContactTime,%.2f",  buf,  0x3Au);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934740 != -1) {
            dispatch_once(&qword_101934740, &stru_101841208);
          }
          LODWORD(v92) = 67241472;
          HIDWORD(v92) = v61;
          __int16 v93 = 2048;
          double v94 = v56;
          __int16 v95 = 2048;
          double v96 = v57;
          __int16 v97 = 2048;
          double v98 = v59;
          __int16 v99 = 2048;
          double v100 = v60;
          __int16 v101 = 2048;
          double v102 = v64;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  2LL,  "[FormController] CLGaitEvents::HealthKitResult, groundContactTimeRejectionStatus,%{public}d,leftGroundContac tTime,%.2f,rightGroundContactTime,%.2f,leftGroundContactTimePercentage,%.2f,rightGroundContactTimePercentage ,%.2f,groundContactTime,%.2f",  &v92,  58);
          __int16 v76 = (uint8_t *)v75;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "GroundContactTimeHKResult CLRunning::FormModels::aggregatedGroundContactTimeInWindow(const StepQueue &, CFAbsoluteTime)",  "%s\n",  v75);
          if (v76 != buf) {
            free(v76);
          }
        }

        if (sub_1005A61A4((uint64_t)v7))
        {
          sub_10116FF1C(&v86, (uint64_t)buf);
          if (qword_1019A1D00 != -1) {
            dispatch_once(&qword_1019A1D00, &stru_101841228);
          }
          uint64_t v66 = qword_1019A1D08;
          if (qword_1019A1D08)
          {
            uint64_t v67 = operator new(0x50uLL);
            sub_10108C450((uint64_t)v67, (uint64_t)buf);
            uint64_t v92 = v68;
            double Current = CFAbsoluteTimeGetCurrent();
            sub_100B50798(v66, &v92, Current);
            uint64_t v70 = v92;
            uint64_t v92 = 0LL;
            if (v70) {
              (*(void (**)(uint64_t))(*(void *)v70 + 8LL))(v70);
            }
          }

          PB::Base::~Base((PB::Base *)buf);
        }
      }

      __int128 v71 = *(_OWORD *)&v88[16];
      *(_OWORD *)(a3 + 32) = *(_OWORD *)v88;
      *(_OWORD *)(a3 + 4_Block_object_dispose(va, 8) = v71;
      *(_OWORD *)(a3 + 64) = v89;
      __int128 v72 = v87;
      *(_OWORD *)a3 = v86;
      *(_OWORD *)(a3 + 16) = v72;
    }

    else
    {
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      uint64_t v51 = (os_log_s *)qword_101934748;
      if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_ERROR,  "[FormController] step aggregation failed",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934740 != -1) {
          dispatch_once(&qword_101934740, &stru_101841208);
        }
        LOWORD(v92) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  16LL,  "[FormController] step aggregation failed",  &v92,  2);
        __int16 v74 = (uint8_t *)v73;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "GroundContactTimeHKResult CLRunning::FormModels::aggregatedGroundContactTimeInWindow(const StepQueue &, CFAbsoluteTime)",  "%s\n",  v73);
        if (v74 != buf) {
          free(v74);
        }
      }

      *(void *)(a3 + 4_Block_object_dispose(va, 8) = 0LL;
      *(_OWORD *)(a3 + 16) = 0u;
      *(_OWORD *)(a3 + 32) = 0u;
      *(_OWORD *)a3 = 0u;
      *(_DWORD *)(a3 + 56) = 1;
      *(void *)(a3 + 64) = 0LL;
      *(void *)(a3 + 72) = 0LL;
    }

    sub_100231C10(v82);
    return sub_100231C10(v84);
  }

  else
  {
    *(void *)(a3 + 4_Block_object_dispose(va, 8) = 0LL;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_DWORD *)(a3 + 56) = 32;
    *(void *)(a3 + 64) = 0LL;
    *(void *)(a3 + 72) = 0LL;
  }

  return result;
}

void sub_1005A6C8C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  sub_100231C10((uint64_t *)va);
  sub_100231C10(va1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005A6CFC( uint64_t a1, void *a2, void *a3, void *a4, unint64_t a5, void *a6, uint64_t *a7)
{
  __int128 v72 = a3;
  if (a7 == (uint64_t *)a5
    || 51 * (a6 - a4)
     - 0x3333333333333333LL * (((uint64_t)a7 - *a6) >> 4)
     + 0x3333333333333333LL * ((uint64_t)(a5 - *a4) >> 4) <= 3)
  {
    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    unint64_t v7 = (os_log_s *)qword_101934748;
    if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "[FormController] Insufficient number of samples to aggregate",  buf,  2u);
    }

    uint64_t result = sub_1002921D0(115, 0);
    if ((_DWORD)result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      LOWORD(__p) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  16LL,  "[FormController] Insufficient number of samples to aggregate",  &__p,  2);
      uint64_t v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLRunning::FormModels::aggregateEventsOverStride(std::deque<Timeseries> &, std::deque<Timeseries> &, const std::deque<CLGaitEvents::LoggingModelOutput>::const_iterator, const std::deque<CLGaitEvents::LoggingModelOutput> ::const_iterator)",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
      return 0LL;
    }

    return result;
  }

  __int128 v83 = 0LL;
  double v84 = 0LL;
  uint64_t v85 = 0LL;
  int v80 = 0LL;
  double v81 = 0LL;
  uint64_t v82 = 0LL;
  HIDWORD(v70) = sub_1005A77E0((void *)a1, 0, (char **)&v83, &v80, a4, a5, a6, a7);
  if ((BYTE4(v70) & 1) == 0)
  {
    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    uint64_t v67 = (os_log_s *)qword_101934748;
    if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEBUG,  "[FormController] Cannot process candidates for aggregation",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      LOWORD(__p) = 0;
      LODWORD(v70) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  2LL,  "[FormController] Cannot process candidates for aggregation",  &__p,  *(void *)&v70);
      uint64_t v69 = (uint8_t *)v68;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLRunning::FormModels::aggregateEventsOverStride(std::deque<Timeseries> &, std::deque<Timeseries> &, const std::deque<CLGaitEvents::LoggingModelOutput>::const_iterator, const std::deque<CLGaitEvents::LoggingModelOutput> ::const_iterator)",  "%s\n",  v68);
      if (v69 != buf) {
        free(v69);
      }
    }

void sub_1005A7708( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, void *a30, uint64_t a31, uint64_t a32, void *a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, void *a39, uint64_t a40)
{
  if (__p) {
    operator delete(__p);
  }
  if (a27) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1005A77E0( void *a1, int a2, char **a3, char **a4, void *a5, unint64_t a6, void *a7, uint64_t *a8)
{
  if (a8 == (uint64_t *)a6)
  {
    LODWORD(sub_10004B64C(v11, v10) = 0;
    goto LABEL_80;
  }

  uint64_t v10 = 51 * (a7 - a5)
  if ((v10 - 1) >= 0x440)
  {
LABEL_80:
    if (qword_101934740 != -1) {
      dispatch_once(&qword_101934740, &stru_101841208);
    }
    int v80 = (os_log_s *)qword_101934748;
    if (os_log_type_enabled((os_log_t)qword_101934748, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v140 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_ERROR,  "[FormController] GCT Buffer Overload - numSamples: %d",  buf,  8u);
    }

    BOOL result = sub_1002921D0(115, 0);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934740 != -1) {
        dispatch_once(&qword_101934740, &stru_101841208);
      }
      v138[0] = 67109120;
      v138[1] = v10;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934748,  16LL,  "[FormController] GCT Buffer Overload - numSamples: %d",  v138);
      double v124 = (uint8_t *)v123;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLRunning::FormModels::processCandidates(AggregateType, std::vector<CLGaitEvents::PredictionCandidate> &, s td::vector<CLGaitEvents::AggregationCandidate> &, const std::deque<CLGaitEvents::LoggingModelOutput>::const_iter ator, const std::deque<CLGaitEvents::LoggingModelOutput>::const_iterator)",  "%s\n",  v123);
      if (v124 != buf) {
        free(v124);
      }
      return 0LL;
    }

    return result;
  }

  int v125 = v10 - 1;
  sub_1005A8194( (void **)a3,  51 * (a7 - a5)
  int v15 = a5;
  unint64_t v14 = a6;
  uint64_t v17 = a7;
  uint64_t v16 = a8;
  int v18 = 0;
  int v134 = 0;
  uint64_t v19 = 0LL;
  int v20 = 0;
  uint64_t v127 = (uint64_t)(a4 + 2);
  uint64_t v128 = (uint64_t)(a3 + 2);
  unint64_t v21 = a5;
  unint64_t v22 = a6;
  int v23 = 1;
  __int16 v135 = a4;
LABEL_4:
  uint64_t v129 = 51 * (v21 - v15);
  while (1)
  {
    int v24 = v23;
    uint64_t v25 = (uint64_t)v16 - *v17;
    unint64_t v26 = 0xCCCCCCCCCCCCCCCDLL * (v25 >> 4);
    if (v25 < 81)
    {
      unint64_t v31 = 51 - v26;
      unint64_t v32 = (51 - v26) / 0x33;
      unint64_t v29 = &v17[-v32];
      unint64_t v30 = *v29 + 80 * (51 * v32 - v31) + 4000;
    }

    else
    {
      unint64_t v27 = v26 - 1;
      unint64_t v28 = (v26 - 1) / 0x33;
      unint64_t v29 = &v17[v28];
      unint64_t v30 = *v29 + 80 * (v27 - 51 * v28);
    }

    if (v21 >= v29 && (v21 != v29 || v22 >= v30)) {
      break;
    }
    uint64_t v34 = v22 - *v21;
    unint64_t v35 = 0xCCCCCCCCCCCCCCCDLL * (v34 >> 4);
    if (v34 < -79) {
      unint64_t v36 = (double *)(v21[-((49 - v35) / 0x33)] + 80 * (v35 - 49 + 51 * ((49 - v35) / 0x33)) + 4000);
    }
    else {
      unint64_t v36 = (double *)(v21[(v35 + 1) / 0x33] + 80 * ((v35 + 1) % 0x33));
    }
    if (v22 == v14) {
      LODWORD(vsub_1005A8CF4(v2 + 37) = 0;
    }
    else {
      uint64_t v37 = v35 + v129 + 0x3333333333333333LL * ((uint64_t)(v14 - *v15) >> 4);
    }
    switch(a2)
    {
      case 2:
        unint64_t v38 = (double *)v22;
        goto LABEL_25;
      case 1:
        unint64_t v38 = (double *)(v22 + 16);
        v36 += 2;
        goto LABEL_25;
      case 0:
        unint64_t v38 = (double *)(v22 + 8);
        ++v36;
LABEL_25:
        double v8 = *v38;
        double v9 = *v36;
        break;
    }

    double v39 = vabdd_f64(v9, v8);
    if (v39 > 0.03) {
      ++v23;
    }
    int v40 = *(_DWORD *)(v22 + 64);
    if (v39 <= 0.03)
    {
      ++v18;
      if (v40 == 2)
      {
        uint64_t v19 = (v19 + 1);
      }

      else if (v40 == 1)
      {
        ++v20;
      }
    }

    else
    {
      if (v18 >= 1)
      {
        else {
          int v41 = 2;
        }
        if (v20 == (_DWORD)v19) {
          BOOL v42 = v19 != 0;
        }
        else {
          BOOL v42 = v41;
        }
        uint64_t v44 = v135[1];
        unint64_t v43 = (unint64_t)v135[2];
        if ((unint64_t)v44 >= v43)
        {
          unint64_t v46 = *v135;
          unint64_t v47 = 0xAAAAAAAAAAAAAAABLL * ((v44 - *v135) >> 2);
          unint64_t v48 = v47 + 1;
          if (v47 + 1 > 0x1555555555555555LL) {
            sub_100007008();
          }
          int v136 = v24;
          int v49 = v23;
          unint64_t v50 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v43 - (void)v46) >> 2);
          if (2 * v50 > v48) {
            unint64_t v48 = 2 * v50;
          }
          if (v50 >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v51 = 0x1555555555555555LL;
          }
          else {
            unint64_t v51 = v48;
          }
          if (v51)
          {
            double v52 = (char *)sub_1005AADE4(v127, v51);
            unint64_t v46 = *v135;
            uint64_t v44 = v135[1];
          }

          else
          {
            double v52 = 0LL;
          }

          double v53 = &v52[12 * v47];
          *(_DWORD *)double v53 = v134;
          *((_DWORD *)v53 + 1) = v37;
          *((_DWORD *)v53 + 2) = v42;
          double v54 = v53;
          if (v44 == v46)
          {
            double v57 = v135;
          }

          else
          {
            do
            {
              uint64_t v55 = *(void *)(v44 - 12);
              v44 -= 12;
              int v56 = *((_DWORD *)v44 + 2);
              *(void *)(v54 - 12) = v55;
              v54 -= 12;
              *((_DWORD *)v54 + 2) = v56;
            }

            while (v44 != v46);
            double v57 = v135;
            unint64_t v46 = *v135;
          }

          uint64_t v45 = v53 + 12;
          *double v57 = v54;
          v57[1] = v53 + 12;
          _OWORD v57[2] = &v52[12 * v51];
          if (v46) {
            operator delete(v46);
          }
          uint64_t v17 = a7;
          uint64_t v16 = a8;
          int v15 = a5;
          unint64_t v14 = a6;
          int v23 = v49;
          int v24 = v136;
        }

        else
        {
          *(_DWORD *)uint64_t v44 = v134;
          *((_DWORD *)v44 + 1) = v37;
          uint64_t v45 = v44 + 12;
          *((_DWORD *)v44 + 2) = v42;
        }

        v135[1] = v45;
      }

      int v18 = 0;
      uint64_t v19 = 0LL;
      int v20 = 0;
      int v134 = v37 + 1;
    }

    uint64_t v59 = *(void *)(v22 + 8);
    uint64_t v58 = *(void *)(v22 + 16);
    uint64_t v60 = *(void *)v22;
    uint64_t v61 = *(void *)(v22 + 48);
    double v62 = a3[1];
    uint64_t v63 = a3[2];
    if (v62 >= v63)
    {
      unint64_t v65 = 0xAAAAAAAAAAAAAAABLL * ((v62 - *a3) >> 4);
      unint64_t v66 = v65 + 1;
      if (v65 + 1 > 0x555555555555555LL) {
        goto LABEL_137;
      }
      int v137 = v23;
      uint64_t v67 = v19;
      unint64_t v68 = 0xAAAAAAAAAAAAAAABLL * ((v63 - *a3) >> 4);
      if (2 * v68 > v66) {
        unint64_t v66 = 2 * v68;
      }
      if (v68 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v69 = 0x555555555555555LL;
      }
      else {
        unint64_t v69 = v66;
      }
      if (v69)
      {
        double v70 = v21;
        int v71 = v24;
        __int128 v72 = (char *)sub_1000BB1F4(v128, v69);
        int v24 = v71;
        unint64_t v21 = v70;
      }

      else
      {
        __int128 v72 = 0LL;
      }

      uint64_t v73 = &v72[48 * v65];
      *(void *)uint64_t v73 = v59;
      *((void *)v73 + 1) = v58;
      *((void *)v73 + 2) = v60;
      *((void *)v73 + 3) = v61;
      *((_DWORD *)v73 + _Block_object_dispose(va, 8) = v40;
      *((_DWORD *)v73 + 9) = 0;
      *((_DWORD *)v73 + 10) = v24;
      uint64_t v75 = *a3;
      __int16 v74 = a3[1];
      uint64_t v76 = v73;
      if (v74 != *a3)
      {
        do
        {
          __int128 v77 = *((_OWORD *)v74 - 3);
          __int128 v78 = *((_OWORD *)v74 - 2);
          *(_OWORD *)(v76 - 20) = *(_OWORD *)(v74 - 20);
          *((_OWORD *)v76 - 3) = v77;
          *((_OWORD *)v76 - 2) = v78;
          v76 -= 48;
          v74 -= 48;
        }

        while (v74 != v75);
        __int16 v74 = *a3;
      }

      double v64 = v73 + 48;
      *a3 = v76;
      a3[1] = v73 + 48;
      a3[2] = &v72[48 * v69];
      if (v74) {
        operator delete(v74);
      }
      uint64_t v17 = a7;
      uint64_t v16 = a8;
      uint64_t v19 = v67;
      int v15 = a5;
      unint64_t v14 = a6;
      int v23 = v137;
    }

    else
    {
      *(void *)double v62 = v59;
      *((void *)v62 + 1) = v58;
      *((void *)v62 + 2) = v60;
      *((void *)v62 + 3) = v61;
      *((_DWORD *)v62 + _Block_object_dispose(va, 8) = v40;
      *((_DWORD *)v62 + 9) = 0;
      double v64 = v62 + 48;
      *((_DWORD *)v62 + 10) = v24;
    }

    a3[1] = v64;
    v22 += 80LL;
    if (v22 - *v21 == 4080)
    {
      unint64_t v79 = v21[1];
      ++v21;
      unint64_t v22 = v79;
      goto LABEL_4;
    }
  }

  uint64_t v82 = a1[328];
  if (a1[329] == v82)
  {
    unint64_t v84 = 0LL;
  }

  else
  {
    unint64_t v83 = a1[332] + a1[331];
    unint64_t v84 = *(void *)(v82 + 8 * (v83 / 0x33)) + 80 * (v83 % 0x33);
  }

  if ((uint64_t *)v84 != v16)
  {
    uint64_t v86 = v16[1];
    uint64_t v85 = v16[2];
    uint64_t v87 = *v16;
    uint64_t v88 = v16[6];
    int v89 = *((_DWORD *)v16 + 16);
    double v90 = a3[1];
    __int16 v91 = a3[2];
    if (v90 >= v91)
    {
      unint64_t v93 = 0xAAAAAAAAAAAAAAABLL * ((v90 - *a3) >> 4);
      unint64_t v94 = v93 + 1;
      if (v93 + 1 > 0x555555555555555LL) {
LABEL_137:
      }
        sub_100007008();
      int v95 = v19;
      unint64_t v96 = 0xAAAAAAAAAAAAAAABLL * ((v91 - *a3) >> 4);
      if (2 * v96 > v94) {
        unint64_t v94 = 2 * v96;
      }
      if (v96 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v97 = 0x555555555555555LL;
      }
      else {
        unint64_t v97 = v94;
      }
      if (v97)
      {
        int v98 = v23;
        __int16 v99 = (char *)sub_1000BB1F4(v128, v97);
        int v24 = v98;
      }

      else
      {
        __int16 v99 = 0LL;
      }

      int v100 = &v99[48 * v93];
      __int16 v101 = &v99[48 * v97];
      *(void *)int v100 = v86;
      *((void *)v100 + 1) = v85;
      *((void *)v100 + 2) = v87;
      *((void *)v100 + 3) = v88;
      *((_DWORD *)v100 + _Block_object_dispose(va, 8) = v89;
      v100[36] = 1;
      *((_DWORD *)v100 + 10) = v24;
      uint64_t v92 = v100 + 48;
      uint64_t v103 = *a3;
      double v102 = a3[1];
      if (v102 != *a3)
      {
        do
        {
          __int128 v104 = *((_OWORD *)v102 - 3);
          __int128 v105 = *((_OWORD *)v102 - 2);
          *(_OWORD *)(v100 - 20) = *(_OWORD *)(v102 - 20);
          *((_OWORD *)v100 - 3) = v104;
          *((_OWORD *)v100 - 2) = v105;
          v100 -= 48;
          v102 -= 48;
        }

        while (v102 != v103);
        double v102 = *a3;
      }

      *a3 = v100;
      a3[1] = v92;
      a3[2] = v101;
      if (v102) {
        operator delete(v102);
      }
      LODWORD(vsub_100210A00(v2 + 19) = v95;
    }

    else
    {
      *(void *)double v90 = v86;
      *((void *)v90 + 1) = v85;
      *((void *)v90 + 2) = v87;
      *((void *)v90 + 3) = v88;
      *((_DWORD *)v90 + _Block_object_dispose(va, 8) = v89;
      v90[36] = 1;
      uint64_t v92 = v90 + 48;
      *((_DWORD *)v90 + 10) = v23;
    }

    a3[1] = v92;
  }

  BOOL result = 1LL;
  if (v18 >= 2)
  {
    else {
      int v106 = 2;
    }
    if (v20 == (_DWORD)v19) {
      BOOL v107 = v19 != 0;
    }
    else {
      BOOL v107 = v106;
    }
    double v108 = v135;
    double v110 = v135[1];
    unint64_t v109 = (unint64_t)v135[2];
    if ((unint64_t)v110 >= v109)
    {
      double v112 = *v135;
      unint64_t v113 = 0xAAAAAAAAAAAAAAABLL * ((v110 - *v135) >> 2);
      unint64_t v114 = v113 + 1;
      if (v113 + 1 > 0x1555555555555555LL) {
        sub_100007008();
      }
      unint64_t v115 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v109 - (void)v112) >> 2);
      if (2 * v115 > v114) {
        unint64_t v114 = 2 * v115;
      }
      if (v115 >= 0xAAAAAAAAAAAAAAALL) {
        unint64_t v116 = 0x1555555555555555LL;
      }
      else {
        unint64_t v116 = v114;
      }
      if (v116)
      {
        double v117 = (char *)sub_1005AADE4(v127, v116);
        double v108 = v135;
        __int128 v118 = v117;
        double v112 = *v135;
        double v110 = v135[1];
      }

      else
      {
        __int128 v118 = 0LL;
      }

      uint64_t v119 = &v118[12 * v113];
      __int16 v120 = &v118[12 * v116];
      *(_DWORD *)uint64_t v119 = v134;
      *((_DWORD *)v119 + 1) = v125;
      *((_DWORD *)v119 + 2) = v107;
      __int16 v111 = v119 + 12;
      if (v110 != v112)
      {
        do
        {
          uint64_t v121 = *(void *)(v110 - 12);
          v110 -= 12;
          int v122 = *((_DWORD *)v110 + 2);
          *(void *)(v119 - 12) = v121;
          v119 -= 12;
          *((_DWORD *)v119 + 2) = v122;
        }

        while (v110 != v112);
        double v112 = *v108;
      }

      *double v108 = v119;
      v108[1] = v111;
      v108[2] = v120;
      if (v112)
      {
        operator delete(v112);
        double v108 = v135;
      }
    }

    else
    {
      *(_DWORD *)double v110 = v134;
      *((_DWORD *)v110 + 1) = v125;
      __int16 v111 = v110 + 12;
      *((_DWORD *)v110 + 2) = v107;
    }

    v108[1] = v111;
    return 1LL;
  }

  return result;
}

void sub_1005A8194(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - (_BYTE *)*a1) >> 4) < a2)
  {
    if (a2 >= 0x555555555555556LL) {
      sub_100007008();
    }
    int64_t v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    int v6 = (char *)sub_1000BB1F4(v3, a2);
    unint64_t v7 = &v6[v5];
    double v9 = &v6[48 * v8];
    unint64_t v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    __int128 v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        __int128 v13 = *((_OWORD *)v10 - 3);
        __int128 v14 = *((_OWORD *)v10 - 2);
        *(_OWORD *)(v12 - 20) = *(_OWORD *)(v10 - 20);
        *((_OWORD *)v12 - 3) = v13;
        *((_OWORD *)v12 - 2) = v14;
        v12 -= 48;
        v10 -= 48;
      }

      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

uint64_t sub_1005A8254(void *a1, void *a2, uint64_t *a3)
{
  uint64_t v6 = a1[2];
  uint64_t v7 = a1[1];
  if (v6 == v7) {
    uint64_t v8 = 0LL;
  }
  else {
    uint64_t v8 = 32 * (v6 - v7) - 1;
  }
  uint64_t v9 = a1[4];
  uint64_t v10 = a1[5];
  unint64_t v11 = v10 + v9;
  if (v8 == v10 + v9)
  {
    sub_1005AA198(a1);
    uint64_t v9 = a1[4];
    uint64_t v10 = a1[5];
    uint64_t v7 = a1[1];
    unint64_t v11 = v9 + v10;
  }

  __int128 v12 = (void *)(*(void *)(v7 + ((v11 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v11);
  uint64_t v13 = *a3;
  *__int128 v12 = *a2;
  v12[1] = v13;
  uint64_t v14 = v10 + 1;
  a1[5] = v14;
  unint64_t v15 = v9 + v14;
  uint64_t v16 = (void *)(v7 + 8 * (v15 >> 8));
  if ((_BYTE)v15) {
    uint64_t v17 = *v16 + 16LL * v15;
  }
  else {
    uint64_t v17 = *(v16 - 1) + 4096LL;
  }
  return v17 - 16;
}

__n128 sub_1005A8314(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 51 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1005ABAE0(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x33)) + 80 * (v7 % 0x33);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  __n128 result = *(__n128 *)(a2 + 16);
  __int128 v10 = *(_OWORD *)(a2 + 32);
  __int128 v11 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v8 + 4_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v8 + 64) = v11;
  *(__n128 *)(v8 + 16) = result;
  *(_OWORD *)(v8 + 32) = v10;
  ++a1[5];
  return result;
}

void sub_1005A83D0(id a1)
{
  qword_101934748 = (uint64_t)os_log_create("com.apple.locationd.Motion", "RunningForm");
}

void *sub_1005A83FC(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 + 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(result[1] - *(void *)*result) >> 4);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 22 - v3;
      uint64_t v6 = &v2[-(v5 / 0x17)];
      *__n128 result = v6;
      unint64_t v4 = *v6 + 176 * (23 * (v5 / 0x17) - v5) + 3872;
    }

    else
    {
      *__n128 result = &v2[v3 / 0x17];
      unint64_t v4 = v2[v3 / 0x17] + 176 * (v3 % 0x17);
    }

    result[1] = v4;
  }

  return result;
}

double sub_1005A84C4(double *a1, double *a2, double a3)
{
  uint64_t v3 = (char *)a2 - (char *)a1;
  unint64_t v4 = a1;
  unint64_t v5 = (unint64_t)(v3 >> 3) >> 1;
  uint64_t v6 = &a1[v5];
  if (v6 != a2) {
    sub_10023DA1C(a1, &a1[v5], a2, a3);
  }
  if (((v3 >> 3) & 0x8000000000000001LL) == 1) {
    return *v6;
  }
  if ((unint64_t)v3 >= 0x10 && v5 != 1)
  {
    unint64_t v8 = v4 + 1;
    double v9 = *v4;
    uint64_t v10 = 8 * v5 - 8;
    __int128 v11 = v4 + 1;
    do
    {
      double v12 = *v11++;
      double v13 = v12;
      if (v9 < v12)
      {
        double v9 = v13;
        unint64_t v4 = v8;
      }

      unint64_t v8 = v11;
      v10 -= 8LL;
    }

    while (v10);
  }

  return *v4 + (*v6 - *v4) * 0.5;
}

void sub_1005A859C(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_1005A85C8(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a1 + 16) <= a3)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101841248);
    }
    unint64_t v15 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "Assertion failed: false, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMRandomForest.h, line 56 ,Index exceeds ensemble size.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101841248);
      }
      LOWORD(v28[0]) = 0;
      int v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: false, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMRandomFor est.h, line 56,Index exceeds ensemble size.",  v28,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual int16_t CMRandomForest<22>::findLeaf(const float (&)[NFeat], size_t) const [NFeat = 22]",  "%s\n",  v23);
    }

    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101841248);
    }
    uint64_t v16 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Error: Index exceeds ensemble size", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101841248);
      }
      LOWORD(v28[0]) = 0;
      LODWORD(v27) = 2;
      uint64_t v17 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Error: Index exceeds ensemble size",  v28,  v27,  v28[0]);
LABEL_67:
      unint64_t v26 = (uint8_t *)v17;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual int16_t CMRandomForest<22>::findLeaf(const float (&)[NFeat], size_t) const [NFeat = 22]",  "%s\n",  v17);
      if (v26 != buf) {
        free(v26);
      }
    }
  }

  else
  {
    unint64_t v3 = 0LL;
    unint64_t v4 = (void *)(*(void *)(a1 + 8) + 16 * a3);
    while (v3 < v4[1])
    {
      unint64_t v5 = *(unsigned __int16 *)(*v4 + 10 * v3 + 4);
      if (v5 >= 0x16)
      {
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101841248);
        }
        int v20 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_FAULT,  "Assertion failed: false, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMRandomForest.h, lin e 65,Invalid decision tree, feature index exceeds feature array.",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101841248);
          }
          LOWORD(v28[0]) = 0;
          uint64_t v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: false, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMRando mForest.h, line 65,Invalid decision tree, feature index exceeds feature array.",  v28,  2);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual int16_t CMRandomForest<22>::findLeaf(const float (&)[NFeat], size_t) const [NFeat = 22]",  "%s\n",  v25);
        }

        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101841248);
        }
        unint64_t v21 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "Error: Invalid decision tree, feature index exceeds feature array",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101841248);
          }
          LOWORD(v28[0]) = 0;
          LODWORD(v27) = 2;
          uint64_t v17 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Error: Invalid decision tree, feature index exceeds feature array",  v28,  v27,  v28[0]);
          goto LABEL_67;
        }

        return -1;
      }

      uint64_t v6 = (float *)(*v4 + 10 * v3);
      float v7 = *(float *)(a2 + 4 * v5);
      unint64_t v8 = (unsigned __int16 *)v6 + 3;
      float v10 = *v6;
      double v9 = (unsigned __int16 *)(v6 + 2);
      BOOL v11 = v7 > v10;
      if (v7 >= v10) {
        double v12 = v9;
      }
      else {
        double v12 = v8;
      }
      if (!v11) {
        double v9 = v8;
      }
      if (*(_BYTE *)(a1 + 24)) {
        double v9 = v12;
      }
      int v13 = (__int16)*v9;
      unint64_t v3 = *v9;
      if (v13 < 0) {
        return (__int16)~(_WORD)v3;
      }
    }

    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101841248);
    }
    int v18 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "Assertion failed: false, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMRandomForest.h, line 91 ,Invalid decision tree, child index exceeds node array.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101841248);
      }
      LOWORD(v28[0]) = 0;
      int v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: false, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMRandomFor est.h, line 91,Invalid decision tree, child index exceeds node array.",  v28,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual int16_t CMRandomForest<22>::findLeaf(const float (&)[NFeat], size_t) const [NFeat = 22]",  "%s\n",  v24);
    }

    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101841248);
    }
    uint64_t v19 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "Error: Invalid decision tree, child index exceeds node array",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101841248);
      }
      LOWORD(v28[0]) = 0;
      LODWORD(v27) = 2;
      uint64_t v17 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Error: Invalid decision tree, child index exceeds node array",  v28,  v27,  v28[0]);
      goto LABEL_67;
    }
  }

  return -1;
}

uint64_t sub_1005A8CF4(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 17LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 34LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    float v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

uint64_t sub_1005A8D88(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 42LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 85LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    float v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void sub_1005A8E1C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    float v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1005A90E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_1005A9130(void *result, uint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = (void *)*result;
    unint64_t v3 = a2 + 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 72 - v3;
      uint64_t v6 = &v2[-(v5 / 0x49)];
      *__n128 result = v6;
      unint64_t v4 = *v6 + 56 * (73 * (v5 / 0x49) - v5) + 4032;
    }

    else
    {
      *__n128 result = &v2[v3 / 0x49];
      unint64_t v4 = v2[v3 / 0x49] + 56 * (v3 % 0x49);
    }

    result[1] = v4;
  }

  return result;
}

void sub_1005A91E4(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    float v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1005A94AC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005A94F8(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    float v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1005A97C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005A980C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x55;
  unint64_t v4 = v2 - 85;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    float v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1005A9AD4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1005A9B20(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x22;
  unint64_t v4 = v2 - 34;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    float v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1005A9DE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

float sub_1005A9E34(void *a1, uint64_t a2, uint64_t a3)
{
  int v5 = (*(uint64_t (**)(void *))(*a1 + 16LL))(a1);
  float v6 = 0.0;
  if (v5 != -1)
  {
    uint64_t v7 = a1[4];
    if (*(void *)(v7 + 16 * a3 + 8) <= (unint64_t)(unsigned __int16)v5)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101841248);
      }
      unint64_t v8 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "Assertion failed: false, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMRandomForestRegressio n.h, line 58,Invalid decision tree, regression index exceeds array length.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101841248);
        }
        v16[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: false, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMRandomForestRegressio n.h, line 58,Invalid decision tree, regression index exceeds array length.",  v16,  2);
        uint64_t v12 = (uint8_t *)v11;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "float CMRandomForestRegression<22>::evaluateTree(const float (&)[NFeat], size_t) const [NFeat = 22]",  "%s\n",  v11);
        if (v12 != buf) {
          free(v12);
        }
      }

      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101841248);
      }
      double v9 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Error: Invalid decision tree, regression index exceeds array length",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101841248);
        }
        v16[0] = 0;
        LODWORD(v15) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Error: Invalid decision tree, regression index exceeds array length",  v16,  v15);
        BOOL v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "float CMRandomForestRegression<22>::evaluateTree(const float (&)[NFeat], size_t) const [NFeat = 22]",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }

    else
    {
      return *(float *)(*(void *)(v7 + 16 * a3) + 4LL * (unsigned __int16)v5);
    }
  }

  return v6;
}

uint64_t sub_1005AA13C(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x22) {
    a2 = 1;
  }
  if (v2 < 0x44) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 34LL;
  }

  return v4 ^ 1u;
}

void sub_1005AA198(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    float v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1005AA460( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005AA4AC(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  sub_1005AA4F0((void *)a1, a2, a3, a4, a5);
  return a1;
}

void sub_1005AA4DC(_Unwind_Exception *a1)
{
}

void *sub_1005AA4F0(void *a1, void *a2, uint64_t a3, void *a4, uint64_t a5)
{
  if (a5 == a3) {
    unint64_t v5 = 0LL;
  }
  else {
    unint64_t v5 = 73 * (a4 - a2) + 0x6DB6DB6DB6DB6DB7LL * ((a5 - *a4) >> 3) - 0x6DB6DB6DB6DB6DB7LL * ((a3 - *a2) >> 3);
  }
  return sub_1005AA554(a1, a2, a3, v5);
}

void *sub_1005AA554(void *a1, void *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1[1];
  uint64_t v9 = a1[2];
  if (v9 == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = 73 * ((v9 - v8) >> 3) - 1;
  }
  unint64_t v11 = a1[5] + a1[4];
  unint64_t v12 = v10 - v11;
  if (a4 > v12)
  {
    sub_1005AA6DC(a1, a4 - v12);
    uint64_t v8 = a1[1];
    uint64_t v9 = a1[2];
    unint64_t v11 = a1[4] + a1[5];
  }

  uint64_t v13 = (void *)(v8 + 8 * (v11 / 0x49));
  if (v9 == v8) {
    unint64_t v14 = 0LL;
  }
  else {
    unint64_t v14 = *v13 + 56 * (v11 % 0x49);
  }
  uint64_t v24 = (void *)(v8 + 8 * (v11 / 0x49));
  unint64_t v25 = v14;
  __n128 result = sub_1005A9130(&v24, a4);
  uint64_t v16 = v25;
  if (v14 != v25)
  {
    uint64_t v17 = v24;
    do
    {
      if (v13 == v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4088LL;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }

      else
      {
        unint64_t v19 = v14;
        do
        {
          *(_OWORD *)unint64_t v19 = *(_OWORD *)a3;
          __int128 v20 = *(_OWORD *)(a3 + 16);
          __int128 v21 = *(_OWORD *)(a3 + 32);
          *(void *)(v19 + 4_Block_object_dispose(va, 8) = *(void *)(a3 + 48);
          *(_OWORD *)(v19 + 16) = v20;
          *(_OWORD *)(v19 + 32) = v21;
          a3 += 56LL;
          if (a3 - *a2 == 4088)
          {
            uint64_t v22 = a2[1];
            ++a2;
            a3 = v22;
          }

          v19 += 56LL;
        }

        while (v19 != v18);
      }

      a1[5] += 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v18 - v14) >> 3);
      if (v13 == v17) {
        break;
      }
      unint64_t v23 = v13[1];
      ++v13;
      unint64_t v14 = v23;
    }

    while (v23 != v16);
  }

  return result;
}

void sub_1005AA6DC(void *a1, unint64_t a2)
{
  BOOL v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if (v5 % 0x49) {
    unint64_t v6 = v5 / 0x49 + 1;
  }
  else {
    unint64_t v6 = v5 / 0x49;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 / 0x49) {
    unint64_t v8 = v7 / 0x49;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 / 0x49)
  {
    for (a1[4] = v7 - 73 * v8; v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      uint64_t v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unint64_t v29 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v28);
          __int128 v31 = &v29[8 * (v28 >> 2)];
          __int128 v32 = (uint64_t *)a1[1];
          BOOL v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            BOOL v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            unint64_t v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)unint64_t v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            BOOL v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          unint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            BOOL v3 = (char *)a1[1];
          }

          uint64_t v27 = &v3[-8 * (v24 >> 1)];
          BOOL v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)BOOL v3 = v18;
      BOOL v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0xFF8uLL);
          sub_1000EC960(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0xFF8uLL);
          sub_1000ECA74((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 72LL;
          }
          else {
            uint64_t v64 = 73LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - 73 * v8;
      if (v8)
      {
        unint64_t v66 = (char *)a1[2];
        do
        {
          uint64_t v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          unint64_t v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              unint64_t v79 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v78);
              double v81 = &v79[8 * (v78 >> 2)];
              uint64_t v82 = (uint64_t *)a1[1];
              unint64_t v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                unint64_t v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                uint64_t v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)uint64_t v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              uint64_t v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                unint64_t v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              uint64_t v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                unint64_t v66 = (char *)a1[1];
              }

              __int128 v77 = &v66[-8 * (v74 >> 1)];
              unint64_t v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)unint64_t v66 = v69;
          unint64_t v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      __int16 v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0LL;
      }
      uint64_t v38 = -73LL * v8;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        uint64_t v88 = operator new(0xFF8uLL);
        sub_1000ECB90(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        uint64_t v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000071BC((uint64_t)v91, v48);
              unint64_t v51 = (uint64_t *)__p[1];
              uint64_t v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                uint64_t v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                __int128 v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)__int128 v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              int v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                uint64_t v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                uint64_t v40 = (char *)__p[1];
              }

              uint64_t v47 = &v40[-8 * (v44 >> 1)];
              uint64_t v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)uint64_t v40 = *v39;
          uint64_t v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      double v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000ECCA4((uint64_t)__p, v57);
      }

      uint64_t v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] += v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_1005AAC1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005AAC90(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x33) {
    a2 = 1;
  }
  if (v2 < 0x66) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 51LL;
  }

  return v4 ^ 1u;
}

void *sub_1005AACEC(void *a1, uint64_t a2, void *a3, uint64_t a4, double *a5)
{
  uint64_t v5 = a2;
  unint64_t v6 = a1;
  if (a4 != a2)
  {
    unint64_t v7 = 23 * (a3 - a1) + 0x2E8BA2E8BA2E8BA3LL * ((a4 - *a3) >> 4) - 0x2E8BA2E8BA2E8BA3LL * ((a2 - *a1) >> 4);
    if (v7)
    {
      do
      {
        unint64_t v9 = v7 >> 1;
        unint64_t v12 = v6;
        uint64_t v13 = v5;
        sub_1005A83FC(&v12, v7 >> 1);
        uint64_t v10 = v13;
        if (*(double *)(v13 + 8) < *a5)
        {
          uint64_t v5 = v13 + 176;
          v13 += 176LL;
          unint64_t v6 = v12;
          if (v10 + 176 - *v12 == 4048)
          {
            unint64_t v6 = v12 + 1;
            uint64_t v5 = v12[1];
          }

          unint64_t v9 = v7 + ~v9;
        }

        unint64_t v7 = v9;
      }

      while (v9);
    }
  }

  return v6;
}

void *sub_1005AADE4(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556LL) {
    sub_1000070D4();
  }
  return operator new(12 * a2);
}

float *sub_1005AAE28@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  for (unint64_t i = 0LL; i != 3; ++i)
  {
    for (unint64_t j = 0LL; j != 3; ++j)
    {
      float v6 = sub_1002B8AF0(a1, i);
      float v7 = v6 * sub_1002B8AF0(a1, j);
      __n128 result = (float *)sub_1002B9EC4(a2, i, j);
      *__n128 result = v7;
    }
  }

  return result;
}

float sub_1005AAEAC(uint64_t a1, unint64_t a2)
{
  if (a2 >= 9)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101841248);
    }
    uint64_t v5 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 134218240;
      unint64_t v12 = a2;
      __int16 v13 = 2048;
      uint64_t v14 = 9LL;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "Assertion failed: ldx < M*N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMMatrix.h, line 84,invalid element %zu >= %zu.",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101841248);
      }
      int v7 = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 9LL;
      float v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: ldx < M*N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMM atrix.h, line 84,invalid element %zu >= %zu.",  (size_t)&v7,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "T CMMatrix<float, 3>::operator[](size_t) const [T = float, M = 3, N = 3]",  "%s\n",  v6);
    }
  }

  return *(float *)(a1 + 4 * a2);
}

float *sub_1005AB084(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0LL;
  *(_DWORD *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  do
  {
    *(_DWORD *)sub_1002B9EC4(a2, v4, v4) = 1065353216;
    int v5 = *(_DWORD *)sub_1002B9EC4(a1, v4, v4);
    *(_DWORD *)sub_1002BA24C((uint64_t)&v69, v4) = v5;
    int v6 = *(_DWORD *)sub_1002B9EC4(a1, v4, v4);
    *(_DWORD *)sub_1002BA24C((uint64_t)&v67, v4) = v6;
    *(_DWORD *)sub_1002BA24C((uint64_t)&v65, v4++) = 0;
  }

  while (v4 != 3);
  unint64_t v7 = 0LL;
  do
  {
    unint64_t v8 = 0LL;
    char v9 = 1;
    float v10 = 0.0;
    do
    {
      char v11 = v9;
      unint64_t v12 = v8 + 1;
      do
      {
        __n128 result = (float *)sub_1002B9EC4(a1, v8, v12);
        float v14 = *result;
        if (*result <= 0.0) {
          float v14 = -*result;
        }
        float v10 = v10 + v14;
        ++v12;
      }

      while (v12 != 3);
      char v9 = 0;
      unint64_t v8 = 1LL;
    }

    while ((v11 & 1) != 0);
    if (v10 == 0.0) {
      break;
    }
    float v15 = 0.0;
    if (v7 <= 2) {
      float v15 = (float)(v10 * 0.2) / 9.0;
    }
    char v16 = 0;
    unint64_t v17 = 0LL;
    unint64_t v64 = v7 + 1;
    char v18 = 1;
    do
    {
      char v19 = v18;
      unint64_t v20 = v17 + 1;
      do
      {
        uint64_t v21 = (float *)sub_1002B9EC4(a1, v17, v20);
        float v22 = *v21;
        if (*v21 <= 0.0) {
          float v22 = -*v21;
        }
        float v23 = v22 * 100.0;
        if (v7 < 4) {
          goto LABEL_31;
        }
        uint64_t v24 = (float *)sub_1002BA24C((uint64_t)&v69, v17);
        float v25 = v23 + *v24;
        if (v25 <= 0.0) {
          float v26 = -v25;
        }
        else {
          float v26 = v23 + *v24;
        }
        uint64_t v27 = (float *)sub_1002BA24C((uint64_t)&v69, v17);
        float v28 = *v27;
        if (*v27 <= 0.0) {
          float v28 = -*v27;
        }
        if (v26 != v28) {
          goto LABEL_31;
        }
        unint64_t v29 = (float *)sub_1002BA24C((uint64_t)&v69, v20);
        float v30 = v23 + *v29;
        if (v30 <= 0.0) {
          float v31 = -v30;
        }
        else {
          float v31 = v23 + *v29;
        }
        __int128 v32 = (float *)sub_1002BA24C((uint64_t)&v69, v20);
        float v33 = *v32;
        if (*v32 <= 0.0) {
          float v33 = -*v32;
        }
        if (v31 == v33)
        {
          __n128 result = (float *)sub_1002B9EC4(a1, v17, v20);
          *__n128 result = 0.0;
        }

        else
        {
LABEL_31:
          __n128 result = (float *)sub_1002B9EC4(a1, v17, v20);
          float v34 = *result;
          if (*result <= 0.0) {
            float v34 = -*result;
          }
          if (v34 > v15)
          {
            float v35 = *(float *)sub_1002BA24C((uint64_t)&v69, v20);
            float v36 = v35 - *(float *)sub_1002BA24C((uint64_t)&v69, v17);
            float v37 = v23 + v36;
            float v38 = -v36;
            if (v36 > 0.0) {
              float v38 = v36;
            }
            if (v37 == v38)
            {
              float v39 = *(float *)sub_1002B9EC4(a1, v17, v20) / v36;
            }

            else
            {
              uint64_t v40 = (float *)sub_1002B9EC4(a1, v17, v20);
              float v41 = (float)(v36 * 0.5) / *v40;
              float v42 = -v41;
              BOOL v43 = v41 < 0.0;
              if (v41 > 0.0) {
                float v42 = (float)(v36 * 0.5) / *v40;
              }
              float v44 = 1.0 / (float)(v42 + sqrtf((float)(v41 * v41) + 1.0));
              if (v43) {
                float v39 = -v44;
              }
              else {
                float v39 = v44;
              }
            }

            float v45 = 1.0 / sqrtf((float)(v39 * v39) + 1.0);
            float v46 = v39 * v45;
            float v47 = (float)(v39 * v45) / (float)(v45 + 1.0);
            float v48 = v39 * *(float *)sub_1002B9EC4(a1, v17, v20);
            uint64_t v49 = (float *)sub_1002BA24C((uint64_t)&v65, v17);
            *uint64_t v49 = *v49 - v48;
            uint64_t v50 = (float *)sub_1002BA24C((uint64_t)&v65, v20);
            *uint64_t v50 = v48 + *v50;
            unint64_t v51 = (float *)sub_1002BA24C((uint64_t)&v69, v17);
            *unint64_t v51 = *v51 - v48;
            uint64_t v52 = (float *)sub_1002BA24C((uint64_t)&v69, v20);
            *uint64_t v52 = v48 + *v52;
            *(_DWORD *)sub_1002B9EC4(a1, v17, v20) = 0;
            if ((v16 & 1) != 0)
            {
              float v53 = *(float *)(a1 + 12);
              __int128 v54 = (float *)sub_1002B9EC4(a1, 0LL, v20);
              float v55 = *v54;
              *(float *)(a1 + 12) = v53 - (float)(v46 * (float)(*v54 + (float)(v53 * v47)));
              *(float *)sub_1002B9EC4(a1, 0LL, v20) = v55 + (float)(v46 * (float)(v53 - (float)(v55 * v47)));
            }

            float v56 = -v46;
            if (v17 + 1 < v20)
            {
              do
              {
                float v57 = *(float *)sub_1002B9EC4(a1, v17, 1uLL);
                float v58 = *(float *)(a1 + 28);
                *(float *)sub_1002B9EC4(a1, v17, 1uLL) = v57 + (float)(v56 * (float)(v58 + (float)(v57 * v47)));
                *(float *)(a1 + 2_Block_object_dispose(va, 8) = v58 + (float)(v46 * (float)(v57 - (float)(v58 * v47)));
              }

              while (v20 > 2);
            }

            if (v20 <= 1)
            {
              float v59 = *(float *)sub_1002B9EC4(a1, v17, 2uLL);
              float v60 = *(float *)sub_1002B9EC4(a1, v20, 2uLL);
              *(float *)sub_1002B9EC4(a1, v17, 2uLL) = v59 + (float)(v56 * (float)(v60 + (float)(v59 * v47)));
              *(float *)sub_1002B9EC4(a1, v20, 2uLL) = v60 + (float)(v46 * (float)(v59 - (float)(v60 * v47)));
            }

            for (unint64_t i = 0LL; i != 3; ++i)
            {
              float v62 = *(float *)sub_1002B9EC4(a2, i, v17);
              float v63 = *(float *)sub_1002B9EC4(a2, i, v20);
              *(float *)sub_1002B9EC4(a2, i, v17) = v62 + (float)(v56 * (float)(v63 + (float)(v62 * v47)));
              __n128 result = (float *)sub_1002B9EC4(a2, i, v20);
              *__n128 result = v63 + (float)(v46 * (float)(v62 - (float)(v63 * v47)));
            }
          }
        }

        ++v20;
      }

      while (v20 != 3);
      char v18 = 0;
      char v16 = 1;
      unint64_t v17 = 1LL;
    }

    while ((v19 & 1) != 0);
    float32x2_t v67 = vadd_f32(v65, v67);
    float v68 = v66 + v68;
    float32x2_t v69 = v67;
    float v70 = v68;
    float v66 = 0.0;
    float32x2_t v65 = 0LL;
    ++v7;
  }

  while (v64 != 10);
  return result;
}

int *sub_1005AB644(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  float v6 = *(float *)sub_1002BA24C(*a1, a2);
  __n128 result = (int *)sub_1002BA24C(*a1, a3);
  if (v6 < *(float *)result)
  {
    unint64_t v8 = (int *)sub_1002BA24C(*a1, a2);
    char v9 = (int *)sub_1002BA24C(*a1, a3);
    int v10 = *v8;
    *unint64_t v8 = *v9;
    int *v9 = v10;
    char v11 = (int *)sub_1002B9EC4(a1[1], 0LL, a2);
    unint64_t v12 = (int *)sub_1002B9EC4(a1[1], 0LL, a3);
    int v13 = *v11;
    *char v11 = *v12;
    *unint64_t v12 = v13;
    float v14 = (int *)sub_1002B9EC4(a1[1], 1uLL, a2);
    float v15 = (int *)sub_1002B9EC4(a1[1], 1uLL, a3);
    int v16 = *v14;
    *float v14 = *v15;
    int *v15 = v16;
    unint64_t v17 = (int *)sub_1002B9EC4(a1[1], 2uLL, a2);
    __n128 result = (int *)sub_1002B9EC4(a1[1], 2uLL, a3);
    int v18 = *v17;
    int *v17 = *result;
    *__n128 result = v18;
  }

  return result;
}

void *sub_1005AB764(void *a1, uint64_t a2, void *a3, uint64_t a4, double *a5)
{
  uint64_t v5 = a2;
  float v6 = a1;
  if (a4 != a2)
  {
    unint64_t v7 = 51 * (a3 - a1) - 0x3333333333333333LL * ((a4 - *a3) >> 4) + 0x3333333333333333LL * ((a2 - *a1) >> 4);
    if (v7)
    {
      do
      {
        unint64_t v9 = v7 >> 1;
        unint64_t v12 = v6;
        uint64_t v13 = v5;
        sub_1005AB848(&v12, v7 >> 1);
        uint64_t v10 = v13;
        if (*(double *)(v13 + 48) < *a5)
        {
          uint64_t v5 = v13 + 80;
          v13 += 80LL;
          float v6 = v12;
          if (v10 + 80 - *v12 == 4080)
          {
            float v6 = v12 + 1;
            uint64_t v5 = v12[1];
          }

          unint64_t v9 = v7 + ~v9;
        }

        unint64_t v7 = v9;
      }

      while (v9);
    }
  }

  return v6;
}

void *sub_1005AB848(void *result, uint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x3333333333333333LL * ((uint64_t)(result[1] - *(void *)*result) >> 4);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 50 - v3;
      float v6 = &v2[-(v5 / 0x33)];
      *__n128 result = v6;
      unint64_t v4 = *v6 + 80 * (51 * (v5 / 0x33) - v5) + 4000;
    }

    else
    {
      *__n128 result = &v2[v3 / 0x33];
      unint64_t v4 = v2[v3 / 0x33] + 80 * (v3 % 0x33);
    }

    result[1] = v4;
  }

  return result;
}

void *sub_1005AB8F4(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a2;
  float v6 = a1;
  if (a4 != a2)
  {
    unint64_t v7 = 73 * (a3 - a1) + 0x6DB6DB6DB6DB6DB7LL * ((a4 - *a3) >> 3) - 0x6DB6DB6DB6DB6DB7LL * ((a2 - *a1) >> 3);
    if (v7)
    {
      do
      {
        unint64_t v9 = v7 >> 1;
        unint64_t v12 = v6;
        uint64_t v13 = v5;
        sub_1005A9130(&v12, v7 >> 1);
        uint64_t v10 = v13;
        if (*(double *)(v13 + 40) <= *(double *)(a5 + 40))
        {
          uint64_t v5 = v13 + 56;
          v13 += 56LL;
          float v6 = v12;
          if (v10 + 56 - *v12 == 4088)
          {
            float v6 = v12 + 1;
            uint64_t v5 = v12[1];
          }

          unint64_t v9 = v7 + ~v9;
        }

        unint64_t v7 = v9;
      }

      while (v9);
    }
  }

  return v6;
}

void *sub_1005AB9EC(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a2;
  float v6 = a1;
  if (a4 != a2)
  {
    unint64_t v7 = 73 * (a3 - a1) + 0x6DB6DB6DB6DB6DB7LL * ((a4 - *a3) >> 3) - 0x6DB6DB6DB6DB6DB7LL * ((a2 - *a1) >> 3);
    if (v7)
    {
      do
      {
        unint64_t v9 = v7 >> 1;
        char v11 = v6;
        uint64_t v12 = v5;
        sub_1005A9130(&v11, v7 >> 1);
        if (*(double *)(a5 + 40) > *(double *)(v12 + 40))
        {
          float v6 = v11;
          uint64_t v5 = v12 + 56;
          if (v12 + 56 - *v11 == 4088)
          {
            float v6 = v11 + 1;
            uint64_t v5 = v11[1];
          }

          unint64_t v9 = v7 + ~v9;
        }

        unint64_t v7 = v9;
      }

      while (v9);
    }
  }

  return v6;
}

void sub_1005ABAE0(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x33;
  unint64_t v4 = v2 - 51;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    float v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      float v34 = (char *)sub_1000071BC(v5, v33);
      float v35 = &v34[8 * (v33 >> 2)];
      float v37 = &v34[8 * v36];
      float v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        float v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)float v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1005ABDA8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005ABDF4(uint64_t a1, void *a2)
{
  *(void *)sub_10060A360((const void *)a1, a2) = off_1018412E0;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = [(Class)off_101938990[0]() sharedInstance];
  *(_BYTE *)(a1 + 136) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 208LL))(a1);
  *(_BYTE *)(a1 + 1sub_1005A8CF4(v2 + 37) = sub_1005AC09C();
  *(void *)(a1 + 14_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 140) = 0LL;
  sub_1002F1454(a1 + 160, @"com.apple.nanolifestyle.sessiontrackerapp", 1, (uint64_t)@"mobile");
  *(void *)(a1 + 296) = 0LL;
  *(void *)(a1 + 304) = 0xBFF0000000000000LL;
  *(_WORD *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 316) = 0;
  *(_BYTE *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 324) = 0;
  int v17 = 0;
  sub_10023AE2C((unsigned __int8 *)(a1 + 328), "OverrideFitnessTrackingChargerWithType", &v17, 0);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver( DarwinNotifyCenter,  (const void *)a1,  (CFNotificationCallback)sub_1005AC0F0,  @"NanoLifestylePrivacyPreferencesChangedNotification",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  unint64_t v4 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver( v4,  (const void *)a1,  (CFNotificationCallback)sub_1005AC310,  @"NanoLifestyleSessionTrackerAppPreferencesChangedNotification",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  uint64_t v5 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver( v5,  (const void *)a1,  (CFNotificationCallback)sub_1005AC530,  @"NanoLifestyleEnableFitnessDataCollectionSettingDidChangeNotification",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  char v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 216LL))(a1);
  sub_10060AB4C(a1, v6);
  unint64_t v7 = CFNotificationCenterGetDarwinNotifyCenter();
  unint64_t v8 = (const __CFString *)off_101938998[0]();
  CFNotificationCenterAddObserver( v7,  (const void *)a1,  (CFNotificationCallback)sub_1005AC750,  v8,  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  unint64_t v9 = CFNotificationCenterGetDarwinNotifyCenter();
  uint64_t v10 = (const __CFString *)off_1019389A0();
  CFNotificationCenterAddObserver( v9,  (const void *)a1,  (CFNotificationCallback)sub_1005AC750,  v10,  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  sub_1003CC884((uint64_t)sub_1005AC970, a1, *(void **)(a1 + 32), &v16);
  uint64_t v11 = v16;
  uint64_t v16 = 0LL;
  uint64_t v12 = *(void *)(a1 + 296);
  *(void *)(a1 + 296) = v11;
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    uint64_t v13 = v16;
    uint64_t v16 = 0LL;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
    }
  }

  objc_msgSend( *(id *)(*(void *)(a1 + 296) + 16),  "register:forNotification:registrationInfo:",  *(void *)(*(void *)(a1 + 296) + 8),  7,  0,  v16);
  else {
    int v14 = 1;
  }
  sub_10060AB54(a1, v14);
  sub_1005ACB48((_DWORD *)a1);
  sub_1005ACD28((_DWORD *)a1);
  return a1;
}

void sub_1005AC050(_Unwind_Exception *a1)
{
  uint64_t v4 = v1[37];
  v1[37] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_1002F14C8(v2);
  sub_10060A80C(v1);
  _Unwind_Resume(a1);
}

id sub_1005AC09C()
{
  id v0 = objc_msgSend(objc_msgSend((Class)off_101938990[0](), "sharedInstance"), "getActivePairedDevice");
  return _objc_msgSend( v0,  "supportsCapability:",   -[NSUUID initWithUUIDString:]( [NSUUID alloc],  "initWithUUIDString:",  @"C5DDE5DD-2FF7-4735-80A3-0108488556DE"));
}

void sub_1005AC0F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101841410);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v15 = 1;
    uint64_t v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFitnessTrackingNotifier::fitnessTrackingStateChanged",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841410);
    }
    uint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v17 = 0;
      __int16 v18 = 2082;
      char v19 = "";
      __int16 v20 = 2082;
      uint64_t v21 = "activity";
      __int16 v22 = 2050;
      uint64_t v23 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFitnessTrackingNotifier::fitnessTrackingStateChanged, event:%{public, location:es cape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v15 = 0;
  }

  id v12 = [*(id *)(a2 + 32) silo];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _OWORD v13[2] = sub_1005AFC94;
  void v13[3] = &unk_10182D1B8;
  _DWORD v13[4] = a2;
  v13[5] = a1;
  void v13[6] = a3;
  _WORD v13[7] = a4;
  v13[8] = a5;
  [v12 sync:v13];
  if (v15) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005AC2F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state, char a19)
{
  if (a19) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005AC310(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101841410);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v15 = 1;
    uint64_t v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFitnessTrackingNotifierWatch::nanoLifestyleSessionTrackerAppPreferencesChanged",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841410);
    }
    uint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v17 = 0;
      __int16 v18 = 2082;
      char v19 = "";
      __int16 v20 = 2082;
      uint64_t v21 = "activity";
      __int16 v22 = 2050;
      uint64_t v23 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFitnessTrackingNotifierWatch::nanoLifestyleSessionTrackerAppPreferencesChanged, eve nt:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v15 = 0;
  }

  id v12 = [*(id *)(a2 + 32) silo];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _OWORD v13[2] = sub_1005AFCD4;
  void v13[3] = &unk_10182D1B8;
  _DWORD v13[4] = a2;
  v13[5] = a1;
  void v13[6] = a3;
  _WORD v13[7] = a4;
  v13[8] = a5;
  [v12 sync:v13];
  if (v15) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005AC510( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state, char a19)
{
  if (a19) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005AC530(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101841410);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v15 = 1;
    uint64_t v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFitnessTrackingNotifierWatch::nanoLifestyleEnableFitnessDataCollectionSettingChanged",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841410);
    }
    uint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v17 = 0;
      __int16 v18 = 2082;
      char v19 = "";
      __int16 v20 = 2082;
      uint64_t v21 = "activity";
      __int16 v22 = 2050;
      uint64_t v23 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFitnessTrackingNotifierWatch::nanoLifestyleEnableFitnessDataCollectionSettingChanged, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v15 = 0;
  }

  id v12 = [*(id *)(a2 + 32) silo];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _OWORD v13[2] = sub_1005AFCDC;
  void v13[3] = &unk_10182D1B8;
  _DWORD v13[4] = a2;
  v13[5] = a1;
  void v13[6] = a3;
  _WORD v13[7] = a4;
  v13[8] = a5;
  [v12 sync:v13];
  if (v15) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005AC730( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state, char a19)
{
  if (a19) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005AC750(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101841410);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v15 = 1;
    uint64_t v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFitnessTrackingNotifierWatch::pairingStateChanged",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841410);
    }
    uint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v17 = 0;
      __int16 v18 = 2082;
      char v19 = "";
      __int16 v20 = 2082;
      uint64_t v21 = "activity";
      __int16 v22 = 2050;
      uint64_t v23 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFitnessTrackingNotifierWatch::pairingStateChanged, event:%{public, location:escap e_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v15 = 0;
  }

  id v12 = [*(id *)(a2 + 32) silo];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _OWORD v13[2] = sub_1005AFD18;
  void v13[3] = &unk_10182D1B8;
  _DWORD v13[4] = a2;
  v13[5] = a1;
  void v13[6] = a3;
  _WORD v13[7] = a4;
  v13[8] = a5;
  [v12 sync:v13];
  if (v15) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005AC950( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state, char a19)
{
  if (a19) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005AC970(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101841410);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    unint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFitnessTrackingNotifierWatch::onBatteryNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841410);
    }
    unint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      char v15 = "";
      __int16 v16 = 2082;
      int v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFitnessTrackingNotifierWatch::onBatteryNotification, event:%{public, location:esc ape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_1005ADA0C((_DWORD *)a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005ACB28( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

id sub_1005ACB48(_DWORD *a1)
{
  id result = +[CMFitnessShared isDeviceSatellitePaired](&OBJC_CLASS___CMFitnessShared, "isDeviceSatellitePaired");
  if ((_DWORD)result) {
    int v3 = 2;
  }
  else {
    int v3 = 1;
  }
  if (a1[38] != v3)
  {
    a1[38] = v3;
    if (qword_101934720 != -1) {
      dispatch_once(&qword_101934720, &stru_101841430);
    }
    uint64_t v4 = (os_log_s *)qword_101934728;
    if (os_log_type_enabled((os_log_t)qword_101934728, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = a1[38];
      *(_DWORD *)__int128 buf = 67240192;
      int v10 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "CM Satellite Pairing State,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934720 != -1) {
        dispatch_once(&qword_101934720, &stru_101841430);
      }
      int v6 = a1[38];
      v8[0] = 67240192;
      v8[1] = v6;
      uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934728,  0LL,  "CM Satellite Pairing State,%{public}d",  v8,  8);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFitnessTrackingNotifierWatch::updateSatellitePairingState()",  "%s\n",  v7);
    }

    return (id)sub_1005ACD28(a1);
  }

  return result;
}

uint64_t sub_1005ACD28(_DWORD *a1)
{
  else {
    int v2 = 1;
  }
  sub_1005AE000((uint64_t)a1, a1 + 35, v2, 1);
  else {
    int v3 = 1;
  }
  sub_1005AE000((uint64_t)a1, a1 + 36, v3, 2);
  else {
    int v4 = 1;
  }
  return sub_1005AE000((uint64_t)a1, a1 + 37, v4, 7);
}

uint64_t sub_1005ACDA4(void *a1)
{
  *a1 = off_1018412E0;
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver( DarwinNotifyCenter,  a1,  @"NanoLifestylePrivacyPreferencesChangedNotification",  0LL);
  int v3 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(v3, a1, @"NanoLifestyleSessionTrackerAppPreferencesChangedNotification", 0LL);
  int v4 = CFNotificationCenterGetDarwinNotifyCenter();
  int v5 = (const __CFString *)off_101938998[0]();
  CFNotificationCenterRemoveObserver(v4, a1, v5, 0LL);
  int v6 = CFNotificationCenterGetDarwinNotifyCenter();
  uint64_t v7 = (const __CFString *)off_1019389A0();
  CFNotificationCenterRemoveObserver(v6, a1, v7, 0LL);

  a1[16] = 0LL;
  uint64_t v8 = a1[37];
  a1[37] = 0LL;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  sub_1002F14C8(a1 + 20);
  return sub_10060A80C(a1);
}

void sub_1005ACE84(void *a1)
{
  uint64_t v1 = (void *)sub_1005ACDA4(a1);
  operator delete(v1);
}

BOOL sub_1005ACE98(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 109))
  {
    if (qword_101934720 != -1) {
      dispatch_once(&qword_101934720, &stru_101841430);
    }
    uint64_t v1 = (os_log_s *)qword_101934728;
    if (os_log_type_enabled((os_log_t)qword_101934728, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "#SystemState, Overriding device activation status check.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934720 != -1) {
        dispatch_once(&qword_101934720, &stru_101841430);
      }
      LOWORD(v9[0]) = 0;
      uint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934728,  0LL,  "#SystemState, Overriding device activation status check.",  v9,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLFitnessTrackingNotifierWatch::isDeviceActivated() const",  "%s\n",  v8);
    }

    return 1LL;
  }

  int v3 = *(void **)(a1 + 128);
  if (v3)
  {
    if ([v3 pairingID]) {
      return 1LL;
    }
    if (qword_101934720 != -1) {
      dispatch_once(&qword_101934720, &stru_101841430);
    }
    int v4 = (os_log_s *)qword_101934728;
    if (os_log_type_enabled((os_log_t)qword_101934728, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#SystemState, Unable to obtain pairing id, suspending activity tracking.",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934720 != -1) {
        dispatch_once(&qword_101934720, &stru_101841430);
      }
      LOWORD(v9[0]) = 0;
      int v5 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934728,  0LL,  "#SystemState, Unable to obtain pairing id, suspending activity tracking.",  v9,  2,  v9[0]);
LABEL_27:
      uint64_t v7 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLFitnessTrackingNotifierWatch::isDeviceActivated() const",  "%s\n",  v5);
      if (v7 != buf) {
        free(v7);
      }
      return 0LL;
    }
  }

  else
  {
    if (qword_101934720 != -1) {
      dispatch_once(&qword_101934720, &stru_101841430);
    }
    int v6 = (os_log_s *)qword_101934728;
    if (os_log_type_enabled((os_log_t)qword_101934728, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#SystemState, Unable to query pairing id, suspending activity tracking.",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934720 != -1) {
        dispatch_once(&qword_101934720, &stru_101841430);
      }
      LOWORD(v9[0]) = 0;
      int v5 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934728,  0LL,  "#SystemState, Unable to query pairing id, suspending activity tracking.",  v9,  2,  v9[0]);
      goto LABEL_27;
    }
  }

  return result;
}

BOOL sub_1005AD240()
{
  id v0 = (const __CFBoolean *)CFPreferencesCopyValue( @"EnableFitnessTracking",  @"com.apple.nanolifestyle.privacy",  @"mobile",  kCFPreferencesAnyHost);
  if (!v0)
  {
    if (qword_101934720 != -1) {
      dispatch_once(&qword_101934720, &stru_101841430);
    }
    int v6 = (os_log_s *)qword_101934728;
    if (os_log_type_enabled((os_log_t)qword_101934728, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "#SystemState, Failed to get fitness tracking state in Bridge->Motion&Fitness. It may not have been set yet. Assuming default.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934720 != -1) {
        dispatch_once(&qword_101934720, &stru_101841430);
      }
      v8[0] = 0;
      uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934728,  1LL,  "#SystemState, Failed to get fitness tracking state in Bridge->Motion&Fitness. It may not have been set yet. Assuming default.",  v8,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLFitnessTrackingNotifierWatch::isFitnessTrackingEnabled() const",  "%s\n",  v7);
    }

    return 1LL;
  }

  uint64_t v1 = v0;
  int Value = CFBooleanGetValue(v0);
  CFRelease(v1);
  if (Value) {
    return 1LL;
  }
  if (qword_101934720 != -1) {
    dispatch_once(&qword_101934720, &stru_101841430);
  }
  int v3 = (os_log_s *)qword_101934728;
  if (os_log_type_enabled((os_log_t)qword_101934728, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#SystemState, Fitness tracking is disabled, suspending activity tracking.",  buf,  2u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934720 != -1) {
      dispatch_once(&qword_101934720, &stru_101841430);
    }
    v8[0] = 0;
    int v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934728,  0LL,  "#SystemState, Fitness tracking is disabled, suspending activity tracking.",  v8,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLFitnessTrackingNotifierWatch::isFitnessTrackingEnabled() const",  "%s\n",  v5);
    return 0LL;
  }

  return result;
}

void sub_1005AD540(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 316);
  int v3 = sub_10060A358(a1);
  BYTE4(v12) = v3;
  *(_WORD *)((char *)&v12 + 5) = *(_WORD *)(a1 + 136);
  if (BYTE5(v12))
  {
    int v4 = sub_10060A358(a1);
    if ((_DWORD)v2 == 3) {
      int v5 = 0;
    }
    else {
      int v5 = v4;
    }
  }

  else
  {
    int v5 = 0;
  }

  HIBYTE(v12) = v5;
  if (qword_101934720 != -1) {
    dispatch_once(&qword_101934720, &stru_101841430);
  }
  int v6 = (os_log_s *)qword_101934728;
  if (os_log_type_enabled((os_log_t)qword_101934728, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(_DWORD *)(a1 + 316);
    *(_DWORD *)__int128 buf = 67240960;
    int v21 = v3;
    __int16 v22 = 1026;
    int v23 = BYTE5(v12);
    __int16 v24 = 1026;
    int v25 = v7;
    __int16 v26 = 1026;
    int v27 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#SystemState, Watch, Enabled, %{public}d, DeviceActivated, %{public}d, OnCharger, %{public}d, allowed, %{public}d",  buf,  0x1Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934720 != -1) {
      dispatch_once(&qword_101934720, &stru_101841430);
    }
    int v10 = *(_DWORD *)(a1 + 316);
    v13[0] = 67240960;
    v13[1] = v3;
    __int16 v14 = 1026;
    int v15 = BYTE5(v12);
    __int16 v16 = 1026;
    int v17 = v10;
    __int16 v18 = 1026;
    int v19 = v5;
    LODWORD(v12) = 26;
    char v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934728,  0LL,  "#SystemState, Watch, Enabled, %{public}d, DeviceActivated, %{public}d, OnCharger, %{public}d, allowed, %{public}d",  v13,  v12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLFitnessTrackingNotifierWatch::notifyClients()", "%s\n", v11);
  }

  *(_DWORD *)__int128 buf = 0;
  if (sub_100247620(a1, (int *)buf, 1LL))
  {
    *(_DWORD *)__int128 buf = 0;
    (*(void (**)(uint64_t, uint8_t *, char *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  buf,  (char *)&v12 + 4,  1LL,  0xFFFFFFFFLL,  0LL);
  }

  uint64_t v8 = objc_autoreleasePoolPush();
  unint64_t v9 = objc_alloc_init(&OBJC_CLASS___ALActivityLog);
  -[ALActivityLog setTimestamp:](v9, "setTimestamp:", CFAbsoluteTimeGetCurrent());
  -[ALActivityLog setFitnessTracking:]( v9,  "setFitnessTracking:",  objc_alloc_init(&OBJC_CLASS___ALCMFitnessTracking));
  -[ALCMFitnessTracking setFitnessTrackingEnabled:]( -[ALActivityLog fitnessTracking](v9, "fitnessTracking"),  "setFitnessTrackingEnabled:",  BYTE4(v12));
  -[ALCMFitnessTracking setPowerSource:](-[ALActivityLog fitnessTracking](v9, "fitnessTracking"), "setPowerSource:", v2);
  objc_msgSend( -[CLServiceVendor proxyForService:]( +[CLServiceVendor sharedInstance](CLServiceVendor, "sharedInstance"),  "proxyForService:",  @"CLActivityLogger"),  "logData:",  v9);
  objc_autoreleasePoolPop(v8);
}

id sub_1005AD848(_BYTE *a1)
{
  if (qword_101934720 != -1) {
    dispatch_once(&qword_101934720, &stru_101841430);
  }
  uint64_t v2 = (os_log_s *)qword_101934728;
  if (os_log_type_enabled((os_log_t)qword_101934728, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#SystemState, Pairing state changed", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934720 != -1) {
      dispatch_once(&qword_101934720, &stru_101841430);
    }
    v5[0] = 0;
    int v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934728,  0LL,  "#SystemState, Pairing state changed",  v5,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFitnessTrackingNotifierWatch::pairingStateChanged(CFNotificationCenterRef, CFStringRef, const void *, CFDictionaryRef)",  "%s\n",  v4);
  }

  a1[136] = (*(uint64_t (**)(_BYTE *))(*(void *)a1 + 208LL))(a1);
  a1[137] = sub_1005AC09C();
  (*(void (**)(_BYTE *))(*(void *)a1 + 224LL))(a1);
  return sub_1005ACB48(a1);
}

void sub_1005ADA0C(_DWORD *a1, uint64_t a2, int *a3, uint64_t a4)
{
  if (*a3 == 7)
  {
    int v5 = a1[83];
    int v6 = a1[79];
    if (v6 != *(_DWORD *)(a4 + 12) || v5 != 0)
    {
      if (v5) {
        int v8 = a1[83];
      }
      else {
        int v8 = *(_DWORD *)(a4 + 12);
      }
      a1[79] = v8;
      if (qword_101934720 != -1) {
        dispatch_once(&qword_101934720, &stru_101841430);
      }
      unint64_t v9 = (os_log_s *)qword_101934728;
      if (os_log_type_enabled((os_log_t)qword_101934728, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = a1[83];
        int v11 = a1[79];
        *(_DWORD *)__int128 buf = 67240448;
        int v27 = v10;
        __int16 v28 = 1026;
        int v29 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#SystemState, OverrideChargerType, %{public}d, NotifyChargerType, %{public}d",  buf,  0xEu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934720 != -1) {
          dispatch_once(&qword_101934720, &stru_101841430);
        }
        int v18 = a1[83];
        int v19 = a1[79];
        int v22 = 67240448;
        int v23 = v18;
        __int16 v24 = 1026;
        int v25 = v19;
        __int16 v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934728,  0LL,  "#SystemState, OverrideChargerType, %{public}d, NotifyChargerType, %{public}d",  &v22,  14);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFitnessTrackingNotifierWatch::onBatteryNotification(int, const CLDaemonStatus_Type::Notification &, con st CLDaemonStatus_Type::NotificationData &)",  "%s\n",  v20);
      }

      (*(void (**)(_DWORD *))(*(void *)a1 + 224LL))(a1);
      int v6 = a1[79];
    }

    if (v6 == 3)
    {
      if (qword_101934720 != -1) {
        dispatch_once(&qword_101934720, &stru_101841430);
      }
      uint64_t v12 = (os_log_s *)qword_101934728;
      if (os_log_type_enabled((os_log_t)qword_101934728, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "#SystemState, Device on-charger, suspending activity tracking.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934720 != -1) {
          dispatch_once(&qword_101934720, &stru_101841430);
        }
        LOWORD(v22) = 0;
        LODWORD(v21) = 2;
        int v13 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934728,  0LL,  "#SystemState, Device on-charger, suspending activity tracking.",  &v22,  v21);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFitnessTrackingNotifierWatch::onBatteryNotification(int, const CLDaemonStatus_Type::Notification &, con st CLDaemonStatus_Type::NotificationData &)",  "%s\n");
LABEL_33:
        if (v13 != buf) {
          free(v13);
        }
      }
    }
  }

  else
  {
    if (qword_101934720 != -1) {
      dispatch_once(&qword_101934720, &stru_101841430);
    }
    int v15 = (os_log_s *)qword_101934728;
    if (os_log_type_enabled((os_log_t)qword_101934728, OS_LOG_TYPE_ERROR))
    {
      int v16 = *a3;
      *(_DWORD *)__int128 buf = 67240192;
      int v27 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "#SystemState, Un-handled notification,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934720 != -1) {
        dispatch_once(&qword_101934720, &stru_101841430);
      }
      int v17 = *a3;
      int v22 = 67240192;
      int v23 = v17;
      int v13 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934728,  16LL,  "#SystemState, Un-handled notification,%{public}d",  &v22,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFitnessTrackingNotifierWatch::onBatteryNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemonStatus_Type::NotificationData &)",  "%s\n");
      goto LABEL_33;
    }
  }

id sub_1005ADE98(uint64_t a1)
{
  else {
    uint64_t v2 = 0LL;
  }
  return +[CMFitnessShared isWorkoutStartReminderEnabledWhenDeviceIsSatellitePaired:isInMoveTimeMode:withCurrentSetting:]( &OBJC_CLASS___CMFitnessShared,  "isWorkoutStartReminderEnabledWhenDeviceIsSatellitePaired:isInMoveTimeMode:withCurrentSetting:",  *(_DWORD *)(a1 + 152) == 2,  *(_DWORD *)(a1 + 116) == 2,  v2);
}

id sub_1005ADF18(uint64_t a1)
{
  else {
    uint64_t v2 = 0LL;
  }
  return +[CMFitnessShared isWorkoutEndReminderEnabledWhenDeviceIsInMoveTimeMode:withCurrentSetting:]( &OBJC_CLASS___CMFitnessShared,  "isWorkoutEndReminderEnabledWhenDeviceIsInMoveTimeMode:withCurrentSetting:",  *(_DWORD *)(a1 + 116) == 2,  v2);
}

id sub_1005ADF8C(uint64_t a1)
{
  else {
    uint64_t v2 = 0LL;
  }
  return +[CMFitnessShared isWorkoutResumeReminderEnabledWhenDeviceIsInMoveTimeMode:withCurrentSetting:]( &OBJC_CLASS___CMFitnessShared,  "isWorkoutResumeReminderEnabledWhenDeviceIsInMoveTimeMode:withCurrentSetting:",  *(_DWORD *)(a1 + 116) == 2,  v2);
}

uint64_t sub_1005AE000(uint64_t result, _DWORD *a2, int a3, int a4)
{
  int v9 = a4;
  if (*a2 != a3)
  {
    uint64_t v6 = result;
    *a2 = a3;
    v8[0] = a3 == 2;
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101841450);
    }
    int v7 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v11 = 0;
      __int16 v12 = 2082;
      int v13 = "";
      __int16 v14 = 1026;
      int v15 = a4;
      __int16 v16 = 1026;
      BOOL v17 = a3 == 2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Workout Alert Flag, notification:%{public}d, enabled:%{public}hhd}",  buf,  0x1Eu);
    }

    return (*(uint64_t (**)(uint64_t, int *, BOOL *, uint64_t, uint64_t, void))(*(void *)v6 + 152LL))( v6,  &v9,  v8,  1LL,  0xFFFFFFFFLL,  0LL);
  }

  return result;
}

uint64_t sub_1005AE148(_DWORD *a1)
{
  return sub_1005ACD28(a1);
}

uint64_t sub_1005AE16C()
{
  unsigned int v0 = sub_1002A6F64((uint64_t)v3, "AlwaysOnMotionSensorLogging", &v4);
  if (v4) {
    uint64_t v1 = v0;
  }
  else {
    uint64_t v1 = 0LL;
  }
  sub_1002F14C8(v3);
  return v1;
}

void sub_1005AE1F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005AE204(uint64_t a1, uint64_t a2)
{
  HIDWORD(v14) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        int v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)__int128 buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v14 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101841410);
      }
      int v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        int v11 = (void *)(a1 + 8);
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v20 = v11;
        __int16 v21 = 1026;
        int v22 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101841410);
        }
        __int16 v12 = (void *)(a1 + 8);
        int v15 = 136446466;
        __int16 v16 = v12;
        __int16 v17 = 1026;
        int v18 = a2;
        LODWORD(v14) = 18;
        int v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                        &v15,
                        v14);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::Notifica tionData>::removeClient(int) [Notification_T = CLFitnessTrackingNotifier_Type::Notification, NotificationData_ T = CLFitnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
      }
    }
  }

uint64_t sub_1005AE478(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_1019389A8);
}

uint64_t sub_1005AE48C(uint64_t a1, int a2, int *a3, char *a4)
{
  int v41 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        int v13 = (uint64_t *)v7;
      }
      else {
        int v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)uint64_t v42 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          __int16 v24 = (uint64_t *)v18;
        }
        else {
          __int16 v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }

      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          int v29 = (uint64_t *)v25;
        }
        else {
          int v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }

      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v40 = v26;
        uint64_t v34 = *(void *)(v26 + 56);
        char v35 = *a4;
        *(void *)__int128 buf = &v41;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v26 + 40), &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v35;
        *(_DWORD *)__int128 buf = 0;
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, _BYTE *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          uint64_t v36 = sub_1005B0C4C(buf);
          sub_1005B02D4((_BYTE *)a1, (uint64_t)v42, (uint64_t)&v40, v36);
        }

        if (v34) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        uint64_t v40 = a1 + 64;
        char v30 = byte_1019389A9;
        HIDWORD(v39) = v17;
        *(void *)__int128 buf = (char *)&v39 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 80) = v30;
        HIDWORD(v39) = *a3;
        *(void *)__int128 buf = (char *)&v39 + 4;
        __int128 v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v31 + 8);
        char v32 = *a4;
        HIDWORD(v39) = *a3;
        *(void *)__int128 buf = (char *)&v39 + 4;
        unint64_t v33 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)__int128 buf = &v41;
        *((_BYTE *)sub_1004EF3D4(v33 + 5, &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v32;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v21 == v19)
      {
        *(_DWORD *)__int128 buf = *a3;
        sub_10004A8FC((uint64_t **)(*(void *)v42 + 40LL), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101841410);
  }
  uint64_t v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    int v15 = (void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    __int16 v46 = 1026;
    int v47 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL v16 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841410);
    }
    float v37 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t v42 = 136446466;
    *(void *)&v42[4] = v37;
    __int16 v43 = 1026;
    int v44 = a2;
    LODWORD(v39) = 18;
    float v38 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                    v42,
                    v39);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::Notification Data>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLFitnes sTrackingNotifier_Type::Notification, NotificationData_T = CLFitnessTrackingNotifier_Type::NotificationData, Notif icationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v38);
    if (v38 != buf) {
      free(v38);
    }
    return 0LL;
  }

  return result;
}

BOOL sub_1005AE8E8(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v5;
    }
    else {
      int v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        uint64_t v21 = (uint64_t *)v15;
      }
      else {
        uint64_t v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841410);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136446466;
      int v29 = v11;
      __int16 v30 = 1026;
      int v31 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101841410);
      }
      int v22 = (void *)(a1 + 8);
      int v24 = 136446466;
      uint64_t v25 = v22;
      __int16 v26 = 1026;
      int v27 = a2;
      BOOL v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                      &v24,
                      18);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::Notificati onData>::clientRegistered(int, const Notification_T &) [Notification_T = CLFitnessTrackingNotifier_Type::Notific ation, NotificationData_T = CLFitnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, Registr ationInfo_T = char]",  "%s\n",  v23);
      return 0LL;
    }
  }

  return result;
}

BOOL sub_1005AEB68(char *a1, int a2, int *a3)
{
  HIDWORD(v33) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        int v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            int v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            int v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                uint64_t v25 = (uint64_t *)v20;
              }
              else {
                uint64_t v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                int v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v33 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101841410);
              }
              __int16 v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v27 = a1 + 8;
                if (a1[31] < 0) {
                  int v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v43 >= 0) {
                  BOOL v28 = __p;
                }
                else {
                  BOOL v28 = (void **)__p[0];
                }
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v35 = 2082;
                uint64_t v36 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v43 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101841410);
                }
                int v29 = a1 + 8;
                if (a1[31] < 0) {
                  int v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v37 >= 0) {
                  int v31 = buf;
                }
                else {
                  int v31 = *(_BYTE **)buf;
                }
                int v38 = 136446466;
                uint64_t v39 = v29;
                __int16 v40 = 2082;
                int v41 = v31;
                LODWORD(v33) = 22;
                char v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                                &v38,
                                v33);
                if (v37 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type:: NotificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLFitnessT rackingNotifier_Type::Notification, NotificationData_T = CLFitnessTrackingNotifier_Type::NotificationD ata, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v32);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_1005AEEF0(uint64_t a1, int *a2, int *a3)
{
  uint64_t v6 = operator new(0x20uLL);
  _DWORD v6[2] = 0LL;
  *uint64_t v6 = off_101841480;
  v6[1] = 0LL;
  int v7 = *a3;
  *((void *)&v14 + 1) = v6;
  *((_DWORD *)v6 + 6) = v7;
  *(void *)&__int128 v14 = v6 + 3;
  int v13 = *a2;
  int v15 = &v13;
  BOOL v8 = sub_10023347C((uint64_t **)(a1 + 56), &v13, (uint64_t)&unk_1012CF090, &v15);
  sub_10005F550((uint64_t)(v8 + 8), &v14);
  int v9 = (std::__shared_weak_count *)*((void *)&v14 + 1);
  if (*((void *)&v14 + 1))
  {
    BOOL v10 = (unint64_t *)(*((void *)&v14 + 1) + 8LL);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return 1LL;
}

void sub_1005AEFC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1005AEFD8(uint64_t a1, unsigned int *a2, _DWORD *a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    BOOL v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841410);
    }
    unint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      BOOL v12 = (void *)(a1 + 8);
      int v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)__int128 buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = "activity";
      __int16 v66 = 2082;
      float32x2_t v67 = v12;
      __int16 v68 = 2050;
      float32x2_t v69 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    __int128 v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      __int128 v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)float v70 = &v70[8];
      memset(&v70[8], 0, 24);
      uint64_t v71 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v70);
      int v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v69;
      if (v69)
      {
        p_shared_owners = (unint64_t *)&v69->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&buf[8], *(void **)&buf[16]);
      BOOL v24 = v71;
      if (v71)
      {
        uint64_t v25 = (unint64_t *)&v71->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v70, *(void **)&v70[8]);
    }

    if (a4)
    {
      int v27 = operator new(0x20uLL);
      _OWORD v27[2] = 0LL;
      *int v27 = off_101841480;
      v27[1] = 0LL;
      *((_DWORD *)v27 + 6) = *a3;
      *(void *)__int128 buf = v27 + 3;
      *(void *)&uint8_t buf[8] = v27;
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      BOOL v28 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        int v29 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    int v31 = sub_1005AFE80(a3);
    if (a5 == -1)
    {
      sub_1005AFF00((void *)a1, (int *)a2, v31);
    }

    else
    {
      uint64_t v32 = a1 + 88;
      uint64_t v33 = *(void *)(a1 + 88);
      if (!v33) {
        goto LABEL_48;
      }
      uint64_t v34 = a1 + 88;
      do
      {
        int v35 = *(_DWORD *)(v33 + 32);
        BOOL v36 = v35 < a5;
        if (v35 >= a5) {
          char v37 = (uint64_t *)v33;
        }
        else {
          char v37 = (uint64_t *)(v33 + 8);
        }
        if (!v36) {
          uint64_t v34 = v33;
        }
        uint64_t v33 = *v37;
      }

      while (*v37);
      if (v34 == v32 || *(_DWORD *)(v34 + 32) > a5) {
LABEL_48:
      }
        uint64_t v34 = a1 + 88;
      uint64_t v63 = v34;
      unint64_t v38 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v39 = *a2;
      __int16 v40 = (__n128 *)(a1 + 64);
      do
      {
        int v41 = *(_DWORD *)(v38 + 32);
        BOOL v42 = v41 < v39;
        if (v41 >= v39) {
          char v43 = (unint64_t *)v38;
        }
        else {
          char v43 = (unint64_t *)(v38 + 8);
        }
        if (!v42) {
          __int16 v40 = (__n128 *)v38;
        }
        unint64_t v38 = *v43;
      }

      while (*v43);
      if (v40 == v15 || v39 < (signed __int32)v40[2].n128_u32[0])
      {
LABEL_59:
        float v62 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101841410);
        }
        int v44 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v45 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v70, a1, a2);
          if (v70[23] >= 0) {
            __int16 v46 = v70;
          }
          else {
            __int16 v46 = *(_BYTE **)v70;
          }
          *(_DWORD *)__int128 buf = 136315650;
          *(void *)&uint8_t buf[4] = v45;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a5;
          *(_WORD *)&_BYTE buf[18] = 2080;
          *(void *)&buf[20] = v46;
          _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v70[23] & 0x80000000) != 0) {
            operator delete(*(void **)v70);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_101841410);
          }
          int v47 = (void *)(a1 + 8);
          uint64_t v48 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v61 >= 0) {
            uint64_t v49 = __p;
          }
          else {
            uint64_t v49 = (void **)__p[0];
          }
          *(_DWORD *)float v70 = 136315650;
          *(void *)&v70[4] = v47;
          *(_WORD *)&v70[12] = 1024;
          *(_DWORD *)&v70[14] = a5;
          *(_WORD *)&_BYTE v70[18] = 2080;
          *(void *)&v70[20] = v49;
          uint64_t v50 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v48,  2LL,  "%s; client %d has deregistered, not notifying %s",
                          v70,
                          28,
                          v59);
          if (v61 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::Notifi cationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Not ification_T = CLFitnessTrackingNotifier_Type::Notification, NotificationData_T = CLFitnessTrackingNotifier_T ype::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v50);
          if (v50 != buf) {
            free(v50);
          }
        }

        goto LABEL_83;
      }

      float v62 = v40;
      if (v34 == v32) {
        goto LABEL_60;
      }
      uint64_t v53 = v40[3].n128_i64[0];
      unint64_t v51 = v40 + 3;
      uint64_t v52 = (__n128 *)v53;
      if (!v53) {
        goto LABEL_60;
      }
      int v54 = *(_DWORD *)(v34 + 32);
      __int128 v55 = v51;
      do
      {
        int v56 = v52[1].n128_i32[3];
        BOOL v57 = v56 < v54;
        if (v56 >= v54) {
          float v58 = v52;
        }
        else {
          float v58 = (__n128 *)&v52->n128_i8[8];
        }
        if (!v57) {
          __int128 v55 = v52;
        }
        uint64_t v52 = (__n128 *)v58->n128_u64[0];
      }

      while (v58->n128_u64[0]);
      sub_1005B02D4((_BYTE *)a1, (uint64_t)&v63, (uint64_t)&v62, v31);
    }

void sub_1005AF610( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_1005AF65C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841410);
    }
    uint64_t v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      int v3 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v34 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101841410);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v29 = 136315138;
      unint64_t v30 = v4;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
                     (const char *)&v29);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::Notificati onData>::listClients() [Notification_T = CLFitnessTrackingNotifier_Type::Notification, NotificationData_T = CLFi tnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841410);
    }
    uint64_t v6 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      int v7 = (void *)(a1 + 8);
      uint64_t v8 = *(void *)(a1 + 96);
      *(_DWORD *)__int128 buf = 136315394;
      uint64_t v34 = v7;
      __int16 v35 = 2048;
      v36[0] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101841410);
      }
      uint64_t v25 = (void *)(a1 + 8);
      uint64_t v26 = *(void *)(a1 + 96);
      int v29 = 136315394;
      unint64_t v30 = v25;
      __int16 v31 = 2048;
      v32[0] = v26;
      int v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
                      (const char *)&v29,
                      22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::Notificati onData>::listClients() [Notification_T = CLFitnessTrackingNotifier_Type::Notification, NotificationData_T = CLFi tnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v27);
    }

    int v9 = *(void **)(a1 + 80);
    if (v9 != (void *)(a1 + 88))
    {
      BOOL v10 = (void *)(a1 + 8);
      do
      {
        unint64_t v11 = (void *)v9[5];
        if (v11 != v9 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_101841410);
            }
            BOOL v12 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              int v13 = (void *)(a1 + 8);
              int v14 = *((_DWORD *)v9 + 8);
              int v15 = *((_DWORD *)v11 + 7);
              *(_DWORD *)__int128 buf = 136315650;
              uint64_t v34 = v13;
              __int16 v35 = 1024;
              LODWORD(v36[0]) = v14;
              WORD2(v36[0]) = 1024;
              *(_DWORD *)((char *)v36 + 6) = v15;
              _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101841410);
              }
              BOOL v19 = (void *)(a1 + 8);
              int v20 = *((_DWORD *)v9 + 8);
              int v21 = *((_DWORD *)v11 + 7);
              int v29 = 136315650;
              unint64_t v30 = v19;
              __int16 v31 = 1024;
              LODWORD(v32[0]) = v20;
              WORD2(v32[0]) = 1024;
              *(_DWORD *)((char *)v32 + 6) = v21;
              int v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                              (const char *)&v29,
                              24,
                              v28);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::No tificationData>::listClients() [Notification_T = CLFitnessTrackingNotifier_Type::Notification, Notificat ionData_T = CLFitnessTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v22);
            }

            signed __int32 v16 = (void *)v11[1];
            if (v16)
            {
              do
              {
                int v17 = v16;
                signed __int32 v16 = (void *)*v16;
              }

              while (v16);
            }

            else
            {
              do
              {
                int v17 = (void *)v11[2];
                BOOL v18 = *v17 == (void)v11;
                unint64_t v11 = v17;
              }

              while (!v18);
            }

            unint64_t v11 = v17;
          }

          while (v17 != v9 + 6);
        }

        unint64_t v23 = (void *)v9[1];
        if (v23)
        {
          do
          {
            BOOL v24 = v23;
            unint64_t v23 = (void *)*v23;
          }

          while (v23);
        }

        else
        {
          do
          {
            BOOL v24 = (void *)v9[2];
            BOOL v18 = *v24 == (void)v9;
            int v9 = v24;
          }

          while (!v18);
        }

        int v9 = v24;
      }

      while (v24 != (void *)(a1 + 88));
    }
  }

Class sub_1005AFC04()
{
  if (qword_101996EB0 != -1) {
    dispatch_once(&qword_101996EB0, &stru_1018413F0);
  }
  Class result = objc_getClass("NRPairedDeviceRegistry");
  qword_101996EA8 = (uint64_t)result;
  off_101938990[0] = sub_1005AFC60;
  return result;
}

uint64_t sub_1005AFC60()
{
  return qword_101996EA8;
}

void sub_1005AFC6C(id a1)
{
  qword_101996EB8 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/NanoRegistry.framework/NanoRegistry", 2);
}

uint64_t sub_1005AFC94(uint64_t a1)
{
  return sub_10060AC94(*(_BYTE **)(a1 + 32));
}

void sub_1005AFCA8(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_1005AFCD4(uint64_t a1)
{
  return sub_1005ACD28(*(_DWORD **)(a1 + 32));
}

uint64_t sub_1005AFCDC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  else {
    int v2 = 1;
  }
  return sub_10060AB54(v1, v2);
}

id sub_1005AFD18(uint64_t a1)
{
  return sub_1005AD848(*(_BYTE **)(a1 + 32));
}

uint64_t sub_1005AFD20()
{
  if (qword_101996EB0 != -1) {
    dispatch_once(&qword_101996EB0, &stru_1018413F0);
  }
  unsigned int v0 = (uint64_t *)dlsym((void *)qword_101996EB8, "NRPairedDeviceRegistryDeviceDidPairDarwinNotification");
  if (v0)
  {
    uint64_t result = *v0;
    qword_101996EC0 = result;
  }

  else
  {
    uint64_t result = qword_101996EC0;
  }

  off_101938998[0] = sub_1005AFD98;
  return result;
}

uint64_t sub_1005AFD98()
{
  return qword_101996EC0;
}

uint64_t sub_1005AFDA4()
{
  if (qword_101996EB0 != -1) {
    dispatch_once(&qword_101996EB0, &stru_1018413F0);
  }
  unsigned int v0 = (uint64_t *)dlsym((void *)qword_101996EB8, "NRPairedDeviceRegistryDeviceDidUnpairDarwinNotification");
  if (v0)
  {
    uint64_t result = *v0;
    qword_101996EC8 = result;
  }

  else
  {
    uint64_t result = qword_101996EC8;
  }

  off_1019389A0 = sub_1005AFE1C;
  return result;
}

uint64_t sub_1005AFE1C()
{
  return qword_101996EC8;
}

void sub_1005AFE28(id a1)
{
  qword_101934728 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Fitness");
}

void sub_1005AFE54(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

CLCppContainer *sub_1005AFE80(_DWORD *a1)
{
  int v2 = operator new(4uLL);
  *int v2 = *a1;
  uint64_t v4 = _NSConcreteStackBlock;
  uint64_t v5 = 3221225472LL;
  uint64_t v6 = sub_1005B03F0;
  int v7 = &unk_10181D3D0;
  uint64_t v8 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_1005AFF00(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    uint64_t v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      int v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          BOOL v12 = (uint64_t *)v4;
        }
        else {
          BOOL v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          int v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        uint64_t v50 = v9;
        id v13 = sub_1005B0400(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        int v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          int v15 = a1 + 11;
          signed __int32 v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            BOOL v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                int v22 = (uint64_t *)v17;
              }
              else {
                int v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                BOOL v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              uint64_t v49 = v19;
              sub_1005B02D4(a1, (uint64_t)&v49, (uint64_t)&v50, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              int v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  uint64_t v32 = (uint64_t *)v27;
                }
                else {
                  uint64_t v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  int v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              uint64_t v50 = v29;
              uint64_t v34 = v29[6];
              int v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                __int16 v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    int v39 = (uint64_t *)v36;
                  }
                  else {
                    int v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    __int16 v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      BOOL v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      BOOL v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      int v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  char v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      int v14 = v43;
                      char v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      int v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      __int16 v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              uint64_t v49 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101841410);
              }
              BOOL v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                uint64_t v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)__int128 buf = 136446466;
                int v56 = v25;
                __int16 v57 = 1026;
                int v58 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101841410);
                }
                uint64_t v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v51 = 136446466;
                uint64_t v52 = v45;
                __int16 v53 = 1026;
                int v54 = v46;
                LODWORD(v4_Block_object_dispose(va, 8) = 18;
                int v47 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                                &v51,
                                v48);
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLFitnessTrackingNotifier_Type::Notification, CLFitnessTrackingNotifier_Type::Notifica tionData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLFitness TrackingNotifier_Type::Notification, NotificationData_T = CLFitnessTrackingNotifier_Type::Notification Data, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
              }
            }
          }

          while (v14 != v50 + 6);
        }
      }
    }
  }

_BYTE *sub_1005B02D4(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    int v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(vsub_100210A00(v2 + 13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_1005B0400(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40LL);
    int v14 = (int *)(*(void *)a2 + 32LL);
    BOOL v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    uint64_t result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

void sub_1005B03B0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101841480;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005B03C4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101841480;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_1005B03F0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

id sub_1005B0400(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppEncodableDataContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_1005B0478(a1);
  }
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v4) & 1) != 0) {
    return sub_1005B0800(a1);
  }
  else {
    return 0LL;
  }
}

id sub_1005B0478(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return sub_1005B0BAC((uint64_t)&v8 + 7, a1);
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018414C0);
    }
    int v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x800000010130A402LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018414C0);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(v_Block_object_dispose(va, 8) = 32;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018414C0);
    }
    uint64_t v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x800000010130A402LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018414C0);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(v_Block_object_dispose(va, 8) = 32;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  int v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLFitnessTrackingNotifier_Type::NotificationData , Callback = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:241:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_1005B0800(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018414C0);
    }
    int v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x800000010130A402LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018414C0);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018414C0);
    }
    uint64_t v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x800000010130A402LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018414C0);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  int v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLFitnessTrackingNotifier_Type::NotificationData , Callback = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:250:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_1005B0BAC(uint64_t a1, void *a2)
{
  if (![a2 cppObjectPtr]
    && objc_msgSend(objc_msgSend(a2, "compatibilityInfo"), "isEqual:", &off_1018D3578))
  {
    if (objc_msgSend(objc_msgSend(a2, "serialized"), "length") != (id)4) {
      sub_10123F6BC();
    }
    objc_msgSend(a2, "setCppObjectPtr:", objc_msgSend(objc_msgSend(a2, "serialized"), "bytes"));
  }

  return [a2 cppObjectPtr];
}

void sub_1005B0C20(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

CLCppContainer *sub_1005B0C4C(_DWORD *a1)
{
  id v2 = operator new(4uLL);
  *id v2 = *a1;
  uint64_t v4 = _NSConcreteStackBlock;
  uint64_t v5 = 3221225472LL;
  uint64_t v6 = sub_1005B0CCC;
  int v7 = &unk_10181D3D0;
  uint64_t v8 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_1005B0CCC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t sub_1005B0F70(void *a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    uint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      if (v5++ >= 9)
      {
        LODWORD(v6) = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      LODWORD(v6) = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      break;
    }
    if ((v6 & 0x7FFF8) == 8)
    {
      uint64_t v12 = objc_alloc_init(&OBJC_CLASS___TRANSITPbLocationFingerprint);
      [a1 addLocationFingerprint:v12];

      PBReaderRecallMark(a2, v14);
    }

    else
    {
      uint64_t result = PBReaderSkipValueWithTag(a2);
      if (!(_DWORD)result) {
        return result;
      }
    }
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

BOOL sub_1005B1544(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  unsigned int v7 = *(unsigned __int16 *)(a1 + 6);
  if (v7 >= 0x100)
  {
    double v8 = *(double *)(a2 + 48);
    *(double *)a4 = v8;
    sub_1005B1790(a1, (uint64_t)v10, v8);
    *(_DWORD *)(a4 + _Block_object_dispose(va, 8) = sub_100A3E530(a1 + 3256, v10);
    *(_BYTE *)(a4 + 12) = sub_100A3EC98((uint64_t)v10);
  }

  return v7 > 0xFF;
}

float sub_1005B15C0(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  float v6 = sub_100833470((float *)a2);
  float v8 = v7;
  float v10 = v9;
  uint64_t v29 = *(void *)(a2 + 16);
  float v30 = *(float *)(a2 + 24);
  sub_1008335D0((float *)a2, v25);
  float v26 = sub_100DEA49C((uint64_t)v25);
  float v27 = v11;
  float v28 = v12;
  uint64_t v13 = v29;
  float v14 = v30;
  float v15 = sub_1005B1918((float *)a1, (float *)a2);
  uint64_t v16 = 0LL;
  float v17 = 0.0;
  do
  {
    float v17 = v17 + (float)(*(float *)((char *)&v29 + v16) * *(float *)((char *)&v29 + v16));
    v16 += 4LL;
  }

  while (v16 != 12);
  float v18 = sqrtf(v17);
  float v19 = -v6;
  if (*a3 == a3[1]) {
    float v19 = v6;
  }
  float v24 = v19;
  float v20 = (float)((float)(v8 * *((float *)&v13 + 1)) + (float)(v6 * *(float *)&v13)) + (float)(v10 * v14);
  sub_10040B364((unsigned __int16 *)(a1 + 4), (uint64_t)&v26);
  float v21 = v27;
  *(float *)(a1 + 308_Block_object_dispose(va, 8) = v26 + *(float *)(a1 + 3088);
  ++*(void *)(a1 + 3096);
  *(float *)(a1 + 3104) = v21 + *(float *)(a1 + 3104);
  ++*(void *)(a1 + 3112);
  *(float *)(a1 + 3120) = v28 + *(float *)(a1 + 3120);
  ++*(void *)(a1 + 3128);
  *(float *)(a1 + 3136) = v18 + *(float *)(a1 + 3136);
  ++*(void *)(a1 + 3144);
  *(float *)(a1 + 316_Block_object_dispose(va, 8) = fabsf(v15) + *(float *)(a1 + 3168);
  ++*(void *)(a1 + 3176);
  float v22 = fabsf(v20) + *(float *)(a1 + 3152);
  ++*(void *)(a1 + 3160);
  *(float *)(a1 + 3152) = v22;
  sub_1005B19F8(a1 + 3200, v15, -v20);
  float result = v24 + *(float *)(a1 + 3184);
  *(float *)(a1 + 3184) = result;
  ++*(void *)(a1 + 3192);
  return result;
}

void sub_1005B1790(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  *(double *)a2 = a3;
  unsigned int v5 = (unsigned __int16 *)(a1 + 4);
  sub_1005B1BD4();
  unint64_t v23 = __PAIR64__(v7, v6);
  int v24 = v8;
  float v9 = sub_1005B1AA8(v5, (float32x2_t *)&v23, (uint64_t)v26);
  uint64_t v11 = 0LL;
  *(float *)uint64_t v25 = v9;
  v25[1] = v12;
  *(float *)&_OWORD v25[2] = v10;
  float v13 = 0.0;
  do
  {
    float v14 = *(float *)&v25[v11];
    if (v14 < 0.0) {
      float v14 = -v14;
    }
    float v13 = v13 + v14;
    ++v11;
  }

  while (v11 != 3);
  *(float *)(a2 + 24) = (float)(1.0 - (float)(fabsf(v10) / v13)) * 100.0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 308_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 3096) = 0LL;
  *(_DWORD *)(a1 + 3104) = 0;
  *(void *)(a1 + 3sub_10004AD90(v15 - 112) = 0LL;
  *(_DWORD *)(a1 + 3120) = 0;
  *(void *)(a1 + 312_Block_object_dispose(va, 8) = 0LL;
  unint64_t v15 = *(void *)(a1 + 3144);
  float v16 = 0.0;
  float v17 = 0.0;
  if (v15) {
    float v17 = *(float *)(a1 + 3136) / (float)v15;
  }
  *(float *)(a2 + _Block_object_dispose(va, 8) = v17;
  *(_DWORD *)(a1 + 3136) = 0;
  *(void *)(a1 + 3144) = 0LL;
  unint64_t v18 = *(void *)(a1 + 3176);
  if (v18) {
    float v16 = *(float *)(a1 + 3168) / (float)v18;
  }
  *(float *)(a2 + 16) = v16;
  *(_DWORD *)(a1 + 316_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 3176) = 0LL;
  float v19 = 0.0;
  float v20 = 0.0;
  unint64_t v21 = *(void *)(a1 + 3160);
  if (v21) {
    float v20 = *(float *)(a1 + 3152) / (float)v21;
  }
  *(float *)(a2 + 12) = v20;
  *(_DWORD *)(a1 + 3152) = 0;
  *(void *)(a1 + 3160) = 0LL;
  *(float *)(a2 + 20) = fabsf(sub_1005B1C24(a1 + 3200));
  *(void *)(a1 + 324_Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(a1 + 3200) = 0u;
  *(_OWORD *)(a1 + 3216) = 0u;
  *(_OWORD *)(a1 + 322_Block_object_dispose(va, 8) = 0u;
  unint64_t v22 = *(void *)(a1 + 3192);
  if (v22) {
    float v19 = *(float *)(a1 + 3184) / (float)v22;
  }
  *(float *)(a2 + 2_Block_object_dispose(va, 8) = v19;
  *(_DWORD *)(a1 + 3184) = 0;
  *(void *)(a1 + 3192) = 0LL;
}

float sub_1005B1918(float *a1, float *a2)
{
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)&qword_101996EE0);
  if ((v3 & 1) == 0)
  {
    float v16 = a2;
    int v15 = __cxa_guard_acquire(&qword_101996EE0);
    a2 = v16;
    if (v15)
    {
      qword_101996ED0 = 1065353216LL;
      dword_101996ED8 = 0;
      __cxa_guard_release(&qword_101996EE0);
      a2 = v16;
    }
  }

  float v5 = a2[8];
  float v4 = a2[9];
  float v6 = a2[7];
  float v7 = (float)(v5 * *(float *)&dword_101996ED8) - (float)(v4 * *((float *)&qword_101996ED0 + 1));
  float v8 = (float)(v4 * *(float *)&qword_101996ED0) - (float)(v6 * *(float *)&dword_101996ED8);
  float v9 = (float)(v6 * *((float *)&qword_101996ED0 + 1)) - (float)(v5 * *(float *)&qword_101996ED0);
  float v10 = sub_100833470(a2);
  float v13 = -(float)((float)((float)(v8 * v11) + (float)(v10 * v7)) + (float)(v12 * v9));
  float result = v13 - *a1;
  *a1 = v13;
  return result;
}

float sub_1005B19F8(uint64_t a1, float a2, float a3)
{
  float v3 = *(float *)(a1 + 8);
  float v4 = a2 - v3;
  uint64_t v5 = *(void *)a1 + 1LL;
  float v6 = v3 + (float)((float)(a2 - v3) / (float)(unint64_t)v5);
  float v7 = *(float *)(a1 + 12) + (float)(v4 * (float)(a2 - v6));
  float v8 = *(float *)(a1 + 24);
  float v9 = a3 - v8;
  uint64_t v10 = *(void *)(a1 + 16) + 1LL;
  float v11 = v8 + (float)((float)(a3 - v8) / (float)(unint64_t)v10);
  float v12 = *(float *)(a1 + 28) + (float)(v9 * (float)(a3 - v11));
  *(void *)a1 = v5;
  *(float *)(a1 + _Block_object_dispose(va, 8) = v6;
  *(float *)(a1 + 12) = v7;
  *(void *)(a1 + 16) = v10;
  *(float *)(a1 + 24) = v11;
  *(float *)(a1 + 2_Block_object_dispose(va, 8) = v12;
  uint64_t v13 = *(void *)(a1 + 48) + 1LL;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v13;
  float v14 = *(float *)(a1 + 32);
  float v15 = *(float *)(a1 + 36);
  float v16 = (float)(a2 - v14) / (float)(unint64_t)v13;
  float v17 = (float)(a3 - v15) / (float)(unint64_t)v13;
  *(float *)(a1 + 32) = v14 + v16;
  *(float *)(a1 + 36) = v15 + v17;
  float result = *(float *)(a1 + 40)
  *(float *)(a1 + 40) = result;
  return result;
}

float sub_1005B1AA8(unsigned __int16 *a1, float32x2_t *a2, uint64_t a3)
{
  int v16 = 0;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  if (a1[1])
  {
    unint64_t v6 = 0LL;
    do
    {
      float v7 = (float32x2_t *)sub_10040B624(a1, v6);
      float v8 = v7[1].f32[0] - a2[1].f32[0];
      float v17 = (_DWORD *)vsub_f32(*v7, *a2);
      *(float *)&uint64_t v18 = v8;
      sub_1005AAE28((uint64_t)&v17, (uint64_t)v19);
      for (unint64_t i = 0LL; i != 9; ++i)
        *((float *)&v14 + i) = sub_1005AAEAC((uint64_t)v19, i) + *((float *)&v14 + i);
      ++v6;
    }

    while (v6 < a1[1]);
  }

  v19[0] = v14;
  v19[1] = v15;
  int v20 = v16;
  sub_1005AB084((uint64_t)v19, a3);
  v21[0] = v10;
  v21[1] = v11;
  _DWORD v21[2] = v12;
  float v17 = v21;
  uint64_t v18 = a3;
  sub_1005AB644((uint64_t *)&v17, 0LL, 1uLL);
  sub_1005AB644((uint64_t *)&v17, 0LL, 2uLL);
  sub_1005AB644((uint64_t *)&v17, 1uLL, 2uLL);
  return *(float *)v21;
}

  ;
}

float sub_1005B1C24(uint64_t a1)
{
  float v1 = 0.0;
  float v2 = 0.0;
  if (*(void *)a1 >= 2uLL) {
    float v2 = *(float *)(a1 + 12) / (float)(unint64_t)(*(void *)a1 - 1LL);
  }
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3 >= 2) {
    float v1 = *(float *)(a1 + 28) / (float)(v3 - 1);
  }
  float v4 = v2 * v1;
  float result = 0.0;
  if (v4 > 0.0)
  {
    unint64_t v6 = *(void *)(a1 + 48);
    if (v6 >= 2) {
      float result = (float)((float)v6 / (float)((float)v6 + -1.0)) * *(float *)(a1 + 40);
    }
    return result / sqrtf(v4);
  }

  return result;
}

void *sub_1005B1CA4(void *a1)
{
  *a1 = 0LL;
  dispatch_queue_t v2 = dispatch_queue_create("com.apple.CoreMotion.CLPressureBiasProxy", 0LL);
  a1[2] = 0LL;
  a1[3] = 0LL;
  a1[1] = v2;
  return a1;
}

uint64_t sub_1005B1CE0(uint64_t a1)
{
  dispatch_queue_t v2 = *(dispatch_object_s **)(a1 + 16);
  if (v2) {
    dispatch_release(v2);
  }
  unint64_t v3 = *(const void **)(a1 + 24);
  if (v3) {
    _Block_release(v3);
  }
  sub_1005B1FE8((CLConnectionClient **)a1, 0LL);
  return a1;
}

void sub_1005B1D34(uint64_t a1)
{
  float v1 = *(dispatch_queue_s **)(a1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1005B1D8C;
  block[3] = &unk_10181D3D0;
  block[4] = a1;
  dispatch_sync(v1, block);
}

void sub_1005B1D8C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(void *)v1)
  {
    dispatch_queue_t v2 = (CLConnectionClient *)operator new(0x38uLL);
    sub_1010DDBC0(v20, "com.apple.locationd.registration");
    CLConnectionClient::CLConnectionClient(v2, v20, *(void *)(v1 + 8));
    sub_1005B1FE8((CLConnectionClient **)v1, v2);
    if (v21 < 0) {
      operator delete(v20[0]);
    }
    unint64_t v3 = *(CLConnectionClient **)v1;
    sub_1010DDBC0(&__p, "kCLConnectionMessagePressureBias");
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472LL;
    void v16[2] = sub_1005B2014;
    float v16[3] = &unk_10182B3E0;
    _OWORD v16[4] = v1;
    CLConnectionClient::setHandlerForMessage(v3, &__p, v16);
    if (v19 < 0) {
      operator delete(__p);
    }
    CLConnectionClient::start(*(CLConnectionClient **)v1);
    unint64_t v22 = @"kCLConnectionMessageSubscribeKey";
    unint64_t v23 = &__kCFBooleanTrue;
    __int128 v15 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v23,  &v22,  1LL);
    sub_1005B23A8("kCLConnectionMessagePressureBias", &v15, &__p);
    float v4 = *(CLConnectionClient **)v1;
    uint64_t v13 = __p;
    __int128 v14 = v18;
    if (v18)
    {
      p_shared_owners = (unint64_t *)&v18->__shared_owners_;
      do
        unint64_t v6 = __ldxr(p_shared_owners);
      while (__stxr(v6 + 1, p_shared_owners));
    }

    CLConnectionClient::sendMessage(v4, &v13, 1LL);
    float v7 = v14;
    if (v14)
    {
      float v8 = (unint64_t *)&v14->__shared_owners_;
      do
        unint64_t v9 = __ldaxr(v8);
      while (__stlxr(v9 - 1, v8));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }

    int v10 = v18;
    if (v18)
    {
      int v11 = (unint64_t *)&v18->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }

void sub_1005B1F88( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
}

void sub_1005B1FE8(CLConnectionClient **a1, CLConnectionClient *a2)
{
  unint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    CLConnectionClient::~CLConnectionClient(v3);
    operator delete(v4);
  }

uint64_t sub_1005B2014(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t Dictionary = (const __CFDictionary *)CLConnectionMessage::getDictionary(*a2);
  sub_1002A5550((int)v12, Dictionary);
  if (*(void *)(v2 + 16)
    && *(void *)(v2 + 24)
    && !sub_1002AF200((uint64_t)v12)
    && sub_1009AF300(v11, (uint64_t)v12))
  {
    float v4 = *(dispatch_queue_s **)(v2 + 16);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_1005B2254;
    block[3] = &unk_1018414E0;
    block[4] = v2;
    v10[0] = *(_OWORD *)v11;
    *(_OWORD *)((char *)v10 + sub_100210A00(v2 + 13) = *(_OWORD *)&v11[13];
    dispatch_async(v4, block);
  }

  else
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101841528);
    }
    uint64_t v5 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Bad pressure bias from daemon.", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101841528);
      }
      __int16 v8 = 0;
      float v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  16LL,  "Bad pressure bias from daemon.",  &v8,  2);
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLPressureBiasProxy::start()_block_invoke", "%s\n", v7);
    }
  }

  return sub_1002A5590(v12);
}

void sub_1005B2234( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

uint64_t sub_1005B2254(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(*(void *)(*(void *)(a1 + 32) + 24LL) + 16LL))( *(void *)(*(void *)(a1 + 32) + 24LL),  a1 + 40);
}

void sub_1005B226C(uint64_t a1)
{
  uint64_t v1 = *(dispatch_queue_s **)(a1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1005B22C4;
  block[3] = &unk_10181D3D0;
  block[4] = a1;
  dispatch_sync(v1, block);
}

void sub_1005B22C4(uint64_t a1)
{
}

void sub_1005B22D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(dispatch_queue_s **)(a1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1005B232C;
  block[3] = &unk_101841508;
  void block[5] = a3;
  block[6] = a1;
  block[4] = a2;
  dispatch_sync(v3, block);
}

void sub_1005B232C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(const void **)(v2 + 24);
  if (v3) {
    _Block_release(v3);
  }
  *(void *)(v2 + 24) = _Block_copy(*(const void **)(a1 + 40));
  float v4 = *(dispatch_object_s **)(v2 + 16);
  if (v4) {
    dispatch_release(v4);
  }
  *(void *)(v2 + 16) = *(void *)(a1 + 32);
  dispatch_retain(*(dispatch_object_t *)(a1 + 32));
}

void sub_1005B237C(id a1)
{
  qword_1019345B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pressure");
}

void *sub_1005B23A8@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  unint64_t v6 = operator new(0x70uLL);
  float result = sub_100215340(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1005B23F4(_Unwind_Exception *a1)
{
}

uint64_t sub_1005B2408(uint64_t a1, uint64_t *a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(a1 + 16) = xmmword_10130A468;
  *(_OWORD *)(a1 + 32) = unk_10130A478;
  *(_OWORD *)(a1 + 80) = xmmword_10130A440;
  float v4 = (uint64_t *)(a1 + 80);
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = xmmword_10130A488;
  *(void *)(a1 + 96) = 0x415BAF8000000000LL;
  uint64_t v5 = (uint64_t *)(a1 + 96);
  *(_OWORD *)(a1 + 60) = *(__int128 *)((char *)&xmmword_10130A488 + 12);
  *(_OWORD *)(a1 + 104) = xmmword_10130A450;
  unint64_t v6 = (int *)(a1 + 104);
  uint64_t v7 = sub_1006E27E8();
  sub_100413284(v7, buf);
  sub_1002A82BC(*(uint64_t *)buf, "VO2MaxAlertBlackoutDuration", v4);
  __int16 v8 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    unint64_t v9 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  uint64_t v11 = sub_1006E27E8();
  sub_100413284(v11, buf);
  uint64_t v52 = (uint64_t *)(a1 + 88);
  sub_1002A82BC(*(uint64_t *)buf, "VO2MaxRepeatAlertWindow", (void *)(a1 + 88));
  unint64_t v12 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    uint64_t v13 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  uint64_t v15 = sub_1006E27E8();
  sub_100413284(v15, buf);
  sub_1002A82BC(*(uint64_t *)buf, "VO2MaxAlertHistoricalEstimateWindow", v5);
  int v16 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    float v17 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  uint64_t v19 = sub_1006E27E8();
  sub_100413284(v19, buf);
  sub_1002A7CB0(*(uint64_t *)buf, "VO2MaxAlertMaxHistoricalEstimates", v6);
  int v20 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    char v21 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  uint64_t v23 = sub_1006E27E8();
  sub_100413284(v23, buf);
  int v24 = (int *)(a1 + 108);
  sub_1002A7CB0(*(uint64_t *)buf, "VO2MaxAlertMinDaysWithEstimate", (_DWORD *)(a1 + 108));
  uint64_t v25 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    float v26 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  uint64_t v28 = sub_1006E27E8();
  sub_100413284(v28, buf);
  sub_1002A7CB0(*(uint64_t *)buf, "VO2MaxAlertMinWorkoutsContrToEstimate", (_DWORD *)(a1 + 112));
  uint64_t v29 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    float v30 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v31 = __ldaxr(v30);
    while (__stlxr(v31 - 1, v30));
    if (!v31)
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
  }

  uint64_t v32 = sub_1006E27E8();
  sub_100413284(v32, buf);
  uint64_t v33 = (int *)(a1 + 116);
  sub_1002A7CB0(*(uint64_t *)buf, "VO2MaxAlertMinEstimatesSinceAlgChange", (_DWORD *)(a1 + 116));
  uint64_t v34 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    __int16 v35 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101841548);
  }
  int v37 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v38 = *v4;
    uint64_t v39 = *v52;
    uint64_t v40 = *v5;
    int v41 = *v6;
    int v42 = *v24;
    int v43 = *v33;
    *(_DWORD *)__int128 buf = 134284801;
    *(void *)&uint8_t buf[4] = v38;
    *(_WORD *)&_BYTE buf[12] = 2049;
    *(void *)&buf[14] = v39;
    __int16 v66 = 2049;
    uint64_t v67 = v40;
    __int16 v68 = 1025;
    int v69 = v41;
    __int16 v70 = 1025;
    int v71 = v42;
    __int16 v72 = 1025;
    int v73 = v43;
    _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEBUG,  "VO2MaxAlert,fAlertBlackoutDuration,%{private}.3f,fRepeatAlertWindow,%{private}.3f,fHistoricalEstimateWindow,%{priv ate}.3f,fMaxHistoricalEstimatesForAlert,%{private}d,fMinDaysWithEstimate,%{private}d,fMinEstimatesSinceAlgChange,%{private}d",  buf,  0x32u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101841548);
    }
    uint64_t v45 = *v4;
    uint64_t v46 = *v52;
    uint64_t v47 = *v5;
    int v48 = *v6;
    int v49 = *v24;
    int v50 = *v33;
    int v53 = 134284801;
    uint64_t v54 = v45;
    __int16 v55 = 2049;
    uint64_t v56 = v46;
    __int16 v57 = 2049;
    uint64_t v58 = v47;
    __int16 v59 = 1025;
    int v60 = v48;
    __int16 v61 = 1025;
    int v62 = v49;
    __int16 v63 = 1025;
    int v64 = v50;
    int v51 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "VO2MaxAlert,fAlertBlackoutDuration,%{private}.3f,fRepeatAlertWindow,%{private}.3f,fHistoricalEstimat eWindow,%{private}.3f,fMaxHistoricalEstimatesForAlert,%{private}d,fMinDaysWithEstimate,%{private}d,f MinEstimatesSinceAlgChange,%{private}d",  &v53,  50);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLVO2MaxAlertEvaluator::CLVO2MaxAlertEvaluator(std::shared_ptr<CLVO2MaxAlertRecorderDb>)",  "%s\n",  v51);
    if (v51 != buf) {
      free(v51);
    }
  }

  sub_1000F2F30((void *)a1, a2);
  return a1;
}

void sub_1005B2950(_Unwind_Exception *a1)
{
}

void sub_1005B29B0(_OWORD *a1, __int128 *a2)
{
  __int128 v3 = *a2;
  __int128 v4 = a2[1];
  __int128 v5 = a2[2];
  *(_OWORD *)((char *)a1 + 60) = *(__int128 *)((char *)a2 + 44);
  a1[2] = v4;
  a1[3] = v5;
  a1[1] = v3;
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101841548);
  }
  unint64_t v6 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
  {
    double v7 = *((float *)a2 + 5);
    int v8 = *(_DWORD *)a2;
    int v9 = *((_DWORD *)a2 + 1);
    *(_DWORD *)__int128 buf = 67175169;
    int v21 = v8;
    __int16 v22 = 2049;
    double v23 = v7;
    __int16 v24 = 1025;
    int v25 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "VO2MaxAlert,gender,%{private}d,age,%{private}f,biologicalSex,%{private}d",  buf,  0x18u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101841548);
    }
    double v10 = *((float *)a2 + 5);
    int v11 = *(_DWORD *)a2;
    int v12 = *((_DWORD *)a2 + 1);
    v15[0] = 67175169;
    v15[1] = v11;
    __int16 v16 = 2049;
    double v17 = v10;
    __int16 v18 = 1025;
    int v19 = v12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "VO2MaxAlert,gender,%{private}d,age,%{private}f,biologicalSex,%{private}d",  v15,  24);
    unint64_t v14 = (uint8_t *)v13;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLVO2MaxAlertEvaluator::feedBodyMetrics(const CLBodyMetrics &)",  "%s\n",  v13);
    if (v14 != buf) {
      free(v14);
    }
  }

void sub_1005B2BB8(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_1005B2BE4(uint64_t a1, char *a2, uint64_t *a3, double a4)
{
  double v11 = a4;
  sub_100400554(a1, a3, &v11);
  *(void *)a1 = off_101841578;
  sub_1010DDBC0((void *)(a1 + 232), a2);
  sub_100B14CF0((void *)(a1 + 256), a1 + 64, 0LL);
  if (sub_1003C1048(a1 + 64))
  {
    unint64_t v6 = (char *)(a1 + 232);
    sub_1003B59A0(a1 + 64, v6, (const char **)&qword_101996EE8, 0LL, 0);
    sub_100400684(a1);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018415A8);
    }
    double v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#Warning Database is not valid; not initializing",
        buf,
        2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018415A8);
      }
      __int16 v10 = 0;
      int v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  0LL,  "#Warning Database is not valid; not initializing",
                     &v10,
                     2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLNrCellLocationDatabase::CLNrCellLocationDatabase(const char *, const CLSqliteDatabase::SqliteProperties &, double)",  "%s\n",  v9);
    }
  }

  return a1;
}

void sub_1005B2E00(_Unwind_Exception *a1)
{
}

uint64_t sub_1005B2E3C(uint64_t a1)
{
  *(void *)a1 = off_101841578;
  return sub_10040063C(a1);
}

void sub_1005B2E7C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1005B2E3C(a1);
  operator delete(v1);
}

char *sub_1005B2E90@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[255] < 0) {
    return (char *)sub_1010DD48C((_BYTE *)a2, *((void **)result + 29), *((void *)result + 30));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 232);
  *(void *)(a2 + 16) = *((void *)result + 31);
  return result;
}

BOOL sub_1005B2EBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL result = sub_1005B2F30(a1, a2, &v8);
  if (result)
  {
    BOOL result = sub_100401610(a1, &v8, a3);
    if (result)
    {
      if (*(void *)(a2 + 16) == -1LL) {
        int v7 = 7;
      }
      else {
        int v7 = 6;
      }
      *(_DWORD *)(a3 + 96) = v7;
      *(_DWORD *)(a3 + 12_Block_object_dispose(va, 8) = 50;
      return 1LL;
    }
  }

  return result;
}

BOOL sub_1005B2F30(uint64_t a1, uint64_t a2, sqlite3_int64 *a3)
{
  unint64_t v6 = sub_10000CF44(&v41, (uint64_t)"SELECT ", 7LL);
  size_t v7 = strlen("ROWID");
  sqlite3_int64 v8 = sub_10000CF44(v6, (uint64_t)"ROWID", v7);
  int v9 = sub_10000CF44(v8, (uint64_t)" FROM ", 6LL);
  __int16 v10 = (const char *)(a1 + 232);
  size_t v11 = strlen(v10);
  int v12 = sub_10000CF44(v9, (uint64_t)v10, v11);
  uint64_t v13 = sub_10000CF44(v12, (uint64_t)" WHERE ", 7LL);
  unint64_t v14 = sub_10000CF44(v13, (uint64_t)"MCC", 3LL);
  uint64_t v15 = sub_10000CF44(v14, (uint64_t)"=? AND ", 7LL);
  __int16 v16 = sub_10000CF44(v15, (uint64_t)"MNC", 3LL);
  double v17 = sub_10000CF44(v16, (uint64_t)"=? AND ", 7LL);
  __int16 v18 = sub_10000CF44(v17, (uint64_t)"TAC", 3LL);
  int v19 = sub_10000CF44(v18, (uint64_t)"=? AND ", 7LL);
  int v20 = sub_10000CF44(v19, (uint64_t)"CI", 2LL);
  sub_10000CF44(v20, (uint64_t)"=?", 2LL);
  std::stringbuf::str(&v48, &v42);
  if ((v48.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v21 = &v48;
  }
  else {
    int v21 = (std::stringbuf::string_type *)v48.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(a1 + 64, (char *)v21, buf);
  uint64_t v22 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  double v23 = (sqlite3_stmt *)sub_100019240(v22);
  if (sub_1003C28BC(v23, 1, *(_DWORD *)a2)
    && (__int16 v24 = (sqlite3_stmt *)sub_100019240(v22), sub_1003C28BC(v24, 2, *(_DWORD *)(a2 + 4)))
    && (int v25 = (sqlite3_stmt *)sub_100019240(v22), sub_1003C28BC(v25, 3, *(_DWORD *)(a2 + 8)))
    && (float v26 = (sqlite3_stmt *)sub_100019240(v22), sub_1003C2D24(v26, 4, *(void *)(a2 + 16))))
  {
    unint64_t v27 = (sqlite3_stmt *)sub_100019240(v22);
    int v28 = sqlite3_step(v27);
    BOOL v29 = v28 == 100;
    if (v28 == 100)
    {
      float v30 = (sqlite3_stmt *)sub_100019240(v22);
      *a3 = sqlite3_column_int64(v30, 0);
    }

    unint64_t v31 = (sqlite3_stmt *)sub_100019240(v22);
    sqlite3_reset(v31);
    if (v22) {
LABEL_15:
    }
      (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018415A8);
    }
    uint64_t v34 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1003D2C58((unsigned int *)a2, &v48);
      __int16 v35 = (v48.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &v48
          : (std::stringbuf::string_type *)v48.__r_.__value_.__r.__words[0];
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = v35;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_FAULT, "CELL_LOC: failed to bind %s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(&v48, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018415A8);
      }
      uint64_t v37 = qword_101934A78;
      sub_1003D2C58((unsigned int *)a2, buf);
      if (v45 >= 0) {
        uint64_t v38 = buf;
      }
      else {
        uint64_t v38 = *(_BYTE **)buf;
      }
      int v46 = 136315138;
      uint64_t v47 = v38;
      uint64_t v39 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v48,  1628LL,  &_mh_execute_header,  v37,  17LL,  "CELL_LOC: failed to bind %s",  (const char *)&v46);
      if (v45 < 0) {
        operator delete(*(void **)buf);
      }
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLNrCellLocationDatabase::getLocation(const CLTelephonyService_Type::NrCell &, sqlite3_int64 &)",  "%s\n",  (const char *)v39);
      if (v39 != &v48) {
        free(v39);
      }
    }

    unint64_t v36 = (sqlite3_stmt *)sub_100019240(v22);
    sqlite3_reset(v36);
    BOOL v29 = 0LL;
    if (v22) {
      goto LABEL_15;
    }
  }

  *(void *)((char *)v40
  uint64_t v41 = v32;
  std::streambuf::~streambuf(&v42);
  std::ios::~ios(&v43);
  return v29;
}

void sub_1005B33DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,void *__p,uint64_t a55,int a56,__int16 a57,char a58,char a59)
{
  if (v59) {
    (*(void (**)(uint64_t))(*(void *)v59 + 8LL))(v59);
  }
  sub_1011F8850((uint64_t)&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1005B343C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (uint64_t *)(a1 + 256);
  if (sub_100B14D64((void *)(a1 + 256)))
  {
LABEL_22:
    sub_100B14CF8(v6, v58);
    int v28 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v58);
    if (sub_1003C28BC(v28, 1, *(_DWORD *)a2)
      && (BOOL v29 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v58), sub_1003C28BC(v29, 2, *(_DWORD *)(a2 + 4)))
      && (float v30 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v58), sub_1003C28BC(v30, 3, *(_DWORD *)(a2 + 8)))
      && (unint64_t v31 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v58), sub_1003C2D24(v31, 4, *(void *)(a2 + 16)))
      && (uint64_t v32 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v58), sub_1003C28BC(v32, 5, *(_DWORD *)(a2 + 24)))
      && (uint64_t v33 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v58), sub_1003C28BC(v33, 6, *(_DWORD *)(a2 + 28))))
    {
      uint64_t v34 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v58);
      sub_1003BB2BC(a1 + 64, v34);
      sqlite3_int64 v35 = sub_1003C1068(a1 + 64);
      sqlite3_int64 v56 = v35;
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018415A8);
      }
      unint64_t v36 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        sub_1003D2C58((unsigned int *)a2, &v59);
        uint64_t v37 = (v59.__r_.__value_.__s.__size_ & 0x80u) == 0
            ? &v59
            : (std::stringbuf::string_type *)v59.__r_.__value_.__r.__words[0];
        *(_DWORD *)int v60 = 136315394;
        *(void *)&v60[4] = v37;
        __int16 v61 = 2048;
        *(void *)int v62 = v35;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEBUG,  "CELL_CEN: adding cell, %s, rowid, %lld",  v60,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(&v59, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_1018415A8);
        }
        uint64_t v53 = qword_101934A78;
        sub_1003D2C58((unsigned int *)a2, v60);
        if (v62[9] >= 0) {
          uint64_t v54 = v60;
        }
        else {
          uint64_t v54 = *(_BYTE **)v60;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v54;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v35;
        __int16 v55 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v59,  1628LL,  &_mh_execute_header,  v53,  2LL,  "CELL_CEN: adding cell, %s, rowid, %lld",  (const char *)&buf,  22);
        if ((v62[9] & 0x80000000) != 0) {
          operator delete(*(void **)v60);
        }
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLNrCellLocationDatabase::setLocation(const CLTelephonyService_Type::NrCell &, const CLDaemonLocation &)",  "%s\n",  (const char *)v55);
        if (v55 != &v59) {
          free(v55);
        }
      }

      uint64_t v38 = sub_100401CE8((uint64_t *)a1, &v56, a3);
    }

    else
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018415A8);
      }
      uint64_t v39 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        sub_1003D2C58((unsigned int *)a2, &v59);
        uint64_t v40 = (v59.__r_.__value_.__s.__size_ & 0x80u) == 0
            ? &v59
            : (std::stringbuf::string_type *)v59.__r_.__value_.__r.__words[0];
        *(_DWORD *)int v60 = 136315138;
        *(void *)&v60[4] = v40;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_FAULT, "CELL_LOC: failed to bind %s", v60, 0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(&v59, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_1018415A8);
        }
        uint64_t v46 = qword_101934A78;
        sub_1003D2C58((unsigned int *)a2, v60);
        if (v62[9] >= 0) {
          uint64_t v47 = v60;
        }
        else {
          uint64_t v47 = *(_BYTE **)v60;
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v47;
        std::stringbuf::string_type v48 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v59,  1628LL,  &_mh_execute_header,  v46,  17LL,  "CELL_LOC: failed to bind %s",  (const char *)&buf);
        if ((v62[9] & 0x80000000) != 0) {
          operator delete(*(void **)v60);
        }
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLNrCellLocationDatabase::setLocation(const CLTelephonyService_Type::NrCell &, const CLDaemonLocation &)",  "%s\n",  (const char *)v48);
        if (v48 != &v59) {
          free(v48);
        }
      }

      uint64_t v41 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v58);
      sqlite3_reset(v41);
      uint64_t v38 = 0LL;
    }

    uint64_t v42 = *(void *)v58;
    *(void *)uint64_t v58 = 0LL;
    if (v42) {
      (*(void (**)(uint64_t))(*(void *)v42 + 8LL))(v42);
    }
    return v38;
  }

  sub_10000CE18((uint64_t)v60);
  size_t v7 = sub_10000CF44(&v62[2], (uint64_t)"INSERT OR REPLACE INTO ", 23LL);
  sqlite3_int64 v8 = (const char *)(a1 + 232);
  size_t v9 = strlen(v8);
  __int16 v10 = sub_10000CF44(v7, (uint64_t)v8, v9);
  size_t v11 = sub_10000CF44(v10, (uint64_t)" (", 2LL);
  int v12 = sub_10000CF44(v11, (uint64_t)"MCC", 3LL);
  uint64_t v13 = sub_10000CF44(v12, (uint64_t)", ", 2LL);
  unint64_t v14 = sub_10000CF44(v13, (uint64_t)"MNC", 3LL);
  uint64_t v15 = sub_10000CF44(v14, (uint64_t)", ", 2LL);
  __int16 v16 = sub_10000CF44(v15, (uint64_t)"TAC", 3LL);
  double v17 = sub_10000CF44(v16, (uint64_t)", ", 2LL);
  __int16 v18 = sub_10000CF44(v17, (uint64_t)"CI", 2LL);
  int v19 = sub_10000CF44(v18, (uint64_t)", ", 2LL);
  int v20 = sub_10000CF44(v19, (uint64_t)"NRARFCN", 7LL);
  int v21 = sub_10000CF44(v20, (uint64_t)", ", 2LL);
  uint64_t v22 = sub_10000CF44(v21, (uint64_t)"PID", 3LL);
  sub_10000CF44(v22, (uint64_t)") VALUES (?, ?, ?, ?, ?, ?)", 27LL);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_1018415A8);
  }
  double v23 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    std::stringbuf::str(&v59, &v63);
    __int16 v24 = (v59.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &v59
        : (std::stringbuf::string_type *)v59.__r_.__value_.__r.__words[0];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v24;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "CELL_LOC: fInsertStatement [%s]",  (uint8_t *)&buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v59, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018415A8);
    }
    uint64_t v49 = qword_101934A78;
    std::stringbuf::str(&buf, &v63);
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_std::stringbuf::string_type buf = &buf;
    }
    else {
      p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t v58 = 136315138;
    *(void *)&v58[4] = p_buf;
    int v51 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v59,  1628LL,  &_mh_execute_header,  v49,  2LL,  "CELL_LOC: fInsertStatement [%s]",  v58);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLNrCellLocationDatabase::setLocation(const CLTelephonyService_Type::NrCell &, const CLDaemonLocation &)",  "%s\n",  (const char *)v51);
    if (v51 != &v59) {
      free(v51);
    }
  }

  std::stringbuf::str(&v59, &v63);
  if ((v59.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v25 = &v59;
  }
  else {
    int v25 = (std::stringbuf::string_type *)v59.__r_.__value_.__r.__words[0];
  }
  *(void *)(a1 + 256) = sub_1003BF158(a1 + 64, (char *)v25);
  *(void *)(a1 + 264) = v26;
  if (sub_100B14D64(v6))
  {
    *(void *)&v62[2] = v27;
    std::streambuf::~streambuf(&v63);
    std::ios::~ios(v64);
    goto LABEL_22;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_1018415A8);
  }
  uint64_t v43 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    LOWORD(v59.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_FAULT,  "Could not prepare cached insert statement",  (uint8_t *)&v59,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(&v59, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018415A8);
    }
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    uint64_t v52 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v59,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Could not prepare cached insert statement",  &buf,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLNrCellLocationDatabase::setLocation(const CLTelephonyService_Type::NrCell &, const CLDaemonLocation &)",  "%s\n",  (const char *)v52);
    if (v52 != &v59) {
      free(v52);
    }
  }

  *(void *)&v62[2] = v44;
  std::streambuf::~streambuf(&v63);
  std::ios::~ios(v64);
  return 0LL;
}

void sub_1005B3E40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17) {
    (*(void (**)(uint64_t))(*(void *)a17 + 8LL))(a17);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1005B3EC0(_BYTE *a1, uint64_t a2)
{
  BOOL result = sub_1005B2F30((uint64_t)a1, a2, &v4);
  if (result) {
    return sub_10040278C(a1, &v4);
  }
  return result;
}

BOOL sub_1005B3EFC(uint64_t a1, sqlite3_int64 a2, uint64_t a3)
{
  unint64_t v6 = sub_10000CF44(&v39, (uint64_t)"SELECT ", 7LL);
  size_t v7 = sub_10000CF44(v6, (uint64_t)"MCC", 3LL);
  sqlite3_int64 v8 = sub_10000CF44(v7, (uint64_t)", ", 2LL);
  size_t v9 = sub_10000CF44(v8, (uint64_t)"MNC", 3LL);
  __int16 v10 = sub_10000CF44(v9, (uint64_t)", ", 2LL);
  size_t v11 = sub_10000CF44(v10, (uint64_t)"TAC", 3LL);
  int v12 = sub_10000CF44(v11, (uint64_t)", ", 2LL);
  uint64_t v13 = sub_10000CF44(v12, (uint64_t)"CI", 2LL);
  unint64_t v14 = sub_10000CF44(v13, (uint64_t)" FROM ", 6LL);
  uint64_t v15 = (const char *)(a1 + 232);
  size_t v16 = strlen(v15);
  double v17 = sub_10000CF44(v14, (uint64_t)v15, v16);
  __int16 v18 = sub_10000CF44(v17, (uint64_t)" WHERE ", 7LL);
  size_t v19 = strlen("ROWID");
  int v20 = sub_10000CF44(v18, (uint64_t)"ROWID", v19);
  sub_10000CF44(v20, (uint64_t)"=?", 2LL);
  std::stringbuf::str(&v42, &v40);
  if ((v42.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v21 = &v42;
  }
  else {
    int v21 = (std::stringbuf::string_type *)v42.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(a1 + 64, (char *)v21, &v37);
  uint64_t v22 = v37;
  uint64_t v37 = 0LL;
  double v23 = (sqlite3_stmt *)sub_100019240(v22);
  if (sub_1003C2D24(v23, 1, a2))
  {
    __int16 v24 = (sqlite3_stmt *)sub_100019240(v22);
    int v25 = sqlite3_step(v24);
    BOOL v26 = v25 == 100;
    if (v25 == 100)
    {
      uint64_t v27 = (sqlite3_stmt *)sub_100019240(v22);
      *(_DWORD *)a3 = sqlite3_column_int(v27, 0);
      int v28 = (sqlite3_stmt *)sub_100019240(v22);
      *(_DWORD *)(a3 + 4) = sqlite3_column_int(v28, 1);
      BOOL v29 = (sqlite3_stmt *)sub_100019240(v22);
      *(_DWORD *)(a3 + _Block_object_dispose(va, 8) = sqlite3_column_int(v29, 2);
      float v30 = (sqlite3_stmt *)sub_100019240(v22);
      *(void *)(a3 + 16) = sqlite3_column_int(v30, 3);
    }

    unint64_t v31 = (sqlite3_stmt *)sub_100019240(v22);
    sqlite3_reset(v31);
    if (v22) {
LABEL_12:
    }
      (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018415A8);
    }
    uint64_t v34 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      LOWORD(v42.__r_.__value_.__l.__data_) = 0;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_FAULT, "could not bind", (uint8_t *)&v42, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(&v42, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018415A8);
      }
      LOWORD(vsub_1005A8CF4(v2 + 37) = 0;
      unint64_t v36 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v42,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not bind",  &v37,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLNrCellLocationDatabase::getLocation(sqlite3_int64, CLTelephonyService_Type::NrCell &) const",  "%s\n",  (const char *)v36);
      if (v36 != &v42) {
        free(v36);
      }
    }

    sqlite3_int64 v35 = (sqlite3_stmt *)sub_100019240(v22);
    sqlite3_reset(v35);
    BOOL v26 = 0LL;
    if (v22) {
      goto LABEL_12;
    }
  }

  *(void *)((char *)v38
  uint64_t v39 = v32;
  std::streambuf::~streambuf(&v40);
  std::ios::~ios(&v41);
  return v26;
}

void sub_1005B4310( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *__p, uint64_t a48, int a49, __int16 a50,char a51,char a52)
{
  if (v52) {
    (*(void (**)(uint64_t))(*(void *)v52 + 8LL))(v52);
  }
  sub_1011F8850((uint64_t)&a12);
  _Unwind_Resume(a1);
}

void sub_1005B4368(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_1005B4394()
{
  qword_101996EE8 = (uint64_t)"MCC";
  dword_101996EF0 = 1;
  word_101996EF4 = 1;
  byte_101996EF8 = 0;
  byte_101996F10 = 0;
  qword_101996F18 = (uint64_t)"MNC";
  dword_101996F20 = 1;
  word_101996F24 = 1;
  byte_101996F28 = 0;
  byte_101996F40 = 0;
  qword_101996F48 = (uint64_t)"TAC";
  dword_101996F50 = 1;
  word_101996F54 = 1;
  byte_101996F58 = 0;
  byte_101996F70 = 0;
  qword_101996F78 = (uint64_t)"CI";
  dword_101996F80 = 1;
  word_101996F84 = 1;
  byte_101996F88 = 0;
  byte_101996FA0 = 0;
  qword_101996FA8 = (uint64_t)"NRARFCN";
  dword_101996FB0 = 1;
  word_101996FB4 = 1;
  byte_101996FB8 = 0;
  byte_101996FD0 = 0;
  qword_101996FD8 = (uint64_t)"PID";
  dword_101996FE0 = 1;
  word_101996FE4 = 1;
  byte_101996FE8 = 0;
  byte_101997000 = 0;
  qword_101997008 = (uint64_t)"Timestamp";
  dword_101997010 = 2;
  word_101997014 = 0;
  byte_101997018 = 0;
  byte_101997030 = 0;
  qword_101997038 = (uint64_t)"Latitude";
  dword_101997040 = 2;
  word_101997044 = 0;
  byte_101997048 = 0;
  byte_101997060 = 0;
  qword_101997068 = (uint64_t)"Longitude";
  dword_101997070 = 2;
  word_101997074 = 0;
  byte_101997078 = 0;
  byte_101997090 = 0;
  qword_101997098 = (uint64_t)"HorizontalAccuracy";
  dword_1019970A0 = 2;
  word_1019970A4 = 0;
  byte_1019970A8 = 0;
  byte_1019970C0 = 0;
  qword_1019970C8 = (uint64_t)"Altitude";
  dword_1019970D0 = 2;
  word_1019970D4 = 0;
  byte_1019970D8 = 0;
  byte_1019970F0 = 0;
  qword_1019970F8 = (uint64_t)"VerticalAccuracy";
  dword_101997100 = 2;
  word_101997104 = 0;
  byte_101997108 = 0;
  byte_101997120 = 0;
  qword_101997128 = (uint64_t)"Speed";
  dword_101997130 = 2;
  word_101997134 = 0;
  byte_101997138 = 0;
  byte_101997150 = 0;
  qword_101997158 = (uint64_t)"Course";
  dword_101997160 = 2;
  word_101997164 = 0;
  byte_101997168 = 0;
  byte_101997180 = 0;
  qword_101997188 = (uint64_t)"Confidence";
  dword_101997190 = 1;
  word_101997194 = 0;
  byte_101997198 = 0;
  byte_1019971B0 = 0;
  qword_1019971B8 = 0LL;
  dword_1019971C0 = 5;
  word_1019971C4 = 0;
  byte_1019971C8 = 0;
  byte_1019971E0 = 0;
}

uint64_t sub_1005B4588(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 24) = 0xC00000046LL;
  *(_DWORD *)(a1 + 32) = 56;
  *(void *)(a1 + 36) = 0x3851B7173727C5ACLL;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + sub_10004AD90(v15 - 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = 0u;
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 16) = a2;
  __int128 v3 = operator new(0x1ECuLL);
  *(_BYTE *)__int128 v3 = 1;
  void v3[4] = 0;
  void v3[5] = 117;
  void v3[3] = 0;
  *(void *)(a1 + 144) = v3;
  sub_1005B4634(a1);
  return a1;
}

void sub_1005B460C(_Unwind_Exception *exception_object)
{
  __int128 v3 = *(void **)(v1 + 144);
  *(void *)(v1 + 144) = 0LL;
  if (v3) {
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

id sub_1005B4634(uint64_t a1)
{
  id result =   [[CMNoMovementStateUpdate alloc] initWithState:0 startTime:CFAbsoluteTimeGetCurrent()];
  *(void *)a1 = result;
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = 0;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + sub_10004AD90(v15 - 112) = 0u;
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = 0u;
  uint64_t v3 = *(void *)(a1 + 144);
  if (v3) {
    *(_DWORD *)(v3 + 16) = 0;
  }
  return result;
}

uint64_t sub_1005B46A8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 144);
  *(void *)(a1 + 144) = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

uint64_t sub_1005B46E8(uint64_t a1)
{
  return *(void *)a1;
}

void sub_1005B46F0(uint64_t a1, __int128 *a2)
{
  __int128 v3 = *a2;
  *(_DWORD *)(a1 + 40) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 24) = v3;
  sub_1005B4634(a1);
  if (qword_1019347F0 != -1) {
    dispatch_once(&qword_1019347F0, &stru_1018415C8);
  }
  sqlite3_int64 v4 = (os_log_s *)qword_1019347F8;
  if (os_log_type_enabled((os_log_t)qword_1019347F8, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *(_DWORD *)(a1 + 24);
    int v6 = *(_DWORD *)(a1 + 28);
    int v7 = *(_DWORD *)(a1 + 32);
    double v8 = *(float *)(a1 + 36);
    double v9 = *(float *)(a1 + 40);
    *(_DWORD *)std::stringbuf::string_type buf = 67110144;
    int v22 = v5;
    __int16 v23 = 1024;
    int v24 = v6;
    __int16 v25 = 1024;
    int v26 = v7;
    __int16 v27 = 2048;
    double v28 = v8;
    __int16 v29 = 2048;
    double v30 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "[CLNoMovement] detector: parameters,epochsPerWindow,%d,epochStepSize,%d,detectionEpochThreshold,%d,userAccelVarSum Threshold,%f,rotationRateVarSumThreshold,%f",  buf,  0x28u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347F0 != -1) {
      dispatch_once(&qword_1019347F0, &stru_1018415C8);
    }
    int v10 = *(_DWORD *)(a1 + 28);
    int v11 = *(_DWORD *)(a1 + 32);
    double v12 = *(float *)(a1 + 36);
    double v13 = *(float *)(a1 + 40);
    LOWORD(v17) = 1024;
    *(_DWORD *)((char *)&v17 + 2) = v10;
    HIWORD(v17) = 1024;
    *(_DWORD *)__int16 v18 = v11;
    *(_WORD *)&v18[4] = 2048;
    *(double *)&void v18[6] = v12;
    __int16 v19 = 2048;
    double v20 = v13;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347F8,  2LL,  "[CLNoMovement] detector: parameters,epochsPerWindow,%d,epochStepSize,%d,detectionEpochThreshold,%d,userAccelVarSum Threshold,%f,rotationRateVarSumThreshold,%f",  &v16,  40,  67110144,  v17,  *(double *)v18);
    uint64_t v15 = (uint8_t *)v14;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNoMovementDetector::setParameters(const CLNoMovement::Parameters)",  "%s\n",  v14);
    if (v15 != buf) {
      free(v15);
    }
  }

void sub_1005B4924(float *a1, uint64_t a2)
{
  int v5 = a1 + 12;
  unint64_t v4 = *((void *)a1 + 6);
  float v6 = *(float *)a2;
  float v7 = a1[14];
  float v8 = a1[15];
  float v9 = *(float *)a2 - v7;
  *((void *)a1 + 6) = v4 + 1;
  float v10 = v7 + (float)(v9 / (float)(v4 + 1));
  float v11 = v8 + (float)(v9 * (float)(v6 - v10));
  a1[14] = v10;
  a1[15] = v11;
  float v12 = *(float *)(a2 + 4);
  float v13 = a1[18];
  float v14 = a1[19];
  float v15 = v12 - v13;
  unint64_t v16 = *((void *)a1 + 8);
  *((void *)a1 + _Block_object_dispose(va, 8) = v16 + 1;
  float v17 = v13 + (float)((float)(v12 - v13) / (float)(v16 + 1));
  float v18 = v14 + (float)(v15 * (float)(v12 - v17));
  a1[18] = v17;
  a1[19] = v18;
  float v19 = *(float *)(a2 + 8);
  float v20 = a1[22];
  float v21 = a1[23];
  float v22 = v19 - v20;
  unint64_t v23 = *((void *)a1 + 10);
  *((void *)a1 + 10) = v23 + 1;
  float v24 = v20 + (float)((float)(v19 - v20) / (float)(v23 + 1));
  float v25 = v21 + (float)(v22 * (float)(v19 - v24));
  a1[22] = v24;
  a1[23] = v25;
  float v26 = *(float *)(a2 + 12);
  float v27 = a1[26];
  float v28 = a1[27];
  float v29 = v26 - v27;
  unint64_t v30 = *((void *)a1 + 12);
  *((void *)a1 + 12) = v30 + 1;
  float v31 = v27 + (float)((float)(v26 - v27) / (float)(v30 + 1));
  float v32 = v28 + (float)(v29 * (float)(v26 - v31));
  a1[26] = v31;
  a1[27] = v32;
  float v33 = *(float *)(a2 + 16);
  float v34 = a1[30];
  float v35 = a1[31];
  float v36 = v33 - v34;
  unint64_t v37 = *((void *)a1 + 14);
  *((void *)a1 + 14) = v37 + 1;
  float v38 = v34 + (float)((float)(v33 - v34) / (float)(v37 + 1));
  float v39 = v35 + (float)(v36 * (float)(v33 - v38));
  a1[30] = v38;
  a1[31] = v39;
  float v40 = *(float *)(a2 + 20);
  float v41 = a1[34];
  float v42 = a1[35];
  float v43 = v40 - v41;
  unint64_t v44 = *((void *)a1 + 16);
  float v45 = v41 + (float)((float)(v40 - v41) / (float)(v44 + 1));
  *((void *)v5 + 10) = v44 + 1;
  float v46 = v42 + (float)(v43 * (float)(v40 - v45));
  v5[22] = v45;
  v5[23] = v46;
  if (v4 + 1 < 0xFF) {
    return;
  }
  ++*((_DWORD *)a1 + 2);
  float v47 = v11 / (float)v4;
  float v48 = 0.0;
  float v49 = v18 / (float)v16;
  if (v16 + 1 < 2) {
    float v49 = 0.0;
  }
  float v50 = v47 + v49;
  float v51 = 0.0;
  if (v23 + 1 >= 2) {
    float v51 = v25 / (float)v23;
  }
  float v52 = v50 + v51;
  if (v30 + 1 >= 2) {
    float v48 = v32 / (float)v30;
  }
  float v53 = 0.0;
  float v54 = v39 / (float)v37;
  if (v37 + 1 < 2) {
    float v54 = 0.0;
  }
  float v55 = v48 + v54;
  if (v44 + 1 >= 2) {
    float v53 = v46 / (float)v44;
  }
  float v56 = v55 + v53;
  uint64_t v57 = *((void *)a1 + 18);
  BOOL v58 = v52 < a1[9] && v56 < a1[10];
  *(_DWORD *)std::stringbuf::string_type buf = v58;
  sub_10032E068((unsigned __int16 *)(v57 + 16), buf);
  *(_BYTE *)uint64_t v57 = 1;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *(_OWORD *)int v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  if (qword_1019347F0 != -1) {
    dispatch_once(&qword_1019347F0, &stru_1018415C8);
  }
  std::stringbuf::string_type v59 = (os_log_s *)qword_1019347F8;
  if (os_log_type_enabled((os_log_t)qword_1019347F8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v60 = *(void *)(a2 + 32);
    *(_DWORD *)std::stringbuf::string_type buf = 134218496;
    uint64_t v96 = v60;
    __int16 v97 = 2048;
    *(double *)int v98 = v52;
    *(_WORD *)&v98[8] = 2048;
    double v99 = v56;
    _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_DEBUG,  "[CLNoMovement] detector: epoch stats,startTime,%f,accelVarSum,%f,rotationVarSum,%f",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347F0 != -1) {
      dispatch_once(&qword_1019347F0, &stru_1018415C8);
    }
    uint64_t v79 = *(void *)(a2 + 32);
    int v90 = 134218496;
    uint64_t v91 = v79;
    __int16 v92 = 2048;
    *(double *)unint64_t v93 = v52;
    *(_WORD *)&v93[8] = 2048;
    double v94 = v56;
    LODWORD(v89) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347F8,  2LL,  "[CLNoMovement] detector: epoch stats,startTime,%f,accelVarSum,%f,rotationVarSum,%f",  COERCE_DOUBLE(&v90),  v89);
    double v81 = (uint8_t *)v80;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNoMovementDetector::computeWindowState(const CLNoMovement::DeviceMotionInput &)",  "%s\n",  v80);
    if (v81 != buf) {
      free(v81);
    }
  }

  if (*((_DWORD *)a1 + 2) >= *((_DWORD *)a1 + 7))
  {
    a1[2] = 0.0;
    uint64_t v61 = *((void *)a1 + 18);
    unint64_t v62 = *((int *)a1 + 6);
    std::stringbuf v63 = (unsigned __int16 *)(v61 + 16);
    unint64_t v64 = *(unsigned __int16 *)(v61 + 18);
    if (v64 >= v62)
    {
      if (v64 - v62 < v64)
      {
        int v66 = 0;
        do
          v66 += *(_DWORD *)sub_10032DE70((unsigned __int16 *)(v61 + 16), --v64);
        while (*(unsigned __int16 *)(v61 + 18) - v62 < v64);
LABEL_31:
        if (v66 < *((_DWORD *)a1 + 8)) {
          uint64_t v67 = 1LL;
        }
        else {
          uint64_t v67 = 2LL;
        }

        id v68 =  [[CMNoMovementStateUpdate alloc] initWithState:v67 startTime:*(double *)(a2 + 32)];
        *(void *)a1 = v68;
        if (qword_1019347F0 != -1) {
          dispatch_once(&qword_1019347F0, &stru_1018415C8);
        }
        int v69 = (os_log_s *)qword_1019347F8;
        if (os_log_type_enabled((os_log_t)qword_1019347F8, OS_LOG_TYPE_DEBUG))
        {
          [v68 startTime];
          uint64_t v71 = v70;
          unsigned int v72 = [v68 state];
          int v73 = *(unsigned __int16 *)(*((void *)a1 + 18) + 18LL);
          *(_DWORD *)std::stringbuf::string_type buf = 134218752;
          uint64_t v96 = v71;
          __int16 v97 = 1024;
          *(_DWORD *)int v98 = v72;
          *(_WORD *)&v98[4] = 1024;
          *(_DWORD *)&v98[6] = v66;
          LOWORD(v99) = 1024;
          *(_DWORD *)((char *)&v99 + 2) = v73;
          _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEBUG,  "[CLNoMovement] detector: compute window-state,startTime,%f,state,%d,bufferSum,%d,bufferSize,%d",  buf,  0x1Eu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019347F0 != -1) {
            dispatch_once(&qword_1019347F0, &stru_1018415C8);
          }
          uint64_t v82 = qword_1019347F8;
          [v68 startTime];
          uint64_t v84 = v83;
          unsigned int v85 = [v68 state];
          int v86 = *(unsigned __int16 *)(*((void *)a1 + 18) + 18LL);
          int v90 = 134218752;
          uint64_t v91 = v84;
          __int16 v92 = 1024;
          *(_DWORD *)unint64_t v93 = v85;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = v66;
          LOWORD(v94) = 1024;
          *(_DWORD *)((char *)&v94 + 2) = v86;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v82,  2LL,  "[CLNoMovement] detector: compute window-state,startTime,%f,state,%d,bufferSum,%d,bufferSize,%d",  COERCE_DOUBLE(&v90),  30);
          uint64_t v88 = (uint8_t *)v87;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNoMovementDetector::computeWindowState(const CLNoMovement::DeviceMotionInput &)",  "%s\n",  v87);
          if (v88 != buf) {
            free(v88);
          }
        }

        uint64_t v74 = (void (***)(void, void))*((void *)a1 + 2);
        if (v74) {
          (**v74)(v74, *(void *)a1);
        }
        goto LABEL_41;
      }
    }

    else if (*(_WORD *)(v61 + 18))
    {
      unint64_t v65 = 0LL;
      int v66 = 0;
      do
        v66 += *(_DWORD *)sub_10032DE70(v63, v65++);
      while (v64 != v65);
      goto LABEL_31;
    }

    int v66 = 0;
    goto LABEL_31;
  }

void sub_1005B5008(id a1)
{
  qword_1019347F8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "CheckIn");
}

void sub_1005B59CC(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void *sub_1005B59F8(void *a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_101841618;
  a1[9] = off_1018416E0;
  a1[44] = off_101841730;
  sub_100B14CF0(a1 + 45, 0LL, 0LL);
  sub_100B14CF0(a1 + 47, 0LL, 0LL);
  sub_100B14CF0(a1 + 49, 0LL, 0LL);
  sub_100B14CF0(a1 + 51, 0LL, 0LL);
  (*(void (**)(void *))(*a1 + 112LL))(a1);
  return a1;
}

void sub_1005B5AD0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005B5AFC(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = 0u;
  float v12 = (void *)(a1 + 8);
  *(void *)a1 = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 8));
  *float v12 = &off_101826EF8;
  *(void *)a1 = off_1018419E8;
  *(void *)(a1 + 72) = off_101841A90;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_1018419E8;
  *(void *)(a1 + 72) = off_101841A90;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  float v13 = (void *)(a1 + 232);
  *(_OWORD *)(a1 + 24_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20_Block_object_dispose(va, 8) = 0u;
  *(_DWORD *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 272) = 12000;
  *(void *)(a1 + 280) = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 288));
  *(void *)(a1 + 28_Block_object_dispose(va, 8) = &off_101826EF8;
  uint64_t v14 = *(void *)(a1 + 112);
  uint64_t v29 = a1 + 112;
  (*(void (**)(void))(v14 + 16))();
  __int16 v31 = 256;
  if (a3)
  {
    void *v13 = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a4;
    uint64_t v28 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v15 = sub_1006E27E8();
  sub_100413284(v15, buf);
  unint64_t v16 = (int *)(a1 + 272);
  char v17 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 272));
  float v18 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(p_shared_owners);
    while (__stlxr(v20 - 1, p_shared_owners));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  if ((v17 & 1) == 0) {
    *unint64_t v16 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101841AD0);
  }
  float v21 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v22 = *v16;
    *(_DWORD *)std::stringbuf::string_type buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v22;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101841AD0);
    }
    int v25 = *v16;
    v32[0] = 67109120;
    v32[1] = v25;
    float v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v32);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>::CLActivityRecorde rDb(const char *, BOOL, float, const std::string &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLMobi lity::SmoothedGaitMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v26);
  }

  int v23 = HIBYTE(v31);
  void *v13 = 0xBFF0000000000000LL;
  if (v23)
  {
    if ((_BYTE)v31)
    {
      pthread_mutex_unlock(v30);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_1005B5EB8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[35] = off_101826EC8;
  sub_1001B9C98(v27);
  sub_1005A8D88(v26);
  sub_100D8A88C(a12);
  *float v24 = off_101826EC8;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_1005B5F5C()
{
}

void *sub_1005B5F64(void *a1)
{
  a1[9] = off_101841A90;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_1018419E8;
  a1[35] = off_101826EC8;
  sub_1001B9C98(a1 + 36);
  sub_1005A8D88(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_101826EC8;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_1005B5FE4(uint64_t a1)
{
  return sub_1005B5F64((void *)(a1 - 72));
}

void *sub_1005B5FEC(uint64_t a1)
{
  return sub_1005B5F64((void *)(a1 - 352));
}

void sub_1005B5FF4(void *a1)
{
  uint64_t v1 = sub_1005B5F64(a1);
  operator delete(v1);
}

void sub_1005B6008(uint64_t a1)
{
  uint64_t v1 = sub_1005B5F64((void *)(a1 - 72));
  operator delete(v1);
}

void sub_1005B6020(uint64_t a1)
{
  uint64_t v1 = sub_1005B5F64((void *)(a1 - 352));
  operator delete(v1);
}

uint64_t sub_1005B6038(uint64_t *a1)
{
  uint64_t result = sub_1003C1048(a1[10]);
  if ((_DWORD)result)
  {
    sub_1005B60E4((uint64_t)a1);
    sub_1005B62F4((uint64_t)a1);
    sub_1003B59A0( a1[10],  "SmoothedGaitMetricsHistory",  (const char **)&off_1018417D8,  (const std::string::value_type **)&off_1019389B8,  0);
    a1[45] = sub_1003BF158(a1[10], "DELETE FROM SmoothedGaitMetricsHistory WHERE startTime < ?");
    a1[46] = v3;
    a1[47] = sub_1003BF158(a1[10], "SELECT * from SmoothedGaitMetricsHistory ORDER BY startTime ASC");
    a1[48] = v4;
    a1[49] = sub_1003BF158(a1[10], "SELECT COUNT(*) FROM SmoothedGaitMetricsHistory");
    a1[50] = v5;
    uint64_t result = sub_1003BF158( a1[10],  "INSERT INTO SmoothedGaitMetricsHistory (startTime, walkingSpeed, stepLength, cycleTime, distance, doubleS upportPercentage, asymmetryProbability, numGaitMetrics \t\t\t\t) VALUES (?, ?, ?, ?, ?, ?, ?, ?)");
    a1[51] = result;
    a1[52] = v6;
  }

  return result;
}

uint64_t sub_1005B60E4(uint64_t a1)
{
  uint64_t result = sub_1003B747C(*(void *)(a1 + 80), "SmoothedGaitMetricsHistory");
  if ((_DWORD)result)
  {
    float v7 = "numGaitMetrics";
    int v8 = 5;
    __int16 v9 = 0;
    char v10 = 0;
    char v11 = 0;
    uint64_t result = sub_1003BC790(*(void *)(a1 + 80), "SmoothedGaitMetricsHistory", "numGaitMetrics", (uint64_t)&v7);
    if ((_DWORD)result && v9 != 0)
    {
      if (qword_1019346B0 != -1) {
        dispatch_once(&qword_1019346B0, &stru_1018419B8);
      }
      uint64_t v4 = (os_log_s *)qword_1019346B8;
      if (os_log_type_enabled((os_log_t)qword_1019346B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Recreate SmoothedGaitMetricsHistory table if the primary key is incorrectly set",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346B0 != -1) {
          dispatch_once(&qword_1019346B0, &stru_1018419B8);
        }
        v6[0] = 0;
        uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346B8,  0LL,  "Recreate SmoothedGaitMetricsHistory table if the primary key is incorrectly set",  v6,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMobility::SmoothedGaitMetricsRecorderDb::updateSchemaIfNecessary()",  "%s\n",  v5);
      }

      sub_1003C0454(*(void *)(a1 + 80));
      sub_1003BCC74(*(void *)(a1 + 80), "SmoothedGaitMetricsHistory", (uint64_t)&off_1018417D8);
      return sub_1003C05BC(*(void *)(a1 + 80));
    }
  }

  return result;
}

uint64_t sub_1005B62F4(uint64_t a1)
{
  uint64_t result = sub_1003B747C(*(void *)(a1 + 80), "SmoothedGaitMetricsHistory");
  if ((_DWORD)result)
  {
    float v35 = "numGaitMetrics";
    int v36 = 5;
    __int16 v37 = 0;
    char v38 = 0;
    char v39 = 0;
    if ((sub_1003BC790(*(void *)(a1 + 80), "SmoothedGaitMetricsHistory", "numGaitMetrics", (uint64_t)&v35) & 1) != 0)
    {
      uint64_t result = sub_1005B6A24( a1,  "SmoothedGaitMetricsHistory",  (const char **)&off_1018417D8,  (const std::string::value_type **)&off_1019389B8);
      if (!(_DWORD)result) {
        return result;
      }
    }

    else
    {
      sub_1003C0454(*(void *)(a1 + 80));
      sub_10000CE18((uint64_t)v31);
      uint64_t v3 = sub_10000CF44(&v32, (uint64_t)"ALTER TABLE SmoothedGaitMetricsHistory ADD COLUMN ", 50LL);
      uint64_t v4 = sub_10000CF44(v3, (uint64_t)"numGaitMetrics", 14LL);
      uint64_t v5 = sub_10000CF44(v4, (uint64_t)" ", 1LL);
      uint64_t v6 = (const char *)sub_1003BCC40(1);
      size_t v7 = strlen(v6);
      int v8 = sub_10000CF44(v5, (uint64_t)v6, v7);
      sub_10000CF44(v8, (uint64_t)";", 1LL);
      uint64_t v9 = *(void *)(a1 + 80);
      std::stringbuf::str(&v28, &v33);
      if ((v28.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        char v10 = &v28;
      }
      else {
        char v10 = (std::stringbuf::string_type *)v28.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(v9, (char *)v10, &v26);
      uint64_t v11 = v26.__r_.__value_.__r.__words[0];
      v26.__r_.__value_.__r.__words[0] = 0LL;
      if ((char)v28.__r_.__value_.__s.__size_ < 0)
      {
        uint64_t v12 = v11;
        operator delete(v28.__r_.__value_.__l.__data_);
        uint64_t v11 = v12;
      }

      uint64_t v13 = *(void *)(a1 + 80);
      uint64_t v25 = v11;
      uint64_t v14 = (sqlite3_stmt *)sub_100019240(v11);
      sub_1003BB2BC(v13, v14);
      sub_10000CE18((uint64_t)&v28);
      uint64_t v15 = sub_10000CF44(&v28.__r_.__value_.__l.__cap_, (uint64_t)"UPDATE SmoothedGaitMetricsHistory SET ", 38LL);
      unint64_t v16 = sub_10000CF44(v15, (uint64_t)"numGaitMetrics", 14LL);
      sub_10000CF44(v16, (uint64_t)" = 0;", 5LL);
      uint64_t v17 = *(void *)(a1 + 80);
      std::stringbuf::str(&v26, &v29);
      if ((v26.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        float v18 = &v26;
      }
      else {
        float v18 = (std::stringbuf::string_type *)v26.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(v17, (char *)v18, &v27);
      uint64_t v19 = v27;
      uint64_t v27 = 0LL;
      uint64_t v20 = *(void *)(a1 + 80);
      float v21 = (sqlite3_stmt *)sub_100019240(v19);
      sub_1003BB2BC(v20, v21);
      sub_1003C05BC(*(void *)(a1 + 80));
      if (v19) {
        (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
      }
      v28.__r_.__value_.__r.__words[0] = v22;
      *(std::string::size_type *)((char *)v28.__r_.__value_.__r.__words + *(void *)(v22 - 24)) = v23;
      v28.__r_.__value_.__l.__cap_ = v24;
      std::streambuf::~streambuf(&v29);
      std::ios::~ios(&v30);
      if (v25) {
        (*(void (**)(uint64_t))(*(void *)v25 + 8LL))(v25);
      }
      v31[0] = v22;
      *(void *)((char *)v31 + *(void *)(v22 - 24)) = v23;
      std::string::size_type v32 = v24;
      std::streambuf::~streambuf(&v33);
      std::ios::~ios(&v34);
      sub_1005B6A24( a1,  "SmoothedGaitMetricsHistory",  (const char **)&off_1018417D8,  (const std::string::value_type **)&off_1019389B8);
    }

    return sub_1003BF200(*(void *)(a1 + 80), "SmoothedGaitMetricsHistory");
  }

  return result;
}

void sub_1005B664C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a17);
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8LL))(a9);
  }
  sub_1011F8850((uint64_t)&a55);
  _Unwind_Resume(a1);
}

uint64_t sub_1005B66E8(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_100B14CF8((uint64_t *)(a1 + 408), &v18);
    if (v18)
    {
      uint64_t v5 = (sqlite3_stmt *)sub_100019240(v18);
      if (sub_1003B7480(v5, 1, *(double *)(a2 + 8)))
      {
        uint64_t v6 = (sqlite3_stmt *)sub_100019240(v18);
        if (sub_1003B7480(v6, 2, *(float *)(a2 + 16)))
        {
          size_t v7 = (sqlite3_stmt *)sub_100019240(v18);
          if (sub_1003B7480(v7, 3, *(float *)(a2 + 24)))
          {
            int v8 = (sqlite3_stmt *)sub_100019240(v18);
            if (sub_1003B7480(v8, 4, *(float *)(a2 + 36)))
            {
              uint64_t v9 = (sqlite3_stmt *)sub_100019240(v18);
              if (sub_1003B7480(v9, 5, *(float *)(a2 + 32)))
              {
                char v10 = (sqlite3_stmt *)sub_100019240(v18);
                if (sub_1003B7480(v10, 6, *(float *)(a2 + 20)))
                {
                  uint64_t v11 = (sqlite3_stmt *)sub_100019240(v18);
                  if (sub_1003B7480(v11, 7, *(float *)(a2 + 28)))
                  {
                    uint64_t v12 = (sqlite3_stmt *)sub_100019240(v18);
                    if (sub_1003C2AF0(v12, 8, *(_DWORD *)(a2 + 40)))
                    {
                      uint64_t v13 = *(void *)(a1 + 80);
                      uint64_t v14 = (sqlite3_stmt *)sub_100019240(v18);
                      sub_1003BB2BC(v13, v14);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    else
    {
      if (qword_1019346B0 != -1) {
        dispatch_once(&qword_1019346B0, &stru_1018419B8);
      }
      uint64_t v15 = (os_log_s *)qword_1019346B8;
      if (os_log_type_enabled((os_log_t)qword_1019346B8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "[SmoothedGaitMetricsRecorderDb] Invalid SQL statement",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346B0 != -1) {
          dispatch_once(&qword_1019346B0, &stru_1018419B8);
        }
        __int16 v17 = 0;
        unint64_t v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346B8,  16LL,  "[SmoothedGaitMetricsRecorderDb] Invalid SQL statement",  &v17,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLMobility::SmoothedGaitMetricsRecorderDb::insertRecordUL(const SmoothedGaitMetrics &, BOOL)",  "%s\n",  v16);
      }
    }

    uint64_t result = v18;
    uint64_t v18 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_1005B699C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8LL))(a12);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1005B69CC@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[111] < 0) {
    return (char *)sub_1010DD48C((_BYTE *)a2, *((void **)result + 11), *((void *)result + 12));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 88);
  *(void *)(a2 + 16) = *((void *)result + 13);
  return result;
}

char *sub_1005B69F8@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[39] < 0) {
    return (char *)sub_1010DD48C((_BYTE *)a2, *((void **)result + 2), *((void *)result + 3));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 1);
  *(void *)(a2 + 16) = *((void *)result + 4);
  return result;
}

uint64_t sub_1005B6A24(uint64_t a1, char *a2, const char **a3, const std::string::value_type **a4)
{
  if (!sub_1003B79FC(*(void *)(a1 + 80), a2))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101841AD0);
    }
    int v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s needs autoincrement migration",  (uint8_t *)buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101841AD0);
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      __int16 v131 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s needs autoincrement migration",  &__p,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbC onstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLMobility::SmoothedGaitMetri cs, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  (const char *)v131);
      if (v131 != buf) {
        free(v131);
      }
    }

    memset(&__p, 0, sizeof(__p));
    sub_1010DDBC0(buf, a2);
    uint64_t v9 = std::string::append(buf, "AutoIncr");
    __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t cap = v9->__r_.__value_.__l.__cap_;
    *(_OWORD *)int v140 = v10;
    v9->__r_.__value_.__l.__size_ = 0LL;
    v9->__r_.__value_.__l.__cap_ = 0LL;
    v9->__r_.__value_.__r.__words[0] = 0LL;
    sub_1010DDBC0(buf, a2);
    uint64_t v11 = std::string::append(buf, "Index");
    __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    int64_t v139 = v11->__r_.__value_.__l.__cap_;
    *(_OWORD *)double v138 = v12;
    v11->__r_.__value_.__l.__size_ = 0LL;
    v11->__r_.__value_.__l.__cap_ = 0LL;
    v11->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003C0454(*(void *)(a1 + 80));
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v14 = buf;
    sub_1000392EC((uint64_t)buf, size + 21);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v14 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (size)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v14, p_p, size);
    }

    strcpy((char *)v14 + size, "DROP TABLE IF EXISTS ");
    if (cap >= 0) {
      unint64_t v16 = v140;
    }
    else {
      unint64_t v16 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v17 = HIBYTE(cap);
    }
    else {
      std::string::size_type v17 = (std::string::size_type)v140[1];
    }
    uint64_t v18 = std::string::append(buf, (const std::string::value_type *)v16, v17);
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v20 = v18->__r_.__value_.__s.__size_;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v19;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v20;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v20 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v19 = __p.__r_.__value_.__r.__words[0];
    }

    if (v20 >= 0) {
      float v21 = &__p;
    }
    else {
      float v21 = (std::string *)v19;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v21, buf);
    std::string::size_type v22 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v23 = sqlite3_step(v22);
    std::string::size_type v24 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v24) {
      (*(void (**)(std::string::size_type))(*(void *)v24 + 8LL))(v24);
    }
    if (v23 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v25 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v25 = __p.__r_.__value_.__l.__size_;
    }
    std::stringbuf::string_type v26 = &v145;
    sub_1000392EC((uint64_t)&v145, v25 + 13);
    if ((v145.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::stringbuf::string_type v26 = (std::string *)v145.__r_.__value_.__r.__words[0];
    }
    if (v25)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v26, v27, v25);
    }

    strcpy((char *)v26 + v25, "CREATE TABLE ");
    if (cap >= 0) {
      std::stringbuf::string_type v28 = v140;
    }
    else {
      std::stringbuf::string_type v28 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v29 = HIBYTE(cap);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)v140[1];
    }
    uint64_t v30 = std::string::append(&v145, (const std::string::value_type *)v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v137.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    std::string::size_type v32 = std::string::append(&v137, " (");
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003BE030(a3, 1, 1, (uint64_t)&v136);
    if ((v136.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v34 = &v136;
    }
    else {
      uint64_t v34 = (std::string *)v136.__r_.__value_.__r.__words[0];
    }
    if ((v136.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v35 = v136.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v35 = v136.__r_.__value_.__l.__size_;
    }
    int v36 = std::string::append(&v146, (const std::string::value_type *)v34, v35);
    __int128 v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v36->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0LL;
    v36->__r_.__value_.__l.__cap_ = 0LL;
    v36->__r_.__value_.__r.__words[0] = 0LL;
    char v38 = std::string::append(buf, ")");
    std::string::size_type v39 = v38->__r_.__value_.__r.__words[0];
    v143.__r_.__value_.__r.__words[0] = v38->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v143.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v40 = v38->__r_.__value_.__s.__size_;
    v38->__r_.__value_.__l.__size_ = 0LL;
    v38->__r_.__value_.__l.__cap_ = 0LL;
    v38->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v39;
    __p.__r_.__value_.__l.__size_ = v143.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v143.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v40;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      float v41 = &__p;
    }
    else {
      float v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v41, buf);
    float v42 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v43 = sqlite3_step(v42);
    std::string::size_type v44 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v44) {
      (*(void (**)(std::string::size_type))(*(void *)v44 + 8LL))(v44);
    }
    if (v43 != 101) {
      goto LABEL_234;
    }
    sub_1003BE030(a3, 0, 0, (uint64_t)buf);
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v45 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v45 = __p.__r_.__value_.__l.__size_;
    }
    float v46 = &v142;
    sub_1000392EC((uint64_t)&v142, v45 + 12);
    if ((v142.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      float v46 = (std::string *)v142.__r_.__value_.__r.__words[0];
    }
    if (v45)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        float v47 = &__p;
      }
      else {
        float v47 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v46, v47, v45);
    }

    strcpy((char *)v46 + v45, "INSERT INTO ");
    if (cap >= 0) {
      float v48 = v140;
    }
    else {
      float v48 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v49 = HIBYTE(cap);
    }
    else {
      std::string::size_type v49 = (std::string::size_type)v140[1];
    }
    float v50 = std::string::append(&v142, (const std::string::value_type *)v48, v49);
    __int128 v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v135.__r_.__value_.__l.__cap_ = v50->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v135.__r_.__value_.__l.__data_ = v51;
    v50->__r_.__value_.__l.__size_ = 0LL;
    v50->__r_.__value_.__l.__cap_ = 0LL;
    v50->__r_.__value_.__r.__words[0] = 0LL;
    float v52 = std::string::append(&v135, " (");
    __int128 v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v143.__r_.__value_.__l.__cap_ = v52->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v143.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0LL;
    v52->__r_.__value_.__l.__cap_ = 0LL;
    v52->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      float v54 = buf;
    }
    else {
      float v54 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v55 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v55 = buf[0].__r_.__value_.__l.__size_;
    }
    float v56 = std::string::append(&v143, (const std::string::value_type *)v54, v55);
    __int128 v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    v136.__r_.__value_.__l.__cap_ = v56->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v136.__r_.__value_.__l.__data_ = v57;
    v56->__r_.__value_.__l.__size_ = 0LL;
    v56->__r_.__value_.__l.__cap_ = 0LL;
    v56->__r_.__value_.__r.__words[0] = 0LL;
    BOOL v58 = std::string::append(&v136, ") SELECT ");
    __int128 v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v145.__r_.__value_.__l.__cap_ = v58->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v145.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0LL;
    v58->__r_.__value_.__l.__cap_ = 0LL;
    v58->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v60 = buf;
    }
    else {
      uint64_t v60 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v61 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v61 = buf[0].__r_.__value_.__l.__size_;
    }
    unint64_t v62 = std::string::append(&v145, (const std::string::value_type *)v60, v61);
    __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v137.__r_.__value_.__l.__cap_ = v62->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0LL;
    v62->__r_.__value_.__l.__cap_ = 0LL;
    v62->__r_.__value_.__r.__words[0] = 0LL;
    unint64_t v64 = std::string::append(&v137, " FROM ");
    __int128 v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v64->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0LL;
    v64->__r_.__value_.__l.__cap_ = 0LL;
    v64->__r_.__value_.__r.__words[0] = 0LL;
    int v66 = std::string::append(&v146, a2);
    std::string::size_type v67 = v66->__r_.__value_.__r.__words[0];
    v144[0] = v66->__r_.__value_.__l.__size_;
    *(void *)((char *)v144 + 7) = *(std::string::size_type *)((char *)&v66->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v68 = v66->__r_.__value_.__s.__size_;
    v66->__r_.__value_.__l.__size_ = 0LL;
    v66->__r_.__value_.__l.__cap_ = 0LL;
    v66->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v67;
    __p.__r_.__value_.__l.__size_ = v144[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v144 + 7);
    __p.__r_.__value_.__s.__size_ = v68;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v69 = &__p;
    }
    else {
      int v69 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v69, &v146);
    uint64_t v70 = (sqlite3_stmt *)sub_100019240((uint64_t)v146.__r_.__value_.__l.__data_);
    int v71 = sqlite3_step(v70);
    std::string::size_type v72 = v146.__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = 0LL;
    if (v72) {
      (*(void (**)(std::string::size_type))(*(void *)v72 + 8LL))(v72);
    }
    if (v71 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v73 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v73 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v74 = buf;
    sub_1000392EC((uint64_t)buf, v73 + 11);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v74 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (v73)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v75 = &__p;
      }
      else {
        uint64_t v75 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v74, v75, v73);
    }

    strcpy((char *)v74 + v73, "DROP TABLE ");
    id v76 = std::string::append(buf, a2);
    std::string::size_type v77 = v76->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v76->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v76->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v78 = v76->__r_.__value_.__s.__size_;
    v76->__r_.__value_.__l.__size_ = 0LL;
    v76->__r_.__value_.__l.__cap_ = 0LL;
    v76->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v77;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v78;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v78 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v77 = __p.__r_.__value_.__r.__words[0];
    }

    if (v78 >= 0) {
      uint64_t v79 = &__p;
    }
    else {
      uint64_t v79 = (std::string *)v77;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v79, buf);
    uint64_t v80 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v81 = sqlite3_step(v80);
    std::string::size_type v82 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v82) {
      (*(void (**)(std::string::size_type))(*(void *)v82 + 8LL))(v82);
    }
    if (v81 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v83 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v83 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v84 = &v137;
    sub_1000392EC((uint64_t)&v137, v83 + 12);
    if ((v137.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v84 = (std::string *)v137.__r_.__value_.__r.__words[0];
    }
    if (v83)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        unsigned int v85 = &__p;
      }
      else {
        unsigned int v85 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v84, v85, v83);
    }

    strcpy((char *)v84 + v83, "ALTER TABLE ");
    if (cap >= 0) {
      int v86 = v140;
    }
    else {
      int v86 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v87 = HIBYTE(cap);
    }
    else {
      std::string::size_type v87 = (std::string::size_type)v140[1];
    }
    uint64_t v88 = std::string::append(&v137, (const std::string::value_type *)v86, v87);
    __int128 v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v88->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v89;
    v88->__r_.__value_.__l.__size_ = 0LL;
    v88->__r_.__value_.__l.__cap_ = 0LL;
    v88->__r_.__value_.__r.__words[0] = 0LL;
    int v90 = std::string::append(&v146, " RENAME TO ");
    __int128 v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v90->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v91;
    v90->__r_.__value_.__l.__size_ = 0LL;
    v90->__r_.__value_.__l.__cap_ = 0LL;
    v90->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v92 = std::string::append(buf, a2);
    std::string::size_type v93 = v92->__r_.__value_.__r.__words[0];
    v145.__r_.__value_.__r.__words[0] = v92->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v94 = v92->__r_.__value_.__s.__size_;
    v92->__r_.__value_.__l.__size_ = 0LL;
    v92->__r_.__value_.__l.__cap_ = 0LL;
    v92->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v93;
    __p.__r_.__value_.__l.__size_ = v145.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v94;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v95 = &__p;
    }
    else {
      int v95 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v95, buf);
    uint64_t v96 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v97 = sqlite3_step(v96);
    std::string::size_type v98 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v98) {
      (*(void (**)(std::string::size_type))(*(void *)v98 + 8LL))(v98);
    }
    if (v97 != 101) {
      goto LABEL_234;
    }
    sub_1003BAFA4(a4, buf);
    std::string::size_type v99 = buf[0].__r_.__value_.__s.__size_;
    unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v99 = buf[0].__r_.__value_.__l.__size_;
    }
    if (v99)
    {
      std::string::assign(&__p, "");
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size_t v101 = __p.__r_.__value_.__s.__size_;
      }
      else {
        size_t v101 = __p.__r_.__value_.__l.__size_;
      }
      double v102 = &v135;
      sub_1000392EC((uint64_t)&v135, v101 + 13);
      if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        double v102 = (std::string *)v135.__r_.__value_.__r.__words[0];
      }
      if (v101)
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v103 = &__p;
        }
        else {
          uint64_t v103 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        memmove(v102, v103, v101);
      }

      strcpy((char *)v102 + v101, "CREATE INDEX ");
      if (v139 >= 0) {
        __int128 v104 = v138;
      }
      else {
        __int128 v104 = (void **)v138[0];
      }
      if (v139 >= 0) {
        std::string::size_type v105 = HIBYTE(v139);
      }
      else {
        std::string::size_type v105 = (std::string::size_type)v138[1];
      }
      int v106 = std::string::append(&v135, (const std::string::value_type *)v104, v105);
      __int128 v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
      v143.__r_.__value_.__l.__cap_ = v106->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v143.__r_.__value_.__l.__data_ = v107;
      v106->__r_.__value_.__l.__size_ = 0LL;
      v106->__r_.__value_.__l.__cap_ = 0LL;
      v106->__r_.__value_.__r.__words[0] = 0LL;
      double v108 = std::string::append(&v143, " ON ");
      __int128 v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
      v136.__r_.__value_.__l.__cap_ = v108->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v136.__r_.__value_.__l.__data_ = v109;
      v108->__r_.__value_.__l.__size_ = 0LL;
      v108->__r_.__value_.__l.__cap_ = 0LL;
      v108->__r_.__value_.__r.__words[0] = 0LL;
      double v110 = std::string::append(&v136, a2);
      __int128 v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
      v145.__r_.__value_.__l.__cap_ = v110->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v145.__r_.__value_.__l.__data_ = v111;
      v110->__r_.__value_.__l.__size_ = 0LL;
      v110->__r_.__value_.__l.__cap_ = 0LL;
      v110->__r_.__value_.__r.__words[0] = 0LL;
      double v112 = std::string::append(&v145, " (");
      __int128 v113 = *(_OWORD *)&v112->__r_.__value_.__l.__data_;
      v137.__r_.__value_.__l.__cap_ = v112->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v113;
      v112->__r_.__value_.__l.__size_ = 0LL;
      v112->__r_.__value_.__l.__cap_ = 0LL;
      v112->__r_.__value_.__r.__words[0] = 0LL;
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        unint64_t v114 = buf;
      }
      else {
        unint64_t v114 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
      }
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v115 = buf[0].__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v115 = buf[0].__r_.__value_.__l.__size_;
      }
      unint64_t v116 = std::string::append(&v137, (const std::string::value_type *)v114, v115);
      __int128 v117 = *(_OWORD *)&v116->__r_.__value_.__l.__data_;
      v146.__r_.__value_.__l.__cap_ = v116->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v117;
      v116->__r_.__value_.__l.__size_ = 0LL;
      v116->__r_.__value_.__l.__cap_ = 0LL;
      v116->__r_.__value_.__r.__words[0] = 0LL;
      __int128 v118 = std::string::append(&v146, ")");
      std::string::size_type v119 = v118->__r_.__value_.__r.__words[0];
      v142.__r_.__value_.__r.__words[0] = v118->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)v142.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v118->__r_.__value_.__r.__words[1] + 7);
      unsigned __int8 v120 = v118->__r_.__value_.__s.__size_;
      v118->__r_.__value_.__l.__size_ = 0LL;
      v118->__r_.__value_.__l.__cap_ = 0LL;
      v118->__r_.__value_.__r.__words[0] = 0LL;
      __p.__r_.__value_.__r.__words[0] = v119;
      __p.__r_.__value_.__l.__size_ = v142.__r_.__value_.__r.__words[0];
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v142.__r_.__value_.__r.__words + 7);
      __p.__r_.__value_.__s.__size_ = v120;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v121 = &__p;
      }
      else {
        uint64_t v121 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(*(void *)(a1 + 80), (char *)v121, &v146);
      int v122 = (sqlite3_stmt *)sub_100019240((uint64_t)v146.__r_.__value_.__l.__data_);
      int v123 = sqlite3_step(v122);
      std::string::size_type v124 = v146.__r_.__value_.__r.__words[0];
      v146.__r_.__value_.__r.__words[0] = 0LL;
      if (v124) {
        (*(void (**)(std::string::size_type))(*(void *)v124 + 8LL))(v124);
      }
      unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    }

    else
    {
      int v123 = 101;
    }

    if ((v100 & 0x80) != 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
    if (v123 == 101)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101841AD0);
      }
      int v125 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s autoincrement migration succeeded",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101841AD0);
        }
        LODWORD(v146.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v134) = 12;
        __int16 v133 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s autoincrement migration succeeded",  &v146,  v134);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>::migrateD bConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLMobility::SmoothedGaitM etrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  (const char *)v133);
        if (v133 != buf) {
          free(v133);
        }
      }

      sub_1003C05BC(*(void *)(a1 + 80));
      char v126 = 0;
    }

    else
    {
LABEL_234:
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101841AD0);
      }
      uint64_t v127 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_FAULT,  "%{public}s autoincrement migration failed",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101841AD0);
        }
        LODWORD(v146.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v134) = 12;
        int v132 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "%{public}s autoincrement migration failed",  &v146,  v134);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>::migrateD bConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = CLMobility::SmoothedGaitM etrics, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  (const char *)v132);
        if (v132 != buf) {
          free(v132);
        }
      }

      sub_1003C0E18(*(void *)(a1 + 80));
      char v126 = 1;
    }

    if (SHIBYTE(v139) < 0) {
      operator delete(v138[0]);
    }
    if (SHIBYTE(cap) < 0) {
      operator delete(v140[0]);
    }
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v126 & 1) != 0) {
        goto LABEL_246;
      }
    }

    else if ((v126 & 1) != 0)
    {
      goto LABEL_246;
    }

    return 1LL;
  }

void sub_1005B7BBC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1005B7EDC(void *a1, void **a2, double a3, double a4)
{
  int v8 = a1 + 9;
  if ((sub_100D8A92C(a1 + 9) & 1) != 0)
  {
    if (sub_100D8A92C(v8))
    {
      sub_10000CE18((uint64_t)buf);
      uint64_t v9 = sub_10000CF44(&v40, (uint64_t)"SELECT * FROM ", 14LL);
      (*(void (**)(_BYTE *__return_ptr, void *))(*a1 + 64LL))(__p, a1);
      if (__p[23] >= 0) {
        __int128 v10 = __p;
      }
      else {
        __int128 v10 = *(_BYTE **)__p;
      }
      if (__p[23] >= 0) {
        uint64_t v11 = __p[23];
      }
      else {
        uint64_t v11 = *(void *)&__p[8];
      }
      __int128 v12 = sub_10000CF44(v9, (uint64_t)v10, v11);
      sub_10000CF44(v12, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY startTime ASC", 62LL);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      uint64_t v13 = a1[10];
      std::stringbuf::str((std::stringbuf::string_type *)__p, &v41);
      if (__p[23] >= 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = *(char **)__p;
      }
      sub_1003C0D54(v13, v14, &v37);
      uint64_t v15 = v37;
      uint64_t v37 = 0LL;
      uint64_t v38 = v15;
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      unint64_t v16 = (sqlite3_stmt *)sub_100019240(v15);
      if (sub_1003B7480(v16, 1, a3))
      {
        std::string::size_type v17 = (sqlite3_stmt *)sub_100019240(v15);
        if (sub_1003B7480(v17, 2, a4))
        {
          *(_DWORD *)std::string __p = 0;
          memset(&__p[8], 0, 36);
          while (!sub_1005B83C8(&v38, (uint64_t)__p))
          {
            uint64_t v18 = a2[1];
            unint64_t v19 = (unint64_t)a2[2];
            if ((unint64_t)v18 >= v19)
            {
              unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * (((char *)v18 - (_BYTE *)*a2) >> 4);
              unint64_t v22 = v21 + 1;
              if (v21 + 1 > 0x555555555555555LL) {
                sub_100007008();
              }
              unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - (void)*a2) >> 4);
              if (2 * v23 > v22) {
                unint64_t v22 = 2 * v23;
              }
              if (v23 >= 0x2AAAAAAAAAAAAAALL) {
                unint64_t v24 = 0x555555555555555LL;
              }
              else {
                unint64_t v24 = v22;
              }
              if (v24) {
                size_t v25 = (char *)sub_1000BB1F4((uint64_t)(a2 + 2), v24);
              }
              else {
                size_t v25 = 0LL;
              }
              std::stringbuf::string_type v26 = &v25[48 * v21];
              *(_OWORD *)std::stringbuf::string_type v26 = *(_OWORD *)__p;
              *((_OWORD *)v26 + 1) = *(_OWORD *)&__p[16];
              *((_OWORD *)v26 + 2) = *(_OWORD *)&__p[32];
              std::stringbuf::string_type v28 = (char *)*a2;
              uint64_t v27 = (char *)a2[1];
              std::string::size_type v29 = v26;
              if (v27 != *a2)
              {
                do
                {
                  __int128 v30 = *((_OWORD *)v27 - 3);
                  __int128 v31 = *((_OWORD *)v27 - 2);
                  *(_OWORD *)((char *)v29 - 20) = *(_OWORD *)(v27 - 20);
                  *(v29 - 3) = v30;
                  *(v29 - 2) = v31;
                  v29 -= 3;
                  v27 -= 48;
                }

                while (v27 != v28);
                uint64_t v27 = (char *)*a2;
              }

              signed __int8 v20 = v26 + 48;
              *a2 = v29;
              a2[1] = v26 + 48;
              a2[2] = &v25[48 * v24];
              if (v27) {
                operator delete(v27);
              }
            }

            else
            {
              *uint64_t v18 = *(_OWORD *)__p;
              v18[1] = *(_OWORD *)&__p[16];
              _DWORD v18[2] = *(_OWORD *)&__p[32];
              signed __int8 v20 = v18 + 3;
            }

            a2[1] = v20;
          }
        }
      }

      if (v15) {
        (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
      }
      uint64_t v40 = v34;
      std::streambuf::~streambuf(&v41);
      std::ios::~ios(&v42);
    }

    return 100LL;
  }

  else
  {
    if (qword_1019346B0 != -1) {
      dispatch_once(&qword_1019346B0, &stru_1018419B8);
    }
    std::string::size_type v32 = (os_log_s *)qword_1019346B8;
    if (os_log_type_enabled((os_log_t)qword_1019346B8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "SmoothedGaitMetricsHistory not accessible",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346B0 != -1) {
        dispatch_once(&qword_1019346B0, &stru_1018419B8);
      }
      *(_WORD *)std::string __p = 0;
      std::string::size_type v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346B8,  2LL,  "SmoothedGaitMetricsHistory not accessible",  __p,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CMError CLMobility::SmoothedGaitMetricsRecorderDb::querySmoothedGaitMetricsInTimeRange(CFAbsoluteTime, C FAbsoluteTime, std::vector<SmoothedGaitMetrics> &) const",  "%s\n",  v35);
    }

    return 109LL;
  }

void sub_1005B8364( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a22);
  _Unwind_Resume(a1);
}

uint64_t sub_1005B83C8(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  sub_1005B8438(a1, a2);
  return 0LL;
}

uint64_t sub_1005B8424(uint64_t a1, void **a2, double a3, double a4)
{
  return sub_1005B7EDC((void *)(a1 - 352), a2, a3, a4);
}

uint64_t sub_1005B842C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return sub_1005B8438(a2, a3);
}

uint64_t sub_1005B8438(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)a2 = sqlite3_column_int(v4, 0);
  int v5 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + _Block_object_dispose(va, 8) = sqlite3_column_double(v5, 1);
  uint64_t v6 = (sqlite3_stmt *)sub_100019240(*a1);
  float v7 = sqlite3_column_double(v6, 2);
  *(float *)(a2 + 16) = v7;
  int v8 = (sqlite3_stmt *)sub_100019240(*a1);
  float v9 = sqlite3_column_double(v8, 3);
  *(float *)(a2 + 24) = v9;
  __int128 v10 = (sqlite3_stmt *)sub_100019240(*a1);
  float v11 = sqlite3_column_double(v10, 4);
  *(float *)(a2 + 36) = v11;
  __int128 v12 = (sqlite3_stmt *)sub_100019240(*a1);
  float v13 = sqlite3_column_double(v12, 5);
  *(float *)(a2 + 32) = v13;
  uint64_t v14 = (sqlite3_stmt *)sub_100019240(*a1);
  float v15 = sqlite3_column_double(v14, 6);
  *(float *)(a2 + 20) = v15;
  unint64_t v16 = (sqlite3_stmt *)sub_100019240(*a1);
  float v17 = sqlite3_column_double(v16, 7);
  *(float *)(a2 + 2_Block_object_dispose(va, 8) = v17;
  uint64_t v18 = (sqlite3_stmt *)sub_100019240(*a1);
  uint64_t result = sqlite3_column_int(v18, 8);
  *(_DWORD *)(a2 + 40) = result;
  return result;
}

uint64_t sub_1005B8524(void *a1, _OWORD *a2)
{
  int v5 = a1 + 14;
  uint64_t v4 = a1[14];
  uint64_t v6 = a1 + 9;
  unint64_t v19 = a1 + 14;
  (*(void (**)(void *))(v4 + 16))(a1 + 14);
  __int16 v20 = 256;
  if ((sub_100D8A92C(v6) & 1) != 0)
  {
    LODWORD(v18[0]) = 0;
    memset((char *)v18 + 8, 0, 36);
    int v7 = (*(uint64_t (**)(void *, _OWORD *))(*a1 + 104LL))(a1, v18);
    if (v7)
    {
      if (v7 == 1)
      {
        if (qword_1019346B0 != -1) {
          dispatch_once(&qword_1019346B0, &stru_1018419B8);
        }
        __int128 v12 = (os_log_s *)qword_1019346B8;
        if (os_log_type_enabled((os_log_t)qword_1019346B8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)std::stringbuf::string_type buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "[SmoothedGaitMetricsHistory] Most recent smoothed gait metrics: No recent records in database",  buf,  2u);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_33;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1019346B0 != -1) {
          dispatch_once(&qword_1019346B0, &stru_1018419B8);
        }
        v17[0] = 0;
        float v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346B8,  2LL,  "[SmoothedGaitMetricsHistory] Most recent smoothed gait metrics: No recent records in database",  v17,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CMError CLMobility::SmoothedGaitMetricsRecorderDb::mostRecentSmoothedGaitMetrics(SmoothedGaitMetrics &) const",  "%s\n",  v9);
      }

      else if (v7 == 2)
      {
        if (qword_1019346B0 != -1) {
          dispatch_once(&qword_1019346B0, &stru_1018419B8);
        }
        int v8 = (os_log_s *)qword_1019346B8;
        if (os_log_type_enabled((os_log_t)qword_1019346B8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::stringbuf::string_type buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "[SmoothedGaitMetricsHistory] Most recent smoothed gait metrics: Query error",  buf,  2u);
        }

        if (!sub_1002921D0(115, 0)) {
          goto LABEL_33;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1019346B0 != -1) {
          dispatch_once(&qword_1019346B0, &stru_1018419B8);
        }
        v17[0] = 0;
        float v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346B8,  16LL,  "[SmoothedGaitMetricsHistory] Most recent smoothed gait metrics: Query error",  v17,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CMError CLMobility::SmoothedGaitMetricsRecorderDb::mostRecentSmoothedGaitMetrics(SmoothedGaitMetrics &) const",  "%s\n",  v9);
      }

      else
      {
        if (qword_1019346B0 != -1) {
          dispatch_once(&qword_1019346B0, &stru_1018419B8);
        }
        uint64_t v14 = (os_log_s *)qword_1019346B8;
        if (os_log_type_enabled((os_log_t)qword_1019346B8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::stringbuf::string_type buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "[SmoothedGaitMetricsHistory] Most recent smoothed gait metrics: unexpected return type",  buf,  2u);
        }

        if (!sub_1002921D0(115, 0)) {
          goto LABEL_33;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1019346B0 != -1) {
          dispatch_once(&qword_1019346B0, &stru_1018419B8);
        }
        v17[0] = 0;
        float v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346B8,  16LL,  "[SmoothedGaitMetricsHistory] Most recent smoothed gait metrics: unexpected return type",  v17,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CMError CLMobility::SmoothedGaitMetricsRecorderDb::mostRecentSmoothedGaitMetrics(SmoothedGaitMetrics &) const",  "%s\n",  v9);
      }
    }

    else
    {
      __int128 v13 = v18[1];
      *a2 = v18[0];
      a2[1] = v13;
      *(_OWORD *)((char *)a2 + 2_Block_object_dispose(va, 8) = *(_OWORD *)((char *)&v18[1] + 12);
    }

void sub_1005B8AC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
}

uint64_t sub_1005B8AF8(uint64_t a1, _OWORD *a2)
{
  return sub_1005B8524((void *)(a1 - 352), a2);
}

uint64_t sub_1005B8B00(void *a1, uint64_t a2)
{
  return sub_1001B3964(a1, a2, 0LL);
}

uint64_t sub_1005B8B08(uint64_t a1, uint64_t a2)
{
  return sub_1001B3964((void *)(a1 - 352), a2, 0LL);
}

uint64_t sub_1005B8B14(uint64_t *a1, uint64_t a2)
{
  double Current = CFAbsoluteTimeGetCurrent();
  sub_100B14CF8(a1 + 45, &v13);
  int v5 = (sqlite3_stmt *)sub_100019240(v13);
  if (sub_1003B7480(v5, 1, Current - *(double *)(*(void *)(a2 + 8) - 24LL)))
  {
    uint64_t v6 = a1[10];
    int v7 = (sqlite3_stmt *)sub_100019240(v13);
    sub_1003BB2BC(v6, v7);
    uint64_t v8 = (*(int (**)(uint64_t *))(*a1 + 152))(a1);
  }

  else
  {
    uint64_t v8 = -1LL;
  }

  sub_1003C05BC(a1[10]);
  uint64_t v9 = a1[10];
  else {
    uint64_t v10 = *(void *)(v9 + 88);
  }
  sub_1003C1EC0(v9, v10);
  uint64_t v11 = v13;
  uint64_t v13 = 0LL;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
  }
  return v8;
}

void sub_1005B8C1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005B8C40(uint64_t a1, uint64_t a2)
{
  return sub_1005B8B14((uint64_t *)(a1 - 72), a2);
}

uint64_t sub_1005B8C48(uint64_t a1, char **a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_100B14CF8((uint64_t *)(a1 + 376), &v22);
    sub_1003C0454(*(void *)(a1 + 80));
    *(_DWORD *)unint64_t v21 = 0;
    memset(&v21[8], 0, 36);
    while (!sub_1005B83C8(&v22, (uint64_t)v21))
    {
      int v5 = a2[1];
      unint64_t v6 = (unint64_t)a2[2];
      if ((unint64_t)v5 >= v6)
      {
        unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a2) >> 4);
        unint64_t v10 = v9 + 1;
        if (v9 + 1 > 0x555555555555555LL) {
          sub_100007008();
        }
        unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (void)*a2) >> 4);
        if (2 * v11 > v10) {
          unint64_t v10 = 2 * v11;
        }
        if (v11 >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v12 = 0x555555555555555LL;
        }
        else {
          unint64_t v12 = v10;
        }
        if (v12) {
          uint64_t v13 = (char *)sub_1000BB1F4((uint64_t)(a2 + 2), v12);
        }
        else {
          uint64_t v13 = 0LL;
        }
        uint64_t v14 = &v13[48 * v9];
        __int128 v15 = *(_OWORD *)&v21[16];
        *(_OWORD *)uint64_t v14 = *(_OWORD *)v21;
        *((_OWORD *)v14 + 1) = v15;
        *((_OWORD *)v14 + 2) = *(_OWORD *)&v21[32];
        float v17 = *a2;
        unint64_t v16 = a2[1];
        uint64_t v18 = v14;
        if (v16 != *a2)
        {
          do
          {
            __int128 v19 = *((_OWORD *)v16 - 3);
            __int128 v20 = *((_OWORD *)v16 - 2);
            *(_OWORD *)(v18 - 20) = *(_OWORD *)(v16 - 20);
            *((_OWORD *)v18 - 3) = v19;
            *((_OWORD *)v18 - 2) = v20;
            v18 -= 48;
            v16 -= 48;
          }

          while (v16 != v17);
          unint64_t v16 = *a2;
        }

        uint64_t v8 = v14 + 48;
        *a2 = v18;
        a2[1] = v14 + 48;
        a2[2] = &v13[48 * v12];
        if (v16) {
          operator delete(v16);
        }
      }

      else
      {
        __int128 v7 = *(_OWORD *)&v21[16];
        *(_OWORD *)int v5 = *(_OWORD *)v21;
        *((_OWORD *)v5 + 1) = v7;
        *((_OWORD *)v5 + 2) = *(_OWORD *)&v21[32];
        uint64_t v8 = v5 + 48;
      }

      a2[1] = v8;
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    uint64_t result = v22;
    uint64_t v22 = 0LL;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

void sub_1005B8E04( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    (*(void (**)(uint64_t))(*(void *)a16 + 8LL))(a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005B8E30(uint64_t a1)
{
  uint64_t v3 = (sqlite3_stmt *)sub_100019240(v8);
  int v4 = sqlite3_step(v3);
  if (v4 == 100)
  {
    int v5 = (sqlite3_stmt *)sub_100019240(v8);
    uint64_t v1 = sqlite3_column_int(v5, 0);
  }

  uint64_t v6 = v8;
  uint64_t v8 = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  if (v4 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_1005B8EC0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005B8EE8(uint64_t a1)
{
  return sub_1005B8E30(a1 - 72);
}

uint64_t sub_1005B8EF0(void *a1, void **a2, double a3, double a4)
{
  unint64_t v10 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v43);
  if ((SHIBYTE(v44) & 0x80000000) == 0)
  {
    if (HIBYTE(v44)) {
      goto LABEL_3;
    }
LABEL_40:
    sub_10123F9F4(v10);
    goto LABEL_41;
  }

  int v4 = (std::stringbuf *)v43[1];
  operator delete(v43[0]);
  if (!v4) {
    goto LABEL_40;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v43);
  unint64_t v11 = sub_10000CF44(&v44, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(_BYTE *__return_ptr, void *))(*a1 + 64LL))(__p, a1);
  if (__p[23] >= 0) {
    unint64_t v12 = __p;
  }
  else {
    unint64_t v12 = *(_BYTE **)__p;
  }
  if (__p[23] >= 0) {
    uint64_t v13 = __p[23];
  }
  else {
    uint64_t v13 = *(void *)&__p[8];
  }
  uint64_t v14 = sub_10000CF44(v11, (uint64_t)v12, v13);
  sub_10000CF44(v14, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v15 = a1[10];
  int v4 = &v45;
  std::stringbuf::str((std::stringbuf::string_type *)__p, &v45);
  if (__p[23] >= 0) {
    unint64_t v16 = __p;
  }
  else {
    unint64_t v16 = *(char **)__p;
  }
  sub_1003C0D54(v15, v16, &v41);
  uint64_t v5 = v41;
  uint64_t v41 = 0LL;
  uint64_t v42 = v5;
  if ((__p[23] & 0x80000000) != 0) {
    operator delete(*(void **)__p);
  }
  float v17 = (sqlite3_stmt *)sub_100019240(v5);
  if (sub_1003B7480(v17, 1, a3))
  {
    uint64_t v18 = (sqlite3_stmt *)sub_100019240(v5);
    if (sub_1003B7480(v18, 2, a4))
    {
      *(_DWORD *)std::string __p = 0;
      memset(&__p[8], 0, 36);
      while (1)
      {
        uint64_t v19 = sub_1001BA11C((uint64_t)a1, &v42, (uint64_t)__p);
        if ((_DWORD)v19) {
          break;
        }
        __int128 v20 = a2[1];
        unint64_t v21 = (unint64_t)a2[2];
        if ((unint64_t)v20 >= v21)
        {
          unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * (((char *)v20 - (_BYTE *)*a2) >> 4);
          unint64_t v26 = v25 + 1;
          if (v25 + 1 > 0x555555555555555LL) {
            sub_100007008();
          }
          unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v21 - (void)*a2) >> 4);
          if (2 * v27 > v26) {
            unint64_t v26 = 2 * v27;
          }
          if (v27 >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v28 = 0x555555555555555LL;
          }
          else {
            unint64_t v28 = v26;
          }
          if (v28) {
            std::string::size_type v29 = (char *)sub_1000BB1F4((uint64_t)(a2 + 2), v28);
          }
          else {
            std::string::size_type v29 = 0LL;
          }
          __int128 v30 = &v29[48 * v25];
          __int128 v31 = *(_OWORD *)__p;
          __int128 v32 = *(_OWORD *)&__p[32];
          *((_OWORD *)v30 + 1) = *(_OWORD *)&__p[16];
          *((_OWORD *)v30 + 2) = v32;
          *(_OWORD *)__int128 v30 = v31;
          uint64_t v34 = (char *)*a2;
          __int128 v33 = (char *)a2[1];
          std::string::size_type v35 = v30;
          if (v33 != *a2)
          {
            do
            {
              __int128 v36 = *((_OWORD *)v33 - 3);
              __int128 v37 = *((_OWORD *)v33 - 2);
              *(_OWORD *)((char *)v35 - 20) = *(_OWORD *)(v33 - 20);
              *(v35 - 3) = v36;
              *(v35 - 2) = v37;
              v35 -= 3;
              v33 -= 48;
            }

            while (v33 != v34);
            __int128 v33 = (char *)*a2;
          }

          unint64_t v24 = v30 + 48;
          *a2 = v35;
          a2[1] = v30 + 48;
          a2[2] = &v29[48 * v28];
          if (v33) {
            operator delete(v33);
          }
        }

        else
        {
          __int128 v22 = *(_OWORD *)__p;
          __int128 v23 = *(_OWORD *)&__p[32];
          v20[1] = *(_OWORD *)&__p[16];
          _OWORD v20[2] = v23;
          *__int128 v20 = v22;
          unint64_t v24 = v20 + 3;
        }

        a2[1] = v24;
      }

      uint64_t v5 = v42;
      goto LABEL_43;
    }
  }

void sub_1005B9244( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_1005B92AC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v38 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101841AD0);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)std::stringbuf::string_type buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101841AD0);
      }
      __int128 v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)std::stringbuf::string_type buf = 134349056;
        *(void *)uint64_t v42 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101841AD0);
        }
        uint64_t v34 = *(void *)(a1 + 216);
        int v39 = 134349056;
        uint64_t v40 = v34;
        std::string::size_type v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v39,  12);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>:: setDatabaseAccessible() [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataP rotectionPolicy]",  "%s\n",  v35);
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101841AD0);
    }
    unint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)std::stringbuf::string_type buf = 68289539;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v11;
      __int16 v45 = 2049;
      uint64_t v46 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    unint64_t v13 = *(void *)(a1 + 208);
    uint64_t v14 = *(void *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 192);
    unint64_t v16 = (void *)(v14 + 8 * (v13 / 0x55));
    unsigned int v37 = v9;
    if (v15 == v14) {
      unint64_t v17 = 0LL;
    }
    else {
      unint64_t v17 = *v16 + 48 * (v13 % 0x55);
    }
    while (1)
    {
      if (v15 == v14)
      {
        unint64_t v23 = 0LL;
      }

      else
      {
        unint64_t v22 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        unint64_t v23 = *(void *)(v14 + 8 * (v22 / 0x55)) + 48 * (v22 % 0x55);
      }

      if (v17 == v23) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_101841AF0);
      }
      unint64_t v24 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_101841AF0);
        }
        LOWORD(v39) = 0;
        LODWORD(v36) = 2;
        unint64_t v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v39,  v36);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>:: setDatabaseAccessible() [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLActivityDB::ClassBDataP rotectionPolicy]",  "%s\n",  v26);
      }

      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v17, 1LL);
      v17 += 48LL;
      if (v17 - *v16 == 4080)
      {
        unint64_t v25 = v16[1];
        ++v16;
        unint64_t v17 = v25;
      }

      uint64_t v14 = *(void *)(a1 + 184);
      uint64_t v15 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    uint64_t v9 = v37;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101841AD0);
    }
    uint64_t v18 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      uint64_t v19 = (void *)(a1 + 88);
      *(_DWORD *)std::stringbuf::string_type buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101841AD0);
      }
    }

    __int128 v20 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      unint64_t v21 = (void *)(a1 + 88);
      *(_DWORD *)std::stringbuf::string_type buf = 68289282;
      *(_DWORD *)uint64_t v42 = 0;
      *(_WORD *)&v42[4] = 2082;
      *(void *)&v42[6] = "";
      __int16 v43 = 2082;
      uint64_t v44 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12_Block_object_dispose(va, 8) = 1;
  }

  unint64_t v27 = *(void ***)(a1 + 184);
  uint64_t v28 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v29 = v28 - (void)v27;
  if (v29 >= 0x11)
  {
    do
    {
      operator delete(*v27);
      uint64_t v30 = *(void *)(a1 + 192);
      unint64_t v27 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v27;
      unint64_t v29 = v30 - (void)v27;
    }

    while (v29 > 0x10);
  }

  if (v29 >> 3 == 1)
  {
    uint64_t v31 = 42LL;
  }

  else
  {
    if (v29 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v31 = 85LL;
  }

  *(void *)(a1 + 20_Block_object_dispose(va, 8) = v31;
LABEL_61:
  __int128 v32 = *(void **)(a1 + 144);
  if (v32)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_1005B99D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

__n128 sub_1005B9A0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  __int128 v4 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 2_Block_object_dispose(va, 8) = *(_OWORD *)(a3 + 28);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

id *sub_1005B9A20(uint64_t a1, __int128 *a2, char a3)
{
  v33[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v33[1] = 0LL;
  if (*(double *)(a1 + 232) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, __int128 *))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, __int128 *))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v33);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  int v29 = 0;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  int v32 = 0;
  int v6 = (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 104LL))(a1, &v29);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, __int128 *, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101841AD0);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101841AD0);
        }
        LOWORD(v34) = 0;
        uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v34,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>:: sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLActiv ityDB::ClassBDataProtectionPolicy]",  "%s\n",  v15);
      }

      goto LABEL_43;
    }

    double v7 = *((double *)a2 + 1);
    double v8 = *(double *)&v30;
    double v9 = v7 - *(double *)&v30;
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101841AD0);
      }
      unint64_t v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *((void *)a2 + 1);
        *(_DWORD *)std::stringbuf::string_type buf = 134349312;
        double v39 = *(double *)&v30;
        __int16 v40 = 2050;
        uint64_t v41 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101841AD0);
        }
        uint64_t v23 = *((void *)a2 + 1);
        int v34 = 134349312;
        double v35 = *(double *)&v30;
        __int16 v36 = 2050;
        uint64_t v37 = v23;
        unint64_t v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v34,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>:: sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLActiv ityDB::ClassBDataProtectionPolicy]",  "%s\n",  v24);
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *((double *)a2 + 1);
      double v8 = *(double *)&v30;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101841AD0);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *((double *)a2 + 1);
          *(_DWORD *)std::stringbuf::string_type buf = 134217984;
          double v39 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_101841AD0);
          }
          double v25 = *((double *)a2 + 1);
          int v34 = 134217984;
          double v35 = v25;
          unint64_t v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v34));
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy> ::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLA ctivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v26);
        }

        (*(void (**)(uint64_t, __int128 *))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v16 = v7 - v8;
      double v17 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v28 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_101841AD0);
        double v17 = v28;
      }

      double v18 = v16 - v17;
      uint64_t v19 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 134217984;
        double v39 = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101841AD0);
        }
        int v34 = 134217984;
        double v35 = v18;
        unint64_t v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v34));
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLMobility::SmoothedGaitMetrics, CLActivityDB::ClassBDataProtectionPolicy>:: sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLMobility::SmoothedGaitMetrics, DataProtectionPolicy = CLActiv ityDB::ClassBDataProtectionPolicy]",  "%s\n",  v27);
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v18);
    }

    (*(void (**)(uint64_t, int *, uint64_t, __int128 *))(*(void *)a1 + 144LL))(a1, &v29, a1 + 224, a2);
    (*(void (**)(uint64_t, __int128 *, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_1005BA178( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_1005BA1A4(void *a1, uint64_t a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    __int128 v20 = (_Unwind_Exception *)sub_10123FB60(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  uint64_t v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 8)))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_1005BA404(void *a1, double a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_10123FCCC(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_1005BA63C(void *a1, uint64_t a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_10123FE38(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  uint64_t v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  double v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

uint64_t sub_1005BA864(uint64_t a1)
{
  return sub_1005B92AC(a1 - 72);
}

void sub_1005BA86C(id a1)
{
  qword_1019346B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Mobility");
}

uint64_t sub_1005BA898(uint64_t *a1, char **a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v37);
  if ((SHIBYTE(v38) & 0x80000000) == 0)
  {
    if (HIBYTE(v38)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_10123FFA4(v4);
LABEL_44:
    sub_100007008();
  }

  __int128 v33 = v37[1];
  operator delete(v37[0]);
  if (!v33) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v37);
    int v6 = sub_10000CF44(&v38, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(_BYTE *__return_ptr, uint64_t *))(*a1 + 64))(__p, a1);
    if (__p[23] >= 0) {
      double v7 = __p;
    }
    else {
      double v7 = *(_BYTE **)__p;
    }
    if (__p[23] >= 0) {
      uint64_t v8 = __p[23];
    }
    else {
      uint64_t v8 = *(void *)&__p[8];
    }
    uint64_t v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v10 = a1[10];
    std::stringbuf::str((std::stringbuf::string_type *)__p, &v39);
    if (__p[23] >= 0) {
      uint64_t v11 = __p;
    }
    else {
      uint64_t v11 = *(char **)__p;
    }
    sub_1003C0D54(v10, v11, &v35);
    uint64_t v12 = v35;
    uint64_t v35 = 0LL;
    uint64_t v36 = v12;
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    sub_1003C0454(a1[10]);
    *(_DWORD *)std::stringbuf::string_type __p = 0;
    memset(&__p[8], 0, 36);
    while (!sub_1001BA11C((uint64_t)a1, &v36, (uint64_t)__p))
    {
      uint64_t v13 = a2[1];
      unint64_t v14 = (unint64_t)a2[2];
      if ((unint64_t)v13 >= v14)
      {
        unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((v13 - *a2) >> 4);
        unint64_t v19 = v18 + 1;
        if (v18 + 1 > 0x555555555555555LL) {
          goto LABEL_44;
        }
        unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - (void)*a2) >> 4);
        if (2 * v20 > v19) {
          unint64_t v19 = 2 * v20;
        }
        if (v20 >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v21 = 0x555555555555555LL;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21) {
          uint64_t v22 = (char *)sub_1000BB1F4((uint64_t)(a2 + 2), v21);
        }
        else {
          uint64_t v22 = 0LL;
        }
        uint64_t v23 = &v22[48 * v18];
        __int128 v24 = *(_OWORD *)__p;
        __int128 v25 = *(_OWORD *)&__p[32];
        *((_OWORD *)v23 + 1) = *(_OWORD *)&__p[16];
        *((_OWORD *)v23 + 2) = v25;
        *(_OWORD *)uint64_t v23 = v24;
        unint64_t v27 = *a2;
        uint64_t v26 = a2[1];
        double v28 = v23;
        if (v26 != *a2)
        {
          do
          {
            __int128 v29 = *((_OWORD *)v26 - 3);
            __int128 v30 = *((_OWORD *)v26 - 2);
            *(_OWORD *)(v28 - 20) = *(_OWORD *)(v26 - 20);
            *((_OWORD *)v28 - 3) = v29;
            *((_OWORD *)v28 - 2) = v30;
            v28 -= 48;
            v26 -= 48;
          }

          while (v26 != v27);
          uint64_t v26 = *a2;
        }

        uint64_t v17 = v23 + 48;
        *a2 = v28;
        a2[1] = v23 + 48;
        a2[2] = &v22[48 * v21];
        if (v26) {
          operator delete(v26);
        }
      }

      else
      {
        __int128 v15 = *(_OWORD *)__p;
        __int128 v16 = *(_OWORD *)&__p[32];
        *((_OWORD *)v13 + 1) = *(_OWORD *)&__p[16];
        *((_OWORD *)v13 + 2) = v16;
        *(_OWORD *)uint64_t v13 = v15;
        uint64_t v17 = v13 + 48;
      }

      a2[1] = v17;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v31 = v36;
    uint64_t v36 = 0LL;
    if (v31) {
      (*(void (**)(uint64_t))(*(void *)v31 + 8LL))(v31);
    }
    *(void **)((char *)v37
    uint64_t v38 = v32;
    std::streambuf::~streambuf(&v39);
    return std::ios::~ios(&v40);
  }

  return result;
}

void sub_1005BABA8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21)
{
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
  }
  sub_1011F8850((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void sub_1005BAC10(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_1005BAC3C(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

void sub_1005BAD0C(id a1)
{
  qword_1019971E8 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLBacklightStateNotifierSilo");
}

uint64_t sub_1005BADC0(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1005BAF20;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_1019971F8 != -1) {
    dispatch_once(&qword_1019971F8, block);
  }
  return qword_1019A1178;
}

uint64_t sub_1005BAF20(uint64_t a1)
{
  uint64_t v2 = operator new(0x78uLL);
  uint64_t result = sub_1005BAF84((uint64_t)v2, "CLBacklightStateNotifier", *(void **)(a1 + 32));
  *uint64_t v2 = off_101841B40;
  v2[14] = 0LL;
  qword_1019A1178 = (uint64_t)v2;
  return result;
}

void sub_1005BAF70(_Unwind_Exception *a1)
{
}

uint64_t sub_1005BAF84(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_101841CC8;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = [a3 silo];
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 10_Block_object_dispose(va, 8) = 0;
  return a1;
}

void sub_1005BB004(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1005BB020(uint64_t a1)
{
  *(void *)a1 = off_101841B40;
  *(_BYTE *)(a1 + 10_Block_object_dispose(va, 8) = 1;

  *(void *)(a1 + sub_10004AD90(v15 - 112) = 0LL;
  return sub_1005BB064(a1);
}

uint64_t sub_1005BB064(uint64_t a1)
{
  *(void *)a1 = off_101841CC8;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

void sub_1005BB0DC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1005BB020(a1);
  operator delete(v1);
}

void sub_1005BB0F0(uint64_t a1)
{
  *(_BYTE *)(a1 + 10_Block_object_dispose(va, 8) = 1;

  *(void *)(a1 + sub_10004AD90(v15 - 112) = 0LL;
}

void *sub_1005BB120@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

uint64_t sub_1005BB198()
{
  return 1LL;
}

uint64_t sub_1005BB1A0()
{
  return 1LL;
}

_BYTE *sub_1005BB1A8(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 63) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }

  else
  {
    __int128 v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 40) = v4;
  }

  uint64_t result = (_BYTE *)(a1 + 64);
  __int128 v6 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)uint64_t result = v6;
  return result;
}

void sub_1005BB22C(_Unwind_Exception *exception_object)
{
}

void sub_1005BB248(uint64_t a1)
{
}

uint64_t sub_1005BB28C(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = &off_101841E18;
  *(void *)(a1 + _Block_object_dispose(va, 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  else {
    uint64_t v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

void sub_1005BB360(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLBacklightStateNotifier");
  sub_1005BB28C((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  *uint64_t v8 = off_101841C20;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005BB3FC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

void sub_1005BB428(uint64_t a1, uint64_t a2)
{
  HIDWORD(v14) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)std::stringbuf::string_type buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v14 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101841C98);
      }
      char v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v11 = (void *)(a1 + 8);
        *(_DWORD *)std::stringbuf::string_type buf = 136446466;
        unint64_t v20 = v11;
        __int16 v21 = 1026;
        int v22 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101841C98);
        }
        uint64_t v12 = (void *)(a1 + 8);
        int v15 = 136446466;
        __int128 v16 = v12;
        __int16 v17 = 1026;
        int v18 = a2;
        LODWORD(v14) = 18;
        id v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                        &v15,
                        v14);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLBacklightStateNotifier_Type::Notification, CLBacklightStateNotifier_Type::Notificati onData, char, char>::removeClient(int) [Notification_T = CLBacklightStateNotifier_Type::Notification, Notifica tionData_T = CLBacklightStateNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
      }
    }
  }

uint64_t sub_1005BB69C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_101938A88);
}

BOOL sub_1005BB6B0(uint64_t a1, int a2, int *a3, char *a4)
{
  int v40 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      uint64_t v39 = v10;
      int v16 = *a3;
      uint64_t v19 = *(void *)(v10 + 48);
      uint64_t v18 = v10 + 48;
      uint64_t v17 = v19;
      if (!v19) {
        goto LABEL_31;
      }
      uint64_t v20 = v18;
      do
      {
        int v21 = *(_DWORD *)(v17 + 28);
        BOOL v22 = v21 < v16;
        if (v21 >= v16) {
          uint64_t v23 = (uint64_t *)v17;
        }
        else {
          uint64_t v23 = (uint64_t *)(v17 + 8);
        }
        if (!v22) {
          uint64_t v20 = v17;
        }
        uint64_t v17 = *v23;
      }

      while (*v23);
      if (v20 == v18 || v16 < *(_DWORD *)(v20 + 28)) {
LABEL_31:
      }
        uint64_t v20 = v18;
      uint64_t v24 = *(void *)(a1 + 64);
      if (!v24) {
        goto LABEL_42;
      }
      uint64_t v25 = a1 + 64;
      do
      {
        int v26 = *(_DWORD *)(v24 + 32);
        BOOL v27 = v26 < v16;
        if (v26 >= v16) {
          double v28 = (uint64_t *)v24;
        }
        else {
          double v28 = (uint64_t *)(v24 + 8);
        }
        if (!v27) {
          uint64_t v25 = v24;
        }
        uint64_t v24 = *v28;
      }

      while (*v28);
      if (v25 != a1 + 64 && v16 >= *(_DWORD *)(v25 + 32))
      {
        *(void *)uint64_t v41 = v25;
        uint64_t v33 = *(void *)(v25 + 56);
        char v34 = *a4;
        *(void *)std::stringbuf::string_type buf = &v40;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v25 + 40), &v40, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v34;
        *(_DWORD *)std::stringbuf::string_type buf = 0;
        *(_OWORD *)&uint8_t buf[8] = 0u;
        *(_OWORD *)std::stringbuf::string_type __p = 0u;
        __int128 v46 = 0u;
        char v47 = 0;
        if (v20 == v18
          && (*(unsigned int (**)(uint64_t, int *, _BYTE *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          uint64_t v35 = sub_1005BDC9C((uint64_t)buf);
          sub_1005BD4E0((_BYTE *)a1, (uint64_t)&v39, (uint64_t)v41, v35);
        }

        if (SHIBYTE(v46) < 0) {
          operator delete(__p[1]);
        }
        if (SHIBYTE(__p[0]) < 0) {
          operator delete(*(void **)&buf[8]);
        }
        if (v33) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        *(void *)uint64_t v41 = a1 + 64;
        char v29 = byte_101938A89;
        HIDWORD(v3_Block_object_dispose(va, 8) = v16;
        *(void *)std::stringbuf::string_type buf = (char *)&v38 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v38 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 80) = v29;
        HIDWORD(v3_Block_object_dispose(va, 8) = *a3;
        *(void *)std::stringbuf::string_type buf = (char *)&v38 + 4;
        __int128 v30 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v38 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v30 + 8);
        char v31 = *a4;
        HIDWORD(v3_Block_object_dispose(va, 8) = *a3;
        *(void *)std::stringbuf::string_type buf = (char *)&v38 + 4;
        uint64_t v32 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v38 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)std::stringbuf::string_type buf = &v40;
        *((_BYTE *)sub_1004EF3D4(v32 + 5, &v40, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v31;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v20 == v18)
      {
        *(_DWORD *)std::stringbuf::string_type buf = *a3;
        sub_10004A8FC((uint64_t **)(v39 + 40), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101841C98);
  }
  uint64_t v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    int v15 = (void *)(a1 + 8);
    *(_DWORD *)std::stringbuf::string_type buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL result = sub_1002921D0(115, 0);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841C98);
    }
    uint64_t v36 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t v41 = 136446466;
    *(void *)&v41[4] = v36;
    __int16 v42 = 1026;
    int v43 = a2;
    LODWORD(v3_Block_object_dispose(va, 8) = 18;
    uint64_t v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                    v41,
                    v38);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLBacklightStateNotifier_Type::Notification, CLBacklightStateNotifier_Type::NotificationDa ta, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLBacklightStateNotifier_Type::Notification, NotificationData_T = CLBacklightStateNotifier_Type::NotificationDat a, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v37);
    if (v37 != buf) {
      free(v37);
    }
    return 0LL;
  }

  return result;
}

void sub_1005BBB48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

BOOL sub_1005BBB68(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        int v21 = (uint64_t *)v15;
      }
      else {
        int v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841C98);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)std::stringbuf::string_type buf = 136446466;
      char v29 = v11;
      __int16 v30 = 1026;
      int v31 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101841C98);
      }
      BOOL v22 = (void *)(a1 + 8);
      int v24 = 136446466;
      uint64_t v25 = v22;
      __int16 v26 = 1026;
      int v27 = a2;
      uint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                      &v24,
                      18);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLBacklightStateNotifier_Type::Notification, CLBacklightStateNotifier_Type::Notification Data, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLBacklightStateNotifier_Type ::Notification, NotificationData_T = CLBacklightStateNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      return 0LL;
    }
  }

  return result;
}

BOOL sub_1005BBDE8(char *a1, int a2, int *a3)
{
  HIDWORD(v33) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        id v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            id v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            BOOL v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                uint64_t v25 = (uint64_t *)v20;
              }
              else {
                uint64_t v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                BOOL v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v33 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101841C98);
              }
              __int16 v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v27 = a1 + 8;
                if (a1[31] < 0) {
                  int v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v43 >= 0) {
                  double v28 = __p;
                }
                else {
                  double v28 = (void **)__p[0];
                }
                *(_DWORD *)std::stringbuf::string_type buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v35 = 2082;
                uint64_t v36 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v43 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101841C98);
                }
                char v29 = a1 + 8;
                if (a1[31] < 0) {
                  char v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v37 >= 0) {
                  int v31 = buf;
                }
                else {
                  int v31 = *(_BYTE **)buf;
                }
                int v38 = 136446466;
                uint64_t v39 = v29;
                __int16 v40 = 2082;
                uint64_t v41 = v31;
                LODWORD(v33) = 22;
                uint64_t v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                                &v38,
                                v33);
                if (v37 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLBacklightStateNotifier_Type::Notification, CLBacklightStateNotifier_Type::No tificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLBacklightStateNotifier_Type::Notification, NotificationData_T = CLBacklightStateNotifier_Type::Notif icationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v32);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_1005BC170(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v7 = *a2;
  uint64_t v8 = v3;
  do
  {
    int v9 = *(_DWORD *)(v4 + 32);
    BOOL v10 = v9 < v7;
    if (v9 >= v7) {
      int v11 = (uint64_t *)v4;
    }
    else {
      int v11 = (uint64_t *)(v4 + 8);
    }
    if (!v10) {
      uint64_t v8 = v4;
    }
    uint64_t v4 = *v11;
  }

  while (*v11);
  if (v8 == v3) {
    return 0LL;
  }
  if (v7 < *(_DWORD *)(v8 + 32)) {
    return 0LL;
  }
  uint64_t v12 = *(void *)(v8 + 64);
  if (!v12) {
    return 0LL;
  }
  *(_DWORD *)a3 = *(_DWORD *)v12;
  std::string::operator=((std::string *)(a3 + 8), (const std::string *)(v12 + 8));
  std::string::operator=((std::string *)(a3 + 32), (const std::string *)(v12 + 32));
  *(_BYTE *)(a3 + 56) = *(_BYTE *)(v12 + 56);
  return 1LL;
}

uint64_t sub_1005BC208(uint64_t a1, int *a2, uint64_t a3)
{
  int v10 = *a2;
  uint64_t v12 = &v10;
  uint64_t v5 = sub_10023347C((uint64_t **)(a1 + 56), &v10, (uint64_t)&unk_1012CF090, &v12);
  sub_10005F550((uint64_t)(v5 + 8), &v11);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1))
  {
    int v7 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return 1LL;
}

void sub_1005BC2B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1005BC2C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = 0;
  *(_OWORD *)uint64_t v5 = 0u;
  *(_OWORD *)std::stringbuf::string_type __p = 0u;
  __int128 v7 = 0u;
  char v8 = 0;
  (*(void (**)(uint64_t, uint64_t, int *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  &v4,  a3,  a4,  0LL);
  if (SHIBYTE(v7) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v5[0]);
  }
}

void sub_1005BC33C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1005BC350(uint64_t a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    int v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841C98);
    }
    __int128 v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v12 = (void *)(a1 + 8);
      id v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)std::stringbuf::string_type buf = 68289794;
      *(_DWORD *)__int128 v65 = 0;
      *(_WORD *)&v65[4] = 2082;
      *(void *)&v65[6] = "";
      *(_WORD *)&v65[14] = 2082;
      *(void *)&v65[16] = "activity";
      __int16 v66 = 2082;
      std::string::size_type v67 = v12;
      __int16 v68 = 2050;
      int v69 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    uint64_t v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      uint64_t v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)uint64_t v70 = &v70[8];
      memset(&v70[8], 0, 24);
      int v71 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v70);
      int v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v69;
      if (v69)
      {
        p_shared_owners = (unint64_t *)&v69->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&v65[4], *(void **)&v65[12]);
      BOOL v24 = v71;
      if (v71)
      {
        uint64_t v25 = (unint64_t *)&v71->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v70, *(void **)&v70[8]);
    }

    if (a4)
    {
      sub_1005BD5BC(a3, buf);
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      int v27 = *(std::__shared_weak_count **)&v65[4];
      if (*(void *)&v65[4])
      {
        double v28 = (unint64_t *)(*(void *)&v65[4] + 8LL);
        do
          unint64_t v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    uint64_t v30 = sub_1005BCFF0(a3);
    if (a5 == -1)
    {
      sub_1005BD10C((void *)a1, (int *)a2, v30);
    }

    else
    {
      uint64_t v31 = a1 + 88;
      uint64_t v32 = *(void *)(a1 + 88);
      if (!v32) {
        goto LABEL_48;
      }
      uint64_t v33 = a1 + 88;
      do
      {
        int v34 = *(_DWORD *)(v32 + 32);
        BOOL v35 = v34 < a5;
        if (v34 >= a5) {
          uint64_t v36 = (uint64_t *)v32;
        }
        else {
          uint64_t v36 = (uint64_t *)(v32 + 8);
        }
        if (!v35) {
          uint64_t v33 = v32;
        }
        uint64_t v32 = *v36;
      }

      while (*v36);
      if (v33 == v31 || *(_DWORD *)(v33 + 32) > a5) {
LABEL_48:
      }
        uint64_t v33 = a1 + 88;
      uint64_t v62 = v33;
      unint64_t v37 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v38 = *a2;
      uint64_t v39 = (__n128 *)(a1 + 64);
      do
      {
        int v40 = *(_DWORD *)(v37 + 32);
        BOOL v41 = v40 < v38;
        if (v40 >= v38) {
          __int16 v42 = (unint64_t *)v37;
        }
        else {
          __int16 v42 = (unint64_t *)(v37 + 8);
        }
        if (!v41) {
          uint64_t v39 = (__n128 *)v37;
        }
        unint64_t v37 = *v42;
      }

      while (*v42);
      if (v39 == v15 || v38 < (signed __int32)v39[2].n128_u32[0])
      {
LABEL_59:
        std::string::size_type v61 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101841C98);
        }
        char v43 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v44 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v70, a1, a2);
          if (v70[23] >= 0) {
            __int16 v45 = v70;
          }
          else {
            __int16 v45 = *(_BYTE **)v70;
          }
          *(_DWORD *)std::stringbuf::string_type buf = 136315650;
          *(void *)__int128 v65 = v44;
          *(_WORD *)&v65[8] = 1024;
          *(_DWORD *)&v65[10] = a5;
          *(_WORD *)&v65[14] = 2080;
          *(void *)&v65[16] = v45;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v70[23] & 0x80000000) != 0) {
            operator delete(*(void **)v70);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_101841C98);
          }
          __int128 v46 = (void *)(a1 + 8);
          uint64_t v47 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v60 >= 0) {
            float v48 = __p;
          }
          else {
            float v48 = (void **)__p[0];
          }
          *(_DWORD *)uint64_t v70 = 136315650;
          *(void *)&v70[4] = v46;
          *(_WORD *)&v70[12] = 1024;
          *(_DWORD *)&v70[14] = a5;
          *(_WORD *)&_BYTE v70[18] = 2080;
          *(void *)&v70[20] = v48;
          std::string::size_type v49 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v47,  2LL,  "%s; client %d has deregistered, not notifying %s",
                          v70,
                          28,
                          v58);
          if (v60 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLBacklightStateNotifier_Type::Notification, CLBacklightStateNotifier_Type::Notifica tionData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Notification_T = CLBacklightStateNotifier_Type::Notification, NotificationData_T = CLBacklightStateNo tifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v49);
        }

        goto LABEL_83;
      }

      std::string::size_type v61 = v39;
      if (v33 == v31) {
        goto LABEL_60;
      }
      uint64_t v52 = v39[3].n128_i64[0];
      float v50 = v39 + 3;
      __int128 v51 = (__n128 *)v52;
      if (!v52) {
        goto LABEL_60;
      }
      int v53 = *(_DWORD *)(v33 + 32);
      float v54 = v50;
      do
      {
        int v55 = v51[1].n128_i32[3];
        BOOL v56 = v55 < v53;
        if (v55 >= v53) {
          __int128 v57 = v51;
        }
        else {
          __int128 v57 = (__n128 *)&v51->n128_i8[8];
        }
        if (!v56) {
          float v54 = v51;
        }
        __int128 v51 = (__n128 *)v57->n128_u64[0];
      }

      while (v57->n128_u64[0]);
      sub_1005BD4E0((_BYTE *)a1, (uint64_t)&v62, (uint64_t)&v61, v30);
    }

void sub_1005BC96C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_1005BC9B8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841C98);
    }
    uint64_t v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)std::stringbuf::string_type buf = 136315138;
      int v34 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101841C98);
      }
      int v4 = (void *)(a1 + 8);
      int v29 = 136315138;
      uint64_t v30 = v4;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
                     (const char *)&v29);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLBacklightStateNotifier_Type::Notification, CLBacklightStateNotifier_Type::Notification Data, char, char>::listClients() [Notification_T = CLBacklightStateNotifier_Type::Notification, NotificationData _T = CLBacklightStateNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841C98);
    }
    uint64_t v6 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      __int128 v7 = (void *)(a1 + 8);
      uint64_t v8 = *(void *)(a1 + 96);
      *(_DWORD *)std::stringbuf::string_type buf = 136315394;
      int v34 = v7;
      __int16 v35 = 2048;
      v36[0] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101841C98);
      }
      uint64_t v25 = (void *)(a1 + 8);
      uint64_t v26 = *(void *)(a1 + 96);
      int v29 = 136315394;
      uint64_t v30 = v25;
      __int16 v31 = 2048;
      v32[0] = v26;
      int v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
                      (const char *)&v29,
                      22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLBacklightStateNotifier_Type::Notification, CLBacklightStateNotifier_Type::Notification Data, char, char>::listClients() [Notification_T = CLBacklightStateNotifier_Type::Notification, NotificationData _T = CLBacklightStateNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v27);
    }

    int v9 = *(void **)(a1 + 80);
    if (v9 != (void *)(a1 + 88))
    {
      int v10 = (void *)(a1 + 8);
      do
      {
        __int128 v11 = (void *)v9[5];
        if (v11 != v9 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_101841C98);
            }
            uint64_t v12 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              id v13 = (void *)(a1 + 8);
              int v14 = *((_DWORD *)v9 + 8);
              int v15 = *((_DWORD *)v11 + 7);
              *(_DWORD *)std::stringbuf::string_type buf = 136315650;
              int v34 = v13;
              __int16 v35 = 1024;
              LODWORD(v36[0]) = v14;
              WORD2(v36[0]) = 1024;
              *(_DWORD *)((char *)v36 + 6) = v15;
              _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101841C98);
              }
              BOOL v19 = (void *)(a1 + 8);
              int v20 = *((_DWORD *)v9 + 8);
              int v21 = *((_DWORD *)v11 + 7);
              int v29 = 136315650;
              uint64_t v30 = v19;
              __int16 v31 = 1024;
              LODWORD(v32[0]) = v20;
              WORD2(v32[0]) = 1024;
              *(_DWORD *)((char *)v32 + 6) = v21;
              BOOL v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                              (const char *)&v29,
                              24,
                              v28);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLBacklightStateNotifier_Type::Notification, CLBacklightStateNotifier_Type::Noti ficationData, char, char>::listClients() [Notification_T = CLBacklightStateNotifier_Type::Notification, NotificationData_T = CLBacklightStateNotifier_Type::NotificationData, NotificationInfo_T = char, Registr ationInfo_T = char]",  "%s\n",  v22);
            }

            signed __int32 v16 = (void *)v11[1];
            if (v16)
            {
              do
              {
                int v17 = v16;
                signed __int32 v16 = (void *)*v16;
              }

              while (v16);
            }

            else
            {
              do
              {
                int v17 = (void *)v11[2];
                BOOL v18 = *v17 == (void)v11;
                __int128 v11 = v17;
              }

              while (!v18);
            }

            __int128 v11 = v17;
          }

          while (v17 != v9 + 6);
        }

        unint64_t v23 = (void *)v9[1];
        if (v23)
        {
          do
          {
            BOOL v24 = v23;
            unint64_t v23 = (void *)*v23;
          }

          while (v23);
        }

        else
        {
          do
          {
            BOOL v24 = (void *)v9[2];
            BOOL v18 = *v24 == (void)v9;
            int v9 = v24;
          }

          while (!v18);
        }

        int v9 = v24;
      }

      while (v24 != (void *)(a1 + 88));
    }
  }

void sub_1005BCF64(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1005BDC3C(a1);
  operator delete(v1);
}

id sub_1005BCF78(uint64_t a1, int a2, void *a3)
{
  id result = sub_1005BD818(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_1005BCFC4(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

CLCppContainer *sub_1005BCFF0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  uint64_t v3 = v2;
  *(_DWORD *)uint64_t v2 = *(_DWORD *)a1;
  if (*(char *)(a1 + 31) < 0)
  {
    sub_1010DD48C(v2 + 8, *(void **)(a1 + 8), *(void *)(a1 + 16));
  }

  else
  {
    *(_OWORD *)(v2 + _Block_object_dispose(va, 8) = *(_OWORD *)(a1 + 8);
    *((void *)v2 + 3) = *(void *)(a1 + 24);
  }

  int v4 = v3 + 32;
  if (*(char *)(a1 + 55) < 0)
  {
    sub_1010DD48C(v4, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }

  else
  {
    *(_OWORD *)int v4 = *(_OWORD *)(a1 + 32);
    *((void *)v3 + 6) = *(void *)(a1 + 48);
  }

  v3[56] = *(_BYTE *)(a1 + 56);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_1005BD7C8;
  v6[3] = &unk_10181D3D0;
  v6[4] = v3;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v3,  v6,  0LL,  64LL);
}

void sub_1005BD0E0(_Unwind_Exception *a1)
{
  if (v1[31] < 0) {
    operator delete(*v2);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1005BD10C(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    uint64_t v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      int v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v4;
        }
        else {
          uint64_t v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          int v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        float v50 = v9;
        id v13 = sub_1005BD818(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        int v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          int v15 = a1 + 11;
          signed __int32 v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            BOOL v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                BOOL v22 = (uint64_t *)v17;
              }
              else {
                BOOL v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                BOOL v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              std::string::size_type v49 = v19;
              sub_1005BD4E0(a1, (uint64_t)&v49, (uint64_t)&v50, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              int v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  uint64_t v32 = (uint64_t *)v27;
                }
                else {
                  uint64_t v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  int v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              float v50 = v29;
              uint64_t v34 = v29[6];
              int v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                __int16 v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    uint64_t v39 = (uint64_t *)v36;
                  }
                  else {
                    uint64_t v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    __int16 v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      __int16 v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      __int16 v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      int v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  char v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      int v14 = v43;
                      char v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      int v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      __int16 v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              std::string::size_type v49 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101841C98);
              }
              BOOL v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                uint64_t v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)std::stringbuf::string_type buf = 136446466;
                BOOL v56 = v25;
                __int16 v57 = 1026;
                int v58 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101841C98);
                }
                __int16 v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v51 = 136446466;
                uint64_t v52 = v45;
                __int16 v53 = 1026;
                int v54 = v46;
                LODWORD(v4_Block_object_dispose(va, 8) = 18;
                uint64_t v47 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                                &v51,
                                v48);
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLBacklightStateNotifier_Type::Notification, CLBacklightStateNotifier_Type::Notificati onData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLBacklightStateNotifier_Type::Notification, NotificationData_T = CLBacklightStateNotifier_Type::Noti ficationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
              }
            }
          }

          while (v14 != v50 + 6);
        }
      }
    }
  }

_BYTE *sub_1005BD4E0(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    __int128 v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(vsub_100210A00(v2 + 13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_1005BD818(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40LL);
    int v14 = (int *)(*(void *)a2 + 32LL);
    uint64_t v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    id result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

void *sub_1005BD5BC@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x58uLL);
  id result = sub_1005BD614(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1005BD600(_Unwind_Exception *a1)
{
}

void *sub_1005BD614(void *a1, uint64_t a2)
{
  a1[2] = 0LL;
  *a1 = off_101841DA8;
  a1[1] = 0LL;
  sub_1005BD6D4((uint64_t)&v4, (uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1005BD660(_Unwind_Exception *a1)
{
}

void sub_1005BD674(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101841DA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005BD688(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101841DA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_1005BD6AC(uint64_t a1)
{
}

_BYTE *sub_1005BD6D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)a2 = *(_DWORD *)a3;
  uint64_t v5 = (_BYTE *)(a2 + 8);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_1010DD48C(v5, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }

  else
  {
    __int128 v6 = *(_OWORD *)(a3 + 8);
    *(void *)(a2 + 24) = *(void *)(a3 + 24);
    *(_OWORD *)uint64_t v5 = v6;
  }

  id result = (_BYTE *)(a2 + 32);
  if (*(char *)(a3 + 55) < 0)
  {
    id result = sub_1010DD48C(result, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }

  else
  {
    __int128 v8 = *(_OWORD *)(a3 + 32);
    *(void *)(a2 + 4_Block_object_dispose(va, 8) = *(void *)(a3 + 48);
    *(_OWORD *)id result = v8;
  }

  *(_BYTE *)(a2 + 56) = *(_BYTE *)(a3 + 56);
  return result;
}

void sub_1005BD768(_Unwind_Exception *exception_object)
{
}

void sub_1005BD784(uint64_t a1, uint64_t a2)
{
}

void sub_1005BD7C8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    operator delete((void *)v1);
  }

id sub_1005BD818(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_1005BD864(a1);
  }
  else {
    return 0LL;
  }
}

id sub_1005BD864(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101841DE8);
    }
    uint64_t v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x800000010130A6F1LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101841DE8);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    char v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101841DE8);
    }
    __int128 v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x800000010130A6F1LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101841DE8);
    }
    LODWORD(v_Block_object_dispose(va, 8) = 134218498;
    HIDWORD(v_Block_object_dispose(va, 8) = (_DWORD)v2;
    char v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  __int128 v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLBacklightStateNotifier_Type::NotificationData, Callback = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:228:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

void sub_1005BDC10(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

uint64_t sub_1005BDC3C(uint64_t a1)
{
  *(void *)a1 = &off_101841E18;
  id v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *id v2 = 0LL;
  *(void *)(a1 + 16) = 0LL;
  return a1;
}

CLCppContainer *sub_1005BDC9C(uint64_t a1)
{
  id v2 = (char *)operator new(0x40uLL);
  uint64_t v3 = v2;
  *(_DWORD *)id v2 = *(_DWORD *)a1;
  if (*(char *)(a1 + 31) < 0)
  {
    sub_1010DD48C(v2 + 8, *(void **)(a1 + 8), *(void *)(a1 + 16));
  }

  else
  {
    *(_OWORD *)(v2 + _Block_object_dispose(va, 8) = *(_OWORD *)(a1 + 8);
    *((void *)v2 + 3) = *(void *)(a1 + 24);
  }

  char v4 = v3 + 32;
  if (*(char *)(a1 + 55) < 0)
  {
    sub_1010DD48C(v4, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }

  else
  {
    *(_OWORD *)char v4 = *(_OWORD *)(a1 + 32);
    *((void *)v3 + 6) = *(void *)(a1 + 48);
  }

  v3[56] = *(_BYTE *)(a1 + 56);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_1005BDDB8;
  v6[3] = &unk_10181D3D0;
  v6[4] = v3;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v3,  v6,  0LL,  64LL);
}

void sub_1005BDD8C(_Unwind_Exception *a1)
{
  if (v1[31] < 0) {
    operator delete(*v2);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1005BDDB8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    operator delete((void *)v1);
  }

uint64_t sub_1005BDE08()
{
  uint64_t result = sub_1004FAB40();
  if ((result & 0x10) != 0)
  {
    uint64_t v1 = operator new(0x90uLL);
    uint64_t result = sub_1005BDE98((uint64_t)v1);
    qword_1019A1180 = (uint64_t)v1;
  }

  return result;
}

void sub_1005BDE40(_Unwind_Exception *a1)
{
}

uint64_t sub_1005BDE54()
{
  if (qword_101997200 != -1) {
    dispatch_once(&qword_101997200, &stru_101841E30);
  }
  return qword_1019A1180;
}

uint64_t sub_1005BDE98(uint64_t a1)
{
  *(void *)sub_1006DC9EC(a1, (uint64_t)"CLPressure", 2) = off_101841E60;
  uint64_t v2 = sub_1006E2838();
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 32) = v2;
  *(_WORD *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0LL;
  *(_DWORD *)(a1 + 72) = 0;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + sub_10004AD90(v15 - 112) = 0x3FF0000000000000LL;
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 136) = 0LL;
  uint64_t v3 = sub_1006E27E8();
  sub_100413284(v3, &v19);
  char v4 = sub_1002A6F64(v19, "LogPressure", (BOOL *)(a1 + 56));
  char v5 = v4;
  __int128 v6 = v20;
  if (!v20) {
    goto LABEL_5;
  }
  p_shared_owners = (unint64_t *)&v20->__shared_owners_;
  do
    unint64_t v8 = __ldaxr(p_shared_owners);
  while (__stlxr(v8 - 1, p_shared_owners));
  if (v8)
  {
LABEL_5:
    if ((v4 & 1) != 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
  std::__shared_weak_count::__release_weak(v6);
  if ((v5 & 1) == 0) {
LABEL_6:
  }
    *(_BYTE *)(a1 + 56) = 0;
LABEL_7:
  sub_101204164((unsigned __int8 *)&v19, "PressureTempMaxUpdateInterval", &qword_10130A730, 0);
  *(void *)(a1 + sub_10004AD90(v15 - 112) = v20;
  if (sub_1004FAA50())
  {
    sub_100C8F484((uint64_t)sub_1005BE174, a1, *(void **)(a1 + 32), &v19);
    uint64_t v9 = v19;
    uint64_t v19 = 0LL;
    uint64_t v10 = *(void *)(a1 + 48);
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = v9;
    if (v10)
    {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
      uint64_t v11 = v19;
      uint64_t v19 = 0LL;
      if (v11) {
        (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
      }
    }

    sub_100DAA9F8((uint64_t)sub_1005BE34C, a1, *(void **)(a1 + 32), &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    uint64_t v13 = *(void *)(a1 + 136);
    *(void *)(a1 + 136) = v12;
    if (v13)
    {
      (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
      uint64_t v14 = v19;
      uint64_t v19 = 0LL;
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
      }
    }

    [*(id *)(*(void *)(a1 + 136) + 16) register:*(void *)(*(void *)(a1 + 136) + 8) forNotification:0 registrationInfo:0];
  }

  if ((sub_1004FAA50() & 1) == 0)
  {
    int v15 = operator new(0x20uLL);
    sub_1005B1CA4(v15);
    sub_1005BE520((uint64_t *)(a1 + 40), (uint64_t)v15);
    uint64_t v16 = *(void *)(a1 + 40);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472LL;
    _DWORD v18[2] = sub_1005BE54C;
    _OWORD v18[3] = &unk_101841E90;
    v18[4] = a1;
    sub_1005B22D0(v16, (uint64_t)&_dispatch_main_q, (uint64_t)v18);
  }

  return a1;
}

void sub_1005BE0E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  uint64_t v19 = v14[17];
  v14[17] = 0LL;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  sub_10000AE14(v16);
  uint64_t v20 = v14[6];
  void v14[6] = 0LL;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  }
  sub_1005BE520(v15, 0LL);
  sub_1006DCAA8(v14);
  _Unwind_Resume(a1);
}

void sub_1005BE174(uint64_t a1, int *a2, _OWORD *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101841EC8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    unint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLPressure::onBias",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841EC8);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      int v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLPressure::onBias, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_1005BE578(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005BE32C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005BE34C(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101841EC8);
  }
  BOOL v7 = os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG);
  if (v7)
  {
    char v12 = 1;
    uint64_t v9 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLPressure::onMotionStateObserverNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v9, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101841EC8);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    BOOL v7 = os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG);
    if (v7)
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v14 = 0;
      __int16 v15 = 2082;
      __int16 v16 = "";
      __int16 v17 = 2082;
      __int16 v18 = "activity";
      __int16 v19 = 2050;
      uint64_t v20 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLPressure::onMotionStateObserverNotification, event:%{public, location:escape_only }s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v12 = 0;
  }

  sub_1005BF2BC(v7, v8, a2, a3);
  if (v12) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005BE500( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005BE520(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    char v4 = (void *)sub_1005B1D30(v3);
    operator delete(v4);
  }

void sub_1005BE54C(uint64_t a1, _OWORD *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = 0;
  sub_1005BE578(v2, (uint64_t)a2, &v3, a2);
}

void sub_1005BE578(uint64_t a1, uint64_t a2, int *a3, _OWORD *a4)
{
  if (qword_101934570 != -1) {
    dispatch_once(&qword_101934570, &stru_101841EE8);
  }
  BOOL v7 = (os_log_s *)qword_101934578;
  if (os_log_type_enabled((os_log_t)qword_101934578, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Received Bias Notification", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934570 != -1) {
      dispatch_once(&qword_101934570, &stru_101841EE8);
    }
    LOWORD(v17[0]) = 0;
    int v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934578,  2LL,  "Received Bias Notification",  v17,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLPressure::onBias(int, const CLPressureBias_Type::Notification &, const CLPressureBias_Type::NotificationData &)",  "%s\n",  v13);
    if (v13 != buf) {
      free(v13);
    }
  }

  if (*a3)
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101841F08);
    }
    uint64_t v8 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_ERROR))
    {
      int v9 = *a3;
      *(_DWORD *)std::stringbuf::string_type buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "Unexpected pressure bias notification.notification,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101841F08);
      }
      int v10 = *a3;
      v17[0] = 67240192;
      v17[1] = v10;
      LODWORD(v14) = 8;
      char v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  16LL,  "Unexpected pressure bias notification.notification,%{public}d",  v17,  v14);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLPressure::onBias(int, const CLPressureBias_Type::Notification &, const CLPressureBias_Type::NotificationData &)",  "%s\n",  v11);
      if (v11 != buf) {
        free(v11);
      }
    }
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type buf = *a4;
    *(_OWORD *)&buf[13] = *(_OWORD *)((char *)a4 + 13);
    uint64_t v12 = sub_1006E27E8();
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472LL;
    _DWORD v15[2] = sub_1005BE954;
    void v15[3] = &unk_1018414E0;
    v15[4] = a1;
    v16[0] = *(_OWORD *)buf;
    *(_OWORD *)((char *)v16 + sub_100210A00(v2 + 13) = *(_OWORD *)&buf[13];
    sub_1006E2970(v12, (uint64_t)v15);
  }

void *sub_1005BE8CC(void *a1)
{
  *a1 = off_101841E60;
  uint64_t v2 = a1[17];
  a1[17] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  sub_10000AE14((uint64_t)(a1 + 15));
  uint64_t v3 = a1[6];
  a1[6] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_1005BE520(a1 + 5, 0LL);
  return sub_1006DCAA8(a1);
}

void sub_1005BE940(void *a1)
{
  uint64_t v1 = sub_1005BE8CC(a1);
  operator delete(v1);
}

uint64_t sub_1005BE954(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  __int128 v2 = *(_OWORD *)(result + 40);
  *(_OWORD *)(v1 + 89) = *(_OWORD *)(result + 53);
  *(_OWORD *)(v1 + 76) = v2;
  return result;
}

uint64_t sub_1005BE9A4(uint64_t a1, float *a2)
{
  uint64_t result = *(void *)(a1 + 120);
  if (result)
  {
    char v4 = (void *)(*(uint64_t (**)(uint64_t, const __CFString *))(*(void *)result + 24LL))( result,  @"AppleVoltageDictionary");
    id v5 = [v4 objectForKeyedSubscript:@"PRESSURE_TEMP"];
    [v5 floatValue];
    *a2 = v6 / 100.0;

    return v5 != 0LL;
  }

  return result;
}

double sub_1005BEA18(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  if (a2 > 1)
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101841F08);
    }
    int v9 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67240192;
      LODWORD(v17) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "Unrecognized pressure notification %{public}d",  buf,  8u);
    }

    double v7 = 0.0;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101841F08);
      }
      int v14 = 67240192;
      LODWORD(v15) = a2;
      int v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  17LL,  "Unrecognized pressure notification %{public}d",  &v14,  8);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CFTimeInterval CLPressure::minimumUpdateIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v13);
    }
  }

  else
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101841F08);
    }
    id v5 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
    {
      uint64_t v6 = *a3;
      *(_DWORD *)std::stringbuf::string_type buf = 134349056;
      uint64_t v17 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Setting pressure data update interval to %{public}f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101841F08);
      }
      uint64_t v11 = *a3;
      int v14 = 134349056;
      uint64_t v15 = v11;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "Setting pressure data update interval to %{public}f",  &v14,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CFTimeInterval CLPressure::minimumUpdateIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v12);
    }

    return sub_1005BED38(a1);
  }

  return v7;
}

double sub_1005BED38(uint64_t a1)
{
  int v2 = 0;
  char v3 = 1;
  double v4 = 0.0;
  do
  {
    char v5 = v3;
    double v6 = sub_1006DDB1C(a1, v2);
    if (v4 == 0.0 || (v6 > 0.0 ? (BOOL v7 = v6 < v4) : (BOOL v7 = 0), v7)) {
      double v4 = v6;
    }
    char v3 = 0;
    int v2 = 1;
  }

  while ((v5 & 1) != 0);
  *(void *)(a1 + 64) = 0LL;
  if (*(void *)(a1 + 40))
  {
    double v8 = sub_1006DDB1C(a1, 1);
    uint64_t v9 = *(void *)(a1 + 40);
    if (v8 == 0.0) {
      sub_1005B226C(v9);
    }
    else {
      sub_1005B1D34(v9);
    }
  }

  if (*(void *)(a1 + 48))
  {
    double v10 = sub_1006DDB1C(a1, 1);
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v13 = *(void *)(v11 + 8);
    uint64_t v12 = *(void **)(v11 + 16);
    if (v10 == 0.0) {
      [v12 unregister:v13 forNotification:0];
    }
    else {
      [v12 register:v13 forNotification:0 registrationInfo:0];
    }
  }

  int v14 = (uint64_t *)(a1 + 120);
  if (!*(void *)(a1 + 120) && (sub_1004FAB40() & 0x10) != 0)
  {
    uint64_t v15 = (uint64_t *)sub_10071542C();
    uint64_t v23 = 0x3100000020LL;
    char v24 = 0;
    sub_10121B774(v15, (uint64_t)&v23, (uint64_t *)buf);
    sub_10005F550(a1 + 120, (__int128 *)buf);
    __int16 v16 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      uint64_t v17 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }

    sub_100719D78(*(uint64_t **)(a1 + 120), (uint64_t)sub_1005BF038, a1);
  }

  sub_10071A73C(*v14, v4);
  uint64_t v19 = sub_10071A7C0(*v14, v4);
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101841F08);
  }
  uint64_t v20 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 134349056;
    *(void *)&uint8_t buf[4] = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Setting pressure batch interval to: %{public}ld us",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101841F08);
    }
    int v25 = 134349056;
    uint64_t v26 = v19;
    BOOL v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "Setting pressure batch interval to: %{public}ld us",  &v25,  12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "CFTimeInterval CLPressure::setPressureUpdateInterval()", "%s\n", v22);
  }

  return v4;
}

void sub_1005BF038(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (IOHIDEventGetType(a4) == 31)
  {
    Floatint Value = IOHIDEventGetFloatValue(a4, 2031616LL);
    *(float *)&double v9 = FloatValue;
    unint64_t TimeStamp = IOHIDEventGetTimeStamp(a4);
    double v8 = sub_101171C7C(TimeStamp);
    sub_1005BF4C8(a1, &v9, &v8);
  }

void sub_1005BF0A4(uint64_t a1, int a2)
{
  if (sub_1004FAA50())
  {
    uint64_t v9 = 0x3FA0E5604189374CLL;
    if (a2) {
      double v4 = &v9;
    }
    else {
      double v4 = (uint64_t *)&unk_10130A730;
    }
    sub_101204164(buf, "PressureTempMaxUpdateInterval", v4, 0);
    *(void *)(a1 + sub_10004AD90(v15 - 112) = *(void *)&v13[4];
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101841F08);
    }
    char v5 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
    {
      double v6 = *(double *)(a1 + 112) * 1000.0;
      *(_DWORD *)std::stringbuf::string_type buf = 134349056;
      *(double *)uint64_t v13 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Temperature update interval set to %{public}f ms",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101841F08);
      }
      double v7 = *(double *)(a1 + 112) * 1000.0;
      int v10 = 134349056;
      double v11 = v7;
      double v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "Temperature update interval set to %{public}f ms",  &v10,  12);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLPressure::setFastTemperatureUpdateInterval(BOOL)", "%s\n", v8);
    }
  }

void sub_1005BF2BC(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (sub_1004FAA50() && !*a3)
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101841F08);
    }
    double v6 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = *(unsigned int *)(a4 + 8);
      *(_DWORD *)std::stringbuf::string_type buf = 134349056;
      uint64_t v13 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Notified of workout event type %{public}ld",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101841F08);
      }
      uint64_t v8 = *(unsigned int *)(a4 + 8);
      int v10 = 134349056;
      uint64_t v11 = v8;
      uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  2LL,  "Notified of workout event type %{public}ld",  &v10,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLPressure::onMotionStateObserverNotification(int, const CLMotionStateObserver_Type::Notification &, const CLMotionStateObserver_Type::NotificationData &)",  "%s\n",  v9);
    }

    if (qword_101997200 != -1) {
      dispatch_once(&qword_101997200, &stru_101841E30);
    }
    if (qword_1019A1180) {
      sub_1005BF0A4(qword_1019A1180, *(_DWORD *)(a4 + 8) != 0);
    }
  }

void sub_1005BF4C8(uint64_t a1, double *a2, double *a3)
{
  if (sub_1006DDB1C(a1, 0) != 0.0 || sub_1006DDB1C(a1, 1) != 0.0)
  {
    double v6 = *a3;
    double v20 = *a3;
    double v7 = *a2;
    double v21 = *a2;
    double v8 = *(double *)(a1 + 64);
    if (v8 == 0.0 || v6 - v8 > *(double *)(a1 + 112))
    {
      int v9 = sub_1005BE9A4(a1, (float *)(a1 + 72));
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101841F08);
      }
      int v10 = (os_log_s *)qword_1019345B8;
      if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 67109120;
        LODWORD(v33) = v9;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Pressure Temperature=%d", buf, 8u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345B0 != -1) {
          dispatch_once(&qword_1019345B0, &stru_101841F08);
        }
        int v22 = 67109120;
        LODWORD(v23) = v9;
        unint64_t v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  2LL,  "Pressure Temperature=%d",  &v22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLPressure::onPressureData(const CLMotionTypePressure &, const CLMotionTypeTimestamp &)",  "%s\n",  v18);
      }

      *(double *)(a1 + 64) = *a3;
    }

    int v11 = *(_DWORD *)(a1 + 72);
    HIDWORD(v21) = v11;
    if (*(_BYTE *)(a1 + 56))
    {
      sub_101125260(buf);
      sub_1011394D4(buf);
      CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
      v44 |= 1u;
      CFAbsoluteTime v42 = Current;
      sub_10119FFA8(v43);
      uint64_t v13 = *((void *)v43 + 1);
      *(_BYTE *)(v13 + 24) |= 1u;
      *(double *)(v13 + _Block_object_dispose(va, 8) = v6;
      uint64_t v14 = *((void *)v43 + 1);
      *(_BYTE *)(v14 + 24) |= 2u;
      *(_DWORD *)(v14 + 16) = LODWORD(v7);
      uint64_t v15 = *((void *)v43 + 1);
      *(_BYTE *)(v15 + 24) |= 4u;
      *(_DWORD *)(v15 + 20) = v11;
      if (qword_1019A1D00 != -1) {
        dispatch_once(&qword_1019A1D00, &stru_101841F28);
      }
      if (qword_1019A1D08) {
        sub_1011CF3D0(qword_1019A1D08, (uint64_t)buf);
      }
      sub_101127D00((PB::Base *)buf);
    }

    if (sub_1006DDB1C(a1, 0) != 0.0) {
      sub_1006DD528(a1, 0LL, (uint64_t)&v20, 16LL);
    }
    if (*(_BYTE *)(a1 + 57)) {
      *(float *)&double v21 = *(float *)&v21
    }
                     + (float)((float)-(float)(*(float *)(a1 + 84)
                                             - (float)(*(float *)(a1 + 80)
    if (sub_1006DDB1C(a1, 1) != 0.0) {
      sub_1006DD528(a1, 1LL, (uint64_t)&v20, 16LL);
    }
    if (qword_101934570 != -1) {
      dispatch_once(&qword_101934570, &stru_101841EE8);
    }
    __int16 v16 = (os_log_s *)qword_101934578;
    if (os_log_type_enabled((os_log_t)qword_101934578, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 136316162;
      uint64_t v33 = "Pressure";
      __int16 v34 = 2048;
      double v35 = *(float *)&v21;
      __int16 v36 = 2048;
      double v37 = *((float *)&v21 + 1);
      __int16 v38 = 2048;
      double v39 = v20;
      __int16 v40 = 2048;
      double v41 = *(float *)&v7;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "Type,%s,pressure,%.6f,temperature,%.3f,timestamp,%f,rawPressure,%.6f",  buf,  0x34u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934570 != -1) {
        dispatch_once(&qword_101934570, &stru_101841EE8);
      }
      int v22 = 136316162;
      uint64_t v23 = "Pressure";
      __int16 v24 = 2048;
      double v25 = *(float *)&v21;
      __int16 v26 = 2048;
      double v27 = *((float *)&v21 + 1);
      __int16 v28 = 2048;
      double v29 = v20;
      __int16 v30 = 2048;
      double v31 = *(float *)&v7;
      LODWORD(vsub_100210A00(v2 + 19) = 52;
      uint64_t v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934578,  2LL,  "Type,%s,pressure,%.6f,temperature,%.3f,timestamp,%f,rawPressure,%.6f",  (const char *)&v22,  v19,  v20,  v21);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLPressure::onPressureData(const CLMotionTypePressure &, const CLMotionTypeTimestamp &)",  "%s\n",  v17);
    }
  }

void sub_1005BFA14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1005BFA34(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_1005BFA60(id a1)
{
  qword_101934578 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Sensors");
}

void sub_1005BFA8C(id a1)
{
  qword_1019345B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pressure");
}

void sub_1005BFB60(id a1)
{
  qword_101997220 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLPredictedWalkDistanceServiceWatchSilo");
}

void sub_1005C004C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

id sub_1005C0080(uint64_t a1, void *a2)
{
  __int128 v2 = *(_OWORD *)(a1 + 80);
  v6[4] = *(_OWORD *)(a1 + 64);
  void v6[5] = v2;
  void v6[6] = *(_OWORD *)(a1 + 96);
  uint64_t v7 = *(void *)(a1 + 112);
  __int128 v3 = *(_OWORD *)(a1 + 16);
  v6[0] = *(_OWORD *)a1;
  v6[1] = v3;
  __int128 v4 = *(_OWORD *)(a1 + 48);
  _DWORD v6[2] = *(_OWORD *)(a1 + 32);
  v6[3] = v4;
  return [a2 onAddBout:v6];
}

id sub_1005C00CC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_1005C00DC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return _[a4 onStepCountNotification:a2 data:a3];
}

id sub_1005C00EC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return _[a4 onUserInfoUpdate:a2 data:a3];
}

id sub_1005C03C4(uint64_t a1, uint64_t a2)
{
  return sub_10039FB50(120.0, a2, 21, *(void **)(a1 + 32), 300LL, 0LL, 0LL, 0LL, 0, 0LL);
}

void sub_1005C0864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t sub_1005C0878(uint64_t a1)
{
  if (qword_1019346C0 != -1) {
    dispatch_once(&qword_1019346C0, &stru_101841F68);
  }
  __int128 v2 = (os_log_s *)qword_1019346C8;
  if (os_log_type_enabled((os_log_t)qword_1019346C8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Aggregating bout records", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346C0 != -1) {
      dispatch_once(&qword_1019346C0, &stru_101841F68);
    }
    v5[0] = 0;
    __int128 v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346C8,  2LL,  "Aggregating bout records",  v5,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLPredictedWalkDistanceServiceWatch setUpAggregationOnTimer]_block_invoke",  "%s\n",  v4);
  }

  return sub_1001B2804(*(void *)(*(void *)(a1 + 32) + 56LL));
}

void sub_1005C0B30(id a1)
{
  qword_1019346C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "PredictedWalkDistance");
}

void sub_1005C0B5C(uint64_t a1, void *a2)
{
  if (a2)
  {
    __int128 v3 = (void *)a2[41];
    if (v3)
    {
      a2[42] = v3;
      operator delete(v3);
    }

    sub_1001B4C40(a2 + 27);
    __int128 v4 = (void *)a2[24];
    if (v4)
    {
      a2[25] = v4;
      operator delete(v4);
    }

    char v5 = (void *)sub_10000AE14((uint64_t)a2);
    operator delete(v5);
  }

uint64_t sub_1005C0BB0()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_101997208, (void *)&_mh_execute_header);
}

uint64_t sub_1005C0E38(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t v7 = (void *)sub_100C6AAF0(a1, a2, a3, a4, a5);
  *uint64_t v7 = off_101841F98;
  void v7[6] = 0LL;
  double v8 = v7 + 6;
  v7[7] = 0LL;
  void v7[8] = 0LL;
  sub_10027EB5C((uint64_t)sub_1005C0F84, a1, a3, &v14);
  uint64_t v9 = v14;
  uint64_t v14 = 0LL;
  uint64_t v10 = *v8;
  *double v8 = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    uint64_t v11 = v14;
    uint64_t v14 = 0LL;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
  }

  *(void *)(a1 + 64) = -[CLAbsoluteAltitudeClientLocal initWithElevationSubscription:]( objc_alloc(&OBJC_CLASS___CLAbsoluteAltitudeClientLocal),  "initWithElevationSubscription:",  a1);
  id v12 = objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "vendor"), "proxyForService:", @"CLBarometerCalibration");
  *(void *)(a1 + 56) = v12;
  objc_msgSend(v12, "registerDelegate:inSilo:", *(void *)(a1 + 64), objc_msgSend(*(id *)(a1 + 8), "silo"));
  [*(id *)(a1 + 56) setDelegateEntityName:"CLElevationSubscription"];
  *(void *)(a1 + 72) = -[CLSettingsMirror initInUniverse:]( objc_alloc(&OBJC_CLASS___CLSettingsMirror),  "initInUniverse:",  *(void *)(a1 + 8));
  return a1;
}

void sub_1005C0F54(_Unwind_Exception *a1)
{
  uint64_t v4 = *v2;
  *__int128 v2 = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_100C6AB50(v1);
  _Unwind_Resume(a1);
}

void sub_1005C0F84(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101842038);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    double v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLElevationSubscription::onOdometerUpdate",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842038);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLElevationSubscription::onOdometerUpdate, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_1005C266C(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005C113C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005C1160(uint64_t a1)
{
  *(void *)a1 = off_101841F98;

  [*(id *)(a1 + 64) setValid:0];
  uint64_t v2 = *(void *)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  [*(id *)(a1 + 72) invalidate];

  *(void *)(a1 + 72) = 0LL;
  uint64_t v3 = *(void *)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return sub_100C6AB50(a1);
}

void sub_1005C11F4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1005C1160(a1);
  operator delete(v1);
}

void *sub_1005C1208@<X0>(uint64_t a1@<X8>)
{
  v24[0] = &off_101842088;
  v24[1] = sub_1005C1670;
  v24[2] = 0LL;
  double v25 = v24;
  sub_1010DDBC0(v26, "kCLConnectionMessageSignificantElevationUpdate");
  sub_1005C301C((uint64_t)&v27, (uint64_t)v24);
  double v21 = &off_101842088;
  v22[0] = sub_1005C1A70;
  v22[1] = 0LL;
  uint64_t v23 = &v21;
  sub_1010DDBC0(v28, "kCLConnectionMessageFilteredElevationUpdate");
  sub_1005C301C((uint64_t)&v29, (uint64_t)&v21);
  v19[0] = &off_101842138;
  v19[1] = sub_1005C1E84;
  _OWORD v19[2] = 0LL;
  double v20 = v19;
  sub_1010DDBC0(v30, "kCLConnectionMessageSignificantElevationDeltaQuery");
  sub_1005C301C((uint64_t)&v31, (uint64_t)v19);
  v17[0] = &off_101842088;
  v17[1] = sub_1005C2270;
  _DWORD v17[2] = 0LL;
  __int16 v18 = v17;
  sub_1010DDBC0(v32, "kCLConnectionMessageAbsoluteAltitudeUpdate");
  sub_1005C301C((uint64_t)&v33, (uint64_t)v17);
  v15[0] = &off_101842138;
  v15[1] = nullsub_268;
  _DWORD v15[2] = 0LL;
  __int16 v16 = v15;
  sub_1010DDBC0(v34, "kCLConnectionMessageElevationProfileQuery");
  sub_1005C301C((uint64_t)&v35, (uint64_t)v15);
  sub_1005C35AC(a1, (unsigned __int8 *)v26, 5LL);
  uint64_t v2 = 35LL;
  do
  {
    uint64_t v3 = (void *)v26[v2 - 1];
    if (&v24[v2] == v3)
    {
      uint64_t v3 = &v24[v2];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE((&v23)[v2]) < 0) {
      operator delete((void *)v22[v2]);
    }
    v2 -= 7LL;
  }

  while (v2 * 8);
  char v5 = v16;
  if (v16 == v15)
  {
    uint64_t v6 = 4LL;
    char v5 = v15;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v16)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  uint64_t v7 = v18;
  if (v18 == v17)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = v17;
LABEL_19:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  else if (v18)
  {
    uint64_t v8 = 5LL;
    goto LABEL_19;
  }

  uint64_t v9 = v20;
  if (v20 == v19)
  {
    uint64_t v10 = 4LL;
    uint64_t v9 = v19;
LABEL_24:
    (*(void (**)(void))(*v9 + 8 * v10))();
  }

  else if (v20)
  {
    uint64_t v10 = 5LL;
    goto LABEL_24;
  }

  char v11 = v23;
  if (v23 == &v21)
  {
    uint64_t v12 = 4LL;
    char v11 = &v21;
LABEL_29:
    (*v11)[v12]();
  }

  else if (v23)
  {
    uint64_t v12 = 5LL;
    goto LABEL_29;
  }

  uint64_t result = v25;
  if (v25 == v24)
  {
    uint64_t v14 = 4LL;
    uint64_t result = v24;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v14))();
  }

  else if (v25)
  {
    uint64_t v14 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v14))();
  }

  return result;
}

void sub_1005C14EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, char a13, uint64_t a14, uint64_t a15, char *a16, char a17, uint64_t a18, uint64_t a19, char *a20, char a21, uint64_t a22, uint64_t a23, char *a24, char a25, uint64_t a26, uint64_t a27, char *a28, char a29)
{
  for (uint64_t i = 224LL; i != -56; i -= 56LL)
    sub_10026E430((uint64_t)(&a29 + i));
  uint64_t v31 = a12;
  if (a12 == &a9)
  {
    uint64_t v32 = 4LL;
    uint64_t v31 = &a9;
  }

  else
  {
    if (!a12) {
      goto LABEL_8;
    }
    uint64_t v32 = 5LL;
  }

  (*(void (**)(void))(*v31 + 8 * v32))();
LABEL_8:
  uint64_t v33 = a16;
  if (a16 == &a13)
  {
    uint64_t v34 = 4LL;
    uint64_t v33 = &a13;
  }

  else
  {
    if (!a16) {
      goto LABEL_13;
    }
    uint64_t v34 = 5LL;
  }

  (*(void (**)(void))(*(void *)v33 + 8 * v34))();
LABEL_13:
  uint64_t v35 = a20;
  if (a20 == &a17)
  {
    uint64_t v36 = 4LL;
    uint64_t v35 = &a17;
  }

  else
  {
    if (!a20) {
      goto LABEL_18;
    }
    uint64_t v36 = 5LL;
  }

  (*(void (**)(void))(*(void *)v35 + 8 * v36))();
LABEL_18:
  double v37 = a24;
  if (a24 == &a21)
  {
    uint64_t v38 = 4LL;
    double v37 = &a21;
  }

  else
  {
    if (!a24) {
      goto LABEL_23;
    }
    uint64_t v38 = 5LL;
  }

  (*(void (**)(void))(*(void *)v37 + 8 * v38))();
LABEL_23:
  double v39 = a28;
  if (a28 == &a25)
  {
    uint64_t v40 = 4LL;
    double v39 = &a25;
  }

  else
  {
    if (!a28) {
      goto LABEL_28;
    }
    uint64_t v40 = 5LL;
  }

  (*(void (**)(void))(*(void *)v39 + 8 * v40))();
LABEL_28:
  _Unwind_Resume(a1);
}

void sub_1005C1670(uint64_t a1, int a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101842058);
  }
  char v5 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 24);
    *(_DWORD *)std::stringbuf::string_type buf = 138412802;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v27 = 2048;
    uint64_t v28 = a1;
    __int16 v29 = 1024;
    int v30 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "SignificantElevation subscription changed, %@, %p, %d",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101842058);
    }
    uint64_t v11 = *(void *)(a1 + 24);
    unsigned int v20 = 138412802;
    uint64_t v21 = v11;
    __int16 v22 = 2048;
    uint64_t v23 = a1;
    __int16 v24 = 1024;
    int v25 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "SignificantElevation subscription changed, %@, %p, %d",  &v20,  28);
    int v13 = (char *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationSubscription::handleRequestSignificantElevationUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v12);
    if (v13 != buf) {
      free(v13);
    }
  }

  if ((sub_1005C28DC(a1, (int *)&v20) & 1) != 0)
  {
    sub_100C6AC8C(a1);
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v9 = *(void *)(v7 + 8);
    uint64_t v8 = *(void **)(v7 + 16);
    if (a2) {
      [v8 register:v9 forNotification:6 registrationInfo:0];
    }
    else {
      [v8 unregister:v9 forNotification:6];
    }
  }

  else
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101842058);
    }
    uint64_t v10 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Warning Failed to subscribe to significant elevation updates.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101842058);
      }
      v17[0] = 0;
      LODWORD(v16) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "#Warning Failed to subscribe to significant elevation updates.",  v17,  v16);
      uint64_t v15 = (char *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationSubscription::handleRequestSignificantElevationUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    uint64_t v18 = CMErrorMessage;
    uint64_t v19 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v20);
    *(void *)std::stringbuf::string_type buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v19,  &v18,  1LL);
    sub_1005C29B4(a1, buf);
  }
}

void sub_1005C1A30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005C1A70(uint64_t a1, int a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if (!sub_10027D72C(*(void *)(a1 + 8)) || (sub_1004FAB40() & 0x10) == 0)
  {
    uint64_t v17 = CMErrorMessage;
    uint64_t v18 = &off_1018D35A8;
    *(void *)std::stringbuf::string_type buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL);
    sub_1005C2A54(a1, buf);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101842058);
    }
    char v5 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#Warning Failed to subscribe to filtered elevation updates.",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_8;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101842058);
    }
    v13[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "#Warning Failed to subscribe to filtered elevation updates.",  v13,  2);
    uint64_t v11 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationSubscription::handleRequestFilteredElevationUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v12);
LABEL_24:
    if (v11 != buf) {
      free(v11);
    }
    goto LABEL_8;
  }

  if ((sub_100C6ADE0(a1) & 1) != 0)
  {
    sub_100C6AC8C(a1);
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v8 = *(void *)(v6 + 8);
    uint64_t v7 = *(void **)(v6 + 16);
    if (a2)
    {
      [v7 register:v8 forNotification:3 registrationInfo:0];
      [*(id *)(*(void *)(a1 + 48) + 16) register:*(void *)(*(void *)(a1 + 48) + 8) forNotification:7 registrationInfo:0];
    }

    else
    {
      [v7 unregister:v8 forNotification:3];
      [*(id *)(*(void *)(a1 + 48) + 16) unregister:*(void *)(*(void *)(a1 + 48) + 8) forNotification:7];
    }

    goto LABEL_8;
  }

  uint64_t v14 = CMErrorMessage;
  uint64_t v15 = &off_1018D35C0;
  *(void *)std::stringbuf::string_type buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v15,  &v14,  1LL);
  sub_1005C2A54(a1, buf);
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101842058);
  }
  uint64_t v9 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning Not authorized for filtered elevation updates.",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101842058);
    }
    v13[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "#Warning Not authorized for filtered elevation updates.",  v13,  2);
    uint64_t v11 = (uint8_t *)v10;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationSubscription::handleRequestFilteredElevationUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v10);
    goto LABEL_24;
  }

void sub_1005C1E38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005C1E84(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if ((sub_1005C28DC(a1, (int *)&v31) & 1) != 0)
  {
    objc_opt_class(&OBJC_CLASS___CMMotionTimeRange);
    uint64_t v6 = v5;
    *(void *)&double v7 = objc_opt_class(&OBJC_CLASS___NSString).n128_u64[0];
    DictionaryOfClasses = (void *)CLConnectionMessage::getDictionaryOfClasses( *(CLConnectionMessage **)a2,  +[NSSet setWithObjects:](&OBJC_CLASS___NSSet, "setWithObjects:", v6, v7, v8, 0LL));
    uint64_t v10 = DictionaryOfClasses;
    if (DictionaryOfClasses
      && (uint64_t v11 = CMSignificantElevationKeyQueryTimeRange,
          [DictionaryOfClasses objectForKeyedSubscript:CMSignificantElevationKeyQueryTimeRange]))
    {
      sub_100222B94(buf, (uint64_t)"CLDaemonClient.OdometerNotifier.SignificantElevationDeltaQuery", 0);
      id v12 = [v10 objectForKeyedSubscript:v11];
      int v13 = *(void **)(*(void *)(a1 + 48) + 16LL);
      id v14 = [v12 startDate];
      id v15 = [v12 endDate];
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 3321888768LL;
      void v28[2] = sub_1005C2AF4;
      void v28[3] = &unk_101841FB8;
      uint64_t v16 = *(std::__shared_weak_count **)(a2 + 8);
      v28[4] = *(void *)a2;
      __int16 v29 = v16;
      if (v16)
      {
        p_shared_owners = (unint64_t *)&v16->__shared_owners_;
        do
          unint64_t v18 = __ldxr(p_shared_owners);
        while (__stxr(v18 + 1, p_shared_owners));
      }

      [v13 querySignificantElevationDeltaFromDate:v14 toDate:v15 withReply:v28];
      uint64_t v19 = v29;
      if (v29)
      {
        unsigned int v20 = (unint64_t *)&v29->__shared_owners_;
        do
          unint64_t v21 = __ldaxr(v20);
        while (__stlxr(v21 - 1, v20));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
        }
      }

      sub_1001BA1BC(buf);
    }

    else
    {
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101842058);
      }
      uint64_t v23 = (os_log_s *)qword_1019345B8;
      if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_FAULT))
      {
        LOWORD(buf[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_FAULT,  "Programmer error: Wrong parameters were passed.",  (uint8_t *)buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345B0 != -1) {
          dispatch_once(&qword_1019345B0, &stru_101842058);
        }
        v30[0] = 0;
        LODWORD(v27) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  17LL,  "Programmer error: Wrong parameters were passed.",  v30,  v27);
        __int16 v26 = (uint8_t *)v25;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLElevationSubscription::handleMessageSignificantElevationDeltaQuery(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v25);
      }

      __int16 v24 = *(CLConnectionMessage **)a2;
      uint64_t v32 = CMErrorMessage;
      uint64_t v33 = &off_1018D35D8;
      +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v33,  &v32,  1LL);
      CLConnectionMessage::sendReply(v24);
    }
  }

  else
  {
    __int16 v22 = *(CLConnectionMessage **)a2;
    uint64_t v35 = CMErrorMessage;
    uint64_t v36 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v31);
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v36,  &v35,  1LL);
    CLConnectionMessage::sendReply(v22);
  }
}

void sub_1005C2218(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005C2270(void *a1, int a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101842058);
  }
  uint64_t v5 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = a1[3];
    *(_DWORD *)std::stringbuf::string_type buf = 138412802;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v26 = 2048;
    uint64_t v27 = a1;
    __int16 v28 = 1024;
    int v29 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "AbsoluteAltitude subscription changed, %@, %p, %d",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101842058);
    }
    uint64_t v10 = a1[3];
    unsigned int v19 = 138412802;
    uint64_t v20 = v10;
    __int16 v21 = 2048;
    __int16 v22 = a1;
    __int16 v23 = 1024;
    int v24 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "AbsoluteAltitude subscription changed, %@, %p, %d",  &v19,  28);
    id v12 = (char *)v11;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationSubscription::handleRequestAbsoluteAltitudeUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  if ((sub_1005C2BE8((uint64_t)a1, &v19) & 1) != 0)
  {
    sub_100C6AC8C((uint64_t)a1);
    double v7 = (void *)a1[7];
    uint64_t v8 = a1[8];
    if (a2)
    {
      [v7 registerClient:v8 forNotification:1];
      sub_1005C2EB4((uint64_t)a1);
    }

    else
    {
      [v7 unregisterClient:v8 forNotification:1];
    }
  }

  else
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101842058);
    }
    uint64_t v9 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning Failed to subscribe to absolute altitude updates.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101842058);
      }
      v16[0] = 0;
      LODWORD(v15) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "#Warning Failed to subscribe to absolute altitude updates.",  v16,  v15);
      id v14 = (char *)v13;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationSubscription::handleRequestAbsoluteAltitudeUpdate(BOOL, const CLNameValuePair &)",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }

    uint64_t v17 = CMErrorMessage;
    unint64_t v18 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v19);
    *(void *)std::stringbuf::string_type buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL);
    sub_1005C2E14((uint64_t)a1, buf);
  }
}

void sub_1005C2630(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1005C266C(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  int v5 = *a3;
  if (*a3 == 3 || v5 == 7)
  {
    id v7 = [[CMSignificantElevationSample alloc] initWithFilteredElevation:a4];
    uint64_t v10 = CMFilteredElevationKeySample;
    id v11 = v7;
    uint64_t v9 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v11,  &v10,  1LL);

    sub_1005C2834(a1, &v9);
  }

  else if (v5 == 6)
  {
    id v8 = [[CMSignificantElevationSample alloc] initWithSignificantElevation:a4];
    uint64_t v12 = CMSignificantElevationKeySample;
    id v13 = v8;
    uint64_t v9 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v13,  &v12,  1LL);

    sub_1005C278C(a1, &v9);
  }

void sub_1005C278C(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_1005C2820(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1005C2834(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_1005C28C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1005C28DC(uint64_t a1, int *a2)
{
  if (sub_100C6ADE0(a1))
  {
    sub_1004F2598();
    if (sub_1001B9A1C())
    {
      sub_1010DDBC0(&__p, "com.apple.locationd.natalimetry");
      char v4 = sub_100C6AC9C(a1);
      char v5 = v4;
      if (v9 < 0)
      {
        operator delete(__p);
        if ((v5 & 1) == 0)
        {
LABEL_13:
          int v6 = 110;
          goto LABEL_14;
        }
      }

      else if ((v4 & 1) == 0)
      {
        goto LABEL_13;
      }
    }

    else if ((sub_1004FAB40() & 0x10) == 0)
    {
LABEL_12:
      int v6 = 109;
      goto LABEL_14;
    }

    if ((sub_10027D72C(*(void *)(a1 + 8)) & 1) != 0) {
      return 1LL;
    }
    goto LABEL_12;
  }

  int v6 = 111;
LABEL_14:
  uint64_t result = 0LL;
  *a2 = v6;
  return result;
}

void sub_1005C2998( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005C29B4(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100272EB8(&off_1018421A8, a2, &v6);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v2 + 24LL))(v2, &v6, 0LL);
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_1005C2A40(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1005C2A54(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100272EB8(&off_1018421B0, a2, &v6);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v2 + 24LL))(v2, &v6, 0LL);
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_1005C2AE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1005C2AF4(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v6 = CMSignificantElevationKeySample;
    uint64_t v7 = a2;
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v7,  &v6,  1LL);
    uint64_t v3 = *(void *)(a1 + 32);
  }

  else
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v8 = CMErrorMessage;
    char v9 = &off_1018D35A8;
    +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v9,  &v8,  1LL);
    uint64_t v3 = v4;
  }

  return CLConnectionMessage::sendReply(v3);
}

uint64_t sub_1005C2BBC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t sub_1005C2BE0(uint64_t a1)
{
  return sub_10000AE14(a1 + 32);
}

uint64_t sub_1005C2BE8(uint64_t a1, _DWORD *a2)
{
  int v4 = sub_100C6ADE0(a1);
  sub_1010DDBC0(__p, "com.apple.locationd.absolute_altimeter");
  unsigned int v5 = sub_100C6AC9C(a1);
  if (v16 < 0) {
    operator delete(*(void **)__p);
  }
  uint64_t v6 = v4 | v5;
  if ((v6 & 1) == 0)
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101842058);
    }
    uint64_t v7 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *(void *)(a1 + 24);
      *(_DWORD *)std::stringbuf::string_type __p = 138543362;
      *(void *)&__p[4] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "%{public}@ is not entitled for motion updates",  __p,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101842058);
      }
      uint64_t v10 = *(void *)(a1 + 24);
      int v13 = 138543362;
      uint64_t v14 = v10;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019345B8,  16LL,  "%{public}@ is not entitled for motion updates",  &v13,  12);
      uint64_t v12 = (char *)v11;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLElevationSubscription::isQualifiedForAbsoluteAltitude(CMError &)",  "%s\n",  v11);
      if (v12 != __p) {
        free(v12);
      }
    }

    *a2 = 111;
  }

  return v6;
}

void sub_1005C2DF0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005C2E14(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100272EB8(&off_1018421B8, a2, &v6);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v2 + 24LL))(v2, &v6, 0LL);
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_1005C2EA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

id sub_1005C2EB4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 72) arrayForKey:@"ElevationThresholds" defaultValue:0];
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  id result = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (result)
  {
    id v4 = result;
    uint64_t v5 = *(void *)v9;
    do
    {
      uint64_t v6 = 0LL;
      do
      {
        if (*(void *)v9 != v5) {
          objc_enumerationMutation(v2);
        }
        [*(id *)(*((void *)&v8 + 1) + 8 * (void)v6) floatValue];
        objc_msgSend( *(id *)(a1 + 56),  "registerClient:forElevationThreshold:",  *(void *)(a1 + 64),  1.79769313e308,  v7);
        uint64_t v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id result = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
      id v4 = result;
    }

    while (result);
  }

  return result;
}

void sub_1005C2FC4(id a1)
{
  qword_1019346A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Altimeter");
}

void sub_1005C2FF0(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_1005C301C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  void *v3 = 0LL;
  return a1;
}

void sub_1005C3080(id a1)
{
  qword_1019345B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pressure");
}

__n128 sub_1005C30AC(uint64_t a1)
{
  id v2 = (char *)operator new(0x18uLL);
  *(void *)id v2 = &off_101842088;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(va, 8) = result;
  return result;
}

__n128 sub_1005C30E8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101842088;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose(va, 8) = result;
  return result;
}

void sub_1005C310C(uint64_t a1, uint64_t a2, __int128 *a3)
{
}

uint64_t sub_1005C3114(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1005C3150()
{
}

void sub_1005C315C(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v6 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  sub_1005C31E0(a1, a2, (CLConnectionMessage **)&v6);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)&v6 + 1);
  if (*((void *)&v6 + 1))
  {
    uint64_t v4 = (unint64_t *)(*((void *)&v6 + 1) + 8LL);
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_1005C31C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1012310A8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005C31E0(uint64_t a1, uint64_t a2, CLConnectionMessage **a3)
{
  __int128 v6 = (NSSet *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  DictionaryOfClasses = (const __CFDictionary *)CLConnectionMessage::getDictionaryOfClasses(*a3, v6);
  sub_1002A5550((int)v15, DictionaryOfClasses);
  if ((sub_1002A6F64((uint64_t)v15, "kCLConnectionMessageSubscribeKey", &v14) & 1) != 0)
  {
    __int128 v8 = *(void (**)(void *, BOOL, uint8_t *))a1;
    uint64_t v9 = *(void *)(a1 + 8);
    __int128 v10 = (void *)(a2 + (v9 >> 1));
    if ((v9 & 1) != 0) {
      __int128 v8 = *(void (**)(void *, BOOL, uint8_t *))(*v10 + v8);
    }
    v8(v10, v14, v15);
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_1018420F8);
    }
    __int128 v11 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      unsigned int v19 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_1018420F8);
      }
    }

    uint64_t v12 = (os_log_s *)qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      unsigned int v19 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Couldn't get value for kCLConnectionMessageSubscribeKey key",  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
    }
  }

  return sub_1002A5590(v15);
}

void sub_1005C33C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_1005C33E0(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

__n128 sub_1005C340C(uint64_t a1)
{
  id v2 = (char *)operator new(0x18uLL);
  *(void *)id v2 = &off_101842138;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(va, 8) = result;
  return result;
}

__n128 sub_1005C3448(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101842138;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + _Block_object_dispose(va, 8) = result;
  return result;
}

void sub_1005C346C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_1005C3474(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1005C34B0()
{
}

void sub_1005C34BC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  uint64_t v15 = v3;
  *a3 = 0LL;
  a3[1] = 0LL;
  unint64_t v5 = *(void (**)(void *, uint64_t *))a1;
  uint64_t v6 = *(void *)(a1 + 8);
  float v7 = (void *)(a2 + (v6 >> 1));
  if ((v6 & 1) != 0) {
    unint64_t v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
  }
  uint64_t v16 = v4;
  int v17 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  v5(v7, &v16);
  __int128 v10 = v17;
  if (v17)
  {
    __int128 v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (v15)
  {
    int v13 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_1005C3590( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_1005C35AC(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_1005C3624(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_1005C3610(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_1005C3624(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  float v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    int v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_1005C38A4(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  __int16 v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *__int16 v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_1005C388C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_1005C38A4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + _Block_object_dispose(va, 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *unint64_t v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_1005C3918(v8 + 2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1005C3900(_Unwind_Exception *a1)
{
}

void *sub_1005C3918(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_1005C3970(_Unwind_Exception *exception_object)
{
}

void *sub_1005C398C@<X0>(char **a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  __n128 result = sub_100272F18(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1005C39D8(_Unwind_Exception *a1)
{
}

void sub_1005C3A90(id a1)
{
  qword_101997230 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLWatchOrientationSettingsNotifierSilo");
}

uint64_t sub_1005C3B44(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1005C44E8;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_101997250 != -1) {
    dispatch_once(&qword_101997250, block);
  }
  return qword_1019A1188;
}

void sub_1005C3CE4(id a1)
{
}

const void *sub_1005C3D0C(const void *a1, void *a2)
{
  unint64_t v3 = (void *)sub_1005C3EE0((uint64_t)a1, "CLWatchOrientationSettingsNotifier", a2);
  void *v3 = off_101842210;
  sub_1005C3F7C((uint64_t)v3);
  sub_1005C4408(a1);
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101842388);
  }
  __int128 v4 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Watch Orientation,Orientation Notifier Instantiated",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101842388);
    }
    v7[0] = 0;
    uint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Watch Orientation,Orientation Notifier Instantiated",  v7,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLWatchOrientationSettingsNotifier::CLWatchOrientationSettingsNotifier(id<CLIntersiloUniverse>)",  "%s\n",  v6);
  }

  return a1;
}

void sub_1005C3EC8(_Unwind_Exception *a1)
{
}

uint64_t sub_1005C3EE0(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_1018423B8;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = [a3 silo];
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 10_Block_object_dispose(va, 8) = 0;
  return a1;
}

void sub_1005C3F60(_Unwind_Exception *exception_object)
{
}

void sub_1005C3F7C(uint64_t a1)
{
  HIBYTE(v17) = 0;
  int v2 = sub_1002956CC(@"invertUI", @"com.apple.nano", (_BYTE *)&v17 + 7);
  if (HIBYTE(v17))
  {
    BOOL v3 = v2 == 0;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101842388);
    }
    __int128 v4 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Watch Orientation,Crown orientation setting key is invalid, defaulting to crown on right (not inverted)",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101842388);
      }
      LOWORD(v18[0]) = 0;
      LODWORD(v17) = 2;
      unint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "Watch Orientation,Crown orientation setting key is invalid, defaulting to crown on right (not inverted)",  v18,  v17);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLWatchOrientationSettingsNotifier::queryOrientationSettings()",  "%s\n",  v15);
    }

    BOOL v3 = 1;
  }

  *(_DWORD *)(a1 + 116) = v3;
  HIBYTE(v17) = 0;
  int v5 = sub_1002956CC(@"wornOnRightArm", @"com.apple.nano", (_BYTE *)&v17 + 7);
  if (HIBYTE(v17))
  {
    BOOL v6 = v5 != 0;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101842388);
    }
    uint64_t v7 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Watch Orientation,Wrist orientation setting key is invalid, defaulting to left wrist",  buf,  2u);
    }

    BOOL v8 = sub_1002921D0(115, 0);
    BOOL v6 = 0;
    if (v8)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101842388);
      }
      LOWORD(v18[0]) = 0;
      LODWORD(v17) = 2;
      float v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "Watch Orientation,Wrist orientation setting key is invalid, defaulting to left wrist",  v18,  v17);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLWatchOrientationSettingsNotifier::queryOrientationSettings()",  "%s\n",  v16);
      BOOL v6 = 0;
    }
  }

  *(_DWORD *)(a1 + sub_10004AD90(v15 - 112) = v6;
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101842388);
  }
  unint64_t v9 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = *(_DWORD *)(a1 + 112);
    int v10 = *(_DWORD *)(a1 + 116);
    *(_DWORD *)std::stringbuf::string_type buf = 67240448;
    int v22 = v10;
    __int16 v23 = 1026;
    int v24 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Watch Orientation,crown,%{public}d,wrist,%{public}d",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101842388);
    }
    int v13 = *(_DWORD *)(a1 + 112);
    int v12 = *(_DWORD *)(a1 + 116);
    v18[0] = 67240448;
    v18[1] = v12;
    __int16 v19 = 1026;
    int v20 = v13;
    LODWORD(v17) = 14;
    unint64_t v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "Watch Orientation,crown,%{public}d,wrist,%{public}d",  v18,  v17);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWatchOrientationSettingsNotifier::queryOrientationSettings()",  "%s\n",  v14);
  }

void sub_1005C4408(const void *a1)
{
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver( DarwinNotifyCenter,  a1,  (CFNotificationCallback)sub_1005C4C20,  @"com.apple.nano.invertUIChangedNotification",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  CFNotificationCenterAddObserver( DarwinNotifyCenter,  a1,  (CFNotificationCallback)sub_1005C4C20,  @"com.apple.nano.wristOrientationChangedNotification",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
}

uint64_t sub_1005C4474(uint64_t a1)
{
  *(void *)a1 = off_1018423B8;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

const void *sub_1005C44E8(uint64_t a1)
{
  int v2 = operator new(0x78uLL);
  __n128 result = sub_1005C3D0C(v2, *(void **)(a1 + 32));
  qword_1019A1188 = (uint64_t)v2;
  return result;
}

void sub_1005C4520(_Unwind_Exception *a1)
{
}

uint64_t sub_1005C4534(_BYTE *a1)
{
  *(void *)a1 = off_101842210;
  sub_1005C4580(a1);
  return sub_1005C4474((uint64_t)a1);
}

void sub_1005C456C(_BYTE *a1)
{
  uint64_t v1 = (void *)sub_1005C4534(a1);
  operator delete(v1);
}

void sub_1005C4580(_BYTE *a1)
{
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101842388);
  }
  int v2 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Watch Orientation,Orientation Notifier is shutting down.",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101842388);
    }
    v4[0] = 0;
    BOOL v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Watch Orientation,Orientation Notifier is shutting down.",  v4,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLWatchOrientationSettingsNotifier::shutdown()", "%s\n", v3);
  }

  sub_1005C4720(a1);
  a1[108] = 1;
}

void sub_1005C4720(const void *a1)
{
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver(DarwinNotifyCenter, a1, @"com.apple.nano.invertUIChangedNotification", 0LL);
  CFNotificationCenterRemoveObserver( DarwinNotifyCenter,  a1,  @"com.apple.nano.wristOrientationChangedNotification",  0LL);
}

void *sub_1005C476C@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

uint64_t sub_1005C47E4(void *a1, int *a2)
{
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101842388);
  }
  __int128 v4 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    v13[0] = *a2;
    int v5 = v13[0];
    int v6 = sub_100247620((uint64_t)a1, v13, 1LL);
    *(_DWORD *)std::stringbuf::string_type buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v5;
    LOWORD(v17) = 1024;
    *(_DWORD *)((char *)&v17 + 2) = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Watch Orientation,Added client for %d, count %d",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101842388);
    }
    uint64_t v8 = qword_1019344B8;
    int v9 = *a2;
    int v12 = v9;
    int v10 = sub_100247620((uint64_t)a1, &v12, 1LL);
    v13[0] = 67109376;
    v13[1] = v9;
    __int16 v14 = 1024;
    int v15 = v10;
    int v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v8,  2LL,  "Watch Orientation,Added client for %d, count %d",  v13,  14);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLWatchOrientationSettingsNotifier::registerForNotificationInternal(const CLWatchOrientationSettingsN otifier_Type::Notification &)",  "%s\n",  v11);
  }

  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  *(void *)std::stringbuf::string_type buf = a1[14];
  uint64_t v17 = 0LL;
  v13[0] = 0;
  (*(void (**)(void *, int *, uint8_t *, uint64_t, uint64_t, void))(*a1 + 152LL))( a1,  v13,  buf,  1LL,  0xFFFFFFFFLL,  0LL);
  return 1LL;
}

uint64_t sub_1005C4A1C(uint64_t a1, int *a2)
{
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101842388);
  }
  __int128 v4 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    v13[0] = *a2;
    int v5 = v13[0];
    int v6 = sub_100247620(a1, v13, 1LL);
    *(_DWORD *)std::stringbuf::string_type buf = 67109376;
    int v17 = v5;
    __int16 v18 = 1024;
    int v19 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Watch Orientation,Removed client for %d, count %d",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101842388);
    }
    uint64_t v8 = qword_1019344B8;
    int v9 = *a2;
    int v12 = v9;
    int v10 = sub_100247620(a1, &v12, 1LL);
    v13[0] = 67109376;
    v13[1] = v9;
    __int16 v14 = 1024;
    int v15 = v10;
    int v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v8,  2LL,  "Watch Orientation,Removed client for %d, count %d",  v13,  14);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLWatchOrientationSettingsNotifier::unregisterForNotificationInternal(const CLWatchOrientationSetting sNotifier_Type::Notification &)",  "%s\n",  v11);
  }

  return 1LL;
}

void sub_1005C4C20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101842368);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v15 = 1;
    int v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLWatchOrientationSettingsNotifier::onOrientationSettingsChanged",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842368);
    }
    int v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v17 = 0;
      __int16 v18 = 2082;
      int v19 = "";
      __int16 v20 = 2082;
      size_t v21 = "activity";
      __int16 v22 = 2050;
      uint64_t v23 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLWatchOrientationSettingsNotifier::onOrientationSettingsChanged, event:%{public, l ocation:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v15 = 0;
  }

  id v12 = [*(id *)(a2 + 32) silo];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  int v13[2] = sub_1005C6B40;
  void v13[3] = &unk_10182D1B8;
  _DWORD v13[4] = a2;
  v13[5] = a1;
  void v13[6] = a3;
  _WORD v13[7] = a4;
  _WORD v13[8] = a5;
  [v12 sync:v13];
  if (v15) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005C4E20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state, char a19)
{
  if (a19) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005C4E40(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLWatchOrientationSettingsNotifier");
  sub_1005C4F08((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  *uint64_t v8 = off_1018422F0;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005C4EDC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1005C4F08(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = off_101842508;
  *(void *)(a1 + _Block_object_dispose(va, 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  else {
    id v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

void sub_1005C4FDC(uint64_t a1, uint64_t a2)
{
  HIDWORD(v14) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        int v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)std::stringbuf::string_type buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v14 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101842368);
      }
      char v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        int v11 = (void *)(a1 + 8);
        *(_DWORD *)std::stringbuf::string_type buf = 136446466;
        __int16 v20 = v11;
        __int16 v21 = 1026;
        int v22 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101842368);
        }
        id v12 = (void *)(a1 + 8);
        int v15 = 136446466;
        float v16 = v12;
        __int16 v17 = 1026;
        int v18 = a2;
        LODWORD(v14) = 18;
        id v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                        &v15,
                        v14);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotif ier_Type::NotificationData>::removeClient(int) [Notification_T = CLWatchOrientationSettingsNotifier_Type::Noti fication, NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
      }
    }
  }

uint64_t sub_1005C5250(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_101938C10);
}

uint64_t sub_1005C5264(uint64_t a1, int a2, int *a3, char *a4)
{
  int v41 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)CFAbsoluteTime v42 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          int v24 = (uint64_t *)v18;
        }
        else {
          int v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }

      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          int v29 = (uint64_t *)v25;
        }
        else {
          int v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }

      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v40 = v26;
        uint64_t v34 = *(void *)(v26 + 56);
        char v35 = *a4;
        *(void *)std::stringbuf::string_type buf = &v41;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v26 + 40), &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v35;
        memset(buf, 0, 32);
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, uint8_t *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          uint64_t v36 = sub_1005C7624(buf);
          sub_1005C6FF4((_BYTE *)a1, (uint64_t)v42, (uint64_t)&v40, v36);
        }

        if (v34) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        uint64_t v40 = a1 + 64;
        char v30 = byte_101938C11;
        HIDWORD(v39) = v17;
        *(void *)std::stringbuf::string_type buf = (char *)&v39 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 80) = v30;
        HIDWORD(v39) = *a3;
        *(void *)std::stringbuf::string_type buf = (char *)&v39 + 4;
        unsigned int v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v31 + 8);
        char v32 = *a4;
        HIDWORD(v39) = *a3;
        *(void *)std::stringbuf::string_type buf = (char *)&v39 + 4;
        uint64_t v33 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)std::stringbuf::string_type buf = &v41;
        *((_BYTE *)sub_1004EF3D4(v33 + 5, &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v32;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v21 == v19)
      {
        *(_DWORD *)std::stringbuf::string_type buf = *a3;
        sub_10004A8FC((uint64_t **)(*(void *)v42 + 40LL), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101842368);
  }
  uint64_t v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    int v15 = (void *)(a1 + 8);
    *(_DWORD *)std::stringbuf::string_type buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL v16 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842368);
    }
    double v37 = (void *)(a1 + 8);
    *(_DWORD *)CFAbsoluteTime v42 = 136446466;
    *(void *)&v42[4] = v37;
    __int16 v43 = 1026;
    int v44 = a2;
    LODWORD(v39) = 18;
    uint64_t v38 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                    v42,
                    v39);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotifier_ Type::NotificationData>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notific ation_T = CLWatchOrientationSettingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientationSettingsNo tifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v38);
    return 0LL;
  }

  return result;
}

BOOL sub_1005C56C4(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v5;
    }
    else {
      int v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        uint64_t v21 = (uint64_t *)v15;
      }
      else {
        uint64_t v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842368);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)std::stringbuf::string_type buf = 136446466;
      int v29 = v11;
      __int16 v30 = 1026;
      int v31 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101842368);
      }
      int v22 = (void *)(a1 + 8);
      int v24 = 136446466;
      uint64_t v25 = v22;
      __int16 v26 = 1026;
      int v27 = a2;
      BOOL v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                      &v24,
                      18);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotifie r_Type::NotificationData>::clientRegistered(int, const Notification_T &) [Notification_T = CLWatchOrientationSet tingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData , NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      return 0LL;
    }
  }

  return result;
}

BOOL sub_1005C5944(char *a1, int a2, int *a3)
{
  HIDWORD(v33) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        id v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            id v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            int v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                uint64_t v25 = (uint64_t *)v20;
              }
              else {
                uint64_t v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                int v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v33 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101842368);
              }
              __int16 v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v27 = a1 + 8;
                if (a1[31] < 0) {
                  int v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v43 >= 0) {
                  BOOL v28 = __p;
                }
                else {
                  BOOL v28 = (void **)__p[0];
                }
                *(_DWORD *)std::stringbuf::string_type buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v35 = 2082;
                uint64_t v36 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v43 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101842368);
                }
                int v29 = a1 + 8;
                if (a1[31] < 0) {
                  int v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v37 >= 0) {
                  int v31 = buf;
                }
                else {
                  int v31 = *(_BYTE **)buf;
                }
                int v38 = 136446466;
                uint64_t v39 = v29;
                __int16 v40 = 2082;
                int v41 = v31;
                LODWORD(v33) = 22;
                char v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                                &v38,
                                v33);
                if (v37 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSetti ngsNotifier_Type::NotificationData>::unregisterForNotification(int, const Notification_T &) [Notificat ion_T = CLWatchOrientationSettingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientation SettingsNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v32);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_1005C5CCC(uint64_t a1, int *a2, _OWORD *a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }

  while (*v10);
  if (v7 == v3) {
    return 0LL;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0LL;
  }
  int v11 = *(_OWORD **)(v7 + 64);
  if (!v11) {
    return 0LL;
  }
  __int128 v12 = v11[1];
  *a3 = *v11;
  a3[1] = v12;
  return 1LL;
}

uint64_t sub_1005C5D2C(uint64_t a1, int *a2, _OWORD *a3)
{
  int v6 = (char *)operator new(0x38uLL);
  __int128 v7 = a3[1];
  *(_OWORD *)(v6 + 24) = *a3;
  *((void *)v6 + 2) = 0LL;
  *(void *)int v6 = off_101842498;
  *((void *)v6 + 1) = 0LL;
  *(_OWORD *)(v6 + 40) = v7;
  *(void *)&__int128 v14 = v6 + 24;
  *((void *)&v14 + 1) = v6;
  int v13 = *a2;
  int v15 = &v13;
  int v8 = sub_10023347C((uint64_t **)(a1 + 56), &v13, (uint64_t)&unk_1012CF090, &v15);
  sub_10005F550((uint64_t)(v8 + 8), &v14);
  BOOL v9 = (std::__shared_weak_count *)*((void *)&v14 + 1);
  if (*((void *)&v14 + 1))
  {
    BOOL v10 = (unint64_t *)(*((void *)&v14 + 1) + 8LL);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return 1LL;
}

void sub_1005C5E04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1005C5E18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  v5,  a3,  a4,  0LL);
}

void sub_1005C5E54(uint64_t a1, unsigned int *a2, _OWORD *a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    BOOL v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842368);
    }
    unint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      __int128 v12 = (void *)(a1 + 8);
      int v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)std::stringbuf::string_type buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = "activity";
      __int16 v67 = 2082;
      __int16 v68 = v12;
      __int16 v69 = 2050;
      uint64_t v70 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    __int128 v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      __int128 v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)int v71 = &v71[8];
      memset(&v71[8], 0, 24);
      std::string::size_type v72 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v71);
      int v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v70;
      if (v70)
      {
        p_shared_owners = (unint64_t *)&v70->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&buf[8], *(void **)&buf[16]);
      BOOL v24 = v72;
      if (v72)
      {
        uint64_t v25 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v71, *(void **)&v71[8]);
    }

    if (a4)
    {
      int v27 = (char *)operator new(0x38uLL);
      *((void *)v27 + 1) = 0LL;
      *((void *)v27 + 2) = 0LL;
      *(void *)int v27 = off_101842498;
      __int128 v28 = a3[1];
      *(_OWORD *)(v27 + 24) = *a3;
      *(_OWORD *)(v27 + 40) = v28;
      *(void *)std::stringbuf::string_type buf = v27 + 24;
      *(void *)&uint8_t buf[8] = v27;
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      int v29 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        uint64_t v30 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    char v32 = sub_1005C6BA0(a3);
    if (a5 == -1)
    {
      sub_1005C6C20((void *)a1, (int *)a2, v32);
    }

    else
    {
      uint64_t v33 = a1 + 88;
      uint64_t v34 = *(void *)(a1 + 88);
      if (!v34) {
        goto LABEL_48;
      }
      uint64_t v35 = a1 + 88;
      do
      {
        int v36 = *(_DWORD *)(v34 + 32);
        BOOL v37 = v36 < a5;
        if (v36 >= a5) {
          int v38 = (uint64_t *)v34;
        }
        else {
          int v38 = (uint64_t *)(v34 + 8);
        }
        if (!v37) {
          uint64_t v35 = v34;
        }
        uint64_t v34 = *v38;
      }

      while (*v38);
      if (v35 == v33 || *(_DWORD *)(v35 + 32) > a5) {
LABEL_48:
      }
        uint64_t v35 = a1 + 88;
      uint64_t v64 = v35;
      unint64_t v39 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v40 = *a2;
      int v41 = (__n128 *)(a1 + 64);
      do
      {
        int v42 = *(_DWORD *)(v39 + 32);
        BOOL v43 = v42 < v40;
        if (v42 >= v40) {
          int v44 = (unint64_t *)v39;
        }
        else {
          int v44 = (unint64_t *)(v39 + 8);
        }
        if (!v43) {
          int v41 = (__n128 *)v39;
        }
        unint64_t v39 = *v44;
      }

      while (*v44);
      if (v41 == v15 || v40 < (signed __int32)v41[2].n128_u32[0])
      {
LABEL_59:
        __int128 v63 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101842368);
        }
        __int16 v45 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          int v46 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v71, a1, a2);
          if (v71[23] >= 0) {
            uint64_t v47 = v71;
          }
          else {
            uint64_t v47 = *(_BYTE **)v71;
          }
          *(_DWORD *)std::stringbuf::string_type buf = 136315650;
          *(void *)&uint8_t buf[4] = v46;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a5;
          *(_WORD *)&_BYTE buf[18] = 2080;
          *(void *)&buf[20] = v47;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v71[23] & 0x80000000) != 0) {
            operator delete(*(void **)v71);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_101842368);
          }
          uint64_t v48 = (void *)(a1 + 8);
          uint64_t v49 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v62 >= 0) {
            float v50 = __p;
          }
          else {
            float v50 = (void **)__p[0];
          }
          *(_DWORD *)int v71 = 136315650;
          *(void *)&v71[4] = v48;
          *(_WORD *)&v71[12] = 1024;
          *(_DWORD *)&v71[14] = a5;
          *(_WORD *)&v71[18] = 2080;
          *(void *)&v71[20] = v50;
          int v51 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v49,  2LL,  "%s; client %d has deregistered, not notifying %s",
                          v71,
                          28,
                          v60);
          if (v62 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNot ifier_Type::NotificationData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, boo l, int, BOOL) [Notification_T = CLWatchOrientationSettingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v51);
          if (v51 != buf) {
            free(v51);
          }
        }

        goto LABEL_83;
      }

      __int128 v63 = v41;
      if (v35 == v33) {
        goto LABEL_60;
      }
      uint64_t v54 = v41[3].n128_i64[0];
      uint64_t v52 = v41 + 3;
      __int16 v53 = (__n128 *)v54;
      if (!v54) {
        goto LABEL_60;
      }
      int v55 = *(_DWORD *)(v35 + 32);
      BOOL v56 = v52;
      do
      {
        int v57 = v53[1].n128_i32[3];
        BOOL v58 = v57 < v55;
        if (v57 >= v55) {
          __int128 v59 = v53;
        }
        else {
          __int128 v59 = (__n128 *)&v53->n128_i8[8];
        }
        if (!v58) {
          BOOL v56 = v53;
        }
        __int16 v53 = (__n128 *)v59->n128_u64[0];
      }

      while (v59->n128_u64[0]);
      sub_1005C6FF4((_BYTE *)a1, (uint64_t)&v64, (uint64_t)&v63, v32);
    }

void sub_1005C6490( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_1005C64DC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842368);
    }
    int v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)std::stringbuf::string_type buf = 136315138;
      uint64_t v34 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101842368);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v29 = 136315138;
      uint64_t v30 = v4;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
                     (const char *)&v29);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotifie r_Type::NotificationData>::listClients() [Notification_T = CLWatchOrientationSettingsNotifier_Type::Notification , NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, Reg istrationInfo_T = char]",  "%s\n",  v5);
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842368);
    }
    int v6 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      __int128 v7 = (void *)(a1 + 8);
      uint64_t v8 = *(void *)(a1 + 96);
      *(_DWORD *)std::stringbuf::string_type buf = 136315394;
      uint64_t v34 = v7;
      __int16 v35 = 2048;
      v36[0] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101842368);
      }
      uint64_t v25 = (void *)(a1 + 8);
      uint64_t v26 = *(void *)(a1 + 96);
      int v29 = 136315394;
      uint64_t v30 = v25;
      __int16 v31 = 2048;
      v32[0] = v26;
      int v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
                      (const char *)&v29,
                      22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotifie r_Type::NotificationData>::listClients() [Notification_T = CLWatchOrientationSettingsNotifier_Type::Notification , NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, Reg istrationInfo_T = char]",  "%s\n",  v27);
    }

    BOOL v9 = *(void **)(a1 + 80);
    if (v9 != (void *)(a1 + 88))
    {
      BOOL v10 = (void *)(a1 + 8);
      do
      {
        unint64_t v11 = (void *)v9[5];
        if (v11 != v9 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_101842368);
            }
            __int128 v12 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              int v13 = (void *)(a1 + 8);
              int v14 = *((_DWORD *)v9 + 8);
              int v15 = *((_DWORD *)v11 + 7);
              *(_DWORD *)std::stringbuf::string_type buf = 136315650;
              uint64_t v34 = v13;
              __int16 v35 = 1024;
              LODWORD(v36[0]) = v14;
              WORD2(v36[0]) = 1024;
              *(_DWORD *)((char *)v36 + 6) = v15;
              _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101842368);
              }
              BOOL v19 = (void *)(a1 + 8);
              int v20 = *((_DWORD *)v9 + 8);
              int v21 = *((_DWORD *)v11 + 7);
              int v29 = 136315650;
              uint64_t v30 = v19;
              __int16 v31 = 1024;
              LODWORD(v32[0]) = v20;
              WORD2(v32[0]) = 1024;
              *(_DWORD *)((char *)v32 + 6) = v21;
              int v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                              (const char *)&v29,
                              24,
                              v28);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSetting sNotifier_Type::NotificationData>::listClients() [Notification_T = CLWatchOrientationSettingsNotifier_Ty pe::Notification, NotificationData_T = CLWatchOrientationSettingsNotifier_Type::NotificationData, Notifi cationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v22);
            }

            signed __int32 v16 = (void *)v11[1];
            if (v16)
            {
              do
              {
                int v17 = v16;
                signed __int32 v16 = (void *)*v16;
              }

              while (v16);
            }

            else
            {
              do
              {
                int v17 = (void *)v11[2];
                BOOL v18 = *v17 == (void)v11;
                unint64_t v11 = v17;
              }

              while (!v18);
            }

            unint64_t v11 = v17;
          }

          while (v17 != v9 + 6);
        }

        unint64_t v23 = (void *)v9[1];
        if (v23)
        {
          do
          {
            BOOL v24 = v23;
            unint64_t v23 = (void *)*v23;
          }

          while (v23);
        }

        else
        {
          do
          {
            BOOL v24 = (void *)v9[2];
            BOOL v18 = *v24 == (void)v9;
            BOOL v9 = v24;
          }

          while (!v18);
        }

        BOOL v9 = v24;
      }

      while (v24 != (void *)(a1 + 88));
    }
  }

void sub_1005C6A88(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1005C75C4(a1);
  operator delete(v1);
}

id sub_1005C6A9C(uint64_t a1, int a2, void *a3)
{
  id result = sub_1005C7120(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_1005C6AE8(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_1005C6B14(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_1005C6B40(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  sub_1005C3F7C((uint64_t)v1);
  v4[0] = v1[14];
  memset(&v4[1], 0, 24);
  int v3 = 0;
  return (*(uint64_t (**)(void *, int *, void *, uint64_t, uint64_t, void))(*v1 + 152LL))( v1,  &v3,  v4,  1LL,  0xFFFFFFFFLL,  0LL);
}

CLCppContainer *sub_1005C6BA0(_OWORD *a1)
{
  int v2 = operator new(0x20uLL);
  __int128 v3 = a1[1];
  *int v2 = *a1;
  v2[1] = v3;
  uint64_t v5 = _NSConcreteStackBlock;
  uint64_t v6 = 3221225472LL;
  __int128 v7 = sub_1005C7110;
  uint64_t v8 = &unk_10181D3D0;
  BOOL v9 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_1005C6C20(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    uint64_t v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      BOOL v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          __int128 v12 = (uint64_t *)v4;
        }
        else {
          __int128 v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          BOOL v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        float v50 = v9;
        id v13 = sub_1005C7120(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        int v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          int v15 = a1 + 11;
          signed __int32 v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            BOOL v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                int v22 = (uint64_t *)v17;
              }
              else {
                int v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                BOOL v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              uint64_t v49 = v19;
              sub_1005C6FF4(a1, (uint64_t)&v49, (uint64_t)&v50, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              int v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  char v32 = (uint64_t *)v27;
                }
                else {
                  char v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  int v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              float v50 = v29;
              uint64_t v34 = v29[6];
              int v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                __int16 v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    unint64_t v39 = (uint64_t *)v36;
                  }
                  else {
                    unint64_t v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    __int16 v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      int v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      int v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      int v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  BOOL v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      int v14 = v43;
                      BOOL v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      int v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      __int16 v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              uint64_t v49 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101842368);
              }
              BOOL v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                uint64_t v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)std::stringbuf::string_type buf = 136446466;
                BOOL v56 = v25;
                __int16 v57 = 1026;
                int v58 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101842368);
                }
                __int16 v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v51 = 136446466;
                uint64_t v52 = v45;
                __int16 v53 = 1026;
                int v54 = v46;
                LODWORD(v4_Block_object_dispose(va, 8) = 18;
                uint64_t v47 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                                &v51,
                                v48);
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLWatchOrientationSettingsNotifier_Type::Notification, CLWatchOrientationSettingsNotif ier_Type::NotificationData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notifica tion_T = CLWatchOrientationSettingsNotifier_Type::Notification, NotificationData_T = CLWatchOrientatio nSettingsNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
              }
            }
          }

          while (v14 != v50 + 6);
        }
      }
    }
  }

_BYTE *sub_1005C6FF4(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    __int128 v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(vsub_100210A00(v2 + 13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_1005C7120(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40LL);
    int v14 = (int *)(*(void *)a2 + 32LL);
    __int128 v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    id result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

void sub_1005C70D0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101842498;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005C70E4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101842498;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_1005C7110(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

id sub_1005C7120(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppEncodableDataContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_1005C7198(a1);
  }
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v4) & 1) != 0) {
    return sub_1005C7350(a1);
  }
  else {
    return 0LL;
  }
}

id sub_1005C7198(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return sub_1005C7524((uint64_t)&v8, a1);
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018424D8);
    }
    uint64_t v3 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_DWORD *)std::stringbuf::string_type buf = 134218498;
    id v10 = v2;
    __int16 v11 = 2048;
    uint64_t v12 = 0LL;
    __int16 v13 = 2080;
    unint64_t v14 = 0x800000010130ACA7LL & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v4 = (os_log_s *)v3;
    os_log_type_t v5 = OS_LOG_TYPE_ERROR;
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018424D8);
    }
    uint64_t v7 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    *(_DWORD *)std::stringbuf::string_type buf = 134218498;
    id v10 = v2;
    __int16 v11 = 2048;
    uint64_t v12 = 0LL;
    __int16 v13 = 2080;
    unint64_t v14 = 0x800000010130ACA7LL & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v4 = (os_log_s *)v7;
    os_log_type_t v5 = OS_LOG_TYPE_FAULT;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v4,  v5,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has cha nged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
  return 0LL;
}

id sub_1005C7350(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018424D8);
    }
    uint64_t v3 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    int v8 = 134218498;
    id v9 = v2;
    __int16 v10 = 2048;
    uint64_t v11 = 0LL;
    __int16 v12 = 2080;
    unint64_t v13 = 0x800000010130ACA7LL & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v4 = (os_log_s *)v3;
    os_log_type_t v5 = OS_LOG_TYPE_ERROR;
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018424D8);
    }
    uint64_t v7 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    int v8 = 134218498;
    id v9 = v2;
    __int16 v10 = 2048;
    uint64_t v11 = 0LL;
    __int16 v12 = 2080;
    unint64_t v13 = 0x800000010130ACA7LL & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v4 = (os_log_s *)v7;
    os_log_type_t v5 = OS_LOG_TYPE_FAULT;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v4,  v5,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has cha nged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  (uint8_t *)&v8,  0x20u);
  return 0LL;
}

id sub_1005C7524(uint64_t a1, void *a2)
{
  if (![a2 cppObjectPtr]
    && objc_msgSend(objc_msgSend(a2, "compatibilityInfo"), "isEqual:", &off_1018D35F0))
  {
    if (objc_msgSend(objc_msgSend(a2, "serialized"), "length") != (id)32) {
      sub_101240418();
    }
    objc_msgSend(a2, "setCppObjectPtr:", objc_msgSend(objc_msgSend(a2, "serialized"), "bytes"));
  }

  return [a2 cppObjectPtr];
}

void sub_1005C7598(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

uint64_t sub_1005C75C4(uint64_t a1)
{
  *(void *)a1 = off_101842508;
  id v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *id v2 = 0LL;
  *(void *)(a1 + 16) = 0LL;
  return a1;
}

CLCppContainer *sub_1005C7624(_OWORD *a1)
{
  id v2 = operator new(0x20uLL);
  __int128 v3 = a1[1];
  *id v2 = *a1;
  v2[1] = v3;
  os_log_type_t v5 = _NSConcreteStackBlock;
  uint64_t v6 = 3221225472LL;
  uint64_t v7 = sub_1005C76A4;
  int v8 = &unk_10181D3D0;
  id v9 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_1005C76A4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t sub_1005C76B4(uint64_t a1)
{
  *(void *)a1 = off_101842530;
  *(_BYTE *)(a1 + sub_100210A00(v2 + 13) = 1;
  id v2 = (BOOL *)(a1 + 13);
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = 1065353216;
  __asm { FMOV            V0.2S, #1.0 }

  *(void *)(a1 + 16) = _D0;
  int v8 = (float *)(a1 + 16);
  sub_1005EF1AC(a1 + 24, 2065LL, 0LL);
  uint64_t v9 = sub_1006E27E8();
  sub_100413284(v9, buf);
  __int16 v10 = (_BYTE *)(a1 + 12);
  char v11 = sub_1002A6F64(*(uint64_t *)buf, "EnableStepperLoadCal", (BOOL *)(a1 + 12));
  char v12 = v11;
  unint64_t v13 = v45;
  if (v45)
  {
    p_shared_owners = (unint64_t *)&v45->__shared_owners_;
    do
      unint64_t v15 = __ldaxr(p_shared_owners);
    while (__stlxr(v15 - 1, p_shared_owners));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
      if ((v12 & 1) != 0) {
        goto LABEL_7;
      }
      goto LABEL_6;
    }
  }

  if ((v11 & 1) == 0) {
LABEL_6:
  }
    _BYTE *v10 = 0;
LABEL_7:
  uint64_t v16 = sub_1006E27E8();
  sub_100413284(v16, buf);
  sub_1002A6F64(*(uint64_t *)buf, "EnableStepperHRModel", v2);
  uint64_t v17 = v45;
  if (v45)
  {
    int v18 = (unint64_t *)&v45->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  uint64_t v20 = sub_1006E27E8();
  sub_100413284(v20, buf);
  sub_1002A81F8(*(uint64_t *)buf, "StairModelMetsScale", v8);
  BOOL v21 = v45;
  if (v45)
  {
    int v22 = (unint64_t *)&v45->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  uint64_t v24 = sub_1006E27E8();
  sub_100413284(v24, buf);
  uint64_t v25 = (float *)(a1 + 20);
  sub_1002A81F8(*(uint64_t *)buf, "StepperVO2MaxScalingFactor", (float *)(a1 + 20));
  int v26 = v45;
  if (v45)
  {
    uint64_t v27 = (unint64_t *)&v45->__shared_owners_;
    do
      unint64_t v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101842570);
  }
  int v29 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    int v30 = *v10;
    BOOL v31 = *v2;
    double v32 = *v8;
    double v33 = *v25;
    *(_DWORD *)std::stringbuf::string_type buf = 67109888;
    *(_DWORD *)&uint8_t buf[4] = v30;
    LOWORD(v45) = 1024;
    *(_DWORD *)((char *)&v45 + 2) = v31;
    HIWORD(v45) = 2048;
    double v46 = v32;
    __int16 v47 = 2048;
    double v48 = v33;
    _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEBUG,  "Stair Climbing, load calibration, %d, HR mode, %d, mets scaling factor, %f, VO2max scaling factor, %f",  buf,  0x22u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101842570);
    }
    BOOL v35 = *v2;
    double v36 = *v8;
    double v37 = *v25;
    double v39 = COERCE_DOUBLE(__PAIR64__(*v10, 67109888));
    LOWORD(v40) = 1024;
    *(_DWORD *)((char *)&v40 + 2) = v35;
    HIWORD(v40) = 2048;
    double v41 = v36;
    __int16 v42 = 2048;
    double v43 = v37;
    BOOL v38 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Stair Climbing, load calibration, %d, HR mode, %d, mets scaling factor, %f, VO2max scaling factor, %f",  &v39,  34,  v39,  v40);
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLNatalieStairClimbingModel::CLNatalieStairClimbingModel()", "%s\n", v38);
  }

  return a1;
}

void sub_1005C7AA4(_Unwind_Exception *a1)
{
}

void *sub_1005C7AE8(void *a1)
{
  id v2 = (void *)a1[15];
  if (v2)
  {
    a1[16] = v2;
    operator delete(v2);
  }

  __int128 v3 = (void *)a1[12];
  if (v3)
  {
    a1[13] = v3;
    operator delete(v3);
  }

  uint64_t v4 = (void *)a1[9];
  if (v4)
  {
    a1[10] = v4;
    operator delete(v4);
  }

  sub_10000AE14((uint64_t)(a1 + 7));
  os_log_type_t v5 = (void *)a1[3];
  if (v5)
  {
    a1[4] = v5;
    operator delete(v5);
  }

  return a1;
}

uint64_t sub_1005C7B54(double a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a3 + 48) + 48LL))(*(void *)(a3 + 48));
  if ((_DWORD)result)
  {
    uint64_t result = (*(uint64_t (**)(void, _BYTE *, double))(**(void **)(a3 + 48) + 24LL))( *(void *)(a3 + 48),  v6,  a1);
    if (v6[208]) {
      return sub_100253308(*(void *)(a3 + 8));
    }
  }

  return result;
}

uint64_t sub_1005C7BEC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(**(void **)(a2 + 8) + 48LL))(*(void *)(a2 + 8));
}

void sub_1005C7BFC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  float v6 = *(float *)(a2 + 1368);
  float v7 = *(float *)(a2 + 1372);
  float v8 = *(float *)(a2 + 1376);
  float v9 = *(float *)(a2 + 1380);
  float v10 = *(float *)(a2 + 304);
  double v11 = *(double *)(a2 + 128);
  HIBYTE(v41) = 0;
  float v12 = (float)(fmaxf(v10, 0.0) * 4.5665) + 2.9705;
  if (v10 <= 0.0) {
    float v13 = 2.1;
  }
  else {
    float v13 = v12;
  }
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101842570);
  }
  unint64_t v14 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    double v15 = *(double *)(a2 + 600);
    *(_DWORD *)std::stringbuf::string_type buf = 134218752;
    double v55 = v11;
    __int16 v56 = 2048;
    double v57 = v10;
    __int16 v58 = 2048;
    double v59 = v13;
    __int16 v60 = 2048;
    double v61 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "Stair Climbing, Work Rate Model, timestamp, %f, step frequency, %f, WRMETS, %f, sinceLastGood, %f",  buf,  0x2Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101842570);
    }
    double v32 = *(double *)(a2 + 600);
    int v42 = 134218752;
    double v43 = v11;
    __int16 v44 = 2048;
    double v45 = v10;
    __int16 v46 = 2048;
    double v47 = v13;
    __int16 v48 = 2048;
    double v49 = v32;
    LODWORD(v39) = 42;
    double v33 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Stair Climbing, Work Rate Model, timestamp, %f, step frequency, %f, WRMETS, %f, sinceLastGood, %f",  COERCE_DOUBLE(&v42),  v39,  v40,  v41);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLNatalieStairClimbingModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v33);
  }

  if (*(_BYTE *)(a1 + 13) && sub_1003DBFB4(a2) && *(double *)(a2 + 600) < *(double *)a2)
  {
    float v16 = *(double *)(a2 + 560);
    double v17 = v16;
    double v18 = v8;
    double v19 = v9;
    float v20 = (v19 - v16) / (v19 - v18);
    float v21 = v6 * sub_100D086F8(v20, v7);
    float v22 = *(float *)(a1 + 20);
    if (qword_1019344D0 != -1)
    {
      LODWORD(v41) = *(_DWORD *)(a1 + 20);
      dispatch_once(&qword_1019344D0, &stru_101842570);
      float v22 = *(float *)&v41;
    }

    float v23 = v21 * v22;
    uint64_t v24 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134219264;
      double v55 = v11;
      __int16 v56 = 2048;
      double v57 = v17;
      __int16 v58 = 2048;
      double v59 = v19;
      __int16 v60 = 2048;
      double v61 = v18;
      __int16 v62 = 2048;
      double v63 = v6;
      __int16 v64 = 2048;
      double v65 = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "Stair Climbing, HR Rate Model, timestamp, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherinemin(cpm), %f, vo2max(METs), %f, METS, %f",  buf,  0x3Eu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101842570);
      }
      int v42 = 134219264;
      double v43 = v11;
      __int16 v44 = 2048;
      double v45 = v17;
      __int16 v46 = 2048;
      double v47 = v19;
      __int16 v48 = 2048;
      double v49 = v18;
      __int16 v50 = 2048;
      double v51 = v6;
      __int16 v52 = 2048;
      double v53 = v23;
      LODWORD(v39) = 62;
      double v36 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Stair Climbing, HR Rate Model, timestamp, %f, catherine(cpm), %f, catherinemax(cpm), %f, catherine min(cpm), %f, vo2max(METs), %f, METS, %f",  COERCE_DOUBLE(&v42),  v39,  v40,  v41);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLNatalieStairClimbingModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v36);
    }

    if (*(_BYTE *)(a1 + 12))
    {
      sub_1005EF1B0((char *)(a1 + 24), a2, (_BYTE *)&v41 + 7, v11, v23, v13);
      *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = v25;
    }

    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101842570);
    }
    int v26 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      double v27 = *(float *)(a1 + 8);
      *(_DWORD *)std::stringbuf::string_type buf = 134219008;
      double v55 = v11;
      __int16 v56 = 2048;
      double v57 = v23;
      __int16 v58 = 2048;
      double v59 = v13;
      __int16 v60 = 2048;
      double v61 = v27;
      __int16 v62 = 1024;
      LODWORD(v63) = HIBYTE(v41);
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "Stair Climbing, timestamp, %f, HRMETs, %f, WRMETs, %f, calibrationValue, %f, loadCalStatus, %d",  buf,  0x30u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101842570);
      }
      double v37 = *(float *)(a1 + 8);
      int v42 = 134219008;
      double v43 = v11;
      __int16 v44 = 2048;
      double v45 = v23;
      __int16 v46 = 2048;
      double v47 = v13;
      __int16 v48 = 2048;
      double v49 = v37;
      __int16 v50 = 1024;
      LODWORD(v51) = HIBYTE(v41);
      LODWORD(v39) = 48;
      BOOL v38 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Stair Climbing, timestamp, %f, HRMETs, %f, WRMETs, %f, calibrationValue, %f, loadCalStatus, %d",  COERCE_DOUBLE(&v42),  v39,  v40,  v41);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLNatalieStairClimbingModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v38);
    }

    int v28 = 1;
    float v29 = v23;
  }

  else
  {
    int v28 = 0;
    float v23 = v13 * *(float *)(a1 + 8);
    float v29 = 0.0;
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101842570);
  }
  int v30 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    double v31 = *(float *)(a1 + 16);
    *(_DWORD *)std::stringbuf::string_type buf = 134218496;
    double v55 = v11;
    __int16 v56 = 2048;
    double v57 = v23;
    __int16 v58 = 2048;
    double v59 = v31;
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "Stair Climbing, timestamp, %f, finalMETS, %f, fMetsScaling, %f",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101842570);
    }
    double v34 = *(float *)(a1 + 16);
    int v42 = 134218496;
    double v43 = v11;
    __int16 v44 = 2048;
    double v45 = v23;
    __int16 v46 = 2048;
    double v47 = v34;
    LODWORD(v39) = 32;
    BOOL v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Stair Climbing, timestamp, %f, finalMETS, %f, fMetsScaling, %f",  COERCE_DOUBLE(&v42),  v39,  v40);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLNatalieStairClimbingModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v35);
  }

  *(float *)a3 = v29;
  *(float *)(a3 + 4) = v13;
  *(_DWORD *)(a3 + _Block_object_dispose(va, 8) = 0;
  *(float *)(a3 + 12) = v13;
  *(_DWORD *)(a3 + 16) = 0;
  *(float *)(a3 + 20) = v23 * *(float *)(a1 + 16);
  *(_DWORD *)(a3 + 24) = v28;
  *(_DWORD *)(a3 + 2_Block_object_dispose(va, 8) = 0;
  *(void *)(a3 + 32) = 0xA00000003LL;
}

void *sub_1005C8420(void *a1)
{
  *a1 = off_101842530;
  id v2 = (void *)a1[18];
  if (v2)
  {
    a1[19] = v2;
    operator delete(v2);
  }

  __int128 v3 = (void *)a1[15];
  if (v3)
  {
    a1[16] = v3;
    operator delete(v3);
  }

  uint64_t v4 = (void *)a1[12];
  if (v4)
  {
    a1[13] = v4;
    operator delete(v4);
  }

  sub_10000AE14((uint64_t)(a1 + 10));
  os_log_type_t v5 = (void *)a1[6];
  if (v5)
  {
    a1[7] = v5;
    operator delete(v5);
  }

  return a1;
}

void sub_1005C8494(void *a1)
{
  *a1 = off_101842530;
  id v2 = (void *)a1[18];
  if (v2)
  {
    a1[19] = v2;
    operator delete(v2);
  }

  __int128 v3 = (void *)a1[15];
  if (v3)
  {
    a1[16] = v3;
    operator delete(v3);
  }

  uint64_t v4 = (void *)a1[12];
  if (v4)
  {
    a1[13] = v4;
    operator delete(v4);
  }

  sub_10000AE14((uint64_t)(a1 + 10));
  os_log_type_t v5 = (void *)a1[6];
  if (v5)
  {
    a1[7] = v5;
    operator delete(v5);
  }

  operator delete(a1);
}

void sub_1005C8508(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

void sub_1005C8534(int a1@<W0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  if (a1)
  {
    float v7 = operator new(0x140uLL);
    float v8 = v7;
    float v9 = (std::__shared_weak_count *)a3[1];
    uint64_t v20 = *a3;
    float v21 = v9;
    if (v9)
    {
      p_shared_owners = (unint64_t *)&v9->__shared_owners_;
      do
        unint64_t v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }

    sub_100C0AA8C((uint64_t)v7, &v20, a2);
    float v12 = v21;
    if (v21)
    {
      float v13 = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      goto LABEL_15;
    }
  }

  else
  {
    double v15 = operator new(0x250uLL);
    float v8 = v15;
    float v16 = (std::__shared_weak_count *)a3[1];
    uint64_t v20 = *a3;
    float v21 = v16;
    if (v16)
    {
      double v17 = (unint64_t *)&v16->__shared_owners_;
      do
        unint64_t v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
    }

    sub_100355960((uint64_t)v15, &v20, a2);
    float v12 = v21;
    if (v21)
    {
      double v19 = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v14 = __ldaxr(v19);
      while (__stlxr(v14 - 1, v19));
LABEL_15:
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }

  *a4 = v8;
}

void sub_1005C8640( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10)
  {
    p_shared_owners = (unint64_t *)&a10->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(p_shared_owners);
    while (__stlxr(v13 - 1, p_shared_owners));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))a10->__on_zero_shared)(a10);
      std::__shared_weak_count::__release_weak(a10);
    }
  }

  operator delete(v10);
  _Unwind_Resume(a1);
}

void *sub_1005C86B0(void *result, uint64_t a2)
{
  *uint64_t result = &off_1018425A0;
  result[1] = a2;
  return result;
}

void sub_1005C86C0(uint64_t a1, std::string *a2)
{
  id v3 = objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "vendor"), "proxyForService:", @"CLClientManager");
  id v4 = [v3 syncgetNonSystemLocationClientKey];
  if (v4)
  {
    sub_1010DDBC0(buf, (char *)[v4 UTF8String]);
    p_data = (void **)&a2[2].__r_.__value_.__l.__data_;
    *(_OWORD *)p_data = *(_OWORD *)buf;
    a2[2].__r_.__value_.__l.__cap_ = v19;
  }

  else
  {
    std::string::assign(a2 + 2, "");
  }

  id v6 = [v3 syncgetLocationClientKeys];
  if ([v6 count])
  {
    id v15 = 0LL;
    float v7 = +[NSJSONSerialization dataWithJSONObject:options:error:]( NSJSONSerialization,  "dataWithJSONObject:options:error:",  [v6 allObjects],  1,  &v15);
    if (v15)
    {
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_1018425F8);
      }
      float v8 = (os_log_s *)qword_1019349B8;
      if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
      {
        id v9 = objc_msgSend(objc_msgSend(v15, "description"), "UTF8String");
        *(_DWORD *)std::stringbuf::string_type buf = 136315138;
        *(void *)&uint8_t buf[4] = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#warning: error serializing json data, error, %s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349B0 != -1) {
          dispatch_once(&qword_1019349B0, &stru_1018425F8);
        }
        uint64_t v10 = qword_1019349B8;
        id v11 = objc_msgSend(objc_msgSend(v15, "description"), "UTF8String");
        int v16 = 136315138;
        id v17 = v11;
        float v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  0LL,  "#warning: error serializing json data, error, %s",  (const char *)&v16);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLPolicyTripExternal::applyBundleId(CLTracksHarvestDataType::HarvestData &)",  "%s\n",  v12);
      }
    }

    else
    {
      unint64_t v13 = -[NSString initWithData:encoding:](objc_alloc(&OBJC_CLASS___NSString), "initWithData:encoding:", v7, 4LL);
      unint64_t v14 = v13;
      if (v13)
      {
        std::string::assign(a2 + 3, -[NSString UTF8String](v13, "UTF8String"));
      }
    }
  }

  else
  {
    std::string::assign(a2 + 3, "");
  }

uint64_t sub_1005C897C()
{
  return 0LL;
}

__n128 sub_1005C8984@<Q0>(uint64_t a1@<X8>)
{
  __int128 v2 = v9;
  *(_OWORD *)(a1 + 96) = v8;
  *(_OWORD *)(a1 + sub_10004AD90(v15 - 112) = v2;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = v10;
  __int128 v3 = *(_OWORD *)&v6.isVehicleConnected;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v6.isStanding;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = v3;
  __int128 v4 = v7;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)&v6.vehicleType;
  *(_OWORD *)(a1 + 80) = v4;
  __n128 result = *(__n128 *)&v6.mountedConfidence;
  *(_OWORD *)a1 = *(_OWORD *)&v6.type;
  *(__n128 *)(a1 + 16) = result;
  return result;
}

id sub_1005C89E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v3 = objc_msgSend( objc_msgSend( objc_msgSend(*(id *)(a1 + 8), "vendor", 0, 0, 0),  "proxyForService:",  @"CLTelephonyService"),  "syncgetServingCells:addNeighborCells:",  &v5,  a3);
  CLMotionActivity v6 = (void **)&v5;
  sub_1005C8A94(&v6);
  return v3;
}

void sub_1005C8A4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_1005C8A94(&a12);
  _Unwind_Resume(a1);
}

void sub_1005C8A68(id a1)
{
  qword_1019349B8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

void sub_1005C8A94(void ***a1)
{
  uint64_t v1 = *a1;
  __int128 v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 696LL;
        sub_10032B988((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

id sub_1005CA0E8(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842658);
  }
  __int128 v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#diagnosticManager Interruption handler called",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842658);
    }
    v5[0] = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#diagnosticManager Interruption handler called",  v5,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLDiagnosticManager listener:shouldAcceptNewConnection:]_block_invoke",  "%s\n",  v4);
  }

  return [*(id *)(a1 + 32) setConnection:0];
}

id sub_1005CA290(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842658);
  }
  __int128 v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#diagnosticManager Invalidation handler called",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842658);
    }
    v5[0] = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#diagnosticManager Invalidation handler called",  v5,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLDiagnosticManager listener:shouldAcceptNewConnection:]_block_invoke",  "%s\n",  v4);
  }

  return [*(id *)(a1 + 32) setConnection:0];
}

void sub_1005CA7C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005CA834(id a1)
{
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  __int128 v2 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p);
  if (v4 < 0) {
    operator delete(v3[0]);
  }
  qword_101997258 = -[NSURL initWithString:]( [NSURL alloc],  "initWithString:",  -[NSString stringByAppendingPathComponent:]( v2,  "stringByAppendingPathComponent:",  [&off_1018D6D48 componentsJoinedByString:@"/"]));
}

void sub_1005CA8FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005CA990(id a1)
{
  qword_101997268 = objc_opt_new(&OBJC_CLASS___NSDateFormatter);
  [(id)qword_101997268 setDateFormat:@"yyyy-MM-dd_HH-mm-ss"];
}

void sub_1005CAA2C(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void sub_1005CAA58(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

uint64_t *sub_1005CAA84(uint64_t *a1, uint64_t a2)
{
  *a1 = a2;
  *((_DWORD *)a1 + 2) = 0;
  *(uint64_t *)((char *)a1 + 12) = 0x500000000LL;
  a1[5] = 0x400000000LL;
  if (!a2 || *(unsigned __int8 *)(a2 + 16) >= 5u)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018426B8);
    }
    char v4 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v5 = *a1;
      int v6 = *(unsigned __int8 *)(*a1 + 16);
      *(_DWORD *)std::stringbuf::string_type buf = 134218496;
      uint64_t v17 = v5;
      __int16 v18 = 1024;
      int v19 = v6;
      __int16 v20 = 1024;
      int v21 = 4;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "Assertion failed: (fIirFilterParams != __null) && (fIirFilterParams->filterOrder <= kMaxFilterOrder), file /Libr ary/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMIirFilter.cpp, line 17,IirFilterParams,%p,filterOrder,%d,m axFilterOrder,%d.",  buf,  0x18u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018426B8);
      }
      uint64_t v7 = *a1;
      int v8 = *(unsigned __int8 *)(*a1 + 16);
      int v10 = 134218496;
      uint64_t v11 = v7;
      __int16 v12 = 1024;
      int v13 = v8;
      __int16 v14 = 1024;
      int v15 = 4;
      __int128 v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: (fIirFilterParams != __null) && (fIirFilterParams->filterOrder <= kMaxFilterOrder), file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMIirFilter.cpp, line 17,IirFilter Params,%p,filterOrder,%d,maxFilterOrder,%d.",  &v10,  24);
      sub_10029211C("Generic", 1LL, 0, 0LL, "CMIirFilter::CMIirFilter(const CMIirFilterParams *)", "%s\n", v9);
    }
  }

  *((_DWORD *)a1 + 3) = 0;
  *((_DWORD *)a1 + 10) = 0;
  return a1;
}

uint64_t sub_1005CACAC(uint64_t result)
{
  *(_DWORD *)(result + 12) = 0;
  *(_DWORD *)(result + 40) = 0;
  return result;
}

unsigned __int16 *sub_1005CACBC(unsigned __int16 *result, float a2)
{
  __int128 v2 = result;
  char v4 = result + 6;
  uint64_t v3 = result[6];
  uint64_t v5 = result[7];
  unint64_t v6 = *((unsigned int *)result + 4);
  if (v3 + v5 >= v6) {
    uint64_t v7 = *((unsigned int *)result + 4);
  }
  else {
    uint64_t v7 = 0LL;
  }
  *(float *)&v4[2 * (v3 + v5 - v7) + 4] = a2;
  if (v6 <= v5)
  {
    unint64_t v8 = v3 + 1;
    if (v8 < v6) {
      LOWORD(v6) = 0;
    }
    *char v4 = v8 - v6;
  }

  else
  {
    result[7] = v5 + 1;
    uint64_t v5 = (unsigned __int16)(v5 + 1);
  }

  unsigned int v9 = *(unsigned __int8 *)(*(void *)result + 16LL);
  uint64_t v10 = result[21];
  if (v10 >= v9)
  {
    unsigned __int8 v14 = 0;
    *((_DWORD *)result + 2) = 0;
    do
    {
      uint64_t v15 = v14;
      int v16 = v14;
      float v17 = *(float *)(**(void **)v2 + 4LL * v14);
      float v18 = *((float *)v2 + 2) + (float)(v17 * *(float *)sub_100208A44(v4, v5 + ~(unint64_t)v14));
      *((float *)v2 + 2) = v18;
      if (v16)
      {
        float v19 = *(float *)(*(void *)(*(void *)v2 + 8LL) + 4 * v15);
        float v18 = *((float *)v2 + 2) - (float)(v19 * *(float *)sub_100208A44(v2 + 20, v10 - v15));
        *((float *)v2 + 2) = v18;
      }

      unsigned __int8 v14 = v15 + 1;
    }

    while (v9 >= (v15 + 1));
    *((float *)v2 + 2) = v18 / **(float **)(*(void *)v2 + 8LL);
    return sub_1005CAE5C(v2 + 20, (_DWORD *)v2 + 2);
  }

  else
  {
    uint64_t v11 = result[20];
    unint64_t v12 = *((unsigned int *)result + 11);
    if (v11 + v10 >= v12) {
      uint64_t v13 = *((unsigned int *)result + 11);
    }
    else {
      uint64_t v13 = 0LL;
    }
    *(float *)&result[2 * (v11 + v10 - v13) + 24] = a2;
    if (v12 <= v10)
    {
      unint64_t v20 = v11 + 1;
      if (v20 < v12) {
        LOWORD(v12) = 0;
      }
      result[20] = v20 - v12;
    }

    else
    {
      result[21] = v10 + 1;
    }

    *((float *)result + 2) = a2;
  }

  return result;
}

unsigned __int16 *sub_1005CAE5C(unsigned __int16 *result, _DWORD *a2)
{
  uint64_t v2 = result[1];
  unint64_t v3 = *((unsigned int *)result + 1);
  uint64_t v4 = *result;
  if (v4 + v2 >= v3) {
    uint64_t v5 = *((unsigned int *)result + 1);
  }
  else {
    uint64_t v5 = 0LL;
  }
  *(_DWORD *)&result[2 * (v4 + v2 - v5) + 4] = *a2;
  if (v3 <= v2)
  {
    if (v4 + 1 < v3) {
      LOWORD(v3) = 0;
    }
    *__n128 result = v4 + 1 - v3;
  }

  else
  {
    result[1] = v2 + 1;
  }

  return result;
}

void sub_1005CAEB0(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_1005CAEDC(void *a1@<X8>)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_1019972B8);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1019972B8))
  {
    __cxa_atexit((void (*)(void *))sub_1005CAFE4, &qword_1019972A8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1019972B8);
  }

  if (!qword_1019972A8 || !sub_100400B64(qword_1019972A8))
  {
    sub_1005CE460((unsigned __int8 *)&qword_101997278, &v9);
    sub_10005F550((uint64_t)&qword_1019972A8, &v9);
    unint64_t v3 = (std::__shared_weak_count *)*((void *)&v9 + 1);
    if (*((void *)&v9 + 1))
    {
      uint64_t v4 = (unint64_t *)(*((void *)&v9 + 1) + 8LL);
      do
        unint64_t v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }

  uint64_t v6 = unk_1019972B0;
  *a1 = qword_1019972A8;
  a1[1] = v6;
  if (v6)
  {
    uint64_t v7 = (unint64_t *)(v6 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

void sub_1005CAFE8(void *a1@<X8>)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_1019972D0);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_1019972D0))
  {
    __cxa_atexit((void (*)(void *))sub_1005CAFE4, &qword_1019972C0, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1019972D0);
  }

  if (!qword_1019972C0 || !sub_100400B64(qword_1019972C0))
  {
    sub_1005CE460((unsigned __int8 *)&qword_101997290, &v9);
    sub_10005F550((uint64_t)&qword_1019972C0, &v9);
    unint64_t v3 = (std::__shared_weak_count *)*((void *)&v9 + 1);
    if (*((void *)&v9 + 1))
    {
      uint64_t v4 = (unint64_t *)(*((void *)&v9 + 1) + 8LL);
      do
        unint64_t v5 = __ldaxr(v4);
      while (__stlxr(v5 - 1, v4));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }

  uint64_t v6 = *(void *)algn_1019972C8;
  *a1 = qword_1019972C0;
  a1[1] = v6;
  if (v6)
  {
    uint64_t v7 = (unint64_t *)(v6 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

uint64_t sub_1005CB0F0(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  uint64_t v4 = a2;
  if ((char)a2[23] < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    *(_OWORD *)__dst = *(_OWORD *)a2;
    uint64_t v23 = *((void *)a2 + 2);
  }

  float v17 = (void *)(&_mh_execute_header + 2);
  __int16 v18 = 256;
  if (*((char *)a3 + 23) < 0)
  {
    sub_1010DD48C(&__p, *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 __p = *a3;
    uint64_t v20 = *((void *)a3 + 2);
  }

  uint64_t v21 = 0LL;
  sub_100CC0268(a1, (__int128 *)__dst, (uint64_t *)&v17, -1.0);
  if (SHIBYTE(v20) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(__dst[0]);
  }
  *(void *)a1 = off_1018426E8;
  sub_1010DDBC0(&v17, "ff:ff:ff:ff:ff:ff");
  *(void *)(a1 + 256) = sub_1007EBE44((uint64_t *)&v17);
  if (SBYTE7(__p) < 0) {
    operator delete(v17);
  }
  sub_100D2D9A4(a1 + 264);
  sub_1008076C4(a1 + 304);
  *(void *)(a1 + 360) = 0LL;
  *(void *)(a1 + 36_Block_object_dispose(va, 8) = 0LL;
  sub_1010DDBC0((void *)(a1 + 376), "UnknownHarvest");
  uint64_t v6 = v4[23];
  size_t v7 = *((void *)v4 + 1);
  if ((v6 & 0x80u) == 0LL) {
    uint64_t v8 = v4[23];
  }
  else {
    uint64_t v8 = *((void *)v4 + 1);
  }
  uint64_t v9 = qword_101997280;
  if (byte_10199728F >= 0) {
    uint64_t v9 = byte_10199728F;
  }
  if (v8 != v9) {
    goto LABEL_29;
  }
  if (byte_10199728F >= 0) {
    uint64_t v10 = &qword_101997278;
  }
  else {
    uint64_t v10 = (uint64_t *)qword_101997278;
  }
  if ((v6 & 0x80) != 0)
  {
LABEL_41:
    uint64_t v11 = "GpsHarvest";
LABEL_44:
    std::string::assign((std::string *)(a1 + 376), v11);
    goto LABEL_45;
  }

  if (!v4[23]) {
    goto LABEL_41;
  }
  uint64_t v11 = "GpsHarvest";
  unint64_t v12 = v4;
  uint64_t v13 = v4[23];
  while (*v12 == *(unsigned __int8 *)v10)
  {
    ++v12;
    uint64_t v10 = (uint64_t *)((char *)v10 + 1);
    if (!--v13) {
      goto LABEL_44;
    }
  }

void sub_1005CB384( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005CB410(uint64_t a1)
{
  *(void *)a1 = off_10187D490;
  return sub_10040063C(a1);
}

void *sub_1005CB450@<X0>(__int128 *a1@<X0>, void *a2@<X8>)
{
  return sub_1005CE5D4((unsigned __int8 *)&qword_101997278, a1, a2);
}

void *sub_1005CB47C@<X0>(__int128 *a1@<X0>, void *a2@<X8>)
{
  return sub_1005CE5D4((unsigned __int8 *)&qword_101997290, a1, a2);
}

uint64_t sub_1005CB4A8(uint64_t a1)
{
  unsigned __int8 v2 = sub_100F4BF44();
  uint64_t v4 = v47;
  if (v47)
  {
    int v34 = v2[2];
    uint64_t v35 = a1 + 376;
    *(void *)&__int128 v3 = 136315906LL;
    __int128 v33 = v3;
    do
    {
      uint64_t v5 = v4[3];
      unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v4[4] - v5) >> 6);
      BOOL v7 = v6 > v34;
      unint64_t v8 = v6 - v34;
      if (v7)
      {
        uint64_t v9 = v5 + 192 * v8;
        __int128 v10 = *(_OWORD *)(v9 + 24);
        __int128 v38 = *(_OWORD *)(v9 + 8);
        __int128 v39 = v10;
        __int128 v11 = *(_OWORD *)(v9 + 40);
        __int128 v12 = *(_OWORD *)(v9 + 56);
        __int128 v13 = *(_OWORD *)(v9 + 88);
        *(_OWORD *)int v42 = *(_OWORD *)(v9 + 72);
        *(_OWORD *)&v42[16] = v13;
        __int128 v40 = v11;
        __int128 v41 = v12;
        __int128 v14 = *(_OWORD *)(v9 + 104);
        __int128 v15 = *(_OWORD *)(v9 + 120);
        __int128 v16 = *(_OWORD *)(v9 + 136);
        *(_OWORD *)((char *)v45 + 12) = *(_OWORD *)(v9 + 148);
        __int128 v44 = v15;
        v45[0] = v16;
        __int128 v43 = v14;
        double Current = CFAbsoluteTimeGetCurrent();
        double v18 = *(double *)&v42[12];
        if (qword_101934A20 != -1) {
          dispatch_once(&qword_101934A20, &stru_101842718);
        }
        double v19 = Current - v18;
        uint64_t v20 = (os_log_s *)off_101934A28;
        if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEBUG))
        {
          std::operator+<char>(v48, "WifiAssociatedApHarvestDatabase, ", v35);
          int v21 = SHIBYTE(v51);
          float v22 = *(_BYTE **)v48;
          sub_1007EC360(&__p);
          uint64_t v23 = v48;
          if (v21 < 0) {
            uint64_t v23 = v22;
          }
          p_p = &__p;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::stringbuf::string_type buf = v33;
          __int16 v56 = v23;
          __int16 v57 = 2048;
          double v58 = v19;
          __int16 v59 = 2080;
          __int16 v60 = p_p;
          __int16 v61 = 1024;
          int v62 = v34;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "%s, deleting samples older than %.1f(s) for mac %s to keep maximum %d samples",  buf,  0x26u);
          if (SHIBYTE(v51) < 0) {
            operator delete(*(void **)v48);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A20 != -1) {
            dispatch_once(&qword_101934A20, &stru_101842718);
          }
          int v25 = off_101934A28;
          std::operator+<char>(&__p, "WifiAssociatedApHarvestDatabase, ", v35);
          int size = (char)__p.__r_.__value_.__s.__size_;
          std::string::size_type v27 = __p.__r_.__value_.__r.__words[0];
          sub_1007EC360(&v36);
          int v28 = &__p;
          if (size < 0) {
            int v28 = (std::string *)v27;
          }
          float v29 = &v36;
          if ((v36.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            float v29 = (std::string *)v36.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)__int16 v48 = v33;
          *(void *)&_DWORD v48[4] = v28;
          __int16 v49 = 2048;
          double v50 = v19;
          __int16 v51 = 2080;
          __int16 v52 = v29;
          __int16 v53 = 1024;
          int v54 = v34;
          LODWORD(v32) = 38;
          int v30 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v25,  2LL,  "%s, deleting samples older than %.1f(s) for mac %s to keep maximum %d samples",  v48,  v32,  (const char *)v33,  DWORD2(v33));
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWifiAssociatedApHarvestDatabase::deleteOldSamplesBeyondThresholdForEachAssociatedAp()",  "%s\n",  v30);
        }

        sub_100CC0DBC(a1, (uint64_t)(v4 + 2), (double *)&v42[12]);
      }

      uint64_t v4 = (void *)*v4;
    }

    while (v4);
  }

  return sub_1005CE680((uint64_t)v46);
}

void sub_1005CB880( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
}

uint64_t sub_1005CB8DC(uint64_t a1)
{
  unint64_t v2 = *((int *)sub_100F4BF44() + 3);
  if (v30[3] > v2)
  {
    sub_1005CE6FC((uint64_t)v26, (uint64_t)v30);
    if (v28)
    {
      __int128 v3 = v27;
      uint64_t v4 = (void *)*v27;
      if (*v27)
      {
        do
        {
          uint64_t v4 = (void *)*v4;
        }

        while (v4);
      }

      uint64_t v5 = v3[2];
    }

    else
    {
      sub_1010DDBC0(__p, "ff:ff:ff:ff:ff:ff");
      uint64_t v5 = sub_1007EBE44((uint64_t *)__p);
      if (SHIBYTE(v43) < 0) {
        operator delete(*(void **)__p);
      }
    }

    uint64_t v29 = v5;
    sub_1005CE680((uint64_t)v26);
    unint64_t v6 = sub_1005CBD4C(v30, &v29);
    double Current = CFAbsoluteTimeGetCurrent();
    unint64_t v8 = sub_1005CE368(v30, &v29);
    if (!v8) {
      sub_10000C918("unordered_map::at: key not found");
    }
    double v9 = *(double *)(v8[4] - 108LL);
    if (qword_101934A20 != -1) {
      dispatch_once(&qword_101934A20, &stru_101842718);
    }
    double v10 = Current - v9;
    __int128 v11 = (os_log_s *)off_101934A28;
    if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEBUG))
    {
      std::operator+<char>(v31, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
      int v12 = SHIBYTE(v34);
      __int128 v13 = *(_BYTE **)v31;
      sub_1007EC360(&v25);
      __int128 v14 = v31;
      if (v12 < 0) {
        __int128 v14 = v13;
      }
      if ((v25.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v15 = &v25;
      }
      else {
        __int128 v15 = (std::string *)v25.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string __p = 136316162;
      *(void *)&__p[4] = v14;
      __int16 v41 = 2048;
      int v42 = v6;
      __int16 v43 = 2080;
      __int128 v44 = v15;
      __int16 v45 = 2048;
      double v46 = v10;
      __int16 v47 = 1024;
      int v48 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "%s, deleting all %zu samples for mac %s that was last harvested %.1f(s) ago to keep maximum %d distinct APs",  __p,  0x30u);
      if (SHIBYTE(v34) < 0) {
        operator delete(*(void **)v31);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A20 != -1) {
        dispatch_once(&qword_101934A20, &stru_101842718);
      }
      float v17 = off_101934A28;
      std::operator+<char>(&v25, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
      int size = (char)v25.__r_.__value_.__s.__size_;
      std::string::size_type v19 = v25.__r_.__value_.__r.__words[0];
      sub_1007EC360(&v24);
      uint64_t v20 = &v25;
      if (size < 0) {
        uint64_t v20 = (std::string *)v19;
      }
      if ((v24.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v21 = &v24;
      }
      else {
        int v21 = (std::string *)v24.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)double v31 = 136316162;
      *(void *)&_DWORD v31[4] = v20;
      __int16 v32 = 2048;
      __int128 v33 = v6;
      __int16 v34 = 2080;
      uint64_t v35 = v21;
      __int16 v36 = 2048;
      double v37 = v10;
      __int16 v38 = 1024;
      int v39 = v2;
      float v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v17,  2LL,  "%s, deleting all %zu samples for mac %s that was last harvested %.1f(s) ago to keep maximum %d distinct APs",  v31,  48,  v23,  *(double *)&v24.__r_.__value_.__l.__data_,  LODWORD(v24.__r_.__value_.__r.__words[1]));
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWifiAssociatedApHarvestDatabase::deleteAssociatedApThatHasNotBeenHarvestedForTheLongestTimeIfNecessary()",  "%s\n",  v22);
      if (v22 != __p) {
        free(v22);
      }
    }

    sub_100CC11B0(a1, (uint64_t)&v29);
  }

  return sub_1005CE680((uint64_t)v30);
}

void sub_1005CBCC0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, int a34, __int16 a35, char a36, char a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, int a43, __int16 a44, char a45, char a46)
{
}

void *sub_1005CBD4C(void *a1, void *a2)
{
  __n128 result = sub_1005CE368(a1, a2);
  if (result)
  {
    uint64_t v5 = sub_1005CE368(a1, a2);
    if (!v5) {
      sub_10000C918("unordered_map::at: key not found");
    }
    return (void *)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5[4] - v5[3]) >> 6));
  }

  return result;
}

void sub_1005CBDA8(uint64_t a1, void *a2, void *a3)
{
  if (sub_1005CE368(a2, a3))
  {
    double v6 = sub_101171D4C();
    if (v6 - *(double *)(a1 + 368) >= 600.0)
    {
      *(double *)(a1 + 36_Block_object_dispose(va, 8) = v6;
      BOOL v7 = sub_1005CE368(a2, a3);
      if (!v7) {
        sub_10000C918("unordered_map::at: key not found");
      }
      unint64_t v8 = v7;
      if (v7[4] != v7[3])
      {
        unint64_t v9 = 0LL;
        uint64_t v30 = a1 + 376;
        p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
        __int128 v11 = &OBJC_METACLASS___CLPrivacyManager.vtable;
        do
        {
          int v12 = (os_log_s *)v11[325];
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            std::operator+<char>(v33, "WifiAssociatedApHarvestDatabase, ", v30);
            __int128 v13 = v11;
            __int128 v14 = p_vtable;
            int v15 = SHIBYTE(v36);
            __int128 v16 = *(_BYTE **)v33;
            uint64_t v18 = v8[3];
            uint64_t v17 = v8[4];
            sub_100B60DDC(v18 + 192 * v9, &__p);
            std::string::size_type v19 = v33;
            if (v15 < 0) {
              std::string::size_type v19 = v16;
            }
            *(_DWORD *)std::stringbuf::string_type buf = 136315907;
            __int16 v41 = v19;
            p_p = &__p;
            if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
            }
            __int16 v42 = 2048;
            unint64_t v43 = v9 + 1;
            __int16 v44 = 2048;
            unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * ((v17 - v18) >> 6);
            __int16 v46 = 2081;
            __int16 v47 = p_p;
            _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "%s, harvest sample %zu / %zu, %{private}s",  buf,  0x2Au);
            p_vtable = v14;
            if (SHIBYTE(v36) < 0) {
              operator delete(*(void **)v33);
            }
            __int128 v11 = v13;
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            int v21 = v11[325];
            std::operator+<char>(&__p, "WifiAssociatedApHarvestDatabase, ", v30);
            int size = (char)__p.__r_.__value_.__s.__size_;
            std::string::size_type v23 = __p.__r_.__value_.__r.__words[0];
            uint64_t v25 = v8[3];
            uint64_t v24 = v8[4];
            sub_100B60DDC(v25 + 192 * v9, &v31);
            int v26 = &__p;
            if (size < 0) {
              int v26 = (std::stringbuf::string_type *)v23;
            }
            *(_DWORD *)__int128 v33 = 136315907;
            ++v9;
            *(void *)&void v33[4] = v26;
            std::string::size_type v27 = &v31;
            if ((v31.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              std::string::size_type v27 = (std::stringbuf::string_type *)v31.__r_.__value_.__r.__words[0];
            }
            __int16 v34 = 2048;
            unint64_t v35 = v9;
            __int16 v36 = 2048;
            unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((v24 - v25) >> 6);
            __int16 v38 = 2081;
            int v39 = v27;
            LODWORD(v29) = 42;
            uint64_t v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  0LL,  "%s, harvest sample %zu / %zu, %{private}s",  v33,  v29);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWifiAssociatedApHarvestDatabase::logAllHarvestSamplesOfCurrentAssociatedApIfPossible(const std::uno rdered_map<CLMacAddress, std::vector<CLWifiHarvestDatabaseEntry>> &, const CLMacAddress &)",  "%s\n",  v28);
          }

          else
          {
            ++v9;
          }
        }

        while (v9 < 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8[4] - v8[3]) >> 6));
      }
    }
  }

void sub_1005CC150( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005CC188(uint64_t a1, void *a2)
{
  if (sub_100400B64(a1))
  {
    double v4 = sub_101171D4C();
    if (v4 - *(double *)(a1 + 360) >= 10.0)
    {
      *(double *)(a1 + 360) = v4;
      sub_100CC2114(a1, (uint64_t)&v86);
      uint64_t v5 = v88;
      if (v88)
      {
        unint64_t v6 = 0LL;
        do
        {
          v6 -= 0x5555555555555555LL * ((uint64_t)(v5[4] - v5[3]) >> 6);
          uint64_t v5 = (void *)*v5;
        }

        while (v5);
      }

      else
      {
        unint64_t v6 = 0LL;
      }

      unint64_t v12 = v89;
      sub_1005CE6FC((uint64_t)v61, (uint64_t)&v86);
      if (v63)
      {
        __int128 v13 = v62;
        __int128 v14 = (void *)*v62;
        if (*v62)
        {
          do
          {
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13[4] - v13[3]) >> 6) < 0xAAAAAAAAAAAAAAABLL {
            __int128 v14 = (void *)*v14;
            }
          }

          while (v14);
        }

        uint64_t v15 = v13[2];
      }

      else
      {
        sub_1010DDBC0(__p, "ff:ff:ff:ff:ff:ff");
        uint64_t v15 = sub_1007EBE44((uint64_t *)__p);
        if (SHIBYTE(v93) < 0) {
          operator delete(*(void **)__p);
        }
      }

      uint64_t v64 = v15;
      sub_1005CE680((uint64_t)v61);
      __int128 v16 = sub_1005CBD4C(&v86, &v64);
      sub_1005CE6FC((uint64_t)v57, (uint64_t)&v86);
      if (v59)
      {
        uint64_t v17 = v58;
        uint64_t v18 = (void *)*v58;
        if (*v58)
        {
          do
          {
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v18[4] - v18[3]) >> 6) < 0xAAAAAAAAAAAAAAABLL {
            uint64_t v18 = (void *)*v18;
            }
          }

          while (v18);
        }

        uint64_t v19 = v17[2];
      }

      else
      {
        sub_1010DDBC0(__p, "ff:ff:ff:ff:ff:ff");
        uint64_t v19 = sub_1007EBE44((uint64_t *)__p);
        if (SHIBYTE(v93) < 0) {
          operator delete(*(void **)__p);
        }
      }

      uint64_t v60 = v19;
      sub_1005CE680((uint64_t)v57);
      uint64_t v20 = sub_1005CBD4C(&v86, &v60);
      int v21 = sub_1005CBD4C(&v86, a2);
      double v22 = -1.0;
      if (sub_1005CE368(&v86, a2))
      {
        std::string::size_type v23 = sub_1005CE368(&v86, a2);
        if (!v23) {
          sub_10000C918("unordered_map::at: key not found");
        }
        uint64_t v24 = v23[3];
        if (v24 != v23[4]) {
          double v22 = (CFAbsoluteTimeGetCurrent() - *(double *)(v24 + 84)) / 3600.0;
        }
      }

      double v25 = -1.0;
      if (sub_1005CE368(&v86, a2))
      {
        int v26 = sub_1005CE368(&v86, a2);
        if (!v26) {
          sub_10000C918("unordered_map::at: key not found");
        }
        uint64_t v27 = v26[4];
        if (v26[3] != v27) {
          double v25 = CFAbsoluteTimeGetCurrent() - *(double *)(v27 - 108);
        }
      }

      double v56 = v25;
      if (qword_101934A20 != -1) {
        dispatch_once(&qword_101934A20, &stru_101842718);
      }
      uint64_t v28 = (os_log_s *)off_101934A28;
      if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v29 = buf;
        std::operator+<char>(buf, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
        __int16 v46 = v21;
        int v48 = v20;
        double v50 = a2;
        if (v68 < 0) {
          uint64_t v29 = *(_BYTE **)buf;
        }
        sub_1007EC360(&v55);
        uint64_t v30 = v16;
        if ((v55.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          std::stringbuf::string_type v31 = &v55;
        }
        else {
          std::stringbuf::string_type v31 = (std::string *)v55.__r_.__value_.__r.__words[0];
        }
        sub_1007EC360(&v54);
        int size = (char)v54.__r_.__value_.__s.__size_;
        std::string::size_type v33 = v54.__r_.__value_.__r.__words[0];
        sub_1007EC360(&v53);
        __int16 v34 = &v54;
        if (size < 0) {
          __int16 v34 = (std::string *)v33;
        }
        if ((v53.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          unint64_t v35 = &v53;
        }
        else {
          unint64_t v35 = (std::string *)v53.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::stringbuf::string_type __p = 136317699;
        *(void *)&__p[4] = v29;
        __int16 v91 = 2049;
        unint64_t v92 = v12;
        __int16 v93 = 2049;
        unint64_t v94 = v6;
        __int16 v95 = 2049;
        __int128 v16 = v30;
        uint64_t v96 = v30;
        __int16 v97 = 2080;
        std::string::size_type v98 = v31;
        __int16 v99 = 2049;
        int v21 = v46;
        uint64_t v20 = v48;
        unsigned __int8 v100 = v48;
        __int16 v101 = 2080;
        double v102 = v34;
        __int16 v103 = 2081;
        __int128 v104 = v35;
        __int16 v105 = 2049;
        int v106 = v46;
        __int16 v107 = 2049;
        double v108 = v22;
        __int16 v109 = 2049;
        double v110 = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "%s, %{private}zu APs, %{private}zu total samples, max samples: %{private}zu (%s), min samples: %{private}zu (% s), current associated AP %{private}s has %{private}zu samples and oldest sample age of %{private}.1f hours, l atest sample age of %{private}.1f seconds",  __p,  0x70u);
        a2 = v50;
        if (SHIBYTE(v68) < 0) {
          operator delete(*(void **)buf);
        }
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(__p, 0x65CuLL);
        if (qword_101934A20 != -1) {
          dispatch_once(&qword_101934A20, &stru_101842718);
        }
        __int16 v36 = off_101934A28;
        unint64_t v37 = &v55;
        std::operator+<char>(&v55, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
        __int16 v49 = v20;
        __int16 v51 = v36;
        __int16 v47 = v21;
        if ((v55.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          unint64_t v37 = (std::string *)v55.__r_.__value_.__r.__words[0];
        }
        __int16 v38 = &v54;
        sub_1007EC360(&v54);
        int v39 = v16;
        unint64_t v40 = v12;
        if ((v54.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          __int16 v38 = (std::string *)v54.__r_.__value_.__r.__words[0];
        }
        sub_1007EC360(&v53);
        int v41 = (char)v53.__r_.__value_.__s.__size_;
        std::string::size_type v42 = v53.__r_.__value_.__r.__words[0];
        sub_1007EC360(&v52);
        unint64_t v43 = &v53;
        if (v41 < 0) {
          unint64_t v43 = (std::string *)v42;
        }
        __int16 v44 = &v52;
        if ((v52.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          __int16 v44 = (std::string *)v52.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::stringbuf::string_type buf = 136317699;
        *(void *)&uint8_t buf[4] = v37;
        __int16 v66 = 2049;
        unint64_t v12 = v40;
        unint64_t v67 = v40;
        __int16 v68 = 2049;
        unint64_t v69 = v6;
        __int16 v70 = 2049;
        int v71 = v39;
        __int16 v72 = 2080;
        size_t v73 = v38;
        __int16 v74 = 2049;
        uint64_t v75 = v49;
        __int16 v76 = 2080;
        std::string::size_type v77 = v43;
        __int16 v78 = 2081;
        uint64_t v79 = v44;
        __int16 v80 = 2049;
        int v81 = v47;
        __int16 v82 = 2049;
        double v83 = v22;
        __int16 v84 = 2049;
        double v85 = v25;
        unint64_t v45 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v51,  2LL,  "%s, %{private}zu APs, %{private}zu total samples, max samples: %{private}zu (%s), min samples: % {private}zu (%s), current associated AP %{private}s has %{private}zu samples and oldest sample a ge of %{private}.1f hours, latest sample age of %{private}.1f seconds",  buf,  112);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWifiAssociatedApHarvestDatabase::logDatabaseInfoAndSubmitMetricsIfPossible(const CLMacAddress &)",  "%s\n",  v45);
        if (v45 != __p) {
          free(v45);
        }
      }

      sub_1008076FC(a1 + 304, v12, v6, &v56, v22);
      sub_1005CBDA8(a1, &v86, a2);
      sub_1005CE680((uint64_t)&v86);
    }
  }

  else
  {
    if (qword_101934A20 != -1) {
      dispatch_once(&qword_101934A20, &stru_101842718);
    }
    BOOL v7 = (os_log_s *)off_101934A28;
    if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEFAULT))
    {
      std::operator+<char>(__p, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
      unint64_t v8 = v93 >= 0 ? __p : *(_BYTE **)__p;
      *(_DWORD *)std::stringbuf::string_type buf = 136315138;
      *(void *)&uint8_t buf[4] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "%s, #warning, could not log database info as it is invalid",  buf,  0xCu);
      if (SHIBYTE(v93) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A20 != -1) {
        dispatch_once(&qword_101934A20, &stru_101842718);
      }
      unint64_t v9 = off_101934A28;
      std::operator+<char>(buf, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
      if (v68 >= 0) {
        double v10 = buf;
      }
      else {
        double v10 = *(_BYTE **)buf;
      }
      int v86 = 136315138;
      std::string::size_type v87 = v10;
      __int128 v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  0LL,  "%s, #warning, could not log database info as it is invalid",  (const char *)&v86);
      if (SHIBYTE(v68) < 0) {
        operator delete(*(void **)buf);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWifiAssociatedApHarvestDatabase::logDatabaseInfoAndSubmitMetricsIfPossible(const CLMacAddress &)",  "%s\n",  v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

void sub_1005CCA38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
}

uint64_t sub_1005CCB50(uint64_t a1, uint64_t *a2)
{
  uint64_t v84 = *a2;
  if (sub_100400B64(a1))
  {
    sub_100CC1A3C(a1, &v84, &v93.__r_.__value_.__l.__data_);
    unint64_t v4 = *((int *)sub_100F4BF44() + 2);
    std::string::size_type v5 = v93.__r_.__value_.__r.__words[0];
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v93.__r_.__value_.__l.__size_ - v93.__r_.__value_.__r.__words[0]) >> 6) >= v4)
    {
      if (v93.__r_.__value_.__r.__words[0] != v93.__r_.__value_.__l.__size_
        && v93.__r_.__value_.__r.__words[0] + 192 != v93.__r_.__value_.__l.__size_)
      {
        std::string::size_type v23 = (double *)(v93.__r_.__value_.__r.__words[0] + 276);
        do
        {
          uint64_t v24 = (char *)v23 - 84;
          double v25 = v23 + 24;
          double v27 = *v23;
          int v26 = (char *)v23 + 108;
          BOOL v28 = v26 == (char *)v93.__r_.__value_.__l.__size_;
          std::string::size_type v23 = v25;
        }

        while (!v28);
      }

      double v29 = *(double *)((char *)a2 + 84) - *(double *)(v5 + 84);
      double v30 = *((double *)sub_100F4BF44() + 4);
      if (v29 >= v30)
      {
        if (qword_101934A20 != -1) {
          dispatch_once(&qword_101934A20, &stru_101842718);
        }
        std::string v55 = (os_log_s *)off_101934A28;
        if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEFAULT))
        {
          std::operator+<char>(v85, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
          int v56 = v85[23];
          __int16 v57 = *(_BYTE **)v85;
          sub_1007EC360(&__p);
          double v58 = v85;
          if (v56 < 0) {
            double v58 = v57;
          }
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::stringbuf::string_type buf = 136315906;
          *(void *)&uint8_t buf[4] = v58;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = p_p;
          *(_WORD *)&_BYTE buf[22] = 2048;
          *(double *)&_BYTE buf[24] = v29;
          *(_WORD *)__int16 v95 = 2048;
          *(double *)&v95[2] = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "%s, will harvest for associated AP %s as timelapse %.1lf >= threshold %.1lf",  buf,  0x2Au);
          if ((v85[23] & 0x80000000) != 0) {
            operator delete(*(void **)v85);
          }
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_89;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934A20 != -1) {
          dispatch_once(&qword_101934A20, &stru_101842718);
        }
        __int16 v72 = off_101934A28;
        std::operator+<char>(&__p, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
        int size = (char)__p.__r_.__value_.__s.__size_;
        std::string::size_type v74 = __p.__r_.__value_.__r.__words[0];
        sub_1007EC360(&v83);
        uint64_t v75 = &__p;
        if (size < 0) {
          uint64_t v75 = (std::string *)v74;
        }
        if ((v83.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int16 v76 = &v83;
        }
        else {
          __int16 v76 = (std::string *)v83.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)double v85 = 136315906;
        *(void *)&v85[4] = v75;
        *(_WORD *)&v85[12] = 2080;
        *(void *)&v85[14] = v76;
        *(_WORD *)&v85[22] = 2048;
        *(double *)&_BYTE v85[24] = v29;
        *(_WORD *)int v86 = 2048;
        *(double *)&v86[2] = v30;
        __int128 v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v72,  0LL,  "%s, will harvest for associated AP %s as timelapse %.1lf >= threshold %.1lf",  v85,  42,  *(double *)&v83.__r_.__value_.__l.__data_,  *(double *)&v83.__r_.__value_.__l.__size_);
      }

      else
      {
        __int128 v31 = *(_OWORD *)(v5 + 24);
        *(_OWORD *)std::stringbuf::string_type buf = *(_OWORD *)(v5 + 8);
        *(_OWORD *)&uint8_t buf[16] = v31;
        __int128 v32 = *(_OWORD *)(v5 + 40);
        __int128 v33 = *(_OWORD *)(v5 + 56);
        __int128 v34 = *(_OWORD *)(v5 + 88);
        __int128 v96 = *(_OWORD *)(v5 + 72);
        __int128 v97 = v34;
        *(_OWORD *)__int16 v95 = v32;
        *(_OWORD *)&v95[16] = v33;
        __int128 v35 = *(_OWORD *)(v5 + 104);
        __int128 v36 = *(_OWORD *)(v5 + 120);
        __int128 v37 = *(_OWORD *)(v5 + 136);
        *(_OWORD *)((char *)v100 + 12) = *(_OWORD *)(v5 + 148);
        __int128 v99 = v36;
        v100[0] = v37;
        __int128 v98 = v35;
        __int128 v38 = *(_OWORD *)(a2 + 15);
        __int128 v89 = *(_OWORD *)(a2 + 13);
        __int128 v90 = v38;
        v91[0] = *(_OWORD *)(a2 + 17);
        *(_OWORD *)((char *)v91 + 12) = *(_OWORD *)((char *)a2 + 148);
        __int128 v39 = *(_OWORD *)(a2 + 7);
        *(_OWORD *)int v86 = *(_OWORD *)(a2 + 5);
        *(_OWORD *)&v86[16] = v39;
        __int128 v40 = *(_OWORD *)(a2 + 11);
        __int128 v87 = *(_OWORD *)(a2 + 9);
        __int128 v88 = v40;
        __int128 v41 = *(_OWORD *)(a2 + 3);
        *(_OWORD *)double v85 = *(_OWORD *)(a2 + 1);
        *(_OWORD *)&v85[16] = v41;
        sub_100D2DCA4((double *)(a1 + 264), (uint64_t)buf, (uint64_t)v85);
        double v43 = v42;
        double v44 = *((double *)sub_100F4CD50() + 10);
        if (v43 <= v44)
        {
          if (qword_101934A20 != -1) {
            dispatch_once(&qword_101934A20, &stru_101842718);
          }
          __int16 v61 = (os_log_s *)off_101934A28;
          if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEFAULT))
          {
            std::operator+<char>(v85, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
            int v62 = v85[23];
            uint64_t v63 = *(_BYTE **)v85;
            sub_1007EC360(&__p);
            uint64_t v64 = v85;
            if (v62 < 0) {
              uint64_t v64 = v63;
            }
            if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              double v65 = &__p;
            }
            else {
              double v65 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)std::stringbuf::string_type buf = 136316162;
            *(void *)&uint8_t buf[4] = v64;
            *(_WORD *)&_BYTE buf[12] = 2080;
            *(void *)&buf[14] = v65;
            *(_WORD *)&_BYTE buf[22] = 2048;
            *(void *)&_BYTE buf[24] = 0xAAAAAAAAAAAAAAABLL
                                * ((uint64_t)(v93.__r_.__value_.__l.__size_ - v93.__r_.__value_.__r.__words[0]) >> 6);
            *(_WORD *)__int16 v95 = 2048;
            *(double *)&v95[2] = v29;
            *(_WORD *)&v95[10] = 2048;
            *(double *)&v95[12] = v43;
            _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_DEFAULT,  "%s, will not harvest for associated AP %s as it has %lu samples, timelapse %.1lf, distance %.1lf",  buf,  0x34u);
            if ((v85[23] & 0x80000000) != 0) {
              operator delete(*(void **)v85);
            }
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934A20 != -1) {
              dispatch_once(&qword_101934A20, &stru_101842718);
            }
            std::string::size_type v77 = off_101934A28;
            std::operator+<char>(&__p, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
            int v78 = (char)__p.__r_.__value_.__s.__size_;
            std::string::size_type v79 = __p.__r_.__value_.__r.__words[0];
            sub_1007EC360(&v83);
            __int16 v80 = &__p;
            if (v78 < 0) {
              __int16 v80 = (std::string *)v79;
            }
            if ((v83.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              int v81 = &v83;
            }
            else {
              int v81 = (std::string *)v83.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)double v85 = 136316162;
            *(void *)&v85[4] = v80;
            *(_WORD *)&v85[12] = 2080;
            *(void *)&v85[14] = v81;
            *(_WORD *)&v85[22] = 2048;
            *(void *)&_BYTE v85[24] = 0xAAAAAAAAAAAAAAABLL
                                * ((uint64_t)(v93.__r_.__value_.__l.__size_ - v93.__r_.__value_.__r.__words[0]) >> 6);
            *(_WORD *)int v86 = 2048;
            *(double *)&v86[2] = v29;
            *(_WORD *)&v86[10] = 2048;
            *(double *)&v86[12] = v43;
            __int16 v82 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v77,  0LL,  "%s, will not harvest for associated AP %s as it has %lu samples, timelapse %.1lf, distance %.1lf",  v85,  52,  v83.__r_.__value_.__r.__words[0],  *(double *)&v83.__r_.__value_.__l.__size_,  *(double *)&v83.__r_.__value_.__l.__cap_);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAssociatedApHarvestDatabase::shouldAddHarvestSample(const CLWifiHarvestDatabaseEntry &)",  "%s\n",  v82);
            if (v82 != buf) {
              free(v82);
            }
          }

          uint64_t v22 = 0LL;
          goto LABEL_90;
        }

        if (qword_101934A20 != -1) {
          dispatch_once(&qword_101934A20, &stru_101842718);
        }
        unint64_t v45 = (os_log_s *)off_101934A28;
        if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEFAULT))
        {
          std::operator+<char>(v85, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
          int v46 = v85[23];
          __int16 v47 = *(_BYTE **)v85;
          sub_1007EC360(&__p);
          int v48 = v85;
          if (v46 < 0) {
            int v48 = v47;
          }
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            __int16 v49 = &__p;
          }
          else {
            __int16 v49 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::stringbuf::string_type buf = 136315906;
          *(void *)&uint8_t buf[4] = v48;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = v49;
          *(_WORD *)&_BYTE buf[22] = 2048;
          *(double *)&_BYTE buf[24] = v43;
          *(_WORD *)__int16 v95 = 2048;
          *(double *)&v95[2] = v44;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "%s, will harvest for associated AP %s as distance %.1lf greater than threshold %.1lf",  buf,  0x2Au);
          if ((v85[23] & 0x80000000) != 0) {
            operator delete(*(void **)v85);
          }
        }

        if (!sub_1002921D0(115, 2))
        {
LABEL_89:
          uint64_t v22 = 1LL;
LABEL_90:
          if (v93.__r_.__value_.__r.__words[0])
          {
            v93.__r_.__value_.__l.__size_ = v93.__r_.__value_.__r.__words[0];
            operator delete(v93.__r_.__value_.__l.__data_);
          }

          return v22;
        }

        bzero(buf, 0x65CuLL);
        if (qword_101934A20 != -1) {
          dispatch_once(&qword_101934A20, &stru_101842718);
        }
        double v50 = off_101934A28;
        std::operator+<char>(&__p, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
        int v51 = (char)__p.__r_.__value_.__s.__size_;
        std::string::size_type v52 = __p.__r_.__value_.__r.__words[0];
        sub_1007EC360(&v83);
        std::string v53 = &__p;
        if (v51 < 0) {
          std::string v53 = (std::string *)v52;
        }
        if ((v83.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          std::string v54 = &v83;
        }
        else {
          std::string v54 = (std::string *)v83.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)double v85 = 136315906;
        *(void *)&v85[4] = v53;
        *(_WORD *)&v85[12] = 2080;
        *(void *)&v85[14] = v54;
        *(_WORD *)&v85[22] = 2048;
        *(double *)&_BYTE v85[24] = v43;
        *(_WORD *)int v86 = 2048;
        *(double *)&v86[2] = v44;
        __int128 v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v50,  0LL,  "%s, will harvest for associated AP %s as distance %.1lf greater than threshold %.1lf",  v85,  42,  *(double *)&v83.__r_.__value_.__l.__data_,  *(double *)&v83.__r_.__value_.__l.__size_);
      }
    }

    else
    {
      if (qword_101934A20 != -1) {
        dispatch_once(&qword_101934A20, &stru_101842718);
      }
      unint64_t v6 = (os_log_s *)off_101934A28;
      if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEFAULT))
      {
        std::operator+<char>(v85, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
        int v7 = v85[23];
        unint64_t v8 = *(_BYTE **)v85;
        sub_1007EC360(&__p);
        unint64_t v9 = v85;
        if (v7 < 0) {
          unint64_t v9 = v8;
        }
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          double v10 = &__p;
        }
        else {
          double v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::stringbuf::string_type buf = 136315906;
        *(void *)&uint8_t buf[4] = v9;
        *(_WORD *)&_BYTE buf[12] = 2080;
        *(void *)&buf[14] = v10;
        *(_WORD *)&_BYTE buf[22] = 2048;
        *(void *)&_BYTE buf[24] = 0xAAAAAAAAAAAAAAABLL
                            * ((uint64_t)(v93.__r_.__value_.__l.__size_ - v93.__r_.__value_.__r.__words[0]) >> 6);
        *(_WORD *)__int16 v95 = 1024;
        *(_DWORD *)&v95[2] = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "%s, will harvest for associated AP %s as it has %lu samples, less than threshold %d",  buf,  0x26u);
        if ((v85[23] & 0x80000000) != 0) {
          operator delete(*(void **)v85);
        }
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_89;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934A20 != -1) {
        dispatch_once(&qword_101934A20, &stru_101842718);
      }
      __int128 v11 = off_101934A28;
      std::operator+<char>(&__p, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
      int v12 = (char)__p.__r_.__value_.__s.__size_;
      std::string::size_type v13 = __p.__r_.__value_.__r.__words[0];
      sub_1007EC360(&v83);
      __int128 v14 = &__p;
      if (v12 < 0) {
        __int128 v14 = (std::string *)v13;
      }
      if ((v83.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v15 = &v83;
      }
      else {
        uint64_t v15 = (std::string *)v83.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)double v85 = 136315906;
      *(void *)&v85[4] = v14;
      *(_WORD *)&v85[12] = 2080;
      *(void *)&v85[14] = v15;
      *(_WORD *)&v85[22] = 2048;
      *(void *)&_BYTE v85[24] = 0xAAAAAAAAAAAAAAABLL
                          * ((uint64_t)(v93.__r_.__value_.__l.__size_ - v93.__r_.__value_.__r.__words[0]) >> 6);
      *(_WORD *)int v86 = 1024;
      *(_DWORD *)&v86[2] = v4;
      __int128 v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v11,  0LL,  "%s, will harvest for associated AP %s as it has %lu samples, less than threshold %d",  v85,  38,  v83.__r_.__value_.__r.__words[0],  LODWORD(v83.__r_.__value_.__r.__words[1]));
    }

    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAssociatedApHarvestDatabase::shouldAddHarvestSample(const CLWifiHarvestDatabaseEntry &)",  "%s\n",  v16);
    if (v16 != buf) {
      free(v16);
    }
    goto LABEL_89;
  }

  if (qword_101934A20 != -1) {
    dispatch_once(&qword_101934A20, &stru_101842718);
  }
  uint64_t v17 = (os_log_s *)off_101934A28;
  if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEFAULT))
  {
    std::operator+<char>(buf, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
    int v18 = buf[23];
    uint64_t v19 = *(_BYTE **)buf;
    sub_1007EC360((std::string *)v85);
    uint64_t v20 = buf;
    if (v18 < 0) {
      uint64_t v20 = v19;
    }
    if (v85[23] >= 0) {
      int v21 = v85;
    }
    else {
      int v21 = *(_BYTE **)v85;
    }
    LODWORD(v93.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)v93.__r_.__value_.__r.__words + 4) = (std::string::size_type)v20;
    WORD2(v93.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v93.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v21;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "%s, #warning, will not harvest for associated AP %s as database is invalid",  (uint8_t *)&v93,  0x16u);
    if ((v85[23] & 0x80000000) != 0) {
      operator delete(*(void **)v85);
    }
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A20 != -1) {
      dispatch_once(&qword_101934A20, &stru_101842718);
    }
    __int16 v66 = off_101934A28;
    std::operator+<char>(v85, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
    int v67 = v85[23];
    __int16 v68 = *(_BYTE **)v85;
    sub_1007EC360(&v93);
    unint64_t v69 = v85;
    if (v67 < 0) {
      unint64_t v69 = v68;
    }
    if ((v93.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int16 v70 = &v93;
    }
    else {
      __int16 v70 = (std::string *)v93.__r_.__value_.__r.__words[0];
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v69;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v70;
    int v71 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v66,  0LL,  "%s, #warning, will not harvest for associated AP %s as database is invalid",  (const char *)&__p,  22);
    if ((v85[23] & 0x80000000) != 0) {
      operator delete(*(void **)v85);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAssociatedApHarvestDatabase::shouldAddHarvestSample(const CLWifiHarvestDatabaseEntry &)",  "%s\n",  v71);
    if (v71 != buf) {
      free(v71);
    }
  }

  return 0LL;
}

void sub_1005CD91C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, void *a38, uint64_t a39, int a40, __int16 a41, char a42, char a43, uint64_t a44, void *__p, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005CD9E8(uint64_t a1, uint64_t *a2)
{
  if ((sub_1005CCB50(a1, a2) & 1) != 0) {
    return sub_1005CDD14(a1, a2);
  }
  if (qword_101934A20 != -1) {
    dispatch_once(&qword_101934A20, &stru_101842718);
  }
  std::string::size_type v5 = (os_log_s *)off_101934A28;
  if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEFAULT))
  {
    std::operator+<char>(v22, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
    int v6 = v23;
    int v7 = (void **)v22[0];
    sub_100B60DDC((uint64_t)a2, &__p);
    unint64_t v8 = v22;
    if (v6 < 0) {
      unint64_t v8 = v7;
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315395;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2081;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "%s, skip adding associated AP harvest sample: %{private}s",  (uint8_t *)&buf,  0x16u);
    if (v23 < 0) {
      operator delete(v22[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(v22, 0x65CuLL);
    if (qword_101934A20 != -1) {
      dispatch_once(&qword_101934A20, &stru_101842718);
    }
    double v10 = off_101934A28;
    std::operator+<char>(&__p, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
    int size = (char)__p.__r_.__value_.__s.__size_;
    std::string::size_type v12 = __p.__r_.__value_.__r.__words[0];
    sub_100B60DDC((uint64_t)a2, &buf);
    std::string::size_type v13 = &__p;
    if (size < 0) {
      std::string::size_type v13 = (std::stringbuf::string_type *)v12;
    }
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_std::stringbuf::string_type buf = &buf;
    }
    else {
      p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
    }
    int v18 = 136315395;
    uint64_t v19 = v13;
    __int16 v20 = 2081;
    int v21 = p_buf;
    uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  v22,  1628LL,  &_mh_execute_header,  v10,  0LL,  "%s, skip adding associated AP harvest sample: %{private}s",  &v18,  22);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAssociatedApHarvestDatabase::addHarvestSampleIfNecessary(const CLWifiHarvestDatabaseEntry &)",  "%s\n",  v15);
  }

  return 0LL;
}

void sub_1005CDCDC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005CDD14(uint64_t a1, void *a2)
{
  if (qword_101934A20 != -1) {
    dispatch_once(&qword_101934A20, &stru_101842718);
  }
  unint64_t v4 = (os_log_s *)off_101934A28;
  if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEFAULT))
  {
    std::operator+<char>(__p, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
    int v5 = v38;
    int v6 = (void **)__p[0];
    sub_100B60DDC((uint64_t)a2, &v39);
    int v7 = __p;
    if (v5 < 0) {
      int v7 = v6;
    }
    if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unint64_t v8 = &v39;
    }
    else {
      unint64_t v8 = (std::stringbuf::string_type *)v39.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315395;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2081;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v8;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "%s, adding associated AP harvest sample: %{private}s",  (uint8_t *)&buf,  0x16u);
    if (v38 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934A20 != -1) {
      dispatch_once(&qword_101934A20, &stru_101842718);
    }
    int v18 = off_101934A28;
    std::operator+<char>(&v39, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
    int size = (char)v39.__r_.__value_.__s.__size_;
    std::string::size_type v20 = v39.__r_.__value_.__r.__words[0];
    sub_100B60DDC((uint64_t)a2, &buf);
    int v21 = &v39;
    if (size < 0) {
      int v21 = (std::stringbuf::string_type *)v20;
    }
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_std::stringbuf::string_type buf = &buf;
    }
    else {
      p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
    }
    int v33 = 136315395;
    __int128 v34 = v21;
    __int16 v35 = 2081;
    __int128 v36 = p_buf;
    char v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v18,  0LL,  "%s, adding associated AP harvest sample: %{private}s",  &v33,  22);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAssociatedApHarvestDatabase::addHarvestSample(const CLWifiHarvestDatabaseEntry &)",  "%s\n",  v23);
  }

  *(void *)(a1 + 256) = *a2;
  uint64_t v9 = sub_100CC04F4(a1, (uint64_t)a2);
  if ((v9 & 1) != 0)
  {
    double v10 = (uint64_t *)sub_100F4BF44();
    __p[0] = COERCE_VOID_(sub_100F4CB14(v10));
    sub_100400BE0(a1, (double *)__p);
    sub_1005CB4A8(a1);
    sub_1005CB8DC(a1);
  }

  else
  {
    if (qword_101934A20 != -1) {
      dispatch_once(&qword_101934A20, &stru_101842718);
    }
    __int128 v11 = (os_log_s *)off_101934A28;
    if (os_log_type_enabled((os_log_t)off_101934A28, OS_LOG_TYPE_DEFAULT))
    {
      std::operator+<char>(__p, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
      int v12 = v38;
      std::string::size_type v13 = (void **)__p[0];
      BOOL v14 = sub_100400B64(a1);
      uint64_t v15 = __p;
      __int128 v16 = "invalid";
      if (v12 < 0) {
        uint64_t v15 = v13;
      }
      if (v14) {
        __int128 v16 = "valid";
      }
      LODWORD(v39.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)v39.__r_.__value_.__r.__words + 4) = (std::string::size_type)v15;
      WORD2(v39.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v39.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v16;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "%s, #warning, could not insert associated AP harvest sample into %s database!",  (uint8_t *)&v39,  0x16u);
      if (v38 < 0) {
        operator delete(__p[0]);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A20 != -1) {
        dispatch_once(&qword_101934A20, &stru_101842718);
      }
      uint64_t v24 = off_101934A28;
      std::operator+<char>(&v39, "WifiAssociatedApHarvestDatabase, ", a1 + 376);
      int v25 = (char)v39.__r_.__value_.__s.__size_;
      std::string::size_type v26 = v39.__r_.__value_.__r.__words[0];
      BOOL v27 = sub_100400B64(a1);
      BOOL v28 = &v39;
      double v29 = "invalid";
      if (v25 < 0) {
        BOOL v28 = (std::stringbuf::string_type *)v26;
      }
      if (v27) {
        double v29 = "valid";
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v29;
      LODWORD(vsub_100231C10(v2 + 31) = 22;
      double v30 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v24,  0LL,  "%s, #warning, could not insert associated AP harvest sample into %s database!",  (const char *)&buf,  v31);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAssociatedApHarvestDatabase::addHarvestSample(const CLWifiHarvestDatabaseEntry &)",  "%s\n",  v30);
    }
  }

  return v9;
}

void sub_1005CE218( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
}

uint64_t sub_1005CE258(uint64_t a1)
{
  *(void *)a1 = off_1018426E8;
  *(void *)a1 = off_10187D490;
  return sub_10040063C(a1);
}

void sub_1005CE2C8(uint64_t a1)
{
  *(void *)a1 = off_1018426E8;
  *(void *)a1 = off_10187D490;
  unint64_t v2 = (void *)sub_10040063C(a1);
  operator delete(v2);
}

void sub_1005CE33C(id a1)
{
  off_101934A28 = os_log_create("com.apple.locationd.Utility", "Database");
}

void *sub_1005CE368(void *a1, void *a2)
{
  unint64_t v4 = sub_1005B46E8((uint64_t)a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0LL;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }

  else
  {
    unint64_t v9 = (*(void *)&v5 - 1LL) & v4;
  }

  double v10 = *(void **)(*a1 + 8 * v9);
  if (!v10) {
    return 0LL;
  }
  __int128 v11 = (void *)*v10;
  if (*v10)
  {
    do
    {
      unint64_t v12 = v11[1];
      if (v6 == v12)
      {
        if (sub_1007EC0B0(v11 + 2, a2)) {
          return v11;
        }
      }

      else
      {
        if (v8 > 1)
        {
          if (v12 >= *(void *)&v5) {
            v12 %= *(void *)&v5;
          }
        }

        else
        {
          v12 &= *(void *)&v5 - 1LL;
        }

        if (v12 != v9) {
          return 0LL;
        }
      }

      __int128 v11 = (void *)*v11;
    }

    while (v11);
  }

  return v11;
}

void *sub_1005CE460@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x1A8uLL);
  __n128 result = sub_1005CE4B8(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1005CE4A4(_Unwind_Exception *a1)
{
}

void *sub_1005CE4B8(void *a1, unsigned __int8 *a2)
{
  a1[2] = 0LL;
  *a1 = off_101842748;
  a1[1] = 0LL;
  sub_1005CE560((uint64_t)&v4, (uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1005CE504(_Unwind_Exception *a1)
{
}

void sub_1005CE518(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101842748;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1005CE52C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101842748;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1005CE550(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_1005CE560(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005CE5B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1005CE5D4@<X0>(unsigned __int8 *a1@<X1>, __int128 *a2@<X2>, void *a3@<X8>)
{
  char v6 = operator new(0x1A8uLL);
  __n128 result = sub_1005CE634(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1005CE620(_Unwind_Exception *a1)
{
}

void *sub_1005CE634(void *a1, unsigned __int8 *a2, __int128 *a3)
{
  a1[2] = 0LL;
  *a1 = off_101842748;
  a1[1] = 0LL;
  sub_1005CB0F0((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_1005CE66C(_Unwind_Exception *a1)
{
}

uint64_t sub_1005CE680(uint64_t a1)
{
  unint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1005CE6B8(int a1, void *__p)
{
  if (__p)
  {
    unint64_t v2 = __p;
    do
    {
      __int128 v3 = (void *)*v2;
      char v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }

      operator delete(v2);
      unint64_t v2 = v3;
    }

    while (v3);
  }

uint64_t sub_1005CE6FC(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_100019E10(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
    sub_1005CE770(a1, i + 2, i + 2);
  return a1;
}

void sub_1005CE758(_Unwind_Exception *a1)
{
}

void *sub_1005CE770(uint64_t a1, void *a2, void *a3)
{
  unint64_t v7 = sub_1005B46E8((uint64_t)a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }

    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }

    unint64_t v12 = *(void **)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      std::string::size_type v13 = (void *)*v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v8)
          {
            if (sub_1007EC0B0(v13 + 2, a2)) {
              return v13;
            }
          }

          else
          {
            if (v11 > 1)
            {
              if (v14 >= v9) {
                v14 %= v9;
              }
            }

            else
            {
              v14 &= v9 - 1;
            }

            if (v14 != v3) {
              break;
            }
          }

          std::string::size_type v13 = (void *)*v13;
        }

        while (v13);
      }
    }
  }

  sub_1005CE9D8(a1, v8, a3, (uint64_t)&v24);
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1LL;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_100019E10(a1, v20);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }

    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }

  int v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *uint64_t v24 = *v21;
    *int v21 = v24;
  }

  else
  {
    *uint64_t v24 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v24;
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*v24)
    {
      unint64_t v22 = *(void *)(*v24 + 8LL);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v22 >= v9) {
          v22 %= v9;
        }
      }

      else
      {
        v22 &= v9 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v22) = v24;
    }
  }

  std::string::size_type v13 = v24;
  ++*(void *)(a1 + 24);
  return v13;
}

void sub_1005CE9B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    sub_1005CEA80((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1005CE9D8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x30uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + _Block_object_dispose(va, 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *unint64_t v8 = 0LL;
  v8[1] = a2;
  unint64_t v9 = (const void *)a3[1];
  _DWORD v8[2] = *a3;
  v8[3] = 0LL;
  BOOL v8[4] = 0LL;
  void v8[5] = 0LL;
  __n128 result = sub_10053B280(v8 + 3, v9, a3[2], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[2] - (void)v9) >> 6));
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1005CEA64(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0LL;
  sub_1005CEA80(v3, v2);
  _Unwind_Resume(a1);
}

void sub_1005CEA80(uint64_t a1, void *__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    uint64_t v3 = (void *)__p[3];
    if (v3)
    {
      __p[4] = v3;
      operator delete(v3);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_1005CEACC()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361B8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361B8))
    {
      qword_1019361A0 = 0LL;
      qword_1019361A8 = 0LL;
      qword_1019361B0 = 0LL;
      uint64_t v1 = operator new(6uLL);
      qword_1019361A8 = (uint64_t)(v1 + 3);
      qword_1019361B0 = (uint64_t)(v1 + 3);
      *(_DWORD *)uint64_t v1 = 151521030;
      v1[2] = 3082;
      qword_1019361A0 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1001CDCD0, &qword_1019361A0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361B8);
    }
  }

void sub_1005CEB68(_Unwind_Exception *a1)
{
}

void sub_1005CEB80()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361D8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361D8))
    {
      qword_1019361C0 = 0LL;
      qword_1019361C8 = 0LL;
      qword_1019361D0 = 0LL;
      uint64_t v1 = operator new(2uLL);
      qword_1019361C0 = (uint64_t)v1;
      *uint64_t v1 = 256;
      qword_1019361C8 = (uint64_t)(v1 + 1);
      qword_1019361D0 = (uint64_t)(v1 + 1);
      __cxa_atexit((void (*)(void *))sub_1001CDD00, &qword_1019361C0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361D8);
    }
  }

void sub_1005CEC0C(_Unwind_Exception *a1)
{
}

uint64_t sub_1005CEC24()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, &qword_101997290, (void *)&_mh_execute_header);
}

double sub_1005CECA0(void *a1)
{
  uint64_t v1 = sub_1009AF3AC(a1);
  *uint64_t v1 = off_101842798;
  *((_OWORD *)v1 + 1) = 0u;
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + 3) = 0u;
  *((_OWORD *)v1 + 4) = 0u;
  *(_OWORD *)((char *)v1 + 76) = 0u;
  *(void *)((char *)v1 + 92) = 1065353216LL;
  *((_DWORD *)v1 + sub_100231C10(v2 + 25) = 0;
  *((_WORD *)v1 + 54) = 0;
  *((_BYTE *)v1 + 110) = 0;
  *(void *)&double result = 0x1E00000000LL;
  v1[14] = 0x1E00000000LL;
  *((_BYTE *)v1 + 152) = 1;
  v1[21] = 0x1E00000000LL;
  *((_DWORD *)v1 + 41) = 1031798784;
  return result;
}

void sub_1005CED08(uint64_t a1, uint64_t a2)
{
  char v3 = *(_BYTE *)(a2 + 74);
  if (v3)
  {
    *(_DWORD *)(a1 + 16) = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 20);
    *(void *)(a1 + 40) = *(void *)(a2 + 24);
    *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 44);
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 48);
    uint64_t v4 = *(unsigned int *)(a2 + 64);
    *(void *)(a1 + 76) = v4;
    *(_DWORD *)(a1 + 86) = *(_DWORD *)(a2 + 68);
    *(_BYTE *)(a1 + 84) = *(_BYTE *)(a2 + 72) != 0;
    int v5 = *(unsigned __int8 *)(a2 + 73);
    uint64_t v6 = *(void *)(a2 + 56);
    *(_DWORD *)(a1 + sub_10004AD90(v15 - 112) = 0;
    uint64_t v7 = (unsigned __int16 *)(a1 + 112);
    *(_BYTE *)(a1 + 85) = v5 != 0;
    *(void *)(a1 + 6_Block_object_dispose(va, 8) = v6;
    *(_BYTE *)(a1 + 110) = v3;
    char v8 = 1;
  }

  else
  {
    char v8 = 0;
  }

  *(_BYTE *)(a1 + 90) = v8;
}

void sub_1005CEDF4(unsigned __int16 *a1, uint64_t a2)
{
  if (a1[1] || *a1)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018427F8);
    }
    uint64_t v4 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      int v5 = a1[1];
      int v6 = *a1;
      *(_DWORD *)std::stringbuf::string_type buf = 67109376;
      int v15 = v5;
      __int16 v16 = 1024;
      int v17 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "Assertion failed: fHeadAndSize.fSize == 0 && fHeadAndSize.fHead == 0, file /Library/Caches/com.apple.xbs/Sources /CoreLocation/Oscar/CMQueue.h, line 78,size,%u,head,%u.",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018427F8);
      }
      int v7 = a1[1];
      int v8 = *a1;
      v11[0] = 67109376;
      v11[1] = v7;
      __int16 v12 = 1024;
      int v13 = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: fHeadAndSize.fSize == 0 && fHeadAndSize.fHead == 0, file /Library/Caches/com.apple.xbs/Sources /CoreLocation/Oscar/CMQueue.h, line 78,size,%u,head,%u.",  v11,  14);
      uint8x8_t v10 = (uint8_t *)v9;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CMQueue<BOOL>::setCapacity(size_t) [T = BOOL]", "%s\n", v9);
      if (v10 != buf) {
        free(v10);
      }
    }
  }

  if (a2) {
    *((_DWORD *)a1 + 1) = a2;
  }
}

void sub_1005CEFE0(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_1018427F8);
  }
  unint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v3 = *(_DWORD *)(a1 + 52);
    int v4 = *(_DWORD *)(a1 + 56);
    int v5 = *(_DWORD *)(a1 + 60);
    int v6 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)std::stringbuf::string_type buf = 67109888;
    *(_DWORD *)int v62 = v3;
    *(_WORD *)&v62[4] = 1024;
    *(_DWORD *)&v62[6] = v4;
    LOWORD(v63) = 1024;
    *(_DWORD *)((char *)&v63 + 2) = v5;
    HIWORD(v63) = 1024;
    *(_DWORD *)uint64_t v64 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "configuration: low band = [%d %d] high band [%d %d]",  buf,  0x1Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018427F8);
    }
    int v25 = *(_DWORD *)(a1 + 56);
    int v26 = *(_DWORD *)(a1 + 60);
    int v27 = *(_DWORD *)(a1 + 64);
    WORD2(v53) = 1024;
    HIWORD(v53) = v25;
    *(_DWORD *)((char *)&v55 + 2) = v26;
    HIWORD(v55) = 1024;
    *(_DWORD *)int v56 = v27;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "configuration: low band = [%d %d] high band [%d %d]",  &v52,  26,  67109888,  HIDWORD(v53));
    double v29 = (uint8_t *)v28;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CMOnBodyDetector::printParameters() const", "%s\n", v28);
    if (v29 != buf) {
      free(v29);
    }
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_1018427F8);
  }
  int v7 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v8 = *(float *)(a1 + 40);
    double v9 = *(float *)(a1 + 44);
    double v10 = *(float *)(a1 + 48);
    *(_DWORD *)std::stringbuf::string_type buf = 134218496;
    *(double *)int v62 = v8;
    *(_WORD *)&v62[8] = 2048;
    double v63 = v9;
    *(_WORD *)uint64_t v64 = 2048;
    *(double *)&_OWORD v64[2] = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "configuration: classifierMinLowPower = %f, classifierMaxLowPower = %f, classifierMaxHighPower = %f",  buf,  0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018427F8);
    }
    double v30 = *(float *)(a1 + 40);
    double v31 = *(float *)(a1 + 44);
    double v32 = *(float *)(a1 + 48);
    int v52 = 134218496;
    double v53 = v30;
    __int16 v54 = 2048;
    double v55 = v31;
    *(_WORD *)int v56 = 2048;
    *(double *)&v56[2] = v32;
    LODWORD(v51) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "configuration: classifierMinLowPower = %f, classifierMaxLowPower = %f, classifierMaxHighPower = %f",  COERCE_DOUBLE(&v52),  v51);
    __int128 v34 = (uint8_t *)v33;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CMOnBodyDetector::printParameters() const", "%s\n", v33);
    if (v34 != buf) {
      free(v34);
    }
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_1018427F8);
  }
  unint64_t v11 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v12 = *(float *)(a1 + 16);
    double v13 = *(float *)(a1 + 20);
    double v14 = *(float *)(a1 + 24);
    double v15 = *(float *)(a1 + 28);
    double v16 = *(float *)(a1 + 32);
    double v17 = *(float *)(a1 + 36);
    *(_DWORD *)std::stringbuf::string_type buf = 134219264;
    *(double *)int v62 = v12;
    *(_WORD *)&v62[8] = 2048;
    double v63 = v13;
    *(_WORD *)uint64_t v64 = 2048;
    *(double *)&_OWORD v64[2] = v14;
    __int16 v65 = 2048;
    *(double *)__int16 v66 = v15;
    *(_WORD *)&v66[8] = 2048;
    *(double *)int v67 = v16;
    *(_WORD *)&v67[8] = 2048;
    double v68 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "configuration: theta = [%.2f %.2f %.2f %.2f %.2f %.2f]",  buf,  0x3Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018427F8);
    }
    double v35 = *(float *)(a1 + 16);
    double v36 = *(float *)(a1 + 20);
    double v37 = *(float *)(a1 + 24);
    double v38 = *(float *)(a1 + 28);
    double v39 = *(float *)(a1 + 32);
    double v40 = *(float *)(a1 + 36);
    int v52 = 134219264;
    double v53 = v35;
    __int16 v54 = 2048;
    double v55 = v36;
    *(_WORD *)int v56 = 2048;
    *(double *)&v56[2] = v37;
    __int16 v57 = 2048;
    *(double *)double v58 = v38;
    *(_WORD *)&_WORD v58[8] = 2048;
    *(double *)uint64_t v59 = v39;
    *(_WORD *)&v59[8] = 2048;
    double v60 = v40;
    LODWORD(v51) = 62;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "configuration: theta = [%.2f %.2f %.2f %.2f %.2f %.2f]",  COERCE_DOUBLE(&v52),  v51);
    double v42 = (uint8_t *)v41;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CMOnBodyDetector::printParameters() const", "%s\n", v41);
    if (v42 != buf) {
      free(v42);
    }
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_1018427F8);
  }
  unint64_t v18 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v19 = *(float *)(a1 + 68);
    double v20 = *(double *)(a1 + 76);
    double v21 = *(float *)(a1 + 86);
    int v22 = *(unsigned __int8 *)(a1 + 84);
    int v23 = *(unsigned __int8 *)(a1 + 85);
    double v24 = *(float *)(a1 + 72);
    *(_DWORD *)std::stringbuf::string_type buf = 134219264;
    *(double *)int v62 = v19;
    *(_WORD *)&v62[8] = 2048;
    double v63 = v20;
    *(_WORD *)uint64_t v64 = 2048;
    *(double *)&_OWORD v64[2] = v21;
    __int16 v65 = 1024;
    *(_DWORD *)__int16 v66 = v22;
    *(_WORD *)&v66[4] = 1024;
    *(_DWORD *)&v66[6] = v23;
    *(_WORD *)int v67 = 2048;
    *(double *)&_OWORD v67[2] = v24;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "configuration: oddsThreshold = %f, medianFilterSize = %zu, confidenceThreshold = %f, useHysteresis = %d, useAngleO verride = %d, angleMetricThreshold = %f",  buf,  0x36u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018427F8);
    }
    double v43 = *(float *)(a1 + 68);
    double v44 = *(double *)(a1 + 76);
    double v45 = *(float *)(a1 + 86);
    int v46 = *(unsigned __int8 *)(a1 + 84);
    int v47 = *(unsigned __int8 *)(a1 + 85);
    double v48 = *(float *)(a1 + 72);
    int v52 = 134219264;
    double v53 = v43;
    __int16 v54 = 2048;
    double v55 = v44;
    *(_WORD *)int v56 = 2048;
    *(double *)&v56[2] = v45;
    __int16 v57 = 1024;
    *(_DWORD *)double v58 = v46;
    *(_WORD *)&v58[4] = 1024;
    *(_DWORD *)&void v58[6] = v47;
    *(_WORD *)uint64_t v59 = 2048;
    *(double *)&_OWORD v59[2] = v48;
    LODWORD(v51) = 54;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "configuration: oddsThreshold = %f, medianFilterSize = %zu, confidenceThreshold = %f, useHysteresis = %d, useAngleO verride = %d, angleMetricThreshold = %f",  COERCE_DOUBLE(&v52),  *(size_t *)&v51);
    double v50 = (uint8_t *)v49;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CMOnBodyDetector::printParameters() const", "%s\n", v49);
    if (v50 != buf) {
      free(v50);
    }
  }

uint64_t sub_1005CF718(uint64_t result)
{
  *(_DWORD *)(result + 92) = 1065353216;
  *(_WORD *)(result + 10_Block_object_dispose(va, 8) = 0;
  *(_DWORD *)(result + sub_10004AD90(v15 - 112) = 0;
  return result;
}

void sub_1005CF72C(uint64_t a1, float a2, float a3)
{
  float v3 = a2 * 100.0;
  if ((float)(a2 * 100.0) <= (float)(*(float *)(a1 + 44) * 100.0) && v3 >= (float)(*(float *)(a1 + 40) * 100.0))
  {
    float v5 = a3 * 100.0;
    if (!sub_100AD14D8(*(unsigned __int8 *)(a1 + 110)) || v5 <= (float)(*(float *)(a1 + 48) * 100.0)) {
      expf( (float)((float)((float)((float)(*(float *)(a1 + 16) + (float)(*(float *)(a1 + 20) * v3))
    }
                              + (float)(*(float *)(a1 + 24) * v5))
                      + (float)((float)(v3 * *(float *)(a1 + 28)) * v5))
  }

uint64_t sub_1005CF7F0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 90))
  {
    uint64_t v4 = 0LL;
    uint64_t v3 = 3LL;
    return v3 | (v4 << 32);
  }

  if (*(_BYTE *)(a1 + 91))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018427F8);
    }
    unint64_t v2 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Accel saturation detected, forcing OnBody.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018427F8);
      }
      v28[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Accel saturation detected, forcing OnBody.",  v28,  2);
      int v27 = (uint8_t *)v26;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLOnBodyNotifier_Type::CLOnBodyDetectionResult CMOnBodyDetector::detect()",  "%s\n",  v26);
      if (v27 != buf) {
        free(v27);
      }
    }

    uint64_t v3 = 1LL;
    uint64_t v4 = 1LL;
    return v3 | (v4 << 32);
  }

  sub_1005CF72C(a1, *(float *)(a1 + 96), *(float *)(a1 + 100));
  *(_DWORD *)(a1 + 92) = v5;
  if (*(_BYTE *)(a1 + 85))
  {
    sub_1005CAE5C((unsigned __int16 *)(a1 + 168), (_DWORD *)(a1 + 104));
    *(_BYTE *)(a1 + 152) = 1;
  }

  uint64_t v6 = *(unsigned __int16 *)(a1 + 112);
  unint64_t v7 = *(unsigned __int16 *)(a1 + 114);
  unint64_t v8 = *(unsigned int *)(a1 + 116);
  if (*(_WORD *)(a1 + 114) && (_DWORD)v8 == (_DWORD)v7)
  {
    __int16 v9 = v6 + 1;
    if (v6 + 1 >= v7) {
      __int16 v10 = *(_WORD *)(a1 + 114);
    }
    else {
      __int16 v10 = 0;
    }
    LOWORD(v6) = v9 - v10;
    *(_WORD *)(a1 + sub_10004AD90(v15 - 112) = v6;
    LOWORD(v11) = v7 - 1;
    *(_WORD *)(a1 + 114) = v7 - 1;
    LODWORD(v7) = (unsigned __int16)(v7 - 1);
  }

  else
  {
    LOWORD(v11) = *(_WORD *)(a1 + 114);
  }

  unint64_t v12 = (unsigned __int16)v6 + (unint64_t)(unsigned __int16)v11;
  if (v12 >= v8) {
    unint64_t v13 = v8;
  }
  else {
    unint64_t v13 = 0LL;
  }
  *(_BYTE *)(a1 + v12 - v13 + 120) = *(float *)(a1 + 92) > *(float *)(a1 + 68);
  if (v8 <= v7)
  {
    *(_WORD *)(a1 + sub_10004AD90(v15 - 112) = v6 + 1 - v8;
  }

  else
  {
    LOWORD(v11) = v11 + 1;
    *(_WORD *)(a1 + 114) = v11;
  }

  unsigned int v14 = *(unsigned __int16 *)(a1 + 108);
  BOOL v15 = (unsigned __int16)v11 <= v14;
  if ((unsigned __int16)v11 > v14)
  {
    *(_WORD *)(a1 + 10_Block_object_dispose(va, 8) = v14 + 1;
    int v18 = *(unsigned __int8 *)(a1 + 84);
    uint64_t v3 = 3LL;
    goto LABEL_43;
  }

  if ((_WORD)v11)
  {
    unint64_t v16 = 0LL;
    unsigned int v17 = 0;
    do
    {
      v17 += *(unsigned __int8 *)sub_1005CFF50((unsigned __int16 *)(a1 + 112), v16++);
      unint64_t v11 = *(unsigned __int16 *)(a1 + 114);
    }

    while (v16 < v11);
    if (*(_BYTE *)(a1 + 84))
    {
      int v18 = 1;
      if (!v17)
      {
LABEL_40:
        uint64_t v3 = 0LL;
        BOOL v15 = 0;
        float v20 = 1.0 - *(float *)(a1 + 92);
        if (!v18) {
          goto LABEL_49;
        }
        goto LABEL_44;
      }

      goto LABEL_42;
    }

    uint64_t v19 = *(unsigned __int16 *)(a1 + 114);
  }

  else
  {
    LOWORD(v11) = *(unsigned __int8 *)(a1 + 84);
    if (*(_BYTE *)(a1 + 84))
    {
      LOWORD(v11) = 0;
      int v18 = 1;
      goto LABEL_40;
    }

    uint64_t v19 = 0LL;
    unsigned int v17 = 0;
  }

  int v18 = 0;
LABEL_42:
  uint64_t v3 = 1LL;
LABEL_43:
  float v20 = *(float *)(a1 + 92);
  if (!v18)
  {
LABEL_49:
    uint64_t v4 = v20 > *(float *)(a1 + 86);
    goto LABEL_50;
  }

float sub_1005CFBC0(unsigned __int16 *a1)
{
  unint64_t v1 = 0LL;
  unint64_t v2 = 0LL;
  int v3 = 0;
  int v25 = 256;
  int v22 = 1031798784;
  uint64_t v4 = a1 + 538;
  int v5 = a1 + 1062;
  uint64_t v6 = a1 + 14;
  do
  {
    float v7 = *(float *)sub_100208A44(v4, v1);
    unint64_t v8 = (float *)sub_100208A44(v5, v1);
    float v9 = sqrtf((float)(v7 * v7) + (float)(*v8 * *v8));
    __int16 v10 = (float *)sub_100208A44(v6, v1);
    float v11 = atan2f(*v10, v9);
    unint64_t v12 = v2 + (unsigned __int16)v3;
    if (v12 >= 0x100) {
      uint64_t v13 = -256LL;
    }
    else {
      uint64_t v13 = 0LL;
    }
    *(float *)&v26[v13 + v12] = v11;
    else {
      int v14 = 0;
    }
    int v15 = v3 + v14;
    if (v2 > 0xFF) {
      int v3 = v15 + 1;
    }
    else {
      ++v2;
    }
    ++v1;
  }

  while (v1 != 256);
  __int16 v24 = v2;
  __int16 v23 = v3;
  v19[0] = 1;
  sub_100208C68((uint64_t)v19);
  float v16 = v21;
  if (v19[0]) {
    sub_100208C68((uint64_t)v19);
  }
  float v17 = v20;
  if (v20 <= 0.0) {
    float v17 = -v20;
  }
  return sqrtf(v16) / v17;
}

BOOL sub_1005CFD38(unsigned __int16 *a1)
{
  unint64_t v1 = 0LL;
  unsigned int v2 = 0;
  int v3 = a1 + 14;
  uint64_t v4 = a1 + 538;
  int v5 = a1 + 1062;
  do
  {
    uint64_t v6 = (float *)sub_100208A44(v3, v1);
    float v7 = *v6 * *v6;
    unint64_t v8 = (float *)sub_100208A44(v4, v1);
    float v9 = v7 + (float)(*v8 * *v8);
    __int16 v10 = (float *)sub_100208A44(v5, v1);
    ++v1;
  }

  while (v1 != 256);
  return v2 > 0xE6;
}

void sub_1005CFDE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (*(_DWORD *)(a2 + 8) == 100)
  {
    *(_BYTE *)(a1 + 91) = sub_1005CFD38((unsigned __int16 *)a2);
    unsigned int v10 = *(_DWORD *)(a1 + 52);
    unsigned int v11 = *(_DWORD *)(a1 + 56);
    int v12 = *(unsigned __int8 *)(a1 + 110);
    float v13 = 0.0;
    float v14 = 0.0;
    if (v10 <= v11)
    {
      int v15 = (float *)(a4 + 4LL * (int)v10);
      float v16 = (float *)(a6 + 4LL * (int)v10);
      do
      {
        float v17 = *v16;
        if (v12 == 18) {
          float v17 = v17 - *v15;
        }
        float v14 = v14 + v17;
        ++v15;
        ++v10;
        ++v16;
      }

      while (v11 >= v10);
    }

    *(float *)(a1 + 96) = v14;
    unsigned int v18 = *(_DWORD *)(a1 + 60);
    unsigned int v19 = *(_DWORD *)(a1 + 64);
    if (v18 <= v19)
    {
      float v20 = (float *)(a4 + 4LL * (int)v18);
      float v21 = 0.0;
      int v22 = (float *)(a6 + 4LL * (int)v18);
      do
      {
        float v23 = *v22;
        if (v12 == 18) {
          float v23 = v23 - *v20;
        }
        float v21 = v21 + v23;
        ++v20;
        ++v18;
        ++v22;
      }

      while (v19 >= v18);
      float v13 = v21 * 0.125;
    }

    *(float *)(a1 + 96) = v14 * 0.125;
    *(float *)(a1 + 100) = v13;
    *(float *)(a1 + 104) = sub_1005CFBC0((unsigned __int16 *)a2);
  }

void *sub_1005CFEE8(void *a1)
{
  *a1 = off_101842798;
  return sub_1009AF3C8(a1);
}

void sub_1005CFEF8(void *a1)
{
  *a1 = off_101842798;
  unint64_t v1 = sub_1009AF3C8(a1);
  operator delete(v1);
}

BOOL sub_1005CFF18(uint64_t a1, int a2)
{
  return a2 == 100;
}

void sub_1005CFF24(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_1005CFF50(unsigned __int16 *a1, unint64_t a2)
{
  if (*((unsigned int *)a1 + 1) <= a2)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018427F8);
    }
    float v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      int v8 = *((_DWORD *)a1 + 1);
      *(_DWORD *)std::stringbuf::string_type buf = 134218240;
      unint64_t v17 = a2;
      __int16 v18 = 1024;
      int v19 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMQueue.h, line 2 33,i,%zu,capacity,%u.",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018427F8);
      }
      int v9 = *((_DWORD *)a1 + 1);
      int v12 = 134218240;
      unint64_t v13 = a2;
      __int16 v14 = 1024;
      int v15 = v9;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: i < fCapacity, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMQueue.h, line 2 33,i,%zu,capacity,%u.",  (size_t)&v12,  18);
      unsigned int v11 = (uint8_t *)v10;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "const T &CMQueue<BOOL>::operator[](const size_t) const [T = BOOL]",  "%s\n",  v10);
      if (v11 != buf) {
        free(v11);
      }
    }
  }

  unint64_t v4 = *a1 + a2;
  unint64_t v5 = *((unsigned int *)a1 + 1);
  if (v4 < v5) {
    unint64_t v5 = 0LL;
  }
  return (uint64_t)a1 + v4 - v5 + 8;
}

uint64_t sub_1005D0148(uint64_t a1, uint64_t a2, int a3, char a4, char a5)
{
  uint64_t v9 = sub_1003070C0(a1, a3);
  *(void *)uint64_t v9 = off_101842828;
  *(void *)(v9 + 200) = off_101842890;
  sub_100A3ECDC(v9 + 200, *(unsigned __int8 *)(v9 + 8), a5);
  *(void *)a1 = off_101842828;
  *(void *)(a1 + 200) = off_101842890;
  *(_BYTE *)(a1 + 274) = a4;
  *(_BYTE *)(a1 + 275) = 0;
  *(void *)(a1 + 280) = 0LL;
  uint64_t v10 = sub_1006FE6A0();
  double v12 = sub_1006FE6E4(v10, a1 + 24);
  sub_1007BFD18(a1 + 288, &v12, a1 + 16, a2);
  return a1;
}

void sub_1005D01FC(_Unwind_Exception *a1)
{
}

uint64_t sub_1005D0224(void *a1)
{
  *a1 = off_101842828;
  a1[25] = off_101842890;
  unsigned int v2 = a1 + 25;
  sub_100A3EFD4((uint64_t)(a1 + 25));
  sub_100A3ED50(v2);
  sub_100A3ED9C(v2);
  sub_1007BFD74(a1 + 36);
  sub_100A3ED0C(v2);
  return sub_100307A9C((uint64_t)a1);
}

uint64_t sub_1005D028C(uint64_t a1)
{
  return sub_1005D0224((void *)(a1 - 200));
}

void sub_1005D0294(void *a1)
{
  uint64_t v1 = (void *)sub_1005D0224(a1);
  operator delete(v1);
}

void sub_1005D02A8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1005D0224((void *)(a1 - 200));
  operator delete(v1);
}

uint64_t sub_1005D02C0(uint64_t a1)
{
  uint64_t v2 = a1 + 288;
  sub_1007BFD94(a1 + 288);
  if (*(_BYTE *)(a1 + 274))
  {
    sub_100A3F004(a1 + 200, *(double *)(a1 + 16));
  }

  else
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    unint64_t v5 = 0xBFF0000000000000LL;
    double v4 = sub_101171D38();
    sub_1007C1678(v2, (double *)&v7, (double *)&v6, (double *)&v5, &v4);
  }

  sub_100A3EE64(a1 + 200, *(double *)(a1 + 24));
  sub_100A3EF20(a1 + 200);
  uint64_t v7 = 2LL;
  uint64_t result = sub_10030867C(a1, &v7);
  *(_BYTE *)(a1 + 275) = 0;
  *(void *)(a1 + 280) = 0LL;
  return result;
}

void *sub_1005D0368(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 200);
  sub_100A3EFD4(a1 + 200);
  sub_100A3ED50(v1);
  return sub_100A3ED9C(v1);
}

void sub_1005D0398(uint64_t a1, int a2)
{
  if (qword_101934560 != -1) {
    dispatch_once(&qword_101934560, &stru_1018428F8);
  }
  double v4 = (os_log_s *)qword_101934568;
  if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 67109120;
    int v8 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Application state changed, %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_1018428F8);
    }
    v6[0] = 67109120;
    v6[1] = a2;
    unint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934568,  1LL,  "Application state changed, %d",  v6);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLSensorFusionServiceLegacy::applicationStateChanged(BOOL)",  "%s\n",  v5);
  }

  *(_BYTE *)(a1 + 275) = a2 ^ 1;
}

void sub_1005D054C(uint64_t a1, uint64_t a2)
{
  float v4 = *(float *)(a2 + 12);
  *(double *)std::stringbuf::string_type buf = *(float *)(a2 + 8);
  uint64_t v5 = a1 + 304;
  uint64_t v6 = a1 + 288;
  double v22 = v4;
  *(double *)BOOL v28 = *(float *)(a2 + 16);
  sub_1007BFE90(a1 + 288, (float64x2_t *)buf, (uint64_t)&v22, (double *)v28, (void *)a2);
  v7.i64[0] = *(void *)(a1 + 464);
  if (*(double *)v7.i64 <= 0.0)
  {
    float32x2_t v8 = 0LL;
    float v9 = 0.0;
  }

  else
  {
    sub_1007C0D6C((double *)buf, (double *)v5);
    float32x4_t v7 = (float32x4_t)vsubq_f64(vcvtq_f64_f32(*(float32x2_t *)(a1 + 472)), *(float64x2_t *)buf);
    float32x2_t v8 = vcvt_f32_f64((float64x2_t)v7);
    *(double *)v7.i64 = *(float *)(a1 + 480) - v30;
    float v9 = *(double *)v7.i64;
  }

  int v10 = *(_DWORD *)(a1 + 452);
  *(_OWORD *)float v23 = 0uLL;
  double v22 = -1.0;
  uint64_t v11 = *(void *)(v5 + 140);
  sub_100833700((float32x4_t *)v23, v7);
  memset(&v23[4], 0, 36);
  *(_OWORD *)&v23[13] = xmmword_1012E2F40;
  uint64_t v24 = 0x1FF00000000LL;
  int v25 = 0;
  char v26 = 0;
  uint64_t v27 = 0LL;
  double v22 = *(double *)a2;
  float32x4_t v12 = *(float32x4_t *)(v5 + 16);
  *(float32x4_t *)std::stringbuf::string_type buf = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v5), (float64x2_t)v12);
  sub_100833700((float32x4_t *)buf, v12);
  *(_OWORD *)float v23 = *(_OWORD *)buf;
  *(float32x2_t *)&v23[4] = v8;
  *(float *)&v23[6] = v9;
  *(void *)&v23[7] = v11;
  v23[9] = v10;
  WORD2(v24) = 511;
  *(_OWORD *)&v23[10] = xmmword_1012E2F50;
  v23[14] = -1082130432;
  __int16 v13 = HIWORD(v24) & 0xFFE7;
  if (*(_BYTE *)(a1 + 252)) {
    __int16 v13 = HIWORD(v24) & 0xFFE7 | 0x10;
  }
  HIWORD(v24) = v13;
  else {
    __int16 v14 = 0;
  }
  HIWORD(v24) = HIWORD(v24) & 0xFEFF | v14;
  int v25 = 3;
  uint64_t v27 = 0LL;
  char v26 = *(_BYTE *)(a2 + 22);
  double v15 = *(double *)a2;
  double v16 = *(double *)(a1 + 280);
  if (v16 != 0.0)
  {
    double v17 = v15 - v16;
    if (v15 - v16 > 0.100000001)
    {
      if (qword_101934560 != -1) {
        dispatch_once(&qword_101934560, &stru_1018428F8);
      }
      __int16 v18 = (os_log_s *)qword_101934568;
      if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 134217984;
        *(double *)&uint8_t buf[4] = v17;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "Large time gap, %lf", buf, 0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934560 != -1) {
          dispatch_once(&qword_101934560, &stru_1018428F8);
        }
        *(_DWORD *)BOOL v28 = 134217984;
        *(double *)&v28[4] = v17;
        float v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934568,  1LL,  "Large time gap, %lf",  COERCE_DOUBLE(v28));
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLSensorFusionServiceLegacy::feedGyroData(const CLGyro::Sample *)",  "%s\n",  v20);
      }

      if (*(_BYTE *)(a1 + 275))
      {
        if (qword_101934560 != -1) {
          dispatch_once(&qword_101934560, &stru_1018428F8);
        }
        int v19 = (os_log_s *)qword_101934568;
        if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::stringbuf::string_type buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Reset while backgrounded", buf, 2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934560 != -1) {
            dispatch_once(&qword_101934560, &stru_1018428F8);
          }
          *(_WORD *)BOOL v28 = 0;
          float v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934568,  0LL,  "Reset while backgrounded",  v28,  2);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLSensorFusionServiceLegacy::feedGyroData(const CLGyro::Sample *)",  "%s\n",  v21);
        }

        sub_1007BFD94(v6);
      }
    }
  }

  *(double *)(a1 + 280) = v15;
  sub_100307D50(a1, (uint64_t)&v22);
}

void sub_1005D09FC(uint64_t a1, uint64_t a2)
{
}

double sub_1005D0A04(uint64_t a1, float32x2_t *a2, float *a3)
{
  return sub_1007C095C(a1 + 288, a2, a3);
}

double sub_1005D0A0C(uint64_t a1, float32x2_t *a2, float *a3)
{
  return sub_1007C095C(a1 + 88, a2, a3);
}

void sub_1005D0A14(uint64_t a1, uint64_t a2)
{
  float v2 = *(float *)(a2 + 12);
  double v5 = *(float *)(a2 + 8);
  double v3 = *(float *)(a2 + 16);
  double v4 = v2;
  sub_1007C1678(a1 + 288, &v5, &v4, &v3, (void *)a2);
}

void sub_1005D0A60(uint64_t a1, uint64_t a2)
{
}

void sub_1005D0A68(id a1)
{
  qword_101934568 = (uint64_t)os_log_create("com.apple.locationd.Motion", "DeviceMotion");
}

void **sub_1005D0A94(void **a1)
{
  *a1 = operator new(1uLL);
  return a1;
}

void **sub_1005D0AC0(void **a1)
{
  float v2 = *a1;
  *a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

CFTypeRef sub_1005D0AF0(int a1, char *name, uint64_t a3)
{
  double v4 = IOServiceNameMatching(name);
  if (!v4) {
    return 0LL;
  }
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v4);
  if (!MatchingService) {
    return 0LL;
  }
  io_object_t v6 = MatchingService;
  CFTypeRef CFProperty = IORegistryEntryCreateCFProperty( MatchingService,  (CFStringRef)+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a3),  kCFAllocatorDefault,  0);
  IOObjectRelease(v6);
  return CFProperty;
}

const void *sub_1005D0B78(int a1)
{
  CFTypeRef v1 = sub_1005D0AF0(a1, "compass", (uint64_t)"compass-calibration");
  if (!v1)
  {
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101842918);
    }
    double v5 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Invalid cpas data.", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101842918);
      }
      v11[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "Invalid cpas data.",  v11,  2);
      float32x2_t v8 = (uint8_t *)v7;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CFDataRef CLMagnetometerCoexistenceLocal::copyCompassCalibrationData()",  "%s\n",  v7);
      if (v8 != buf) {
        free(v8);
      }
    }

    return 0LL;
  }

  float v2 = v1;
  CFTypeID v3 = CFGetTypeID(v1);
  if (v3 != CFDataGetTypeID())
  {
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101842918);
    }
    double v4 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "The cpas data is not a CFData type.", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101842918);
      }
      v11[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "The cpas data is not a CFData type.",  v11,  2);
      int v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CFDataRef CLMagnetometerCoexistenceLocal::copyCompassCalibrationData()",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    CFRelease(v2);
    return 0LL;
  }

  return v2;
}

BOOL sub_1005D0E78(int a1)
{
  CFTypeRef v1 = (const __CFData *)sub_1005D0B78(a1);
  if (v1)
  {
    float v2 = v1;
    BytePtr = CFDataGetBytePtr(v1);
    if (!BytePtr)
    {
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101842918);
      }
      double v16 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "#Warning Cpas pointer is NULL.", buf, 2u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_52;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101842918);
      }
      LOWORD(v49) = 0;
      double v17 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  0LL,  "#Warning Cpas pointer is NULL.",  &v49,  2);
      int v19 = v18;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()",  "%s\n",  v17);
      goto LABEL_97;
    }

    double v4 = (UInt8 *)BytePtr;
    CFIndex Length = CFDataGetLength(v2);
    if (Length < 2) {
      goto LABEL_47;
    }
    CFIndex v6 = Length;
    int v7 = sub_100111E14(v4);
    if (v7 == 5 && v6 == 76)
    {
      unint64_t v20 = 5LL;
    }

    else
    {
      int v9 = v7;
      if (v7 != 6 || v6 != 76)
      {
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_101842918);
        }
        uint64_t v11 = (os_log_s *)qword_101934588;
        if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 67109120;
          LODWORD(v54) = v9;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "Unexpected cpas version: %u.", buf, 8u);
        }

        if (!sub_1002921D0(115, 0)) {
          goto LABEL_52;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_101842918);
        }
        double v13 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  17LL,  "Unexpected cpas version: %u.",  &v49);
        goto LABEL_96;
      }

      unint64_t v20 = 8LL;
    }

    float v21 = CFDataCreate(kCFAllocatorDefault, v4 + 2, v20);
    if (!v21)
    {
LABEL_47:
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101842918);
      }
      int v33 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_FAULT,  "Original serial number data is NULL.",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_52;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101842918);
      }
      double v13 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  17LL,  "Original serial number data is NULL.");
LABEL_96:
      int v19 = v12;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()",  "%s\n",  v13);
LABEL_97:
      if (v19 != buf) {
        free(v19);
      }
LABEL_52:
      double v22 = 0LL;
LABEL_53:
      BOOL v15 = 0LL;
      char v26 = v2;
      goto LABEL_54;
    }

    double v22 = v21;
    float v23 = CFDataGetBytePtr(v21);
    if (!v23)
    {
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101842918);
      }
      double v36 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_FAULT,  "Original serial number pointer is NULL.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_101842918);
        }
        LOWORD(v49) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  17LL,  "Original serial number pointer is NULL.",  &v49,  2);
        double v38 = (uint8_t *)v37;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMagnetometerCoexistenceLocal::deviceStillHasOriginalCamera()",  "%s\n",  v37);
        if (v38 != buf) {
          free(v38);
        }
      }

      goto LABEL_53;
    }

    uint64_t v24 = v23;
    int v25 = (const __CFData *)sub_1005D0AF0((int)v23, "AppleH4CamIn", (uint64_t)"BackCameraSerialNumber");
    char v26 = v25;
    if (!v25 || (CFTypeID v27 = CFGetTypeID(v25), v27 != CFDataGetTypeID()))
    {
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101842918);
      }
      double v35 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_FAULT,  "Invalid back camera serial number data.",  buf,  2u);
      }

      BOOL v15 = 0LL;
      if (!sub_1002921D0(115, 0))
      {
LABEL_63:
        CFRelease(v2);
        if (!v26)
        {
LABEL_55:
          if (v22) {
            CFRelease(v22);
          }
          return v15;
        }

NSNumber *sub_1005D19D0(int a1)
{
  CFTypeRef v1 = (const __CFNumber *)sub_1005D0AF0(a1, "AppleH4CamIn", (uint64_t)"BackCameraModuleFocusActuatorID");
  float v2 = v1;
  HIDWORD(v12) = -1;
  if (v1 && (CFTypeID v3 = CFGetTypeID(v1), v3 == CFNumberGetTypeID()))
  {
    if (CFNumberGetType(v2) == kCFNumberSInt32Type)
    {
    }

    else
    {
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101842918);
      }
      double v5 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 67109376;
        int Type = CFNumberGetType(v2);
        __int16 v18 = 1024;
        int v19 = 3;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "VCM actuator ID data type %d does not match expected type %d",  buf,  0xEu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_101842918);
        }
        uint64_t v9 = qword_101934588;
        v13[0] = 67109376;
        v13[1] = CFNumberGetType(v2);
        __int16 v14 = 1024;
        int v15 = 3;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v9,  1LL,  "VCM actuator ID data type %d does not match expected type %d",  v13,  14);
        uint64_t v11 = (uint8_t *)v10;
        sub_10029211C("Generic", 1LL, 0, 2LL, "NSNumber *CLMagnetometerCoexistenceLocal::cameraVcmId()", "%s\n", v10);
        if (v11 != buf) {
          free(v11);
        }
      }
    }
  }

  else
  {
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101842918);
    }
    double v4 = (os_log_s *)qword_101934588;
    if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "Bailing while checking VCM actuator ID.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_101842918);
      }
      LOWORD(v13[0]) = 0;
      LODWORD(v12) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "Bailing while checking VCM actuator ID.",  v13,  v12);
      float32x2_t v8 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 2LL, "NSNumber *CLMagnetometerCoexistenceLocal::cameraVcmId()", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
    }

    if (!v2) {
      return 0LL;
    }
  }

  CFRelease(v2);
  if (HIDWORD(v12) != -1) {
    return +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:");
  }
  return 0LL;
}

id sub_1005D1D74(int a1)
{
  CFTypeRef v1 = (const __CFData *)sub_1005D0B78(a1);
  if (v1)
  {
    float v2 = v1;
    BytePtr = CFDataGetBytePtr(v1);
    if (BytePtr)
    {
      double v4 = (unsigned __int8 *)BytePtr;
      CFIndex Length = CFDataGetLength(v2);
      if (Length >= 2)
      {
        CFIndex v6 = Length;
        int v7 = sub_100111E14(v4);
        id v8 = -[__CFData mutableCopy](v2, "mutableCopy");
        id v9 = v8;
        if (v8)
        {
          if (v7 == 5 && v6 == 76)
          {
            uint64_t v12 = 5LL;
          }

          else
          {
            if (v7 != 6 || v6 != 76) {
              goto LABEL_27;
            }
            uint64_t v12 = 8LL;
          }

          objc_msgSend(v8, "resetBytesInRange:", 2, v12);
        }

void sub_1005D20F4(id a1)
{
  qword_101934588 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Compass");
}

void sub_1005D21C4(id a1)
{
  qword_1019972D8 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLLocationCorrectiveCompensatorSilo");
}

uint64_t sub_1005D25F4(uint64_t a1, void *a2, uint64_t a3)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842980);
  }
  CFIndex v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138412290;
    *(void *)&uint8_t buf[4] = objc_msgSend(objc_msgSend(a2, "coarseMetadata"), "dictionaryRepresentation");
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "#compensation GeoLocation coarseMetaData: %@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842980);
    }
    uint64_t v33 = qword_101934988;
    *(_DWORD *)double v43 = 138412290;
    *(void *)double v44 = objc_msgSend(objc_msgSend(a2, "coarseMetadata"), "dictionaryRepresentation");
    __int128 v34 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v33,  2LL,  "#compensation GeoLocation coarseMetaData: %@",  v43,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLLocationCorrectiveCompensator snapLocation:withReply:]_block_invoke",  "%s\n",  v34);
    if (v34 != buf) {
      free(v34);
    }
  }

  uint64_t v40 = 0LL;
  int v7 = +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  [a2 coarseMetadata],  1,  &v40);
  if (v40)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842980);
    }
    id v8 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 138412290;
      *(void *)&uint8_t buf[4] = v40;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "#compensation GeoLocation coarseMetaData encoding failed, error, %@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842980);
      }
      *(_DWORD *)double v43 = 138412290;
      *(void *)double v44 = v40;
      LODWORD(v36) = 12;
      double v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  16LL,  "#compensation GeoLocation coarseMetaData encoding failed, error, %@",  v43,  v36);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CLLocationCorrectiveCompensator snapLocation:withReply:]_block_invoke",  "%s\n",  v35);
      if (v35 != buf) {
        free(v35);
      }
    }
  }

  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)&buf[44] = _Q0;
  *(_OWORD *)&buf[60] = _Q0;
  *(_DWORD *)std::stringbuf::string_type buf = 0xFFFF;
  *(_DWORD *)&buf[84] = 0;
  *(void *)&buf[88] = 0xBFF0000000000000LL;
  *(void *)&v58[20] = 0xBFF0000000000000LL;
  *(_DWORD *)double v58 = 0;
  *(_DWORD *)&v58[28] = 0x7FFFFFFF;
  memset(v59, 0, 25);
  objc_msgSend(objc_msgSend(a2, "latLng"), "lat");
  *(void *)&uint8_t buf[4] = v14;
  objc_msgSend(objc_msgSend(a2, "latLng"), "lng");
  *(void *)&_BYTE buf[12] = v15;
  objc_msgSend(objc_msgSend(a2, "latLng"), "lat");
  *(void *)&v58[4] = v16;
  objc_msgSend(objc_msgSend(a2, "latLng"), "lng");
  *(void *)&_BYTE v58[12] = v17;
  [a2 timestamp];
  *(void *)&buf[76] = v18;
  *(double *)&_BYTE buf[28] = (double)(int)[a2 altitude];
  [a2 horizontalAccuracy];
  *(void *)&buf[20] = v19;
  [a2 verticalAccuracy];
  *(void *)&buf[36] = v20;
  unsigned int v21 = [a2 referenceFrame];
  if (v21 <= 2) {
    *(_DWORD *)&v59[4] = v21;
  }
  [a2 speed];
  *(void *)&buf[44] = v22;
  [a2 course];
  if (v23 < 360.0)
  {
    [a2 course];
    if (v24 >= 0.0)
    {
      [a2 course];
      *(void *)&buf[60] = v25;
    }
  }

  sub_100D2D9A4((uint64_t)v39);
  sub_100D2DCA4(v39, a1 + 40, (uint64_t)buf);
  double v27 = v26;
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842980);
  }
  BOOL v28 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)double v43 = 68290563;
    *(_DWORD *)double v44 = 0;
    *(_WORD *)&v44[4] = 2082;
    *(void *)&v44[6] = "";
    __int16 v45 = 1040;
    int v46 = 156;
    __int16 v47 = 2097;
    uint64_t v48 = a1 + 40;
    __int16 v49 = 1040;
    int v50 = 156;
    __int16 v51 = 2097;
    unint64_t v52 = buf;
    __int16 v53 = 2050;
    double v54 = v27;
    __int16 v55 = 2050;
    uint64_t v56 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Location #compensation Snapping, Input:%{private, location:CLClientLocation}.*P, Ou tput:%{private, location:CLClientLocation}.*P, distance:%{public}f, GeoResultCode:%{public}ld}",  v43,  0x46u);
  }

  v41[0] = @"Distance";
  uint64_t v29 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v27);
  v41[1] = @"GeoResultCode";
  v42[0] = v29;
  v42[1] = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", a3);
  AnalyticsSendEvent( @"com.apple.locationd.ccmetric",  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v42,  v41,  2LL));
  uint64_t v30 = *(void *)(a1 + 32);
  int v31 = objc_alloc(&OBJC_CLASS___CLLocation);
  v37[6] = *(_OWORD *)v58;
  v37[7] = *(_OWORD *)&v58[16];
  v38[0] = *(_OWORD *)v59;
  *(_OWORD *)((char *)v38 + 12) = *(_OWORD *)&v59[12];
  v37[2] = *(_OWORD *)&buf[32];
  v37[3] = *(_OWORD *)&buf[48];
  v37[4] = *(_OWORD *)&buf[64];
  v37[5] = *(_OWORD *)&buf[80];
  v37[0] = *(_OWORD *)buf;
  v37[1] = *(_OWORD *)&buf[16];
  return (*(uint64_t (**)(uint64_t, CLLocation *, BOOL, NSData *))(v30 + 16))( v30,  -[CLLocation initWithClientLocation:](v31, "initWithClientLocation:", v37),  ((a3 - 1) & 0xFFFFFFFFFFFFFFFDLL) == 0,  v7);
}

void sub_1005D2C14(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

uint64_t sub_1005D3124(_BYTE *a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    uint64_t v6 = 0LL;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      if (v5++ >= 9)
      {
        LODWORD(v6) = 0;
        int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      LODWORD(v6) = 0;
    }
LABEL_13:
    if (v11 || (v6 & 7) == 4) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    switch((unsigned __int16)(v6 >> 3))
    {
      case 1u:
        a1[48] |= 1u;
        unint64_t v13 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v13 <= 0xFFFFFFFFFFFFFFF7LL && v13 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v14 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v13);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v13 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v14 = 0LL;
        }

        uint64_t v20 = 8LL;
        goto LABEL_43;
      case 2u:
        a1[48] |= 2u;
        unint64_t v16 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v16 <= 0xFFFFFFFFFFFFFFF7LL && v16 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v14 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v16);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v16 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v14 = 0LL;
        }

        uint64_t v20 = 16LL;
        goto LABEL_43;
      case 3u:
        a1[48] |= 4u;
        unint64_t v17 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v17 <= 0xFFFFFFFFFFFFFFF7LL && v17 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v14 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v17);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v17 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v14 = 0LL;
        }

        uint64_t v20 = 24LL;
        goto LABEL_43;
      case 4u:
        a1[48] |= 8u;
        unint64_t v18 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v18 <= 0xFFFFFFFFFFFFFFF7LL && v18 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v14 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v18);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v18 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v14 = 0LL;
        }

        uint64_t v20 = 32LL;
LABEL_43:
        *(void *)&a1[v20] = v14;
        goto LABEL_44;
      case 5u:
        uint64_t v19 = objc_alloc_init(&OBJC_CLASS___TRANSITPbRegionPreloadTile);
        [a1 addTiles:v19];

        if (PBReaderPlaceMark(a2, v21) && (sub_100291654((uint64_t)v19, a2) & 1) != 0)
        {
          PBReaderRecallMark(a2, v21);
LABEL_44:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }

        return 0LL;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_44;
    }
  }

_OWORD *sub_1005D3E40(_OWORD *a1, uint64_t a2)
{
  a1[1] = 0u;
  *a1 = 0u;
  sub_10001A504((uint64_t)(a1 + 2), a2);
  return a1;
}

void sub_1005D3E80(_Unwind_Exception *a1)
{
  unsigned int v5 = *(void **)(v1 + 24);
  *(void *)(v1 + 24) = 0LL;
  if (v5) {
    operator delete(v5);
  }
  sub_101240588(v3, v2, (void **)v1);
  _Unwind_Resume(a1);
}

BOOL sub_1005D3EB0(void *a1, int a2)
{
  switch(a2)
  {
    case 0:
      uint64_t v3 = 1LL;
      if (!*a1)
      {
        char v4 = operator new(0xE0uLL);
        void v4[6] = 0u;
        v4[7] = 0u;
        _WORD v4[8] = 0u;
        v4[9] = 0u;
        *char v4 = 0u;
        v4[1] = 0u;
        _DWORD v4[2] = 0u;
        v4[3] = 0u;
        void v4[4] = 0u;
        void v4[5] = 0u;
        v4[10] = 0u;
        v4[11] = 0u;
        v4[12] = 0u;
        v4[13] = 0u;
        *((_BYTE *)v4 + 92) = 1;
        *((_DWORD *)v4 + 2_Block_object_dispose(va, 8) = 5;
        *((_DWORD *)v4 + 26) = 1031798784;
        *((_BYTE *)v4 + 136) = 1;
        *((_DWORD *)v4 + 39) = 5;
        *((_DWORD *)v4 + sub_1005A8CF4(v2 + 37) = 1031798784;
        *((_BYTE *)v4 + 180) = 1;
        *((_DWORD *)v4 + 50) = 5;
        *((_DWORD *)v4 + 4_Block_object_dispose(va, 8) = 1031798784;
        *a1 = v4;
      }

      return v3;
    case 1:
      if (!a1[1])
      {
        unsigned int v5 = operator new(0x2750uLL);
        sub_1002B7BD0((uint64_t)v5);
        uint64_t v6 = (void *)a1[1];
        a1[1] = v5;
        if (v6) {
          goto LABEL_9;
        }
      }

      return *a1 || a1[1] || a1[2] || a1[3] != 0LL;
    case 2:
      if (!a1[2])
      {
        uint64_t v7 = (char *)operator new(0xCE0uLL);
        bzero(v7, 0xCE0uLL);
        *((_DWORD *)v7 + 2) = 256;
        *((_DWORD *)v7 + 776) = 0;
        *((_DWORD *)v7 + 784) = 0;
        *((_DWORD *)v7 + 792) = 0;
        *(_OWORD *)(v7 + 3192) = 0u;
        *(_OWORD *)(v7 + 320_Block_object_dispose(va, 8) = 0u;
        *(_OWORD *)(v7 + 3224) = 0u;
        *((_DWORD *)v7 + 810) = 0;
        sub_100A3E508((uint64_t)(v7 + 3256));
        uint64_t v6 = (void *)a1[2];
        a1[2] = v7;
        if (v6) {
LABEL_9:
        }
          operator delete(v6);
      }

      return *a1 || a1[1] || a1[2] || a1[3] != 0LL;
    case 3:
      if (!a1[3])
      {
        unint64_t v8 = operator new(0xB8uLL);
        BOOL v8[4] = 0u;
        void v8[5] = 0u;
        void v8[6] = 0u;
        void v8[7] = 0u;
        _WORD v8[8] = 0u;
        v8[9] = 0u;
        *unint64_t v8 = 0u;
        v8[1] = 0u;
        _DWORD v8[2] = 0u;
        v8[3] = 0u;
        v8[10] = 0u;
        *((void *)v8 + 22) = 0LL;
        *((_BYTE *)v8 + 4_Block_object_dispose(va, 8) = 1;
        *((_DWORD *)v8 + 17) = 5;
        *((_DWORD *)v8 + 15) = 1031798784;
        *((_BYTE *)v8 + 92) = 1;
        *((_DWORD *)v8 + 2_Block_object_dispose(va, 8) = 5;
        *((_DWORD *)v8 + 26) = 1031798784;
        *((_BYTE *)v8 + 136) = 1;
        *((_DWORD *)v8 + 39) = 5;
        *((_DWORD *)v8 + sub_1005A8CF4(v2 + 37) = 1031798784;
        a1[3] = v8;
      }

      return *a1 || a1[1] || a1[2] || a1[3] != 0LL;
    default:
      return *a1 || a1[1] || a1[2] || a1[3] != 0LL;
  }

void sub_1005D4078(_Unwind_Exception *a1)
{
}

BOOL sub_1005D4090(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      uint64_t v3 = *(void **)a1;
      *(void *)a1 = 0LL;
      if (v3) {
        goto LABEL_9;
      }
      goto LABEL_11;
    case 1:
      uint64_t v3 = *(void **)(a1 + 8);
      *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
      if (!v3) {
        break;
      }
      goto LABEL_9;
    case 2:
      uint64_t v3 = *(void **)(a1 + 16);
      *(void *)(a1 + 16) = 0LL;
      if (!v3) {
        break;
      }
      goto LABEL_9;
    case 3:
      uint64_t v3 = *(void **)(a1 + 24);
      *(void *)(a1 + 24) = 0LL;
      if (v3) {
LABEL_9:
      }
        operator delete(v3);
      break;
    default:
      break;
  }

  if (*(void *)a1) {
    return 1LL;
  }
LABEL_11:
  if (*(void *)(a1 + 8) || *(void *)(a1 + 16)) {
    return 1LL;
  }
  return *(void *)(a1 + 24) != 0LL;
}

uint64_t sub_1005D413C(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)result;
  int v4 = 0;
  unsigned int v5 = (int *)(result + 64);
  uint64_t v6 = result + 72;
  while (2)
  {
    switch(v4)
    {
      case 0:
        uint64_t result = *v3;
        if (!*v3) {
          goto LABEL_16;
        }
        uint64_t result = sub_100B3D3A0(result, a2, (uint64_t)&v13);
        if (!(_DWORD)result) {
          goto LABEL_16;
        }
        _DWORD v12[4] = v13;
        void v12[5] = v14;
        int v15 = 0;
        uint64_t v7 = v3[7];
        if (!v7) {
          goto LABEL_22;
        }
        unint64_t v8 = *(uint64_t (**)(void))(*(void *)v7 + 48LL);
        goto LABEL_15;
      case 1:
        uint64_t result = v3[1];
        if (!result) {
          goto LABEL_16;
        }
        uint64_t result = sub_1002B7BD4(result, a2, v5, v6, (uint64_t)&v13);
        if (!(_DWORD)result) {
          goto LABEL_16;
        }
        void v12[2] = v13;
        void v12[3] = v14;
        int v15 = 1;
        uint64_t v9 = v3[7];
        if (!v9) {
          goto LABEL_22;
        }
        unint64_t v8 = *(uint64_t (**)(void))(*(void *)v9 + 48LL);
        goto LABEL_15;
      case 2:
        uint64_t result = v3[2];
        if (!result) {
          goto LABEL_16;
        }
        uint64_t result = sub_1005B1544(result, a2, v5, (uint64_t)&v13);
        if (!(_DWORD)result) {
          goto LABEL_16;
        }
        void v12[6] = v13;
        v12[7] = v14;
        int v15 = 2;
        uint64_t v10 = v3[7];
        if (!v10) {
          goto LABEL_22;
        }
        unint64_t v8 = *(uint64_t (**)(void))(*(void *)v10 + 48LL);
LABEL_15:
        uint64_t result = v8();
LABEL_16:
        if (++v4 == 4) {
          return result;
        }
        continue;
      case 3:
        uint64_t result = v3[3];
        if (!result) {
          return result;
        }
        uint64_t result = sub_10050C8A4(result, a2, (uint64_t)&v13);
        if (!(_DWORD)result) {
          return result;
        }
        v12[0] = v13;
        v12[1] = v14;
        int v15 = 3;
        uint64_t v11 = v3[7];
        if (!v11) {
LABEL_22:
        }
          sub_100008BDC();
        return (*(uint64_t (**)(uint64_t, int *, _OWORD *))(*(void *)v11 + 48LL))(v11, &v15, v12);
      default:
        goto LABEL_16;
    }
  }

void *sub_1005D42E4(void *result)
{
  if (result)
  {
    id v1 = objc_msgSend(objc_msgSend(result, "lastPathComponent"), "componentsSeparatedByString:", @"-");
    if ((unint64_t)[v1 count] >= 3)
    {
      objc_msgSend(objc_msgSend(v1, "objectAtIndex:", 1), "doubleValue");
      uint64_t v3 = v2;
      objc_msgSend(objc_msgSend(v1, "objectAtIndex:", 2), "intValue");
      return (void *)v3;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void *sub_1005D4368(void *a1)
{
  return sub_1005D42E4([a1 path]);
}

NSString *sub_1005D437C(uint64_t a1, uint64_t a2)
{
  return +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"secondary-%f-%zu", a1, a2);
}

uint64_t sub_1005D43B0(void *a1)
{
  uint64_t v2 = open_dprotected_np((const char *)[a1 UTF8String], 521, 2, 0, 416);
  if ((_DWORD)v2 == -1)
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_1018429A0);
    }
    uint64_t v3 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = __error();
      unsigned int v5 = strerror(*v4);
      *(_DWORD *)std::stringbuf::string_type buf = 68289539;
      int v8 = 0;
      __int16 v9 = 2082;
      uint64_t v10 = "";
      __int16 v11 = 2082;
      uint64_t v12 = v5;
      __int16 v13 = 2113;
      __int128 v14 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning open failed, errno:%{public, location:escape_only}s, path:%{private, l ocation:escape_only}@}",  buf,  0x26u);
    }
  }

  return v2;
}

uint64_t sub_1005D44DC(void *a1)
{
  uint64_t v2 = open((const char *)[a1 UTF8String], 0);
  if ((_DWORD)v2 == -1)
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_1018429A0);
    }
    uint64_t v3 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = __error();
      unsigned int v5 = strerror(*v4);
      v7[0] = 68289539;
      v7[1] = 0;
      __int16 v8 = 2082;
      __int16 v9 = "";
      __int16 v10 = 2082;
      __int16 v11 = v5;
      __int16 v12 = 2113;
      __int16 v13 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning open failed, errno:%{public, location:escape_only}s, path:%{private, l ocation:escape_only}@}",  (uint8_t *)v7,  0x26u);
    }
  }

  return v2;
}

BOOL sub_1005D45F8(void *a1, void *a2, int a3)
{
  uint64_t v6 = sub_1005D43B0(a1);
  uint64_t v7 = sub_1005D44DC(a2);
  if ((_DWORD)v6 == -1 || (int v8 = v7, (_DWORD)v7 == -1))
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_1018429A0);
    }
    __int128 v14 = (os_log_s *)qword_1019349B8;
    uint64_t v10 = 0LL;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289539;
      int v19 = 0;
      __int16 v20 = 2082;
      unsigned int v21 = "";
      __int16 v22 = 2113;
      double v23 = a1;
      __int16 v24 = 2113;
      uint64_t v25 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning failed to concatenate files, leading:%{private, location:escape_only}@,  trailing:%{private, location:escape_only}@}",  buf,  0x26u);
      return 0LL;
    }
  }

  else
  {
    id v9 = -[NSData _cl_initWithFileDescriptor:](objc_alloc(&OBJC_CLASS___NSData), "_cl_initWithFileDescriptor:", v7);
    uint64_t v10 = 1LL;
    __int16 v11 = -[NSFileHandle initWithFileDescriptor:closeOnDealloc:]( objc_alloc(&OBJC_CLASS___NSFileHandle),  "initWithFileDescriptor:closeOnDealloc:",  v6,  1LL);
    -[NSFileHandle writeData:](v11, "writeData:", v9);

    close(v8);
    if (a3
      && -[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  a2))
    {
      unint64_t v17 = 0LL;
      -[NSFileManager removeItemAtPath:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtPath:error:",  a2,  &v17);
      if (v17)
      {
        if (qword_1019349B0 != -1) {
          dispatch_once(&qword_1019349B0, &stru_1018429A0);
        }
        __int16 v12 = (os_log_s *)qword_1019349B8;
        if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 68289539;
          int v19 = 0;
          __int16 v20 = 2082;
          unsigned int v21 = "";
          __int16 v22 = 2113;
          double v23 = a2;
          __int16 v24 = 2113;
          uint64_t v25 = v17;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:failed to remove fs item, path:%{private, location:escape_only}@, error:%{p rivate, location:escape_only}@}",  buf,  0x26u);
          if (qword_1019349B0 != -1) {
            dispatch_once(&qword_1019349B0, &stru_1018429A0);
          }
        }

        __int16 v13 = (os_log_s *)qword_1019349B8;
        if (os_signpost_enabled((os_log_t)qword_1019349B8))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 68289539;
          int v19 = 0;
          __int16 v20 = 2082;
          unsigned int v21 = "";
          __int16 v22 = 2113;
          double v23 = a2;
          __int16 v24 = 2113;
          uint64_t v25 = v17;
          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "failed to remove fs item",  "{msg%{public}.0s:failed to remove fs item, path:%{private, location:escape_only}@, error:%{p rivate, location:escape_only}@}",  buf,  0x26u);
        }
      }

      else
      {
        if (qword_1019349B0 != -1) {
          dispatch_once(&qword_1019349B0, &stru_1018429A0);
        }
        int v15 = (os_log_s *)qword_1019349B8;
        if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 68289283;
          int v19 = 0;
          __int16 v20 = 2082;
          unsigned int v21 = "";
          __int16 v22 = 2113;
          double v23 = a2;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:removed fs item, path:%{private, location:escape_only}@}",  buf,  0x1Cu);
        }
      }

      return v17 == 0LL;
    }
  }

  return v10;
}

void sub_1005D499C(id a1)
{
  qword_1019349B8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

void sub_1005D4BA4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1005D4BBC(uint64_t a1, uint64_t a2)
{
}

void sub_1005D4BCC(uint64_t a1)
{
}

id sub_1005D4BD8(uint64_t a1)
{
  id result = [*(id *)(*(void *)(a1 + 32) + 8) hasChanges];
  if ((_DWORD)result) {
    return _[*(id *)(*(void *)(a1 + 32) + 8) save:*(void *)(*(void *)(a1 + 40) + 8) + 40];
  }
  return result;
}

void sub_1005D4CE4(_Unwind_Exception *a1)
{
}

void sub_1005D4CFC(void *a1)
{
  uint64_t v2 = -[NSFetchRequest initWithEntityName:](objc_alloc(&OBJC_CLASS___NSFetchRequest), "initWithEntityName:", a1[4]);
  -[NSFetchRequest setPredicate:]( v2,  "setPredicate:",  +[NSCompoundPredicate andPredicateWithSubpredicates:]( &OBJC_CLASS___NSCompoundPredicate,  "andPredicateWithSubpredicates:",  a1[5]));
  uint64_t v3 = -[NSBatchDeleteRequest initWithFetchRequest:]( objc_alloc(&OBJC_CLASS___NSBatchDeleteRequest),  "initWithFetchRequest:",  v2);
  [*(id *)(a1[6] + 8) executeRequest:v3 error:*(void *)(a1[7] + 8) + 40];
}

void sub_1005D4EA4(_Unwind_Exception *a1)
{
}

void sub_1005D4ED0(uint64_t a1)
{
  int v4 = objc_alloc_init(&OBJC_CLASS___NSFetchRequest);
  -[NSFetchRequest setEntity:]( v4,  "setEntity:",  +[NSEntityDescription entityForName:inManagedObjectContext:]( &OBJC_CLASS___NSEntityDescription,  "entityForName:inManagedObjectContext:",  *(void *)(a1 + 32),  *(void *)(*(void *)(a1 + 40) + 8LL)));
  -[NSFetchRequest setPredicate:]( v4,  "setPredicate:",  +[NSCompoundPredicate andPredicateWithSubpredicates:]( &OBJC_CLASS___NSCompoundPredicate,  "andPredicateWithSubpredicates:",  *(void *)(a1 + 48)));
  id v2 = [*(id *)(*(void *)(a1 + 40) + 8) executeFetchRequest:v4 error:*(void *)(*(void *)(a1 + 56) + 8) + 40];
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _OWORD v5[2] = sub_1005D4FA0;
  void v5[3] = &unk_101842A18;
  __int128 v3 = *(_OWORD *)(a1 + 64);
  __int128 v6 = *(_OWORD *)(a1 + 32);
  __int128 v7 = v3;
  [v2 enumerateObjectsUsingBlock:v5];
}

id sub_1005D4FA0(uint64_t a1, void *a2)
{
  int v4 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"managedObject of class %@ must respond to convert selector",  NSClassFromString(*(NSString **)(a1 + 32)));
  if ((objc_opt_respondsToSelector(a2, "convert") & 1) == 0) {
    -[NSAssertionHandler handleFailureInMethod:object:file:lineNumber:description:]( +[NSAssertionHandler currentHandler](&OBJC_CLASS___NSAssertionHandler, "currentHandler"),  "handleFailureInMethod:object:file:lineNumber:description:",  *(void *)(a1 + 56),  *(void *)(a1 + 40),  @"CLStore.m",  102LL,  v4);
  }
  id result = [a2 performSelector:"convert"];
  if (result) {
    return [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) addObject:result];
  }
  return result;
}

void sub_1005D515C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

id sub_1005D5180(void *a1)
{
  id v2 = +[NSFetchRequest fetchRequestWithEntityName:](&OBJC_CLASS___NSFetchRequest, "fetchRequestWithEntityName:", a1[4]);
  -[NSFetchRequest setPredicate:]( v2,  "setPredicate:",  +[NSCompoundPredicate andPredicateWithSubpredicates:]( &OBJC_CLASS___NSCompoundPredicate,  "andPredicateWithSubpredicates:",  a1[5]));
  id result = [*(id *)(a1[6] + 8) countForFetchRequest:v2 error:*(void *)(a1[8] + 8) + 40];
  *(void *)(*(void *)(a1[7] + 8LL) + 24LL) = result;
  return result;
}

void sub_1005D52A8(id a1)
{
  qword_1019972E8 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLLocationStreamerSilo");
}

void sub_1005D5318(id a1)
{
  if (objc_opt_class(&OBJC_CLASS___IDSService))
  {
    sub_1004F2598();
    if (sub_1004FAA50())
    {
      sub_1004F2598();
      if (sub_1004F7500()) {
        byte_1019972F8 = 1;
      }
    }
  }

void sub_1005D582C(_Unwind_Exception *a1)
{
}

id sub_1005D5868(uint64_t a1)
{
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_101842AC8);
  }
  uint64_t v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    __int16 v5 = 2082;
    __int128 v6 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Stop timer fired}",  (uint8_t *)v4,  0x12u);
  }

  return [*(id *)(a1 + 32) stopLocation];
}

id sub_1005D5948(uint64_t a1)
{
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_101842AC8);
  }
  uint64_t v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    __int16 v5 = 2082;
    __int128 v6 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Motion alarm stop timer fired}",  (uint8_t *)v4,  0x12u);
  }

  return [*(id *)(a1 + 32) stopMotionAlarm];
}

id sub_1005D5A28(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return _[a4 onLocationNotification:a2 withData:a3];
}

id sub_1005D5A38(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return _[a4 onMotionStateNotification:a2 withData:a3];
}

id sub_1005D5A48(uint64_t a1)
{
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_101842AC8);
  }
  uint64_t v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    __int16 v5 = 2082;
    __int128 v6 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Repeating motion state}",  (uint8_t *)v4,  0x12u);
  }

  return [*(id *)(a1 + 32) sendMotionState];
}

id sub_1005D5B28(uint64_t a1)
{
  return [*(id *)(a1 + 32) setAliveAgainThrottleTimer:0];
}

void sub_1005D5C2C(uint64_t **a1, uint64_t *a2)
{
  __int128 v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    int v4 = sub_1005D7FFC(v3);
    operator delete(v4);
  }

uint64_t sub_1005D6760(uint64_t a1)
{
  double v2 = *(double *)(a1 + 16) + 5.0;
  __int128 v3 = operator new(0x30uLL);
  sub_100AD558C((uint64_t)v3, (uint64_t)"CLLocationStreamer::RollingPowerAssertion", a1, v2);
  if (*(char *)(a1 + 47) < 0)
  {
    sub_1010DD48C(__p, *(void **)(a1 + 24), *(void *)(a1 + 32));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 40);
  }

  sub_100AD5668((uint64_t)v3, (uint64_t *)__p);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
  uint64_t result = *(void *)a1;
  *(void *)a1 = v3;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_1005D6824( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_1005D7548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1005D7F0C(id a1)
{
  qword_101934998 = (uint64_t)os_log_create("com.apple.locationd.Core", "Streaming");
}

uint64_t sub_1005D7F38(uint64_t a1, __int128 *a2, void *a3, uint64_t a4, double a5)
{
  *(void *)a1 = 0LL;
  id v9 = [a3 newTimer];
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 64), 8) = v9;
  *(double *)(a1 + 16) = a5;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 24), *(void **)a2, *((void *)a2 + 1));
    id v9 = *(id *)(a1 + 8);
  }

  else
  {
    __int128 v10 = *a2;
    *(void *)(a1 + 40) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 24) = v10;
  }

  [v9 setHandler:a4];
  return a1;
}

void sub_1005D7FC0(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v1;
  *uint64_t v1 = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1005D7FFC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_1005D8058()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_10130AE30;
      v1[3] = unk_10130AE40;
      v1[4] = xmmword_10130AE50;
      v1[0] = xmmword_10130AE10;
      v1[1] = unk_10130AE20;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_1005D812C(_Unwind_Exception *a1)
{
}

double sub_1005D8144()
{
  double result = 30.0;
  qword_101997308 = 0x403E000000000000LL;
  return result;
}

uint64_t sub_1005D815C(uint64_t a1, uint64_t a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_1005D81B4;
  void v3[3] = &unk_101820718;
  void v3[4] = a2;
  return AnalyticsSendEventLazy(@"com.apple.CoreMotion.MotionStateBoutMetrics", v3);
}

NSDictionary *sub_1005D81B4(uint64_t a1)
{
  v5[0] = @"boutType";
  v6[0] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned __int8 *)(*(void *)(a1 + 32) + 1LL));
  v5[1] = @"duration";
  *(float *)&double v2 = (float)*(unint64_t *)(*(void *)(a1 + 32) + 2LL);
  v6[1] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v2);
  _OWORD v5[2] = @"timeSinceLastBout";
  *(float *)&double v3 = (float)*(unint64_t *)(*(void *)(a1 + 32) + 10LL);
  _DWORD v6[2] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v3);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v6,  v5,  3LL);
}

uint64_t sub_1005D8288(uint64_t a1)
{
  double v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 64), 8) = v2;
    operator delete(v2);
  }

  return a1;
}

void sub_1005D835C(id a1)
{
  qword_101997310 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLCorrectiveCompensatedLocationProviderSilo");
}

uint64_t sub_1005D8410(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1005D88A4;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_101997320 != -1) {
    dispatch_once(&qword_101997320, block);
  }
  return qword_1019A11A8;
}

id sub_1005D85D0(id *a1, uint64_t a2)
{
  *(void *)&_OWORD v16[4] = 0LL;
  *(void *)&v16[12] = 0LL;
  *(_OWORD *)&v16[20] = xmmword_1012E0070;
  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)&v16[36] = _Q0;
  *(_OWORD *)&v16[52] = _Q0;
  *(_OWORD *)&v16[68] = _Q0;
  *(_DWORD *)unint64_t v16 = 0xFFFF;
  *(_DWORD *)&v16[84] = 0;
  *(void *)&v16[88] = 0xBFF0000000000000LL;
  __int128 v17 = 0uLL;
  *(void *)((char *)&v18 + 4) = 0xBFF0000000000000LL;
  LODWORD(v1_Block_object_dispose((const void *)(v11 - 64), 8) = 0;
  HIDWORD(v1_Block_object_dispose((const void *)(v11 - 64), 8) = 0x7FFFFFFF;
  memset(v19, 0, 25);
  if ((*((unsigned int (**)(id *, _BYTE *))*a1 + 29))(a1, v16)
    && sub_100869780((uint64_t)v16)
    && (double v9 = *(double *)&v16[20], *(double *)&v16[20] > 0.0))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    __int128 v10 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      uint64_t buf = 68289539LL;
      __int16 v21 = 2082;
      __int16 v22 = "";
      __int16 v23 = 1040;
      int v24 = 156;
      __int16 v25 = 2097;
      double v26 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#cclp passing cached location to reply, location:%{private, location:CLClientLocation}.*P}",  (uint8_t *)&buf,  0x22u);
    }

    void v14[6] = v17;
    v14[7] = v18;
    v15[0] = *(_OWORD *)v19;
    *(_OWORD *)((char *)v15 + 12) = *(_OWORD *)&v19[12];
    _DWORD v14[2] = *(_OWORD *)&v16[32];
    v14[3] = *(_OWORD *)&v16[48];
    v14[4] = *(_OWORD *)&v16[64];
    v14[5] = *(_OWORD *)&v16[80];
    v14[0] = *(_OWORD *)v16;
    v14[1] = *(_OWORD *)&v16[16];
    return (id)(*(uint64_t (**)(uint64_t, uint64_t, _OWORD *))(a2 + 16))(a2, 1LL, v14);
  }

  else
  {
    id v12 = objc_msgSend( objc_msgSend(a1[4], "vendor", v9),  "proxyForService:forClient:",  @"CLLocationController",  @"CLCorrectiveCompensatedLocationProvider");
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472LL;
    _DWORD v13[2] = sub_1005DA714;
    void v13[3] = &unk_101842C80;
    _DWORD v13[4] = a2;
    v13[5] = a1;
    return [v12 fetchLocationWithReply:v13];
  }

uint64_t sub_1005D8800(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  __int128 v4 = a3[7];
  __int128 v16 = a3[6];
  __int128 v17 = v4;
  v18[0] = a3[8];
  *(_OWORD *)((char *)v18 + 12) = *(__int128 *)((char *)a3 + 140);
  __int128 v5 = a3[3];
  __int128 v12 = a3[2];
  __int128 v13 = v5;
  __int128 v6 = a3[5];
  __int128 v14 = a3[4];
  __int128 v15 = v6;
  __int128 v7 = a3[1];
  __int128 v10 = *a3;
  __int128 v11 = v7;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  void v9[2] = sub_1005DCCFC;
  v9[3] = &unk_101839070;
  return (*(uint64_t (**)(uint64_t, uint64_t, id))(v3 + 16))(v3, a2, [v9 copy]);
}

uint64_t sub_1005D88A4(uint64_t a1)
{
  double v2 = operator new(0x190uLL);
  uint64_t result = sub_1005D88F0((uint64_t)v2, *(void **)(a1 + 32));
  qword_1019A11A8 = (uint64_t)v2;
  return result;
}

void sub_1005D88DC(_Unwind_Exception *a1)
{
}

uint64_t sub_1005D88F0(uint64_t a1, void *a2)
{
  *(void *)sub_100479C24(a1, "correctiveCompensated", a2) = off_101842B40;
  id v3 = -[CLSettingsMirror initInUniverse:]( objc_alloc(&OBJC_CLASS___CLSettingsMirror),  "initInUniverse:",  *(void *)(a1 + 32));
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v11 - 64), 8) = 0LL;
  __int128 v4 = (uint64_t *)(a1 + 128);
  *(void *)(a1 + 120) = v3;
  *(void *)(a1 + 136) = 0LL;
  *(void *)(a1 + 144) = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "silo"), "newTimer");
  *(void *)(a1 + 152) = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "silo"), "newTimer");
  id v5 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "silo"), "newTimer");
  *(void *)(a1 + 20_Block_object_dispose((const void *)(v11 - 64), 8) = off_10182F180;
  *(void *)(a1 + 160) = v5;
  __asm { FMOV            V0.2D, #-1.0 }

  __int128 v20 = _Q0;
  *(_OWORD *)(a1 + 16_Block_object_dispose((const void *)(v11 - 64), 8) = _Q0;
  *(_BYTE *)(a1 + 184) = 0;
  *(_BYTE *)(a1 + 202) = 0;
  __int128 v11 = operator new(0x20uLL);
  _DWORD v11[2] = 0LL;
  *__int128 v11 = off_10182F1B8;
  v11[1] = 0LL;
  *((_DWORD *)v11 + 6) = 31337;
  *(void *)(a1 + 20_Block_object_dispose((const void *)(v11 - 64), 8) = off_10183EE40;
  *(void *)(a1 + 216) = v11 + 3;
  *(void *)(a1 + 224) = v11;
  *(void *)(a1 + 232) = 0LL;
  *(_DWORD *)(a1 + 240) = 0xFFFF;
  *(void *)(a1 + 252) = 0LL;
  *(void *)(a1 + 244) = 0LL;
  *(_OWORD *)(a1 + 260) = xmmword_1012E0070;
  *(_OWORD *)(a1 + 276) = v20;
  *(_OWORD *)(a1 + 292) = v20;
  *(_OWORD *)(a1 + 30_Block_object_dispose((const void *)(v11 - 64), 8) = v20;
  *(_DWORD *)(a1 + 324) = 0;
  *(void *)(a1 + 336) = 0LL;
  *(void *)(a1 + 344) = 0LL;
  *(void *)(a1 + 32_Block_object_dispose((const void *)(v11 - 64), 8) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 352) = 0;
  *(void *)(a1 + 356) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 364) = 0x7FFFFFFF;
  *(void *)(a1 + 376) = 0LL;
  *(void *)(a1 + 384) = 0LL;
  *(void *)(a1 + 36_Block_object_dispose((const void *)(v11 - 64), 8) = 0LL;
  *(_BYTE *)(a1 + 392) = 0;
  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  _OWORD v25[2] = sub_1005D8C80;
  void v25[3] = &unk_10183FFC8;
  _OWORD v25[4] = a1;
  [*(id *)(a1 + 120) setSettingsChangeHandler:v25];
  sub_1005D8C88(a1);
  id v12 =  objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "proxyForService:",  @"CLLocationCorrectiveCompensator");
  *(void *)(a1 + 192) = v12;
  objc_msgSend(v12, "registerDelegate:inSilo:", sub_100520500(a1 + 208), objc_msgSend(*(id *)(a1 + 32), "silo"));
  *(_BYTE *)(a1 + 200) = 0;
  sub_1006DB4E8((uint64_t)sub_1005D9270, a1, *(void **)(a1 + 32), &v24);
  uint64_t v13 = v24;
  uint64_t v24 = 0LL;
  uint64_t v14 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = v13;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
    uint64_t v15 = v24;
    uint64_t v24 = 0LL;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
  }

  objc_msgSend( *(id *)(*(void *)(a1 + 136) + 16),  "register:forNotification:registrationInfo:",  *(void *)(*(void *)(a1 + 136) + 8),  13,  0,  v20);
  sub_1004EEF6C((uint64_t)sub_1005D9440, a1, *(void **)(a1 + 32), &v24);
  uint64_t v16 = v24;
  uint64_t v24 = 0LL;
  uint64_t v17 = *v4;
  *__int128 v4 = v16;
  if (v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
    uint64_t v18 = v24;
    uint64_t v24 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
  }

  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  _OWORD v23[2] = sub_1005D9618;
  v23[3] = &unk_10181D3D0;
  v23[4] = a1;
  [*(id *)(a1 + 144) setHandler:v23];
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472LL;
  void v22[2] = sub_1005D986C;
  _DWORD v22[3] = &unk_10181D3D0;
  v22[4] = a1;
  [*(id *)(a1 + 152) setHandler:v22];
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472LL;
  _DWORD v21[2] = sub_1005D9AC0;
  _DWORD v21[3] = &unk_10181D3D0;
  v21[4] = a1;
  [*(id *)(a1 + 160) setHandler:v21];
  return a1;
}

void sub_1005D8C14(_Unwind_Exception *a1)
{
  uint64_t v5 = *(void *)(v1 + 136);
  *(void *)(v1 + 136) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *v3;
  uint64_t *v3 = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  sub_10047A1C0(v1);
  _Unwind_Resume(a1);
}

void sub_1005D8C80(uint64_t a1)
{
}

void sub_1005D8C88(uint64_t a1)
{
  double v2 = *(double *)(a1 + 168);
  [*(id *)(a1 + 120) doubleForKey:@"CCLP.CorrectiveCompensationInterval" defaultValue:900.0];
  *(void *)(a1 + 16_Block_object_dispose((const void *)(v11 - 64), 8) = v3;
  double v4 = *(double *)(a1 + 176);
  [*(id *)(a1 + 120) doubleForKey:@"CCLP.ApparentCorrectiveCompensationInterval" defaultValue:1.79769313e308];
  *(void *)(a1 + 176) = v5;
  *(_BYTE *)(a1 + 184) = [*(id *)(a1 + 120) BOOLForKey:@"CCLP.CorrectiveCompensationClaimsOriginalAccuracy" defaultValue:0];
  *(_BYTE *)(a1 + 201) = [*(id *)(a1 + 120) BOOLForKey:@"CCLP.ClockAlignmentTestModeEnabled" defaultValue:0];
  *(_BYTE *)(a1 + 204) = [*(id *)(a1 + 120) BOOLForKey:@"CCLP.EnableClockAlignment" defaultValue:0];
  if (*(_BYTE *)(a1 + 201)) {
    *(void *)(a1 + 16_Block_object_dispose((const void *)(v11 - 64), 8) = 0x405E000000000000LL;
  }
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842D50);
  }
  uint64_t v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 168);
    uint64_t v8 = *(void *)(a1 + 176);
    int v9 = *(unsigned __int8 *)(a1 + 184);
    int v10 = *(unsigned __int8 *)(a1 + 201);
    int v11 = *(unsigned __int8 *)(a1 + 204);
    uint64_t v12 = 0x4059000000000000LL;
    if (!*(_BYTE *)(a1 + 201)) {
      uint64_t v12 = 0x4088600000000000LL;
    }
    uint64_t v13 = 0x4064000000000000LL;
    if (!*(_BYTE *)(a1 + 201)) {
      uint64_t v13 = 0x4092C00000000000LL;
    }
    *(_DWORD *)uint64_t buf = 68290818;
    __int16 v27 = 2082;
    int v26 = 0;
    BOOL v28 = "";
    __int16 v29 = 2050;
    uint64_t v30 = v7;
    __int16 v31 = 2050;
    uint64_t v32 = v8;
    __int16 v33 = 1026;
    int v34 = v9;
    __int16 v35 = 1026;
    int v36 = v10;
    __int16 v37 = 1026;
    int v38 = v11;
    __int16 v39 = 2050;
    uint64_t v40 = v12;
    __int16 v41 = 2050;
    uint64_t v42 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Update #compensation #settings for CCLP, CorrectiveCompensationInterval:%{public}f , ApparentCorrectiveCompensationInterval:%{public}f, CorrectiveCompensationClaimsOriginalAccuracy:%{pu blic}hhd, ClockAlignmentTestModeEnabled:%{public}hhd, EnableClockAlignment:%{public}hhd, CorrectiveCompe nsationIntervalLowerBound:%{public}f, CorrectiveCompensationIntervalUpperBound:%{public}f}",  buf,  0x4Cu);
  }

  if (*(double *)(a1 + 168) != v2)
  {
    [*(id *)(a1 + 144) nextFireDelay];
    if (v14 != 1.79769313e308)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      uint64_t v15 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "#cclp CorrectiveCompensationInterval changed. Reset CompensationTimer.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101842D50);
        }
        v24[0] = 0;
        __int128 v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "#cclp CorrectiveCompensationInterval changed. Reset CompensationTimer.",  v24,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::refreshSettings()",  "%s\n",  v20);
      }

      [*(id *)(a1 + 144) setNextFireDelay:0.0];
    }
  }

  double v16 = *(double *)(a1 + 176);
  if (v16 != v4)
  {
    if (v16 > *(double *)(a1 + 168))
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      uint64_t v17 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "#warning #cclp ApparentCorrectiveCompensationInterval greater than CorrectiveCompensationInterval",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101842D50);
        }
        v24[0] = 0;
        LODWORD(v23) = 2;
        __int16 v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "#warning #cclp ApparentCorrectiveCompensationInterval greater than CorrectiveCompensationInterval",  v24,  v23);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::refreshSettings()",  "%s\n",  v22);
      }

      *(void *)(a1 + 176) = 0x7FEFFFFFFFFFFFFFLL;
    }

    [*(id *)(a1 + 144) nextFireDelay];
    if (v18 != 1.79769313e308)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      int v19 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "#cclp ApparentCorrectiveCompensationInterval changed. Reset ApparentCompensationTimer.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101842D50);
        }
        v24[0] = 0;
        LODWORD(v23) = 2;
        __int16 v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "#cclp ApparentCorrectiveCompensationInterval changed. Reset ApparentCompensationTimer.",  v24,  v23);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::refreshSettings()",  "%s\n",  v21);
      }

      [*(id *)(a1 + 152) setNextFireDelay:0.0];
    }
  }

void sub_1005D9270(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101842D30);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLCorrectiveCompensatedLocationProvider::onSimulationNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842D30);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLCorrectiveCompensatedLocationProvider::onSimulationNotification, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_1005DBD78(a4, v6, v7, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005D9420( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005D9440(uint64_t a1, unsigned int *a2, uint64_t a3, id *a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101842D30);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLCorrectiveCompensatedLocationProvider::onLocationNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842D30);
    }
    int v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLCorrectiveCompensatedLocationProvider::onLocationNotification, event:%{public, lo cation:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_1005DBBDC(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005D95F8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

id sub_1005D9618(uint64_t a1)
{
  return sub_1005D9620(*(void *)(a1 + 32));
}

id sub_1005D9620(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842D50);
  }
  double v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    [*(id *)(a1 + 40) currentLatchedAbsoluteTimestamp];
    *(_DWORD *)uint64_t buf = 134217984;
    uint64_t v15 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#cclp CompensationTimer fired at : %f",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    uint64_t v8 = qword_101934988;
    [*(id *)(a1 + 40) currentLatchedAbsoluteTimestamp];
    int v12 = 134217984;
    uint64_t v13 = v9;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v8,  0LL,  "#cclp CompensationTimer fired at : %f",  COERCE_DOUBLE(&v12));
    char v11 = (uint8_t *)v10;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::onCompensationTimer()",  "%s\n",  v10);
    if (v11 != buf) {
      free(v11);
    }
  }

  id result = [*(id *)(a1 + 144) setNextFireDelay:1.79769313e308];
  uint64_t v5 = (unsigned int *)qword_1019A1190;
  uint64_t v6 = qword_1019A1198;
  while (v5 != (unsigned int *)v6)
  {
    *(_DWORD *)uint64_t buf = *v5;
    if (sub_100247620(a1, (int *)buf, 1LL))
    {
      id result = [*(id *)(*(void *)(a1 + 128) + 16) register:*(void *)(*(void *)(a1 + 128) + 8) forNotification:*v5 registrationInfo:0];
      char v7 = 1;
    }

    else
    {
      (*(void (**)(uint64_t, unsigned int *))(*(void *)a1 + 120LL))(a1, v5);
      id result = [*(id *)(*(void *)(a1 + 128) + 16) unregister:*(void *)(*(void *)(a1 + 128) + 8) forNotification:*v5];
      char v7 = 0;
    }

    *(_BYTE *)(a1 + 203) = v7;
    ++v5;
  }

  return result;
}

void sub_1005D986C(uint64_t a1)
{
}

void sub_1005D9874(uint64_t a1)
{
  LODWORD(buf) = 0;
  if (((*(uint64_t (**)(uint64_t, uint64_t *, _BYTE *))(*(void *)a1 + 128LL))(a1, &buf, v14) & 1) != 0)
  {
    [*(id *)(a1 + 40) currentLatchedAbsoluteTimestamp];
    uint64_t v15 = v2;
    double v16 = *(double *)(a1 + 168) * 1.33333333;
    LODWORD(buf) = 0;
    sub_10047B624((char *)a1, (int *)&buf, (uint64_t)v14, 1, 0xFFFFFFFFLL, 0);
    double v3 = *(double *)(a1 + 176);
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    double v4 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      uint64_t buf = 68289026LL;
      __int16 v24 = 2082;
      __int16 v25 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#cclp ceasing apparent #compensation rate increase monitoring due to no cached message}",  (uint8_t *)&buf,  0x12u);
    }

    double v3 = 1.79769313e308;
  }

  [*(id *)(a1 + 152) setNextFireDelay:v3];

  uint64_t v5 = v21;
  if (v21)
  {
    p_shared_owners = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  if (v20 < 0) {
    operator delete(__p);
  }
  uint64_t v8 = v18;
  if (v18)
  {
    uint64_t v9 = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  char v11 = v17;
  if (v17)
  {
    int v12 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

void sub_1005D9A94(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1005D9AC0(uint64_t a1)
{
}

void sub_1005D9AC8(uint64_t a1)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842D50);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 1040;
    *(_DWORD *)&buf[20] = 156;
    *(_WORD *)&_BYTE buf[24] = 2097;
    *(void *)&buf[26] = a1 + 240;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#cclp UpdateLastReceivedLocationTimer fired. Using location, location:%{private, loca tion:CLClientLocation}.*P}",  buf,  0x22u);
  }

  [*(id *)(a1 + 160) setNextFireDelay:1.79769313e308];
  if ((sub_100869780(a1 + 240) & 1) != 0)
  {
    sub_100246564((uint64_t)buf);
    __int128 v3 = *(_OWORD *)(a1 + 352);
    __int128 v30 = *(_OWORD *)(a1 + 336);
    __int128 v31 = v3;
    v32[0] = *(_OWORD *)(a1 + 368);
    *(_OWORD *)((char *)v32 + 12) = *(_OWORD *)(a1 + 380);
    __int128 v4 = *(_OWORD *)(a1 + 288);
    *(_OWORD *)&_BYTE buf[32] = *(_OWORD *)(a1 + 272);
    __int128 v27 = v4;
    __int128 v5 = *(_OWORD *)(a1 + 320);
    __int128 v28 = *(_OWORD *)(a1 + 304);
    __int128 v29 = v5;
    __int128 v6 = *(_OWORD *)(a1 + 256);
    *(_OWORD *)uint64_t buf = *(_OWORD *)(a1 + 240);
    *(_OWORD *)&uint8_t buf[16] = v6;
    *(_DWORD *)(a1 + 240) = 0xFFFF;
    *(void *)(a1 + 244) = 0LL;
    *(void *)(a1 + 252) = 0LL;
    __asm { FMOV            V1.2D, #-1.0 }

    *(_OWORD *)(a1 + 260) = xmmword_1012E0070;
    *(_OWORD *)(a1 + 276) = _Q1;
    *(_OWORD *)(a1 + 292) = _Q1;
    *(_OWORD *)(a1 + 30_Block_object_dispose((const void *)(v11 - 64), 8) = _Q1;
    *(_DWORD *)(a1 + 324) = 0;
    *(_DWORD *)(a1 + 352) = 0;
    *(void *)(a1 + 32_Block_object_dispose((const void *)(v11 - 64), 8) = 0xBFF0000000000000LL;
    *(void *)(a1 + 336) = 0LL;
    *(void *)(a1 + 344) = 0LL;
    *(void *)(a1 + 356) = 0xBFF0000000000000LL;
    *(_DWORD *)(a1 + 364) = 0x7FFFFFFF;
    *(void *)(a1 + 376) = 0LL;
    *(void *)(a1 + 384) = 0LL;
    *(void *)(a1 + 36_Block_object_dispose((const void *)(v11 - 64), 8) = 0LL;
    *(_BYTE *)(a1 + 392) = 0;
    v25[0] = 0;
    sub_1005DBBDC((id *)a1, v12, v25, (uint64_t)buf);

    unint64_t v13 = v37;
    if (v37)
    {
      p_shared_owners = (unint64_t *)&v37->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }

    if (v36 < 0) {
      operator delete(__p);
    }
    double v16 = v34;
    if (v34)
    {
      uint64_t v17 = (unint64_t *)&v34->__shared_owners_;
      do
        unint64_t v18 = __ldaxr(v17);
      while (__stlxr(v18 - 1, v17));
      if (!v18)
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }

    uint64_t v19 = v33;
    if (v33)
    {
      char v20 = (unint64_t *)&v33->__shared_owners_;
      do
        unint64_t v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    id v22 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#cclp #warning UpdateLastReceivedLocationTimer handler early return. LastReceivedLocation is invalid.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      LOWORD(v25[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#cclp #warning UpdateLastReceivedLocationTimer handler early return. LastReceivedLocation is invalid.",  v25,  2);
      __int16 v24 = (char *)v23;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::onUpdateLastReceivedLocationTimer()",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
    }
  }

void sub_1005D9E7C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005D9EA8(uint64_t a1)
{
  *(void *)(a1 + 160) = 0LL;
  [*(id *)(a1 + 152) invalidate];

  *(void *)(a1 + 152) = 0LL;
  [*(id *)(a1 + 144) invalidate];

  *(void *)(a1 + 144) = 0LL;
  [*(id *)(a1 + 120) invalidate];

  *(void *)(a1 + 120) = 0LL;
}

BOOL sub_1005D9F24(uint64_t a1, int a2, unsigned int *a3, __int128 *a4)
{
  int v19 = a2;
  unint64_t v7 = (_DWORD *)qword_1019A1190;
  if (qword_1019A1190 != qword_1019A1198)
  {
    while (*v7 != *a3)
    {
      if (++v7 == (_DWORD *)qword_1019A1198)
      {
        unint64_t v7 = (_DWORD *)qword_1019A1198;
        break;
      }
    }
  }

  if (v7 == (_DWORD *)qword_1019A1198)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    uint64_t v12 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      unint64_t v13 = sub_10100D9D8(*a3);
      *(_DWORD *)uint64_t buf = 136315138;
      *(void *)&uint8_t buf[4] = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "#cclp registering for un-supported notification: %s",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      uint64_t v15 = qword_101934988;
      double v16 = sub_10100D9D8(*a3);
      int v20 = 136315138;
      unint64_t v21 = v16;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  17LL,  "#cclp registering for un-supported notification: %s",  (const char *)&v20);
      unint64_t v18 = (char *)v17;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLCorrectiveCompensatedLocationProvider::registerForNotification(int, const CLLocationProvider_Type ::Notification &, const CLLocationProvider_Type::RegInfo &)",  "%s\n",  v17);
      if (v18 != buf) {
        free(v18);
      }
    }

    return 0LL;
  }

  else
  {
    BOOL v8 = sub_10023FEB8(a1, a2, (int *)a3, a4);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    uint64_t v9 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t buf = &v19;
      id v10 = objc_msgSend( sub_10023311C((uint64_t **)(a1 + 80), &v19, (uint64_t)&unk_1012CF090, (_DWORD **)buf)[8],  "description");
      char v11 = sub_10100D9D8(*a3);
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      __int16 v23 = 2050;
      uint64_t v24 = a2;
      __int16 v25 = 2114;
      id v26 = v10;
      __int16 v27 = 2082;
      __int128 v28 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#cclp registration, client-id:%{public}ld, client:%{public, location:escape_onl y}@, notification:%{public, location:escape_only}s}",  buf,  0x30u);
    }
  }

  return v8;
}

uint64_t sub_1005DA230(uint64_t a1, unsigned int *a2)
{
  if (v4 == 1.79769313e308)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    unint64_t v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v8 = sub_10100D9D8(*a2);
      int v10 = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      unint64_t v13 = "";
      __int16 v14 = 2082;
      uint64_t v15 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#cclp registering to FLC, notification:%{public, location:escape_only}s}",  (uint8_t *)&v10,  0x1Cu);
    }

    [*(id *)(*(void *)(a1 + 128) + 16) register:*(void *)(*(void *)(a1 + 128) + 8) forNotification:*a2 registrationInfo:0];
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    __int128 v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v6 = sub_10100D9D8(*a2);
      int v10 = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      unint64_t v13 = "";
      __int16 v14 = 2082;
      uint64_t v15 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#cclp skip registering to FLC - timer locked(no need to source location from FLC), no tification:%{public, location:escape_only}s}",  (uint8_t *)&v10,  0x1Cu);
    }
  }

  return 1LL;
}

BOOL sub_1005DA3EC(uint64_t a1, int a2, int *a3)
{
  int v11 = a2;
  BOOL v6 = sub_1002406A8((char *)a1, a2, a3);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842D50);
  }
  unint64_t v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t buf = &v11;
    id v8 = objc_msgSend( sub_10023311C((uint64_t **)(a1 + 80), &v11, (uint64_t)&unk_1012CF090, (_DWORD **)buf)[8],  "description");
    uint64_t v9 = sub_10100D9D8(*a3);
    *(_DWORD *)uint64_t buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v13 = 2082;
    __int16 v14 = "";
    __int16 v15 = 2050;
    uint64_t v16 = a2;
    __int16 v17 = 2114;
    id v18 = v8;
    __int16 v19 = 2082;
    int v20 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#cclp unregistration, client-Id:%{public}ld, client:%{public, location:escape_onl y}@, notification:%{public, location:escape_only}s}",  buf,  0x30u);
  }

  return v6;
}

uint64_t sub_1005DA548(uint64_t a1, unsigned int *a2)
{
  if (v4 == 1.79769313e308)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    unint64_t v7 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      id v8 = sub_10100D9D8(*a2);
      int v10 = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      __int16 v13 = "";
      __int16 v14 = 2082;
      __int16 v15 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#cclp unregistering from FLC, notification:%{public, location:escape_only}s}",  (uint8_t *)&v10,  0x1Cu);
    }

    (*(void (**)(uint64_t, unsigned int *))(*(void *)a1 + 120LL))(a1, a2);
    [*(id *)(*(void *)(a1 + 128) + 16) unregister:*(void *)(*(void *)(a1 + 128) + 8) forNotification:*a2];
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    __int128 v5 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v6 = sub_10100D9D8(*a2);
      int v10 = 68289282;
      int v11 = 0;
      __int16 v12 = 2082;
      __int16 v13 = "";
      __int16 v14 = 2082;
      __int16 v15 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#cclp skip unregistering from FLC - timer locked(will get unsubcribed after receiving sna pped result), notification:%{public, location:escape_only}s}",  (uint8_t *)&v10,  0x1Cu);
    }
  }

  return 1LL;
}

void sub_1005DA714(uint64_t a1, int a2, uint64_t a3)
{
  __int128 v5 = *(id **)(a1 + 40);
  (*(void (**)(__int128 *__return_ptr, uint64_t))(a3 + 16))(&v30, a3);
  if (a2 && sub_100869780((uint64_t)&v30) && *(double *)((char *)&v31 + 4) >= 0.0)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    BOOL v6 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 1040;
      *(_DWORD *)&buf[20] = 156;
      *(_WORD *)&_BYTE buf[24] = 2097;
      *(void *)&buf[26] = &v30;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#cclp perform snapping on location by LC, location:%{private, location:CLClientLocation}.*P}",  buf,  0x22u);
    }

    sub_100246564((uint64_t)buf);
    __int128 v43 = v36;
    __int128 v44 = v37;
    v45[0] = *(_OWORD *)v38;
    *(_OWORD *)((char *)v45 + 12) = *(_OWORD *)&v38[12];
    *(_OWORD *)&_BYTE buf[32] = v32;
    __int128 v40 = v33;
    __int128 v41 = v34;
    __int128 v42 = v35;
    *(_OWORD *)uint64_t buf = v30;
    *(_OWORD *)&uint8_t buf[16] = v31;
    v20[0] = 0;
    sub_1005DAB18(v5, v20, (uint64_t)buf, *(void *)(a1 + 32));

    unint64_t v7 = v50;
    if (v50)
    {
      p_shared_owners = (unint64_t *)&v50->__shared_owners_;
      do
        unint64_t v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }

    if (v49 < 0) {
      operator delete(__p);
    }
    int v10 = v47;
    if (v47)
    {
      int v11 = (unint64_t *)&v47->__shared_owners_;
      do
        unint64_t v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    __int16 v13 = v46;
    if (v46)
    {
      __int16 v14 = (unint64_t *)&v46->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    uint64_t v16 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "#warning #cclp LocationController has no location",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      LOWORD(v20[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#warning #cclp LocationController has no location",  v20,  2);
      __int16 v19 = (char *)v18;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::fetchCorrectiveCompensatedLocation(void (^)(BOOL, CLDaemonLocation))_block_invoke",  "%s\n",  v18);
      if (v19 != buf) {
        free(v19);
      }
    }

    uint64_t v17 = *(void *)(a1 + 32);
    __int128 v27 = v36;
    __int128 v28 = v37;
    v29[0] = *(_OWORD *)v38;
    *(_OWORD *)((char *)v29 + 12) = *(_OWORD *)&v38[12];
    __int128 v23 = v32;
    __int128 v24 = v33;
    __int128 v25 = v34;
    __int128 v26 = v35;
    __int128 v21 = v30;
    __int128 v22 = v31;
    (*(void (**)(void))(v17 + 16))();
  }

void sub_1005DAAEC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DAB18(id *a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842D50);
  }
  id v8 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
  {
    unint64_t v9 = sub_10100D9D8(*a2);
    *(_DWORD *)uint64_t buf = 136315138;
    int v71 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "#cclp try performLocationSnapping - Notification: %s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    uint64_t v47 = qword_101934988;
    uint64_t v48 = sub_10100D9D8(*a2);
    int v68 = 136315138;
    unint64_t v69 = v48;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v47,  1LL,  "#cclp try performLocationSnapping - Notification: %s",  (const char *)&v68);
    int v50 = (uint8_t *)v49;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))",  "%s\n",  v49);
    if (v50 != buf) {
      free(v50);
    }
  }

  int v10 = (_DWORD *)qword_1019A1190;
  if (qword_1019A1190 != qword_1019A1198)
  {
    while (*v10 != *a2)
    {
      if (++v10 == (_DWORD *)qword_1019A1198)
      {
        int v10 = (_DWORD *)qword_1019A1198;
        break;
      }
    }
  }

  if (v10 == (_DWORD *)qword_1019A1198)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    id v18 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      __int16 v19 = sub_10100D9D8(*a2);
      *(_DWORD *)uint64_t buf = 136315138;
      int v71 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "#cclp received location notification for un-supported notification: %s",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      uint64_t v51 = qword_101934988;
      unint64_t v52 = sub_10100D9D8(*a2);
      int v68 = 136315138;
      unint64_t v69 = v52;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v51,  17LL,  "#cclp received location notification for un-supported notification: %s",  (const char *)&v68);
      uint64_t v17 = (uint8_t *)v53;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Notificatio n &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))",  "%s\n",  v53);
      goto LABEL_74;
    }
  }

  else
  {
    [a1[18] nextFireDelay];
    if (v11 == 1.79769313e308)
    {
      [a1[20] nextFireDelay];
      if (v20 == 1.79769313e308)
      {
        if (*a2 == 9)
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_101842D50);
          }
          __int128 v30 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_INFO,  "#cclp skip performLocationSnapping location-unavailable",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_101842D50);
            }
            LOWORD(v6_Block_object_dispose((const void *)(v11 - 64), 8) = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#cclp skip performLocationSnapping location-unavailable",  &v68,  2);
            uint64_t v59 = (uint8_t *)v58;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Notif ication &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))",  "%s\n",  v58);
            if (v59 != buf) {
              free(v59);
            }
          }

          *(_DWORD *)uint64_t buf = 9;
          (*((void (**)(id *, uint8_t *, uint64_t, uint64_t, uint64_t, void))*a1 + 19))( a1,  buf,  a3,  1LL,  0xFFFFFFFFLL,  0LL);
        }

        else if ((sub_100869780(a3) & 1) != 0)
        {
          sub_100246564((uint64_t)&v68);
          *(_DWORD *)uint64_t buf = 0;
          char v31 = (*((uint64_t (**)(id *, uint8_t *, int *))*a1 + 16))(a1, buf, &v68);
          if (*((_BYTE *)a1 + 200))
          {
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_101842D50);
            }
            __int128 v32 = (os_log_s *)qword_101934988;
            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)uint64_t buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_INFO,  "#cclp skip performLocationSnapping already in-progres",  buf,  2u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_101842D50);
              }
              v67[0] = 0;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#cclp skip performLocationSnapping already in-progres",  v67,  2);
              __int128 v34 = (uint8_t *)v33;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Not ification &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))",  "%s\n",  v33);
              if (v34 != buf) {
                free(v34);
              }
            }
          }

          else
          {
            char v37 = v31;
            uint64_t v38 = *(void *)(a3 + 20);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_101842D50);
            }
            __int16 v39 = (os_log_s *)qword_101934988;
            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)uint64_t buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_INFO,  "#cclp dispatching call to CitySnapper",  buf,  2u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_101842D50);
              }
              v67[0] = 0;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#cclp dispatching call to CitySnapper",  v67,  2);
              __int16 v61 = (uint8_t *)v60;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Not ification &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))",  "%s\n",  v60);
              if (v61 != buf) {
                free(v61);
              }
            }

            *((_BYTE *)a1 + 200) = 1;
            id v40 = a1[24];
            __int128 v41 = objc_alloc(&OBJC_CLASS___CLLocation);
            __int128 v42 = *(_OWORD *)(a3 + 112);
            v65[6] = *(_OWORD *)(a3 + 96);
            v65[7] = v42;
            v66[0] = *(_OWORD *)(a3 + 128);
            *(_OWORD *)((char *)v66 + 12) = *(_OWORD *)(a3 + 140);
            __int128 v43 = *(_OWORD *)(a3 + 48);
            v65[2] = *(_OWORD *)(a3 + 32);
            v65[3] = v43;
            __int128 v44 = *(_OWORD *)(a3 + 80);
            v65[4] = *(_OWORD *)(a3 + 64);
            v65[5] = v44;
            __int128 v45 = *(_OWORD *)(a3 + 16);
            v65[0] = *(_OWORD *)a3;
            v65[1] = v45;
            int v46 = -[CLLocation initWithClientLocation:](v41, "initWithClientLocation:", v65);
            v62[0] = _NSConcreteStackBlock;
            v62[1] = 3321888768LL;
            v62[2] = sub_1005DC0F8;
            v62[3] = &unk_101842CA8;
            v62[5] = a1;
            sub_100246C40((uint64_t)v63, (uint64_t)&v68);
            char v64 = v37;
            v63[191] = v38;
            v62[4] = a4;
            [v40 snapLocation:v46 withReply:v62];
            sub_100243768((uint64_t)v63);
          }

          sub_100243768((uint64_t)&v68);
        }

        else
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_101842D50);
          }
          __int128 v35 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "#cclp skip snapping #warning invalid location.",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_101842D50);
            }
            LOWORD(v6_Block_object_dispose((const void *)(v11 - 64), 8) = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#cclp skip snapping #warning invalid location.",  &v68,  2);
            uint64_t v17 = (uint8_t *)v36;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Notif ication &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))",  "%s\n",  v36);
            goto LABEL_74;
          }
        }
      }

      else
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101842D50);
        }
        __int128 v21 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
        {
          __int128 v22 = sub_10100D9D8(*a2);
          *(_DWORD *)uint64_t buf = 136315138;
          int v71 = v22;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "#cclp skip notification: %s. UpdateLastReceivedLocationTimer scheduled",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_101842D50);
          }
          uint64_t v54 = qword_101934988;
          __int16 v55 = sub_10100D9D8(*a2);
          int v68 = 136315138;
          unint64_t v69 = v55;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v54,  0LL,  "#cclp skip notification: %s. UpdateLastReceivedLocationTimer scheduled",  (const char *)&v68);
          __int16 v57 = (uint8_t *)v56;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Notific ation &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))",  "%s\n",  v56);
          if (v57 != buf) {
            free(v57);
          }
        }

        if (*a2 != 9)
        {
          __int128 v23 = *(_OWORD *)(a3 + 16);
          *((_OWORD *)a1 + 15) = *(_OWORD *)a3;
          *((_OWORD *)a1 + 16) = v23;
          __int128 v24 = *(_OWORD *)(a3 + 32);
          __int128 v25 = *(_OWORD *)(a3 + 48);
          __int128 v26 = *(_OWORD *)(a3 + 80);
          *((_OWORD *)a1 + sub_100210A00(v2 + 19) = *(_OWORD *)(a3 + 64);
          *((_OWORD *)a1 + 20) = v26;
          *((_OWORD *)a1 + 17) = v24;
          *((_OWORD *)a1 + 1_Block_object_dispose((const void *)(v11 - 64), 8) = v25;
          __int128 v27 = *(_OWORD *)(a3 + 96);
          __int128 v28 = *(_OWORD *)(a3 + 112);
          __int128 v29 = *(_OWORD *)(a3 + 128);
          *(_OWORD *)((char *)a1 + 380) = *(_OWORD *)(a3 + 140);
          *((_OWORD *)a1 + 22) = v28;
          *((_OWORD *)a1 + 23) = v29;
          *((_OWORD *)a1 + 21) = v27;
        }
      }
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      unint64_t v12 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v13 = sub_10100D9D8(*a2);
        *(_DWORD *)uint64_t buf = 136315138;
        int v71 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "#cclp skip notification: %s. CompensationTimer scheduled",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101842D50);
        }
        uint64_t v14 = qword_101934988;
        unint64_t v15 = sub_10100D9D8(*a2);
        int v68 = 136315138;
        unint64_t v69 = v15;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  0LL,  "#cclp skip notification: %s. CompensationTimer scheduled",  (const char *)&v68);
        uint64_t v17 = (uint8_t *)v16;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Notificat ion &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))",  "%s\n",  v16);
LABEL_74:
        if (v17 != buf) {
          free(v17);
        }
      }
    }
  }

void sub_1005DB788(_Unwind_Exception *a1)
{
}

double sub_1005DB7C4(uint64_t a1)
{
  double v1 = *(double *)(a1 + 168);
  if (!*(_BYTE *)(a1 + 204))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    double v11 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "#cclp: Clock Alignment disabled by default settings. Using default CC interval",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      LOWORD(v1_Block_object_dispose((const void *)(v11 - 64), 8) = 0;
      unint64_t v12 = (const char *)((uint64_t (*)(uint64_t, void, uint8_t *, uint64_t, const mach_header_64 *, uint64_t, uint64_t, const char *, ...))_os_log_send_and_compose_impl)( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#cclp: Clock Alignment disabled by default settings. Using default CC interval",  &v18,  2,  v18);
      goto LABEL_42;
    }

    return v1;
  }

  int v3 = *(unsigned __int8 *)(a1 + 201);
  if (v1 == 900.0) {
    goto LABEL_5;
  }
  if (*(_BYTE *)(a1 + 201))
  {
    int v3 = 1;
LABEL_5:
    if (v3) {
      double v4 = 100.0;
    }
    else {
      double v4 = 780.0;
    }
    [*(id *)(a1 + 40) currentLatchedAbsoluteTimestamp];
    int v6 = (int)v5;
    double v7 = *(double *)(a1 + 168);
    int v8 = v6 % (int)v7;
    if (v8 <= (int)(v1 - v4))
    {
      double v13 = v7 - (double)v8;
      if (v4 >= v13) {
        double v1 = v4;
      }
      else {
        double v1 = v13;
      }
    }

    else
    {
      double v9 = 160.0;
      if (!v3) {
        double v9 = 1200.0;
      }
      double v10 = -((double)v8 - v7 * 2.0);
      if (v10 >= v9) {
        double v1 = v9;
      }
      else {
        double v1 = v10;
      }
    }

    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    uint64_t v14 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 134217984;
      double v20 = v1;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "#cclp: next fire delay: %f", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      unint64_t v12 = (const char *)((uint64_t (*)(uint64_t, void, uint8_t *, uint64_t, const mach_header_64 *, uint64_t, void, const char *, ...))_os_log_send_and_compose_impl)( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#cclp: next fire delay: %f");
LABEL_42:
      uint64_t v17 = (uint8_t *)v12;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CFTimeInterval CLCorrectiveCompensatedLocationProvider::computeNextFireDelayToMaximizeAlignment()",  "%s\n",  v12);
      if (v17 != buf) {
        free(v17);
      }
      return v1;
    }

    return v1;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842D50);
  }
  unint64_t v15 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "#cclp: Clock Alignment disabled. Either TestMode should be enabled or CompensationInterval should be 15m. Check #c ompensation #settings",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    LOWORD(v1_Block_object_dispose((const void *)(v11 - 64), 8) = 0;
    unint64_t v12 = (const char *)((uint64_t (*)(uint64_t, void, uint8_t *, uint64_t, const mach_header_64 *, uint64_t, uint64_t, const char *, ...))_os_log_send_and_compose_impl)( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#cclp: Clock Alignment disabled. Either TestMode should be enabled or CompensationInterval sho uld be 15m. Check #compensation #settings",  &v18,  2,  v18);
    goto LABEL_42;
  }

  return v1;
}

void sub_1005DBBDC(id *a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842D50);
  }
  double v7 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = sub_10100D9D8(*a3);
    v9[0] = 68289795;
    v9[1] = 0;
    __int16 v10 = 2082;
    double v11 = "";
    __int16 v12 = 2082;
    double v13 = v8;
    __int16 v14 = 1040;
    int v15 = 156;
    __int16 v16 = 2097;
    uint64_t v17 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#cclp onLocationNotification, Notification:%{public, location:escape_only}s, locati on:%{private, location:CLClientLocation}.*P}",  (uint8_t *)v9,  0x2Cu);
  }

  sub_1005DAB18(a1, a3, a4, 0LL);
}

void sub_1005DBD04(uint64_t a1, int *a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  if (v12 != 1.79769313e308) {
    sub_101240764();
  }
  sub_10047B624((char *)a1, a2, a3, a4, a5, a6);
}

void sub_1005DBD78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842D50);
  }
  int v6 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
  {
    if (*(_BYTE *)(a4 + 824)) {
      double v7 = "enabled";
    }
    else {
      double v7 = "disabled";
    }
    *(_DWORD *)uint64_t buf = 136315138;
    __int128 v18 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "#cclp Simulation %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    if (*(_BYTE *)(a4 + 824)) {
      double v12 = "enabled";
    }
    else {
      double v12 = "disabled";
    }
    int v15 = 136315138;
    __int16 v16 = v12;
    double v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "#cclp Simulation %s",  (const char *)&v15);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::onSimulationNotification(int, const CLLocationProvider_Type::Notific ation &, const CLLocationProvider_Type::NotificationData &)",  "%s\n",  v13);
  }

  [*(id *)(a1 + 144) nextFireDelay];
  if (v8 == 1.79769313e308 && !*(_BYTE *)(a1 + 203))
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    double v11 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "#cclp CompensationTimer not scheduled and not subscribed to FLC",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      LOWORD(v15) = 0;
      __int16 v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "#cclp CompensationTimer not scheduled and not subscribed to FLC",  &v15,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::onSimulationNotification(int, const CLLocationProvider_Type::Notif ication &, const CLLocationProvider_Type::NotificationData &)",  "%s\n",  v14);
    }
  }

  else
  {
    double v9 = 3.0;
    if (!*(_BYTE *)(a4 + 824)) {
      double v9 = 4.0;
    }
    [*(id *)(a1 + 160) setNextFireDelay:v9];
    [*(id *)(a1 + 144) nextFireDelay];
    if (v10 != 1.79769313e308)
    {
      *(_BYTE *)(a1 + 202) = *(_BYTE *)(a4 + 824);
      [*(id *)(a1 + 144) setNextFireDelay:0.0];
    }
  }

void sub_1005DC0F8(uint64_t a1, void *a2, int a3, void *a4)
{
  uint64_t v7 = *(void *)(a1 + 40);
  if (a2)
  {
    [a2 clientLocation];
  }

  else
  {
    memset(v67, 0, 28);
    __int128 v66 = 0u;
    __int128 v65 = 0u;
    __int128 v64 = 0u;
    __int128 v63 = 0u;
    __int128 v62 = 0u;
    memset(buf, 0, sizeof(buf));
  }

  __int128 v56 = v65;
  __int128 v57 = v66;
  v58[0] = v67[0];
  *(_OWORD *)((char *)v58 + 12) = *(_OWORD *)((char *)v67 + 12);
  __int128 v53 = *(_OWORD *)&buf[32];
  __int128 v54 = v62;
  *(_OWORD *)__int16 v55 = v63;
  *(_OWORD *)&v55[16] = v64;
  __int128 v51 = *(_OWORD *)buf;
  __int128 v52 = *(_OWORD *)&buf[16];
  *(_BYTE *)(v7 + 200) = 0;
  [*(id *)(v7 + 40) currentLatchedAbsoluteTimestamp];
  double v9 = v8;
  double v10 = *(double *)(a1 + 124);
  double v11 = *(double *)(v7 + 168);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_101842D50);
  }
  double v12 = vabdd_f64(v9, v10);
  double v13 = v11 * 1.33333333;
  __int16 v14 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = *(unsigned __int8 *)(a1 + 1584);
    *(_DWORD *)uint64_t buf = 68290563;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 1026;
    *(_DWORD *)&buf[20] = a3;
    *(_WORD *)&_BYTE buf[24] = 2050;
    *(double *)&buf[26] = v12;
    *(_WORD *)&buf[34] = 1026;
    *(_DWORD *)&buf[36] = v12 < v13;
    *(_WORD *)&uint8_t buf[40] = 1026;
    *(_DWORD *)&buf[42] = v15;
    *(_WORD *)&buf[46] = 1040;
    LODWORD(v62) = 156;
    WORD2(v62) = 2097;
    *(void *)((char *)&v62 + 6) = &v51;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#cclp snapLocation reply, permanent:%{public}hhd, cacheAge:%{public}f, cach eAgeLessThanExtendedInterval:%{public}hhd, hasCachedLocation:%{public}hhd, location:%{private, location: CLClientLocation}.*P}",  buf,  0x3Eu);
  }

  if ((a3 & 1) != 0 || !*(_BYTE *)(a1 + 1584) || v12 >= v13)
  {
    LODWORD(v56) = 12;
    *(double *)&v55[24] = vabdd_f64(v9, *(double *)&v55[12]) + *(double *)(v7 + 168) * 1.33333333;
    if (*(_BYTE *)(v7 + 184)) {
      *(void *)((char *)&v52 + 4) = *(void *)(a1 + 1576);
    }
    sub_100246564((uint64_t)v43);
    v43[6] = v56;
    v43[7] = v57;
    v44[0] = v58[0];
    *(_OWORD *)((char *)v44 + 12) = *(_OWORD *)((char *)v58 + 12);
    v43[2] = v53;
    v43[3] = v54;
    uint8_t v43[4] = *(_OWORD *)v55;
    v43[5] = *(_OWORD *)&v55[16];
    v43[0] = v51;
    v43[1] = v52;
    if (a4)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      __int16 v16 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "#cclp Encoded coarse meta data available",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101842D50);
        }
        LOWORD(v59) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  2LL,  "#cclp Encoded coarse meta data available",  &v59,  2);
        __int16 v39 = (uint8_t *)v38;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Notificat ion &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))_block_invoke",  "%s\n",  v38);
        if (v39 != buf) {
          free(v39);
        }
      }

      sub_1005DCA84(&v50, a4);
    }

    if (*(void *)(a1 + 32))
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      uint64_t v17 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "#cclp delivering compensated location to reply block",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101842D50);
        }
        LOWORD(v59) = 0;
        LODWORD(v42) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#cclp delivering compensated location to reply block",  &v59,  v42);
        __int128 v41 = (uint8_t *)v40;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Notificat ion &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))_block_invoke",  "%s\n",  v40);
        if (v41 != buf) {
          free(v41);
        }
      }

      (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    }

    *(_DWORD *)uint64_t buf = 0;
    (*(void (**)(uint64_t, uint8_t *, _OWORD *, uint64_t, uint64_t, void))(*(void *)v7 + 152LL))( v7,  buf,  v43,  1LL,  0xFFFFFFFFLL,  0LL);
    [*(id *)(v7 + 152) setNextFireDelay:*(double *)(v7 + 176)];
    __int128 v18 = (unsigned int *)qword_1019A1190;
    uint64_t v19 = qword_1019A1198;
    while (v18 != (unsigned int *)v19)
      [*(id *)(*(void *)(v7 + 128) + 16) unregister:*(void *)(*(void *)(v7 + 128) + 8) forNotification:*v18++];
    *(_BYTE *)(v7 + 203) = 0;
    if (*(_BYTE *)(v7 + 202))
    {
      *(_BYTE *)(v7 + 202) = 0;
      double v20 = (float)((float)rand() * 4.6566e-10);
      double v21 = *(double *)(v7 + 168);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      double v22 = v20 * v21 + 1.0;
      __int128 v23 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 134217984;
        *(double *)&uint8_t buf[4] = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#cclp Simulation started. Random next fire delay: %f",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_101842D50);
        }
        int v59 = 134217984;
        double v60 = v22;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  0LL,  "#cclp Simulation started. Random next fire delay: %f",  COERCE_DOUBLE(&v59));
        __int128 v25 = (uint8_t *)v24;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Notificat ion &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))_block_invoke",  "%s\n",  v24);
        if (v25 != buf) {
          free(v25);
        }
      }
    }

    else
    {
      double v22 = sub_1005DB7C4(v7);
    }

    [*(id *)(v7 + 144) setNextFireDelay:v22];

    __int128 v29 = v49;
    if (v49)
    {
      p_shared_owners = (unint64_t *)&v49->__shared_owners_;
      do
        unint64_t v31 = __ldaxr(p_shared_owners);
      while (__stlxr(v31 - 1, p_shared_owners));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }

    if (v48 < 0) {
      operator delete(__p);
    }
    __int128 v32 = v46;
    if (v46)
    {
      __int128 v33 = (unint64_t *)&v46->__shared_owners_;
      do
        unint64_t v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }

    __int128 v35 = v45;
    if (v45)
    {
      __int128 v36 = (unint64_t *)&v45->__shared_owners_;
      do
        unint64_t v37 = __ldaxr(v36);
      while (__stlxr(v37 - 1, v36));
      if (!v37)
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_101842D50);
    }
    __int128 v26 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_INFO,  "#cclp snapLocation expecting a improved location",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_101842D50);
      }
      LOWORD(v43[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  1LL,  "#cclp snapLocation expecting a improved location",  v43,  2);
      __int128 v28 = (uint8_t *)v27;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCorrectiveCompensatedLocationProvider::performLocationSnapping(const CLLocationProvider_Type::Notificatio n &, const CLLocationProvider_Type::NotificationData &, void (^)(BOOL, CLDaemonLocation))_block_invoke",  "%s\n",  v27);
      if (v28 != buf) {
        free(v28);
      }
    }
  }

void sub_1005DCA3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_1005DCA84(void **a1, void *a2)
{
  id v3 = a2;
  double v4 = *a1;
  *a1 = v3;
}

void sub_1005DCAB4(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1005DCAC4(uint64_t a1, uint64_t a2)
{
  return sub_100246C40(a1 + 48, a2 + 48);
}

uint64_t sub_1005DCAD0(uint64_t a1)
{
  return sub_10000AE14(a1 + 728);
}

void sub_1005DCB1C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  double v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLCorrectiveCompensatedLocationProvider");
  sub_10047D890((uint64_t)v8, (uint64_t *)__p, a3, a1, a2);
  *double v8 = &off_101842CE8;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005DCBB4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1005DCBE0(void *a1)
{
  *a1 = off_101842B40;
  sub_100527AF4((uint64_t)(a1 + 26));
  uint64_t v2 = a1[17];
  a1[17] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = a1[16];
  a1[16] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return sub_10047A1C0(a1);
}

void sub_1005DCC40(void *a1)
{
  *a1 = off_101842B40;
  sub_100527AF4((uint64_t)(a1 + 26));
  uint64_t v2 = a1[17];
  a1[17] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = a1[16];
  a1[16] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  double v4 = (void *)sub_10047A1C0(a1);
  operator delete(v4);
}

void sub_1005DCCA4(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_1005DCCD0(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

__n128 sub_1005DCCFC@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2 = *(_OWORD *)(a1 + 144);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(a1 + 128);
  *(_OWORD *)(a2 + sub_10004AD90(v15 - 112) = v2;
  *(_OWORD *)(a2 + 12_Block_object_dispose((const void *)(v11 - 64), 8) = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(a2 + 140) = *(_OWORD *)(a1 + 172);
  __int128 v3 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v11 - 64), 8) = v3;
  __int128 v4 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(a2 + 80) = v4;
  __n128 result = *(__n128 *)(a1 + 32);
  __int128 v6 = *(_OWORD *)(a1 + 48);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v6;
  return result;
}

uint64_t sub_1005DCD30()
{
  qword_1019A1190 = 0LL;
  qword_1019A1198 = 0LL;
  qword_1019A11A0 = 0LL;
  unsigned __int8 v0 = operator new(0x20uLL);
  qword_1019A1198 = (uint64_t)(v0 + 2);
  qword_1019A11A0 = (uint64_t)(v0 + 2);
  *unsigned __int8 v0 = xmmword_10130AE70;
  v0[1] = unk_10130AE80;
  qword_1019A1190 = (uint64_t)v0;
  return __cxa_atexit((void (*)(void *))sub_1005D8288, &qword_1019A1190, (void *)&_mh_execute_header);
}

void sub_1005DCDDC(id a1)
{
  BOOL v1 = 1;
  if ((sub_1001B9A1C() & 1) == 0)
  {
    sub_1004F2598();
    if ((sub_1004F7858() & 1) == 0)
    {
      sub_1004F2598();
      if ((sub_1004F64FC() & 2) != 0) {
        BOOL v1 = 0;
      }
    }
  }

  byte_101997340 = v1;
}

void sub_1005DCEC8(id a1)
{
  qword_101997350 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLCachedLocationControllerSilo");
}

uint64_t sub_1005DCF84(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1005DD280;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_101997360 != -1) {
    dispatch_once(&qword_101997360, block);
  }
  return qword_1019A11B0;
}

void sub_1005DD0E4(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  double v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLCachedLocationController");
  sub_1005DD1AC((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  *double v8 = &off_101842DC0;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1005DD180( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1005DD1AC(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = off_101843028;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 64), 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  else {
    double v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

uint64_t sub_1005DD280(uint64_t a1)
{
  __int128 v2 = operator new(0x320uLL);
  uint64_t result = sub_1005DD2CC((uint64_t)v2, *(void **)(a1 + 32));
  qword_1019A11B0 = (uint64_t)v2;
  return result;
}

void sub_1005DD2B8(_Unwind_Exception *a1)
{
}

uint64_t sub_1005DD2CC(uint64_t a1, void *a2)
{
  *(void *)a1 = off_101842FD0;
  sub_1005DD7A4(a1 + 8, "CachedLocationController", a2);
  *(void *)a1 = off_101842DE8;
  *(void *)(a1 + _Block_object_dispose((const void *)(v11 - 64), 8) = off_101842E40;
  sub_100AEB404(a1 + 120, "Traffic", *(void *)(a1 + 40));
  uint64_t v4 = a1 + 312;
  *(void *)(a1 + 320) = 0LL;
  *(void *)(a1 + 32_Block_object_dispose((const void *)(v11 - 64), 8) = 0LL;
  *(void *)(a1 + 312) = 0LL;
  *(void *)(a1 + 344) = 0LL;
  *(void *)(a1 + 352) = 0x4072C00000000000LL;
  *(_DWORD *)(a1 + 360) = 0;
  sub_1007875EC(a1 + 368, *(void *)(a1 + 40));
  sub_100FF9DDC((void *)(a1 + 552), *(void *)(a1 + 40));
  sub_100C060A4(a1 + 568, a1 + 552);
  *(void *)(a1 + 792) =  objc_msgSend( objc_msgSend(*(id *)(a1 + 40), "vendor"),  "proxyForService:",  @"CLClientAuthorizationCache");
  id v5 = [*(id *)(a1 + 48) newTimer];
  *(void *)(a1 + 336) = v5;
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472LL;
  _DWORD v21[2] = sub_1005DD840;
  _DWORD v21[3] = &unk_10181D3D0;
  v21[4] = a1;
  [v5 setHandler:v21];
  id v6 = -[CLRouteListener initInUniverse:withDelegate:]( objc_alloc(&OBJC_CLASS___CLRouteListener),  "initInUniverse:withDelegate:",  a2,  a1);
  *(void *)(a1 + 544) = v6;
  [v6 enable];
  sub_100583844((uint64_t)sub_1005DD9EC, a1, *(void **)(a1 + 40), buf);
  uint64_t v7 = *(void *)buf;
  *(void *)uint64_t buf = 0LL;
  uint64_t v8 = *(void *)(a1 + 320);
  *(void *)(a1 + 320) = v7;
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    uint64_t v9 = *(void *)buf;
    *(void *)uint64_t buf = 0LL;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    }
  }

  [*(id *)(*(void *)(a1 + 320) + 16) register:*(void *)(*(void *)(a1 + 320) + 8) forNotification:4 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 320) + 16) register:*(void *)(*(void *)(a1 + 320) + 8) forNotification:2 registrationInfo:0];
  sub_100D96A2C((uint64_t)sub_1005DDBC4, a1, *(void **)(a1 + 40), buf);
  uint64_t v10 = *(void *)buf;
  *(void *)uint64_t buf = 0LL;
  uint64_t v11 = *(void *)(a1 + 328);
  *(void *)(a1 + 32_Block_object_dispose((const void *)(v11 - 64), 8) = v10;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    uint64_t v12 = *(void *)buf;
    *(void *)uint64_t buf = 0LL;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
  }

  [*(id *)(*(void *)(a1 + 328) + 16) register:*(void *)(*(void *)(a1 + 328) + 8) forNotification:1 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 328) + 16) register:*(void *)(*(void *)(a1 + 328) + 8) forNotification:4 registrationInfo:0];
  sub_100AEB408(a1 + 120, (uint64_t)sub_1005DDD9C, a1, *(void **)(a1 + 40), buf);
  uint64_t v13 = *(void *)buf;
  *(void *)uint64_t buf = 0LL;
  uint64_t v14 = *(void *)v4;
  *(void *)uint64_t v4 = v13;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
    uint64_t v15 = *(void *)buf;
    *(void *)uint64_t buf = 0LL;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
  }

  [*(id *)(*(void *)v4 + 16) register:*(void *)(*(void *)v4 + 8) forNotification:14 registrationInfo:0];
  [*(id *)(*(void *)v4 + 16) register:*(void *)(*(void *)v4 + 8) forNotification:4 registrationInfo:0];
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101842FF8);
  }
  __int16 v16 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "CLC: Init power state: off", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101842FF8);
    }
    __int16 v20 = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "CLC: Init power state: off",  &v20,  2);
    uint64_t v19 = (uint8_t *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLCachedLocationController::CLCachedLocationController(id<CLIntersiloUniverse>)",  "%s\n",  v18);
    if (v19 != buf) {
      free(v19);
    }
  }

  return a1;
}

void sub_1005DD6F8(_Unwind_Exception *a1)
{
  uint64_t v7 = *(void *)(v2 + 328);
  *(void *)(v2 + 32_Block_object_dispose((const void *)(v11 - 64), 8) = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  uint64_t v8 = *(void *)(v2 + 320);
  *(void *)(v2 + 320) = 0LL;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  uint64_t v9 = *v5;
  uint64_t *v5 = 0LL;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
  }
  sub_1008AF1C4(v3);
  sub_1005DDF74(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1005DD7A4(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_101843050;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = [a3 silo];
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v11 - 64), 8) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 8_Block_object_dispose((const void *)(v11 - 64), 8) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 10_Block_object_dispose((const void *)(v11 - 64), 8) = 0;
  return a1;
}

void sub_1005DD824(_Unwind_Exception *exception_object)
{
}

void sub_1005DD840(uint64_t a1)
{
}

void sub_1005DD848(uint64_t a1)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101842FF8);
  }
  uint64_t v2 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "CLC: Debounce timer fired, stopping", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101842FF8);
    }
    v5[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  1LL,  "CLC: Debounce timer fired, stopping",  v5,  2);
    uint64_t v4 = (uint8_t *)v3;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCachedLocationController::onTransitDebounceTimer()", "%s\n", v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  sub_1005DE18C(a1, 0LL, 1.79769313e308);
}

void sub_1005DD9EC(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101842FA0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLCachedLocationController::onClientManagerNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842FA0);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLCachedLocationController::onClientManagerNotification, event:%{public, location:e scape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_1005DFB70(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005DDBA4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DDBC4(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101842FA0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLCachedLocationController::onAppMonitorNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842FA0);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLCachedLocationController::onAppMonitorNotification, event:%{public, location:esca pe_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_1005DF06C(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005DDD7C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DDD9C(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101842FA0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLCachedLocationController::onLocationUpdateNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101842FA0);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLCachedLocationController::onLocationUpdateNotification, event:%{public, location: escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_1005DEE74(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1005DDF54( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1005DDF74(uint64_t a1)
{
  *(void *)a1 = off_101843050;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

void *sub_1005DDFE8(void *a1)
{
  *a1 = off_101842DE8;
  a1[1] = off_101842E40;
  uint64_t v2 = (uint64_t)(a1 + 1);
  sub_1005DE0C0((uint64_t)a1);
  sub_100787644(a1 + 46);
  uint64_t v3 = a1[41];
  a1[41] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = a1[40];
  a1[40] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = a1[39];
  a1[39] = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  sub_1008AF1C4((uint64_t)(a1 + 15));
  sub_1005DDF74(v2);
  return a1;
}

void *sub_1005DE08C(uint64_t a1)
{
  return sub_1005DDFE8((void *)(a1 - 8));
}

void sub_1005DE094(void *a1)
{
  uint64_t v1 = sub_1005DDFE8(a1);
  operator delete(v1);
}

void sub_1005DE0A8(uint64_t a1)
{
  uint64_t v1 = sub_1005DDFE8((void *)(a1 - 8));
  operator delete(v1);
}

void sub_1005DE0C0(uint64_t a1)
{
  *(void *)(a1 + 336) = 0LL;
  *(void *)(a1 + 352) = 0x4072C00000000000LL;
  [*(id *)(*(void *)(a1 + 312) + 16) unregister:*(void *)(*(void *)(a1 + 312) + 8) forNotification:4];
  [*(id *)(*(void *)(a1 + 312) + 16) unregister:*(void *)(*(void *)(a1 + 312) + 8) forNotification:14];
  [*(id *)(*(void *)(a1 + 320) + 16) unregister:*(void *)(*(void *)(a1 + 320) + 8) forNotification:4];
  [*(id *)(*(void *)(a1 + 320) + 16) unregister:*(void *)(*(void *)(a1 + 320) + 8) forNotification:2];
  [*(id *)(*(void *)(a1 + 328) + 16) unregister:*(void *)(*(void *)(a1 + 328) + 8) forNotification:4];
  [*(id *)(*(void *)(a1 + 328) + 16) unregister:*(void *)(*(void *)(a1 + 328) + 8) forNotification:1];
  [*(id *)(a1 + 544) disable];

  *(void *)(a1 + 544) = 0LL;
  *(void *)(a1 + 792) = 0LL;
}

void sub_1005DE18C(uint64_t a1, uint64_t a2, double a3)
{
  int v6 = *(_DWORD *)(a1 + 344);
  double v7 = *(double *)(a1 + 352);
  *(double *)(a1 + 352) = a3;
  if (v7 != a3)
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101842FF8);
    }
    uint64_t v8 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      double v9 = -1.0;
      if (a3 != 1.79769313e308) {
        double v9 = a3;
      }
      *(_DWORD *)uint64_t buf = 134283521;
      *(double *)&uint8_t buf[4] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "CLC: Debounce changed to %{private}lf [s]",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101842FF8);
      }
      double v32 = -1.0;
      if (a3 != 1.79769313e308) {
        double v32 = a3;
      }
      *(_DWORD *)__int128 v53 = 134283521;
      *(double *)&v53[4] = v32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "CLC: Debounce changed to %{private}lf [s]",  v53,  12);
      unint64_t v34 = (uint8_t *)v33;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCachedLocationController::setStateAndUpdateDebounceTimout(CLCachedLocationController_Type::CachedLocation State, CFTimeInterval)",  "%s\n",  v33);
      if (v34 != buf) {
        free(v34);
      }
    }

    if ((_DWORD)a2 == 1) {
      [*(id *)(a1 + 336) setNextFireDelay:*(double *)(a1 + 352)];
    }
  }

  if (v6 == (_DWORD)a2)
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101842FF8);
    }
    uint64_t v10 = (os_log_s *)qword_101934838;
    BOOL v11 = os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG);
    if (v11)
    {
      sub_1005DE9B0(v11, *(unsigned int *)(a1 + 344), buf);
      if (v59 >= 0) {
        uint64_t v12 = buf;
      }
      else {
        uint64_t v12 = *(uint8_t **)buf;
      }
      double v13 = *(double *)(a1 + 352);
      if (v13 == 1.79769313e308) {
        double v13 = -1.0;
      }
      *(_DWORD *)__int128 v53 = 136380931;
      *(void *)&v53[4] = v12;
      __int16 v54 = 2049;
      double v55 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "CLC: Already in state %{private}s, %{private}lf",  v53,  0x16u);
      if (SHIBYTE(v59) < 0) {
        operator delete(*(void **)buf);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101842FF8);
      }
      uint64_t v15 = qword_101934838;
      sub_1005DE9B0(v14, *(unsigned int *)(a1 + 344), v53);
      if (v56 >= 0) {
        __int16 v16 = v53;
      }
      else {
        __int16 v16 = *(_BYTE **)v53;
      }
      double v17 = *(double *)(a1 + 352);
      if (v17 == 1.79769313e308) {
        double v17 = -1.0;
      }
      *(_DWORD *)__int128 v45 = 136380931;
      *(void *)&v45[4] = v16;
      __int16 v46 = 2049;
      double v47 = v17;
      LODWORD(v44) = 22;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  2LL,  "CLC: Already in state %{private}s, %{private}lf",  v45,  v44);
      uint64_t v19 = v18;
      if (v56 < 0) {
        operator delete(*(void **)v53);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCachedLocationController::setStateAndUpdateDebounceTimout(CLCachedLocationController_Type::CachedLocation State, CFTimeInterval)",  "%s\n",  v19);
    }
  }

  else
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101842FF8);
    }
    __int16 v20 = (os_log_s *)qword_101934838;
    BOOL v21 = os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG);
    if (v21)
    {
      double v22 = sub_1005DE9B0(v21, *(unsigned int *)(a1 + 344), buf);
      int v23 = SHIBYTE(v59);
      __int128 v24 = *(uint8_t **)buf;
      sub_1005DE9B0((uint64_t)v22, a2, v53);
      __int128 v25 = buf;
      if (v23 < 0) {
        __int128 v25 = v24;
      }
      if (v56 >= 0) {
        __int128 v26 = v53;
      }
      else {
        __int128 v26 = *(_BYTE **)v53;
      }
      *(_DWORD *)__int128 v45 = 136380931;
      *(void *)&v45[4] = v25;
      __int16 v46 = 2081;
      double v47 = *(double *)&v26;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "CLC: Cached Location changed state from %{private}s to %{private}s",  v45,  0x16u);
      if (v56 < 0) {
        operator delete(*(void **)v53);
      }
      if (SHIBYTE(v59) < 0) {
        operator delete(*(void **)buf);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101842FF8);
      }
      uint64_t v36 = qword_101934838;
      unint64_t v37 = sub_1005DE9B0(v35, *(unsigned int *)(a1 + 344), v53);
      int v38 = v56;
      __int16 v39 = *(_BYTE **)v53;
      sub_1005DE9B0((uint64_t)v37, a2, v45);
      id v40 = v53;
      if (v38 < 0) {
        id v40 = v39;
      }
      if (v48 >= 0) {
        __int128 v41 = v45;
      }
      else {
        __int128 v41 = *(_BYTE **)v45;
      }
      int v49 = 136380931;
      int v50 = v40;
      __int16 v51 = 2081;
      __int128 v52 = v41;
      LODWORD(v44) = 22;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v36,  2LL,  "CLC: Cached Location changed state from %{private}s to %{private}s",  &v49,  v44);
      __int128 v43 = v42;
      if (v48 < 0) {
        operator delete(*(void **)v45);
      }
      if (v56 < 0) {
        operator delete(*(void **)v53);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCachedLocationController::setStateAndUpdateDebounceTimout(CLCachedLocationController_Type::CachedLocation State, CFTimeInterval)",  "%s\n",  v43);
    }

    *(_DWORD *)(a1 + 344) = a2;
    if ((_DWORD)a2 == 1)
    {
      sub_100787648((int *)(a1 + 368), 1);
      __asm { FMOV            V0.2D, #-1.0 }

      *(_OWORD *)uint64_t buf = _Q0;
      int v59 = 0;
      int v60 = 0;
      __int16 v58 = 0;
      [*(id *)(*(void *)(a1 + 312) + 16) register:*(void *)(*(void *)(a1 + 312) + 8) forNotification:22 registrationInfo:sub_100419014(buf)];
    }

    else
    {
      [*(id *)(a1 + 336) setNextFireDelay:1.79769313e308];
      [*(id *)(*(void *)(a1 + 312) + 16) unregister:*(void *)(*(void *)(a1 + 312) + 8) forNotification:22];
      sub_100787648((int *)(a1 + 368), 0);
    }

    *(_DWORD *)uint64_t buf = *(_DWORD *)(a1 + 344);
    *(_DWORD *)__int128 v53 = 1;
    (*(void (**)(uint64_t, _BYTE *, uint8_t *, void, uint64_t, void))(*(void *)(a1 + 8) + 152LL))( a1 + 8,  v53,  buf,  0LL,  0xFFFFFFFFLL,  0LL);
  }

void sub_1005DE860( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1005DE898(uint64_t a1)
{
}

void *sub_1005DE8A0@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

void *sub_1005DE918@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

uint64_t sub_1005DE990()
{
  return 1LL;
}

uint64_t sub_1005DE998()
{
  return 1LL;
}

uint64_t sub_1005DE9A0()
{
  return 1LL;
}

uint64_t sub_1005DE9A8()
{
  return 1LL;
}

void *sub_1005DE9B0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (!(_DWORD)a2)
  {
    uint64_t v3 = "Off";
    return sub_1010DDBC0(a3, v3);
  }

  if ((_DWORD)a2 == 1)
  {
    uint64_t v3 = "Active";
    return sub_1010DDBC0(a3, v3);
  }

  uint64_t v5 = sub_101240A58(a1, a2);
  return (void *)sub_1005DE9E4(v5);
}

void sub_1005DE9E4(uint64_t a1, double a2)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101842FF8);
  }
  uint64_t v4 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "CLC: Received start route", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101842FF8);
    }
    LOWORD(v13[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  1LL,  "CLC: Received start route",  v13,  2);
    uint64_t v12 = (uint8_t *)v11;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLCachedLocationController::onStartTransitRoute(CFTimeInterval, const CLClientLocationCoordinate &)",  "%s\n",  v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  double v5 = a2 * 1.5;
  if (a2 * 1.5 < a2 + 600.0) {
    double v5 = a2 + 600.0;
  }
  sub_1005DE18C(a1, 1LL, v5);
  if (*(_DWORD *)(a1 + 348) != 1)
  {
    *(_DWORD *)(a1 + 34_Block_object_dispose((const void *)(v11 - 64), 8) = 1;
    *(_DWORD *)uint64_t buf = 1;
    LODWORD(v13[0]) = 2;
    (*(void (**)(uint64_t, double *, uint8_t *, void, uint64_t, void))(*(void *)(a1 + 8) + 152LL))( a1 + 8,  v13,  buf,  0LL,  0xFFFFFFFFLL,  0LL);
  }

  *(_DWORD *)uint64_t buf = 0xFFFF;
  uint64_t v16 = 0LL;
  uint64_t v15 = 0LL;
  __int128 v17 = xmmword_1012E0070;
  __asm { FMOV            V0.2D, #-1.0 }

  __int128 v18 = _Q0;
  __int128 v19 = _Q0;
  __int128 v20 = _Q0;
  int v21 = 0;
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  unint64_t v22 = 0xBFF0000000000000LL;
  int v25 = 0;
  unint64_t v26 = 0xBFF0000000000000LL;
  int v27 = 0x7FFFFFFF;
  uint64_t v29 = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v28 = 0LL;
  char v31 = 0;
  v13[0] = CFAbsoluteTimeGetCurrent();
  sub_100C06928((void *)(a1 + 568), (uint64_t)buf, v13);
}

void sub_1005DEC60(uint64_t a1)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101842FF8);
  }
  uint64_t v2 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "CLC: Received end route", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101842FF8);
    }
    LOWORD(v5[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  1LL,  "CLC: Received end route",  v5,  2);
    uint64_t v4 = (uint8_t *)v3;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLCachedLocationController::onEndTransitRoute()", "%s\n", v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  sub_1005DE18C(a1, 0LL, 1.79769313e308);
  if (*(_DWORD *)(a1 + 348))
  {
    *(_DWORD *)(a1 + 34_Block_object_dispose((const void *)(v11 - 64), 8) = 0;
    *(_DWORD *)uint64_t buf = 0;
    v5[0] = 2;
    (*(void (**)(uint64_t, _DWORD *, uint8_t *, void, uint64_t, void))(*(void *)(a1 + 8) + 152LL))( a1 + 8,  v5,  buf,  0LL,  0xFFFFFFFFLL,  0LL);
  }

id sub_1005DEE40(uint64_t a1, uint64_t a2)
{
  return _objc_msgSend( objc_msgSend( objc_msgSend(*(id *)(a1 + 40), "vendor"),  "proxyForService:",  @"CLAccessoryLocationProvider"),  "syncSetNavigationStateChange:",  a2);
}

void sub_1005DEE74(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  int v5 = *a3;
  if (*a3 > 13)
  {
    if (v5 == 14 || v5 == 22) {
      return;
    }
  }

  else
  {
    if (v5) {
      BOOL v6 = v5 == 4;
    }
    else {
      BOOL v6 = 1;
    }
    if (v6)
    {
      uint64_t v8 = (void *)(a1 + 568);
      *(void *)uint64_t buf = CFAbsoluteTimeGetCurrent();
      sub_100C060A8(v8, a4, (double *)buf);
      return;
    }
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101842FF8);
  }
  uint64_t v10 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v11 = *a3;
    *(_DWORD *)uint64_t buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "CLC: Received unknown notification, %{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101842FF8);
    }
    int v12 = *a3;
    v15[0] = 67240192;
    v15[1] = v12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "CLC: Received unknown notification, %{public}d",  v15,  8);
    uint64_t v14 = (uint8_t *)v13;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCachedLocationController::onLocationUpdateNotification(int, const CLLocationProvider_Type::Notification &, const CLLocationProvider_Type::NotificationData &)",  "%s\n",  v13);
    if (v14 != buf) {
      free(v14);
    }
  }

void sub_1005DF06C(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  if (*a3 == 4)
  {
    if (!std::string::compare((const std::string *)(a4 + 8), "com.apple.Maps"))
    {
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101842FF8);
      }
      BOOL v6 = (os_log_s *)qword_101934838;
      if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint64_t buf = 136380675;
        __int128 v20 = "com.apple.Maps";
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "CLC: Received kNotificationForegroundRunning for %{private}s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934830 != -1) {
          dispatch_once(&qword_101934830, &stru_101842FF8);
        }
        int v17 = 136380675;
        __int128 v18 = "com.apple.Maps";
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "CLC: Received kNotificationForegroundRunning for %{private}s",  &v17,  12);
        uint64_t v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCachedLocationController::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CLAppMonitor_Type::NotificationData &)",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      sub_1005DF84C(a1, 4);
    }
  }

  else if (*a3 == 1)
  {
    if (!std::string::compare((const std::string *)(a4 + 8), "com.apple.Maps"))
    {
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101842FF8);
      }
      int v5 = (os_log_s *)qword_101934838;
      if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint64_t buf = 136380675;
        __int128 v20 = "com.apple.Maps";
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "CLC: Received kNotificationTerminated for %{private}s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934830 != -1) {
          dispatch_once(&qword_101934830, &stru_101842FF8);
        }
        int v17 = 136380675;
        __int128 v18 = "com.apple.Maps";
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "CLC: Received kNotificationTerminated for %{private}s",  &v17,  12);
        uint64_t v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCachedLocationController::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CLAppMonitor_Type::NotificationData &)",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }

      sub_1005DF514(a1, 4);
    }
  }

  else
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101842FF8);
    }
    uint64_t v8 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      int v9 = *a3;
      *(_DWORD *)uint64_t buf = 67240192;
      LODWORD(v20) = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "CLC: Received unknown notification %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101842FF8);
      }
      int v10 = *a3;
      int v17 = 67240192;
      LODWORD(v1_Block_object_dispose((const void *)(v11 - 64), 8) = v10;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "CLC: Received unknown notification %{public}d",  &v17,  8);
      int v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCachedLocationController::onAppMonitorNotification(int, const CLAppMonitor_Type::Notification &, const CL AppMonitor_Type::NotificationData &)",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }
  }

void sub_1005DF514(uint64_t a1, int a2)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101842FF8);
  }
  uint64_t v4 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *(_DWORD *)(a1 + 360);
    *(_DWORD *)uint64_t buf = 67240448;
    int v18 = a2;
    __int16 v19 = 1026;
    int v20 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "CLC: Suspend for exception, %{public}#x, oldExceptions %{public}#x",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101842FF8);
    }
    int v8 = *(_DWORD *)(a1 + 360);
    v14[0] = 67240448;
    v14[1] = a2;
    __int16 v15 = 1026;
    int v16 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "CLC: Suspend for exception, %{public}#x, oldExceptions %{public}#x",  v14,  14);
    int v10 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCachedLocationController::suspendForException(CLCachedLocationController::CacheException)",  "%s\n",  v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  int v6 = *(_DWORD *)(a1 + 360);
  if (v6)
  {
    *(_DWORD *)(a1 + 360) = v6 | a2;
  }

  else
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101842FF8);
    }
    double v7 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "CLC: Suspend", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101842FF8);
      }
      LOWORD(v14[0]) = 0;
      LODWORD(vsub_100210A00(v2 + 13) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  1LL,  "CLC: Suspend",  v14,  v13);
      int v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLCachedLocationController::suspendForException(CLCachedLocationController::CacheException)",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }

    *(_DWORD *)(a1 + 360) |= a2;
    sub_1005DE18C(a1, 0LL, 1.79769313e308);
    [*(id *)(a1 + 544) disable];
  }