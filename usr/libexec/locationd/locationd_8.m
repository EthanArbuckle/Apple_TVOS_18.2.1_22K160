void sub_10020BB48( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, char *a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, int a39, __int16 a40, char a41, char a42, void *a43, uint64_t a44)
{
  uint64_t v44;
  if (__p)
  {
    a22 = (uint64_t)__p;
    operator delete(__p);
  }

  sub_1000229D4((uint64_t)&a15, a16);
  if (a18)
  {
    a19 = (uint64_t)a18;
    operator delete(a18);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10020BBFC(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 1068)) {
    return 0LL;
  }
  double v2 = *(double *)(a1 + 992);
  if (v2 < 0.0) {
    return 0LL;
  }
  double v3 = *(double *)(a1 + 1000);
  if (v3 < 0.0) {
    return 0LL;
  }
  memset(v11, 0, sizeof(v11));
  uint64_t v5 = *(void *)(a1 + 192);
  if (v5)
  {
    sub_10020BEA8( a1,  *(void *)(*(void *)(a1 + 160) + 8 * ((v5 + *(void *)(a1 + 184) - 1) / 0x1AuLL))
    + 152 * ((v5 + *(void *)(a1 + 184) - 1) % 0x1AuLL),
      (uint64_t)v11);
  }

  else
  {
    memset(&v11[40], 0, 32);
    if (v2 < 2.22044605e-16) {
      double v2 = 2.22044605e-16;
    }
    memset(&v11[88], 0, 64);
    *(_OWORD *)&v11[72] = 0uLL;
    memset(&v11[8], 0, 32);
    *(void *)v11 = 0x7FFFFFFFFFFFFFFFLL;
    *(double *)&v11[40] = v2;
    *(double *)&v11[48] = v2;
    *(_DWORD *)&v11[96] = 4;
    double v6 = *(float *)(a1 + 1008);
    *(double *)&v11[56] = v3;
    *(double *)&v11[88] = v6;
    *(_OWORD *)&v11[128] = 0uLL;
    uuid_copy(&v11[8], (const unsigned __int8 *)(a1 + 1014));
  }

  sub_10020BF34(a1, (uint64_t)v11);
  sub_1007BC02C((double *)(a1 + 2104), (uint64_t)v11);
  if (qword_1019344E0 != -1) {
    dispatch_once(&qword_1019344E0, &stru_10182B200);
  }
  v7 = (os_log_s *)qword_1019344E8;
  if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Set first session entry", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10182B200);
    }
    v9[0] = 0;
    v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  2LL,  "Set first session entry",  v9,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLSwimDataStore::setFirstEntry()", "%s\n", v8);
  }

  return 1LL;
}

void sub_10020BEA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double v3 = *(double *)(a2 + 48) + 2.22044605e-16;
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a2;
  __int128 v6 = *(_OWORD *)(a2 + 64);
  __int128 v5 = *(_OWORD *)(a2 + 80);
  __int128 v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a3 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a3 + 64) = v6;
  *(_OWORD *)(a3 + 16) = v4;
  *(_OWORD *)(a3 + 32) = v7;
  *(_OWORD *)(a3 + 80) = v5;
  __int128 v8 = *(_OWORD *)(a2 + 96);
  __int128 v9 = *(_OWORD *)(a2 + 112);
  __int128 v10 = *(_OWORD *)(a2 + 128);
  *(void *)(a3 + 144) = *(void *)(a2 + 144);
  *(_OWORD *)(a3 + 112) = v9;
  *(_OWORD *)(a3 + 128) = v10;
  *(_OWORD *)(a3 + 96) = v8;
  *(void *)a3 = 0x7FFFFFFFFFFFFFFFLL;
  *(double *)(a3 + 40) = v3;
  *(double *)(a3 + 48) = v3;
  *(void *)(a3 + 56) = *(void *)(a1 + 1000);
  *(_DWORD *)(a3 + 96) = 4;
  *(double *)(a3 + 88) = *(float *)(a1 + 1008);
  *(void *)(a3 + 128) = 0LL;
  *(void *)(a3 + 136) = 0LL;
  uuid_copy((unsigned __int8 *)(a3 + 8), (const unsigned __int8 *)(a1 + 1014));
}

void sub_10020BF34(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 1012))
  {
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10182B200);
    }
    double v3 = (os_log_s *)qword_1019344E8;
    if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134221826;
      uint64_t v25 = *((void *)&v58 + 1);
      __int16 v26 = 2048;
      uint64_t v27 = v59;
      __int16 v28 = 2048;
      uint64_t v29 = *((void *)&v59 + 1);
      __int16 v30 = 2048;
      uint64_t v31 = *((void *)&v60 + 1);
      __int16 v32 = 2048;
      uint64_t v33 = v61;
      __int16 v34 = 2048;
      uint64_t v35 = *((void *)&v61 + 1);
      __int16 v36 = 1024;
      int v37 = v62;
      __int16 v38 = 1024;
      int v39 = DWORD1(v62);
      __int16 v40 = 1024;
      int v41 = DWORD2(v62);
      __int16 v42 = 1024;
      int v43 = HIDWORD(v62);
      __int16 v44 = 1024;
      int v45 = DWORD2(v63);
      __int16 v46 = 2048;
      uint64_t v47 = v64;
      __int16 v48 = 2048;
      uint64_t v49 = *((void *)&v64 + 1);
      __int16 v50 = 2048;
      double v51 = *(double *)&v59 - *((double *)&v58 + 1);
      __int16 v52 = 2080;
      v53 = out;
      __int16 v54 = 1024;
      int v55 = v65;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Persisting Swim Entry,startTime,%f,endTime,%f,timestamp,%f,distance,%f,distanceTimestamp,%f,poolLength,%f,type,% d,style,%d,strokes,%d,laps,%d,segment,%d,SWOLF,%f,segmentSWOLF,%f,lapTime,%f,uuid,%s,kickCount,%d",  buf,  0x8Au);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344E0 != -1) {
        dispatch_once(&qword_1019344E0, &stru_10182B200);
      }
      LODWORD(v20[0]) = 134221826;
      *(void *)((char *)v20 + 4) = *((void *)&v58 + 1);
      WORD6(v20[0]) = 2048;
      *(void *)((char *)v20 + 14) = v59;
      WORD3(v20[1]) = 2048;
      *((void *)&v20[1] + 1) = *((void *)&v59 + 1);
      LOWORD(v20[2]) = 2048;
      *(void *)((char *)&v20[2] + 2) = *((void *)&v60 + 1);
      WORD5(v20[2]) = 2048;
      *(void *)((char *)&v20[2] + 12) = v61;
      WORD2(v20[3]) = 2048;
      *(void *)((char *)&v20[3] + 6) = *((void *)&v61 + 1);
      HIWORD(v20[3]) = 1024;
      LODWORD(v21) = v62;
      WORD2(v21) = 1024;
      *(_DWORD *)((char *)&v21 + 6) = DWORD1(v62);
      WORD5(v21) = 1024;
      HIDWORD(v21) = DWORD2(v62);
      LOWORD(v22[0]) = 1024;
      *(_DWORD *)((char *)v22 + 2) = HIDWORD(v62);
      WORD3(v22[0]) = 1024;
      DWORD2(v22[0]) = DWORD2(v63);
      WORD6(v22[0]) = 2048;
      *(void *)((char *)v22 + 14) = v64;
      WORD3(v22[1]) = 2048;
      *((void *)&v22[1] + 1) = *((void *)&v64 + 1);
      LOWORD(v22[2]) = 2048;
      *(double *)((char *)&v22[2] + 2) = *(double *)&v59 - *((double *)&v58 + 1);
      WORD5(v22[2]) = 2080;
      *(void *)((char *)&v22[2] + 12) = out;
      WORD2(v22[3]) = 1024;
      *(_DWORD *)((char *)&v22[3] + 6) = v65;
      LODWORD(v15) = 138;
      v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  0LL,  "Persisting Swim Entry,startTime,%f,endTime,%f,timestamp,%f,distance,%f,distanceTimestamp,%f,poolLe ngth,%f,type,%d,style,%d,strokes,%d,laps,%d,segment,%d,SWOLF,%f,segmentSWOLF,%f,lapTime,%f,uuid,%s,kickCount,%d",  COERCE_DOUBLE(v20),  v15,  v16,  *(double *)&__p,  *(double *)&v18,  v19);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSwimDataStore::persistSwimEntry(const CLSwimEntry &)", "%s\n", v14);
    }

    if (*((double *)&v58 + 1) <= *(double *)&v59)
    {
      __int128 v7 = operator new(0x98uLL);
      __p = v7;
      *(void *)&double v19 = (char *)v7 + 152;
      __int128 v8 = v63;
      v7[6] = v62;
      v7[7] = v8;
      v7[8] = v64;
      *((void *)v7 + 18) = v65;
      __int128 v9 = v59;
      v7[2] = v58;
      v7[3] = v9;
      __int128 v10 = v61;
      v7[4] = v60;
      v7[5] = v10;
      __int128 v11 = v57[1];
      _OWORD *v7 = v57[0];
      v7[1] = v11;
      v18 = (char *)v7 + 152;
      sub_100A711A0((uint64_t *)(a1 + 1072), (uint64_t *)&__p);
      if (__p)
      {
        v18 = __p;
        operator delete(__p);
      }

      uint64_t v23 = 0LL;
      memset(v22, 0, sizeof(v22));
      __int128 v21 = 0u;
      memset(v20, 0, sizeof(v20));
      if (sub_100A70C7C((void *)(a1 + 1072), (uint64_t)v20) == 100)
      {
        unint64_t v12 = *(void *)(a1 + 192);
        if (v12 >= 0xC9)
        {
          do
          {
            *(void *)(a1 + 192) = v12 - 1;
            ++*(void *)(a1 + 184);
            sub_100210CB8(a1 + 152, 1);
            unint64_t v12 = *(void *)(a1 + 192);
          }

          while (v12 > 0xC8);
        }

        sub_10020FFB4((void *)(a1 + 152), (uint64_t)v20);
        *(_BYTE *)(a1 + 1013) = 1;
      }

      else
      {
        if (qword_1019344E0 != -1) {
          dispatch_once(&qword_1019344E0, &stru_10182B200);
        }
        v13 = (os_log_s *)qword_1019344E8;
        if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "Failure to store lap due to database inaccessibility.",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344E0 != -1) {
            dispatch_once(&qword_1019344E0, &stru_10182B200);
          }
          LOWORD(v16) = 0;
          LODWORD(v15) = 2;
          __int128 v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  17LL,  "Failure to store lap due to database inaccessibility.",  &v16,  *(void *)&v15);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSwimDataStore::persistSwimEntry(const CLSwimEntry &)",  "%s\n",  v5);
          goto LABEL_43;
        }
      }
    }

    else
    {
      if (qword_1019344E0 != -1) {
        dispatch_once(&qword_1019344E0, &stru_10182B200);
      }
      __int128 v4 = (os_log_s *)qword_1019344E8;
      if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 134218240;
        uint64_t v25 = *((void *)&v58 + 1);
        __int16 v26 = 2048;
        uint64_t v27 = v59;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "Failure to store lap due to time rollback, startTime, %f, > endTime, %f",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344E0 != -1) {
          dispatch_once(&qword_1019344E0, &stru_10182B200);
        }
        LODWORD(v20[0]) = 134218240;
        *(void *)((char *)v20 + 4) = *((void *)&v58 + 1);
        WORD6(v20[0]) = 2048;
        *(void *)((char *)v20 + 14) = v59;
        LODWORD(v15) = 22;
        __int128 v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  17LL,  "Failure to store lap due to time rollback, startTime, %f, > endTime, %f",  COERCE_DOUBLE(v20),  v15);
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLSwimDataStore::persistSwimEntry(const CLSwimEntry &)", "%s\n", v5);
LABEL_43:
      }
    }
  }

  else
  {
    sub_10020FFB4((void *)(a1 + 152), (uint64_t)v57);
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10182B200);
    }
    __int128 v6 = (os_log_s *)qword_1019344E8;
    if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134221826;
      uint64_t v25 = *((void *)&v58 + 1);
      __int16 v26 = 2048;
      uint64_t v27 = v59;
      __int16 v28 = 2048;
      uint64_t v29 = *((void *)&v59 + 1);
      __int16 v30 = 2048;
      uint64_t v31 = *((void *)&v60 + 1);
      __int16 v32 = 2048;
      uint64_t v33 = v61;
      __int16 v34 = 2048;
      uint64_t v35 = *((void *)&v61 + 1);
      __int16 v36 = 1024;
      int v37 = v62;
      __int16 v38 = 1024;
      int v39 = DWORD1(v62);
      __int16 v40 = 1024;
      int v41 = DWORD2(v62);
      __int16 v42 = 1024;
      int v43 = HIDWORD(v62);
      __int16 v44 = 1024;
      int v45 = DWORD2(v63);
      __int16 v46 = 2048;
      uint64_t v47 = v64;
      __int16 v48 = 2048;
      uint64_t v49 = *((void *)&v64 + 1);
      __int16 v50 = 2048;
      double v51 = *(double *)&v59 - *((double *)&v58 + 1);
      __int16 v52 = 2080;
      v53 = out;
      __int16 v54 = 1024;
      int v55 = v65;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Deferring Swim Entry,startTime,%f,endTime,%f,timestamp,%f,distance,%f,distanceTimestamp,%f,poolLength,%f,type,%d ,style,%d,strokes,%d,laps,%d,segment,%d,SWOLF,%f,segmentSWOLF,%f,lapTime,%f,uuid,%s,kickCount,%d",  buf,  0x8Au);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344E0 != -1) {
        dispatch_once(&qword_1019344E0, &stru_10182B200);
      }
      LODWORD(v20[0]) = 134221826;
      *(void *)((char *)v20 + 4) = *((void *)&v58 + 1);
      WORD6(v20[0]) = 2048;
      *(void *)((char *)v20 + 14) = v59;
      WORD3(v20[1]) = 2048;
      *((void *)&v20[1] + 1) = *((void *)&v59 + 1);
      LOWORD(v20[2]) = 2048;
      *(void *)((char *)&v20[2] + 2) = *((void *)&v60 + 1);
      WORD5(v20[2]) = 2048;
      *(void *)((char *)&v20[2] + 12) = v61;
      WORD2(v20[3]) = 2048;
      *(void *)((char *)&v20[3] + 6) = *((void *)&v61 + 1);
      HIWORD(v20[3]) = 1024;
      LODWORD(v21) = v62;
      WORD2(v21) = 1024;
      *(_DWORD *)((char *)&v21 + 6) = DWORD1(v62);
      WORD5(v21) = 1024;
      HIDWORD(v21) = DWORD2(v62);
      LOWORD(v22[0]) = 1024;
      *(_DWORD *)((char *)v22 + 2) = HIDWORD(v62);
      WORD3(v22[0]) = 1024;
      DWORD2(v22[0]) = DWORD2(v63);
      WORD6(v22[0]) = 2048;
      *(void *)((char *)v22 + 14) = v64;
      WORD3(v22[1]) = 2048;
      *((void *)&v22[1] + 1) = *((void *)&v64 + 1);
      LOWORD(v22[2]) = 2048;
      *(double *)((char *)&v22[2] + 2) = *(double *)&v59 - *((double *)&v58 + 1);
      WORD5(v22[2]) = 2080;
      *(void *)((char *)&v22[2] + 12) = out;
      WORD2(v22[3]) = 1024;
      *(_DWORD *)((char *)&v22[3] + 6) = v65;
      LODWORD(v15) = 138;
      __int128 v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  0LL,  "Deferring Swim Entry,startTime,%f,endTime,%f,timestamp,%f,distance,%f,distanceTimestamp,%f,poolLeng th,%f,type,%d,style,%d,strokes,%d,laps,%d,segment,%d,SWOLF,%f,segmentSWOLF,%f,lapTime,%f,uuid,%s,kickCount,%d",  COERCE_DOUBLE(v20),  v15,  v16,  *(double *)&__p,  *(double *)&v18,  v19);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSwimDataStore::persistSwimEntry(const CLSwimEntry &)", "%s\n", v5);
      goto LABEL_43;
    }
  }

void sub_10020C888( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10020C8AC(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 1068))
  {
    BOOL result = sub_10020B154(a1);
    if (!result) {
      return result;
    }
    *(_BYTE *)(a1 + 1068) = 1;
  }

  if (*(_BYTE *)(a1 + 1069)) {
    return 1LL;
  }
  if ((sub_10020BBFC(a1) & 1) != 0)
  {
    BOOL result = 1LL;
    *(_BYTE *)(a1 + 1069) = 1;
  }

  else
  {
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10182B200);
    }
    double v3 = (os_log_s *)qword_1019344E8;
    if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "Cannot yet set first swim session entry",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344E0 != -1) {
        dispatch_once(&qword_1019344E0, &stru_10182B200);
      }
      v5[0] = 0;
      __int128 v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  2LL,  "Cannot yet set first swim session entry",  v5,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLSwimDataStore::setupSessionPersistence()", "%s\n", v4);
      return 0LL;
    }
  }

  return result;
}

unint64_t sub_10020CA7C(void *a1, void *a2, char *a3, void *a4, char *a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = 26 * (a4 - a2)
  }
  unint64_t v7 = a1[4];
  uint64_t v8 = a1[1];
  __int128 v9 = (char **)(v8 + 8 * (v7 / 0x1A));
  if (a1[2] == v8) {
    __int128 v10 = 0LL;
  }
  else {
    __int128 v10 = &(*v9)[152 * (v7 % 0x1A)];
  }
  if (a3 == v10) {
    unint64_t v11 = 0LL;
  }
  else {
    unint64_t v11 = 26 * ((char **)a2 - v9)
  }
  v24[0].n128_u64[0] = v8 + 8 * (v7 / 0x1A);
  v24[0].n128_u64[1] = (unint64_t)v10;
  sub_100210D88(v24, v11);
  if (v6 >= 1)
  {
    __n128 v12 = v24[0];
    if (v11 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      sub_100210D88(v24, v6);
      sub_100210E3C( v9,  v10,  (char **)v12.n128_u64[0],  (char *)v12.n128_u64[1],  v24[0].n128_u64[0],  (char *)v24[0].n128_u64[1],  v24);
      uint64_t v18 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v18;
    }

    else
    {
      sub_100210D88(v24, v6);
      __n128 v13 = v24[0];
      unint64_t v14 = a1[4] + a1[5];
      uint64_t v15 = a1[1];
      double v16 = (_BYTE **)(v15 + 8 * (v14 / 0x1A));
      if (a1[2] == v15) {
        v17 = 0LL;
      }
      else {
        v17 = &(*v16)[152 * (v14 % 0x1A)];
      }
      v24[0] = v12;
      sub_100210FE8(v13.n128_u64[0], (_BYTE *)v13.n128_u64[1], v16, v17, (uint64_t)v24);
      a1[5] -= v6;
      while ((sub_100210D14(a1, 1) & 1) != 0)
        ;
    }
  }

  unint64_t v19 = a1[4];
  uint64_t v20 = a1[1];
  __int128 v21 = (void *)(v20 + 8 * (v19 / 0x1A));
  if (a1[2] == v20) {
    unint64_t v22 = 0LL;
  }
  else {
    unint64_t v22 = *v21 + 152 * (v19 % 0x1A);
  }
  v24[0].n128_u64[0] = (unint64_t)v21;
  v24[0].n128_u64[1] = v22;
  sub_100210D88(v24, v11);
  return v24[0].n128_u64[0];
}

BOOL sub_10020CD24(uint64_t a1, double a2)
{
  *(double *)(a1 + 1000) = a2;
  return sub_10020C8AC(a1);
}

void sub_10020CD2C(uint64_t a1, void *a2)
{
  if (qword_1019344E0 != -1) {
    dispatch_once(&qword_1019344E0, &stru_10182B200);
  }
  double v3 = (os_log_s *)qword_1019344E8;
  if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v51) = [a2 count];
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Got %d swimming LOIs.", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10182B200);
    }
    uint64_t v26 = qword_1019344E8;
    *(_DWORD *)uu2 = 67109120;
    *(_DWORD *)&uu2[4] = [a2 count];
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  2LL,  "Got %d swimming LOIs.",  uu2);
    __int16 v28 = (uint8_t *)v27;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSwimDataStore::setCurrentLOI(NSArray *)", "%s\n", v27);
    if (v28 != buf) {
      free(v28);
    }
  }

  if ((int)[a2 count] >= 1)
  {
    if (!*(_BYTE *)(a1 + 1068) && sub_10020B154(a1)) {
      *(_BYTE *)(a1 + 1068) = 1;
    }
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    id obj = [a2 reverseObjectEnumerator];
    id v32 = [obj countByEnumeratingWithState:&v35 objects:v48 count:16];
    if (!v32) {
      goto LABEL_59;
    }
    char v4 = 0;
    uint64_t v30 = *(void *)v36;
    do
    {
      __int128 v5 = 0LL;
      do
      {
        if (*(void *)v36 != v30) {
          objc_enumerationMutation(obj);
        }
        sub_1010DDBC0( __p,  (char *)objc_msgSend( objc_msgSend(*(id *)(*((void *)&v35 + 1) + 8 * (void)v5), "UUIDString"),  "UTF8String"));
        if (qword_1019344E0 != -1) {
          dispatch_once(&qword_1019344E0, &stru_10182B200);
        }
        uint64_t v6 = (os_log_s *)qword_1019344E8;
        if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEBUG))
        {
          if (v34 >= 0) {
            unint64_t v7 = __p;
          }
          else {
            unint64_t v7 = (void **)__p[0];
          }
          *(_DWORD *)buf = 136315138;
          double v51 = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Checking swimming LOI with id '%s'.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344E0 != -1) {
            dispatch_once(&qword_1019344E0, &stru_10182B200);
          }
          if (v34 >= 0) {
            __int128 v21 = __p;
          }
          else {
            __int128 v21 = (void **)__p[0];
          }
          *(_DWORD *)uu2 = 136315138;
          *(void *)&uu2[4] = v21;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  2LL,  "Checking swimming LOI with id '%s'.",  (const char *)uu2);
          uint64_t v23 = (uint8_t *)v22;
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSwimDataStore::setCurrentLOI(NSArray *)", "%s\n", v22);
          if (v23 != buf) {
            free(v23);
          }
        }

        if (v34 >= 0) {
          uint64_t v8 = __p;
        }
        else {
          uint64_t v8 = (void **)__p[0];
        }
        uuid_parse((const char *)v8, uu);
        __int128 v10 = *(__int128 **)(a1 + 32);
        __int128 v9 = *(__int128 **)(a1 + 40);
        while (v10 != v9)
        {
          __int128 v11 = *v10;
          __int128 v12 = v10[1];
          __int128 v43 = v10[2];
          *(_OWORD *)uu2 = v11;
          __int128 v42 = v12;
          __int128 v13 = v10[3];
          __int128 v14 = v10[4];
          __int128 v15 = v10[6];
          __int128 v46 = v10[5];
          __int128 v47 = v15;
          __int128 v44 = v13;
          __int128 v45 = v14;
          if (!uuid_compare(uu, uu2))
          {
            if (qword_1019344E0 != -1) {
              dispatch_once(&qword_1019344E0, &stru_10182B200);
            }
            double v16 = (os_log_s *)qword_1019344E8;
            if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEBUG))
            {
              if (v34 >= 0) {
                v17 = __p;
              }
              else {
                v17 = (void **)__p[0];
              }
              *(_DWORD *)buf = 136315138;
              double v51 = v17;
              _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "Found swimming distributions for LOI with id '%s'.",  buf,  0xCu);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019344E0 != -1) {
                dispatch_once(&qword_1019344E0, &stru_10182B200);
              }
              if (v34 >= 0) {
                uint64_t v18 = __p;
              }
              else {
                uint64_t v18 = (void **)__p[0];
              }
              int v39 = 136315138;
              __int16 v40 = v18;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  2LL,  "Found swimming distributions for LOI with id '%s'.",  (const char *)&v39);
              uint64_t v20 = (uint8_t *)v19;
              sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSwimDataStore::setCurrentLOI(NSArray *)", "%s\n", v19);
              if (v20 != buf) {
                free(v20);
              }
            }

            uuid_copy((unsigned __int8 *)(a1 + 1030), uu);
            char v4 = 1;
          }

          v10 += 7;
        }

        if (v34 < 0) {
          operator delete(__p[0]);
        }
        __int128 v5 = (char *)v5 + 1;
      }

      while (v5 != v32);
      id v24 = [obj countByEnumeratingWithState:&v35 objects:v48 count:16];
      id v32 = v24;
    }

    while (v24);
    if ((v4 & 1) == 0) {
LABEL_59:
    }
      uuid_copy((unsigned __int8 *)(a1 + 1030), uu);
    *(CFAbsoluteTime *)(a1 + 1048) = CFAbsoluteTimeGetCurrent();
    for (uint64_t i = 200LL; i != 984; i += 112LL)
      uuid_copy((unsigned __int8 *)(a1 + i), (const unsigned __int8 *)(a1 + 1030));
  }

void sub_10020D380( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10020D3B0(uint64_t a1, double a2, double a3)
{
  if (*(void *)(a1 + 2120) == 1LL) {
    sub_10020D3C4(a1, a2, a3);
  }
  else {
    sub_10020D5BC(a1);
  }
}

void sub_10020D3C4(uint64_t a1, double a2, double a3)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 176LL))(a1) & 1) == 0 && sub_10020C8AC(a1))
  {
    uint64_t v23 = 0LL;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    __int128 v16 = 0u;
    memset(v15, 0, sizeof(v15));
    uuid_copy((unsigned __int8 *)v15 + 8, (const unsigned __int8 *)(a1 + 1014));
    uint64_t v6 = *(void *)(a1 + 192);
    if (v6)
    {
      unint64_t v7 = *(void *)(*(void *)(a1 + 160) + 8 * ((v6 + *(void *)(a1 + 184) - 1) / 0x1AuLL))
         + 152 * ((v6 + *(void *)(a1 + 184) - 1) % 0x1AuLL);
      *((void *)&v16 + 1) = *(void *)(v7 + 48);
      int v8 = (*(uint64_t (**)(uint64_t, void, double, double))(*(void *)a1 + 136LL))( a1,  *(void *)(a1 + 96),  *(double *)(v7 + 56),  a3);
      unint64_t v9 = *(void *)(a1 + 192) + *(void *)(a1 + 184) - 1LL;
      int v10 = *(_DWORD *)(*(void *)(*(void *)(a1 + 160) + 8 * (v9 / 0x1A)) + 152 * (v9 % 0x1A) + 108);
    }

    else
    {
      *((void *)&v16 + 1) = *(void *)(a1 + 992);
      int v8 = sub_100DADF74(a1 + 2128);
      int v10 = 0;
    }

    DWORD1(v20) = v8;
    HIDWORD(v20) = v10;
    *(double *)&__int128 v17 = a2;
    *((double *)&v17 + 1) = a3;
    *(void *)&__int128 v18 = 0LL;
    *((void *)&v18 + 1) = sub_1007BC038(a1 + 2104);
    __int128 v19 = *(unint64_t *)&a2;
    LODWORD(v20) = 3;
    DWORD2(v20) = (*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 128LL))(a1, a3);
    if (*(void *)(a1 + 96))
    {
      int v11 = sub_10020EEF8((void *)a1, (uint64_t)v13, a3);
      int v12 = v14;
      if (!v11) {
        int v12 = 0;
      }
    }

    else
    {
      int v12 = *(_DWORD *)(a1 + 1060);
    }

    LODWORD(v23) = v12;
    DWORD2(v21) = 0;
    __int128 v22 = COERCE_UNSIGNED_INT64(sub_1007BC79C((uint64_t)v15, a1));
    sub_10020BF34(a1, (uint64_t)v15);
  }

void sub_10020D5BC(uint64_t a1)
{
  if ((*(unsigned int (**)(uint64_t, _DWORD *))(*(void *)a1 + 120LL))(a1, v2))
  {
    double v4 = sub_1007BC964(v3++, a1);
    v2[24] = 5;
    sub_10020BF34(a1, (uint64_t)v2);
  }

void sub_10020D650(uint64_t a1)
{
  uint64_t v1 = 0LL;
  uint64_t v2 = 0LL;
  uint64_t v3 = a1 + 1072;
  uint64_t v4 = a1 + 984;
  do
  {
    if (*(_BYTE *)(v4 + v2))
    {
      if (*(_DWORD *)(v4 + v1 - 744) != 6) {
        sub_100A6F718(v3, v4 + v1 - 784);
      }
    }

    ++v2;
    v1 += 112LL;
  }

  while (v2 != 7);
}

BOOL sub_10020D6B8(uint64_t a1, unsigned int a2, char a3, double a4)
{
  BOOL v8 = sub_10020C8AC(a1);
  if (v8)
  {
    sub_1009A0528(a1 + 1544, a4);
    v13.n128_f64[0] = a4;
    int v9 = *(_DWORD *)(a1 + 1056) + 1;
    *(_DWORD *)(a1 + 1056) = v9;
    v13.n128_u64[1] = __PAIR64__(v9, a2);
    char v14 = a3;
    int v10 = *(_DWORD *)(a1 + 1060);
    if (a2 == 6) {
      *(_DWORD *)(a1 + 1060) = ++v10;
    }
    int v15 = v10;
    unint64_t v11 = *(void *)(a1 + 96);
    if (v11 >= 0x1F5)
    {
      ++*(void *)(a1 + 88);
      *(void *)(a1 + 96) = v11 - 1;
      sub_100211164(a1 + 56, 1);
    }

    sub_10020D77C((void *)(a1 + 56), &v13);
  }

  return v8;
}

__n128 sub_10020D77C(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1002111C0(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  BOOL v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  __n128 *v8 = result;
  ++a1[5];
  return result;
}

BOOL sub_10020D828(void *a1, __n128 *a2, double a3)
{
  BOOL v6 = sub_10020C8AC((uint64_t)a1);
  if (v6)
  {
    if (a1[265]) {
      sub_1012304F4();
    }
    a2->n128_f64[0] = a3;
    a2[1].n128_u32[0] = *((_DWORD *)a1 + 252);
    uint64_t v7 = a1[18];
    if (v7)
    {
      BOOL v8 = (double *)(*(void *)(a1[14] + 8 * ((v7 + a1[17] - 1) / 0xAAuLL)) + 24 * ((v7 + a1[17] - 1) % 0xAAuLL));
    }

    else
    {
      uint64_t v9 = a1[24];
      if (v9) {
        BOOL v8 = (double *)(*(void *)(a1[20] + 8 * ((v9 + a1[23] - 1) / 0x1AuLL))
      }
                      + 152 * ((v9 + a1[23] - 1) % 0x1AuLL)
                      + 56);
      else {
        BOOL v8 = (double *)(a1 + 125);
      }
    }

    a2->n128_u32[2] = (*(uint64_t (**)(void *, void, double, double))(*a1 + 136LL))(a1, a1[12], *v8, a3);
    a2->n128_u32[3] = (*(uint64_t (**)(void *, double))(*a1 + 128LL))(a1, a3);
    unint64_t v10 = a1[18];
    if (v10 >= 0xC9)
    {
      ++a1[17];
      a1[18] = v10 - 1;
      sub_100211164((uint64_t)(a1 + 13), 1);
    }

    sub_10020D984(a1 + 13, a2);
  }

  return v6;
}

__n128 sub_10020D984(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1002114D4(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  BOOL v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  __n128 *v8 = result;
  ++a1[5];
  return result;
}

uint64_t sub_10020DA30@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  *(void *)(a3 + 16) = 0LL;
  return sub_100A70EB4((uint64_t *)(a1 + 1072), a2, (char **)a3);
}

void sub_10020DA60(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_10020DA7C(uint64_t a1@<X0>, const unsigned __int8 *a2@<X1>, uint64_t a3@<X8>)
{
}

BOOL sub_10020DA84(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[24];
  if (v2)
  {
    unint64_t v3 = *(void *)(a1[20] + 8 * ((v2 + a1[23] - 1) / 0x1AuLL)) + 152 * ((v2 + a1[23] - 1) % 0x1AuLL);
    __int128 v4 = *(_OWORD *)(v3 + 80);
    __int128 v6 = *(_OWORD *)(v3 + 32);
    __int128 v5 = *(_OWORD *)(v3 + 48);
    *(_OWORD *)(a2 + 64) = *(_OWORD *)(v3 + 64);
    *(_OWORD *)(a2 + 80) = v4;
    *(_OWORD *)(a2 + 32) = v6;
    *(_OWORD *)(a2 + 48) = v5;
    __int128 v8 = *(_OWORD *)(v3 + 112);
    __int128 v7 = *(_OWORD *)(v3 + 128);
    __int128 v9 = *(_OWORD *)(v3 + 96);
    *(void *)(a2 + 144) = *(void *)(v3 + 144);
    *(_OWORD *)(a2 + 112) = v8;
    *(_OWORD *)(a2 + 128) = v7;
    *(_OWORD *)(a2 + 96) = v9;
    __int128 v10 = *(_OWORD *)(v3 + 16);
    *(_OWORD *)a2 = *(_OWORD *)v3;
    *(_OWORD *)(a2 + 16) = v10;
  }

  return v2 != 0;
}

void *sub_10020DB04@<X0>(uint64_t a1@<X0>, int a2@<W1>, unsigned int a3@<W2>, void **a4@<X8>)
{
  __int128 v8 = (char *)operator new(0x20uLL);
  *(void *)__int128 v8 = &off_10182B270;
  *((_DWORD *)v8 + 2) = a2;
  *(_OWORD *)(v8 + 12) = *(_OWORD *)dst;
  int v12 = v8;
  sub_10020DC20((void *)a1, a3, (uint64_t)v11, a4);
  __n128 result = v12;
  if (v12 == v11)
  {
    uint64_t v10 = 4LL;
    __n128 result = v11;
  }

  else
  {
    if (!v12) {
      return result;
    }
    uint64_t v10 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v10))();
}

void sub_10020DBE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  int v15 = a13;
  if (a13 == v13)
  {
    uint64_t v16 = 4LL;
    int v15 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*(void *)v15 + 8 * v16))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_10020DC20(void *a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, void **a4@<X8>)
{
  int v5 = a2;
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  unint64_t v8 = a1[23];
  unint64_t v9 = v8 + a1[24];
  uint64_t v10 = a1[20];
  uint64_t v11 = a1[21];
  int v12 = (unint64_t *)(v10 + 8 * (v9 / 0x1A));
  if (v11 == v10) {
    unint64_t v13 = 0LL;
  }
  else {
    unint64_t v13 = *v12 + 152 * (v9 % 0x1A);
  }
  unint64_t v67 = a2;
  while (1)
  {
    unint64_t v14 = v11 == v10 ? 0LL : *(void *)(v10 + 8 * (v8 / 0x1A)) + 152 * (v8 % 0x1A);
    if (v13 == v14 || v5 >= 1 && v67 <= ((_BYTE *)a4[1] - (_BYTE *)*a4) >> 4) {
      break;
    }
    unint64_t v15 = *v12;
    uint64_t v16 = v13 - *v12;
    unint64_t v17 = 0x86BCA1AF286BCA1BLL * (v16 >> 3);
    unint64_t v18 = v16 < 153
        ? v12[-((26 - v17) / 0x1A)] + 152 * (26 * ((26 - v17) / 0x1A) - (26 - v17)) + 3800
        : v12[(v17 - 1) / 0x1A] + 152 * ((v17 - 1) % 0x1A);
    unint64_t v19 = v11 == v10 ? 0LL : *(void *)(v10 + 8 * (v8 / 0x1A)) + 152 * (v8 % 0x1A);
    if (v18 == v19) {
      break;
    }
    if (v13 == v15)
    {
      uint64_t v21 = *(v12 - 1);
      unint64_t v15 = v13;
      unint64_t v20 = v21 + 3952;
    }

    else
    {
      unint64_t v20 = v13;
    }

    uint64_t v22 = *(void *)(a3 + 24);
    if (!v22) {
      sub_100008BDC();
    }
    int v23 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v22 + 48LL))(v22, v20 - 152);
    unint64_t v15 = *v12;
    if (v23)
    {
      unint64_t v24 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(v13 - v15) >> 3);
      if ((uint64_t)(v13 - v15) < 153)
      {
        unint64_t v30 = 26 - v24;
        unint64_t v31 = (26 - v24) / 0x1A;
        uint64_t v27 = &v12[-v31];
        unint64_t v28 = *v27;
        uint64_t v29 = *v27 + 152 * (26 * v31 - v30) + 3800;
      }

      else
      {
        unint64_t v25 = v24 - 1;
        unint64_t v26 = (v24 - 1) / 0x1A;
        uint64_t v27 = &v12[v26];
        unint64_t v28 = *v27;
        uint64_t v29 = *v27 + 152 * (v25 - 26 * v26);
      }

      uint64_t v32 = a1[20];
      while (1)
      {
        unint64_t v33 = a1[21] == v32 ? 0LL : *(void *)(v32 + 8 * (a1[23] / 0x1AuLL)) + 152 * (a1[23] % 0x1AuLL);
        if (v29 == v33) {
          break;
        }
        if (v29 == v28)
        {
          uint64_t v37 = *(v27 - 1);
          unsigned int v38 = *(_DWORD *)(v37 + 3896);
          BOOL v62 = v38 > 4;
          int v39 = (1 << v38) & 0x16;
          if (!v62 && v39 != 0)
          {
LABEL_46:
            if (v13 == v15)
            {
              uint64_t v43 = *(v12 - 1);
              int v41 = (uint64_t *)(v43 + 3888);
              unint64_t v42 = v43 + 3952;
            }

            else
            {
              int v41 = (uint64_t *)(v13 - 64);
              unint64_t v42 = v13;
            }

            if (v29 == v28) {
              uint64_t v29 = *(v27 - 1) + 3952;
            }
            uint64_t v44 = *v41;
            int v45 = *(_DWORD *)(v42 - 48) - *(_DWORD *)(v29 - 48);
            __int128 v47 = (char *)a4[1];
            __int128 v46 = (char *)a4[2];
            if (v47 >= v46)
            {
              uint64_t v49 = a3;
              __int16 v50 = (char *)*a4;
              uint64_t v51 = (v47 - (_BYTE *)*a4) >> 4;
              unint64_t v52 = v51 + 1;
              uint64_t v53 = v46 - v50;
              if (v53 >> 3 > v52) {
                unint64_t v52 = v53 >> 3;
              }
              else {
                unint64_t v54 = v52;
              }
              if (v54)
              {
                int v55 = (char *)sub_100037038((uint64_t)(a4 + 2), v54);
                __int16 v50 = (char *)*a4;
                __int128 v47 = (char *)a4[1];
              }

              else
              {
                int v55 = 0LL;
              }

              v56 = &v55[16 * v51];
              *(void *)v56 = v44;
              *((_DWORD *)v56 + 2) = v45;
              v57 = v56;
              a3 = v49;
              if (v47 != v50)
              {
                do
                {
                  *((_OWORD *)v57 - 1) = *((_OWORD *)v47 - 1);
                  v57 -= 16;
                  v47 -= 16;
                }

                while (v47 != v50);
                __int16 v50 = (char *)*a4;
              }

              int v5 = a2;
              __int16 v48 = v56 + 16;
              *a4 = v57;
              a4[1] = v56 + 16;
              a4[2] = &v55[16 * v54];
              if (v50) {
                operator delete(v50);
              }
            }

            else
            {
              *(void *)__int128 v47 = v44;
              *((_DWORD *)v47 + 2) = v45;
              __int16 v48 = v47 + 16;
            }

            a4[1] = v48;
            unint64_t v15 = *v12;
            break;
          }

          uint64_t v29 = v37 + 3952;
          unint64_t v28 = *--v27;
        }

        else
        {
          unsigned int v34 = *(_DWORD *)(v29 - 56);
          BOOL v62 = v34 > 4;
          int v35 = (1 << v34) & 0x16;
          if (!v62 && v35 != 0) {
            goto LABEL_46;
          }
        }

        v29 -= 152LL;
      }
    }

void sub_10020E094(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_10020E0BC(void *a1@<X0>, int a2@<W1>, void **a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  unint64_t v6 = a1[23] + a1[24];
  uint64_t v7 = a1[20];
  uint64_t v8 = a1[21];
  unint64_t v9 = (unint64_t *)(v7 + 8 * (v6 / 0x1A));
  if (v8 == v7) {
    unint64_t v10 = 0LL;
  }
  else {
    unint64_t v10 = *v9 + 152 * (v6 % 0x1A);
  }
  uint64_t v11 = (const unsigned __int8 *)a1 + 1014;
  v72 = (const unsigned __int8 *)a1 + 1014;
  while (1)
  {
    unint64_t v12 = v8 == v7 ? 0LL : *(void *)(v7 + 8 * (a1[23] / 0x1AuLL)) + 152 * (a1[23] % 0x1AuLL);
    if (v10 == v12) {
      break;
    }
    if (v10 == *v9)
    {
      uint64_t v14 = *(v9 - 1);
      if (*(_DWORD *)(v14 + 3920) < a2) {
        break;
      }
      unint64_t v13 = v14 + 3952;
    }

    else
    {
      unint64_t v13 = v10;
      if (*(_DWORD *)(v10 - 32) < a2) {
        break;
      }
    }

    unint64_t v15 = *v9;
    uint64_t v16 = v10 - *v9;
    unint64_t v17 = 0x86BCA1AF286BCA1BLL * (v16 >> 3);
    unint64_t v18 = v17 - 1;
    unint64_t v19 = v16 < 153
        ? v9[-((26 - v17) / 0x1A)] + 152 * (v17 - 26 + 26 * ((26 - v17) / 0x1A)) + 3800
        : v9[v18 / 0x1A] + 152 * (v18 % 0x1A);
    uint64_t v20 = a1[20];
    unint64_t v21 = a1[21] == v20 ? 0LL : *(void *)(v20 + 8 * (a1[23] / 0x1AuLL)) + 152 * (a1[23] % 0x1AuLL);
    if (v19 == v21) {
      break;
    }
    if (v10 == v15)
    {
      uint64_t v24 = *(v9 - 1);
      unint64_t v23 = v10;
      if (*(_DWORD *)(v24 + 3920) != a2) {
        goto LABEL_62;
      }
      unint64_t v22 = v24 + 3952;
    }

    else
    {
      unint64_t v22 = v10;
      if (*(_DWORD *)(v10 - 32) != a2)
      {
        unint64_t v23 = *v9;
        goto LABEL_62;
      }
    }

    unsigned int v25 = *(_DWORD *)(v22 - 56) - 1;
    unint64_t v23 = *v9;
    if (v25 <= 1)
    {
      if (v16 < 153)
      {
        unint64_t v29 = 26 - v17;
        unint64_t v30 = (26 - v17) / 0x1A;
        unint64_t v26 = &v9[-v30];
        unint64_t v27 = *v26;
        uint64_t v28 = *v26 + 152 * (26 * v30 - v29) + 3800;
      }

      else
      {
        unint64_t v26 = &v9[v18 / 0x1A];
        unint64_t v27 = *v26;
        uint64_t v28 = *v26 + 152 * (v18 % 0x1A);
      }

      if (v10 == v15)
      {
        uint64_t v34 = *(v9 - 1);
        unint64_t v31 = (uint64_t *)(v34 + 3840);
        uint64_t v32 = (uint64_t *)(v34 + 3848);
        unint64_t v33 = v34 + 3952;
      }

      else
      {
        unint64_t v31 = (uint64_t *)(v10 - 112);
        uint64_t v32 = (uint64_t *)(v10 - 104);
        unint64_t v33 = v10;
      }

      uint64_t v35 = v28;
      if (v28 == v27) {
        uint64_t v35 = *(v26 - 1) + 3952;
      }
      if (v10 == v15)
      {
        uint64_t v38 = *(v9 - 1);
        __int128 v36 = (int *)(v38 + 3900);
        unint64_t v37 = v38 + 3952;
      }

      else
      {
        __int128 v36 = (int *)(v10 - 52);
        unint64_t v37 = v10;
      }

      if (v28 == v27) {
        uint64_t v28 = *(v26 - 1) + 3952;
      }
      uint64_t v39 = v10;
      if (v10 == v15) {
        uint64_t v39 = *(v9 - 1) + 3952;
      }
      uint64_t v40 = *v31;
      uint64_t v41 = *v32;
      double v42 = *(double *)(v33 - 80) - *(double *)(v35 - 80);
      int v43 = *v36;
      int v44 = *(_DWORD *)(v37 - 48) - *(_DWORD *)(v28 - 48);
      uint64_t v45 = *(void *)(v39 - 24);
      __int128 v47 = (char *)a3[1];
      __int128 v46 = (char *)a3[2];
      if (v47 >= v46)
      {
        uint64_t v49 = (char *)*a3;
        unint64_t v50 = 0xCCCCCCCCCCCCCCCDLL * ((v47 - (_BYTE *)*a3) >> 3);
        unint64_t v51 = v50 + 1;
        if (v50 + 1 > 0x666666666666666LL) {
          sub_100007008();
        }
        unint64_t v52 = 0xCCCCCCCCCCCCCCCDLL * ((v46 - v49) >> 3);
        if (2 * v52 > v51) {
          unint64_t v51 = 2 * v52;
        }
        if (v52 >= 0x333333333333333LL) {
          unint64_t v53 = 0x666666666666666LL;
        }
        else {
          unint64_t v53 = v51;
        }
        if (v53)
        {
          unint64_t v54 = (char *)sub_100100EF8((uint64_t)(a3 + 2), v53);
          uint64_t v49 = (char *)*a3;
          __int128 v47 = (char *)a3[1];
        }

        else
        {
          unint64_t v54 = 0LL;
        }

        int v55 = &v54[40 * v50];
        *(void *)int v55 = v40;
        *((void *)v55 + 1) = v41;
        *((double *)v55 + 2) = v42;
        *((_DWORD *)v55 + 6) = v43;
        *((_DWORD *)v55 + 7) = v44;
        *((void *)v55 + 4) = v45;
        if (v47 == v49)
        {
          __int128 v59 = &v54[40 * v50];
        }

        else
        {
          v56 = &v54[40 * v50];
          do
          {
            __int128 v57 = *(_OWORD *)(v47 - 40);
            __int128 v58 = *(_OWORD *)(v47 - 24);
            __int128 v59 = v56 - 40;
            *((void *)v56 - 1) = *((void *)v47 - 1);
            *(_OWORD *)(v56 - 24) = v58;
            *(_OWORD *)(v56 - 40) = v57;
            v47 -= 40;
            v56 -= 40;
          }

          while (v47 != v49);
        }

        __int16 v48 = v55 + 40;
        *a3 = v59;
        a3[1] = v55 + 40;
        a3[2] = &v54[40 * v53];
        if (v49) {
          operator delete(v49);
        }
      }

      else
      {
        *(void *)__int128 v47 = v40;
        *((void *)v47 + 1) = v41;
        *((double *)v47 + 2) = v42;
        *((_DWORD *)v47 + 6) = v43;
        *((_DWORD *)v47 + 7) = v44;
        __int16 v48 = v47 + 40;
        *((void *)v47 + 4) = v45;
      }

      a3[1] = v48;
      unint64_t v23 = *v9;
      uint64_t v11 = v72;
    }

void sub_10020E5B8(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10020E5DC(void *a1, int a2, void *a3, _DWORD *a4)
{
  uint64_t v4 = a1[8];
  if (a1[9] == v4) {
    return 0LL;
  }
  unint64_t v5 = a1[11];
  unint64_t v6 = (void *)(v4 + 8 * (v5 / 0xAA));
  unint64_t v7 = *v6 + 24 * (v5 % 0xAA);
  unint64_t v8 = a1[12] + v5;
  unint64_t v9 = v8 / 0xAA;
  unint64_t v10 = v8 % 0xAA;
  unint64_t v11 = *(void *)(v4 + 8 * (v8 / 0xAA)) + 24 * (v8 % 0xAA);
  if (v7 != v11)
  {
    while (*(_DWORD *)(v7 + 12) < a2)
    {
      v7 += 24LL;
      if (v7 - *v6 == 4080)
      {
        unint64_t v12 = v6[1];
        ++v6;
        unint64_t v7 = v12;
      }

      if (v7 == v11)
      {
        unint64_t v7 = v11;
        break;
      }
    }
  }

  if (v7 == *(void *)(v4 + 8 * v9) + 24 * v10) {
    return 0LL;
  }
  *a3 = *(void *)v7;
  *a4 = *(_DWORD *)(v7 + 12);
  return 1LL;
}

uint64_t sub_10020E698(void *a1)
{
  uint64_t v1 = a1[24];
  if (v1) {
    return *(unsigned int *)(*(void *)(a1[20] + 8 * ((v1 + a1[23] - 1) / 0x1AuLL))
  }
                           + 152 * ((v1 + a1[23] - 1) % 0x1AuLL)
                           + 108);
  else {
    return 0LL;
  }
}

double sub_10020E6EC(void *a1)
{
  if (!a1[24]) {
    return 0.0;
  }
  unint64_t v2 = a1[24] + a1[23] - 1LL;
  return *(double *)(*(void *)(a1[20] + 8 * (v2 / 0x1A)) + 152 * (v2 % 0x1A) + 72);
}

void sub_10020E778(void *a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, char **a4@<X8>)
{
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  unint64_t v8 = a1[17];
  unint64_t v9 = v8 + a1[18];
  uint64_t v10 = a1[14];
  uint64_t v11 = a1[15];
  unint64_t v12 = (uint64_t *)(v10 + 8 * (v9 / 0xAA));
  if (v11 == v10) {
    unint64_t v13 = 0LL;
  }
  else {
    unint64_t v13 = *v12 + 24 * (v9 % 0xAA);
  }
  uint64_t v14 = 0LL;
  unint64_t v15 = a4 + 2;
  unint64_t v16 = a3;
  while (1)
  {
    unint64_t v17 = v11 == v10 ? 0LL : *(void *)(v10 + 8 * (v8 / 0xAA)) + 24 * (v8 % 0xAA);
    if (v13 == v17) {
      break;
    }
    uint64_t v18 = *v12;
    uint64_t v19 = v13 - *v12;
    unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * (v19 >> 3);
    unint64_t v21 = v20 - 1;
    unint64_t v22 = v19 < 25
        ? v12[-((170 - v20) / 0xAA)] + 24 * (v20 - 170 + 170 * ((170 - v20) / 0xAA)) + 4056
        : v12[v21 / 0xAA] + 24 * (v21 % 0xAA);
    unint64_t v23 = v11 == v10 ? 0LL : *(void *)(v10 + 8 * (v8 / 0xAA)) + 24 * (v8 % 0xAA);
    if (a2 == 5) {
      goto LABEL_22;
    }
    uint64_t v24 = v13;
    if (v13 == v18) {
      uint64_t v24 = *(v12 - 1) + 4080;
    }
    if (*(_DWORD *)(v24 - 16) == a2)
    {
LABEL_22:
      uint64_t v25 = v13;
      if (v13 == v18) {
        uint64_t v25 = *(v12 - 1) + 4080;
      }
      if (v19 < 25)
      {
        unint64_t v29 = 170 - v20;
        unint64_t v30 = (170 - v20) / 0xAA;
        unint64_t v26 = -(uint64_t)v30;
        uint64_t v27 = v12[-v30];
        uint64_t v28 = v27 + 24 * (170 * v30 - v29) + 4056;
      }

      else
      {
        unint64_t v26 = v21 / 0xAA;
        uint64_t v27 = v12[v21 / 0xAA];
        uint64_t v28 = v27 + 24 * (v21 % 0xAA);
      }

      if (v28 == v27) {
        uint64_t v28 = v12[v26 - 1] + 4080;
      }
      int v31 = *(_DWORD *)(v25 - 12) - *(_DWORD *)(v28 - 12);
      if (v31 >= 1)
      {
        uint64_t v32 = v13;
        if (v13 == v18) {
          uint64_t v32 = *(v12 - 1) + 4080;
        }
        double v33 = *(float *)(v32 - 8);
        if ((unint64_t)v14 >= *v15)
        {
          uint64_t v34 = a3;
          uint64_t v35 = (double *)*a4;
          uint64_t v36 = ((char *)v14 - *a4) >> 4;
          unint64_t v37 = v36 + 1;
          uint64_t v38 = *v15 - (void)v35;
          if (v38 >> 3 > v37) {
            unint64_t v37 = v38 >> 3;
          }
          else {
            unint64_t v39 = v37;
          }
          if (v39)
          {
            uint64_t v40 = (char *)sub_100037038((uint64_t)v15, v39);
            uint64_t v35 = (double *)*a4;
            uint64_t v14 = (double *)a4[1];
            unint64_t v15 = a4 + 2;
          }

          else
          {
            uint64_t v40 = 0LL;
          }

          uint64_t v41 = &v40[16 * v36];
          *(double *)uint64_t v41 = v33;
          *((_DWORD *)v41 + 2) = v31;
          double v42 = v41;
          a3 = v34;
          if (v14 != v35)
          {
            do
            {
              *((_OWORD *)v42 - 1) = *((_OWORD *)v14 - 1);
              v42 -= 16;
              v14 -= 2;
            }

            while (v14 != v35);
            uint64_t v35 = (double *)*a4;
          }

          uint64_t v14 = (double *)(v41 + 16);
          *a4 = v42;
          a4[1] = v41 + 16;
          a4[2] = &v40[16 * v39];
          if (v35)
          {
            operator delete(v35);
            unint64_t v15 = a4 + 2;
          }
        }

        else
        {
          double *v14 = v33;
          *((_DWORD *)v14 + 2) = v31;
          v14 += 2;
        }

        a4[1] = (char *)v14;
        uint64_t v18 = *v12;
      }
    }

    if (v13 == v18)
    {
      uint64_t v43 = *--v12;
      unint64_t v13 = v43 + 4080;
    }

    v13 -= 24LL;
    unint64_t v8 = a1[17];
    uint64_t v10 = a1[14];
    uint64_t v11 = a1[15];
  }

  int v44 = (double *)*a4;
  uint64_t v45 = v14 - 2;
  if (*a4 != (char *)v14 && v45 > v44)
  {
    unint64_t v47 = (unint64_t)(v44 + 2);
    do
    {
      __int128 v48 = *(_OWORD *)(v47 - 16);
      *(_OWORD *)(v47 - 16) = *(_OWORD *)v45;
      *(_OWORD *)uint64_t v45 = v48;
      v45 -= 2;
      BOOL v49 = v47 >= (unint64_t)v45;
      v47 += 16LL;
    }

    while (!v49);
  }

void sub_10020EB1C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10020EB3C(void *a1, int a2)
{
  uint64_t v2 = a1[14];
  if (a1[15] == v2) {
    return 0LL;
  }
  unint64_t v3 = a1[17];
  uint64_t v4 = (unint64_t *)(v2 + 8 * (v3 / 0xAA));
  unint64_t v5 = *v4;
  unint64_t v6 = *v4 + 24 * (v3 % 0xAA);
  unint64_t v7 = *(void *)(v2 + 8 * ((a1[18] + v3) / 0xAA)) + 24 * ((a1[18] + v3) % 0xAA);
  if (v6 == v7) {
    return 0LL;
  }
  LODWORD(result) = 0;
  do
  {
    if (*(_DWORD *)(v6 + 8) == a2) {
      uint64_t result = (result + 1);
    }
    else {
      uint64_t result = result;
    }
    v6 += 24LL;
    if (v6 - v5 == 4080)
    {
      unint64_t v9 = v4[1];
      ++v4;
      unint64_t v5 = v9;
      unint64_t v6 = v9;
    }
  }

  while (v6 != v7);
  return result;
}

uint64_t sub_10020EBD0(uint64_t a1, void *a2)
{
  return sub_100A7121C(a1 + 1072, a2);
}

BOOL sub_10020EBD8(uint64_t a1)
{
  return *(double *)(a1 + 992) > -1.79769313e308;
}

__n128 sub_10020EBF0(uint64_t a1, int a2, __int128 *a3)
{
  if (*((_DWORD *)a3 + 10) != a2) {
    sub_101230660();
  }
  *(_BYTE *)(a1 + a2 + 984) = 1;
  uint64_t v3 = a1 + 112LL * a2;
  __int128 v4 = *a3;
  __int128 v5 = a3[1];
  *(_OWORD *)(v3 + 232) = a3[2];
  *(_OWORD *)(v3 + 216) = v5;
  *(_OWORD *)(v3 + 200) = v4;
  __n128 result = (__n128)a3[3];
  __int128 v7 = a3[4];
  __int128 v8 = a3[6];
  *(_OWORD *)(v3 + 280) = a3[5];
  *(_OWORD *)(v3 + 296) = v8;
  *(_OWORD *)(v3 + 264) = v7;
  *(__n128 *)(v3 + 248) = result;
  return result;
}

__n128 sub_10020EC50@<Q0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3 = a1 + 112LL * a2;
  __int128 v4 = *(_OWORD *)(v3 + 248);
  __int128 v5 = *(_OWORD *)(v3 + 216);
  *(_OWORD *)a3 = *(_OWORD *)(v3 + 200);
  *(_OWORD *)(a3 + 16) = v5;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v3 + 232);
  *(_OWORD *)(a3 + 48) = v4;
  __int128 v6 = *(_OWORD *)(v3 + 280);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(v3 + 264);
  *(_OWORD *)(a3 + 80) = v6;
  __n128 result = *(__n128 *)(v3 + 296);
  *(__n128 *)(a3 + 96) = result;
  return result;
}

uint64_t sub_10020EC88@<X0>(uint64_t a1@<X0>, int a2@<W1>, const unsigned __int8 *a3@<X2>, uint64_t *a4@<X8>)
{
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  sub_1002118E4( a4,  *(const void **)(a1 + 32),  *(void *)(a1 + 40),  0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(*(void *)(a1 + 40) - *(void *)(a1 + 32)) >> 4));
  uuid_parse("00000000-0000-0000-0000-000000000000", uu);
  uint64_t result = uuid_compare(a3, uu);
  uint64_t v8 = *a4;
  if (!(_DWORD)result) {
    goto LABEL_19;
  }
  unint64_t v9 = (__int128 *)a4[1];
  __int128 v23 = *(_OWORD *)a3;
  if ((__int128 *)v8 != v9)
  {
    while (*(_DWORD *)(v8 + 40) == a2)
    {
      uint64_t result = uuid_compare((const unsigned __int8 *)v8, (const unsigned __int8 *)&v23);
      if ((_DWORD)result) {
        break;
      }
      v8 += 112LL;
      if ((__int128 *)v8 == v9)
      {
        uint64_t v8 = (uint64_t)v9;
        goto LABEL_14;
      }
    }

    if ((__int128 *)v8 != v9)
    {
      for (uint64_t i = (const unsigned __int8 *)(v8 + 112); i != (const unsigned __int8 *)v9; i += 112)
      {
        if (*((_DWORD *)i + 10) == a2)
        {
          uint64_t result = uuid_compare(i, (const unsigned __int8 *)&v23);
          if (!(_DWORD)result)
          {
            __int128 v11 = *(_OWORD *)i;
            __int128 v12 = *((_OWORD *)i + 2);
            *(_OWORD *)(v8 + 16) = *((_OWORD *)i + 1);
            *(_OWORD *)(v8 + 32) = v12;
            *(_OWORD *)uint64_t v8 = v11;
            __int128 v13 = *((_OWORD *)i + 3);
            __int128 v14 = *((_OWORD *)i + 4);
            __int128 v15 = *((_OWORD *)i + 6);
            *(_OWORD *)(v8 + 80) = *((_OWORD *)i + 5);
            *(_OWORD *)(v8 + 96) = v15;
            *(_OWORD *)(v8 + 48) = v13;
            *(_OWORD *)(v8 + 64) = v14;
            v8 += 112LL;
          }
        }
      }
    }
  }

void sub_10020EEA0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void *sub_10020EEC4@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  __int128 v4 = *(const void **)(a1 + 32);
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  return sub_1002118E4(a3, v4, (uint64_t)v4, 0LL);
}

uint64_t sub_10020EEF8(void *a1, uint64_t a2, double a3)
{
  uint64_t v3 = a1[12];
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = a1[8];
  if (a1[9] == v4) {
    return 0LL;
  }
  unint64_t v5 = a1[11];
  unint64_t v6 = v5 + v3;
  __int128 v7 = (uint64_t *)(v4 + 8 * ((v5 + v3) / 0xAA));
  uint64_t v8 = *v7;
  unint64_t v9 = *v7 + 24 * (v6 % 0xAA);
  unint64_t v10 = v5 / 0xAA;
  uint64_t v11 = *(void *)(v4 + 8 * (v5 / 0xAA));
  unint64_t v12 = v5 % 0xAA;
  uint64_t v13 = v11 + 24 * v12;
  if (v9 == v13)
  {
    uint64_t v8 = *v7 + 24 * (v6 % 0xAA);
  }

  else
  {
    __int128 v14 = v7;
    do
    {
      if (v9 == v8)
      {
        uint64_t v16 = *--v14;
        uint64_t v15 = v16;
        unint64_t v9 = v15 + 4080;
        __int128 v7 = v14;
      }

      else
      {
        uint64_t v15 = v8;
        uint64_t v8 = v9;
      }

      v9 -= 24LL;
      uint64_t v8 = v15;
    }

    while (v9 != v13);
    uint64_t v8 = v13;
  }

uint64_t sub_10020EFF8(uint64_t a1, double a2)
{
  if (!*(void *)(a1 + 96)) {
    return *(unsigned int *)(a1 + 1056);
  }
  return 0LL;
}

__n128 sub_10020F034@<Q0>(void *a1@<X0>, double *a2@<X1>, __n128 **a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  unint64_t v6 = a1[11] + a1[12];
  uint64_t v7 = a1[8];
  uint64_t v8 = a1[9];
  unint64_t v9 = (void *)(v7 + 8 * (v6 / 0xAA));
  if (v8 == v7) {
    unint64_t v10 = 0LL;
  }
  else {
    unint64_t v10 = *v9 + 24 * (v6 % 0xAA);
  }
  uint64_t v11 = 0LL;
  unint64_t v12 = a3 + 2;
  while (1)
  {
    unint64_t v13 = v8 == v7 ? 0LL : *(void *)(v7 + 8 * (a1[11] / 0xAAuLL)) + 24 * (a1[11] % 0xAAuLL);
    if (v10 == v13) {
      break;
    }
    if (v10 == *v9)
    {
      uint64_t v16 = *(v9 - 1);
      result.n128_u64[0] = *(void *)(v16 + 4056);
      if (result.n128_f64[0] <= *a2) {
        break;
      }
      unint64_t v15 = v16 + 4080;
    }

    else
    {
      result.n128_u64[0] = *(void *)(v10 - 24);
      unint64_t v15 = v10;
      if (result.n128_f64[0] <= *a2) {
        break;
      }
    }

    __int128 v17 = (__n128 *)(v15 - 24);
    if ((unint64_t)v11 >= *v12)
    {
      unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (((char *)v11 - (char *)*a3) >> 3);
      unint64_t v19 = v18 + 1;
      if (v18 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100007008();
      }
      else {
        unint64_t v20 = v19;
      }
      if (v20) {
        __int128 v21 = (char *)sub_10000701C((uint64_t)(a3 + 2), v20);
      }
      else {
        __int128 v21 = 0LL;
      }
      __int128 v22 = (__n128 *)&v21[24 * v18];
      __n128 result = *v17;
      v22[1].n128_u64[0] = v17[1].n128_u64[0];
      *__int128 v22 = result;
      uint64_t v24 = *a3;
      __int128 v23 = a3[1];
      uint64_t v25 = v22;
      if (v23 != *a3)
      {
        do
        {
          __n128 result = *(__n128 *)((char *)v23 - 24);
          v25[-1].n128_u64[1] = v23[-1].n128_u64[1];
          *(__n128 *)((char *)v25 - 24) = result;
          uint64_t v25 = (__n128 *)((char *)v25 - 24);
          __int128 v23 = (__n128 *)((char *)v23 - 24);
        }

        while (v23 != v24);
        __int128 v23 = *a3;
      }

      uint64_t v11 = (__n128 *)((char *)v22 + 24);
      *a3 = v25;
      a3[1] = (__n128 *)((char *)v22 + 24);
      a3[2] = (__n128 *)&v21[24 * v20];
      if (v23) {
        operator delete(v23);
      }
    }

    else
    {
      __n128 result = *v17;
      v11[1].n128_u64[0] = *(void *)(v15 - 8);
      *uint64_t v11 = result;
      uint64_t v11 = (__n128 *)((char *)v11 + 24);
    }

    a3[1] = v11;
    if (v10 == *v9)
    {
      uint64_t v26 = *--v9;
      unint64_t v10 = v26 + 4080;
    }

    v10 -= 24LL;
    uint64_t v7 = a1[8];
    uint64_t v8 = a1[9];
  }

  uint64_t v27 = *a3;
  uint64_t v28 = &v11[-2].n128_i8[8];
  if (*a3 != v11 && v28 > (__int8 *)v27)
  {
    unint64_t v30 = (unint64_t)&v27[1].n128_u64[1];
    do
    {
      __n128 result = *(__n128 *)(v30 - 24);
      uint64_t v31 = *(void *)(v30 - 8);
      uint64_t v32 = *((void *)v28 + 2);
      *(_OWORD *)(v30 - 24) = *(_OWORD *)v28;
      *(void *)(v30 - 8) = v32;
      *((void *)v28 + 2) = v31;
      *(__n128 *)uint64_t v28 = result;
      v28 -= 24;
      BOOL v33 = v30 >= (unint64_t)v28;
      v30 += 24LL;
    }

    while (!v33);
  }

  return result;
}

void sub_10020F2D4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_10020F2F4(void *a1@<X0>, void *a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  unint64_t v8 = a1[11] + a1[12];
  uint64_t v9 = a1[8];
  uint64_t v10 = a1[9];
  uint64_t v11 = (unint64_t *)(v9 + 8 * (v8 / 0xAA));
  if (v10 == v9) {
    unint64_t v12 = 0LL;
  }
  else {
    unint64_t v12 = *v11 + 24 * (v8 % 0xAA);
  }
  unint64_t v13 = 0LL;
  __int128 v14 = a2 + 2;
  while (1)
  {
    unint64_t v15 = v10 == v9 ? 0LL : *(void *)(v9 + 8 * (a1[11] / 0xAAuLL)) + 24 * (a1[11] % 0xAAuLL);
    if (v12 == v15) {
      break;
    }
    unint64_t v16 = *v11;
    if (v12 == *v11)
    {
      uint64_t v19 = *(v11 - 1);
      double v20 = *(double *)(v19 + 4056);
      if (v20 < a3) {
        break;
      }
      if (v20 > a4)
      {
        unint64_t v16 = v12;
        goto LABEL_34;
      }

      unint64_t v18 = v19 + 4080;
LABEL_17:
      unint64_t v21 = v18 - 24;
      if ((unint64_t)v13 >= *v14)
      {
        unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v13[-*a2] >> 3);
        unint64_t v24 = v23 + 1;
        if (v23 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_100007008();
        }
        else {
          unint64_t v25 = v24;
        }
        if (v25) {
          uint64_t v26 = (char *)sub_10000701C((uint64_t)(a2 + 2), v25);
        }
        else {
          uint64_t v26 = 0LL;
        }
        uint64_t v27 = &v26[24 * v23];
        __int128 v28 = *(_OWORD *)v21;
        *((void *)v27 + 2) = *(void *)(v21 + 16);
        *(_OWORD *)uint64_t v27 = v28;
        unint64_t v30 = (char *)*a2;
        unint64_t v29 = (char *)a2[1];
        uint64_t v31 = v27;
        if (v29 != (char *)*a2)
        {
          do
          {
            __int128 v32 = *(_OWORD *)(v29 - 24);
            *((void *)v31 - 1) = *((void *)v29 - 1);
            *(_OWORD *)(v31 - 24) = v32;
            v31 -= 24;
            v29 -= 24;
          }

          while (v29 != v30);
          unint64_t v29 = (char *)*a2;
        }

        unint64_t v13 = v27 + 24;
        *a2 = v31;
        a2[1] = v27 + 24;
        a2[2] = &v26[24 * v25];
        if (v29) {
          operator delete(v29);
        }
      }

      else
      {
        __int128 v22 = *(_OWORD *)v21;
        *((void *)v13 + 2) = *(void *)(v18 - 8);
        *(_OWORD *)unint64_t v13 = v22;
        v13 += 24;
      }

      a2[1] = v13;
      unint64_t v16 = *v11;
      goto LABEL_34;
    }

    double v17 = *(double *)(v12 - 24);
    if (v17 < a3) {
      break;
    }
    unint64_t v18 = v12;
    if (v17 <= a4) {
      goto LABEL_17;
    }
LABEL_34:
    if (v12 == v16)
    {
      uint64_t v33 = *--v11;
      unint64_t v12 = v33 + 4080;
    }

    v12 -= 24LL;
    uint64_t v9 = a1[8];
    uint64_t v10 = a1[9];
  }

  uint64_t v34 = (char *)*a2;
  uint64_t v35 = v13 - 24;
  if ((char *)*a2 != v13 && v35 > v34)
  {
    unint64_t v37 = v34 + 24;
    do
    {
      __int128 v38 = *(_OWORD *)(v37 - 24);
      uint64_t v39 = *((void *)v37 - 1);
      uint64_t v40 = *((void *)v35 + 2);
      *(_OWORD *)(v37 - 24) = *(_OWORD *)v35;
      *((void *)v37 - 1) = v40;
      *((void *)v35 + 2) = v39;
      *(_OWORD *)uint64_t v35 = v38;
      v35 -= 24;
      BOOL v41 = v37 >= v35;
      v37 += 24;
    }

    while (!v41);
  }

void sub_10020F5B0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

BOOL sub_10020F5D0(uint64_t a1, uint64_t a2, double a3)
{
  BOOL v6 = sub_10020C8AC(a1);
  if (v6)
  {
    if (*(void *)(a1 + 2120)) {
      sub_1012307CC();
    }
    uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
    memset(v37, 0, sizeof(v37));
    double v8 = *(double *)a2;
    double v7 = *(double *)(a2 + 8);
    double v9 = a3 - v7;
    BOOL v10 = v7 < a3;
    double v11 = 0.0;
    if (!v10) {
      double v9 = 0.0;
    }
    double v12 = *(double *)(a1 + 2168);
    double v13 = v12 - v9;
    if (v8 < a3) {
      double v11 = a3 - v8;
    }
    double v14 = v12 - v11;
    double v38 = v12 - v9;
    double v39 = v12 - v11;
    double v40 = v8;
    uint64_t v41 = 0LL;
    uint64_t v15 = *(void *)(a1 + 192);
    double v16 = *(float *)(a1 + 1008);
    if (v15) {
      double v17 = *(double *)(*(void *)(*(void *)(a1 + 160) + 8 * ((v15 + *(void *)(a1 + 184) - 1) / 0x1AuLL))
    }
                      + 152 * ((v15 + *(void *)(a1 + 184) - 1) % 0x1AuLL)
                      + 72)
          + v16;
    else {
      double v17 = *(float *)(a1 + 1008);
    }
    double v42 = v17;
    double v43 = v14;
    double v44 = v16;
    uint64_t v45 = 0LL;
    int v46 = (*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 128LL))(a1, v8);
    uint64_t v18 = *(void *)(a1 + 192);
    if (v18) {
      int v19 = *(_DWORD *)(*(void *)(*(void *)(a1 + 160) + 8 * ((v18 + *(void *)(a1 + 184) - 1) / 0x1AuLL))
    }
                      + 152 * ((v18 + *(void *)(a1 + 184) - 1) % 0x1AuLL)
                      + 108)
          + 1;
    else {
      int v19 = 1;
    }
    int v47 = v19;
    __int128 v48 = 0u;
    __int128 v49 = 0u;
    if (*(void *)(a1 + 96))
    {
      int v20 = sub_10020EEF8((void *)a1, (uint64_t)&v26, *(double *)a2);
      int v21 = DWORD1(v27);
      if (!v20) {
        int v21 = 0;
      }
    }

    else
    {
      int v21 = *(_DWORD *)(a1 + 1060);
    }

    int v50 = v21;
    uint64_t v35 = 0LL;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v26 = 0u;
    if ((*(unsigned int (**)(uint64_t, __int128 *))(*(void *)a1 + 120LL))(a1, &v26))
    {
      DWORD2(v48) = DWORD2(v33);
      int v22 = DWORD2(v33) + 1;
    }

    else
    {
      int v22 = 1;
    }

    if (*(_BYTE *)(a2 + 20))
    {
      sub_10020D5BC(a1);
      DWORD2(v48) = v22;
    }

    int v23 = *(_DWORD *)(a2 + 16);
    if (v23)
    {
      if (v23 != 1)
      {
LABEL_27:
        HIDWORD(v45) = (*(uint64_t (**)(uint64_t, void, double, double))(*(void *)a1 + 136LL))( a1,  *(void *)(a1 + 96),  v8 - vabdd_f64(v14, v13),  v8);
        uuid_copy(v37, (const unsigned __int8 *)(a1 + 1014));
        *(void *)&__int128 v49 = sub_1007BC55C((uint64_t)&v36, a1);
        sub_10020BF34(a1, (uint64_t)&v36);
        sub_100F345DC((_OWORD *)(a1 + 1648));
        return v6;
      }

      int v24 = 2;
    }

    else
    {
      int v24 = 1;
    }

    LODWORD(v45) = v24;
    goto LABEL_27;
  }

  return v6;
}

double sub_10020F8AC(uint64_t a1, int a2)
{
  return sub_100F3443C(a1 + 1648, a2);
}

BOOL sub_10020F8B4(uint64_t a1, uint64_t a2, double a3, double a4, double a5)
{
  BOOL result = sub_10020C8AC(a1);
  if (result)
  {
    if (*(_BYTE *)(a1 + 1013))
    {
      double v11 = *(float *)(a1 + 1008);
      int v12 = (*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 128LL))(a1, a3);
      float v13 = sub_1009A0508(a1 + 1544, a3);
      int v14 = *(_DWORD *)(a1 + 1064);
      int v15 = (*(uint64_t (**)(uint64_t, void, double, double))(*(void *)a1 + 136LL))( a1,  *(void *)(a1 + 96),  a3 - a5,  a3);
      if (*(void *)(a1 + 96))
      {
        int v16 = sub_10020EEF8((void *)a1, (uint64_t)v25, a3);
        int v17 = v25[5];
        if (!v16) {
          int v17 = 0;
        }
      }

      else
      {
        int v17 = *(_DWORD *)(a1 + 1060);
      }

      int v18 = 0;
      *(void *)(a2 + 32) = 0LL;
      *(_OWORD *)a2 = 0u;
      *(_OWORD *)(a2 + 16) = 0u;
      *(double *)(a2 + 40) = a4 - a5;
      *(double *)(a2 + 48) = a4;
      *(void *)(a2 + 64) = 0LL;
      *(void *)(a2 + 72) = 0LL;
      *(void *)(a2 + 56) = 0LL;
      *(double *)(a2 + 80) = a4;
      *(double *)(a2 + 88) = v11;
      *(void *)(a2 + 96) = 0LL;
      *(_DWORD *)(a2 + 104) = v12;
      *(_DWORD *)(a2 + 108) = 0;
      *(float *)(a2 + 112) = v13;
      *(_DWORD *)(a2 + 116) = v14;
      *(_DWORD *)(a2 + 120) = 0;
      *(_DWORD *)(a2 + 124) = v15;
      *(void *)(a2 + 128) = 0LL;
      *(void *)(a2 + 136) = 0LL;
      *(_DWORD *)(a2 + 144) = v17;
      if (v13 > 0.0) {
        int v18 = (*(uint64_t (**)(uint64_t, void, double, double))(*(void *)a1 + 136LL))( a1,  *(int *)(a1 + 1624),  0.0,  a3);
      }
      *(_DWORD *)(a2 + 100) = v18;
      uint64_t v19 = *(void *)(a1 + 192);
      if (v19)
      {
        unint64_t v20 = *(void *)(*(void *)(a1 + 160) + 8 * ((v19 + *(void *)(a1 + 184) - 1) / 0x1AuLL))
            + 152 * ((v19 + *(void *)(a1 + 184) - 1) % 0x1AuLL);
        LODWORD(v19) = *(_DWORD *)(v20 + 120);
        int v21 = *(_DWORD *)(v20 + 108);
      }

      else
      {
        int v21 = 0;
      }

      *(_DWORD *)(a2 + 120) = v19;
      *(_DWORD *)(a2 + 108) = v21;
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 176LL))(a1))
      {
        uint64_t v22 = *(void *)(a1 + 192);
        if (v22) {
          double v23 = *(double *)(*(void *)(*(void *)(a1 + 160) + 8 * ((v22 + *(void *)(a1 + 184) - 1) / 0x1AuLL))
        }
                          + 152 * ((v22 + *(void *)(a1 + 184) - 1) % 0x1AuLL)
                          + 72);
        else {
          double v23 = 0.0;
        }
        (*(void (**)(uint64_t, _DWORD *))(*(void *)a1 + 120LL))(a1, v25);
        double v24 = v23 + sub_100F343B0(a1 + 1648, v26);
      }

      else
      {
        double v24 = sub_1007BC038(a1 + 2104);
      }

      *(double *)(a2 + 72) = v24;
      uuid_copy((unsigned __int8 *)(a2 + 8), (const unsigned __int8 *)(a1 + 1014));
      uuid_parse("00000000-0000-0000-0000-000000000000", (unsigned __int8 *)(a2 + 24));
      return 1LL;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

double sub_10020FB78(uint64_t a1, double a2)
{
  return sub_1007BC040((double *)(a1 + 2104), a2);
}

void sub_10020FB80(uint64_t a1, double a2, double a3)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 176LL))(a1) & 1) == 0)
  {
  }

__n128 sub_10020FBE4@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v6 = *(double *)(a1 + 992);
  double v7 = *(double *)(a1 + 2176);
  if (v6 >= v7)
  {
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10182B200);
    }
    int v15 = (os_log_s *)qword_1019344E8;
    if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *(void *)(a1 + 992);
      uint64_t v17 = *(void *)(a1 + 2176);
      *(_DWORD *)buf = 134218240;
      uint64_t v30 = v16;
      __int16 v31 = 2048;
      uint64_t v32 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Session start time should be > session end time, not alterting timestamps, sessionStart, %f, sessionEnd, %f",  buf,  0x16u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_21;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10182B200);
    }
    int v18 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  16LL,  "Session start time should be > session end time, not alterting timestamps, sessionStart, %f, sessionEnd, %f");
    goto LABEL_25;
  }

  double v8 = v6 + 0.1;
  double v9 = v7 + -0.1;
  if (v8 < v9)
  {
    __int128 v10 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a2;
    *(_OWORD *)(a3 + 16) = v10;
    *(void *)(a3 + 32) = *(void *)(a2 + 32);
    *(double *)(a3 + 40) = v8;
    *(double *)(a3 + 48) = v9;
    __int128 v11 = *(_OWORD *)(a2 + 104);
    *(_OWORD *)(a3 + 88) = *(_OWORD *)(a2 + 88);
    *(_OWORD *)(a3 + 104) = v11;
    __int128 v12 = *(_OWORD *)(a2 + 136);
    *(_OWORD *)(a3 + 120) = *(_OWORD *)(a2 + 120);
    *(_OWORD *)(a3 + 136) = v12;
    __n128 result = *(__n128 *)(a2 + 56);
    __int128 v14 = *(_OWORD *)(a2 + 72);
    *(__n128 *)(a3 + 56) = result;
    *(_OWORD *)(a3 + 72) = v14;
    return result;
  }

  if (qword_1019344E0 != -1) {
    dispatch_once(&qword_1019344E0, &stru_10182B200);
  }
  uint64_t v19 = (os_log_s *)qword_1019344E8;
  if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_ERROR))
  {
    uint64_t v20 = *(void *)(a1 + 992);
    uint64_t v21 = *(void *)(a1 + 2176);
    uint64_t v22 = *(void *)(a2 + 40);
    uint64_t v23 = *(void *)(a2 + 48);
    *(_DWORD *)buf = 134218752;
    uint64_t v30 = v20;
    __int16 v31 = 2048;
    uint64_t v32 = v21;
    __int16 v33 = 2048;
    uint64_t v34 = v22;
    __int16 v35 = 2048;
    uint64_t v36 = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "sanitizing entry resulted in startTime > endTime, not altering timestamps, sessionStart, %f, sessionEnd, %f, entry Start, %f, entryEnd, %f",  buf,  0x2Au);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10182B200);
    }
    int v18 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  16LL,  "sanitizing entry resulted in startTime > endTime, not altering timestamps, sessionStart, %f, s essionEnd, %f, entryStart, %f, entryEnd, %f");
LABEL_25:
    __int128 v28 = (uint8_t *)v18;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLSwimEntry CLSwimDataStore::sanitizeEntryStartEndTimes(const CLSwimEntry &)",  "%s\n",  v18);
    if (v28 != buf) {
      free(v28);
    }
  }

__n128 sub_10020FFB4(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 26 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1002119B0(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x1A)) + 152 * (v7 % 0x1A);
  __int128 v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  __int128 v10 = *(_OWORD *)(a2 + 32);
  __int128 v11 = *(_OWORD *)(a2 + 48);
  __int128 v12 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v8 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v8 + 80) = v12;
  *(_OWORD *)(v8 + 32) = v10;
  *(_OWORD *)(v8 + 48) = v11;
  __n128 result = *(__n128 *)(a2 + 96);
  __int128 v14 = *(_OWORD *)(a2 + 112);
  __int128 v15 = *(_OWORD *)(a2 + 128);
  *(void *)(v8 + 144) = *(void *)(a2 + 144);
  *(_OWORD *)(v8 + 112) = v14;
  *(_OWORD *)(v8 + 128) = v15;
  *(__n128 *)(v8 + 96) = result;
  ++a1[5];
  return result;
}

uint64_t sub_100210088(void *a1)
{
  return (*(uint64_t (**)(void *, void))(*a1 + 136LL))(a1, a1[12]);
}

uint64_t sub_100210098(void *a1, unint64_t a2, double a3, double a4)
{
  unint64_t v8 = a1[11] + a1[12];
  uint64_t v9 = a1[8];
  uint64_t v10 = a1[9];
  __int128 v11 = (unint64_t *)(v9 + 8 * (v8 / 0xAA));
  if (v10 == v9) {
    unint64_t v12 = 0LL;
  }
  else {
    unint64_t v12 = *v11 + 24 * (v8 % 0xAA);
  }
  unint64_t v13 = 0LL;
  while (1)
  {
    unint64_t v14 = v10 == v9 ? 0LL : *(void *)(v9 + 8 * (a1[11] / 0xAAuLL)) + 24 * (a1[11] % 0xAAuLL);
    if (v12 == v14) {
      return sub_100DADF74((uint64_t)v24);
    }
    unint64_t v15 = *v11;
    if (v12 == *v11)
    {
      uint64_t v19 = *(v11 - 1);
      double v20 = *(double *)(v19 + 4056);
      if (v20 < a3 || v13 >= a2) {
        return sub_100DADF74((uint64_t)v24);
      }
      if (v20 > a4)
      {
        unint64_t v15 = v12;
        goto LABEL_24;
      }

      unint64_t v18 = v19 + 4080;
LABEL_23:
      sub_100DADF48((uint64_t)v24, *(_DWORD *)(v18 - 16));
      ++v13;
      unint64_t v15 = *v11;
      goto LABEL_24;
    }

    double v16 = *(double *)(v12 - 24);
    if (v16 < a3 || v13 >= a2) {
      return sub_100DADF74((uint64_t)v24);
    }
    unint64_t v18 = v12;
    if (v16 <= a4) {
      goto LABEL_23;
    }
LABEL_24:
    if (v12 == v15)
    {
      uint64_t v22 = *--v11;
      unint64_t v12 = v22 + 4080;
    }

    v12 -= 24LL;
    uint64_t v9 = a1[8];
    uint64_t v10 = a1[9];
  }

void sub_1002101FC(uint64_t a1)
{
}

void sub_100210204(uint64_t a1, double a2)
{
  *(double *)(a1 + 2176) = a2;
  if (qword_1019344E0 != -1) {
    dispatch_once(&qword_1019344E0, &stru_10182B200);
  }
  uint64_t v3 = (os_log_s *)qword_1019344E8;
  if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 134217984;
    double v9 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "data store setting session end time to %f",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10182B200);
    }
    int v6 = 134217984;
    double v7 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  2LL,  "data store setting session end time to %f",  COERCE_DOUBLE(&v6));
    uint64_t v5 = (uint8_t *)v4;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSwimDataStore::setSessionEndTime(CFAbsoluteTime)", "%s\n", v4);
    if (v5 != buf) {
      free(v5);
    }
  }

float sub_1002103B0(uint64_t a1)
{
  return *(float *)(a1 + 1008);
}

uint64_t sub_1002103B8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 1056);
}

BOOL sub_1002103C0(uint64_t a1)
{
  return *(void *)(a1 + 2120) == 0LL;
}

double sub_1002103D0(uint64_t a1)
{
  return *(double *)(a1 + 1000);
}

void sub_1002103D8(id a1)
{
  qword_1019344E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Swimming");
}

void sub_100210404(void **a1)
{
  *a1 = off_10182B230;
  sub_100008390((uint64_t)(a1 + 8), a1[9]);
  sub_100210578(a1 + 2);
  operator delete(a1);
}

void sub_100210444(void *a1)
{
  uint64_t v2 = (void **)a1[3];
  uint64_t v3 = a1[4];
  a1[7] = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = a1[4];
      uint64_t v2 = (void **)(a1[3] + 8LL);
      a1[3] = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 256LL;
    goto LABEL_7;
  }

  if (v4 >> 3 == 2)
  {
    uint64_t v6 = 512LL;
LABEL_7:
    a1[6] = v6;
  }

  unint64_t v8 = (void *)a1[9];
  double v7 = a1 + 9;
  sub_100008390((uint64_t)(v7 - 1), v8);
  *(v7 - 1) = v7;
  void *v7 = 0LL;
  v7[1] = 0LL;
}

void sub_1002104CC(uint64_t a1, double *a2)
{
  uint64_t v3 = (void *)(a1 + 16);
  unint64_t v4 = (uint64_t **)(a1 + 64);
  uint64_t v6 = sub_1000F0468((uint64_t **)(a1 + 64), a2);
  sub_10021060C(v3, &v6);
  if (*(void *)(a1 + 56) > (unint64_t)*(unsigned int *)(a1 + 8))
  {
    sub_1000087E8(v4, v5);
    operator delete(v5);
    *(int64x2_t *)(a1 + 48) = vaddq_s64(*(int64x2_t *)(a1 + 48), (int64x2_t)xmmword_1012CE4D0);
    sub_1002109A4((uint64_t)v3, 1);
  }

uint64_t sub_100210578(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 512LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    double v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void sub_10021060C(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_100210690(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_100210690(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      double v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100210958( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002109A4(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x200) {
    a2 = 1;
  }
  if (v2 < 0x400) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 512LL;
  }

  return v4 ^ 1u;
}

uint64_t sub_100210A00(void *a1)
{
  unint64_t v2 = (void **)a1[1];
  BOOL v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = (void **)a1[2];
      unint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 85LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 170LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

uint64_t sub_100210A94(void *a1)
{
  unint64_t v2 = (void **)a1[1];
  BOOL v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      BOOL v3 = (void **)a1[2];
      unint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 13LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 26LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

_OWORD *sub_100210B28(uint64_t **a1, const void **a2, uint64_t a3)
{
  unint64_t v5 = (void **)sub_1000227E8((uint64_t)a1, &v9, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    uint64_t v6 = operator new(0x58uLL);
    v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0LL;
    *(void *)(a3 + 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    *(_OWORD *)((char *)v6 + 56) = *(_OWORD *)(a3 + 24);
    *(_OWORD *)((char *)v6 + 68) = *(_OWORD *)(a3 + 36);
    sub_1000085FC(a1, v9, v7, (uint64_t *)v6);
  }

  return v6;
}

void sub_100210BC8(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, void **a5)
{
  uint64_t v7 = a2;
  unint64_t v8 = *a5;
  if (a1 == a3)
  {
    while (v7 != a4)
    {
      sub_10020FFB4(v8, v7);
      v7 += 152LL;
    }
  }

  else
  {
    uint64_t v11 = *a1 + 3952;
    if (v11 != a2)
    {
      do
      {
        sub_10020FFB4(v8, v7);
        v7 += 152LL;
      }

      while (v7 != v11);
    }

    *a5 = v8;
    for (uint64_t i = a1 + 1; i != a3; ++i)
    {
      uint64_t v13 = 0LL;
      uint64_t v14 = *i;
      do
      {
        sub_10020FFB4(v8, v14 + v13);
        v13 += 152LL;
      }

      while (v13 != 3952);
      *a5 = v8;
    }

    for (uint64_t j = *a3; j != a4; j += 152LL)
      sub_10020FFB4(v8, j);
  }

  *a5 = v8;
}

uint64_t sub_100210CB8(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x1A) {
    a2 = 1;
  }
  if (v2 < 0x34) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 26LL;
  }

  return v4 ^ 1u;
}

uint64_t sub_100210D14(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = 26 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x1A) {
    a2 = 1;
  }
  if (v5 < 0x34) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

void *sub_100210D88(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x79435E50D79435E5LL * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 25 - v3;
      uint64_t v6 = &v2[-(v5 / 0x1A)];
      *__n128 result = v6;
      unint64_t v4 = *v6 + 152 * (26 * (v5 / 0x1A) - v5) + 3800;
    }

    else
    {
      *__n128 result = &v2[v3 / 0x1A];
      unint64_t v4 = v2[v3 / 0x1A] + 152 * (v3 % 0x1A);
    }

    result[1] = v4;
  }

  return result;
}

__n128 sub_100210E3C@<Q0>( char **a1@<X1>, char *a2@<X2>, char **a3@<X3>, char *a4@<X4>, void *a5@<X5>, char *a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    uint64_t v19 = a2;
    uint64_t v18 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
  }

  else
  {
    uint64_t v13 = a3 - 1;
    uint64_t v12 = *a3;
    uint64_t v14 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
    while (1)
    {
      sub_100210F08(v12, v14, v15, v16, &v21);
      uint64_t v16 = (char *)v22.n128_u64[1];
      uint64_t v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      uint64_t v17 = *v13--;
      uint64_t v12 = v17;
      uint64_t v14 = v17 + 3952;
    }

    uint64_t v18 = *a1 + 3952;
    uint64_t v19 = a2;
  }

  sub_100210F08(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = (unint64_t)a4;
  a7[1] = result;
  return result;
}

void *sub_100210F08@<X0>(char *a1@<X1>, char *a2@<X2>, void *a3@<X3>, char *a4@<X4>, void *a5@<X8>)
{
  uint64_t v6 = a3;
  if (a1 == a2)
  {
    uint64_t v9 = a1;
  }

  else
  {
    uint64_t v9 = a2;
    uint64_t v10 = *a3;
    uint64_t v11 = a2;
    while (1)
    {
      int64_t v12 = 0x86BCA1AF286BCA1BLL * ((uint64_t)&a4[-v10] >> 3);
      v11 -= 152 * v12;
      a4 -= 152 * v12;
      if (v12) {
        __n128 result = memmove(a4, v11, 152 * v12);
      }
      if (v11 == a1) {
        break;
      }
      uint64_t v14 = *--v6;
      uint64_t v10 = v14;
      a4 = (char *)(v14 + 3952);
    }

    if ((char *)(*v6 + 3952LL) == a4)
    {
      uint64_t v15 = (char *)v6[1];
      ++v6;
      a4 = v15;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = a4;
  return result;
}

double sub_100210FE8(void *a1, _BYTE *a2, _BYTE **a3, _BYTE *a4, uint64_t a5)
{
  int v7 = *(void ***)a5;
  unint64_t v8 = *(char **)(a5 + 8);
  if (a1 != a3)
  {
    uint64_t v10 = a1 + 1;
    for (uint64_t i = (_BYTE *)(*a1 + 3952LL); ; uint64_t i = v12 + 3952)
    {
      sub_100211078(a2, v8, i, v7, &v14);
      unint64_t v8 = (char *)*((void *)&v15 + 1);
      int v7 = (void **)v15;
      *(void *)a5 = v15;
      *(void *)(a5 + 8) = v8;
      if (v10 == a3) {
        break;
      }
      int64_t v12 = (_BYTE *)*v10++;
      a2 = v12;
    }

    a2 = *a3;
  }

  sub_100211078(a2, v8, a4, v7, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

void *sub_100211078@<X0>( _BYTE *__src@<X1>, char *__dst@<X4>, _BYTE *a3@<X2>, void **a4@<X3>, void *a5@<X8>)
{
  uint64_t v6 = a4;
  int v7 = __src;
  if (__src == a3)
  {
    uint64_t v9 = __src;
  }

  else
  {
    uint64_t v9 = a3;
    uint64_t v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      int64_t v11 = 0x86BCA1AF286BCA1BLL * ((v10 - __dst + 3952) >> 3);
      unint64_t v12 = (uint64_t)(0x86BCA1AF286BCA1BLL * ((v9 - v7) >> 3)) >= v11 ? v11 : 0x86BCA1AF286BCA1BLL * ((v9 - v7) >> 3);
      if (v12) {
        double result = memmove(__dst, v7, 152 * v12);
      }
      v7 += 152 * v12;
      if (v7 == v9) {
        break;
      }
      uint64_t v14 = (char *)*v6++;
      uint64_t v10 = v14;
      __uuid_t dst = v14;
    }

    __dst += 152 * v12;
    else {
      --v6;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = __dst;
  return result;
}

uint64_t sub_100211164(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0xAA) {
    a2 = 1;
  }
  if (v2 < 0x154) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 170LL;
  }

  return v4 ^ 1u;
}

void sub_1002111C0(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    int v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      double v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100211488( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002114D4(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    int v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      double v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_10021179C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_1002117F0(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = &off_10182B270;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_DWORD *)v2 + 6) = *(_DWORD *)(a1 + 24);
  return result;
}

__n128 sub_100211830(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_10182B270;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL sub_100211858(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  return (v2 == 5 || *(_DWORD *)(a2 + 100) == v2)
      && uuid_compare((const unsigned __int8 *)(a2 + 8), (const unsigned __int8 *)(a1 + 12)) == 0;
}

uint64_t sub_10021189C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1002118D8()
{
}

void *sub_1002118E4(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    __n128 result = sub_10021195C(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_100211940(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_10021195C(void *a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL) {
    sub_100007008();
  }
  __n128 result = (char *)sub_10005057C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[112 * v4];
  return result;
}

void sub_1002119B0(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x1A;
  unint64_t v4 = v2 - 26;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    size_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)size_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      double v38 = (uint64_t *)a1[1];
      size_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        size_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100211C78( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100211CC4()
{
  return os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_FAULT);
}

BOOL sub_100211CD8()
{
  return os_log_type_enabled(*(os_log_t *)(v0 + 1256), OS_LOG_TYPE_INFO);
}

BOOL sub_100211CE8()
{
  return os_signpost_enabled(*(os_log_t *)(v0 + 1256));
}

void sub_100211F2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_100212AE0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

id sub_100212AF4(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(a1 + 32));
  return _[Weak enableBOMScan];
}

NSDictionary *__cdecl sub_100212C60(id a1)
{
  return (NSDictionary *)&off_1018D6620;
}

NSDictionary *sub_100212DC4(uint64_t a1)
{
  v4[0] = @"bomDisableCount";
  unint64_t v2 = +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  *(void *)(a1 + 32));
  v4[1] = @"timeSinceLastDisable";
  v5[0] = v2;
  v5[1] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 40));
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v5,  v4,  2LL);
}

id sub_100213224(uint64_t a1)
{
  if (qword_101934900 != -1) {
    dispatch_once(&qword_101934900, &stru_10182B388);
  }
  unint64_t v2 = (os_log_s *)qword_101934908;
  if (os_log_type_enabled((os_log_t)qword_101934908, OS_LOG_TYPE_INFO))
  {
    v5[0] = 68289026;
    v5[1] = 0;
    __int16 v6 = 2082;
    uint64_t v7 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#ut BOM reset check}",  (uint8_t *)v5,  0x12u);
  }

  BOOL v3 = (id *)(a1 + 32);
  [objc_loadWeak(v3) resetBOMScanIfNeeded];
  return [objc_loadWeak(v3) scheduleDailyResetBOMScan];
}

void sub_100213344(id a1)
{
  qword_101934908 = (uint64_t)os_log_create("com.apple.locationd.Position", "TrackingAvoidance");
}

void sub_1002133C4(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v17 = CMPedestrianFenceIdentifier;
    uint64_t v18 = a2;
    uint64_t v16 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL);
    sub_1002152E0("PedestrianFence/kCLConnectionMessagePedestrianFence", &v16, &v14);
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v12 = v14;
    uint64_t v13 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
    }

    CLConnection::sendMessage(v3, &v12);
    __int16 v6 = v13;
    if (v13)
    {
      uint64_t v7 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }

    uint64_t v9 = v15;
    if (v15)
    {
      uint64_t v10 = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }

void sub_1002134FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  sub_10000AE14((uint64_t)va);
  sub_10000AE14((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_10021352C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v17 = CMErrorMessage;
    uint64_t v18 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", a2);
    uint64_t v16 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL);
    sub_1002152E0("PedestrianFence/kCLConnectionMessagePedestrianFence", &v16, &v14);
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v12 = v14;
    uint64_t v13 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
    }

    CLConnection::sendMessage(v3, &v12);
    __int16 v6 = v13;
    if (v13)
    {
      uint64_t v7 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }

    uint64_t v9 = v15;
    if (v15)
    {
      uint64_t v10 = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }

void sub_100213678(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  sub_10000AE14((uint64_t)va);
  sub_10000AE14((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1002136A8(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 8))
  {
    id v3 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    id obj = [a2 allKeys];
    id v4 = [obj countByEnumeratingWithState:&v25 objects:v33 count:16];
    if (v4)
    {
      uint64_t v5 = *(void *)v26;
      do
      {
        for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v26 != v5) {
            objc_enumerationMutation(obj);
          }
          uint64_t v7 = *(void *)(*((void *)&v25 + 1) + 8LL * (void)i);
          id v8 = [a2 objectForKeyedSubscript:v7];
          v31[0] = @"radius";
          [v8 radius];
          v32[0] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:");
          v31[1] = @"radialDisplacement";
          [v8 radialDisplacement];
          v32[1] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:");
          v31[2] = @"duration";
          [v8 duration];
          v32[2] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:");
          objc_msgSend( v3,  "setObject:forKeyedSubscript:",  +[NSDictionary dictionaryWithObjects:forKeys:count:]( NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v32,  v31,  3),  v7);
        }

        id v4 = [obj countByEnumeratingWithState:&v25 objects:v33 count:16];
      }

      while (v4);
    }

    uint64_t v29 = CMPedestrianFenceStatus;
    id v30 = v3;
    uint64_t v24 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v30,  &v29,  1LL);
    sub_100215458("PedestrianFence/kCLConnectionMessagePedestrianFenceStatus", &v24, &v22);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v20 = v22;
    uint64_t v21 = v23;
    if (v23)
    {
      p_shared_owners = (unint64_t *)&v23->__shared_owners_;
      do
        unint64_t v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }

    CLConnection::sendMessage(v9, &v20);
    uint64_t v12 = v21;
    if (v21)
    {
      uint64_t v13 = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }

    uint64_t v15 = v23;
    if (v23)
    {
      uint64_t v16 = (unint64_t *)&v23->__shared_owners_;
      do
        unint64_t v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
  }

void sub_100213940(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_10000AE14((uint64_t)va);
  sub_10000AE14((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1002139D8(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 8))
  {
    uint64_t v17 = CMBackgroundInertialOdometry;
    uint64_t v18 = a2;
    uint64_t v16 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL);
    sub_1002154B8("PedestrianFence/kCLConnectionMessageBackgroundInertialOdometry", &v16, &v14);
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v12 = v14;
    uint64_t v13 = v15;
    if (v15)
    {
      p_shared_owners = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v5 = __ldxr(p_shared_owners);
      while (__stxr(v5 + 1, p_shared_owners));
    }

    CLConnection::sendMessage(v3, &v12);
    __int16 v6 = v13;
    if (v13)
    {
      uint64_t v7 = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }

    uint64_t v9 = v15;
    if (v15)
    {
      uint64_t v10 = (unint64_t *)&v15->__shared_owners_;
      do
        unint64_t v11 = __ldaxr(v10);
      while (__stlxr(v11 - 1, v10));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
  }

void sub_100213B10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  sub_10000AE14((uint64_t)va);
  sub_10000AE14((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_100213B54(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(void *)a1 = off_10182B3B8;
  *(_BYTE *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 112) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = 0LL;
  *(_BYTE *)(a1 + 88) = 0;
  uint64_t v5 = -[CLPedestrianFenceClientDelegate initWithPedestrianFenceClient:]( objc_alloc(&OBJC_CLASS___CLPedestrianFenceClientDelegate),  "initWithPedestrianFenceClient:",  a1);
  *(void *)(a1 + 24) = v5;
  -[CLPedestrianFenceClientDelegate setValid:](v5, "setValid:", 1LL);
  id v6 = objc_msgSend(objc_msgSend(a3, "vendor"), "proxyForService:", @"CLPedestrianFenceService");
  *(void *)(a1 + 32) = v6;
  objc_msgSend(v6, "registerDelegate:inSilo:", *(void *)(a1 + 24), objc_msgSend(a3, "silo"));
  [*(id *)(a1 + 32) setDelegateEntityName:"CLPedestrianFenceClient"];
  uint64_t v7 = -[CLBackgroundInertialOdometryClientDelegate initWithPedestrianFenceClient:]( objc_alloc(&OBJC_CLASS___CLBackgroundInertialOdometryClientDelegate),  "initWithPedestrianFenceClient:",  a1);
  *(void *)(a1 + 40) = v7;
  -[CLBackgroundInertialOdometryClientDelegate setValid:](v7, "setValid:", 1LL);
  id v8 = objc_msgSend(objc_msgSend(a3, "vendor"), "proxyForService:", @"CLBackgroundInertialOdometryService");
  *(void *)(a1 + 48) = v8;
  objc_msgSend(v8, "registerDelegate:inSilo:", *(void *)(a1 + 40), objc_msgSend(a3, "silo"));
  [*(id *)(a1 + 48) setDelegateEntityName:"CLBackgroundInertialOdometryService"];
  uint64_t v9 = *(void *)(a1 + 8);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  v13[2] = sub_100213D3C;
  v13[3] = &unk_10182B3E0;
  v13[4] = a1;
  CLConnection::setDefaultMessageHandler(v9, v13);
  uint64_t v10 = *(void *)(a1 + 8);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  v12[2] = sub_100213DDC;
  v12[3] = &unk_10181D3D0;
  v12[4] = a1;
  CLConnection::setDisconnectionHandler(v10, v12);
  return a1;
}

void sub_100213D08(_Unwind_Exception *a1)
{
}

void sub_100213D3C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v9 = *a2;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 16LL))(v2, &v9);
  id v6 = v10;
  if (v10)
  {
    uint64_t v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_100213DC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id sub_100213DDC(uint64_t a1)
{
  return sub_100213DE4(*(void *)(a1 + 32));
}

id sub_100213DE4(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) teardownClient:*(void *)(a1 + 24)];
  if (*(_BYTE *)(a1 + 56))
  {
    uint64_t v3 = (void *)(a1 + 64);
    id result = objc_msgSend( *(id *)(a1 + 32),  "odometryClient:requestInterval:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v3),  &off_1018D5298);
  }

  if (*(_BYTE *)(a1 + 88)) {
    return [*(id *)(a1 + 48) stopBackgroundInertialOdometryUpdatesForClient:*(void *)(a1 + 40)];
  }
  return result;
}

void *sub_100213E60(void *a1)
{
  *a1 = off_10182B438;
  uint64_t v2 = (CLConnection *)a1[1];
  if (v2)
  {
    CLConnection::deferredDelete(v2);
    a1[1] = 0LL;
  }

  return a1;
}

void *sub_100213EA8(uint64_t a1)
{
  *(void *)a1 = off_10182B3B8;

  *(void *)(a1 + 32) = 0LL;
  [*(id *)(a1 + 24) setValid:0];

  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 48) = 0LL;
  [*(id *)(a1 + 40) setValid:0];

  *(void *)(a1 + 40) = 0LL;
  return sub_100213E60((void *)a1);
}

void sub_100213F44(uint64_t a1)
{
  uint64_t v1 = sub_100213EA8(a1);
  operator delete(v1);
}

void sub_100213F58(uint64_t a1, CLConnectionMessage **a2)
{
  id v4 = (void *)CLConnectionMessage::name(*a2);
  int v5 = *((char *)v4 + 23);
  if (v5 < 0)
  {
    if (v4[1] != 52LL) {
      goto LABEL_7;
    }
    id v4 = (void *)*v4;
  }

  else if (v5 != 52)
  {
    goto LABEL_7;
  }

  if (!memcmp(v4, "PedestrianFence/kCLConnectionMessageInertialOdometry", 0x34uLL)) {
    goto LABEL_16;
  }
LABEL_7:
  id v6 = (void *)CLConnectionMessage::name(*a2);
  int v7 = *((char *)v6 + 23);
  if ((v7 & 0x80000000) == 0)
  {
    if (v7 != 62) {
      goto LABEL_13;
    }
LABEL_12:
    if (memcmp(v6, "PedestrianFence/kCLConnectionMessageBackgroundInertialOdometry", 0x3EuLL)) {
      goto LABEL_13;
    }
LABEL_16:
    uint64_t v11 = *(void *)(a1 + 8);
    sub_1010DDBC0(__p, "com.apple.locationd.inertialodometry");
    char isEntitled = CLConnection::isEntitled(v11, __p);
    char v13 = isEntitled;
    if (v62 < 0)
    {
      operator delete(*(void **)__p);
      if ((v13 & 1) != 0) {
        goto LABEL_29;
      }
    }

    else if ((isEntitled & 1) != 0)
    {
      goto LABEL_29;
    }

    if (qword_101934790 != -1) {
      dispatch_once(&qword_101934790, &stru_10182B460);
    }
    uint64_t v20 = (os_log_s *)qword_101934798;
    if (os_log_type_enabled((os_log_t)qword_101934798, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__p = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Subscription: Client not entitled.", __p, 2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return;
    }
    bzero(__p, 0x65CuLL);
    if (qword_101934790 != -1) {
      dispatch_once(&qword_101934790, &stru_10182B460);
    }
    LOWORD(v59) = 0;
    uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934798,  16LL,  "Subscription: Client not entitled.",  &v59,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLPedestrianFenceClient::handleMessage(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v15);
    goto LABEL_46;
  }

  if (v6[1] == 62LL)
  {
    id v6 = (void *)*v6;
    goto LABEL_12;
  }

void sub_100214730( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
}

void sub_100214798(uint64_t a1, CLConnectionMessage **a2)
{
  Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
  id v4 = [Dictionary objectForKey:@"kCLConnectionMessageSubscribeKey"];
  if (!v4)
  {
    if (qword_101934780 != -1) {
      dispatch_once(&qword_101934780, &stru_10182B480);
    }
    uint64_t v12 = (os_log_s *)qword_101934788;
    if (os_log_type_enabled((os_log_t)qword_101934788, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "Couldn't get value for kCLConnectionMessageSubscribeKey key",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934780 != -1) {
      dispatch_once(&qword_101934780, &stru_10182B480);
    }
    LOWORD(v21[0]) = 0;
    char v13 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934788,  17LL,  "Couldn't get value for kCLConnectionMessageSubscribeKey key",  v21,  2,  v21[0]);
LABEL_36:
    uint64_t v20 = (uint8_t *)v13;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLPedestrianFenceClient::handleMessagePedestrianFenceUpdate(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v13);
    if (v20 != buf) {
      free(v20);
    }
    return;
  }

  int v5 = v4;
  id v6 = [Dictionary objectForKey:CMPedestrianFenceIdentifier];
  if (!v6)
  {
    if (qword_101934780 != -1) {
      dispatch_once(&qword_101934780, &stru_10182B480);
    }
    uint64_t v14 = (os_log_s *)qword_101934788;
    if (os_log_type_enabled((os_log_t)qword_101934788, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "Invalid paramaters!", buf, 2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934780 != -1) {
      dispatch_once(&qword_101934780, &stru_10182B480);
    }
    LOWORD(v21[0]) = 0;
    char v13 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934788,  17LL,  "Invalid paramaters!",  v21,  2,  v21[0]);
    goto LABEL_36;
  }

  id v7 = v6;
  if (![v5 BOOLValue])
  {
    id v15 = [Dictionary objectForKey:CMPedestrianFenceForceClear];
    id v16 = [Dictionary objectForKey:CMPedestrianFenceForceClearAll];
    if ([v15 BOOLValue])
    {
      unsigned int v17 = [v16 BOOLValue];
      uint64_t v18 = *(void **)(a1 + 32);
      if (v17) {
        _[v18 forceClearAllFences];
      }
      else {
        _objc_msgSend(v18, "forceClearFence:");
      }
    }

    else
    {
      [*(id *)(a1 + 32) clearFence:v7 forClient:*(void *)(a1 + 24)];
    }

    return;
  }

  id v8 = [Dictionary objectForKey:CMPedestrianFenceRadius];
  if (v8)
  {
    uint64_t v11 = a1 + 24;
    uint64_t v9 = *(void *)(a1 + 24);
    char v10 = *(void **)(v11 + 8);
    [v8 floatValue];
    objc_msgSend(v10, "setFence:forClient:withRadius:", v7, v9);
    return;
  }

  if (qword_101934780 != -1) {
    dispatch_once(&qword_101934780, &stru_10182B480);
  }
  int v19 = (os_log_s *)qword_101934788;
  if (os_log_type_enabled((os_log_t)qword_101934788, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "Invalid parameters!", buf, 2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934780 != -1) {
      dispatch_once(&qword_101934780, &stru_10182B480);
    }
    LOWORD(v21[0]) = 0;
    char v13 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934788,  17LL,  "Invalid parameters!",  v21,  2,  v21[0]);
    goto LABEL_36;
  }

void sub_100214C60(uint64_t a1, CLConnectionMessage **a2)
{
  Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
  id v4 = [Dictionary objectForKey:CMPedestrianFenceIdentifier];
  id v5 = [Dictionary objectForKey:CMPedestrianFenceDelay];
  id v6 = [Dictionary objectForKey:CMPedestrianFenceShouldWake];
  if (v4) {
    BOOL v7 = v5 == 0LL;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7 || v6 == 0LL)
  {
    if (qword_101934780 != -1) {
      dispatch_once(&qword_101934780, &stru_10182B480);
    }
    uint64_t v9 = (os_log_s *)qword_101934788;
    if (os_log_type_enabled((os_log_t)qword_101934788, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "Invalid simulation paramaters!", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934780 != -1) {
        dispatch_once(&qword_101934780, &stru_10182B480);
      }
      v16[0] = 0;
      uint64_t v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934788,  17LL,  "Invalid simulation paramaters!",  v16,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLPedestrianFenceClient::handleMessagePedestrianFenceSimulation(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v14);
    }
  }

  else
  {
    char v10 = v6;
    uint64_t v13 = a1 + 24;
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void **)(v13 + 8);
    [v5 doubleValue];
    _objc_msgSend(v12, "simulateFence:forClient:withExitAfterDelay:wake:", v4, v11, objc_msgSend(v10, "BOOLValue"), v15);
  }

void sub_100214EB8(uint64_t a1, CLConnectionMessage **a2)
{
  Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
  id v4 = [Dictionary objectForKey:@"kCLConnectionMessageSubscribeKey"];
  if (v4)
  {
    unsigned int v5 = [v4 BOOLValue];
    uint64_t v8 = a1 + 24;
    uint64_t v7 = *(void *)(a1 + 24);
    id v6 = *(void **)(v8 + 8);
    if (v5) {
      objc_msgSend( v6,  "startSessionForClient:withIdentifier:",  v7,  objc_msgSend(Dictionary, "objectForKey:", CMPedestrianFenceClientIdentifier));
    }
    else {
      [v6 endSessionForClient:v7];
    }
  }

  else
  {
    if (qword_101934780 != -1) {
      dispatch_once(&qword_101934780, &stru_10182B480);
    }
    uint64_t v9 = (os_log_s *)qword_101934788;
    if (os_log_type_enabled((os_log_t)qword_101934788, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "Couldn't get value for inSession key", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934780 != -1) {
        dispatch_once(&qword_101934780, &stru_10182B480);
      }
      v11[0] = 0;
      char v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934788,  17LL,  "Couldn't get value for inSession key",  v11,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLPedestrianFenceClient::handleMessagePedestrianFenceSession(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v10);
    }
  }

id sub_1002150E8(uint64_t a1, CLConnectionMessage **a2)
{
  Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
  id v4 = [Dictionary objectForKey:CMInertialOdometryUpdateInterval];
  id result = [Dictionary objectForKey:CMPedestrianFenceClientIdentifier];
  if (v4) {
    BOOL v6 = result == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    id v7 = result;
    *(_BYTE *)(a1 + 56) = 1;
    sub_1010DDBC0(&v9, (char *)[result UTF8String]);
    uint64_t v8 = (void **)(a1 + 64);
    *(_OWORD *)uint64_t v8 = v9;
    *(void *)(a1 + 80) = v10;
    return [*(id *)(a1 + 32) odometryClient:v7 requestInterval:v4];
  }

  return result;
}

id sub_1002151A4(uint64_t a1, CLConnectionMessage **a2)
{
  Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
  id v4 = [Dictionary objectForKey:CMPedestrianFenceClientIdentifier];
  id result = [Dictionary objectForKey:@"kCLConnectionMessageSubscribeKey"];
  if (v4) {
    BOOL v6 = result == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    id v7 = result;
    *(_BYTE *)(a1 + 88) = 1;
    sub_1010DDBC0(&v12, (char *)[v4 UTF8String]);
    uint64_t v8 = (void **)(a1 + 96);
    *(_OWORD *)uint64_t v8 = v12;
    *(void *)(a1 + 112) = v13;
    unsigned int v9 = [v7 BOOLValue];
    uint64_t v11 = *(void *)(a1 + 40);
    uint64_t v10 = *(void **)(a1 + 48);
    if (v9) {
      return [v10 startBackgroundInertialOdometryUpdatesForClient:v11 withIdentifier:v4 usingReferenceFrame:1];
    }
    else {
      return [v10 stopBackgroundInertialOdometryUpdatesForClient:v11];
    }
  }

  return result;
}

uint64_t sub_100215278(uint64_t a1)
{
  return CLConnection::getName(*(CLConnection **)(a1 + 8));
}

uint64_t sub_100215280()
{
  return 0LL;
}

void sub_100215288(id a1)
{
  qword_101934798 = (uint64_t)os_log_create("com.apple.locationd.Motion", "InertialOdometry");
}

void sub_1002152B4(id a1)
{
  qword_101934788 = (uint64_t)os_log_create("com.apple.locationd.Motion", "PedestrianFence");
}

void *sub_1002152E0@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  BOOL v6 = operator new(0x70uLL);
  id result = sub_100215340(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_10021532C(_Unwind_Exception *a1)
{
}

void *sub_100215340(void *a1, char *__s, void *a3)
{
  a1[2] = 0LL;
  *a1 = off_10182B4B0;
  a1[1] = 0LL;
  sub_1002153E8((int)&v5, (uint64_t)(a1 + 3), __s, a3);
  return a1;
}

void sub_100215390(_Unwind_Exception *a1)
{
}

void sub_1002153A4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182B4B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002153B8(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182B4B0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_1002153DC(uint64_t a1)
{
}

void sub_1002153E8(int a1, uint64_t a2, char *__s, void *a4)
{
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10021543C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100215458@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  BOOL v6 = operator new(0x70uLL);
  id result = sub_100215340(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_1002154A4(_Unwind_Exception *a1)
{
}

void *sub_1002154B8@<X0>(char *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  BOOL v6 = operator new(0x70uLL);
  id result = sub_100215340(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_100215504(_Unwind_Exception *a1)
{
}

float sub_100215518(uint64_t a1, float a2, float a3, float a4, float a5)
{
  float v5 = (float)(1.0 / a3) / 6.28318531;
  *(float *)a1 = v5;
  *(float *)(a1 + 4) = a2;
  unint64_t v6 = (unint64_t)(float)(a4 / a2);
  float result = a5 / a2;
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 16) = (unint64_t)result;
  return result;
}

float sub_100215550(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)(a1 + 8) >= a3) {
    unint64_t v3 = a3;
  }
  else {
    unint64_t v3 = *(void *)(a1 + 8);
  }
  if (*(void *)(a1 + 16) >= a3) {
    unint64_t v4 = a3;
  }
  else {
    unint64_t v4 = *(void *)(a1 + 16);
  }
  double v5 = 0.0;
  BOOL v6 = v4 > v3;
  unint64_t v7 = v4 - v3;
  if (v6)
  {
    unint64_t v8 = 0LL;
    uint64_t v9 = a2 + 4 * v3;
    float v10 = 0.0;
    float v11 = 0.0;
    do
    {
      float v12 = *(float *)(v9 + 4 * v8++);
      float v13 = v12 - v11;
      float v11 = v11 + (float)((float)(v12 - v11) / (float)v8);
      float v10 = v10 + (float)(v13 * (float)(v12 - v11));
    }

    while (v7 != v8);
    if (v7 >= 2) {
      double v5 = (float)(v10 / (float)(v7 - 1));
    }
  }

  return pow(v5, 4.0);
}

float sub_1002155DC(uint64_t a1, uint64_t a2, float *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v4 = 0LL;
    unint64_t v5 = 0LL;
    float v6 = 3.4028e38;
    do
    {
      if (*(float *)(a2 + 4 * v4) < v6)
      {
        float v6 = *(float *)(a2 + 4 * v4);
        unint64_t v5 = v4;
      }

      ++v4;
    }

    while (a4 != v4);
  }

  else
  {
    unint64_t v5 = 0LL;
    float v6 = 3.4028e38;
  }

  if (v5 >= a4)
  {
    float v8 = 0.0;
  }

  else
  {
    unint64_t v7 = 0LL;
    do
    {
      if (*(float *)(a2 + 4 * v5) > v6)
      {
        float v6 = *(float *)(a2 + 4 * v5);
        unint64_t v7 = v5;
      }

      ++v5;
    }

    while (a4 != v5);
    float v8 = (float)v7;
  }

  *a3 = fmaxf(v6, 0.0);
  return *(float *)(a1 + 4) * v8;
}

id sub_100215F28(uint64_t a1, void *a2)
{
  if (!*(void *)(a1 + 128)) {
    *(void *)(a1 + 128) = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CS Session");
  }
  *(_BYTE *)(a1 + 200) = 0;
  [*(id *)(a1 + 8) setSessionStalenessInterval:5];
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56)))
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    unint64_t v5 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "@GtsWarn, GizmoSync, handleStartSession, #CloneMe",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      v7[0] = 0;
      float v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsWarn, GizmoSync, handleStartSession, #CloneMe",  v7,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "NSDictionary *CLTileSyncManager::handleStartSession(NSDictionary *)",  "%s\n",  v6);
    }
  }

  return 0LL;
}

void sub_100216868(uint64_t a1)
{
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  uint64_t v2 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    int v3 = *(char *)(a1 + 192);
    *(_DWORD *)buf = 67240192;
    int v8 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "@GtsSync, CsSync, handleServiceError, %{public}c",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v4 = *(char *)(a1 + 192);
    v6[0] = 67240192;
    v6[1] = v4;
    unint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsSync, CsSync, handleServiceError, %{public}c",  v6,  8);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::handleServiceError()", "%s\n", v5);
  }

uint64_t sub_100216D2C(uint64_t a1, void *a2)
{
  return 256LL;
}

void sub_1002170F8(uint64_t a1, void *a2)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56)))
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v4 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "@GtsWarn, GizmoSync, handleApplyChanges, #CloneMe",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      *(_WORD *)__p = 0;
      unint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsWarn, GizmoSync, handleApplyChanges, #CloneMe",  __p,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncManager::handleApplyChanges(CLTileSyncSyChange *)",  "%s\n",  v5);
    }
  }

  else
  {
    id v6 = [a2 properties];
    id v7 = [v6 objectForKey:@"kSYDictionaryObjectSyncIDKey"];
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v8 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      id v22 = [v7 UTF8String];
      __int16 v23 = 2050;
      id v24 = [a2 changeType];
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "@GtsMgr, change, syncId, %{public}s, type, %{public}ld",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      uint64_t v12 = qword_101934868;
      *(_DWORD *)__p = 136446466;
      *(void *)&__p[4] = [v7 UTF8String];
      __int16 v18 = 2050;
      id v19 = [a2 changeType];
      float v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v12,  1LL,  "@GtsMgr, change, syncId, %{public}s, type, %{public}ld",  __p,  22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncManager::handleApplyChanges(CLTileSyncSyChange *)",  "%s\n",  v13);
    }

    if (v7)
    {
      id v9 = [v6 objectForKey:@"kCLTileSyncObjectDataKey"];
      objc_msgSend(objc_msgSend(v6, "objectForKey:", @"kCLTileSyncObjectSyncTimestampKey"), "doubleValue");
      uint64_t v16 = v10;
      sub_1010DDBC0(__p, (char *)[v7 UTF8String]);
      sub_1008AD02C(buf, __p);
      if (v20 < 0) {
        operator delete(*(void **)__p);
      }
      sub_100220884(a1, (int *)buf, v9, (double *)&v16);
      if (v26 < 0) {
        operator delete(v25);
      }
    }

    else
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      float v11 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "@GtsCont, change with no data!!!", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        *(_WORD *)__p = 0;
        LODWORD(v15) = 2;
        uint64_t v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsCont, change with no data!!!",  __p,  v15);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncManager::handleApplyChanges(CLTileSyncSyChange *)",  "%s\n",  v14);
      }
    }

    *(_BYTE *)(a1 + 193) = 1;
  }

void sub_100217608( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100217B18(uint64_t a1, int a2)
{
  int v4 = *(unsigned __int8 *)(a1 + 160);
  BOOL v6 = v4 == 73 || v4 == 82;
  if (a2) {
    int v7 = *(_DWORD *)(a1 + 196) + 1;
  }
  else {
    int v7 = 0;
  }
  *(_DWORD *)(a1 + 196) = v7;
  double v8 = (*(double (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56));
  sub_10021B900(a1 + 208, a2, v8);
  if (!*(_BYTE *)(a1 + 193))
  {
    sub_100222E28((uint64_t *)(a1 + 168));
    if (!*(_BYTE *)(a1 + 200)) {
      *(_BYTE *)(a1 + 192) = 88;
    }
  }

  *(_BYTE *)(a1 + 193) = 0;
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    int v10 = *(_DWORD *)(a1 + 196);
    if (v10 <= 3)
    {
      if (v10 == 1 || *(_BYTE *)(a1 + 120))
      {
        float v11 = "CsErrorShort";
        double v12 = 30.0;
      }

      else
      {
        float v11 = "CsErrorLong";
        double v12 = 600.0;
      }

      sub_10021CBAC(a1, (uint64_t)v11, v12);
    }
  }

  *(void *)(a1 + 128) = 0LL;
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  float v13 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    int v14 = *(_DWORD *)(a1 + 196);
    int v15 = *(char *)(a1 + 192);
    int v16 = *(unsigned __int8 *)(a1 + 200);
    int v17 = *(char *)(a1 + 160);
    unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
    int v19 = *(unsigned __int8 *)(a1 + 120);
    *(_DWORD *)buf = 67241984;
    int v44 = a2;
    __int16 v45 = 1026;
    int v46 = v14;
    __int16 v47 = 1026;
    int v48 = v15;
    __int16 v49 = 1026;
    int v50 = v16;
    __int16 v51 = 1026;
    BOOL v52 = v6;
    __int16 v53 = 1026;
    int v54 = v17;
    __int16 v55 = 2050;
    unint64_t v56 = v18;
    __int16 v57 = 1026;
    int v58 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "@GtsMgr, handleSessionDidEnd, error, %{public}d, %{public}d, change, %{public}c, pending, %{public}d, psActive, %{ public}d, syncState, %{public}c, queue, %{public}ld, exchanged, %{public}d",  buf,  0x36u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v21 = *(_DWORD *)(a1 + 196);
    int v22 = *(char *)(a1 + 192);
    int v23 = *(unsigned __int8 *)(a1 + 200);
    int v24 = *(char *)(a1 + 160);
    unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
    int v26 = *(unsigned __int8 *)(a1 + 120);
    v28[0] = 67241984;
    v28[1] = a2;
    __int16 v29 = 1026;
    int v30 = v21;
    __int16 v31 = 1026;
    int v32 = v22;
    __int16 v33 = 1026;
    int v34 = v23;
    __int16 v35 = 1026;
    BOOL v36 = v6;
    __int16 v37 = 1026;
    int v38 = v24;
    __int16 v39 = 2050;
    unint64_t v40 = v25;
    __int16 v41 = 1026;
    int v42 = v26;
    __int128 v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsMgr, handleSessionDidEnd, error, %{public}d, %{public}d, change, %{public}c, pending, %{public}d , psActive, %{public}d, syncState, %{public}c, queue, %{public}ld, exchanged, %{public}d",  v28,  54);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLTileSyncManager::handleSessionDidEnd(BOOL)", "%s\n", v27);
  }

  *(_BYTE *)(a1 + 120) = 0;
  return v6;
}

void sub_100218228(uint64_t a1, void *a2)
{
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  int v4 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    id v5 = objc_msgSend(objc_msgSend(a2, "UUIDString"), "UTF8String");
    double v6 = (*(double (**)(void))(**(void **)(a1 + 56) + 56LL))(*(void *)(a1 + 56));
    *(_DWORD *)buf = 136446466;
    id v16 = v5;
    __int16 v17 = 2050;
    double v18 = v6 / 86400.0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "@GtsMgr, willSwitch, new, %{public}s, days inactive, %{public}0.1f",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    uint64_t v7 = qword_101934868;
    id v8 = objc_msgSend(objc_msgSend(a2, "UUIDString"), "UTF8String");
    double v9 = (*(double (**)(void))(**(void **)(a1 + 56) + 56LL))(*(void *)(a1 + 56));
    int v11 = 136446466;
    id v12 = v8;
    __int16 v13 = 2050;
    double v14 = v9 / 86400.0;
    int v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  1LL,  "@GtsMgr, willSwitch, new, %{public}s, days inactive, %{public}0.1f",  &v11,  22);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::handleWillSwitch(NSUUID *)", "%s\n", v10);
  }

void sub_100218674(uint64_t a1, int a2, int a3)
{
  int v6 = *(char *)(a1 + 160);
  [*(id *)(a1 + 8) setSessionStalenessInterval:5];
  int v7 = 88;
  if (a2 && (a3 & 1) == 0)
  {
    sub_10021D2E8(a1);
    if (*(_BYTE *)(a1 + 136)) {
      char v8 = 76;
    }
    else {
      char v8 = 83;
    }
    *(_BYTE *)(a1 + 160) = v8;
    int v7 = 82;
  }

  if (a3 && (a2 & 1) == 0)
  {
    [*(id *)(a1 + 8) suspend];
    *(_BYTE *)(a1 + 160) = 76;
    int v7 = 83;
  }

  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  double v9 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    int v10 = *(char *)(a1 + 160);
    int v11 = *(unsigned __int8 *)(a1 + 136);
    double v12 = (*(double (**)(void))(**(void **)(a1 + 56) + 56LL))(*(void *)(a1 + 56));
    *(_DWORD *)buf = 67241728;
    int v32 = a2;
    __int16 v33 = 1026;
    int v34 = a3;
    __int16 v35 = 1026;
    int v36 = v7;
    __int16 v37 = 1026;
    int v38 = v6;
    __int16 v39 = 1026;
    int v40 = v10;
    __int16 v41 = 1026;
    int v42 = v11;
    __int16 v43 = 2050;
    double v44 = v12 / 86400.0;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "@GtsMgr, handlePairSwitch, ids ,%{public}d, %{public}d, resume/suspend, %{public}c, state, %{public}c, %{public}c, restricted, %{public}d, inactive, %{public}0.1f",  buf,  0x30u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    uint64_t v13 = qword_101934868;
    int v14 = *(char *)(a1 + 160);
    int v15 = *(unsigned __int8 *)(a1 + 136);
    double v16 = (*(double (**)(void))(**(void **)(a1 + 56) + 56LL))(*(void *)(a1 + 56));
    v18[0] = 67241728;
    v18[1] = a2;
    __int16 v19 = 1026;
    int v20 = a3;
    __int16 v21 = 1026;
    int v22 = v7;
    __int16 v23 = 1026;
    int v24 = v6;
    __int16 v25 = 1026;
    int v26 = v14;
    __int16 v27 = 1026;
    int v28 = v15;
    __int16 v29 = 2050;
    double v30 = v16 / 86400.0;
    __int16 v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  1LL,  "@GtsMgr, handlePairSwitch, ids ,%{public}d, %{public}d, resume/suspend, %{public}c, state, %{public} c, %{public}c, restricted, %{public}d, inactive, %{public}0.1f",  v18,  48);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::handlePairingSwitch(BOOL, BOOL)", "%s\n", v17);
  }

id sub_100218B64(uint64_t a1)
{
  id v2 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "activeSyncSession"), "syncSessionType");
  id v3 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "activeSyncSession"), "syncSessionType");
  int v4 = "Unknown";
  if (v3 == (id)1) {
    int v4 = "Reunion";
  }
  if (v3) {
    id v5 = v4;
  }
  else {
    id v5 = "Full";
  }
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  int v6 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    int v14 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "@GtsFlow, PS, handleSyncTrapTurn%s, 1",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v11 = 136315138;
    double v12 = v5;
    double v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsFlow, PS, handleSyncTrapTurn%s, 1",  (const char *)&v11);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLTileSyncDelegate syncCoordinator:beginSyncSession:]_block_invoke",  "%s\n",  v9);
  }

  id result = (id)sub_100218EA4(*(void *)(*(void *)(a1 + 40) + 8LL), v2 == 0LL);
  if ((_DWORD)result)
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    char v8 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "@GtsFlow, PS, syncDidCompleteTx, 2, skipped",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      LOWORD(v11) = 0;
      int v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsFlow, PS, syncDidCompleteTx, 2, skipped",  &v11,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLTileSyncDelegate syncCoordinator:beginSyncSession:]_block_invoke",  "%s\n",  v10);
    }

    return [*(id *)(*(void *)(a1 + 40) + 24) syncDidComplete];
  }

  return result;
}

uint64_t sub_100218EA4(uint64_t a1, int a2)
{
  int v3 = *(char *)(a1 + 160);
  if (a2) {
    char v4 = 73;
  }
  else {
    char v4 = 82;
  }
  *(_BYTE *)(a1 + 160) = v4;
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 48LL))(*(void *)(a1 + 56)))
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    id v5 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "@GtsMgr, xSyncTrap, canDownload", buf, 2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 1LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    *(_WORD *)int v24 = 0;
    int v6 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsMgr, xSyncTrap, canDownload",  v24,  2,  *(_OWORD *)v24,  *(void *)&v24[16],  v25[0]);
LABEL_39:
    __int16 v19 = (uint8_t *)v6;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLTileSyncManager::handleSyncTrapTurn(BOOL)", "%s\n", v6);
    if (v19 != buf) {
      free(v19);
    }
    return 1LL;
  }

  double v7 = (*(double (**)(void))(**(void **)(a1 + 56) + 56LL))(*(void *)(a1 + 56));
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  char v8 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134349312;
    *(double *)__int16 v27 = v7 / 3600.0;
    *(_WORD *)&v27[8] = 2050;
    *(double *)int v28 = v7 / 86400.0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "@GtsSync, since last switched, hours, %{public}0.1f, days, %{public}0.1f",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    *(_DWORD *)int v24 = 134349312;
    *(double *)&v24[4] = v7 / 3600.0;
    *(_WORD *)&v24[12] = 2050;
    *(double *)&v24[14] = v7 / 86400.0;
    double v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsSync, since last switched, hours, %{public}0.1f, days, %{public}0.1f",  v24,  22);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLTileSyncManager::handleSyncTrapTurn(BOOL)", "%s\n", v16);
  }

  if (v7 < *(double *)(a1 + 88) || *(_BYTE *)(a1 + 200))
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    double v9 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134349568;
      double v10 = *(double *)(a1 + 88);
      int v11 = *(unsigned __int8 *)(a1 + 200);
      *(double *)__int16 v27 = v7 / 86400.0;
      *(_WORD *)&v27[8] = 2050;
      *(double *)int v28 = v10 / 86400.0;
      *(_WORD *)&v28[8] = 1026;
      v29[0] = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "@GtsMgr, xSyncTrap, days inactive, %{public}0.1f, thresh, %{public}0.1f, pending, %{public}d",  buf,  0x1Cu);
    }

    if (!sub_1002921D0(115, 2)) {
      return 1LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    *(_DWORD *)int v24 = 134349568;
    double v17 = *(double *)(a1 + 88);
    int v18 = *(unsigned __int8 *)(a1 + 200);
    *(double *)&v24[4] = v7 / 86400.0;
    *(_WORD *)&v24[12] = 2050;
    *(double *)&v24[14] = v17 / 86400.0;
    *(_WORD *)&v24[22] = 1026;
    LODWORD(v25[0]) = v18;
    LODWORD(v23) = 28;
    int v6 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsMgr, xSyncTrap, days inactive, %{public}0.1f, thresh, %{public}0.1f, pending, %{public}d",  v24,  v23,  *(_OWORD *)v24,  *(void *)&v24[16],  v25[0]);
    goto LABEL_39;
  }

  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  uint64_t v13 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = *(char *)(a1 + 160);
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
    *(_DWORD *)buf = 67240960;
    *(_DWORD *)__int16 v27 = v3;
    *(_WORD *)&v27[4] = 1026;
    *(_DWORD *)&v27[6] = v14;
    *(_WORD *)int v28 = 2050;
    *(void *)&_DWORD v28[2] = v15;
    LOWORD(v29[0]) = 2050;
    *(double *)((char *)v29 + 2) = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "@GtsFlow, CS, setNeedsReset, 1, BeginPair, state, %{public}c, %{public}c, queuewas, %{public}ld, inactive, %{public}0.1f",  buf,  0x22u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v20 = *(char *)(a1 + 160);
    unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
    *(_DWORD *)int v24 = 67240960;
    *(_DWORD *)&v24[4] = v3;
    *(_WORD *)&v24[8] = 1026;
    *(_DWORD *)&v24[10] = v20;
    *(_WORD *)&v24[14] = 2050;
    *(void *)&v24[16] = v21;
    LOWORD(v25[0]) = 2050;
    *(double *)((char *)v25 + 2) = v7;
    LODWORD(v23) = 34;
    int v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsFlow, CS, setNeedsReset, 1, BeginPair, state, %{public}c, %{public}c, queuewas, %{public}ld, ina ctive, %{public}0.1f",  v24,  v23);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLTileSyncManager::handleSyncTrapTurn(BOOL)", "%s\n", v22);
  }

  *(_BYTE *)(a1 + 192) = 84;
  *(_BYTE *)(a1 + 200) = 1;
  sub_100222E28((uint64_t *)(a1 + 168));
  [*(id *)(a1 + 8) setHasChangesAvailable];
  return 0LL;
}

void sub_100219A60(uint64_t a1)
{
  if (![*(id *)(a1 + 32) syncRestriction])
  {
    uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8LL);
    int v3 = 0;
    goto LABEL_5;
  }

  if ([*(id *)(a1 + 32) syncRestriction] == (id)1)
  {
    uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8LL);
    int v3 = 1;
LABEL_5:
    sub_100219C9C(v2, v3);
    return;
  }

  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  char v4 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
  {
    id v5 = [*(id *)(a1 + 32) syncRestriction];
    *(_DWORD *)buf = 134349056;
    id v12 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "@GtsSync, PsCoord, RestrictionUnknown, %{public}ld, #CloneMe",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    uint64_t v6 = qword_101934868;
    id v7 = [*(id *)(a1 + 32) syncRestriction];
    int v9 = 134349056;
    id v10 = v7;
    char v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v6,  16LL,  "@GtsSync, PsCoord, RestrictionUnknown, %{public}ld, #CloneMe",  &v9,  12);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CLTileSyncDelegate syncCoordinatorDidChangeSyncRestriction:]_block_invoke",  "%s\n",  v8);
  }

void sub_100219C9C(uint64_t a1, int a2)
{
  int v3 = *(char *)(a1 + 160);
  *(_BYTE *)(a1 + 136) = a2;
  if (a2)
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    char v4 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "@GtsSync, PsCoord, RestrictionLimitPush",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      LOWORD(v16[0]) = 0;
      uint64_t v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsSync, PsCoord, RestrictionLimitPush",  v16,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::handleRestrictionChange(BOOL)", "%s\n", v13);
    }

    char v5 = 76;
    goto LABEL_15;
  }

  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  uint64_t v6 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "@GtsSync, PsCoord, RestrictionNone", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    LOWORD(v16[0]) = 0;
    int v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsSync, PsCoord, RestrictionNone",  v16,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::handleRestrictionChange(BOOL)", "%s\n", v14);
  }

  if ((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 40LL))(*(void *)(a1 + 56)))
  {
    char v5 = 83;
LABEL_15:
    *(_BYTE *)(a1 + 160) = v5;
  }

  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  id v7 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    int v8 = *(char *)(a1 + 160);
    int v9 = *(unsigned __int8 *)(a1 + 136);
    *(_DWORD *)buf = 67240704;
    int v22 = v3;
    __int16 v23 = 1026;
    int v24 = v8;
    __int16 v25 = 1026;
    int v26 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "@GtsMgr, restriction, state was, %{public}c, now, %{public}c, restricted, %{public}d",  buf,  0x14u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v10 = *(char *)(a1 + 160);
    int v11 = *(unsigned __int8 *)(a1 + 136);
    v16[0] = 67240704;
    v16[1] = v3;
    __int16 v17 = 1026;
    int v18 = v10;
    __int16 v19 = 1026;
    int v20 = v11;
    LODWORD(v15) = 20;
    id v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsMgr, restriction, state was, %{public}c, now, %{public}c, restricted, %{public}d",  v16,  v15);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::handleRestrictionChange(BOOL)", "%s\n", v12);
  }

void sub_10021A574(uint64_t a1)
{
}

void sub_10021A580(uint64_t a1)
{
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  uint64_t v2 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    int v3 = *(char *)(a1 + 160);
    *(_DWORD *)buf = 67240192;
    int v8 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "@GtsMgr, SyncTrapEnd, oldstate, %{public}c",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v4 = *(char *)(a1 + 160);
    v6[0] = 67240192;
    v6[1] = v4;
    char v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsMgr, SyncTrapEnd, oldstate, %{public}c",  v6,  8);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::handleSyncTrapEnd()", "%s\n", v5);
  }

  *(_BYTE *)(a1 + 160) = 83;
  sub_10021CBAC(a1, (uint64_t)"ClosePS", 1.0);
}

void sub_10021AA54(double *a1, double a2)
{
  a1[6] = a2;
  int v3 = objc_autoreleasePoolPush();
  int v4 = +[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 11LL);
  -[NSMutableArray setObject:atIndexedSubscript:]( v4,  "setObject:atIndexedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)a1),  0LL);
  -[NSMutableArray setObject:atIndexedSubscript:]( v4,  "setObject:atIndexedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 1)),  1LL);
  -[NSMutableArray setObject:atIndexedSubscript:]( v4,  "setObject:atIndexedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 2)),  2LL);
  -[NSMutableArray setObject:atIndexedSubscript:]( v4,  "setObject:atIndexedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 3)),  3LL);
  -[NSMutableArray setObject:atIndexedSubscript:]( v4,  "setObject:atIndexedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 6)),  4LL);
  -[NSMutableArray setObject:atIndexedSubscript:]( v4,  "setObject:atIndexedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 4)),  5LL);
  -[NSMutableArray setObject:atIndexedSubscript:]( v4,  "setObject:atIndexedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 5)),  6LL);
  -[NSMutableArray setObject:atIndexedSubscript:]( v4,  "setObject:atIndexedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 7)),  7LL);
  -[NSMutableArray setObject:atIndexedSubscript:]( v4,  "setObject:atIndexedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *((unsigned int *)a1 + 8)),  8LL);
  -[NSMutableArray setObject:atIndexedSubscript:]( v4,  "setObject:atIndexedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", a1[5]),  9LL);
  -[NSMutableArray setObject:atIndexedSubscript:]( v4,  "setObject:atIndexedSubscript:",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", a1[6]),  10LL);
  uint64_t v5 = sub_1002F8DDC();
  sub_1002AB3DC(v5);
  uint64_t v6 = sub_1002F8DDC();
  (*(void (**)(uint64_t))(*(void *)v6 + 944LL))(v6);
  objc_autoreleasePoolPop(v3);
}

void sub_10021ABF8(uint64_t a1, double a2)
{
  int v4 = objc_autoreleasePoolPush();
  uint64_t v5 = sub_1002F8DDC();
  if (sub_1002AA610(v5, @"TileSyncAwd", (CFTypeRef *)&v27))
  {
    uint64_t v6 = v27;
    if ([v27 count] == (id)11)
    {
      *(_DWORD *)a1 = objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 0), "intValue");
      *(_DWORD *)(a1 + 4) = objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 1), "intValue");
      *(_DWORD *)(a1 + 8) = objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 2), "intValue");
      *(_DWORD *)(a1 + 12) = objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 3), "intValue");
      *(_DWORD *)(a1 + 24) = objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 4), "intValue");
      *(_DWORD *)(a1 + 16) = objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 5), "intValue");
      *(_DWORD *)(a1 + 20) = objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 6), "intValue");
      *(_DWORD *)(a1 + 28) = objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 7), "intValue");
      *(_DWORD *)(a1 + 32) = objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 8), "intValue");
      objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 9), "doubleValue");
      *(void *)(a1 + 40) = v7;
      objc_msgSend(objc_msgSend(v6, "objectAtIndexedSubscript:", 10), "doubleValue");
      *(void *)(a1 + 48) = v8;
    }

    else
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      int v9 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
      {
        double v10 = COERCE_DOUBLE([v6 count]);
        *(_DWORD *)buf = 134349056;
        double v35 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "@GtsAwd, plist, error, load, %{public}lu",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        uint64_t v23 = qword_101934868;
        double v24 = COERCE_DOUBLE([v6 count]);
        int v28 = 134349056;
        double v29 = v24;
        __int16 v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v23,  1LL,  "@GtsAwd, plist, error, load, %{public}lu",  &v28,  12);
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncAWD::loadMetrics(CFAbsoluteTime)", "%s\n", v25);
      }
    }
  }

  double v11 = a2 - *(double *)(a1 + 48);
  if (v11 > 7776000.0)
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    id v12 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      uint64_t v13 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 134349568;
      double v35 = v11;
      __int16 v36 = 2050;
      double v37 = 7776000.0;
      __int16 v38 = 2050;
      uint64_t v39 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "@GtsAwd, plist, clear, %{public}.1f, thresh, %{public}.0f, last, %{public}.1f",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      uint64_t v19 = *(void *)(a1 + 48);
      int v28 = 134349568;
      double v29 = v11;
      __int16 v30 = 2050;
      double v31 = 7776000.0;
      __int16 v32 = 2050;
      uint64_t v33 = v19;
      LODWORD(v26) = 32;
      int v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsAwd, plist, clear, %{public}.1f, thresh, %{public}.0f, last, %{public}.1f",  &v28,  v26);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncAWD::loadMetrics(CFAbsoluteTime)", "%s\n", v20);
    }

    uint64_t v14 = sub_1002F8DDC();
    sub_1002A66DC(v14);
  }

  objc_autoreleasePoolPop(v4);
  double v15 = *(double *)(a1 + 40);
  if (v15 > a2 || v15 + 604800.0 < a2)
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    __int16 v17 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      double v18 = *(double *)(a1 + 40);
      *(_DWORD *)buf = 134349312;
      double v35 = v18;
      __int16 v36 = 2048;
      double v37 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "@GtsAwd, plist, error, time, %{public}.1f, now, %.1f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      double v21 = *(double *)(a1 + 40);
      int v28 = 134349312;
      double v29 = v21;
      __int16 v30 = 2048;
      double v31 = a2;
      LODWORD(v26) = 22;
      int v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsAwd, plist, error, time, %{public}.1f, now, %.1f",  &v28,  v26);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncAWD::loadMetrics(CFAbsoluteTime)", "%s\n", v22);
    }

    *(double *)(a1 + 40) = a2;
  }

  sub_10021B224((double *)a1, (uint64_t)"loadcache", a2);
}

void sub_10021B224(double *a1, uint64_t a2, double a3)
{
  double v6 = a3 - a1[6];
  if (v6 > 604800.0)
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    uint64_t v7 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *((void *)a1 + 6);
      *(_DWORD *)buf = 134349568;
      double v62 = v6;
      __int16 v63 = 2050;
      *(void *)__int128 v64 = 0x4122750000000000LL;
      *(_WORD *)&v64[8] = 2050;
      uint64_t v65 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "@GtsAwd, plist, clear, %{public}.1f, thresh, %{public}.0f, last, %{public}.1f",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      uint64_t v34 = *((void *)a1 + 6);
      int v37 = 134349568;
      double v38 = v6;
      __int16 v39 = 2050;
      *(void *)int v40 = 0x4122750000000000LL;
      *(_WORD *)&v40[8] = 2050;
      uint64_t v41 = v34;
      double v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsAwd, plist, clear, %{public}.1f, thresh, %{public}.0f, last, %{public}.1f",  &v37,  32);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncAWD::weekLongLogging(const char *, CFAbsoluteTime)",  "%s\n",  v35);
    }

    uint64_t v9 = sub_1002F8DDC();
    sub_1002A66DC(v9);
  }

  double v10 = a1[5];
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  double v11 = a3 - v10;
  id v12 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *(_DWORD *)a1;
    int v14 = *((_DWORD *)a1 + 1);
    int v15 = *((_DWORD *)a1 + 2);
    int v16 = *((_DWORD *)a1 + 3);
    int v17 = *((_DWORD *)a1 + 4);
    double v18 = (double)*((int *)a1 + 5) * 0.0009765625;
    int v19 = *((_DWORD *)a1 + 6);
    int v20 = *((_DWORD *)a1 + 7);
    double v21 = (double)*((int *)a1 + 8) * 0.0009765625;
    uint64_t v22 = *((void *)a1 + 6);
    *(_DWORD *)buf = 136449538;
    double v62 = *(double *)&a2;
    __int16 v63 = 1026;
    *(_DWORD *)__int128 v64 = v13;
    *(_WORD *)&v64[4] = 1026;
    *(_DWORD *)&v64[6] = v14;
    LOWORD(v65) = 1026;
    *(_DWORD *)((char *)&v65 + 2) = v15;
    HIWORD(v65) = 1026;
    int v66 = v16;
    __int16 v67 = 1026;
    int v68 = v19;
    __int16 v69 = 1026;
    int v70 = v17;
    __int16 v71 = 2050;
    double v72 = v18;
    __int16 v73 = 1026;
    int v74 = v20;
    __int16 v75 = 2050;
    double v76 = v21;
    __int16 v77 = 2050;
    double v78 = v11 / 3600.0;
    __int16 v79 = 1026;
    BOOL v80 = v11 > 604800.0;
    __int16 v81 = 2050;
    uint64_t v82 = v22;
    __int16 v83 = 2050;
    double v84 = v6 / 3600.0;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "@GtsAwd, snap, %{public}s, sessions, %{public}d, empty, %{public}d, completed, %{public}d, errored, %{public}d, re quested, %{public}d, synced, %{public}d, sizemb, %{public}.1f, week, %{public}d, %{public}.1f, sinceweekly, %{publ ic}0.1f, reset, %{public}d, lastSave, %{public}0.1f, %{public}0.1f",  buf,  0x6Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v23 = *(_DWORD *)a1;
    int v24 = *((_DWORD *)a1 + 1);
    int v25 = *((_DWORD *)a1 + 2);
    int v26 = *((_DWORD *)a1 + 3);
    int v27 = *((_DWORD *)a1 + 4);
    double v28 = (double)*((int *)a1 + 5) * 0.0009765625;
    int v29 = *((_DWORD *)a1 + 6);
    int v30 = *((_DWORD *)a1 + 7);
    double v31 = (double)*((int *)a1 + 8) * 0.0009765625;
    int v37 = 136449538;
    uint64_t v32 = *((void *)a1 + 6);
    double v38 = *(double *)&a2;
    __int16 v39 = 1026;
    *(_DWORD *)int v40 = v23;
    *(_WORD *)&v40[4] = 1026;
    *(_DWORD *)&v40[6] = v24;
    LOWORD(v41) = 1026;
    *(_DWORD *)((char *)&v41 + 2) = v25;
    HIWORD(v41) = 1026;
    int v42 = v26;
    __int16 v43 = 1026;
    int v44 = v29;
    __int16 v45 = 1026;
    int v46 = v27;
    __int16 v47 = 2050;
    double v48 = v28;
    __int16 v49 = 1026;
    int v50 = v30;
    __int16 v51 = 2050;
    double v52 = v31;
    __int16 v53 = 2050;
    double v54 = v11 / 3600.0;
    __int16 v55 = 1026;
    BOOL v56 = v11 > 604800.0;
    __int16 v57 = 2050;
    uint64_t v58 = v32;
    __int16 v59 = 2050;
    double v60 = v6 / 3600.0;
    LODWORD(v36) = 110;
    uint64_t v33 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsAwd, snap, %{public}s, sessions, %{public}d, empty, %{public}d, completed, %{public}d, errored, %{public}d, requested, %{public}d, synced, %{public}d, sizemb, %{public}.1f, week, %{public}d, %{pub lic}.1f, sinceweekly, %{public}0.1f, reset, %{public}d, lastSave, %{public}0.1f, %{public}0.1f",  &v37,  v36);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncAWD::weekLongLogging(const char *, CFAbsoluteTime)",  "%s\n",  v33);
  }

  if (v11 > 604800.0)
  {
    *((_DWORD *)a1 + 7) = 0;
    *((_DWORD *)a1 + 8) = 0;
    a1[5] = a1[5] + 604800.0;
  }

void sub_10021B72C(double *a1, double a2)
{
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  int v4 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    int v5 = *(_DWORD *)a1;
    *(_DWORD *)buf = 67240192;
    int v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "@GtsAwd, started, %{public}d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v6 = *(_DWORD *)a1;
    v8[0] = 67240192;
    v8[1] = v6;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsAwd, started, %{public}d",  v8,  8);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncAWD::startSession(CFAbsoluteTime)", "%s\n", v7);
  }

  sub_10021AA54(a1, a2);
}

void sub_10021B900(uint64_t a1, int a2, double a3)
{
  if (a2) {
    ++*(_DWORD *)(a1 + 12);
  }
  ++*(_DWORD *)(a1 + 8);
  sub_10021AA54((double *)a1, a3);
  sub_10021B224((double *)a1, (uint64_t)"endsync", a3);
}

void sub_10021B960(double *a1, int a2, double a3)
{
  if (!a2) {
    ++*((_DWORD *)a1 + 1);
  }
  *((_DWORD *)a1 + 6) += a2;
  sub_10021AA54(a1, a3);
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  int v5 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    int v6 = *((_DWORD *)a1 + 6);
    int v7 = *(_DWORD *)a1;
    *(_DWORD *)buf = 67240704;
    int v17 = a2;
    __int16 v18 = 1026;
    int v19 = v6;
    __int16 v20 = 1026;
    int v21 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "@GtsAwd, request, tiles, %{public}d, total, %{public}d, sessions, %{public}d",  buf,  0x14u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v8 = *((_DWORD *)a1 + 6);
    int v9 = *(_DWORD *)a1;
    v11[0] = 67240704;
    v11[1] = a2;
    __int16 v12 = 1026;
    int v13 = v8;
    __int16 v14 = 1026;
    int v15 = v9;
    int v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsAwd, request, tiles, %{public}d, total, %{public}d, sessions, %{public}d",  v11,  20);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncAWD::tilesRequested(CFAbsoluteTime, int)", "%s\n", v10);
  }

void sub_10021BB68(uint64_t a1, int a2, double a3)
{
  int v6 = a2 + 512;
  if (a2 < -512) {
    int v6 = a2 + 1535;
  }
  int v7 = *(_DWORD *)(a1 + 20) + (v6 >> 10);
  ++*(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 20) = v7;
  int v8 = *(_DWORD *)(a1 + 32);
  ++*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 32) = v8 + (v6 >> 10);
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  int v9 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    double v10 = (double)*(int *)(a1 + 20) * 0.0009765625;
    *(_DWORD *)buf = 67240448;
    int v17 = a2;
    __int16 v18 = 2050;
    double v19 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "@GtsAwd, serialized, %{public}d, totalmb, %{public}.1f",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    double v11 = (double)*(int *)(a1 + 20) * 0.0009765625;
    v13[0] = 67240448;
    v13[1] = a2;
    __int16 v14 = 2050;
    double v15 = v11;
    __int16 v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsAwd, serialized, %{public}d, totalmb, %{public}.1f",  v13,  18);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncAWD::tileSynced(CFAbsoluteTime, int)", "%s\n", v12);
  }

  sub_10021AA54((double *)a1, a3);
}

void sub_10021BD98(unsigned int *a1, _DWORD *a2, double a3)
{
  unsigned int v5 = *a1;
  int v6 = 1;
  if ((int)*a1 >= 101)
  {
    unsigned int v7 = *a1;
    do
    {
      unsigned int v5 = v7 / 0xA;
      v6 *= 10;
      BOOL v8 = v7 > 0x3F1;
      v7 /= 0xAu;
    }

    while (v8);
  }

  a2[10] = v6 * v5;
  signed int v9 = a1[1];
  int v10 = 1;
  if (v9 >= 101)
  {
    unsigned int v11 = a1[1];
    do
    {
      signed int v9 = v11 / 0xA;
      v10 *= 10;
      BOOL v8 = v11 > 0x3F1;
      v11 /= 0xAu;
    }

    while (v8);
  }

  a2[11] = v10 * v9;
  signed int v12 = a1[2];
  int v13 = 1;
  if (v12 >= 101)
  {
    unsigned int v14 = a1[2];
    do
    {
      signed int v12 = v14 / 0xA;
      v13 *= 10;
      BOOL v8 = v14 > 0x3F1;
      v14 /= 0xAu;
    }

    while (v8);
  }

  a2[12] = v13 * v12;
  signed int v15 = a1[3];
  int v16 = 1;
  if (v15 >= 101)
  {
    unsigned int v17 = a1[3];
    do
    {
      signed int v15 = v17 / 0xA;
      v16 *= 10;
      BOOL v8 = v17 > 0x3F1;
      v17 /= 0xAu;
    }

    while (v8);
  }

  a2[13] = v16 * v15;
  signed int v18 = a1[4];
  int v19 = 1;
  if (v18 >= 101)
  {
    unsigned int v20 = a1[4];
    do
    {
      signed int v18 = v20 / 0xA;
      v19 *= 10;
      BOOL v8 = v20 > 0x3F1;
      v20 /= 0xAu;
    }

    while (v8);
  }

  unsigned int v21 = a1[5];
  a2[14] = v19 * v18;
  a2[15] = v21;
  sub_10021B224((double *)a1, (uint64_t)"report", a3);
  *(void *)a1 = 0LL;
  *((void *)a1 + 1) = 0LL;
  *((void *)a1 + 2) = 0LL;
  sub_10021AA54((double *)a1, a3);
}

uint64_t sub_10021BF28(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4, void *a5)
{
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_10182B500;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 48) = a2;
  uint64_t v7 = *a4;
  *a4 = 0LL;
  *(void *)(a1 + 56) = v7;
  *(void *)(a1 + 64) = a3;
  *(void *)(a1 + 72) = 0LL;
  *(_BYTE *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 88) = xmmword_1012E2620;
  BOOL v8 = (void *)(a1 + 88);
  id v9 = objc_msgSend(objc_msgSend(a3, "silo"), "newTimer");
  *(void *)(a1 + 144) = *a5;
  *(void *)(a1 + 104) = v9;
  *(_BYTE *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0LL;
  *(_BYTE *)(a1 + 136) = 1;
  uint64_t v10 = a5[1];
  *(void *)(a1 + 152) = v10;
  if (v10)
  {
    unsigned int v11 = (unint64_t *)(v10 + 8);
    do
      unint64_t v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }

  *(void *)(a1 + 168) = 0LL;
  *(_BYTE *)(a1 + 160) = 76;
  *(void *)(a1 + 176) = 0LL;
  *(void *)(a1 + 184) = 0LL;
  *(_WORD *)(a1 + 192) = 88;
  *(_DWORD *)(a1 + 196) = 0;
  *(_BYTE *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  uint64_t v13 = a1 + 208;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_DWORD *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0LL;
  *(void *)(a1 + 256) = 0LL;
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56)) & 1) == 0
    && ((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56)) & 1) == 0)
  {
    sub_101230938();
    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLTileSyncManager.mm",  571,  "CLTileSyncManager");
    __break(1u);
  }

  sub_1002F0B04(buf);
  sub_1002A82BC(*(uint64_t *)buf, "ManifestRate", (void *)(a1 + 96));
  unsigned int v14 = v56;
  if (v56)
  {
    p_shared_owners = (unint64_t *)&v56->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  sub_1002F0B04(buf);
  sub_1002A82BC(*(uint64_t *)buf, "QwsPeriod", v8);
  unsigned int v17 = v56;
  if (v56)
  {
    signed int v18 = (unint64_t *)&v56->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  double v20 = (*(double (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56));
  *(double *)(a1 + 72) = v20;
  sub_100222E28((uint64_t *)(a1 + 168));
  int v21 = sub_10021C514(a1);
  else {
    BOOL v22 = 1;
  }
  if ((v21 & v22) != 0) {
    char v23 = 83;
  }
  else {
    char v23 = 76;
  }
  *(_BYTE *)(a1 + 160) = v23;
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  int v24 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
  {
    int v25 = v21;
    int v26 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56));
    int v27 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56));
    uint64_t v28 = *(void *)(a1 + 96);
    int v29 = *(char *)(a1 + 160);
    int v30 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 48LL))(*(void *)(a1 + 56));
    *(_DWORD *)buf = 67241728;
    *(_DWORD *)&uint8_t buf[4] = v26;
    LOWORD(v56) = 1026;
    *(_DWORD *)((char *)&v56 + 2) = v27;
    HIWORD(v56) = 2050;
    uint64_t v57 = v28;
    __int16 v58 = 1026;
    BOOL v59 = v22;
    __int16 v60 = 1026;
    int v21 = v25;
    int v61 = v25;
    __int16 v62 = 1026;
    int v63 = v29;
    __int16 v64 = 1026;
    int v65 = v30;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "@GtsInit, CG, %{public}d, %{public}d, rate, %{public}0.0f, state, %{public}d, %{public}d, %{public}c, canDownload, %{public}d",  buf,  0x30u);
    uint64_t v13 = a1 + 208;
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    int v32 = v21;
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    uint64_t v40 = v13;
    uint64_t v33 = qword_101934868;
    int v34 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56));
    int v35 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56));
    uint64_t v36 = *(void *)(a1 + 96);
    int v37 = *(char *)(a1 + 160);
    int v38 = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 48LL))(*(void *)(a1 + 56));
    v42[0] = 67241728;
    v42[1] = v34;
    __int16 v43 = 1026;
    int v44 = v35;
    __int16 v45 = 2050;
    uint64_t v46 = v36;
    __int16 v47 = 1026;
    BOOL v48 = v22;
    __int16 v49 = 1026;
    int v50 = v32;
    __int16 v51 = 1026;
    int v52 = v37;
    __int16 v53 = 1026;
    int v54 = v38;
    __int16 v39 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v33,  0LL,  "@GtsInit, CG, %{public}d, %{public}d, rate, %{public}0.0f, state, %{public}d, %{public}d, %{public}c , canDownload, %{public}d",  v42,  48);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTileSyncManager::CLTileSyncManager(CLITilesManager *, id<CLIntersiloUniverse>, std::unique_ptr<IExternal>, std:: shared_ptr<CLWifiAccessPointLocationService>)",  "%s\n",  v39);
    uint64_t v13 = v40;
  }

  sub_10021ABF8(v13, v20);
  v41[0] = _NSConcreteStackBlock;
  v41[1] = 3221225472LL;
  v41[2] = sub_10021C9D4;
  v41[3] = &unk_10181D3D0;
  v41[4] = a1;
  [*(id *)(a1 + 104) setHandler:v41];
  sub_10021CBAC(a1, (uint64_t)"Timer", *(double *)(a1 + 96));
  return a1;
}

void sub_10021C498( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v20 = *(void *)(v17 + 56);
  *(void *)(v17 + 56) = 0LL;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10021C514(uint64_t a1)
{
  *(void *)(a1 + 16) = -[CLTileSyncDelegate initWithSyncManager:silo:]( [CLTileSyncDelegate alloc],  "initWithSyncManager:silo:",  a1,  [*(id *)(a1 + 64) silo]);
  id v2 = objc_alloc(off_101936498());
  id v3 = [v2 initWithService:@"com.apple.private.alloy.location.wifitilesync" priority:-20 asMasterStore:(*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56)) options:0];
  *(void *)(a1 + 8) = v3;
  objc_msgSend( v3,  "setDelegate:queue:",  *(void *)(a1 + 16),  objc_msgSend(objc_msgSend(*(id *)(a1 + 64), "silo"), "queue"));
  *(void *)(a1 + 24) = objc_alloc_init(&OBJC_CLASS___CLTileSyncSyChange);
  [*(id *)(a1 + 8) setSessionStalenessInterval:1];
  if (*(void *)(a1 + 8))
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40LL))(*(void *)(a1 + 56));
    if ((_DWORD)result)
    {
      sub_10021D2E8(a1);
      return 1LL;
    }
  }

  else
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    unsigned int v5 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "@GtsInit, CsObjects failed", buf, 2u);
    }

    uint64_t result = sub_1002921D0(115, 2);
    if ((_DWORD)result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      v7[0] = 0;
      int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsInit, CsObjects failed",  v7,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLTileSyncManager::csInitialize()", "%s\n", v6);
      return 0LL;
    }
  }

  return result;
}

BOOL sub_10021C77C(uint64_t a1)
{
  id v2 = -[objc_class syncCoordinatorWithServiceName:]( off_101936488(),  "syncCoordinatorWithServiceName:",  @"com.apple.pairedsync.locationd");
  *(void *)(a1 + 32) = v2;
  [v2 setDelegate:*(void *)(a1 + 16)];
  *(void *)(a1 + 40) = [objc_alloc(off_101936490()) initWithDelegate:*(void *)(a1 + 16)];
  *(_BYTE *)(a1 + 136) = [*(id *)(a1 + 32) syncRestriction] != 0;
  if (!*(void *)(a1 + 32) || !*(void *)(a1 + 40))
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    id v3 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      BOOL v4 = *(void *)(a1 + 32) == 0LL;
      BOOL v5 = *(void *)(a1 + 40) == 0LL;
      *(_DWORD *)buf = 67240448;
      BOOL v14 = v4;
      __int16 v15 = 1026;
      BOOL v16 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "@GtsInit, PsObjects failed, C, %{public}d, O, %{public}d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      BOOL v7 = *(void *)(a1 + 32) == 0LL;
      BOOL v8 = *(void *)(a1 + 40) == 0LL;
      v10[0] = 67240448;
      v10[1] = v7;
      __int16 v11 = 1026;
      BOOL v12 = v8;
      id v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsInit, PsObjects failed, C, %{public}d, O, %{public}d",  v10,  14);
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLTileSyncManager::psInitialize()", "%s\n", v9);
    }
  }

  return *(_BYTE *)(a1 + 136) == 0;
}

uint64_t sub_10021C9D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  id v2 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(v1 + 112);
    *(_DWORD *)buf = 136446210;
    uint64_t v10 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "@GtsTimer, fired, %{public}s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    uint64_t v5 = *(void *)(v1 + 112);
    int v7 = 136446210;
    uint64_t v8 = v5;
    int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsTimer, fired, %{public}s",  &v7,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTileSyncManager::CLTileSyncManager(CLITilesManager *, id<CLIntersiloUniverse>, std::unique_ptr<IExternal>, std:: shared_ptr<CLWifiAccessPointLocationService>)_block_invoke",  "%s\n",  v6);
  }

  sub_10021CBAC(v1, (uint64_t)"Timer", *(double *)(v1 + 96));
  return (*(uint64_t (**)(uint64_t, void))(*(void *)v1 + 48LL))(v1, *(void *)(v1 + 112));
}

void sub_10021CBAC(uint64_t a1, uint64_t a2, double a3)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56)))
  {
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 48LL))(*(void *)(a1 + 56)))
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      int v6 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "@GtsTimer, direct, skip", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        LOWORD(v12) = 0;
        int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsTimer, direct, skip",  &v12,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncManager::setManifestFire(const char *, CFTimeInterval)",  "%s\n",  v7);
      }
    }

    else
    {
      if (*(_BYTE *)(a1 + 160) != 83) {
        a3 = *(double *)(a1 + 96);
      }
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      uint64_t v8 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
      {
        int v9 = *(char *)(a1 + 160);
        *(_DWORD *)buf = 134349570;
        double v19 = a3;
        __int16 v20 = 2082;
        uint64_t v21 = a2;
        __int16 v22 = 1026;
        int v23 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "@GtsTimer, nextfire, %{public}.0f, %{public}s, state, %{public}c",  buf,  0x1Cu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        int v10 = *(char *)(a1 + 160);
        int v12 = 134349570;
        double v13 = a3;
        __int16 v14 = 2082;
        uint64_t v15 = a2;
        __int16 v16 = 1026;
        int v17 = v10;
        __int16 v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsTimer, nextfire, %{public}.0f, %{public}s, state, %{public}c",  &v12,  28);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncManager::setManifestFire(const char *, CFTimeInterval)",  "%s\n",  v11);
      }

      *(void *)(a1 + 112) = a2;
      [*(id *)(a1 + 104) setNextFireDelay:a3];
    }
  }

uint64_t sub_10021CF18(uint64_t a1)
{
  *(void *)a1 = off_10182B500;
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  id v2 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "@GtsMgr, dtor", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    v6[0] = 0;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsMgr, dtor",  v6,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual CLTileSyncManager::~CLTileSyncManager()", "%s\n", v5);
  }

  sub_10021D11C((id *)a1);

  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;

  *(void *)buf = a1 + 168;
  sub_100222DE8((void ***)buf);
  sub_10000AE14(a1 + 144);
  uint64_t v3 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return a1;
}

void sub_10021D110(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

void sub_10021D11C(id *a1)
{
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  id v2 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "@GtsMgr, release", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    v4[0] = 0;
    uint64_t v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsMgr, release",  v4,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::csRelease()", "%s\n", v3);
  }

  a1[1] = 0LL;
  a1[2] = 0LL;

  a1[3] = 0LL;
}

void sub_10021D2D4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10021CF18(a1);
  operator delete(v1);
}

void sub_10021D2E8(uint64_t a1)
{
  id v6 = 0LL;
  [*(id *)(a1 + 8) resume:&v6];
  if (v6)
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    uint64_t v1 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      id v2 = objc_msgSend(objc_msgSend(v6, "localizedDescription"), "UTF8String");
      *(_DWORD *)buf = 136446210;
      id v10 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_INFO,  "@GtsSync, CsError, 1, resume, %{public}s",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      uint64_t v3 = qword_101934868;
      id v4 = objc_msgSend(objc_msgSend(v6, "localizedDescription"), "UTF8String");
      int v7 = 136446210;
      id v8 = v4;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v3,  1LL,  "@GtsSync, CsError, 1, resume, %{public}s",  &v7,  12);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::csResume()", "%s\n", v5);
    }
  }

id sub_10021D4B8(uint64_t a1, void *a2)
{
  if ([a2 count])
  {
    id v4 = [a2 objectForKey:@"kSYDictionaryObjectSyncIDKey"];
    id v5 = [a2 objectForKey:@"kCLTileSyncControlRequest"];
    if ([v4 isEqualToString:@"Control"]
      && [v5 isEqualToString:@"Request"])
    {
      sub_10021CBAC(a1, (uint64_t)"GizmoReq", 30.0);
    }

    else
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      id v6 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)uint64_t v40 = [v4 UTF8String];
        *(_WORD *)&v40[8] = 2082;
        *(void *)&_BYTE v40[10] = [v5 UTF8String];
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "@GtsMgr, Mismatching keys, syncId, %{public}s, request, %{public}s",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        uint64_t v31 = qword_101934868;
        *(_DWORD *)uint64_t v36 = 136446466;
        *(void *)&v36[4] = [v4 UTF8String];
        *(_WORD *)&v36[12] = 2082;
        *(void *)&v36[14] = [v5 UTF8String];
        int v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v31,  1LL,  "@GtsMgr, Mismatching keys, syncId, %{public}s, request, %{public}s",  v36,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "NSDictionary *CLTileSyncManager::handleStartSessionCompanion(NSDictionary *)",  "%s\n",  v32);
      }
    }

    if (*(_BYTE *)(a1 + 192) == 88) {
      goto LABEL_36;
    }
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v7 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      int v8 = *(char *)(a1 + 192);
      *(_DWORD *)buf = 67240192;
      *(_DWORD *)uint64_t v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "@GtsMgr, Crossing sessions, %{public}c, #CloneMe",  buf,  8u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_36;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v9 = *(char *)(a1 + 192);
    *(_DWORD *)uint64_t v36 = 67240192;
    *(_DWORD *)&v36[4] = v9;
    LODWORD(v35) = 8;
    id v10 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsMgr, Crossing sessions, %{public}c, #CloneMe",  v36,  v35,  *(void *)v36);
LABEL_54:
    int v34 = (uint8_t *)v10;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "NSDictionary *CLTileSyncManager::handleStartSessionCompanion(NSDictionary *)",  "%s\n",  v10);
    if (v34 != buf) {
      free(v34);
    }
LABEL_36:
    id v12 = 0LL;
    goto LABEL_37;
  }

  int v11 = *(unsigned __int8 *)(a1 + 192);
  if (v11 == 84)
  {
    sub_10021DD2C(a1, 1);
    id v12 = objc_msgSend( objc_msgSend(*(id *)(a1 + 24), "properties"),  "objectForKey:",  @"kCLTileSyncControlManifestDict");
    goto LABEL_37;
  }

  if (v11 != 77)
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    __int16 v16 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *(char *)(a1 + 192);
      *(_DWORD *)buf = 67240192;
      *(_DWORD *)uint64_t v40 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "@GtsMgr, Unexpected Companion startSession flow, type, %{public}c, #CloneMe",  buf,  8u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_36;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v33 = *(char *)(a1 + 192);
    *(_DWORD *)uint64_t v36 = 67240192;
    *(_DWORD *)&v36[4] = v33;
    id v10 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsMgr, Unexpected Companion startSession flow, type, %{public}c, #CloneMe",  v36,  8,  *(void *)v36);
    goto LABEL_54;
  }

  id v12 = objc_msgSend( objc_msgSend(*(id *)(a1 + 24), "properties"),  "objectForKey:",  @"kCLTileSyncControlManifestDict");
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  double v13 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134349056;
    *(void *)uint64_t v40 = [v12 count];
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "@GtsManif, CompTx, %{public}ld", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    uint64_t v14 = qword_101934868;
    *(_DWORD *)uint64_t v36 = 134349056;
    *(void *)&v36[4] = [v12 count];
    uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  0LL,  "@GtsManif, CompTx, %{public}ld",  v36,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "NSDictionary *CLTileSyncManager::handleStartSessionCompanion(NSDictionary *)",  "%s\n",  v15);
  }

id sub_10021DD2C(uint64_t a1, int a2)
{
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16LL))(*(void *)(a1 + 48));
  id v4 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v5 = v3 + 184;
  uint64_t v6 = sub_1005B46E8(v5);
  uint64_t v7 = sub_100056FA8(v5);
  if (v6 != v7)
  {
    int v8 = (void *)v7;
    do
    {
      *(_OWORD *)buf = *(_OWORD *)(v6 + 32);
      *(void *)&buf[16] = *(void *)(v6 + 48);
      if (*(char *)(v6 + 79) < 0)
      {
        sub_1010DD48C(&v50, *(void **)(v6 + 56), *(void *)(v6 + 64));
      }

      else
      {
        __int128 v50 = *(_OWORD *)(v6 + 56);
        uint64_t v51 = *(void *)(v6 + 72);
      }

      uint64_t v9 = sub_1006025CC(v5, (unsigned int *)buf);
      if (!a2
        || ((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 32LL))(*(void *)(a1 + 48), v9) & 1) != 0)
      {
        id v10 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(v9 + 176));
        sub_1008AD030((unsigned int *)buf, &__p);
        int v11 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
            ? &__p
            : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
        -[NSMutableDictionary setObject:forKey:]( v4,  "setObject:forKey:",  v10,  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v11));
      }

      if (SHIBYTE(v51) < 0) {
        operator delete((void *)v50);
      }
      id v12 = *(void **)(v6 + 8);
      if (v12)
      {
        do
        {
          double v13 = v12;
          id v12 = (void *)*v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          double v13 = *(void **)(v6 + 16);
          BOOL v14 = *v13 == v6;
          uint64_t v6 = (uint64_t)v13;
        }

        while (!v14);
      }

      uint64_t v6 = (uint64_t)v13;
    }

    while (v13 != v8);
  }

  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  uint64_t v15 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = *(void *)(a1 + 112);
    uint64_t v17 = sub_100019240(v5);
    unsigned int v18 = -[NSMutableDictionary count](v4, "count");
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = v16;
    *(_WORD *)&buf[12] = 2050;
    *(void *)&buf[14] = v17;
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v50) = v18;
    WORD2(v50) = 1026;
    *(_DWORD *)((char *)&v50 + 6) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "@GtsManif, PrepTx, %{public}s, tiles, %{public}lu, %d, currentOnly, %{public}d",  buf,  0x22u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    uint64_t v33 = qword_101934868;
    std::string::size_type v34 = *(void *)(a1 + 112);
    uint64_t v35 = sub_100019240(v5);
    unsigned int v36 = -[NSMutableDictionary count](v4, "count");
    LODWORD(__p.__r_.__value_.__l.__data_) = 136446978;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v34;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2050;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v35;
    HIWORD(__p.__r_.__value_.__r.__words[2]) = 1024;
    unsigned int v46 = v36;
    __int16 v47 = 1026;
    int v48 = a2;
    __int16 v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v33,  0LL,  "@GtsManif, PrepTx, %{public}s, tiles, %{public}lu, %d, currentOnly, %{public}d",  &__p,  34);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::createManifestInSyChange(BOOL)", "%s\n", v37);
    if (v37 != buf) {
      free(v37);
    }
  }

  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  id v19 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v40,  v44,  16LL);
  if (v19)
  {
    uint64_t v20 = *(void *)v41;
    do
    {
      unint64_t v21 = 0LL;
      do
      {
        if (*(void *)v41 != v20) {
          objc_enumerationMutation(v4);
        }
        id v22 = *(void **)(*((void *)&v40 + 1) + 8LL * (void)v21);
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        double v23 = (os_log_s *)qword_101934868;
        if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
        {
          id v24 = [v22 UTF8String];
          objc_msgSend( -[NSMutableDictionary objectForKeyedSubscript:](v4, "objectForKeyedSubscript:", v22),  "doubleValue");
          *(_DWORD *)buf = 136380931;
          *(void *)&uint8_t buf[4] = v24;
          *(_WORD *)&buf[12] = 2050;
          *(void *)&buf[14] = v25;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "@GtsManif, entry, %{private}s, gentime, %{public}.1f",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          uint64_t v26 = qword_101934868;
          id v27 = [v22 UTF8String];
          objc_msgSend( -[NSMutableDictionary objectForKeyedSubscript:](v4, "objectForKeyedSubscript:", v22),  "doubleValue");
          LODWORD(__p.__r_.__value_.__l.__data_) = 136380931;
          *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
          WORD2(__p.__r_.__value_.__r.__words[1]) = 2050;
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v28;
          LODWORD(v38) = 22;
          id v29 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  1LL,  "@GtsManif, entry, %{private}s, gentime, %{public}.1f",  &__p,  v38);
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::createManifestInSyChange(BOOL)", "%s\n", v29);
          if (v29 != buf) {
            free(v29);
          }
        }

        unint64_t v21 = (char *)v21 + 1;
      }

      while (v19 != v21);
      id v30 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v40,  v44,  16LL);
      id v19 = v30;
    }

    while (v30);
  }

  uint64_t v31 = +[NSDictionary dictionaryWithObjectsAndKeys:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjectsAndKeys:",  @"Control",  @"kSYDictionaryObjectSyncIDKey",  v4,  @"kCLTileSyncControlManifestDict",  0LL);
  [*(id *)(a1 + 24) setObjectIdentifier:@"Control"];
  [*(id *)(a1 + 24) setChangeType:1];
  id result = [*(id *)(a1 + 24) setProperties:v31];
  *(_BYTE *)(a1 + 192) = 77;
  *(_BYTE *)(a1 + 200) = 1;
  return result;
}

void sub_10021E374( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, int a43, __int16 a44, char a45, char a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (a58 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10021E3B4(uint64_t a1, void *a2)
{
  if (*(_BYTE *)(a1 + 192) != 77) {
    goto LABEL_52;
  }
  *(_BYTE *)(a1 + 192) = 65;
  *(_BYTE *)(a1 + 120) = 1;
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  uint64_t v5 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [a2 count];
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
    *(_DWORD *)buf = 134349312;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&buf[12] = 2050;
    *(void *)&buf[14] = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "@GtsManif, CompRx, %{public}ld, queue, %{public}lu, metadata",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    uint64_t v59 = qword_101934868;
    id v60 = [a2 count];
    unint64_t v61 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
    *(_DWORD *)v86 = 134349312;
    *(void *)&v86[4] = v60;
    *(_WORD *)&v86[12] = 2050;
    *(void *)&v86[14] = v61;
    id v2 = (const mach_header_64 *)buf;
    __int16 v62 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v59,  0LL,  "@GtsManif, CompRx, %{public}ld, queue, %{public}lu, metadata",  v86,  22);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<BOOL, BOOL, BOOL> CLTileSyncManager::handleEnqueueChangesCompanion(NSDictionary *)",  "%s\n",  v62);
    if (v62 != buf) {
      free(v62);
    }
  }

  double v8 = (*(double (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56));
  sub_10021B960((double *)(a1 + 208), (int)[a2 count], v8);
  __int128 v78 = 0u;
  __int128 v79 = 0u;
  __int128 v76 = 0u;
  __int128 v77 = 0u;
  id v9 = [a2 countByEnumeratingWithState:&v76 objects:v89 count:16];
  if (v9)
  {
    id v2 = &_mh_execute_header;
    uint64_t v10 = *(void *)v77;
    uint64_t v75 = 136380931LL;
    do
    {
      int v11 = 0LL;
      do
      {
        if (*(void *)v77 != v10) {
          objc_enumerationMutation(a2);
        }
        id v12 = *(void **)(*((void *)&v76 + 1) + 8LL * (void)v11);
        uint64_t v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16LL))(*(void *)(a1 + 48));
        sub_1010DDBC0(buf, (char *)[v12 UTF8String]);
        sub_1008AD02C(v86, buf);
        if ((buf[23] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        if (sub_1008AD1E0((unsigned int *)v86))
        {
          uint64_t v14 = v13 + 184;
          BOOL v15 = sub_10060238C(v14, (unsigned int *)v86);
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          uint64_t v16 = (os_log_s *)qword_101934868;
          if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
          {
            id v17 = [v12 UTF8String];
            *(_DWORD *)buf = v75;
            *(void *)&uint8_t buf[4] = v17;
            *(_WORD *)&buf[12] = 1026;
            *(_DWORD *)&buf[14] = v15;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_INFO,  "@GtsManif, CompReply, %{private}s, have, %{public}d",  buf,  0x12u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934860 != -1) {
              dispatch_once(&qword_101934860, &stru_10182B5B0);
            }
            uint64_t v25 = qword_101934868;
            id v26 = [v12 UTF8String];
            int v80 = v75;
            *(void *)__int16 v81 = v26;
            *(_WORD *)&v81[8] = 1026;
            *(_DWORD *)&v81[10] = v15;
            LODWORD(v74) = 18;
            id v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v25,  1LL,  "@GtsManif, CompReply, %{private}s, have, %{public}d",  &v80,  v74);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<BOOL, BOOL, BOOL> CLTileSyncManager::handleEnqueueChangesCompanion(NSDictionary *)",  "%s\n",  v27);
            if (v27 != buf) {
              free(v27);
            }
          }

          if (v15)
          {
            uint64_t v18 = sub_1006025CC(v14, (unsigned int *)v86);
            sub_10021F9AC(a1, v18);
          }
        }

        else
        {
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          id v19 = (os_log_s *)qword_101934868;
          if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
          {
            id v20 = [v12 UTF8String];
            *(_DWORD *)buf = 136380675;
            *(void *)&uint8_t buf[4] = v20;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "@GtsManif, BadId, enqueueC, %{private}s, #CloneMe",  buf,  0xCu);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934860 != -1) {
              dispatch_once(&qword_101934860, &stru_10182B5B0);
            }
            uint64_t v22 = qword_101934868;
            id v23 = [v12 UTF8String];
            int v80 = 136380675;
            *(void *)__int16 v81 = v23;
            LODWORD(v74) = 12;
            id v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v22,  16LL,  "@GtsManif, BadId, enqueueC, %{private}s, #CloneMe",  &v80,  v74);
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "std::tuple<BOOL, BOOL, BOOL> CLTileSyncManager::handleEnqueueChangesCompanion(NSDictionary *)",  "%s\n",  v24);
            if (v24 != buf) {
              free(v24);
            }
          }

          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_10182B5F0);
          }
          unint64_t v21 = (os_log_s *)qword_101934A78;
          if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136315650;
            *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLTileSyncManager.mm";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 966;
            *(_WORD *)&buf[18] = 2080;
            *(void *)&buf[20] = "false";
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "Assert Failed, %s, %d, %s", buf, 0x1Cu);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934A70 != -1) {
              dispatch_once(&qword_101934A70, &stru_10182B5F0);
            }
            int v80 = 136315650;
            *(void *)__int16 v81 = "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLTileSyncManager.mm";
            *(_WORD *)&v81[8] = 1024;
            *(_DWORD *)&v81[10] = 966;
            __int16 v82 = 2080;
            __int16 v83 = "false";
            std::string::size_type v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assert Failed, %s, %d, %s",  (const char *)&v80,  28,  (const char *)v75);
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "std::tuple<BOOL, BOOL, BOOL> CLTileSyncManager::handleEnqueueChangesCompanion(NSDictionary *)",  "%s\n",  v28);
            if (v28 != buf) {
              free(v28);
            }
          }

          sub_1002920DC();
        }

        if (SHIBYTE(v88) < 0) {
          operator delete((void *)__p);
        }
        int v11 = (char *)v11 + 1;
      }

      while (v9 != v11);
      id v29 = [a2 countByEnumeratingWithState:&v76 objects:v89 count:16];
      id v9 = v29;
    }

    while (v29);
  }

  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4) >= 0x29)
  {
    [*(id *)(a1 + 8) setSessionStalenessInterval:300];
    int v30 = 1;
  }

  else
  {
LABEL_52:
    int v30 = 0;
  }

  if ([a2 count])
  {
    unsigned int v31 = *(unsigned __int8 *)(a1 + 192);
    if (v31 > 0x51)
    {
      if (v31 == 84)
      {
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        __int16 v47 = (os_log_s *)qword_101934868;
        if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "@GtsFlow, CS, enqueueChanges, 3, SyncTrap",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          *(_WORD *)v86 = 0;
          LODWORD(v74) = 2;
          __int16 v67 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsFlow, CS, enqueueChanges, 3, SyncTrap",  v86,  v74);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<BOOL, BOOL, BOOL> CLTileSyncManager::handleEnqueueChangesCompanion(NSDictionary *)",  "%s\n",  v67);
          if (v67 != buf) {
            free(v67);
          }
        }

        *(_BYTE *)(a1 + 192) = 77;
        goto LABEL_98;
      }

      if (v31 != 82) {
        goto LABEL_57;
      }
    }

    else
    {
      if (v31 == 65)
      {
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        __int128 v41 = (os_log_s *)qword_101934868;
        if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
        {
          int v42 = *(char *)(a1 + 192);
          unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
          *(_DWORD *)buf = 67240448;
          *(_DWORD *)&uint8_t buf[4] = v42;
          *(_WORD *)&uint8_t buf[8] = 2050;
          *(void *)&buf[10] = v43;
          _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "@GtsFlow, CS, enqueueChanges, 3, TileData, %{public}c, queue, %{public}ld",  buf,  0x12u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          int v64 = *(char *)(a1 + 192);
          unint64_t v65 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
          *(_DWORD *)v86 = 67240448;
          *(_DWORD *)&v86[4] = v64;
          *(_WORD *)&v86[8] = 2050;
          *(void *)&v86[10] = v65;
          LODWORD(v74) = 18;
          int v66 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsFlow, CS, enqueueChanges, 3, TileData, %{public}c, queue, %{public}ld",  v86,  v74);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<BOOL, BOOL, BOOL> CLTileSyncManager::handleEnqueueChangesCompanion(NSDictionary *)",  "%s\n",  v66);
          if (v66 != buf) {
            free(v66);
          }
        }

        int v44 = *(__int128 **)(a1 + 168);
        if (*(__int128 **)(a1 + 176) == v44)
        {
          LOBYTE(v2) = 0;
          LOBYTE(v32) = 1;
          goto LABEL_100;
        }

        __int128 v45 = *v44;
        *(void *)&v86[16] = *((void *)v44 + 2);
        *(_OWORD *)v86 = v45;
        if (*((char *)v44 + 47) < 0)
        {
          sub_1010DD48C(&__p, *((void **)v44 + 3), *((void *)v44 + 4));
        }

        else
        {
          __int128 v46 = *(__int128 *)((char *)v44 + 24);
          uint64_t v88 = *((void *)v44 + 5);
          __int128 __p = v46;
        }

        sub_100220038(a1, (unsigned int *)v86);
        sub_100222E74( (uint64_t)buf,  (__int128 *)(*(void *)(a1 + 168) + 48LL),  *(__int128 **)(a1 + 176),  *(void *)(a1 + 168));
        uint64_t v51 = v50;
        for (uint64_t i = *(void *)(a1 + 176); i != v51; i -= 48LL)
        {
        }

        *(void *)(a1 + 176) = v51;
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        __int16 v53 = (os_log_s *)qword_101934868;
        if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
        {
          int v54 = *(char *)(a1 + 192);
          double v55 = sub_1008ADB4C((uint64_t)v86);
          double v56 = sub_1008ADB70((uint64_t)v86);
          unint64_t v57 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
          *(_DWORD *)buf = 67240961;
          *(_DWORD *)&uint8_t buf[4] = v54;
          *(_WORD *)&uint8_t buf[8] = 2049;
          *(double *)&buf[10] = v55;
          *(_WORD *)&buf[18] = 2049;
          *(double *)&buf[20] = v56;
          __int16 v91 = 2050;
          unint64_t v92 = v57;
          _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_INFO,  "@GtsSync, CsSession, %{public}c, llsw, %{private}.2lf, %{private}.2lf, queue, %{public}ld",  buf,  0x26u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          uint64_t v68 = qword_101934868;
          int v69 = *(char *)(a1 + 192);
          double v70 = sub_1008ADB4C((uint64_t)v86);
          double v71 = sub_1008ADB70((uint64_t)v86);
          unint64_t v72 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
          int v80 = 67240961;
          *(_DWORD *)__int16 v81 = v69;
          *(_WORD *)&v81[4] = 2049;
          *(double *)&v81[6] = v70;
          __int16 v82 = 2049;
          __int16 v83 = *(const char **)&v71;
          __int16 v84 = 2050;
          unint64_t v85 = v72;
          LODWORD(v74) = 38;
          __int16 v73 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v68,  1LL,  "@GtsSync, CsSession, %{public}c, llsw, %{private}.2lf, %{private}.2lf, queue, %{public}ld",  &v80,  v74);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<BOOL, BOOL, BOOL> CLTileSyncManager::handleEnqueueChangesCompanion(NSDictionary *)",  "%s\n",  v73);
          if (v73 != buf) {
            free(v73);
          }
        }

        LOBYTE(v32) = *(void *)(a1 + 176) == *(void *)(a1 + 168);
        if (SHIBYTE(v88) < 0) {
          operator delete((void *)__p);
        }
LABEL_99:
        LOBYTE(v2) = 1;
        goto LABEL_100;
      }

      if (v31 != 77)
      {
LABEL_57:
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        int v32 = (os_log_s *)qword_101934868;
        if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
        {
          int v33 = *(char *)(a1 + 192);
          *(_DWORD *)buf = 67240192;
          *(_DWORD *)&uint8_t buf[4] = v33;
          _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "@GtsFlow, CS, enqueueChanges, 3, Unexpected change type, %{public}c",  buf,  8u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          int v34 = *(char *)(a1 + 192);
          *(_DWORD *)v86 = 67240192;
          *(_DWORD *)&v86[4] = v34;
          LODWORD(v74) = 8;
          int v32 = (os_log_s *)buf;
          uint64_t v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsFlow, CS, enqueueChanges, 3, Unexpected change type, %{public}c",  v86,  v74);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<BOOL, BOOL, BOOL> CLTileSyncManager::handleEnqueueChangesCompanion(NSDictionary *)",  "%s\n",  v35);
          if (v35 != buf) {
            free(v35);
          }
        }

        goto LABEL_100;
      }
    }

    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    __int16 v37 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
    {
      int v38 = *(char *)(a1 + 192);
      *(_DWORD *)buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v38;
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "@GtsFlow, CS, enqueueChanges, 3, Manifest, %{public}c",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      int v39 = *(char *)(a1 + 192);
      *(_DWORD *)v86 = 67240192;
      *(_DWORD *)&v86[4] = v39;
      LODWORD(v74) = 8;
      __int128 v40 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsFlow, CS, enqueueChanges, 3, Manifest, %{public}c",  v86,  v74);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<BOOL, BOOL, BOOL> CLTileSyncManager::handleEnqueueChangesCompanion(NSDictionary *)",  "%s\n",  v40);
      if (v40 != buf) {
        free(v40);
      }
    }

void sub_10021F768( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void *__p, uint64_t a35, int a36, __int16 a37, char a38, char a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10021F7D4()
{
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  uint64_t v0 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67240704;
    int v9 = 0;
    __int16 v10 = 1026;
    int v11 = 1;
    __int16 v12 = 1026;
    int v13 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_INFO,  "@GtsSync, enqueue return, change, %{public}d, complete, %{public}d, large, %{public}d",  buf,  0x14u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    v3[0] = 67240704;
    v3[1] = 0;
    __int16 v4 = 1026;
    int v5 = 1;
    __int16 v6 = 1026;
    int v7 = 0;
    id v2 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsSync, enqueue return, change, %{public}d, complete, %{public}d, large, %{public}d",  v3,  20);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::tuple<BOOL, BOOL, BOOL> CLTileSyncManager::handleEnqueueChangesGizmo(NSDictionary *)",  "%s\n",  v2);
  }

  return 256LL;
}

void sub_10021F9AC(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56)))
  {
    __int16 v4 = (__int128 *)(a2 + 48);
    if (!*(_DWORD *)(a2 + 48))
    {
      if ((*(_BYTE *)(a1 + 160) & 0xFE) == 0x4C)
      {
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        int v5 = (os_log_s *)qword_101934868;
        if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
        {
          int v6 = *(char *)(a1 + 160);
          *(_DWORD *)buf = 67240192;
          LODWORD(v45) = v6;
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "@GtsPair, skipevent, add, blocking sync state, %{public}c",  buf,  8u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          int v7 = *(char *)(a1 + 160);
          int v36 = 67240192;
          LODWORD(v37) = v7;
          double v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsPair, skipevent, add, blocking sync state, %{public}c",  &v36,  8);
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::addTileSync(CLTileFile *)", "%s\n", v8);
LABEL_44:
        }
      }

      else
      {
        int v9 = *(__int128 **)(a1 + 168);
        __int16 v10 = *(__int128 **)(a1 + 176);
        if (v9 == v10)
        {
          uint64_t v11 = *(void *)(a1 + 168);
        }

        else
        {
          while ((sub_1008ADB94((uint64_t)v9, a2 + 48) & 1) == 0)
          {
            v9 += 3;
            if (v9 == v10)
            {
              int v9 = v10;
              break;
            }
          }

          uint64_t v11 = (uint64_t)v9;
          int v9 = *(__int128 **)(a1 + 176);
        }

        if ((__int128 *)v11 != v9)
        {
          sub_100222E74((uint64_t)buf, (__int128 *)(v11 + 48), v9, v11);
          uint64_t v13 = v12;
          for (uint64_t i = *(void *)(a1 + 176); i != v13; i -= 48LL)
          {
          }

          *(void *)(a1 + 176) = v13;
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          BOOL v15 = (os_log_s *)qword_101934868;
          if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
          {
            double v16 = sub_1008ADB4C(a2 + 48);
            double v17 = sub_1008ADB70(a2 + 48);
            unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
            *(_DWORD *)buf = 134284033;
            double v45 = v16;
            __int16 v46 = 2049;
            double v47 = v17;
            __int16 v48 = 2050;
            unint64_t v49 = v18;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "@GtsCont, replaceadd, llsw, %{private}.2lf, %{private}.2lf, size, %{public}ld",  buf,  0x20u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934860 != -1) {
              dispatch_once(&qword_101934860, &stru_10182B5B0);
            }
            uint64_t v30 = qword_101934868;
            double v31 = sub_1008ADB4C(a2 + 48);
            double v32 = sub_1008ADB70(a2 + 48);
            unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
            int v36 = 134284033;
            double v37 = v31;
            __int16 v38 = 2049;
            double v39 = v32;
            __int16 v40 = 2050;
            unint64_t v41 = v33;
            int v34 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v30,  1LL,  "@GtsCont, replaceadd, llsw, %{private}.2lf, %{private}.2lf, size, %{public}ld",  &v36,  32);
            sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::addTileSync(CLTileFile *)", "%s\n", v34);
          }
        }

        int v19 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 32LL))(*(void *)(a1 + 48), a2);
        if (v19)
        {
          sub_100221F80((uint64_t *)(a1 + 168), *(void *)(a1 + 168), (unint64_t)v4);
        }

        else
        {
          unint64_t v20 = *(void *)(a1 + 176);
          if (v20 >= *(void *)(a1 + 184))
          {
            uint64_t v21 = sub_10022358C((uint64_t *)(a1 + 168), v4);
          }

          else
          {
            sub_100222F00(a1 + 168, v4);
            uint64_t v21 = v20 + 48;
          }

          *(void *)(a1 + 176) = v21;
        }

        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        uint64_t v22 = (os_log_s *)qword_101934868;
        if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
        {
          double v23 = sub_1008ADB4C((uint64_t)v4);
          double v24 = sub_1008ADB70((uint64_t)v4);
          unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
          *(_DWORD *)buf = 134284289;
          double v45 = v23;
          __int16 v46 = 2049;
          double v47 = v24;
          __int16 v48 = 2050;
          unint64_t v49 = v25;
          __int16 v50 = 1024;
          int v51 = v19;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "@GtsCont, add, llsw, %{private}.2lf, %{private}.2lf, size, %{public}ld, current, {public}%d",  buf,  0x26u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          uint64_t v26 = qword_101934868;
          double v27 = sub_1008ADB4C((uint64_t)v4);
          double v28 = sub_1008ADB70((uint64_t)v4);
          unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
          int v36 = 134284289;
          double v37 = v27;
          __int16 v38 = 2049;
          double v39 = v28;
          __int16 v40 = 2050;
          unint64_t v41 = v29;
          __int16 v42 = 1024;
          int v43 = v19;
          LODWORD(v35) = 38;
          double v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  1LL,  "@GtsCont, add, llsw, %{private}.2lf, %{private}.2lf, size, %{public}ld, current, {public}%d",  &v36,  v35);
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::addTileSync(CLTileFile *)", "%s\n", v8);
          goto LABEL_44;
        }
      }
    }
  }

BOOL sub_100220038(uint64_t a1, unsigned int *a2)
{
  if (v45[144])
  {
    *(void *)uint64_t v59 = 0LL;
    *(void *)&v59[8] = v59;
    *(void *)&v59[16] = 0x3812000000LL;
    id v60 = sub_100222924;
    unint64_t v61 = sub_100222934;
    uint64_t v62 = 0LL;
    sub_100F7D280(*(void *)(a1 + 144), (uint64_t)a2, (std::string::size_type *)v63);
    uint64_t v4 = *(void *)(*(void *)&v59[8] + 48LL);
    BOOL v5 = v4 != 0;
    if (v4)
    {
      double v6 = (*(double (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56));
      double v7 = (*(double (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56));
      sub_10021BB68( a1 + 208,  *(_DWORD *)(*(void *)(*(void *)&v59[8] + 48LL) + 8LL) - **(_DWORD **)(*(void *)&v59[8] + 48LL),  v7);
      double v8 = objc_alloc(&OBJC_CLASS___NSData);
      int v9 = *(uint64_t **)(*(void *)&v59[8] + 48LL);
      uint64_t v10 = *v9;
      uint64_t v11 = v9[1];
      uint64_t v12 = v11 - *v9;
      if (v11 == *v9) {
        sub_100092C20();
      }
      v44[0] = _NSConcreteStackBlock;
      v44[1] = 3221225472LL;
      v44[2] = nullsub_127;
      v44[3] = &unk_10182B568;
      v44[4] = v59;
      uint64_t v13 =  -[NSData initWithBytesNoCopy:length:deallocator:]( v8,  "initWithBytesNoCopy:length:deallocator:",  v10,  v12,  v44);
      sub_1008AD030(a2, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      BOOL v15 = +[NSDictionary dictionaryWithObjectsAndKeys:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjectsAndKeys:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", p_p),  @"kSYDictionaryObjectSyncIDKey",  v13,  @"kCLTileSyncObjectDataKey",  +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v6),  @"kCLTileSyncObjectSyncTimestampKey",  0LL);
      double v16 = *(void **)(a1 + 24);
      sub_1008AD030(a2, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        double v17 = &__p;
      }
      else {
        double v17 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      objc_msgSend( v16,  "setObjectIdentifier:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v17));
      [*(id *)(a1 + 24) setChangeType:1];
      [*(id *)(a1 + 24) setProperties:v15];
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      unint64_t v18 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
      {
        double v19 = sub_1008ADB4C((uint64_t)a2);
        double v20 = sub_1008ADB70((uint64_t)a2);
        unsigned int v21 = a2[1];
        unsigned int v22 = a2[2];
        uint64_t v23 = *(void *)(*(void *)(*(void *)&v59[8] + 48LL) + 8LL) - **(void **)(*(void *)&v59[8] + 48LL);
        unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
        LODWORD(__p.__r_.__value_.__l.__data_) = 134284801;
        *(double *)((char *)__p.__r_.__value_.__r.__words + 4) = v19;
        WORD2(__p.__r_.__value_.__r.__words[1]) = 2049;
        *(double *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v20;
        HIWORD(__p.__r_.__value_.__r.__words[2]) = 1025;
        unsigned int v65 = v21;
        __int16 v66 = 1025;
        unsigned int v67 = v22;
        __int16 v68 = 2050;
        uint64_t v69 = v23;
        __int16 v70 = 2050;
        unint64_t v71 = v24;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "@GtsComp, add, llsw, %{private}.2lf, %{private}.2lf, tile_x, %{private}d, tile_y, %{private}d, tilesize, %{pub lic}ld, queue, %{public}lu",  (uint8_t *)&__p,  0x36u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_33;
      }
      bzero(&__p, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      uint64_t v25 = qword_101934868;
      double v26 = sub_1008ADB4C((uint64_t)a2);
      double v27 = sub_1008ADB70((uint64_t)a2);
      unsigned int v28 = a2[1];
      unsigned int v29 = a2[2];
      uint64_t v30 = *(void *)(*(void *)(*(void *)&v59[8] + 48LL) + 8LL) - **(void **)(*(void *)&v59[8] + 48LL);
      unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
      int v47 = 134284801;
      double v48 = v26;
      __int16 v49 = 2049;
      double v50 = v27;
      __int16 v51 = 1025;
      unsigned int v52 = v28;
      __int16 v53 = 1025;
      unsigned int v54 = v29;
      __int16 v55 = 2050;
      uint64_t v56 = v30;
      __int16 v57 = 2050;
      unint64_t v58 = v31;
      LODWORD(v43) = 54;
      double v32 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v25,  1LL,  "@GtsComp, add, llsw, %{private}.2lf, %{private}.2lf, tile_x, %{private}d, t ile_y, %{private}d, tilesize, %{public}ld, queue, %{public}lu",  &v47,  v43);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileSyncManager::sendEventToGizmo(TileId &)",  "%s\n",  (const char *)v32);
    }

    else
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      int v36 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p.__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_ERROR,  "Unable to send #tile, it is missing",  (uint8_t *)&__p,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_33;
      }
      bzero(&__p, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      LOWORD(v47) = 0;
      double v32 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  qword_101934868,  16LL,  "Unable to send #tile, it is missing",  &v47,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTileSyncManager::sendEventToGizmo(TileId &)",  "%s\n",  (const char *)v32);
    }

    if (v32 != &__p) {
      free(v32);
    }
LABEL_33:
    _Block_object_dispose(v59, 8);
    double v37 = (void **)v63[0];
    v63[0] = 0LL;
    if (v37) {
      sub_100223734((int)v63, v37);
    }
    goto LABEL_35;
  }

  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  unint64_t v33 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    double v34 = sub_1008ADB4C((uint64_t)a2);
    double v35 = sub_1008ADB70((uint64_t)a2);
    LODWORD(__p.__r_.__value_.__l.__data_) = 134283777;
    *(double *)((char *)__p.__r_.__value_.__r.__words + 4) = v34;
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2049;
    *(double *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v35;
    _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_INFO,  "@GtsCont, addlost, llsw, %{private}.2lf, %{private}.2lf",  (uint8_t *)&__p,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    uint64_t v39 = qword_101934868;
    double v40 = sub_1008ADB4C((uint64_t)a2);
    double v41 = sub_1008ADB70((uint64_t)a2);
    *(_DWORD *)uint64_t v59 = 134283777;
    *(double *)&v59[4] = v40;
    *(_WORD *)&v59[12] = 2049;
    *(double *)&v59[14] = v41;
    __int16 v42 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v39,  1LL,  "@GtsCont, addlost, llsw, %{private}.2lf, %{private}.2lf",  v59,  22);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLTileSyncManager::sendEventToGizmo(TileId &)",  "%s\n",  (const char *)v42);
    if (v42 != &__p) {
      free(v42);
    }
  }

  BOOL v5 = 0LL;
LABEL_35:
  sub_1001BA1BC(v46);
  return v5;
}

void sub_1002207F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, id a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void **a55,uint64_t a56,void *__p,uint64_t a58,int a59,__int16 a60,char a61,char a62)
{
  int v64 = a55;
  a55 = 0LL;
  if (v64) {
    sub_100223734(v62, v64);
  }
  sub_1001BA1BC(&a39);
  _Unwind_Resume(a1);
}

void sub_100220884(uint64_t a1, int *a2, void *a3, double *a4)
{
  if (*a2) {
    sub_101230AB8();
  }
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16LL))(*(void *)(a1 + 48));
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 64LL))(*(void *)(a1 + 56)) & 1) == 0)
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    BOOL v15 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      LOWORD(buf.__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "@GtsLock, drop add on LS off",  (uint8_t *)&buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      LOWORD(v66) = 0;
      uint64_t v14 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsLock, drop add on LS off",  &v66,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncManager::addTile(const TileId &, NSData *, const CFAbsoluteTime &)",  "%s\n",  (const char *)v14);
      goto LABEL_29;
    }

    return;
  }

  if (*a4 < *(double *)(a1 + 72))
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v9 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      double v10 = *a4;
      std::string::size_type v11 = *(void *)(a1 + 72);
      LODWORD(buf.__r_.__value_.__l.__data_) = 134349312;
      *(double *)((char *)buf.__r_.__value_.__r.__words + 4) = v10;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2050;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "@GtsSync, drop older add, timestamp, %{public}0.1f, toggle/reset, %{public}0.1f",  (uint8_t *)&buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      uint64_t v12 = *(std::string **)a4;
      uint64_t v13 = *(void *)(a1 + 72);
      int v66 = 134349312;
      unsigned int v67 = v12;
      __int16 v68 = 2050;
      uint64_t v69 = v13;
      uint64_t v14 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsSync, drop older add, timestamp, %{public}0.1f, toggle/reset, %{public}0.1f",  &v66,  22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncManager::addTile(const TileId &, NSData *, const CFAbsoluteTime &)",  "%s\n",  (const char *)v14);
LABEL_29:
      if (v14 != &buf) {
        free(v14);
      }
      return;
    }

    return;
  }

  if (!*a2)
  {
    sub_100DFD4E8(a2, (uint64_t)v56);
    uint64_t v19 = sub_1008AE674(a2);
    double v20 = (char *)v19;
    else {
      size_t v21 = *(void *)(v19 + 8);
    }
    p_std::string buf = &buf;
    sub_1000392EC((uint64_t)&buf, v21 + 1);
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
    }
    if (v21)
    {
      if (v20[23] >= 0) {
        uint64_t v23 = v20;
      }
      else {
        uint64_t v23 = *(char **)v20;
      }
      memmove(p_buf, v23, v21);
    }

    *(_WORD *)((char *)&p_buf->__r_.__value_.__l.__data_ + v21) = 47;
    if ((v57 & 0x80u) == 0) {
      unint64_t v24 = v56;
    }
    else {
      unint64_t v24 = (void **)v56[0];
    }
    if ((v57 & 0x80u) == 0) {
      std::string::size_type v25 = v57;
    }
    else {
      std::string::size_type v25 = (std::string::size_type)v56[1];
    }
    double v26 = std::string::append(&buf, (const std::string::value_type *)v24, v25);
    __int128 v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__l.__cap_ = v26->__r_.__value_.__l.__cap_;
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v27;
    v26->__r_.__value_.__l.__size_ = 0LL;
    v26->__r_.__value_.__l.__cap_ = 0LL;
    v26->__r_.__value_.__r.__words[0] = 0LL;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (objc_msgSend( a3,  "writeToFile:atomically:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", p_p),  1))
    {
      sub_100DFA11C(*(void *)(a1 + 144), &__p, (uint64_t)&v66, *a4);
      if (v70 && sub_100924384((uint64_t *)&v66))
      {
        if ((*(unsigned __int8 (**)(void, int *, double))(**(void **)(a1 + 48) + 56LL))( *(void *)(a1 + 48),  &v66,  *a4))
        {
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            unsigned int v29 = &__p;
          }
          else {
            unsigned int v29 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          sub_100292D50((const char *)v29);
        }
      }

      else
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          double v34 = &__p;
        }
        else {
          double v34 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        sub_100C148A0((const char *)v34);
      }

      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_10182B650);
      }
      double v35 = (os_log_s *)qword_101934858;
      if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
      {
        double v36 = sub_1008ADB4C((uint64_t)a2);
        double v37 = sub_1008ADB70((uint64_t)a2);
        uint64_t v38 = sub_100019240(v8 + 184);
        uint64_t v39 = sub_100603208(v8 + 184);
        LODWORD(buf.__r_.__value_.__l.__data_) = 134284289;
        *(double *)((char *)buf.__r_.__value_.__r.__words + 4) = v36;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2049;
        *(double *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v37;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2050;
        uint64_t v72 = v38;
        __int16 v73 = 2050;
        uint64_t v74 = v39;
        _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "@TileList, wifi, add, llsw, %{private}.2lf, %{private}.2lf, sync, size, %{public}lu, unprot size, %{public}lu",  (uint8_t *)&buf,  0x2Au);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_10182B650);
        }
        uint64_t v44 = qword_101934858;
        double v45 = sub_1008ADB4C((uint64_t)a2);
        double v46 = sub_1008ADB70((uint64_t)a2);
        uint64_t v47 = sub_100019240(v8 + 184);
        uint64_t v48 = sub_100603208(v8 + 184);
        int v58 = 134284289;
        double v59 = v45;
        __int16 v60 = 2049;
        double v61 = v46;
        __int16 v62 = 2050;
        uint64_t v63 = v47;
        __int16 v64 = 2050;
        uint64_t v65 = v48;
        __int16 v49 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v44,  0LL,  "@TileList, wifi, add, llsw, %{private}.2lf, %{private}.2lf, sync, size, %{public}lu, unpr ot size, %{public}lu",  &v58,  42);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncManager::addTile(const TileId &, NSData *, const CFAbsoluteTime &)",  "%s\n",  (const char *)v49);
        if (v49 != &buf) {
          free(v49);
        }
      }

      (*(void (**)(void, double))(**(void **)(a1 + 48) + 64LL))(*(void *)(a1 + 48), *a4);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      double v40 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
      {
        double v41 = sub_1008ADB4C((uint64_t)a2);
        double v42 = sub_1008ADB70((uint64_t)a2);
        uint64_t v43 = sub_100019240(v8 + 184);
        LODWORD(buf.__r_.__value_.__l.__data_) = 134284033;
        *(double *)((char *)buf.__r_.__value_.__r.__words + 4) = v41;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2049;
        *(double *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v42;
        HIWORD(buf.__r_.__value_.__r.__words[2]) = 2050;
        uint64_t v72 = v43;
        _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_INFO,  "@GtsLock, add, llsw, %{private}.2lf, %{private}.2lf, mapsize, %{public}ld",  (uint8_t *)&buf,  0x20u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_87;
      }
      bzero(&buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      uint64_t v50 = qword_101934868;
      double v51 = sub_1008ADB4C((uint64_t)a2);
      double v52 = sub_1008ADB70((uint64_t)a2);
      uint64_t v53 = sub_100019240(v8 + 184);
      int v58 = 134284033;
      double v59 = v51;
      __int16 v60 = 2049;
      double v61 = v52;
      __int16 v62 = 2050;
      uint64_t v63 = v53;
      LODWORD(v54) = 32;
      unint64_t v33 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v50,  1LL,  "@GtsLock, add, llsw, %{private}.2lf, %{private}.2lf, mapsize, %{public}ld",  &v58,  v54);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncManager::addTile(const TileId &, NSData *, const CFAbsoluteTime &)",  "%s\n",  (const char *)v33);
    }

    else
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      uint64_t v30 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
      {
        unint64_t v31 = &__p;
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          unint64_t v31 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        LODWORD(buf.__r_.__value_.__l.__data_) = 136380675;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v31;
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_ERROR,  "Failed writing tile to file, %{private}s",  (uint8_t *)&buf,  0xCu);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_87;
      }
      bzero(&buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      double v32 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        double v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      int v66 = 136380675;
      unsigned int v67 = v32;
      unint64_t v33 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934868,  16LL,  "Failed writing tile to file, %{private}s",  &v66,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLTileSyncManager::addTile(const TileId &, NSData *, const CFAbsoluteTime &)",  "%s\n",  (const char *)v33);
    }

    if (v33 != &buf) {
      free(v33);
    }
LABEL_87:
    return;
  }

  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  double v16 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_ERROR))
  {
    int v17 = *a2;
    LODWORD(buf.__r_.__value_.__l.__data_) = 67240192;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "@GtsError, Adding non-Wifi tile, %{public}d, #CloneMe",  (uint8_t *)&buf,  8u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v18 = *a2;
    int v66 = 67240192;
    LODWORD(v67) = v18;
    uint64_t v14 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934868,  16LL,  "@GtsError, Adding non-Wifi tile, %{public}d, #CloneMe",  &v66,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLTileSyncManager::addTile(const TileId &, NSData *, const CFAbsoluteTime &)",  "%s\n",  (const char *)v14);
    goto LABEL_29;
  }

void sub_1002213F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10022146C(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56));
  if ((_DWORD)result) {
    return sub_1002214D4(a1);
  }
  return result;
}

uint64_t sub_1002214D4(uint64_t result)
{
  if (*(_BYTE *)(result + 80))
  {
    uint64_t v1 = result;
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    id v2 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "@GtsGiz, reclearing", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      v4[0] = 0;
      uint64_t v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsGiz, reclearing",  v4,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::handleFirstUnlockGizmo()", "%s\n", v3);
    }

    *(_BYTE *)(v1 + 8sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0;
    return (*(uint64_t (**)(void))(**(void **)(v1 + 48) + 40LL))(*(void *)(v1 + 48));
  }

  return result;
}

void sub_100221680(uint64_t a1)
{
}

void sub_1002216C0(uint64_t a1)
{
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  id v2 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
    int v4 = *(_DWORD *)(a1 + 196);
    *(_DWORD *)std::string buf = 134349312;
    unint64_t v13 = v3;
    __int16 v14 = 1026;
    int v15 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "@GtsMgr, Nearby, queue, %{public}lu, sessionErrors, %{public}d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
    int v6 = *(_DWORD *)(a1 + 196);
    int v8 = 134349312;
    unint64_t v9 = v5;
    __int16 v10 = 1026;
    int v11 = v6;
    double v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsMgr, Nearby, queue, %{public}lu, sessionErrors, %{public}d",  &v8,  18);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::handleNearbyCompanion()", "%s\n", v7);
  }

  if (*(_DWORD *)(a1 + 196)) {
    sub_10021CBAC(a1, (uint64_t)"Nearby", 1.0);
  }
}

void sub_1002218D4(uint64_t a1, int a2)
{
  *(double *)(a1 + 72) = (*(double (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56));
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56)))
  {
    id v4 = [*(id *)(a1 + 64) silo];
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    _DWORD v5[2] = sub_100221B3C;
    v5[3] = &unk_10182B540;
    v5[4] = a1;
    int v6 = a2;
    [v4 async:v5];
  }

void sub_100221988(uint64_t a1, int a2)
{
  char v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 24LL))(*(void *)(a1 + 48));
  if (!a2 && (v4 & 1) == 0)
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    unint64_t v5 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "@GtsGiz, reclear pending", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      v7[0] = 0;
      int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsGiz, reclear pending",  v7,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLTileSyncManager::handleToggleResetGizmo(int)", "%s\n", v6);
    }

    *(_BYTE *)(a1 + 8sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 1;
  }

void sub_100221B3C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (qword_101934860 != -1) {
    dispatch_once(&qword_101934860, &stru_10182B5B0);
  }
  unint64_t v3 = (os_log_s *)qword_101934868;
  if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
  {
    int v4 = *(_DWORD *)(a1 + 40);
    unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v2 + 176) - *(void *)(v2 + 168)) >> 4);
    *(_DWORD *)std::string buf = 67240448;
    int v13 = v4;
    __int16 v14 = 2050;
    unint64_t v15 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "@GtsCont, ToggleReset, %{public}d, queuewas, %{public}ld",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v6 = *(_DWORD *)(a1 + 40);
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v2 + 176) - *(void *)(v2 + 168)) >> 4);
    v9[0] = 67240448;
    v9[1] = v6;
    __int16 v10 = 2050;
    unint64_t v11 = v7;
    int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsCont, ToggleReset, %{public}d, queuewas, %{public}ld",  v9,  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLTileSyncManager::handleToggleResetCompanion(int)_block_invoke",  "%s\n",  v8);
  }

  sub_100222E28((uint64_t *)(v2 + 168));
}

void sub_100221D40(uint64_t a1, uint64_t a2, double a3, double a4)
{
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 24LL))(*(void *)(a1 + 56)) & 1) == 0)
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    int v8 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)std::string buf = 136446723;
      uint64_t v17 = a2;
      __int16 v18 = 2049;
      double v19 = a3;
      __int16 v20 = 2049;
      double v21 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "@GtsCont, %{public}s, llsw, %{private}.2lf, %{private}.2lf",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      int v10 = 136446723;
      uint64_t v11 = a2;
      __int16 v12 = 2049;
      double v13 = a3;
      __int16 v14 = 2049;
      double v15 = a4;
      unint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsCont, %{public}s, llsw, %{private}.2lf, %{private}.2lf",  &v10,  32);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileSyncManager::handleTileAdded(const char *, double, double)",  "%s\n",  v9);
    }

    sub_10021CBAC(a1, a2, 30.0);
  }

void sub_100221F48(uint64_t a1, _DWORD *a2)
{
  unint64_t v3 = (unsigned int *)(a1 + 208);
  double v4 = (*(double (**)(void))(**(void **)(a1 + 56) + 32LL))(*(void *)(a1 + 56));
  sub_10021BD98(v3, a2, v4);
}

unint64_t sub_100221F80(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v4 = a2;
  uint64_t v7 = *a1;
  unint64_t v6 = a1[1];
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a2 - *a1) >> 4);
  unint64_t v11 = a1[2];
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = v11;
  if (v6 >= v11)
  {
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - v7) >> 4) + 1;
    if (v13 > 0x555555555555555LL) {
      sub_100007008();
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v7) >> 4);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v15 = 0x555555555555555LL;
    }
    else {
      unint64_t v15 = v13;
    }
    uint64_t v22 = v9;
    if (v15) {
      double v16 = (char *)sub_1000BB1F4(v9, v15);
    }
    else {
      double v16 = 0LL;
    }
    __int16 v18 = v16;
    double v19 = &v16[48 * v8];
    __int16 v20 = v19;
    double v21 = &v16[48 * v15];
    sub_100222FF4(&v18, (__int128 *)a3);
    unint64_t v4 = sub_100223184((uint64_t)a1, &v18, (__int128 *)v4);
    sub_100223504((uint64_t)&v18);
  }

  else if (a2 == v6)
  {
    sub_100222F00((uint64_t)a1, (__int128 *)a3);
  }

  else
  {
    sub_100222F70((uint64_t)a1, a2, v6, a2 + 48);
    if (v4 <= a3) {
      a3 += 48LL * (a1[1] > a3);
    }
    __int128 v12 = *(_OWORD *)a3;
    *(void *)(v4 + 16) = *(void *)(a3 + 16);
    *(_OWORD *)unint64_t v4 = v12;
    std::string::operator=((std::string *)(v7 + 48 * v8 + 24), (const std::string *)(a3 + 24));
  }

  return v4;
}

void sub_1002220F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10022210C(uint64_t a1, uint64_t a2)
{
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 56) + 16LL))(*(void *)(a1 + 56)) & 1) != 0)
  {
    if ((*(unsigned int (**)(void))(**(void **)(a1 + 56) + 48LL))(*(void *)(a1 + 56)))
    {
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      unint64_t v4 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "@GtsManif, skip, direct", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        LOWORD(v32) = 0;
        unint64_t v5 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  0LL,  "@GtsManif, skip, direct",  &v32,  2);
LABEL_19:
        uint64_t v7 = (uint8_t *)v5;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileSyncManager::sendCompanionManifest(const char *)",  "%s\n",  v5);
        if (v7 != buf) {
          free(v7);
        }
      }
    }

    else
    {
      uint64_t v31 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 16LL))(*(void *)(a1 + 48));
      BOOL v8 = !(*(unsigned int (**)(void))(**(void **)(a1 + 48) + 24LL))(*(void *)(a1 + 48))
        || *(_BYTE *)(a1 + 160) != 83
        || sub_100019240(v31 + 184) == 0;
      uint64_t v10 = *(void *)(a1 + 168);
      uint64_t v9 = *(void *)(a1 + 176);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
      __int128 v12 = (os_log_s *)qword_101934868;
      if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
      {
        int v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 24LL))(*(void *)(a1 + 48)) ^ 1;
        int v14 = *(char *)(a1 + 160);
        uint64_t v15 = sub_100019240(v31 + 184);
        unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
        *(_DWORD *)std::string buf = 136447234;
        uint64_t v43 = a2;
        __int16 v44 = 1026;
        BOOL v45 = v13;
        __int16 v46 = 1026;
        BOOL v47 = v14;
        p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
        __int16 v48 = 2050;
        uint64_t v49 = v15;
        __int16 v50 = 2050;
        unint64_t v51 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "@GtsManif, check, %{public}s, state, %{public}d, %{public}c, %{public}lu, sync, %{public}lu",  buf,  0x2Cu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        uint64_t v20 = qword_101934868;
        int v21 = (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 24LL))(*(void *)(a1 + 48)) ^ 1;
        int v22 = *(char *)(a1 + 160);
        uint64_t v23 = sub_100019240(v31 + 184);
        unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 176) - *(void *)(a1 + 168)) >> 4);
        int v32 = 136447234;
        uint64_t v33 = a2;
        __int16 v34 = 1026;
        BOOL v35 = v21;
        __int16 v36 = 1026;
        BOOL v37 = v22;
        __int16 v38 = 2050;
        uint64_t v39 = v23;
        __int16 v40 = 2050;
        unint64_t v41 = v24;
        std::string::size_type v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  1LL,  "@GtsManif, check, %{public}s, state, %{public}d, %{public}c, %{public}lu, sync, %{public}lu",  &v32,  44);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileSyncManager::sendCompanionManifest(const char *)",  "%s\n",  v25);
        p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
      }

      int v17 = v9 != v10 || v8;
      if (v17 == 1)
      {
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        __int16 v18 = (os_log_s *)p_vtable[269];
        if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)std::string buf = 136446722;
          uint64_t v43 = a2;
          __int16 v44 = 1026;
          BOOL v45 = v8;
          __int16 v46 = 1026;
          BOOL v47 = v9 != v10;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "@GtsManif, skip, %{public}s, state, %{public}d, sync, %{public}d",  buf,  0x18u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          double v26 = p_vtable[269];
          int v32 = 136446722;
          uint64_t v33 = a2;
          __int16 v34 = 1026;
          BOOL v35 = v8;
          __int16 v36 = 1026;
          BOOL v37 = v9 != v10;
          LODWORD(v3sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 24;
          __int128 v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  1LL,  "@GtsManif, skip, %{public}s, state, %{public}d, sync, %{public}d",  &v32,  v30);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileSyncManager::sendCompanionManifest(const char *)",  "%s\n",  v27);
        }

        if (v9 != v10) {
          sub_10021CBAC(a1, (uint64_t)"Syncing", 30.0);
        }
      }

      else
      {
        sub_10021DD2C(a1, 0);
        if (qword_101934860 != -1) {
          dispatch_once(&qword_101934860, &stru_10182B5B0);
        }
        double v19 = (os_log_s *)p_vtable[269];
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "@GtsFlow, CS, setHasChanges, 1, SendManifest",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934860 != -1) {
            dispatch_once(&qword_101934860, &stru_10182B5B0);
          }
          unsigned int v28 = p_vtable[269];
          LOWORD(v32) = 0;
          LODWORD(v3sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 2;
          unsigned int v29 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v28,  0LL,  "@GtsFlow, CS, setHasChanges, 1, SendManifest",  &v32,  v30);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLTileSyncManager::sendCompanionManifest(const char *)",  "%s\n",  v29);
        }

        [*(id *)(a1 + 8) setHasChangesAvailable];
      }
    }
  }

  else
  {
    if (qword_101934860 != -1) {
      dispatch_once(&qword_101934860, &stru_10182B5B0);
    }
    unint64_t v6 = (os_log_s *)qword_101934868;
    if (os_log_type_enabled((os_log_t)qword_101934868, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "@GtsManif, return, not companion", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934860 != -1) {
        dispatch_once(&qword_101934860, &stru_10182B5B0);
      }
      LOWORD(v32) = 0;
      unint64_t v5 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934868,  1LL,  "@GtsManif, return, not companion",  &v32,  2);
      goto LABEL_19;
    }
  }

uint64_t sub_100222924(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0LL;
  *(void *)(result + 48) = v2;
  return result;
}

void sub_100222934(uint64_t a1)
{
  unint64_t v3 = *(void ***)(a1 + 48);
  uint64_t v1 = (void *)(a1 + 48);
  uint64_t v2 = v3;
  *uint64_t v1 = 0LL;
  if (v3) {
    sub_100223734((int)v1, v2);
  }
}

void sub_10022294C(id a1)
{
  qword_101934868 = (uint64_t)os_log_create("com.apple.locationd.Position", "WifiPosition");
}

Class sub_100222978()
{
  if (qword_101993C68 != -1) {
    dispatch_once(&qword_101993C68, &stru_10182B5D0);
  }
  Class result = objc_getClass("SYDictionaryObject");
  qword_101993C60 = (uint64_t)result;
  off_1019362A0 = sub_1002229D4;
  return result;
}

uint64_t sub_1002229D4()
{
  return qword_101993C60;
}

void sub_1002229E0(id a1)
{
  qword_101993C70 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/CompanionSync.framework/CompanionSync", 2);
}

void sub_100222A08(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

Class sub_100222A34()
{
  if (qword_101993C80 != -1) {
    dispatch_once(&qword_101993C80, &stru_10182B610);
  }
  Class result = objc_getClass("PSYSyncCoordinator");
  qword_101993C78 = (uint64_t)result;
  off_101936488 = sub_100222A90;
  return result;
}

uint64_t sub_100222A90()
{
  return qword_101993C78;
}

void sub_100222A9C(id a1)
{
  qword_101993C88 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/PairedSync.framework/PairedSync", 2);
}

Class sub_100222AC4()
{
  if (qword_101993C80 != -1) {
    dispatch_once(&qword_101993C80, &stru_10182B610);
  }
  Class result = objc_getClass("PSYInitialSyncStateObserver");
  qword_101993C90 = (uint64_t)result;
  off_101936490 = sub_100222B20;
  return result;
}

uint64_t sub_100222B20()
{
  return qword_101993C90;
}

Class sub_100222B2C()
{
  if (qword_101993C68 != -1) {
    dispatch_once(&qword_101993C68, &stru_10182B5D0);
  }
  Class result = objc_getClass("SYService");
  qword_101993C98 = (uint64_t)result;
  off_101936498 = sub_100222B88;
  return result;
}

uint64_t sub_100222B88()
{
  return qword_101993C98;
}

void *sub_100222B94(void *a1, uint64_t a2, int a3)
{
  *a1 = os_transaction_create(a2);
  a1[1] = 0LL;
  if (!a3)
  {
    a1[1] = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2);
    if (qword_101934A50 != -1) {
      dispatch_once(&qword_101934A50, &stru_10182B630);
    }
    unint64_t v6 = (os_log_s *)qword_101934A58;
    if (os_log_type_enabled((os_log_t)qword_101934A58, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = a1[1];
      *(_DWORD *)std::string buf = 134349314;
      unint64_t v16 = a1;
      __int16 v17 = 2114;
      uint64_t v18 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "os_transaction created: (%{public}p) %{public}@",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A50 != -1) {
        dispatch_once(&qword_101934A50, &stru_10182B630);
      }
      uint64_t v9 = a1[1];
      int v11 = 134349314;
      __int128 v12 = a1;
      __int16 v13 = 2114;
      uint64_t v14 = v9;
      uint64_t v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A58,  0LL,  "os_transaction created: (%{public}p) %{public}@",  &v11,  22);
      sub_10029211C( "Generic",  1LL,  0LL,  2LL,  "CLAutoOSTransaction::CLAutoOSTransaction(const char *, LoggingPolicy)",  "%s\n",  v10);
    }
  }

  return a1;
}

void sub_100222D90(id a1)
{
  qword_101934A58 = (uint64_t)os_log_create("com.apple.locationd.Utility", "QA");
}

void sub_100222DBC(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

void sub_100222DE8(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100222E28((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_100222E28(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 48LL)
  {
  }

  a1[1] = v2;
}

__int128 *sub_100222E74(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  unint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      __int128 v7 = *v5;
      *(void *)(a4 + 16) = *((void *)v5 + 2);
      *(_OWORD *)a4 = v7;
      BOOL v8 = (void **)(a4 + 24);
      __int128 v9 = *(__int128 *)((char *)v5 + 24);
      *(void *)(a4 + 4sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = *((void *)v5 + 5);
      *(_OWORD *)BOOL v8 = v9;
      *((_BYTE *)v5 + 47) = 0;
      *((_BYTE *)v5 + 24) = 0;
      a4 += 48LL;
      v5 += 3;
    }

    while (v5 != a3);
    return a3;
  }

  return v5;
}

_BYTE *sub_100222F00(uint64_t a1, __int128 *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  __int128 v4 = *a2;
  *(void *)(v3 + 16) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v3 = v4;
  Class result = (_BYTE *)(v3 + 24);
  if (*((char *)a2 + 47) < 0)
  {
    Class result = sub_1010DD48C(result, *((void **)a2 + 3), *((void *)a2 + 4));
  }

  else
  {
    __int128 v6 = *(__int128 *)((char *)a2 + 24);
    *(void *)(v3 + 4sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = *((void *)a2 + 5);
    *(_OWORD *)Class result = v6;
  }

  *(void *)(a1 + 8) = v3 + 48;
  return result;
}

void sub_100222F68(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_100222F70(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    unint64_t v9 = v7;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      __int128 v10 = *(_OWORD *)v9;
      *(void *)(v8 + 16) = *(void *)(v9 + 16);
      *(_OWORD *)uint64_t v8 = v10;
      __int128 v11 = *(_OWORD *)(v9 + 24);
      *(void *)(v8 + 4sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = *(void *)(v9 + 40);
      *(_OWORD *)(v8 + 24) = v11;
      *(void *)(v9 + 32) = 0LL;
      *(void *)(v9 + 4sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0LL;
      *(void *)(v9 + 24) = 0LL;
      v8 += 48LL;
      v9 += 48LL;
    }

    while (v9 < a3);
  }

  *(void *)(a1 + 8) = v8;
  return sub_100223234((uint64_t)&v13, a2, v7, v6);
}

_BYTE *sub_100222FF4(void *a1, __int128 *a2)
{
  uint64_t v4 = a1[2];
  if (v4 == a1[3])
  {
    unint64_t v5 = (__int128 *)a1[1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == *a1) {
        unint64_t v10 = 1LL;
      }
      else {
        unint64_t v10 = 0x5555555555555556LL * ((v4 - *a1) >> 4);
      }
      unint64_t v11 = v10 >> 2;
      uint64_t v12 = a1[4];
      uint64_t v30 = a1[4];
      char v13 = (char *)sub_1000BB1F4(v12, v10);
      uint64_t v15 = &v13[48 * v11];
      unint64_t v16 = a1[1];
      unint64_t v17 = a1[2] - v16;
      if (v17)
      {
        uint64_t v18 = &v15[v17];
        double v19 = &v13[48 * v11];
        do
        {
          __int128 v20 = *(_OWORD *)v16;
          *((void *)v19 + 2) = *(void *)(v16 + 16);
          *(_OWORD *)double v19 = v20;
          __int128 v21 = *(_OWORD *)(v16 + 24);
          *((void *)v19 + 5) = *(void *)(v16 + 40);
          *(_OWORD *)(v19 + 24) = v21;
          *(void *)(v16 + 32) = 0LL;
          *(void *)(v16 + 4sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0LL;
          *(void *)(v16 + 24) = 0LL;
          v19 += 48;
          v16 += 48LL;
        }

        while (v19 != v18);
        int64x2_t v22 = *(int64x2_t *)(a1 + 1);
      }

      else
      {
        int64x2_t v22 = vdupq_n_s64(v16);
        uint64_t v18 = &v13[48 * v11];
      }

      uint64_t v27 = *a1;
      *a1 = v13;
      a1[1] = v15;
      int64x2_t v28 = v22;
      uint64_t v23 = a1[3];
      a1[2] = v18;
      a1[3] = &v13[48 * v14];
      uint64_t v29 = v23;
      sub_100223504((uint64_t)&v27);
      uint64_t v4 = a1[2];
    }

    else
    {
      int64_t v6 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v5 - *a1) >> 4);
      if (v6 >= -1) {
        uint64_t v7 = v6 + 1;
      }
      else {
        uint64_t v7 = v6 + 2;
      }
      uint64_t v8 = -3 * (v7 >> 1);
      sub_100222E74((uint64_t)&v27, v5, (__int128 *)v4, (uint64_t)&v5[-3 * (v7 >> 1)]);
      uint64_t v4 = v9;
      a1[1] += 16 * v8;
      a1[2] = v9;
    }
  }

  __int128 v24 = *a2;
  *(void *)(v4 + 16) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v4 = v24;
  Class result = (_BYTE *)(v4 + 24);
  if (*((char *)a2 + 47) < 0)
  {
    Class result = sub_1010DD48C(result, *((void **)a2 + 3), *((void *)a2 + 4));
  }

  else
  {
    __int128 v26 = *(__int128 *)((char *)a2 + 24);
    *(void *)(v4 + 4sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = *((void *)a2 + 5);
    *(_OWORD *)Class result = v26;
  }

  a1[2] += 48LL;
  return result;
}

uint64_t sub_100223184(uint64_t a1, void *a2, __int128 *a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = a1 + 16;
  sub_1002232D4(a1 + 16, (uint64_t)a3, (uint64_t)a3, *(void *)a1, *(void *)a1, v6, v6);
  a2[1] = v8;
  a2[2] = sub_100223380(v7, a3, *(__int128 **)(a1 + 8), a2[2]);
  uint64_t v9 = *(void *)a1;
  *(void *)a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = a2[2];
  a2[2] = v10;
  uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_100223234(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = a3 + v7;
      uint64_t v9 = a4 + v7;
      __int128 v10 = *(_OWORD *)(a3 + v7 - 48);
      *(void *)(v9 - 32) = *(void *)(a3 + v7 - 32);
      *(_OWORD *)(v9 - 48) = v10;
      uint64_t v11 = (void **)(a4 + v7 - 24);
      __int128 v12 = *(_OWORD *)(v8 - 24);
      *(void *)(a4 + v7 - 8) = *(void *)(v8 - 8);
      *(_OWORD *)uint64_t v11 = v12;
      *(_BYTE *)(v8 - 1) = 0;
      *(_BYTE *)(v8 - 24) = 0;
      v7 -= 48LL;
    }

    while (a3 + v7 != a2);
  }

  return a3;
}

uint64_t sub_1002232D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v16 = a6;
  *((void *)&v16 + 1) = a7;
  __int128 v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  _DWORD v13[2] = &v16;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      __int128 v10 = *(_OWORD *)(a3 - 48);
      *(void *)(v9 - 32) = *(void *)(a3 - 32);
      *(_OWORD *)(v9 - 48) = v10;
      __int128 v11 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v11;
      v9 -= 48LL;
      *(void *)(a3 - 16) = 0LL;
      *(void *)(a3 - 8) = 0LL;
      *(void *)(a3 - 24) = 0LL;
      v7 -= 48LL;
      a3 -= 48LL;
    }

    while (a3 != a5);
    *((void *)&v16 + 1) = v9;
  }

  char v14 = 1;
  sub_100223414((uint64_t)v13);
  return a6;
}

uint64_t sub_100223380(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v10 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  if (a2 != a3)
  {
    do
    {
      __int128 v5 = *a2;
      *(void *)(v4 + 16) = *((void *)a2 + 2);
      *(_OWORD *)uint64_t v4 = v5;
      __int128 v6 = *(__int128 *)((char *)a2 + 24);
      *(void *)(v4 + 4sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = *((void *)a2 + 5);
      *(_OWORD *)(v4 + 24) = v6;
      *((void *)a2 + 4) = 0LL;
      *((void *)a2 + 5) = 0LL;
      *((void *)a2 + 3) = 0LL;
      v4 += 48LL;
      a2 += 3;
    }

    while (a2 != a3);
    uint64_t v11 = v4;
  }

  char v9 = 1;
  sub_10022348C((uint64_t)v8);
  return v4;
}

uint64_t sub_100223414(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100223448(a1);
  }
  return a1;
}

void sub_100223448(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    v1 += 48LL;
  }

uint64_t sub_10022348C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1002234C0(a1);
  }
  return a1;
}

void sub_1002234C0(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    v1 -= 48LL;
  }

uint64_t sub_100223504(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100223538(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 48;
      *(void *)(a1 + 16) = v2 - 48;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        uint64_t v5 = *(void *)(a1 + 16);
      }

      uint64_t v2 = v5;
    }

    while (v5 != a2);
  }

uint64_t sub_10022358C(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x555555555555555LL) {
    sub_100007008();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v9 = 0x555555555555555LL;
  }
  else {
    unint64_t v9 = v5;
  }
  __int128 v20 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_1000BB1F4(v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t v11 = &v10[48 * v4];
  v17[0] = v10;
  v17[1] = v11;
  uint64_t v18 = v11;
  double v19 = &v10[48 * v9];
  __int128 v12 = *a2;
  *((void *)v11 + 2) = *((void *)a2 + 2);
  *(_OWORD *)uint64_t v11 = v12;
  char v13 = v11 + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_1010DD48C(v13, *((void **)a2 + 3), *((void *)a2 + 4));
    uint64_t v11 = v18;
  }

  else
  {
    __int128 v14 = *(__int128 *)((char *)a2 + 24);
    *((void *)v11 + 5) = *((void *)a2 + 5);
    *(_OWORD *)char v13 = v14;
  }

  uint64_t v18 = v11 + 48;
  sub_1002236C0(a1, v17);
  uint64_t v15 = a1[1];
  sub_100223504((uint64_t)v17);
  return v15;
}

void sub_1002236AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1002236C0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1002232D4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void sub_100223734(int a1, void **__p)
{
  if (__p)
  {
    uint64_t v3 = *__p;
    if (*__p)
    {
      __p[1] = v3;
      operator delete(v3);
    }

    operator delete(__p);
  }

BOOL sub_10022376C()
{
  return os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT);
}

BOOL sub_100223780()
{
  return os_log_type_enabled(*(os_log_t *)(v0 + 2680), OS_LOG_TYPE_INFO);
}

BOOL sub_100223790()
{
  return os_signpost_enabled(*(os_log_t *)(v0 + 2680));
}

void sub_10022379C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936068);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936068))
    {
      qword_101936050 = 0LL;
      *(void *)algn_101936058 = 0LL;
      qword_101936060 = 0LL;
      __cxa_atexit((void (*)(void *))sub_1001BA3E4, &qword_101936050, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936068);
    }
  }

void sub_100223800()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936118);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936118))
    {
      std::__shared_mutex_base::__shared_mutex_base(&stru_101936070);
      __cxa_atexit((void (*)(void *))sub_1001BA414, &stru_101936070, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936118);
    }
  }

void sub_100223874(_Unwind_Exception *a1)
{
}

uint64_t sub_100223F88(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v10 = v5++ >= 9;
      if (v10)
      {
        unint64_t v6 = 0LL;
        int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v11 || (v6 & 7) == 4) {
      break;
    }
    switch((v6 >> 3))
    {
      case 1u:
        char v13 = 0;
        unsigned int v14 = 0;
        uint64_t v15 = 0LL;
        while (1)
        {
          uint64_t v16 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v17 = v16 + 1;
          if (v16 == -1 || v17 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v18 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v16);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v17;
          v15 |= (unint64_t)(v18 & 0x7F) << v13;
          if ((v18 & 0x80) == 0) {
            goto LABEL_59;
          }
          v13 += 7;
          BOOL v10 = v14++ >= 9;
          if (v10)
          {
            LODWORD(v15) = 0;
            goto LABEL_61;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_59:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v15) = 0;
        }
LABEL_61:
        uint64_t v42 = 8LL;
        goto LABEL_78;
      case 2u:
        char v20 = 0;
        unsigned int v21 = 0;
        uint64_t v15 = 0LL;
        *(_BYTE *)(a1 + 32) |= 1u;
        while (2)
        {
          uint64_t v22 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v23 = v22 + 1;
          if (v22 == -1 || v23 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v24 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v22);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v23;
            v15 |= (unint64_t)(v24 & 0x7F) << v20;
            if (v24 < 0)
            {
              v20 += 7;
              BOOL v10 = v21++ >= 9;
              if (v10)
              {
                LODWORD(v15) = 0;
                goto LABEL_65;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v15) = 0;
        }
LABEL_65:
        uint64_t v42 = 12LL;
        goto LABEL_78;
      case 3u:
        char v25 = 0;
        unsigned int v26 = 0;
        uint64_t v15 = 0LL;
        *(_BYTE *)(a1 + 32) |= 2u;
        while (2)
        {
          uint64_t v27 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v28 = v27 + 1;
          if (v27 == -1 || v28 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v29 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v27);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v28;
            v15 |= (unint64_t)(v29 & 0x7F) << v25;
            if (v29 < 0)
            {
              v25 += 7;
              BOOL v10 = v26++ >= 9;
              if (v10)
              {
                LODWORD(v15) = 0;
                goto LABEL_69;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v15) = 0;
        }
LABEL_69:
        uint64_t v42 = 16LL;
        goto LABEL_78;
      case 4u:
        *(_BYTE *)(a1 + 32) |= 0x10u;
        unint64_t v30 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v30 <= 0xFFFFFFFFFFFFFFFBLL && v30 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          int v31 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v30);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v30 + 4;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          int v31 = 0;
        }

        *(_DWORD *)(a1 + 28) = v31;
        continue;
      case 5u:
        char v32 = 0;
        unsigned int v33 = 0;
        uint64_t v15 = 0LL;
        *(_BYTE *)(a1 + 32) |= 4u;
        while (2)
        {
          uint64_t v34 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v35 = v34 + 1;
          if (v34 == -1 || v35 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v36 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v34);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v35;
            v15 |= (unint64_t)(v36 & 0x7F) << v32;
            if (v36 < 0)
            {
              v32 += 7;
              BOOL v10 = v33++ >= 9;
              if (v10)
              {
                LODWORD(v15) = 0;
                goto LABEL_73;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v15) = 0;
        }
LABEL_73:
        uint64_t v42 = 20LL;
        goto LABEL_78;
      case 6u:
        char v37 = 0;
        unsigned int v38 = 0;
        uint64_t v15 = 0LL;
        *(_BYTE *)(a1 + 32) |= 8u;
        break;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        continue;
    }

    while (1)
    {
      uint64_t v39 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v40 = v39 + 1;
      if (v39 == -1 || v40 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v41 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v39);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v40;
      v15 |= (unint64_t)(v41 & 0x7F) << v37;
      if ((v41 & 0x80) == 0) {
        goto LABEL_75;
      }
      v37 += 7;
      BOOL v10 = v38++ >= 9;
      if (v10)
      {
        LODWORD(v15) = 0;
        goto LABEL_77;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_75:
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      LODWORD(v15) = 0;
    }
LABEL_77:
    uint64_t v42 = 24LL;
LABEL_78:
    *(_DWORD *)(a1 + v42) = v15;
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

uint64_t sub_100225464(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    char v4 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    unsigned int v5 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    unint64_t v6 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    uint64_t v7 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    unint64_t v8 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    char v9 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    BOOL v10 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    int v11 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    __int128 v12 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    char v13 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    unsigned int v14 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    uint64_t v15 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    do
    {
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        break;
      }
      char v16 = 0;
      unsigned int v17 = 0;
      unint64_t v18 = 0LL;
      while (1)
      {
        uint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        unint64_t v20 = v19 + 1;
        if (v19 == -1 || v20 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v21 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v20;
        v18 |= (unint64_t)(v21 & 0x7F) << v16;
        if ((v21 & 0x80) == 0) {
          goto LABEL_12;
        }
        v16 += 7;
        BOOL v22 = v17++ >= 9;
        if (v22)
        {
          unint64_t v18 = 0LL;
          int v23 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_12:
      int v23 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        unint64_t v18 = 0LL;
      }
LABEL_14:
      if (v23 || (v18 & 7) == 4) {
        break;
      }
      switch((v18 >> 3))
      {
        case 1u:
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 0x100u;
          unint64_t v25 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v25 <= 0xFFFFFFFFFFFFFFF7LL && v25 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v26 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v25);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v25 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v26 = 0LL;
          }

          uint64_t v74 = *((int *)v5 + 421);
          goto LABEL_128;
        case 2u:
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 8u;
          unint64_t v34 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v34 <= 0xFFFFFFFFFFFFFFF7LL && v34 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v26 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v34);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v34 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v26 = 0LL;
          }

          uint64_t v74 = *((int *)v6 + 422);
          goto LABEL_128;
        case 3u:
          char v35 = 0;
          unsigned int v36 = 0;
          uint64_t v37 = 0LL;
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 0x1000u;
          while (2)
          {
            uint64_t v38 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v39 = v38 + 1;
            if (v38 == -1 || v39 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v40 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v38);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v39;
              v37 |= (unint64_t)(v40 & 0x7F) << v35;
              if (v40 < 0)
              {
                v35 += 7;
                BOOL v22 = v36++ >= 9;
                if (v22)
                {
                  LODWORD(v37) = 0;
                  goto LABEL_89;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v37) = 0;
          }
LABEL_89:
          uint64_t v71 = *((int *)v7 + 423);
          goto LABEL_107;
        case 4u:
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 1u;
          unint64_t v41 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v41 <= 0xFFFFFFFFFFFFFFF7LL && v41 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v26 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v41);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v41 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v26 = 0LL;
          }

          uint64_t v74 = *((int *)v8 + 424);
          goto LABEL_128;
        case 5u:
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 0x20u;
          unint64_t v42 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v42 <= 0xFFFFFFFFFFFFFFF7LL && v42 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v26 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v42);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v42 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v26 = 0LL;
          }

          uint64_t v74 = *((int *)v9 + 425);
          goto LABEL_128;
        case 6u:
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 0x40u;
          unint64_t v43 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v43 <= 0xFFFFFFFFFFFFFFF7LL && v43 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v26 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v43);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v43 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v26 = 0LL;
          }

          uint64_t v74 = *((int *)v10 + 426);
          goto LABEL_128;
        case 7u:
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 0x200u;
          unint64_t v44 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v44 <= 0xFFFFFFFFFFFFFFF7LL && v44 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v26 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v44);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v44 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v26 = 0LL;
          }

          uint64_t v74 = *((int *)v11 + 427);
          goto LABEL_128;
        case 8u:
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 0x10u;
          unint64_t v45 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v45 <= 0xFFFFFFFFFFFFFFF7LL && v45 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v26 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v45);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v45 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v26 = 0LL;
          }

          uint64_t v74 = *((int *)v12 + 428);
          goto LABEL_128;
        case 9u:
          char v46 = 0;
          unsigned int v47 = 0;
          uint64_t v37 = 0LL;
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 0x800u;
          while (2)
          {
            uint64_t v48 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v49 = v48 + 1;
            if (v48 == -1 || v49 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v50 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v48);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v49;
              v37 |= (unint64_t)(v50 & 0x7F) << v46;
              if (v50 < 0)
              {
                v46 += 7;
                BOOL v22 = v47++ >= 9;
                if (v22)
                {
                  LODWORD(v37) = 0;
                  goto LABEL_93;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v37) = 0;
          }
LABEL_93:
          uint64_t v71 = *((int *)v13 + 429);
          goto LABEL_107;
        case 0xAu:
          char v51 = 0;
          unsigned int v52 = 0;
          uint64_t v53 = 0LL;
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 0x4000u;
          while (2)
          {
            uint64_t v54 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v55 = v54 + 1;
            if (v54 == -1 || v55 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v56 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v54);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v55;
              v53 |= (unint64_t)(v56 & 0x7F) << v51;
              if (v56 < 0)
              {
                v51 += 7;
                BOOL v22 = v52++ >= 9;
                if (v22)
                {
                  uint64_t v53 = 0LL;
                  goto LABEL_97;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v53 = 0LL;
          }
LABEL_97:
          BOOL v72 = v53 != 0;
          uint64_t v73 = *((int *)v14 + 430);
          goto LABEL_102;
        case 0xBu:
          char v57 = 0;
          unsigned int v58 = 0;
          uint64_t v59 = 0LL;
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 0x2000u;
          while (2)
          {
            uint64_t v60 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v61 = v60 + 1;
            if (v60 == -1 || v61 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v62 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v60);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v61;
              v59 |= (unint64_t)(v62 & 0x7F) << v57;
              if (v62 < 0)
              {
                v57 += 7;
                BOOL v22 = v58++ >= 9;
                if (v22)
                {
                  uint64_t v59 = 0LL;
                  goto LABEL_101;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v59 = 0LL;
          }
LABEL_101:
          BOOL v72 = v59 != 0;
          uint64_t v73 = *((int *)v15 + 431);
LABEL_102:
          *(_BYTE *)(a1 + v73) = v72;
          continue;
        case 0xCu:
          char v63 = 0;
          unsigned int v64 = 0;
          uint64_t v37 = 0LL;
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 0x400u;
          break;
        case 0xDu:
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 4u;
          unint64_t v68 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v68 <= 0xFFFFFFFFFFFFFFF7LL && v68 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v26 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v68);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v68 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v26 = 0LL;
          }

          uint64_t v74 = 24LL;
          goto LABEL_128;
        case 0xEu:
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 2u;
          unint64_t v69 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v69 <= 0xFFFFFFFFFFFFFFF7LL && v69 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v26 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v69);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v69 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v26 = 0LL;
          }

          uint64_t v74 = 16LL;
          goto LABEL_128;
        case 0xFu:
          *(_WORD *)(a1 + *((int *)v4 + 420)) |= 0x80u;
          unint64_t v70 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v70 <= 0xFFFFFFFFFFFFFFF7LL && v70 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v26 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v70);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v70 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v26 = 0LL;
          }

          uint64_t v74 = 64LL;
LABEL_128:
          *(void *)(a1 + v74) = v26;
          continue;
        default:
          uint64_t v27 = v5;
          unint64_t v28 = v6;
          char v29 = v4;
          unint64_t v30 = v7;
          int v31 = v8;
          uint64_t v32 = a1;
          uint64_t result = PBReaderSkipValueWithTag(a2);
          uint64_t v15 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          a1 = v32;
          char v9 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          unint64_t v8 = v31;
          BOOL v10 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          uint64_t v7 = v30;
          int v11 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          char v4 = v29;
          unsigned int v14 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          unint64_t v6 = v28;
          __int128 v12 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          unsigned int v5 = v27;
          char v13 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          if (!(_DWORD)result) {
            return result;
          }
          continue;
      }

      while (1)
      {
        uint64_t v65 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        unint64_t v66 = v65 + 1;
        if (v65 == -1 || v66 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v67 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v65);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v66;
        v37 |= (unint64_t)(v67 & 0x7F) << v63;
        if ((v67 & 0x80) == 0) {
          goto LABEL_104;
        }
        v63 += 7;
        BOOL v22 = v64++ >= 9;
        if (v22)
        {
          LODWORD(v37) = 0;
          goto LABEL_106;
        }
      }

      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_104:
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v37) = 0;
      }
LABEL_106:
      uint64_t v71 = 88LL;
LABEL_107:
      *(_DWORD *)(a1 + v71) = v37;
    }

    while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length));
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

double sub_100227054(uint64_t a1)
{
  uint64_t v1 = sub_100ACA534(a1, 1);
  *(void *)uint64_t v1 = off_10182B6A0;
  *(void *)(v1 + 96) = &_mh_execute_header;
  *(void *)(v1 + 104) = 26LL;
  *(_DWORD *)(v1 + 112) = 0;
  *(_BYTE *)(v1 + 12sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0;
  *(_BYTE *)(v1 + 128) = 0;
  *(void *)(v1 + 136) = 0x7FF0000000000000LL;
  *(_BYTE *)(v1 + 144) = 0;
  *(void *)(v1 + 152) = 0LL;
  double result = 2.22507386e-308;
  *(_OWORD *)(v1 + 16sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = xmmword_1012E2690;
  *(_BYTE *)(v1 + 176) = 0;
  *(void *)(v1 + 184) = 0x10000000000000LL;
  *(_DWORD *)(v1 + 192) = 0;
  *(void *)(v1 + 20sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0LL;
  *(_BYTE *)(v1 + 208) = 0;
  *(_BYTE *)(v1 + 216) = 0;
  return result;
}

void sub_1002270D4(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 96) != a2)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182B748);
    }
    char v4 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
    {
      uint64_t v5 = *(int *)(a1 + 96);
      v6[0] = 68289538;
      v6[1] = 0;
      __int16 v7 = 2082;
      unint64_t v8 = "";
      __int16 v9 = 2050;
      uint64_t v10 = a2;
      __int16 v11 = 2050;
      uint64_t v12 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Changing source state, new state:%{public, location:CLStreamingAwareLocationProvide rLocalGPSStateMachine::LocationSourceState}lld, old state:%{public, location:CLStreamingAwareLocationProvide rLocalGPSStateMachine::LocationSourceState}lld}",  (uint8_t *)v6,  0x26u);
    }

    *(_DWORD *)(a1 + 96) = a2;
    if (a2 != 1) {
      *(_DWORD *)(a1 + 10sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 1;
    }
  }

void sub_1002271F4(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 96) != 1) {
    sub_101230C48();
  }
  int v4 = *(_DWORD *)(a1 + 100);
  if (v4 != a2)
  {
    if (a2 != 1 || v4 != 2) {
      goto LABEL_27;
    }
    uint64_t v5 = *(int **)(a1 + 64);
    unint64_t v6 = *(int **)(a1 + 72);
    if (v5 == v6)
    {
      uint64_t v13 = 0LL;
      uint64_t v7 = 0LL;
      uint64_t v10 = 0LL;
      uint64_t v16 = 0LL;
    }

    else
    {
      uint64_t v7 = 0LL;
      unint64_t v8 = *(int **)(a1 + 64);
      do
      {
        int v9 = *v8++;
        if (v9 == 3) {
          ++v7;
        }
      }

      while (v8 != v6);
      uint64_t v10 = 0LL;
      __int16 v11 = *(int **)(a1 + 64);
      do
      {
        int v12 = *v11++;
        if (v12 == 2) {
          ++v10;
        }
      }

      while (v11 != v6);
      uint64_t v13 = 0LL;
      unsigned int v14 = *(int **)(a1 + 64);
      do
      {
        int v15 = *v14++;
        if (v15 == 1) {
          ++v13;
        }
      }

      while (v14 != v6);
      uint64_t v16 = 0LL;
      do
      {
        if (!*v5++) {
          ++v16;
        }
      }

      while (v5 != v6);
    }

    if (v10 > 2 || v13 > 1 || v16 >= 2)
    {
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182B748);
      }
      unint64_t v20 = (os_log_s *)qword_101934998;
      if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = (uint64_t)(*(void *)(a1 + 72) - *(void *)(a1 + 64)) >> 2;
        *(_DWORD *)std::string buf = 134350848;
        *(void *)unint64_t v41 = v7;
        *(_WORD *)&v41[8] = 2050;
        *(void *)&v41[10] = v10;
        *(_WORD *)&v41[18] = 2050;
        *(void *)&v41[20] = 2LL;
        *(_WORD *)&v41[28] = 2050;
        *(void *)&v41[30] = v13;
        __int16 v42 = 2050;
        uint64_t v43 = 1LL;
        __int16 v44 = 2050;
        uint64_t v45 = v16;
        __int16 v46 = 2050;
        uint64_t v47 = 1LL;
        __int16 v48 = 2050;
        uint64_t v49 = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Will not change to remote compatible workout state due to companion not meeting availability criteria,ahq,%{pu blic}ld,a,%{public}ld,thresh_a,%{public}ld,ua,%{public}ld,thresh_ua,%{public}ld,uk,%{public}ld,thresh_uk,%{pub lic}ld,buffsize,%{public}zu",  buf,  0x52u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934990 != -1) {
          dispatch_once(&qword_101934990, &stru_10182B748);
        }
        uint64_t v22 = (uint64_t)(*(void *)(a1 + 72) - *(void *)(a1 + 64)) >> 2;
        int v24 = 134350848;
        uint64_t v25 = v7;
        __int16 v26 = 2050;
        uint64_t v27 = v10;
        __int16 v28 = 2050;
        uint64_t v29 = 2LL;
        __int16 v30 = 2050;
        uint64_t v31 = v13;
        __int16 v32 = 2050;
        uint64_t v33 = 1LL;
        __int16 v34 = 2050;
        uint64_t v35 = v16;
        __int16 v36 = 2050;
        uint64_t v37 = 1LL;
        __int16 v38 = 2050;
        uint64_t v39 = v22;
        int v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934998,  0LL,  "Will not change to remote compatible workout state due to companion not meeting availability cri teria,ahq,%{public}ld,a,%{public}ld,thresh_a,%{public}ld,ua,%{public}ld,thresh_ua,%{public}ld,uk ,%{public}ld,thresh_uk,%{public}ld,buffsize,%{public}zu",  &v24,  82);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStreamingAwareLocationProviderLocalGPSStateMachine::changeWorkoutState(WorkoutState)",  "%s\n",  v23);
      }
    }

    else
    {
LABEL_27:
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182B748);
      }
      unint64_t v18 = (os_log_s *)qword_101934998;
      if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = *(int *)(a1 + 100);
        *(_DWORD *)std::string buf = 68289538;
        *(_DWORD *)unint64_t v41 = 0;
        *(_WORD *)&v41[4] = 2082;
        *(void *)&v41[6] = "";
        *(_WORD *)&v41[14] = 2050;
        *(void *)&v41[16] = a2;
        *(_WORD *)&v41[24] = 2050;
        *(void *)&v41[26] = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Changing workout state, new state:%{public, location:CLStreamingAwareLocationProv iderLocalGPSStateMachine::WorkoutState}lld, old state:%{public, location:CLStreamingAwareLocationProviderL ocalGPSStateMachine::WorkoutState}lld}",  buf,  0x26u);
      }

      *(_DWORD *)(a1 + 10sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = a2;
    }
  }

uint64_t sub_1002275D0(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 96);
  if ((v4 - 2) < 2)
  {
LABEL_11:
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182B748);
    }
    goto LABEL_13;
  }

  if (v4 == 1)
  {
    int v5 = sub_100ACA7BC(a1) ^ 1;
    if ((_DWORD)a2) {
      goto LABEL_11;
    }
  }

  else
  {
    int v5 = 1;
    if ((_DWORD)a2) {
      goto LABEL_11;
    }
  }

  if (!v5) {
    goto LABEL_11;
  }
  *(void *)(a1 + 184) = 0x10000000000000LL;
  *(_DWORD *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 16sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = xmmword_1012E2690;
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182B748);
  }
  unint64_t v6 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
  {
    int v9 = 68289026;
    int v10 = 0;
    __int16 v11 = 2082;
    int v12 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Clearing motion sample data}",  (uint8_t *)&v9,  0x12u);
    goto LABEL_11;
  }

void sub_1002277AC(uint64_t a1)
{
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182B748);
  }
  uint64_t v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(int *)(a1 + 96);
    uint64_t v4 = *(int *)(a1 + 100);
    int v5 = *(unsigned __int8 *)(a1 + 144);
    *(void *)__int16 v13 = 68289794LL;
    *(_WORD *)&v13[8] = 2082;
    *(void *)&v13[10] = "";
    __int16 v14 = 2050;
    uint64_t v15 = v3;
    __int16 v16 = 2050;
    uint64_t v17 = v4;
    __int16 v18 = 1026;
    int v19 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Starting providers, state:%{public, location:CLStreamingAwareLocationProviderLocalGPS StateMachine::LocationSourceState}lld, workoutState:%{public, location:CLStreamingAwareLocationProviderLocalGP SStateMachine::WorkoutState}lld, workoutForceGPSOn:%{public}hhd}",  v13,  0x2Cu);
  }

  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)__int16 v13 = _Q0;
  *(_WORD *)&v13[16] = 0;
  uint64_t v15 = 0LL;
  switch(*(_DWORD *)(a1 + 96))
  {
    case 0:
      sub_100ACB610(a1, 0LL);
      goto LABEL_14;
    case 1:
      if (*(_BYTE *)(a1 + 144))
      {
        sub_100ACB794(a1, 0LL, (uint64_t)v13);
        v13[17] = 1;
        uint64_t v11 = 0LL;
LABEL_12:
        sub_100ACB794(a1, 1LL, (uint64_t)v13);
LABEL_15:
        uint64_t v11 = 0LL;
        goto LABEL_16;
      }

      int v12 = *(_DWORD *)(a1 + 100);
      switch(v12)
      {
        case 0:
          sub_100ACB794(a1, 0LL, (uint64_t)v13);
          uint64_t v11 = 1LL;
          sub_100ACB610(a1, 1LL);
LABEL_16:
          sub_1002275D0(a1, v11);
          return;
        case 1:
          sub_100ACB610(a1, 0LL);
          goto LABEL_24;
        case 2:
          sub_100ACB794(a1, 0LL, (uint64_t)v13);
LABEL_24:
          v13[17] = 1;
          goto LABEL_12;
      }

      return;
    case 2:
    case 4:
      sub_100ACB794(a1, 0LL, (uint64_t)v13);
      goto LABEL_12;
    case 3:
      sub_100ACB610(a1, 0LL);
      goto LABEL_12;
    case 5:
      sub_100ACB794(a1, 0LL, (uint64_t)v13);
LABEL_14:
      sub_100ACB610(a1, 1LL);
      goto LABEL_15;
    default:
      return;
  }

void sub_100227A04(uint64_t a1, double a2)
{
  uint64_t v4 = *(int *)(a1 + 96);
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182B748);
  }
  int v5 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
  {
    v7[0] = 68289282;
    v7[1] = 0;
    __int16 v8 = 2082;
    int v9 = "";
    __int16 v10 = 2050;
    uint64_t v11 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Determining state, current state:%{public, location:CLStreamingAwareLocationProviderL ocalGPSStateMachine::LocationSourceState}lld}",  (uint8_t *)v7,  0x1Cu);
  }

  uint64_t v6 = *(void *)(a1 + 104);
  if (v6 && v6 != 26) {
    sub_100227B34(a1, a2);
  }
  else {
    sub_100227BAC(a1, a2);
  }
  sub_1002277AC(a1);
}

void sub_100227B34(uint64_t a1, double a2)
{
  uint64_t v4 = *(uint64_t **)(a1 + 16);
  if (!v4)
  {
LABEL_6:
    sub_100227BAC(a1, a2);
    return;
  }

  while (1)
  {
    int v5 = *((_DWORD *)v4 + 7);
    if (v5 <= 0) {
      break;
    }
LABEL_5:
    uint64_t v4 = (uint64_t *)*v4;
    if (!v4) {
      goto LABEL_6;
    }
  }

  if (v5 < 0)
  {
    ++v4;
    goto LABEL_5;
  }

  sub_1002270D4(a1, 1);
  sub_1002286CC(a1, a2);
}

void sub_100227BAC(uint64_t a1, double a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(uint64_t **)(a1 + 16);
  if (!v3)
  {
LABEL_16:
    int v10 = 0;
LABEL_24:
    sub_1002270D4(a1, v10);
    return;
  }

  int v5 = *(uint64_t **)(a1 + 16);
  do
  {
    int v6 = *((_DWORD *)v5 + 7);
    if (v6 > 0) {
      goto LABEL_6;
    }
    if ((v6 & 0x80000000) == 0)
    {
      if (sub_100ACA7BC(a1))
      {
        int v14 = *(_DWORD *)(v2 + 112);
        if (v14 != 3)
        {
          if (v14 == 4) {
            goto LABEL_23;
          }
          if (!*(_BYTE *)(v2 + 128)
            || ((double v15 = a2 - *(double *)(v2 + 120), v15 >= 0.0) ? (v16 = v15 > 30.0) : (v16 = 1), v16))
          {
            int v18 = 1;
            int v19 = (unsigned int *)&v18;
            int v17 = *((_DWORD *)sub_100228E48((uint64_t **)(v2 + 40), &v18, (uint64_t)&unk_1012CF090, &v19) + 8);
            uint64_t v12 = v2;
            if (v17 == 1) {
              int v13 = 2;
            }
            else {
              int v13 = 3;
            }
            goto LABEL_26;
          }
        }

        a1 = v2;
        int v10 = 4;
        goto LABEL_24;
      }

void sub_100227D54(uint64_t a1, unsigned int a2, unsigned int *a3, uint64_t a4, double a5)
{
  double v26 = a5;
  int v10 = *(_DWORD *)(a4 + 928);
  if ((*(_DWORD *)(a4 + 96) - 6) >= 3)
  {
    int v11 = *(_DWORD *)(a4 + 436);
    *(_DWORD *)(a1 + 112) = v11;
    if ((v11 - 3) <= 1)
    {
      if (v11 == 4)
      {
        *(double *)(a1 + 12sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = a5;
        *(_BYTE *)(a1 + 128) = 1;
      }

      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182B748);
      }
      uint64_t v12 = (os_log_s *)qword_101934998;
      if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *(_DWORD *)(a4 + 436);
        int v14 = *(_DWORD *)(a4 + 96);
        uint64_t v15 = *(void *)(a4 + 76);
        *(_DWORD *)std::string buf = 68290050;
        __int16 v28 = 2082;
        *(_DWORD *)&uint8_t buf[4] = 0;
        uint64_t v29 = "";
        __int16 v30 = 2050;
        uint64_t v31 = a2;
        __int16 v32 = 1026;
        *(_DWORD *)uint64_t v33 = v13;
        *(_WORD *)&v33[4] = 1026;
        *(_DWORD *)&v33[6] = v14;
        *(_WORD *)__int16 v34 = 2050;
        *(void *)&v34[2] = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#cltr,Received track notification, source:%{public, location:CLStreamingAwareLoca tionProviderStateMachine::LocationSource}lld, trackProximity:%{public}d, type:%{public}d, timestamp :%{public}f}",  buf,  0x32u);
      }
    }
  }

  int v16 = *(_DWORD *)(a1 + 96);
  if (v16 != 1)
  {
    if (v16 != 5)
    {
      if (v16 == 3 && a2 != 1) {
        return;
      }
LABEL_39:
      (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 32) + 8LL))(*(void *)(a1 + 32), *a3, a4);
      return;
    }

    goto LABEL_31;
  }

  if (a2)
  {
    BOOL v17 = a2 == 1;
    BOOL v18 = a2 != 1;
    if (a2 == 1 && v10)
    {
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182B748);
      }
      int v19 = (os_log_s *)qword_101934998;
      if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
      {
        uint64_t v20 = (int)*a3;
        uint64_t v21 = *(unsigned int *)(a4 + 928);
        uint64_t v22 = *(void *)(a4 + 76);
        *(_DWORD *)std::string buf = 68290050;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v28 = 2082;
        uint64_t v29 = "";
        __int16 v30 = 2050;
        uint64_t v31 = 1LL;
        __int16 v32 = 2050;
        *(void *)uint64_t v33 = v20;
        *(_WORD *)&v33[8] = 2050;
        *(void *)__int16 v34 = v21;
        *(_WORD *)&v34[8] = 2050;
        uint64_t v35 = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received motion rich location notification, source:%{public, location:CLStreaming AwareLocationProviderStateMachine::LocationSource}lld, notification:%{public, location:CLLocationProvider_ Type::Notification}lld, motion data:%{public, location:CLLocationProvider_Type::MotionDetected}lld, time stamp:%{public}f}",  buf,  0x3Au);
      }

      sub_1002280B8(a1, (int *)(a4 + 928), (double *)(a4 + 76), &v26);
      BOOL v17 = 1;
    }
  }

  else
  {
    BOOL v17 = 0;
    *(double *)(a1 + 208) = a5;
    BOOL v18 = 1;
    *(_BYTE *)(a1 + 216) = 1;
  }

  int v23 = *(_DWORD *)(a1 + 100);
  if (v23 != 2)
  {
    if (v23 == 1)
    {
      if (!v17) {
        return;
      }
      goto LABEL_39;
    }

    if (v23) {
      goto LABEL_39;
    }
  }

  if (a2) {
    char v24 = v18;
  }
  else {
    char v24 = 1;
  }
  if ((v24 & 1) != 0)
  {
LABEL_31:
    if (a2) {
      return;
    }
    goto LABEL_39;
  }

  if ((*(void *)(a1 + 104) | 8LL) != 0x1B)
  {
    int v25 = 0;
    *(void *)std::string buf = &v25;
    if (*((_DWORD *)sub_100228E48((uint64_t **)(a1 + 40), &v25, (uint64_t)&unk_1012CF090, (unsigned int **)buf) + 8) != 3
      || !*(_BYTE *)(a1 + 216)
      || vabdd_f64(a5, *(double *)(a1 + 208)) >= 4.0)
    {
      goto LABEL_39;
    }
  }

uint64_t sub_1002280B8(uint64_t a1, int *a2, double *a3, double *a4)
{
  int v6 = *a2;
  if (*a2 == *(_DWORD *)(a1 + 192))
  {
    double v7 = *(double *)(a1 + 184);
    if (v7 >= *a3) {
      double v7 = *a3;
    }
  }

  else
  {
    *(_DWORD *)(a1 + 192) = v6;
    double v7 = *a3;
  }

  *(double *)(a1 + 184) = v7;
  double v8 = v7 + 30.0;
  if (v6 == 1) {
    double v7 = v7 + 15.0;
  }
  if (v6 == 2) {
    double v9 = v8;
  }
  else {
    double v9 = v7;
  }
  if (v9 <= *a4)
  {
    double v9 = INFINITY;
  }

  else
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182B748);
    }
    int v10 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
    {
      double v11 = *a4;
      double v12 = v9 - *a4;
      *(_DWORD *)std::string buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v25 = 2082;
      double v26 = "";
      __int16 v27 = 2050;
      double v28 = v11;
      __int16 v29 = 2050;
      double v30 = v9;
      __int16 v31 = 2050;
      double v32 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Scheduling timer for motion confidence, now_s:%{public}.09f, fire time_s: %{public}.09f, delta_s:%{public}.09f}",  buf,  0x30u);
    }
  }

  if (!*(void *)(a1 + 200))
  {
    (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 32) + 32LL))(buf);
    uint64_t v13 = *(void *)buf;
    *(void *)std::string buf = 0LL;
    uint64_t v14 = *(void *)(a1 + 200);
    *(void *)(a1 + 20sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = v13;
    if (v14)
    {
      (*(void (**)(uint64_t))(*(void *)v14 + 40LL))(v14);
      uint64_t v15 = *(void *)buf;
      *(void *)std::string buf = 0LL;
      if (v15) {
        (*(void (**)(uint64_t))(*(void *)v15 + 40LL))(v15);
      }
    }

    uint64_t v16 = *(void *)(a1 + 200);
    v22[0] = &off_10182B808;
    v22[1] = a1;
    int v23 = v22;
    (*(void (**)(uint64_t, void *))(*(void *)v16 + 8LL))(v16, v22);
    BOOL v17 = v23;
    if (v23 == v22)
    {
      uint64_t v18 = 4LL;
      BOOL v17 = v22;
    }

    else
    {
      if (!v23) {
        goto LABEL_26;
      }
      uint64_t v18 = 5LL;
    }

    (*(void (**)(void))(*v17 + 8 * v18))();
  }

void sub_100228318( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12)
{
  uint64_t v14 = a12;
  if (a12 == v12)
  {
    uint64_t v15 = 4LL;
    uint64_t v14 = &a9;
  }

  else
  {
    if (!a12) {
      goto LABEL_6;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_100228358(uint64_t a1, uint64_t a2, double a3)
{
  unint64_t v4 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = a2;
  if (!a2 || a2 == 26)
  {
    int v5 = 0;
    *(void *)(a1 + 136) = 0x7FF0000000000000LL;
    goto LABEL_23;
  }

  if (v4 > 0x21) {
    goto LABEL_10;
  }
  if (((1LL << v4) & 0x201028006LL) != 0)
  {
    int v6 = 0;
    goto LABEL_11;
  }

  if (((1LL << v4) & 0x4000001) != 0) {
    goto LABEL_20;
  }
  if (((1LL << v4) & 0x8080000) != 0) {
    int v6 = 1;
  }
  else {
LABEL_10:
  }
    int v6 = 2;
LABEL_11:
  int v7 = 0;
  if (a2 > 26)
  {
    if (a2 != 33)
    {
      if (a2 == 27) {
LABEL_15:
      }
        int v7 = 1;
      else {
LABEL_17:
      }
        int v7 = 2;
    }
  }

  else
  {
    switch(a2)
    {
      case 15LL:
      case 17LL:
      case 24LL:
        break;
      case 16LL:
      case 18LL:
      case 20LL:
      case 21LL:
      case 22LL:
      case 23LL:
        goto LABEL_17;
      case 19LL:
        goto LABEL_15;
      default:
        break;
    }
  }

  if (v6 == v7)
  {
    int v5 = 0;
    goto LABEL_23;
  }

double sub_100228588(uint64_t a1, uint64_t a2)
{
  double result = *(double *)a2;
  uint64_t v3 = *(void *)(a2 + 208);
  *(void *)(a1 + 16sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = *(void *)a2;
  *(void *)(a1 + 168) = v3;
  return result;
}

uint64_t sub_100228598(uint64_t result, unsigned int a2, double a3)
{
  unsigned int v7 = a2;
  double v6 = a3;
  if (*(_DWORD *)(result + 96) == 1)
  {
    uint64_t v4 = result;
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182B748);
    }
    int v5 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      __int16 v11 = "";
      __int16 v12 = 2050;
      uint64_t v13 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Motion alarm fired, detected motion:%{public, location:CLLocationProvider_Type::Mot ionDetected}lld}",  buf,  0x1Cu);
    }

    return sub_1002280B8(v4, (int *)&v7, &v6, &v6);
  }

  return result;
}

void sub_1002286B4(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 96);
  if (v1) {
    BOOL v2 = v1 == 3;
  }
  else {
    BOOL v2 = 1;
  }
  if (!v2) {
    sub_1002277AC(a1);
  }
}

uint64_t sub_1002286CC(uint64_t a1, double a2)
{
  unint64_t v4 = *(void *)(a1 + 104);
  if (v4 > 0x21)
  {
LABEL_65:
    uint64_t v6 = 0LL;
    int v5 = 2;
    goto LABEL_4;
  }

  if (((1LL << v4) & 0x201028006LL) == 0)
  {
    if (((1LL << v4) & 0x8080000) != 0)
    {
      uint64_t v6 = 0LL;
      char v7 = 0;
      int v5 = 1;
      goto LABEL_7;
    }

    if (((1LL << v4) & 0x4000001) != 0) {
      sub_101230DB4();
    }
    goto LABEL_65;
  }

  int v5 = 0;
  uint64_t v6 = 1LL;
LABEL_4:
  char v7 = 1;
LABEL_7:
  if (v5 == 2)
  {
    uint64_t v6 = 0LL;
    int v9 = 0;
    int v8 = 1;
    goto LABEL_10;
  }

  if (v5 == 1)
  {
    uint64_t v6 = 0LL;
LABEL_9:
    int v8 = 0;
    int v9 = 1;
    goto LABEL_10;
  }

  int v12 = *(_DWORD *)(a1 + 192);
  if (v12 == 1)
  {
    if (a2 - *(double *)(a1 + 184) >= 15.0)
    {
      int v9 = 0;
      int v8 = 1;
      goto LABEL_68;
    }

    goto LABEL_67;
  }

  if (v12 != 2
    || a2 - *(double *)(a1 + 184) < 30.0
    || *(double *)(a1 + 160) + 15.0 <= a2
    || *(double *)(a1 + 168) <= 0.0)
  {
LABEL_67:
    int v9 = 0;
    int v8 = 0;
    goto LABEL_68;
  }

  int v8 = 0;
  int v9 = 1;
LABEL_68:
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182B748);
  }
  __int16 v25 = (os_log_s *)qword_101934998;
  uint64_t v6 = 1LL;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
  {
    uint64_t v26 = *(unsigned int *)(a1 + 192);
    uint64_t v27 = *(void *)(a1 + 184);
    *(_DWORD *)std::string buf = 68290306;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v34 = 2082;
    uint64_t v35 = "";
    __int16 v36 = 2050;
    uint64_t v37 = v26;
    __int16 v38 = 2050;
    uint64_t v39 = v27;
    __int16 v40 = 2050;
    double v41 = a2;
    __int16 v42 = 1026;
    int v43 = v8;
    __int16 v44 = 1026;
    int v45 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:In pedestrian workout, Motion compatible?, remote motion:%{public, location:CLLocatio nProvider_Type::MotionDetected}lld, sample time_s:%{public}.09f, now_s:%{public}.09f, prefer rem ote:%{public}hhd, prefer local:%{public}hhd}",  buf,  0x3Cu);
  }

void sub_100228D08( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char *a16)
{
  uint64_t v18 = a16;
  if (a16 == v16)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = &a13;
  }

  else
  {
    if (!a16) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*(void *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_100228D4C(void *a1)
{
  int v1 = (void *)sub_100228D94(a1);
  operator delete(v1);
}

uint64_t sub_100228D60(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = a2;
  return result;
}

void sub_100228D68(id a1)
{
  qword_101934998 = (uint64_t)os_log_create("com.apple.locationd.Core", "Streaming");
}

uint64_t sub_100228D94(void *a1)
{
  *a1 = off_10182B6A0;
  uint64_t v2 = a1[25];
  a1[25] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 40LL))(v2);
  }
  uint64_t v3 = a1[19];
  a1[19] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40LL))(v3);
  }
  return sub_100228DF0((uint64_t)a1);
}

uint64_t sub_100228DF0(uint64_t a1)
{
  *(void *)a1 = off_10186DE18;
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(void *)(a1 + 72) = v2;
    operator delete(v2);
  }

  sub_100008390(a1 + 40, *(void **)(a1 + 48));
  sub_100008390(a1 + 8, *(void **)(a1 + 16));
  return a1;
}

uint64_t *sub_100228E48(uint64_t **a1, int *a2, uint64_t a3, unsigned int **a4)
{
  char v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        int v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        char v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        char v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    int v9 = a1 + 1;
LABEL_10:
    double v11 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v11 + 28) = **a4;
    sub_1000085FC(a1, (uint64_t)v9, v7, v11);
    return v11;
  }

  return (uint64_t *)v9;
}

void *sub_100228F0C(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &off_10182B778;
  result[1] = v3;
  return result;
}

uint64_t sub_100228F40(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10182B778;
  a2[1] = v2;
  return result;
}

uint64_t sub_100228F5C(uint64_t a1, double *a2)
{
  double v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182B748);
  }
  unint64_t v4 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 68289026;
    v6[1] = 0;
    __int16 v7 = 2082;
    int v8 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Reconsidering forced GPS state}",  (uint8_t *)v6,  0x12u);
  }

  return (*(uint64_t (**)(uint64_t, double))(*(void *)v3 + 96LL))(v3, v2);
}

uint64_t sub_100229054(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100229090()
{
}

void *sub_1002290A4(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &off_10182B808;
  result[1] = v3;
  return result;
}

uint64_t sub_1002290D8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10182B808;
  a2[1] = v2;
  return result;
}

uint64_t sub_1002290F4(uint64_t a1, double *a2)
{
  double v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182B748);
  }
  unint64_t v4 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 68289026;
    v6[1] = 0;
    __int16 v7 = 2082;
    int v8 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Reconsidering motion compatibility}",  (uint8_t *)v6,  0x12u);
  }

  return (*(uint64_t (**)(uint64_t, double))(*(void *)v3 + 96LL))(v3, v2);
}

uint64_t sub_1002291EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100229228()
{
}

BOOL sub_100229234()
{
  return os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_FAULT);
}

BOOL sub_100229248()
{
  return os_log_type_enabled(*(os_log_t *)(v0 + 2456), OS_LOG_TYPE_INFO);
}

BOOL sub_100229258()
{
  return os_signpost_enabled(*(os_log_t *)(v0 + 2456));
}

void sub_100229308(id a1)
{
  qword_101993CA0 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLHealthAssessmentNotifierSilo");
}

uint64_t sub_1002298D8(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10022E4C4;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_101993CC0 != -1) {
    dispatch_once(&qword_101993CC0, block);
  }
  return qword_1019A0E00;
}

void sub_100229DDC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void sub_100229DF8(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 109))
  {
    if ((sub_1004F97F4() & 0x10000000) != 0)
    {
      unsigned __int8 v18 = 0;
      sub_100231D7C(&v18, &v19);
      sub_10005F550(a1 + 160, (__int128 *)&v19);
      double v2 = (std::__shared_weak_count *)v19.n128_u64[1];
      if (v19.n128_u64[1])
      {
        uint64_t v3 = (unint64_t *)(v19.n128_u64[1] + 8);
        do
          unint64_t v4 = __ldaxr(v3);
        while (__stlxr(v4 - 1, v3));
        if (!v4)
        {
          ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
          std::__shared_weak_count::__release_weak(v2);
        }
      }

      int v5 = operator new(0x30uLL);
      uint64_t v6 = (uint64_t)v5;
      unint64_t v7 = *(void *)(a1 + 168);
      v19.n128_u64[0] = *(void *)(a1 + 160);
      v19.n128_u64[1] = v7;
      if (v7)
      {
        int v8 = (unint64_t *)(v7 + 8);
        do
          unint64_t v9 = __ldxr(v8);
        while (__stxr(v9 + 1, v8));
      }

      sub_1001B4E14((uint64_t)v5, (uint64_t *)&v19);
      int v10 = (std::__shared_weak_count *)v19.n128_u64[1];
      if (v19.n128_u64[1])
      {
        double v11 = (unint64_t *)(v19.n128_u64[1] + 8);
        do
          unint64_t v12 = __ldaxr(v11);
        while (__stlxr(v12 - 1, v11));
        if (!v12)
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }

      sub_1001B4F90((uint64_t *)(a1 + 176), v6);
      sub_10022E794(*(void ***)(a1 + 176), 604800.0);
    }

    sub_1005C4E40((uint64_t)sub_10022EA48, a1, *(void **)(a1 + 32), &v19);
    unint64_t v13 = v19.n128_u64[0];
    v19.n128_u64[0] = 0LL;
    uint64_t v14 = *(void *)(a1 + 280);
    *(void *)(a1 + 28sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = v13;
    if (v14)
    {
      (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
      unint64_t v15 = v19.n128_u64[0];
      v19.n128_u64[0] = 0LL;
      if (v15) {
        (*(void (**)(unint64_t))(*(void *)v15 + 8LL))(v15);
      }
    }

    [*(id *)(*(void *)(a1 + 280) + 16) register:*(void *)(*(void *)(a1 + 280) + 8) forNotification:1 registrationInfo:0];
    [*(id *)(a1 + 32) monitorKinesiasStart];
    v19.n128_u64[0] = v16;
    [*(id *)(a1 + 32) monitorKinesiasExpiration];
    v19.n128_u64[1] = v17;
    sub_10022EC20((void *)(a1 + 184), &v19);
    *(_BYTE *)(a1 + 109) = 1;
  }

void sub_100229FAC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    sub_1012310A8(a12);
  }
  operator delete(v12);
  _Unwind_Resume(a1);
}

id sub_100229FCC(uint64_t a1)
{
  return _[*(id *)(a1 + 32) updateSensorRecorderQuery];
}

id sub_100229FD4(uint64_t a1)
{
  return [*(id *)(a1 + 32) aggregateRecords];
}

id sub_10022A4C4(uint64_t a1)
{
  return [*(id *)(a1 + 32) updateSensorRecorderSubscription];
}

void sub_10022A4CC(uint64_t a1)
{
  if (qword_101934800 != -1) {
    dispatch_once(&qword_101934800, &stru_10182B9E8);
  }
  double v2 = (os_log_s *)off_101934808;
  if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 67240448;
    LODWORD(v17[0]) = 100;
    WORD2(v17[0]) = 1026;
    *(_DWORD *)((char *)v17 + 6) = 100;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Subscribing to Sensor Recorder: Accel Rate %{public}d Gyro Rate %{public}d",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    int v14 = 67240448;
    *(_DWORD *)unint64_t v15 = 100;
    *(_WORD *)&v15[4] = 1026;
    *(_DWORD *)&v15[6] = 100;
    unint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "Subscribing to Sensor Recorder: Accel Rate %{public}d Gyro Rate %{public}d",  &v14,  14);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLHealthAssessmentNotifierAdapter updateSensorRecorderSubscription]_block_invoke",  "%s\n",  v7);
  }

  if ((objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "sensorRecorder"), "setAccelSampleRate:", 100) & 1) == 0)
  {
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    uint64_t v3 = (os_log_s *)off_101934808;
    if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 67240192;
      LODWORD(v17[0]) = 100;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Unable to set sample rate for accel to %{public}d.",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934800 != -1) {
        dispatch_once(&qword_101934800, &stru_10182B9E8);
      }
      int v14 = 67240192;
      *(_DWORD *)unint64_t v15 = 100;
      LODWORD(v13) = 8;
      double v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  16LL,  "Unable to set sample rate for accel to %{public}d.",  &v14,  v13);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CLHealthAssessmentNotifierAdapter updateSensorRecorderSubscription]_block_invoke",  "%s\n",  v11);
    }
  }

  if ((objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "sensorRecorder"), "setGyroSampleRate:", 100) & 1) == 0)
  {
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    unint64_t v4 = (os_log_s *)off_101934808;
    if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 67240192;
      LODWORD(v17[0]) = 100;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Unable to set sample rate for gyro to %{public}d.",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934800 != -1) {
        dispatch_once(&qword_101934800, &stru_10182B9E8);
      }
      int v14 = 67240192;
      *(_DWORD *)unint64_t v15 = 100;
      LODWORD(v13) = 8;
      unint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  16LL,  "Unable to set sample rate for gyro to %{public}d.",  &v14,  v13);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CLHealthAssessmentNotifierAdapter updateSensorRecorderSubscription]_block_invoke",  "%s\n",  v12);
    }
  }

  objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "fSensorRecorderSubscribeTimer"), "setNextFireDelay:", 43200.0);
  if (qword_101934800 != -1) {
    dispatch_once(&qword_101934800, &stru_10182B9E8);
  }
  int v5 = (os_log_s *)off_101934808;
  if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
  {
    objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "fSensorRecorderSubscribeTimer"), "nextFireTime");
    *(_DWORD *)std::string buf = 134349056;
    v17[0] = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "fSensorRecorderSubscribeTimer.nextFireTime, %{public}f",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    int v8 = off_101934808;
    objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "fSensorRecorderSubscribeTimer"), "nextFireTime");
    int v14 = 134349056;
    *(void *)unint64_t v15 = v9;
    LODWORD(v13) = 12;
    int v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v8,  1LL,  "fSensorRecorderSubscribeTimer.nextFireTime, %{public}f",  &v14,  v13);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLHealthAssessmentNotifierAdapter updateSensorRecorderSubscription]_block_invoke",  "%s\n",  v10);
  }

id sub_10022AB20(uint64_t a1)
{
  return objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "fSensorRecorderQueryTimer"), "setNextFireDelay:", 300.0);
}

uint64_t sub_10022C448()
{
  int v5 = 0;
  uint64_t v0 = sub_1002F8DDC();
  sub_1002A7D20(v0, (uint64_t)@"kMonitorKinesiasDBPushErrorCount", &v5);
  uint64_t v1 = sub_1002F8DDC();
  int v4 = v5 + 1;
  sub_1002AC288(v1, @"kMonitorKinesiasDBPushErrorCount", &v4);
  uint64_t v2 = sub_1002F8DDC();
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 944LL))(v2);
}

BOOL sub_10022C4B4(void *a1, double *a2, CFAbsoluteTime *a3, double a4)
{
  if (qword_101934800 != -1) {
    dispatch_once(&qword_101934800, &stru_10182B9E8);
  }
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  uint64_t v9 = (os_log_s *)off_101934808;
  if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
  {
    double v10 = *a2;
    *(_DWORD *)std::string buf = 134349056;
    double v71 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Checking from %{public}.2f", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    double v50 = *a2;
    int v66 = 134349056;
    double v67 = v50;
    char v51 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "Checking from %{public}.2f",  &v66,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHealthAssessmentNotifier::getNextValidPeriod(CFAbsoluteTime *, CFAbsoluteTime *, NSTimeInterval)",  "%s\n",  v51);
  }

  uint64_t v11 = a1[28];
  if (!v11)
  {
LABEL_9:
    *a3 = CFAbsoluteTimeGetCurrent();
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    uint64_t v13 = (os_log_s *)off_101934808;
    if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "No valid monitoring periods seen", buf, 2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    LOWORD(v66) = 0;
    LODWORD(v64) = 2;
    uint64_t v49 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "No valid monitoring periods seen",  &v66,  v64);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHealthAssessmentNotifier::getNextValidPeriod(CFAbsoluteTime *, CFAbsoluteTime *, NSTimeInterval)",  "%s\n",  v49);
LABEL_93:
    return 0LL;
  }

  while (1)
  {
    unint64_t v12 = a1[27];
    a1[28] = v11 - 1;
    a1[27] = v12 + 1;
    sub_100232D40((uint64_t)(a1 + 23), 1);
    uint64_t v11 = a1[28];
    if (!v11) {
      goto LABEL_9;
    }
  }

  if (qword_101934800 != -1) {
    dispatch_once(&qword_101934800, &stru_10182B9E8);
  }
  unint64_t v15 = (os_log_s *)off_101934808;
  if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
  {
    unint64_t v16 = (double *)(*(void *)(a1[24] + ((a1[27] >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * a1[27]);
    double v18 = *v16;
    double v17 = v16[1];
    *(_DWORD *)std::string buf = 134349312;
    double v71 = v18;
    __int16 v72 = 2050;
    CFAbsoluteTime v73 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "Selecting monitoring period: %{public}f - %{public}f",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    unsigned int v52 = (double *)(*(void *)(a1[24] + ((a1[27] >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * a1[27]);
    double v54 = *v52;
    double v53 = v52[1];
    int v66 = 134349312;
    double v67 = v54;
    __int16 v68 = 2050;
    CFAbsoluteTime v69 = v53;
    LODWORD(v64) = 22;
    unint64_t v55 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "Selecting monitoring period: %{public}f - %{public}f",  &v66,  v64);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHealthAssessmentNotifier::getNextValidPeriod(CFAbsoluteTime *, CFAbsoluteTime *, NSTimeInterval)",  "%s\n",  v55);
  }

  __n128 v19 = (CFAbsoluteTime *)(*(void *)(a1[24] + ((a1[27] >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * a1[27]);
  double v20 = *a2;
  if (*a2 < *v19) {
    double v20 = *v19;
  }
  *a2 = v20;
  *a3 = v19[1];
  uint64_t v21 = a1[30];
  if (a1[31] == v21
    || (unint64_t v22 = a1[33],
        uint64_t v23 = (void *)(v21 + 8 * (v22 >> 8)),
        uint64_t v24 = *v23 + 16LL * v22,
        uint64_t v25 = *(void *)(v21 + (((a1[34] + v22) >> 5) & 0x7FFFFFFFFFFFFF8LL))
            + 16LL * (*((_BYTE *)a1 + 272) + v22),
        v24 == v25))
  {
LABEL_66:
    BOOL v29 = 1;
    goto LABEL_67;
  }

  char v26 = 0;
  int v65 = 0;
  uint64_t v27 = (uint64_t)(a1 + 29);
  double v28 = (int64x2_t *)(a1 + 33);
  BOOL v29 = 1;
  while (1)
  {
    double v30 = *(double *)v24;
    if (*(double *)v24 >= *a3)
    {
LABEL_54:
      int v38 = 0;
      goto LABEL_57;
    }

    if ((v26 & 1) != 0)
    {
      if (v30 < *a3 && *(_BYTE *)(v24 + 8) == 0) {
        goto LABEL_56;
      }
      if (qword_101934800 != -1) {
        dispatch_once(&qword_101934800, &stru_10182B9E8);
      }
      double v32 = p_vtable;
      uint64_t v33 = (os_log_s *)p_vtable[257];
      if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_INFO,  "Found two consecutive onWrist events, skipping later one",  buf,  2u);
      }

      p_vtable = v32;
      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934800 != -1) {
          dispatch_once(&qword_101934800, &stru_10182B9E8);
        }
        __int16 v36 = v32[257];
        LOWORD(v66) = 0;
        LODWORD(v64) = 2;
        uint64_t v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v36,  1LL,  "Found two consecutive onWrist events, skipping later one",  &v66,  v64);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHealthAssessmentNotifier::getNextValidPeriod(CFAbsoluteTime *, CFAbsoluteTime *, NSTimeInterval)",  "%s\n",  v37);
      }

      char v26 = 1;
      goto LABEL_46;
    }

    if (v30 > *a2) {
      break;
    }
    char v26 = 0;
    ++v65;
    int v34 = *(unsigned __int8 *)(v24 + 8);
LABEL_45:
    BOOL v29 = v34 != 0;
LABEL_46:
    v24 += 16LL;
    if (v24 - *v23 == 4096)
    {
      uint64_t v35 = v23[1];
      ++v23;
      uint64_t v24 = v35;
    }

    if (v24 == v25) {
      goto LABEL_54;
    }
  }

  if (*(_BYTE *)(v24 + 8))
  {
    if (!v29) {
      *a2 = v30;
    }
    int v34 = 1;
    char v26 = 1;
    goto LABEL_45;
  }

  if (!v29)
  {
    int v34 = 0;
    char v26 = 0;
    goto LABEL_45;
  }

  BOOL v29 = 1;
LABEL_56:
  *a3 = v30;
  int v38 = 1;
LABEL_57:
  if (v65 >= 2)
  {
    unsigned int v39 = v65 + 1;
    do
    {
      *double v28 = vaddq_s64(*v28, (int64x2_t)xmmword_1012CE4D0);
      sub_100232D40(v27, 1);
      --v39;
    }

    while (v39 > 2);
  }

  if (v38)
  {
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    __int16 v40 = (os_log_s *)p_vtable[257];
    if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
    {
      double v41 = *a2;
      CFAbsoluteTime v42 = *a3;
      *(_DWORD *)std::string buf = 134349312;
      double v71 = v41;
      __int16 v72 = 2050;
      CFAbsoluteTime v73 = v42;
      _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_INFO,  "Full on wrist period seen, %{public}0.f - %{public}0.f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934800 != -1) {
        dispatch_once(&qword_101934800, &stru_10182B9E8);
      }
      uint64_t v60 = p_vtable[257];
      double v61 = *a2;
      CFAbsoluteTime v62 = *a3;
      int v66 = 134349312;
      double v67 = v61;
      __int16 v68 = 2050;
      CFAbsoluteTime v69 = v62;
      LODWORD(v64) = 22;
      char v63 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v60,  1LL,  "Full on wrist period seen, %{public}0.f - %{public}0.f",  &v66,  v64);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHealthAssessmentNotifier::getNextValidPeriod(CFAbsoluteTime *, CFAbsoluteTime *, NSTimeInterval)",  "%s\n",  v63);
    }

    goto LABEL_66;
  }

void sub_10022D658(uint64_t a1, void *a2, int a3)
{
  if (a3)
  {
    if (a3 == 1)
    {
      objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", @"time"), "doubleValue");
      double v6 = v5;
      unsigned int v7 = objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", @"score"), "intValue");
      objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", @"likelihood"), "floatValue");
      objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", @"strength"), "floatValue");
      unsigned int v8 = objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", @"tremorScore"), "intValue");
      double v10 = *(double *)(a1 + 112);
      if (v10 == 0.0)
      {
        double v11 = (double)(uint64_t)(v6 / 60.0) * 60.0;
        if (v11 <= v10) {
          double v11 = v11 + 60.0;
        }
        *(_OWORD *)(a1 + 128) = 0u;
        *(_OWORD *)(a1 + 144) = 0u;
        double v12 = v11 + 60.0;
        *(double *)(a1 + 112) = v11;
        *(double *)(a1 + 12sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = v11 + 60.0;
      }

      else
      {
        double v12 = *(double *)(a1 + 120);
      }

      if (v6 >= v12)
      {
        float32x4_t v14 = *(float32x4_t *)(a1 + 128);
        float v16 = *(float *)(a1 + 144);
        float v15 = *(float *)(a1 + 148);
        float v17 = *(float *)(a1 + 152);
        *(float *)v9.i32 = (float)((float)((float)((float)(COERCE_FLOAT(vaddq_f32( v14,  (float32x4_t)vdupq_laneq_s32( *(int32x4_t *)&v14,  3)).i32[2])
                                                         + v16)
                                                 + v15)
                                         + v17)
                                 + COERCE_FLOAT(HIDWORD(*(void *)(a1 + 128))))
                         + v14.f32[0];
        if (*(float *)v9.i32 >= 18.75)
        {
          *(float *)(a1 + 144) = v16 / *(float *)v9.i32;
          *(float *)(a1 + 148) = v15 / *(float *)v9.i32;
          *(float *)(a1 + 152) = v17 / *(float *)v9.i32;
          *(float32x4_t *)(a1 + 128) = vdivq_f32(v14, (float32x4_t)vdupq_lane_s32(v9, 0));
          if ((sub_100D8A92C(*(void *)(a1 + 160) + 72LL) & 1) != 0)
          {
            if (qword_101934800 != -1) {
              dispatch_once(&qword_101934800, &stru_10182B9E8);
            }
            double v20 = (os_log_s *)off_101934808;
            if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
            {
              double v21 = *(double *)(a1 + 120);
              *(_DWORD *)std::string buf = 134349056;
              double v38 = v21;
              _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Persisting result for period ending %{public}f",  buf,  0xCu);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934800 != -1) {
                dispatch_once(&qword_101934800, &stru_10182B9E8);
              }
              double v27 = *(double *)(a1 + 120);
              int v33 = 134349056;
              double v34 = v27;
              double v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "Persisting result for period ending %{public}f",  &v33,  12);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLHealthAssessmentNotifier::resultReady(NSDictionary *, CLHealthAssessment_Types::DataType)",  "%s\n",  v28);
            }

            uint64_t v22 = 0LL;
          }

          else
          {
            if (qword_101934800 != -1) {
              dispatch_once(&qword_101934800, &stru_10182B9E8);
            }
            uint64_t v23 = (os_log_s *)off_101934808;
            if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_ERROR))
            {
              double v24 = *(double *)(a1 + 112);
              uint64_t v25 = *(void *)(a1 + 120);
              *(_DWORD *)std::string buf = 134349312;
              double v38 = v24;
              __int16 v39 = 2050;
              uint64_t v40 = v25;
              _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "WARNING: DB not accessible, results for period from %{public}f to %{public}f may be lost.",  buf,  0x16u);
            }

            if (sub_1002921D0(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934800 != -1) {
                dispatch_once(&qword_101934800, &stru_10182B9E8);
              }
              double v29 = *(double *)(a1 + 112);
              uint64_t v30 = *(void *)(a1 + 120);
              int v33 = 134349312;
              double v34 = v29;
              __int16 v35 = 2050;
              uint64_t v36 = v30;
              __int16 v31 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  16LL,  "WARNING: DB not accessible, results for period from %{public}f to %{public}f may be lost.",  &v33,  22);
              sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLHealthAssessmentNotifier::resultReady(NSDictionary *, CLHealthAssessment_Types::DataType)",  "%s\n",  v31);
            }

            sub_10022C448();
            uint64_t v22 = 5LL;
          }

          sub_10022F134(*(void *)(a1 + 176), (double *)(a1 + 112));
          [*(id *)(a1 + 32) setLastProcessedTime:*(double *)(a1 + 120)];
          sub_10022ECA8(a1, 2LL, v22, 1LL, *(double *)(a1 + 112), *(double *)(a1 + 120));
        }

        else
        {
          float v32 = *(float *)v9.i32;
          if (qword_101934800 != -1) {
            dispatch_once(&qword_101934800, &stru_10182B9E8);
          }
          double v18 = (os_log_s *)off_101934808;
          if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)std::string buf = 134349312;
            double v38 = v32;
            __int16 v39 = 2050;
            uint64_t v40 = 0x4032C00000000000LL;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "Skipping partially empty period, saw %{public}.1f of %{public}.1f epochs in period",  buf,  0x16u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934800 != -1) {
              dispatch_once(&qword_101934800, &stru_10182B9E8);
            }
            int v33 = 134349312;
            double v34 = v32;
            __int16 v35 = 2050;
            uint64_t v36 = 0x4032C00000000000LL;
            __n128 v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "Skipping partially empty period, saw %{public}.1f of %{public}.1f epochs in period",  &v33,  22);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLHealthAssessmentNotifier::resultReady(NSDictionary *, CLHealthAssessment_Types::DataType)",  "%s\n",  v19);
          }
        }

        double v26 = (double)(uint64_t)(v6 / 60.0) * 60.0;
        *(_OWORD *)(a1 + 128) = 0u;
        *(_OWORD *)(a1 + 144) = 0u;
        *(double *)(a1 + 112) = v26;
        *(double *)(a1 + 12sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = v26 + 60.0;
      }

      switch(v8)
      {
        case 1u:
          *(float *)(a1 + 14sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = *(float *)(a1 + 140) + 1.0;
          break;
        case 2u:
          *(float *)(a1 + 144) = *(float *)(a1 + 144) + 1.0;
          break;
        case 3u:
          *(float *)(a1 + 148) = *(float *)(a1 + 148) + 1.0;
          break;
        case 4u:
          *(float *)(a1 + 152) = *(float *)(a1 + 152) + 1.0;
          break;
        default:
          if (v7 == 1)
          {
            *(float *)(a1 + 132) = *(float *)(a1 + 132) + 1.0;
          }

          else if (v8)
          {
            *(float *)(a1 + 128) = *(float *)(a1 + 128) + 1.0;
          }

          else
          {
            *(float *)(a1 + 136) = *(float *)(a1 + 136) + 1.0;
          }

          break;
      }
    }
  }

  else
  {
    uint64_t v13 = +[NSNotificationCenter defaultCenter](&OBJC_CLASS___NSNotificationCenter, "defaultCenter");
    -[NSNotificationCenter postNotificationName:object:userInfo:]( v13,  "postNotificationName:object:userInfo:",  off_1019901F0,  *(void *)(a1 + 32),  a2);
  }

BOOL sub_10022E0FC(uint64_t a1)
{
  if (qword_101934800 != -1) {
    dispatch_once(&qword_101934800, &stru_10182B9E8);
  }
  uint64_t v2 = (os_log_s *)off_101934808;
  if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Aggregating records for fParkinsonsResultPersistence",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    v7[0] = 0;
    double v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "Aggregating records for fParkinsonsResultPersistence",  v7,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLHealthAssessmentNotifier::aggregateRecords()", "%s\n", v6);
  }

  sub_10022F658(*(void *)(a1 + 176));
  double Current = CFAbsoluteTimeGetCurrent();
  [*(id *)(a1 + 32) monitorKinesiasExpiration];
  return Current < v4 + 604800.0;
}

void sub_10022E494(id a1)
{
  if (sub_1001B9A1C())
  {
    if ((sub_1004F97F4() & 0x200000000000LL) != 0) {
      byte_101993CB0 = 1;
    }
  }

double sub_10022E4C4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x120uLL);
  sub_10022E5FC((uint64_t)v2, "CLHealthAssessmentNotifier", *(void **)(a1 + 32));
  *(void *)uint64_t v2 = off_10182B8D8;
  v2[109] = 0;
  double result = 0.0;
  *((_OWORD *)v2 + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *(_OWORD *)(v2 + 14sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0u;
  *((_OWORD *)v2 + 1sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0u;
  *((_OWORD *)v2 + 11) = 0u;
  *((_OWORD *)v2 + 12) = 0u;
  *((_OWORD *)v2 + 13) = 0u;
  *((_OWORD *)v2 + 14) = 0u;
  *((_OWORD *)v2 + 15) = 0u;
  *((_OWORD *)v2 + 16) = 0u;
  *((_OWORD *)v2 + 17) = 0u;
  qword_1019A0E00 = (uint64_t)v2;
  return result;
}

void sub_10022E530(_Unwind_Exception *a1)
{
}

uint64_t sub_10022E544(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10022E5B8;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_101993CD0 != -1) {
    dispatch_once(&qword_101993CD0, block);
  }
  return byte_101993CC8;
}

id sub_10022E5B8(uint64_t a1)
{
  id result = objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "isServiceEnabled:",  @"CLHealthAssessmentNotifier");
  byte_101993CC8 = (char)result;
  return result;
}

uint64_t sub_10022E5E4(uint64_t result)
{
  *(_BYTE *)(result + 108) = 1;
  return result;
}

uint64_t sub_10022E5F0(uint64_t result)
{
  *(_BYTE *)(result + 108) = 1;
  return result;
}

uint64_t sub_10022E5FC(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_10182BA38;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = [a3 silo];
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 108) = 0;
  return a1;
}

void sub_10022E67C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10022E698(uint64_t a1)
{
  *(void *)a1 = off_10182B8D8;
  *(_BYTE *)(a1 + 108) = 1;
  uint64_t v2 = *(void *)(a1 + 280);
  *(void *)(a1 + 28sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  sub_100231C10((void *)(a1 + 232));
  sub_100231C10((void *)(a1 + 184));
  sub_1001B4F90((uint64_t *)(a1 + 176), 0LL);
  sub_10000AE14(a1 + 160);
  return sub_10022E708(a1);
}

uint64_t sub_10022E708(uint64_t a1)
{
  *(void *)a1 = off_10182BA38;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

void sub_10022E780(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10022E698(a1);
  operator delete(v1);
}

void sub_10022E794(void **a1, double a2)
{
  if (a2 >= 0.0)
  {
    unsigned int v8 = a1[2];
    uint64_t v6 = (uint64_t)(a1 + 2);
    unsigned int v7 = v8;
    unint64_t v9 = *(void *)(v6 - 8);
    if (v9 >= (unint64_t)v8)
    {
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (void)*a1) >> 3);
      unint64_t v12 = v11 + 1;
      if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100007008();
      }
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (_BYTE *)*a1) >> 3);
      if (2 * v13 > v12) {
        unint64_t v12 = 2 * v13;
      }
      if (v13 >= 0x555555555555555LL) {
        unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14) {
        float v15 = (char *)sub_10000701C(v6, v14);
      }
      else {
        float v15 = 0LL;
      }
      float v16 = &v15[24 * v11];
      float v17 = &v15[24 * v14];
      *(double *)float v16 = a2;
      *((void *)v16 + 1) = 0x7FEFFFFFFFFFFFFFLL;
      v16[16] = 0;
      double v10 = v16 + 24;
      __n128 v19 = (char *)*a1;
      double v18 = (char *)a1[1];
      if (v18 != *a1)
      {
        do
        {
          __int128 v20 = *(_OWORD *)(v18 - 24);
          *(v16 - 8) = *(v18 - 8);
          *(_OWORD *)(v16 - 24) = v20;
          v16 -= 24;
          v18 -= 24;
        }

        while (v18 != v19);
        double v18 = (char *)*a1;
      }

      *a1 = v16;
      a1[1] = v10;
      a1[2] = v17;
      if (v18) {
        operator delete(v18);
      }
    }

    else
    {
      *(double *)unint64_t v9 = a2;
      *(void *)(v9 + 8) = 0x7FEFFFFFFFFFFFFFLL;
      *(_BYTE *)(v9 + 16) = 0;
      double v10 = (char *)(v9 + 24);
    }

    a1[1] = v10;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182BB58);
    }
    uint64_t v3 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134349056;
      double v24 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Programmer error, this expiration rule with time %{public}fis not valid.",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182BB58);
      }
      int v21 = 134349056;
      double v22 = a2;
      double v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Programmer error, this expiration rule with time %{public}fis not valid.",  &v21,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLActivityAggregator<ParkinsonsResult, CLActivityDB::ClassBDataProtectionPolicy>::setExpirationRule(CFTimeI nterval) [T = ParkinsonsResult, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v4);
    }
  }

void sub_10022EA48(uint64_t a1, _DWORD *a2, unsigned __int32 *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182BA08);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    unsigned int v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLHealthAssessmentNotifier::onWatchOrientationSettingsNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182BA08);
    }
    unint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      float v15 = "";
      __int16 v16 = 2082;
      float v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLHealthAssessmentNotifier::onWatchOrientationSettingsNotification, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10022FBCC((void *)a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10022EC00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_10022EC20(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100231E98(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  __n128 result = *a2;
  *(__n128 *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v7) = *a2;
  ++a1[5];
  return result;
}

void sub_10022ECA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5, double a6)
{
  if (objc_opt_class(&OBJC_CLASS___MCProfileConnection)
    && (objc_msgSend( +[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"),  "isHealthDataSubmissionAllowed") & 1) != 0)
  {
    unint64_t v12 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", a2),  @"dataBaseAccessType");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", a3),  @"errorType");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", a4),  @"recordsCount");
    double Current = CFAbsoluteTimeGetCurrent();
    [*(id *)(a1 + 32) lastProcessedTime];
    uint64_t v15 = (int)fmax(Current - v14, 0.0);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (int)fmax(Current - a5, 0.0)),  @"relativeQueryStartTime");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", (int)fmax(Current - a6, 0.0)),  @"relativeQueryEndTime");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v15),  @"timeSinceLastProcessed");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 160) + 132LL)),  @"databaseSize");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v12,  "setObject:forKeyedSubscript:",  -[NSUUID UUIDString](+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"), "UUIDString"),  @"uuid");
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    __int16 v16 = (os_log_s *)off_101934808;
    if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138543362;
      uint64_t v23 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Sending metrics to CoreAnalytics:%{public}@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934800 != -1) {
        dispatch_once(&qword_101934800, &stru_10182B9E8);
      }
      int v20 = 138543362;
      int v21 = v12;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  0LL,  "Sending metrics to CoreAnalytics:%{public}@",  &v20,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLHealthAssessmentNotifier::logDBAccessAnalytics(DataBaseAccessType, ErrorType, int, CFAbsoluteTime, CFAbsoluteTime) const",  "%s\n",  v19);
    }

    AnalyticsSendEvent(@"com.apple.CoreLocation.CLParkinsonsDBUsage", v12);
  }

  else
  {
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    float v17 = (os_log_s *)off_101934808;
    if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "Not sending analytics, no IHA permission",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934800 != -1) {
        dispatch_once(&qword_101934800, &stru_10182B9E8);
      }
      LOWORD(v2sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0;
      __int16 v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  2LL,  "Not sending analytics, no IHA permission",  &v20,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLHealthAssessmentNotifier::logDBAccessAnalytics(DataBaseAccessType, ErrorType, int, CFAbsoluteTime, CFAbsoluteTime) const",  "%s\n",  v18);
    }
  }

uint64_t sub_10022F134(uint64_t a1, double *a2)
{
  uint64_t result = sub_1002321AC(*(void *)(a1 + 24), a2);
  if (!*(_BYTE *)(a1 + 41))
  {
    uint64_t result = sub_100D8A92C(*(void *)(a1 + 24) + 72LL);
    if ((_DWORD)result)
    {
      *(_BYTE *)(a1 + 41) = 1;
      return sub_10022F658(a1);
    }
  }

  return result;
}

void *sub_10022F188@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

uint64_t sub_10022F200(uint64_t a1, int a2, double a3)
{
  unint64_t v6 = sub_1004F97F4();
  if ((v6 & 0x10000000) == 0) {
    return (v6 >> 28) & 1;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  double v8 = Current;
  if (a3 <= 0.0)
  {
    uint64_t v24 = *(void *)(a1 + 224);
    if (v24)
    {
      uint64_t v25 = *(void *)(*(void *)(a1 + 192)
      double v27 = *(double *)(v25 + 8);
      double v26 = (double *)(v25 + 8);
      if (v27 > Current) {
        *double v26 = Current;
      }
    }

    [*(id *)(a1 + 32) stopMonitoring];
    return (v6 >> 28) & 1;
  }

  double v9 = Current + a3;
  [*(id *)(a1 + 32) addMonitoringPeriodFrom:Current until:v9];
  uint64_t v10 = *(void *)(a1 + 224);
  if (v10
    && (uint64_t v11 = *(void *)(*(void *)(a1 + 192)
                        + (((unint64_t)(v10 + *(void *)(a1 + 216) - 1) >> 5) & 0x7FFFFFFFFFFFFF8LL))
            + 16LL * (v10 + *(_BYTE *)(a1 + 216) - 1),
        double v13 = *(double *)(v11 + 8),
        unint64_t v12 = (double *)(v11 + 8),
        v13 >= v8))
  {
    *unint64_t v12 = v9;
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    double v28 = (os_log_s *)off_101934808;
    if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
    {
      unint64_t v29 = *(void *)(a1 + 224) + *(void *)(a1 + 216) - 1LL;
      uint64_t v32 = *v30;
      uint64_t v31 = v30[1];
      *(_DWORD *)std::string buf = 134349312;
      *(void *)&uint8_t buf[4] = v32;
      *(_WORD *)&buf[12] = 2050;
      *(void *)&buf[14] = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_INFO,  "Extend existing monitoring period %{public}f - %{public}f",  buf,  0x16u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_22;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    unint64_t v34 = *(void *)(a1 + 224) + *(void *)(a1 + 216) - 1LL;
    uint64_t v37 = *v35;
    uint64_t v36 = v35[1];
    *(_DWORD *)__int16 v39 = 134349312;
    *(void *)&v39[4] = v37;
    *(_WORD *)&v39[12] = 2050;
    *(void *)&v39[14] = v36;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "Extend existing monitoring period %{public}f - %{public}f",  v39,  22,  *(_OWORD *)v39,  *(void *)&v39[16]);
  }

  else
  {
    *(double *)std::string buf = v8;
    *(double *)&uint8_t buf[8] = v9;
    sub_10022EC20((void *)(a1 + 184), (__n128 *)buf);
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    double v14 = (os_log_s *)off_101934808;
    if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
    {
      unint64_t v15 = *(void *)(a1 + 224) + *(void *)(a1 + 216) - 1LL;
      uint64_t v18 = *v16;
      uint64_t v17 = v16[1];
      *(_DWORD *)std::string buf = 134349312;
      *(void *)&uint8_t buf[4] = v18;
      *(_WORD *)&buf[12] = 2050;
      *(void *)&buf[14] = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "Add new monitoring period %{public}f - %{public}f",  buf,  0x16u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_22;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    unint64_t v19 = *(void *)(a1 + 224) + *(void *)(a1 + 216) - 1LL;
    uint64_t v22 = *v20;
    uint64_t v21 = v20[1];
    *(_DWORD *)__int16 v39 = 134349312;
    *(void *)&v39[4] = v22;
    *(_WORD *)&v39[12] = 2050;
    *(void *)&v39[14] = v21;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "Add new monitoring period %{public}f - %{public}f",  v39,  22,  *(_OWORD *)v39,  *(void *)&v39[16]);
  }

  double v38 = (char *)v23;
  sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHealthAssessmentNotifier::recordHealthAssessmentData(CLHealthAssessment_Types::DataType, CFTimeInterval)",  "%s\n",  v23);
  if (v38 != buf) {
    free(v38);
  }
LABEL_22:
  [*(id *)(a1 + 32) setupService];
  if (!a2)
  {
LABEL_25:
    [*(id *)(a1 + 32) startUpdatesforAnalyzer:0];
    return (v6 >> 28) & 1;
  }

  if (a2 == 1)
  {
    [*(id *)(a1 + 32) startUpdatesforAnalyzer:1];
    goto LABEL_25;
  }

  return (v6 >> 28) & 1;
}

uint64_t sub_10022F658(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 40)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182BB58);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v3 = sub_101171D38();
    int v4 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::string buf = 134218240;
    *(double *)int v33 = v3;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Aggregating records start %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182BB58);
    }
    uint64_t v16 = qword_101934A78;
    double v17 = sub_101171D38();
    int v18 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)uint64_t v30 = v17;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v18;
    unint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  2LL,  "Aggregating records start %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<ParkinsonsResult, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = Par kinsonsResult, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v19);
  }

  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182BB58);
  }
  unint64_t v6 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v7 = sub_101171D38();
    int v8 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::string buf = 134218240;
    *(double *)int v33 = v7;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Aggregating records stop %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182BB58);
    }
    uint64_t v20 = qword_101934A78;
    double v21 = sub_101171D38();
    int v22 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)uint64_t v30 = v21;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v22;
    uint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  2LL,  "Aggregating records stop %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<ParkinsonsResult, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = Par kinsonsResult, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v23);
  }

  uint64_t v9 = *(void *)(a1 + 24);
  double v10 = (double)*(int *)(v9 + 132);
  if ((double)(int)sub_100232B44(v9, (double **)a1) * 1.2 < v10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182BB58);
    }
    uint64_t v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 24);
      int v13 = *(_DWORD *)(v12 + 132);
      int v14 = sub_100232B44(v12, (double **)a1);
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)int v33 = v13;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182BB58);
      }
      uint64_t v24 = qword_101934A78;
      uint64_t v25 = *(void *)(a1 + 24);
      int v26 = *(_DWORD *)(v25 + 132);
      int v27 = sub_100232B44(v25, (double **)a1);
      int v29 = 67109376;
      *(_DWORD *)uint64_t v30 = v26;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = v27;
      double v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v24,  0LL,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records es timated to be needed %d",  &v29,  14);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<ParkinsonsResult, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = P arkinsonsResult, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v28);
    }
  }

  return v5;
}

void sub_10022FBCC(void *a1, uint64_t a2, _DWORD *a3, unsigned __int32 *a4)
{
  if (*a3 == 1)
  {
    if (qword_101934800 != -1) {
      dispatch_once(&qword_101934800, &stru_10182B9E8);
    }
    unint64_t v6 = (os_log_s *)off_101934808;
    if (os_log_type_enabled((os_log_t)off_101934808, OS_LOG_TYPE_INFO))
    {
      unsigned __int32 v7 = *a4;
      buf[0].n128_u32[0] = 67240192;
      buf[0].n128_u32[1] = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "Watch wrist state updated,onwrist,%{public}d",  (uint8_t *)buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934800 != -1) {
        dispatch_once(&qword_101934800, &stru_10182B9E8);
      }
      unsigned __int32 v14 = *a4;
      v16[0] = 67240192;
      v16[1] = v14;
      unint64_t v15 = (__n128 *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934808,  1LL,  "Watch wrist state updated,onwrist,%{public}d",  v16,  8);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLHealthAssessmentNotifier::onWatchOrientationSettingsNotification(int, const CLWatchOrientationSettingsNot ifier_Type::Notification &, const CLWatchOrientationSettingsNotifier_Type::NotificationData &)",  "%s\n",  (const char *)v15);
      if (v15 != buf) {
        free(v15);
      }
    }

    double Current = CFAbsoluteTimeGetCurrent();
    int v9 = *a4 == 1;
    uint64_t v10 = a1[34];
    if (!v10
      || (uint64_t v11 = v10 - 1,
          unint64_t v12 = v11 + a1[33],
          uint64_t v13 = *(void *)(a1[30] + ((v12 >> 5) & 0x7FFFFFFFFFFFFF8LL)),
          *(unsigned __int8 *)(v13 + 16LL * v12 + 8) != v9)
      && (*(double *)(v13 + 16LL * (v11 + *((_BYTE *)a1 + 264))) + 60.0 <= Current
       || (a1[34] = v11, sub_100232D9C(a1 + 29, 1), !a1[34])))
    {
      buf[0].n128_f64[0] = Current;
      buf[0].n128_u8[8] = v9;
      sub_10022FE2C(a1 + 29, buf);
    }
  }

__n128 sub_10022FE2C(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100232E08(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  __n128 result = *a2;
  *(__n128 *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v7) = *a2;
  ++a1[5];
  return result;
}

uint64_t sub_10022FEB4(uint64_t a1, uint64_t *a2)
{
  if (*(_BYTE *)(a1 + 108)) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v7 = (int *)v8;
  v8[0] = 0LL;
  v8[1] = 0LL;
  int v9 = a2;
  double v3 = (unsigned int *)(a1 + 104);
  ++*(_DWORD *)(a1 + 104);
  uint64_t v10 = (_DWORD *)(a1 + 104);
  uint64_t v4 = sub_10023311C((uint64_t **)(a1 + 80), (int *)(a1 + 104), (uint64_t)&unk_1012CF090, &v10);
  uint64_t v5 = (void *)v8[0];
  _WORD v4[8] = v9;
  uint64_t v2 = *v3;
  sub_100008390((uint64_t)&v7, v5);
  return v2;
}

void sub_10022FF64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_10022FF7C(uint64_t a1, uint64_t a2)
{
  HIDWORD(v14) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        int v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)std::string buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v14 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182BA08);
      }
      uint64_t v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v11 = (void *)(a1 + 8);
        *(_DWORD *)std::string buf = 136446466;
        uint64_t v20 = v11;
        __int16 v21 = 1026;
        int v22 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_10182BA08);
        }
        unint64_t v12 = (void *)(a1 + 8);
        int v15 = 136446466;
        uint64_t v16 = v12;
        __int16 v17 = 1026;
        int v18 = a2;
        LODWORD(v14) = 18;
        uint64_t v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                        &v15,
                        v14);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::Notifi cationData, char, char>::removeClient(int) [Notification_T = CLHealthAssessmentNotifier_Type::Notification, No tificationData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
      }
    }
  }

uint64_t sub_1002301F0(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  id v7 = sub_1011D622C(a4);
  if (v7)
  {
    int v10 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *, id))(*(void *)a1 + 96LL))(a1, a2, &v10, v7);
  }

  else
  {
    int v9 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 88LL))(a1, a2, &v9);
  }

uint64_t sub_100230270(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 104LL))(a1, a2, &v4);
}

uint64_t sub_10023029C(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 112LL))(a1, a2, &v4);
}

uint64_t sub_1002302C8(uint64_t a1, int a2)
{
  int v3 = a2;
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 120LL))(a1, &v3);
}

uint64_t sub_1002302F4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 48);
  if (!result)
  {
    int v3 = objc_alloc_init(&OBJC_CLASS___CLNotifierServiceAdapter);
    *(void *)(a1 + 48) = v3;
    -[CLNotifierServiceAdapter setValid:](v3, "setValid:", 1LL);
    [*(id *)(a1 + 48) setAdaptedNotifier:a1];
    return *(void *)(a1 + 48);
  }

  return result;
}

uint64_t sub_100230340(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_101936680);
}

uint64_t sub_100230354(uint64_t a1, int a2, int *a3, char *a4)
{
  int v41 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        uint64_t v13 = (uint64_t *)v7;
      }
      else {
        uint64_t v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)CFAbsoluteTime v42 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          uint64_t v24 = (uint64_t *)v18;
        }
        else {
          uint64_t v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }

      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          int v29 = (uint64_t *)v25;
        }
        else {
          int v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }

      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v40 = v26;
        uint64_t v34 = *(void *)(v26 + 56);
        char v35 = *a4;
        *(void *)std::string buf = &v41;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v26 + 40), &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v35;
        *(void *)std::string buf = 0LL;
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, _BYTE *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          uint64_t v36 = sub_100233320(buf);
          sub_1002333A0((_BYTE *)a1, (uint64_t)v42, (uint64_t)&v40, v36);
        }

        if (v34) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        uint64_t v40 = a1 + 64;
        char v30 = byte_101936681;
        HIDWORD(v39) = v17;
        *(void *)std::string buf = (char *)&v39 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 8sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = v30;
        HIDWORD(v39) = *a3;
        *(void *)std::string buf = (char *)&v39 + 4;
        int v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v31 + 8);
        char v32 = *a4;
        HIDWORD(v39) = *a3;
        *(void *)std::string buf = (char *)&v39 + 4;
        int v33 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)std::string buf = &v41;
        *((_BYTE *)sub_1004EF3D4(v33 + 5, &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v32;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v21 == v19)
      {
        *(_DWORD *)std::string buf = *a3;
        sub_10004A8FC((uint64_t **)(*(void *)v42 + 40LL), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182BA08);
  }
  uint64_t v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    int v15 = (void *)(a1 + 8);
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    __int16 v46 = 1026;
    int v47 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL v16 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182BA08);
    }
    uint64_t v37 = (void *)(a1 + 8);
    *(_DWORD *)CFAbsoluteTime v42 = 136446466;
    *(void *)&v42[4] = v37;
    __int16 v43 = 1026;
    int v44 = a2;
    LODWORD(v39) = 18;
    double v38 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                    v42,
                    v39);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::Notificati onData, char, char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notificatio n_T = CLHealthAssessmentNotifier_Type::Notification, NotificationData_T = CLHealthAssessmentNotifier_Type::Notific ationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v38);
    if (v38 != buf) {
      free(v38);
    }
    return 0LL;
  }

  return result;
}

BOOL sub_1002307B0(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v5;
    }
    else {
      int v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        uint64_t v21 = (uint64_t *)v15;
      }
      else {
        uint64_t v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182BA08);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)std::string buf = 136446466;
      int v29 = v11;
      __int16 v30 = 1026;
      int v31 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182BA08);
      }
      int v22 = (void *)(a1 + 8);
      int v24 = 136446466;
      uint64_t v25 = v22;
      __int16 v26 = 1026;
      int v27 = a2;
      BOOL v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                      &v24,
                      18);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::Notifica tionData, char, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLHealthAssessmentNotifie r_Type::Notification, NotificationData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100230A30(char *a1, int a2, int *a3)
{
  HIDWORD(v33) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        uint64_t v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            uint64_t v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            int v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                uint64_t v25 = (uint64_t *)v20;
              }
              else {
                uint64_t v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                int v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v33 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10182BA08);
              }
              __int16 v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v27 = a1 + 8;
                if (a1[31] < 0) {
                  int v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v43 >= 0) {
                  BOOL v28 = __p;
                }
                else {
                  BOOL v28 = (void **)__p[0];
                }
                *(_DWORD *)std::string buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v35 = 2082;
                uint64_t v36 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v43 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_10182BA08);
                }
                int v29 = a1 + 8;
                if (a1[31] < 0) {
                  int v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v37 >= 0) {
                  int v31 = buf;
                }
                else {
                  int v31 = *(_BYTE **)buf;
                }
                int v38 = 136446466;
                uint64_t v39 = v29;
                __int16 v40 = 2082;
                int v41 = v31;
                LODWORD(v33) = 22;
                char v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                                &v38,
                                v33);
                if (v37 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type ::NotificationData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_ T = CLHealthAssessmentNotifier_Type::Notification, NotificationData_T = CLHealthAssessmentNotifier_Typ e::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v32);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

void sub_100230DB8(uint64_t a1, int *a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v2 = a1 + 64;
  uint64_t v3 = v4;
  if (v4)
  {
    int v5 = *a2;
    uint64_t v6 = v2;
    do
    {
      int v7 = *(_DWORD *)(v3 + 32);
      BOOL v8 = v7 < v5;
      if (v7 >= v5) {
        int v9 = (uint64_t *)v3;
      }
      else {
        int v9 = (uint64_t *)(v3 + 8);
      }
      if (!v8) {
        uint64_t v6 = v3;
      }
      uint64_t v3 = *v9;
    }

    while (*v9);
    if (v6 != v2 && v5 >= *(_DWORD *)(v6 + 32)) {
      sub_1000F0D38((void *)(v6 + 64));
    }
  }

uint64_t sub_100230E04(uint64_t a1, int *a2, void *a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }

  while (*v10);
  if (v7 == v3) {
    return 0LL;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0LL;
  }
  int v11 = *(void **)(v7 + 64);
  if (!v11) {
    return 0LL;
  }
  *a3 = *v11;
  return 1LL;
}

uint64_t sub_100230E64(uint64_t a1, int *a2, uint64_t *a3)
{
  int v6 = operator new(0x20uLL);
  _DWORD v6[2] = 0LL;
  *int v6 = off_10182BBE8;
  v6[1] = 0LL;
  uint64_t v7 = *a3;
  *((void *)&v14 + 1) = v6;
  v6[3] = v7;
  *(void *)&__int128 v14 = v6 + 3;
  int v13 = *a2;
  int v15 = &v13;
  int v8 = sub_10023347C((uint64_t **)(a1 + 56), &v13, (uint64_t)&unk_1012CF090, &v15);
  sub_10005F550((uint64_t)(v8 + 8), &v14);
  BOOL v9 = (std::__shared_weak_count *)*((void *)&v14 + 1);
  if (*((void *)&v14 + 1))
  {
    BOOL v10 = (unint64_t *)(*((void *)&v14 + 1) + 8LL);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return 1LL;
}

void sub_100230F38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100230F4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = 0LL;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  &v5,  a3,  a4,  0LL);
}

void sub_100230F84(uint64_t a1, unsigned int *a2, void *a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    BOOL v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182BA08);
    }
    unint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      BOOL v12 = (void *)(a1 + 8);
      int v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)std::string buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = "activity";
      __int16 v66 = 2082;
      double v67 = v12;
      __int16 v68 = 2050;
      CFAbsoluteTime v69 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    __int128 v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      __int128 v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)unint64_t v70 = &v70[8];
      memset(&v70[8], 0, 24);
      double v71 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v70);
      int v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v69;
      if (v69)
      {
        p_shared_owners = (unint64_t *)&v69->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&buf[8], *(void **)&buf[16]);
      BOOL v24 = v71;
      if (v71)
      {
        uint64_t v25 = (unint64_t *)&v71->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v70, *(void **)&v70[8]);
    }

    if (a4)
    {
      int v27 = operator new(0x20uLL);
      v27[2] = 0LL;
      *int v27 = off_10182BBE8;
      v27[1] = 0LL;
      v27[3] = *a3;
      *(void *)std::string buf = v27 + 3;
      *(void *)&uint8_t buf[8] = v27;
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      BOOL v28 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        int v29 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    int v31 = sub_100233E50(a3);
    if (a5 == -1)
    {
      sub_100233ED0((void *)a1, (int *)a2, v31);
    }

    else
    {
      uint64_t v32 = a1 + 88;
      uint64_t v33 = *(void *)(a1 + 88);
      if (!v33) {
        goto LABEL_48;
      }
      uint64_t v34 = a1 + 88;
      do
      {
        int v35 = *(_DWORD *)(v33 + 32);
        BOOL v36 = v35 < a5;
        if (v35 >= a5) {
          char v37 = (uint64_t *)v33;
        }
        else {
          char v37 = (uint64_t *)(v33 + 8);
        }
        if (!v36) {
          uint64_t v34 = v33;
        }
        uint64_t v33 = *v37;
      }

      while (*v37);
      if (v34 == v32 || *(_DWORD *)(v34 + 32) > a5) {
LABEL_48:
      }
        uint64_t v34 = a1 + 88;
      uint64_t v63 = v34;
      unint64_t v38 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v39 = *a2;
      __int16 v40 = (__n128 *)(a1 + 64);
      do
      {
        int v41 = *(_DWORD *)(v38 + 32);
        BOOL v42 = v41 < v39;
        if (v41 >= v39) {
          char v43 = (unint64_t *)v38;
        }
        else {
          char v43 = (unint64_t *)(v38 + 8);
        }
        if (!v42) {
          __int16 v40 = (__n128 *)v38;
        }
        unint64_t v38 = *v43;
      }

      while (*v43);
      if (v40 == v15 || v39 < (signed __int32)v40[2].n128_u32[0])
      {
LABEL_59:
        CFAbsoluteTime v62 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_10182BA08);
        }
        int v44 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          double v45 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v70, a1, a2);
          if (v70[23] >= 0) {
            __int16 v46 = v70;
          }
          else {
            __int16 v46 = *(_BYTE **)v70;
          }
          *(_DWORD *)std::string buf = 136315650;
          *(void *)&uint8_t buf[4] = v45;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a5;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = v46;
          _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v70[23] & 0x80000000) != 0) {
            operator delete(*(void **)v70);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_10182BA08);
          }
          int v47 = (void *)(a1 + 8);
          uint64_t v48 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v61 >= 0) {
            uint64_t v49 = __p;
          }
          else {
            uint64_t v49 = (void **)__p[0];
          }
          *(_DWORD *)unint64_t v70 = 136315650;
          *(void *)&v70[4] = v47;
          *(_WORD *)&v70[12] = 1024;
          *(_DWORD *)&v70[14] = a5;
          *(_WORD *)&v70[18] = 2080;
          *(void *)&v70[20] = v49;
          double v50 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v48,  2LL,  "%s; client %d has deregistered, not notifying %s",
                          v70,
                          28,
                          v59);
          if (v61 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::Noti ficationData, char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, i nt, BOOL) [Notification_T = CLHealthAssessmentNotifier_Type::Notification, NotificationData_T = CLHealthAsse ssmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v50);
          if (v50 != buf) {
            free(v50);
          }
        }

        goto LABEL_83;
      }

      CFAbsoluteTime v62 = v40;
      if (v34 == v32) {
        goto LABEL_60;
      }
      uint64_t v53 = v40[3].n128_i64[0];
      char v51 = v40 + 3;
      unsigned int v52 = (__n128 *)v53;
      if (!v53) {
        goto LABEL_60;
      }
      int v54 = *(_DWORD *)(v34 + 32);
      unint64_t v55 = v51;
      do
      {
        int v56 = v52[1].n128_i32[3];
        BOOL v57 = v56 < v54;
        if (v56 >= v54) {
          CFAbsoluteTime v58 = v52;
        }
        else {
          CFAbsoluteTime v58 = (__n128 *)&v52->n128_i8[8];
        }
        if (!v57) {
          unint64_t v55 = v52;
        }
        unsigned int v52 = (__n128 *)v58->n128_u64[0];
      }

      while (v58->n128_u64[0]);
      sub_1002333A0((_BYTE *)a1, (uint64_t)&v63, (uint64_t)&v62, v31);
    }

void sub_1002315BC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

uint64_t sub_100231608()
{
  return 1LL;
}

void sub_100231610(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182BA08);
    }
    uint64_t v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)std::string buf = 136315138;
      uint64_t v34 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182BA08);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v29 = 136315138;
      unint64_t v30 = v4;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
                     (const char *)&v29);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::Notifica tionData, char, char>::listClients() [Notification_T = CLHealthAssessmentNotifier_Type::Notification, Notificati onData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182BA08);
    }
    int v6 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = (void *)(a1 + 8);
      uint64_t v8 = *(void *)(a1 + 96);
      *(_DWORD *)std::string buf = 136315394;
      uint64_t v34 = v7;
      __int16 v35 = 2048;
      v36[0] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182BA08);
      }
      uint64_t v25 = (void *)(a1 + 8);
      uint64_t v26 = *(void *)(a1 + 96);
      int v29 = 136315394;
      unint64_t v30 = v25;
      __int16 v31 = 2048;
      v32[0] = v26;
      int v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
                      (const char *)&v29,
                      22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::Notifica tionData, char, char>::listClients() [Notification_T = CLHealthAssessmentNotifier_Type::Notification, Notificati onData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v27);
    }

    BOOL v9 = *(void **)(a1 + 80);
    if (v9 != (void *)(a1 + 88))
    {
      BOOL v10 = (void *)(a1 + 8);
      do
      {
        unint64_t v11 = (void *)v9[5];
        if (v11 != v9 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_10182BA08);
            }
            BOOL v12 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              int v13 = (void *)(a1 + 8);
              int v14 = *((_DWORD *)v9 + 8);
              int v15 = *((_DWORD *)v11 + 7);
              *(_DWORD *)std::string buf = 136315650;
              uint64_t v34 = v13;
              __int16 v35 = 1024;
              LODWORD(v36[0]) = v14;
              WORD2(v36[0]) = 1024;
              *(_DWORD *)((char *)v36 + 6) = v15;
              _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10182BA08);
              }
              BOOL v19 = (void *)(a1 + 8);
              int v20 = *((_DWORD *)v9 + 8);
              int v21 = *((_DWORD *)v11 + 7);
              int v29 = 136315650;
              unint64_t v30 = v19;
              __int16 v31 = 1024;
              LODWORD(v32[0]) = v20;
              WORD2(v32[0]) = 1024;
              *(_DWORD *)((char *)v32 + 6) = v21;
              int v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                              (const char *)&v29,
                              24,
                              v28);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type:: NotificationData, char, char>::listClients() [Notification_T = CLHealthAssessmentNotifier_Type::Notifica tion, NotificationData_T = CLHealthAssessmentNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v22);
            }

            signed __int32 v16 = (void *)v11[1];
            if (v16)
            {
              do
              {
                int v17 = v16;
                signed __int32 v16 = (void *)*v16;
              }

              while (v16);
            }

            else
            {
              do
              {
                int v17 = (void *)v11[2];
                BOOL v18 = *v17 == (void)v11;
                unint64_t v11 = v17;
              }

              while (!v18);
            }

            unint64_t v11 = v17;
          }

          while (v17 != v9 + 6);
        }

        unint64_t v23 = (void *)v9[1];
        if (v23)
        {
          do
          {
            BOOL v24 = v23;
            unint64_t v23 = (void *)*v23;
          }

          while (v23);
        }

        else
        {
          do
          {
            BOOL v24 = (void *)v9[2];
            BOOL v18 = *v24 == (void)v9;
            BOOL v9 = v24;
          }

          while (!v18);
        }

        BOOL v9 = v24;
      }

      while (v24 != (void *)(a1 + 88));
    }
  }

void sub_100231BB8(id a1)
{
  off_101934808 = os_log_create("com.apple.locationd.Motion", "MovementDisorder");
}

void sub_100231BE4(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_100231C10(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 128LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 256LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void sub_100231CA4(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100231CA4(a1, *a2);
    sub_100231CA4(a1, a2[1]);
    sub_100008390((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }

void sub_100231CF0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100231CF0(a1, *a2);
    sub_100231CF0(a1, a2[1]);
    sub_10000AE14((uint64_t)(a2 + 8));
    sub_100008390((uint64_t)(a2 + 5), (void *)a2[6]);
    operator delete(a2);
  }

uint64_t sub_100231D48(uint64_t a1)
{
  return a1;
}

void *sub_100231D7C@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x178uLL);
  BOOL result = sub_100231DD4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100231DC0(_Unwind_Exception *a1)
{
}

void *sub_100231DD4(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10182BB18;
  sub_100EDB8BC(a1 + 3, *a2);
  return a1;
}

void sub_100231E10(_Unwind_Exception *a1)
{
}

void sub_100231E24(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182BB18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100231E38(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182BB18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100231E5C(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void sub_100231E6C(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_100231E98(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    BOOL v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      char v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100232160( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002321AC(uint64_t a1, double *a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  *(void *)&v21[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v22 = 256;
  v21[0] = *a2;
  if (sub_100D8AB44(v6, v21))
  {
    if (sub_100D8A92C(v6))
    {
      (*(void (**)(uint64_t, double *, void))(*(void *)a1 + 80LL))(a1, a2, 0LL);
    }

    else if (!*(_BYTE *)(a1 + 128))
    {
      uint64_t v12 = (void *)(a1 + 176);
      unint64_t v13 = *(void *)(a1 + 216);
      if (v13 > *(int *)(a1 + 272))
      {
        ++*(void *)(a1 + 208);
        *(void *)(a1 + 216) = v13 - 1;
        sub_1002327A8(a1 + 176, 1);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182BB78);
        }
        BOOL v14 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "Maximum number of entries exceeded, throwing out oldest entry.",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10182BB78);
          }
          v20[0] = 0;
          uint64_t v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Maximum number of entries exceeded, throwing out oldest entry.",  v20,  2);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityRecorderDb<ParkinsonsResult, CLActivityDB::ClassBDataProtectionPolicy>::addSuspectRecord(cons t T &) [T = ParkinsonsResult, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v18);
        }
      }

      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10182BB98);
      }
      uint64_t v15 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Buffer was added to since db was inaccesible.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10182BB98);
        }
        v20[0] = 0;
        LODWORD(v19) = 2;
        uint64_t v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Buffer was added to since db was inaccesible.",  v20,  v19);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityRecorderDb<ParkinsonsResult, CLActivityDB::ClassBDataProtectionPolicy>::addSuspectRecord(const T &) [T = ParkinsonsResult, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v17);
      }

      __n128 v7 = sub_1002326D0(v12, (uint64_t)a2);
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182BB78);
    }
    uint64_t v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
    {
      BOOL v9 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289538;
      int v24 = 0;
      __int16 v25 = 2082;
      uint64_t v26 = "";
      __int16 v27 = 1026;
      int v28 = (int)v21[0];
      __int16 v29 = 2082;
      __int128 v30 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CL database error, record contains invalid time, invalid time:%{public}d, name: %{public, location:escape_only}s}",  buf,  0x22u);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182BB78);
      }
    }

    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      uint64_t v11 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289538;
      int v24 = 0;
      __int16 v25 = 2082;
      uint64_t v26 = "";
      __int16 v27 = 1026;
      int v28 = (int)v21[0];
      __int16 v29 = 2082;
      __int128 v30 = v11;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CL database error, record contains invalid time",  "{msg%{public}.0s:CL database error, record contains invalid time, invalid time:%{public}d, name: %{public, location:escape_only}s}",  buf,  0x22u);
    }
  }

  return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v5 + 24LL))(v5, v7);
}

void sub_1002326A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

__n128 sub_1002326D0(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 85 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100232830(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x55)) + 48 * (v7 % 0x55);
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v8 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v8 + 32) = v10;
  *(__n128 *)unint64_t v8 = result;
  ++a1[5];
  return result;
}

void sub_10023277C(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_1002327A8(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x55) {
    a2 = 1;
  }
  if (v2 < 0xAA) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 85LL;
  }

  return v4 ^ 1u;
}

void sub_100232804(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

void sub_100232830(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x55;
  unint64_t v4 = v2 - 85;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    BOOL v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      char v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100232AF8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100232B44(uint64_t a1, double **a2)
{
  BOOL v3 = *a2;
  unint64_t v2 = a2[1];
  double v4 = (*a2)[1];
  double v5 = *(float *)(a1 + 136);
  if (v4 <= v5) {
    double v4 = *(float *)(a1 + 136);
  }
  uint64_t v6 = v3 + 3;
  if (v3 + 3 == v2)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    LODWORD(v7) = 0;
    double v8 = *v3;
    do
    {
      double v9 = *v6;
      double v10 = v6[1];
      v6 += 3;
      uint64_t v7 = (v7 + (int)((v9 - v8) / v4));
      if (v10 <= v5) {
        double v4 = *(float *)(a1 + 136);
      }
      else {
        double v4 = v10;
      }
      double v8 = v9;
    }

    while (v6 != v2);
  }

  if (v4 != 1.79769313e308)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182BB78);
    }
    uint64_t v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning No expiration rule was added so the number of records will be unbounded.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182BB78);
      }
      v14[0] = 0;
      uint64_t v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning No expiration rule was added so the number of records will be unbounded.",  v14,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLActivityRecorderDb<ParkinsonsResult, CLActivityDB::ClassBDataProtectionPolicy>::estimateRecordsNeeded(cons t CLAggregationRules &) [T = ParkinsonsResult, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v13);
    }
  }

  return v7;
}

uint64_t sub_100232D40(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x100) {
    a2 = 1;
  }
  if (v2 < 0x200) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 256LL;
  }

  return v4 ^ 1u;
}

uint64_t sub_100232D9C(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = 32 * (v2 - v3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x100) {
    a2 = 1;
  }
  if (v5 < 0x200) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

void sub_100232E08(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    int v7 = (void *)a1[1];
    double v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    double v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)double v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      char v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      double v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        double v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1002330D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t **sub_10023311C(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  int v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        double v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    double v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x48uLL);
    _WORD v11[8] = **a4;
    *((void *)v11 + 7) = 0LL;
    *((void *)v11 + 8) = 0LL;
    *((void *)v11 + 6) = 0LL;
    *((void *)v11 + 5) = v11 + 12;
    sub_1000085FC(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }

  return v9;
}

uint64_t sub_1002331E8(uint64_t **a1, uint64_t a2)
{
  BOOL v3 = a1 + 1;
  unint64_t v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        BOOL v3 = (uint64_t **)v4;
        if (*(_DWORD *)(a2 + 28) >= *((_DWORD *)v4 + 7)) {
          break;
        }
        unint64_t v4 = (uint64_t *)*v4;
        uint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }

      unint64_t v4 = (uint64_t *)v4[1];
    }

    while (v4);
    uint64_t v5 = v3 + 1;
  }

  else
  {
    uint64_t v5 = a1 + 1;
  }

uint64_t sub_100233254(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      int v7 = (uint64_t *)v2;
    }
    else {
      int v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }

  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0LL;
  }
  sub_1002332B8((uint64_t **)a1, v4);
  return 1LL;
}

uint64_t *sub_1002332B8(uint64_t **a1, uint64_t a2)
{
  int v3 = sub_1000087E8(a1, (uint64_t *)a2);
  sub_100008390(a2 + 40, *(void **)(a2 + 48));
  operator delete((void *)a2);
  return v3;
}

void sub_1002332F4(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

CLCppContainer *sub_100233320(void *a1)
{
  uint64_t v2 = operator new(8uLL);
  *uint64_t v2 = *a1;
  uint64_t v4 = _NSConcreteStackBlock;
  uint64_t v5 = 3221225472LL;
  BOOL v6 = sub_1002335A8;
  int v7 = &unk_10181D3D0;
  int v8 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

_BYTE *sub_1002333A0(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    int v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_1002335B8(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    uint64_t v11 = (uint64_t **)(*(void *)a3 + 40LL);
    BOOL v14 = (int *)(*(void *)a2 + 32LL);
    uint64_t v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    __n128 result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

uint64_t **sub_10023347C(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  int v7 = a1 + 1;
  BOOL v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        id v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        BOOL v6 = *v9;
        int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      BOOL v6 = v9[1];
      if (!v6)
      {
        int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    id v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x58uLL);
    _WORD v11[8] = **a4;
    *((_OWORD *)v11 + 4) = 0u;
    *((void *)v11 + 9) = 0LL;
    *((void *)v11 + 1sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0LL;
    *((_OWORD *)v11 + 3) = 0u;
    *((void *)v11 + 5) = v11 + 12;
    *((void *)v11 + 8) = 0LL;
    sub_1000085FC(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }

  return v9;
}

void sub_100233554(uint64_t a1, void **a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    sub_10000AE14((uint64_t)(a2 + 8));
    sub_100008390((uint64_t)(a2 + 5), a2[6]);
  }

  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

void sub_1002335A8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

id sub_1002335B8(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppEncodableDataContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_100233630(a1);
  }
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v4) & 1) != 0) {
    return sub_1002339B8(a1);
  }
  else {
    return 0LL;
  }
}

id sub_100233630(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return sub_100233D64((uint64_t)&v8 + 7, a1);
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182BBB8);
    }
    int v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x80000001012E2A30LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182BBB8);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(v8) = 32;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182BBB8);
    }
    BOOL v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x80000001012E2A30LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182BBB8);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(v8) = 32;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  int v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLHealthAssessmentNotifier_Type::NotificationDat a, Callback = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:241:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_1002339B8(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182BBB8);
    }
    int v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012E2A30LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182BBB8);
    }
    LODWORD(v8) = 134218498;
    HIDWORD(v8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182BBB8);
    }
    BOOL v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012E2A30LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182BBB8);
    }
    LODWORD(v8) = 134218498;
    HIDWORD(v8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  int v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLHealthAssessmentNotifier_Type::NotificationDat a, Callback = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:250:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_100233D64(uint64_t a1, void *a2)
{
  if (![a2 cppObjectPtr]
    && objc_msgSend(objc_msgSend(a2, "compatibilityInfo"), "isEqual:", &off_1018D3098))
  {
    if (objc_msgSend(objc_msgSend(a2, "serialized"), "length") != (id)8) {
      sub_1012310F4();
    }
    objc_msgSend(a2, "setCppObjectPtr:", objc_msgSend(objc_msgSend(a2, "serialized"), "bytes"));
  }

  return [a2 cppObjectPtr];
}

void sub_100233DD8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182BBE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100233DEC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182BBE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100233E18(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  sub_10000AE14(a1 + 32);
  sub_100008390(v2, *(void **)(a1 + 16));
  return a1;
}

CLCppContainer *sub_100233E50(void *a1)
{
  uint64_t v2 = operator new(8uLL);
  *uint64_t v2 = *a1;
  uint64_t v4 = _NSConcreteStackBlock;
  uint64_t v5 = 3221225472LL;
  BOOL v6 = sub_100234494;
  int v7 = &unk_10181D3D0;
  uint64_t v8 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_100233ED0(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    uint64_t v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      uint64_t v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v4;
        }
        else {
          uint64_t v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          uint64_t v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        uint64_t v50 = v9;
        id v13 = sub_1002335B8(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        unint64_t v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          unint64_t v15 = a1 + 11;
          uint64_t v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            uint64_t v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                unint64_t v22 = (uint64_t *)v17;
              }
              else {
                unint64_t v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                uint64_t v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              uint64_t v49 = v19;
              sub_1002333A0(a1, (uint64_t)&v49, (uint64_t)&v50, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              __int16 v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  __int128 v32 = (uint64_t *)v27;
                }
                else {
                  __int128 v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  __int16 v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              uint64_t v50 = v29;
              uint64_t v34 = v29[6];
              unint64_t v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                __int16 v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    uint64_t v39 = (uint64_t *)v36;
                  }
                  else {
                    uint64_t v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    __int16 v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      uint64_t v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      uint64_t v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      unint64_t v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  char v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      unint64_t v14 = v43;
                      char v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      unint64_t v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      __int16 v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              uint64_t v49 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10182BA08);
              }
              uint64_t v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                unint64_t v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)std::string buf = 136446466;
                int v56 = v25;
                __int16 v57 = 1026;
                int v58 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_10182BA08);
                }
                uint64_t v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v51 = 136446466;
                uint64_t v52 = v45;
                __int16 v53 = 1026;
                int v54 = v46;
                LODWORD(v48) = 18;
                uint64_t v47 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                                &v51,
                                v48);
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLHealthAssessmentNotifier_Type::Notification, CLHealthAssessmentNotifier_Type::Notifi cationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification _T = CLHealthAssessmentNotifier_Type::Notification, NotificationData_T = CLHealthAssessmentNotifier_Ty pe::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
              }
            }
          }

          while (v14 != v50 + 6);
        }
      }
    }
  }

__n128 *sub_1002342A4(uint64_t **a1, __n128 *a2)
{
  uint64_t v4 = a1 + 1;
  uint64_t v5 = (__n128 *)operator new(0x58uLL);
  BOOL v11 = v4;
  sub_10023438C(v5 + 2, a2);
  char v12 = 1;
  BOOL v6 = a1[1];
  if (v6)
  {
    signed __int32 v7 = v5[2].n128_i32[0];
    while (1)
    {
      while (1)
      {
        int v8 = (uint64_t **)v6;
        signed __int32 v9 = *((_DWORD *)v6 + 8);
        if (v7 >= v9) {
          break;
        }
        BOOL v6 = *v8;
        uint64_t v4 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      BOOL v6 = v8[1];
      if (!v6)
      {
        uint64_t v4 = v8 + 1;
        goto LABEL_10;
      }
    }

    sub_100233554((uint64_t)&v11, v5);
    return (__n128 *)v8;
  }

  else
  {
    int v8 = v4;
LABEL_10:
    sub_1000085FC(a1, (uint64_t)v8, v4, (uint64_t *)v5);
  }

  return v5;
}

__n128 sub_10023438C(__n128 *a1, __n128 *a2)
{
  a1->n128_u32[0] = a2->n128_u32[0];
  a1->n128_u64[1] = a2->n128_u64[1];
  uint64_t v2 = a2 + 1;
  unint64_t v3 = a2[1].n128_u64[0];
  a1[1].n128_u64[0] = v3;
  uint64_t v4 = a1 + 1;
  unint64_t v5 = a2[1].n128_u64[1];
  a1[1].n128_u64[1] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2->n128_u64[1] = (unint64_t)v2;
    v2->n128_u64[0] = 0LL;
    a2[1].n128_u64[1] = 0LL;
  }

  else
  {
    a1->n128_u64[1] = (unint64_t)v4;
  }

  __n128 result = a2[2];
  a1[2] = result;
  a2[2].n128_u64[0] = 0LL;
  a2[2].n128_u64[1] = 0LL;
  a1[3].n128_u8[0] = a2[3].n128_u8[0];
  return result;
}

uint64_t sub_1002343E4(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)a1 = *a2;
  sub_100234440((uint64_t *)(a1 + 8), a3);
  uint64_t v5 = *(void *)(a3 + 32);
  *(void *)(a1 + 32) = *(void *)(a3 + 24);
  *(void *)(a1 + 4sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = v5;
  if (v5)
  {
    BOOL v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a3 + 40);
  return a1;
}

uint64_t *sub_100234440(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_100AE83D0(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_10023447C(_Unwind_Exception *a1)
{
}

void sub_100234494(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

BOOL sub_1002344A4()
{
  return os_signpost_enabled(*(os_log_t *)(v0 + 1144));
}

uint64_t sub_1002344B4( uint64_t a1, char *a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, __int128 *a8, float a9, __int128 *a10)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  int v18 = (void *)(a1 + 8);
  *(void *)a1 = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 8));
  void *v18 = &off_101826EF8;
  *(void *)a1 = off_10182BC38;
  *(void *)(a1 + 72) = off_10182BC70;
  sub_100D8A584(a1 + 72, a2, a5, a1, a9, a6, 7, 12000LL);
  *(void *)a1 = off_10182BC38;
  *(void *)(a1 + 72) = off_10182BC70;
  *(_OWORD *)(a1 + 184) = 0u;
  uint64_t v19 = (uint64_t *)(a1 + 184);
  *(void *)(a1 + 176) = a4;
  *(_OWORD *)(a1 + 20sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0u;
  *(void *)(a1 + 216) = 0LL;
  sub_1010DDBC0((void *)(a1 + 224), a2);
  int v20 = (_BYTE *)(a1 + 248);
  if (*((char *)a8 + 23) < 0)
  {
    sub_1010DD48C(v20, *(void **)a8, *((void *)a8 + 1));
  }

  else
  {
    __int128 v21 = *a8;
    *(void *)(a1 + 264) = *((void *)a8 + 2);
    *(_OWORD *)int v20 = v21;
  }

  if (*((char *)a10 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 272), *(void **)a10, *((void *)a10 + 1));
  }

  else
  {
    __int128 v22 = *a10;
    *(void *)(a1 + 288) = *((void *)a10 + 2);
    *(_OWORD *)(a1 + 272) = v22;
  }

  *(void *)(a1 + 296) = -1LL;
  *(void *)(a1 + 304) = -1LL;
  *(_BYTE *)(a1 + 312) = 0;
  *(void *)(a1 + 328) = 0LL;
  *(void *)(a1 + 336) = 0LL;
  *(void *)(a1 + 32sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = 0LL;
  *(_BYTE *)(a1 + 344) = 0;
  sub_100B14CF0((void *)(a1 + 352), 0LL, 0LL);
  int v23 = operator new(0x48uLL);
  v23[8] = 0LL;
  *((_OWORD *)v23 + 2) = 0u;
  *((_OWORD *)v23 + 3) = 0u;
  *(_OWORD *)int v23 = 0u;
  *((_OWORD *)v23 + 1) = 0u;
  if (a3)
  {
    *int v23 = off_101826EC8;
    sub_1001B9AC4(v23 + 1);
  }

  else
  {
    *int v23 = off_10182BD58;
    sub_1001B9AC4(v23 + 1);
  }

  v23[1] = v24 + 2;
  uint64_t v25 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = v23;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 24LL))(v25);
  }
  uint64_t v26 = *(void *)(a1 + 192);
  uint64_t v27 = operator new(0x80uLL);
  sub_1010DDBC0(__p, "");
  sub_10023BA7C(v27, a2, v26, a5, a9);
  if (v36 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v28 = *v19;
  *uint64_t v19 = (uint64_t)v27;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
  }
  *(void *)(a1 + 16sub_100222B94(v46, (uint64_t)"sendEventToGizmo", 0) = a7;
  v37[0] = &off_10182BE40;
  v37[1] = sub_100234984;
  BOOL v38 = v37;
  (**(void (***)(uint64_t, uint64_t, void *))a1)(a1, a1, v37);
  int v30 = v38;
  if (v38 == v37)
  {
    uint64_t v31 = 4LL;
    int v30 = v37;
    goto LABEL_20;
  }

  if (v38)
  {
    uint64_t v31 = 5LL;
LABEL_20:
    (*(void (**)(void *, uint64_t))(*v30 + 8 * v31))(v30, v29);
  }

  unsigned __int8 v34 = 0;
  sub_1012049AC((unsigned __int8 *)__p, "HealthColdStorageMaxExpirationEnabled", &v34, 0);
  *(_BYTE *)(a1 + 312) = BYTE1(__p[0]);
  return a1;
}

void sub_10023481C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22)
{
  uint64_t v27 = *(void *)(v22 + 192);
  *(void *)(v22 + 192) = 0LL;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 24LL))(v27);
  }
  uint64_t v28 = *v24;
  *uint64_t v24 = 0LL;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
  }
  sub_100D8A88C(a10);
  *(void *)uint64_t v22 = off_101826EC8;
  sub_1001B9C98(v23);
  _Unwind_Resume(a1);
}

void sub_100234970()
{
}

void sub_10023497C()
{
}

uint64_t sub_100234984(uint64_t a1, int a2)
{
  if (!a2) {
    return 0LL;
  }
  if (*(void *)(a1 + 176))
  {
    if ((sub_100D8A92C(a1 + 72) & 1) == 0) {
      sub_100BE71D8(*(void *)(a1 + 176));
    }
  }

  else {
    return 0LL;
  }
}

uint64_t sub_1002349F0( uint64_t a1, char *a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, __int128 *a8, float a9, __int128 *a10)
{
  return sub_1002344B4(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t sub_1002349FC(uint64_t a1, uint64_t *a2, double *a3, int *a4)
{
  int v8 = (sqlite3_stmt *)sub_100019240(*a2);
  int v9 = sqlite3_step(v8);
  if (v9 == 101) {
    return 1LL;
  }
  int v10 = v9;
  if (v9 == 100)
  {
    sub_100234BF8(a1, a2, a3, a4);
    return 0LL;
  }

  else
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    char v12 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      int v17 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "[DB] getMostRecentTimeWithCode - Result was error: %d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182BCE8);
      }
      v15[0] = 67109120;
      v15[1] = v10;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  17LL,  "[DB] getMostRecentTimeWithCode - Result was error: %d",  v15);
      unint64_t v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLActivityDB::ActivityCode CMHealthColdStorageDb::getTimeAndIDWithCode(const CLSqliteScopedStatement &, CFAbsolu teTime &, int &) const",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }

    return 2LL;
  }

void sub_100234BF8(uint64_t a1, uint64_t *a2, double *a3, int *a4)
{
  int v8 = (sqlite3_stmt *)sub_100019240(*a2);
  *a4 = sqlite3_column_int(v8, *(_DWORD *)(a1 + 308));
  int v9 = (sqlite3_stmt *)sub_100019240(*a2);
  *a3 = sqlite3_column_double(v9, *(_DWORD *)(a1 + 296));
}

uint64_t sub_100234C50(void *a1, double *a2, uint64_t a3)
{
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v36);
    unint64_t v7 = sub_10000CF44(&v37, (uint64_t)"SELECT * FROM ", 14LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 32LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    int v10 = sub_10000CF44(v7, (uint64_t)p_p, size);
    BOOL v11 = sub_10000CF44(v10, (uint64_t)" WHERE ", 7LL);
    if (byte_101993D07 >= 0) {
      char v12 = &qword_101993CF0;
    }
    else {
      char v12 = (uint64_t *)qword_101993CF0;
    }
    if (byte_101993D07 >= 0) {
      uint64_t v13 = byte_101993D07;
    }
    else {
      uint64_t v13 = unk_101993CF8;
    }
    unint64_t v14 = sub_10000CF44(v11, (uint64_t)v12, v13);
    unint64_t v15 = sub_10000CF44(v14, (uint64_t)" LIKE '%", 8LL);
    int v16 = *(char *)(a3 + 23);
    if (v16 >= 0) {
      uint64_t v17 = a3;
    }
    else {
      uint64_t v17 = *(void *)a3;
    }
    if (v16 >= 0) {
      uint64_t v18 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v18 = *(void *)(a3 + 8);
    }
    uint64_t v19 = sub_10000CF44(v15, v17, v18);
    int v20 = sub_10000CF44(v19, (uint64_t)"%' OR ", 6LL);
    if (byte_101993D07 >= 0) {
      __int128 v21 = &qword_101993CF0;
    }
    else {
      __int128 v21 = (uint64_t *)qword_101993CF0;
    }
    if (byte_101993D07 >= 0) {
      uint64_t v22 = byte_101993D07;
    }
    else {
      uint64_t v22 = unk_101993CF8;
    }
    int v23 = sub_10000CF44(v20, (uint64_t)v21, v22);
    uint64_t v24 = sub_10000CF44(v23, (uint64_t)" IS NULL OR ", 12LL);
    if (byte_101993D07 >= 0) {
      uint64_t v25 = &qword_101993CF0;
    }
    else {
      uint64_t v25 = (uint64_t *)qword_101993CF0;
    }
    if (byte_101993D07 >= 0) {
      uint64_t v26 = byte_101993D07;
    }
    else {
      uint64_t v26 = unk_101993CF8;
    }
    uint64_t v27 = sub_10000CF44(v24, (uint64_t)v25, v26);
    sub_10000CF44(v27, (uint64_t)" = '' ORDER BY ROWID DESC LIMIT 1", 33LL);
    uint64_t v28 = a1[10];
    std::stringbuf::str(&__p, &v38);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v29 = &__p;
    }
    else {
      uint64_t v29 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v28, (char *)v29, &v33);
    uint64_t v30 = v33;
    uint64_t v33 = 0LL;
    uint64_t v34 = v30;
    unsigned int v31 = sub_1002349FC((uint64_t)a1, &v34, a2, (int *)&__p);
    if (v30) {
      (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
    }
    *(void *)((char *)v36
    uint64_t v37 = v32;
    std::streambuf::~streambuf(&v38);
    std::ios::~ios(&v39);
    return v31 < 2;
  }

  return result;
}

void sub_100234EAC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
  }
  sub_1011F8850((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_100234F00(void *a1, double *a2, uint64_t a3)
{
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v36);
    unint64_t v7 = sub_10000CF44(&v37, (uint64_t)"SELECT * FROM ", 14LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 32LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    int v10 = sub_10000CF44(v7, (uint64_t)p_p, size);
    BOOL v11 = sub_10000CF44(v10, (uint64_t)" WHERE ", 7LL);
    if (byte_101993D07 >= 0) {
      char v12 = &qword_101993CF0;
    }
    else {
      char v12 = (uint64_t *)qword_101993CF0;
    }
    if (byte_101993D07 >= 0) {
      uint64_t v13 = byte_101993D07;
    }
    else {
      uint64_t v13 = unk_101993CF8;
    }
    unint64_t v14 = sub_10000CF44(v11, (uint64_t)v12, v13);
    unint64_t v15 = sub_10000CF44(v14, (uint64_t)" LIKE '%", 8LL);
    int v16 = *(char *)(a3 + 23);
    if (v16 >= 0) {
      uint64_t v17 = a3;
    }
    else {
      uint64_t v17 = *(void *)a3;
    }
    if (v16 >= 0) {
      uint64_t v18 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v18 = *(void *)(a3 + 8);
    }
    uint64_t v19 = sub_10000CF44(v15, v17, v18);
    int v20 = sub_10000CF44(v19, (uint64_t)"%' OR ", 6LL);
    if (byte_101993D07 >= 0) {
      __int128 v21 = &qword_101993CF0;
    }
    else {
      __int128 v21 = (uint64_t *)qword_101993CF0;
    }
    if (byte_101993D07 >= 0) {
      uint64_t v22 = byte_101993D07;
    }
    else {
      uint64_t v22 = unk_101993CF8;
    }
    int v23 = sub_10000CF44(v20, (uint64_t)v21, v22);
    uint64_t v24 = sub_10000CF44(v23, (uint64_t)" IS NULL OR ", 12LL);
    if (byte_101993D07 >= 0) {
      uint64_t v25 = &qword_101993CF0;
    }
    else {
      uint64_t v25 = (uint64_t *)qword_101993CF0;
    }
    if (byte_101993D07 >= 0) {
      uint64_t v26 = byte_101993D07;
    }
    else {
      uint64_t v26 = unk_101993CF8;
    }
    uint64_t v27 = sub_10000CF44(v24, (uint64_t)v25, v26);
    sub_10000CF44(v27, (uint64_t)" = '' ORDER BY ROWID ASC LIMIT 1", 32LL);
    uint64_t v28 = a1[10];
    std::stringbuf::str(&__p, &v38);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v29 = &__p;
    }
    else {
      uint64_t v29 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v28, (char *)v29, &v33);
    uint64_t v30 = v33;
    uint64_t v33 = 0LL;
    uint64_t v34 = v30;
    unsigned int v31 = sub_1002349FC((uint64_t)a1, &v34, a2, (int *)&__p);
    if (v30) {
      (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
    }
    *(void *)((char *)v36
    uint64_t v37 = v32;
    std::streambuf::~streambuf(&v38);
    std::ios::~ios(&v39);
    return v31 < 2;
  }

  return result;
}

void sub_10023515C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
  }
  sub_1011F8850((uint64_t)&a17);
  _Unwind_Resume(a1);
}

BOOL sub_1002351B0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, double a5)
{
  if (sub_100D8A92C(a1 + 72))
  {
    sub_10000CE18((uint64_t)v58);
    int v10 = sub_10000CF44(&v59, (uint64_t)"SELECT * FROM ", 14LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v13 = sub_10000CF44(v10, (uint64_t)p_p, size);
    unint64_t v14 = sub_10000CF44(v13, (uint64_t)" WHERE ", 7LL);
    int v15 = *(char *)(a1 + 271);
    if (v15 >= 0) {
      uint64_t v16 = a1 + 248;
    }
    else {
      uint64_t v16 = *(void *)(a1 + 248);
    }
    if (v15 >= 0) {
      uint64_t v17 = *(unsigned __int8 *)(a1 + 271);
    }
    else {
      uint64_t v17 = *(void *)(a1 + 256);
    }
    uint64_t v18 = sub_10000CF44(v14, v16, v17);
    uint64_t v19 = sub_10000CF44(v18, (uint64_t)" > ? AND (", 10LL);
    if (byte_101993D07 >= 0) {
      int v20 = &qword_101993CF0;
    }
    else {
      int v20 = (uint64_t *)qword_101993CF0;
    }
    if (byte_101993D07 >= 0) {
      uint64_t v21 = byte_101993D07;
    }
    else {
      uint64_t v21 = unk_101993CF8;
    }
    uint64_t v22 = sub_10000CF44(v19, (uint64_t)v20, v21);
    int v23 = sub_10000CF44(v22, (uint64_t)" LIKE '%", 8LL);
    int v24 = *(char *)(a3 + 23);
    if (v24 >= 0) {
      uint64_t v25 = a3;
    }
    else {
      uint64_t v25 = *(void *)a3;
    }
    if (v24 >= 0) {
      uint64_t v26 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v26 = *(void *)(a3 + 8);
    }
    uint64_t v27 = sub_10000CF44(v23, v25, v26);
    uint64_t v28 = sub_10000CF44(v27, (uint64_t)"%' OR ", 6LL);
    if (byte_101993D07 >= 0) {
      uint64_t v29 = &qword_101993CF0;
    }
    else {
      uint64_t v29 = (uint64_t *)qword_101993CF0;
    }
    if (byte_101993D07 >= 0) {
      uint64_t v30 = byte_101993D07;
    }
    else {
      uint64_t v30 = unk_101993CF8;
    }
    unsigned int v31 = sub_10000CF44(v28, (uint64_t)v29, v30);
    uint64_t v32 = sub_10000CF44(v31, (uint64_t)" IS NULL OR ", 12LL);
    if (byte_101993D07 >= 0) {
      uint64_t v33 = &qword_101993CF0;
    }
    else {
      uint64_t v33 = (uint64_t *)qword_101993CF0;
    }
    if (byte_101993D07 >= 0) {
      uint64_t v34 = byte_101993D07;
    }
    else {
      uint64_t v34 = unk_101993CF8;
    }
    __int16 v35 = sub_10000CF44(v32, (uint64_t)v33, v34);
    char v36 = sub_10000CF44(v35, (uint64_t)" = '') ORDER BY ROWID ASC LIMIT ", 32LL);
    std::ostream::operator<<(v36, 500LL);
    uint64_t v37 = *(void *)(a1 + 80);
    std::stringbuf::str(&__p, &v60);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::stringbuf v38 = &__p;
    }
    else {
      std::stringbuf v38 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v37, (char *)v38, &v55);
    uint64_t v39 = v55;
    uint64_t v55 = 0LL;
    uint64_t v56 = v39;
    int v40 = (sqlite3_stmt *)sub_100019240(v39);
    if (sub_1003B7480(v40, 1, a5))
    {
      while (1)
      {
        int v41 = sub_1002349FC(a1, &v56, (double *)&__p, (int *)&v55);
        if (v41) {
          break;
        }
        char v43 = *(_DWORD **)(a2 + 8);
        unint64_t v42 = *(void *)(a2 + 16);
        if ((unint64_t)v43 >= v42)
        {
          uint64_t v45 = *(_DWORD **)a2;
          uint64_t v46 = ((uint64_t)v43 - *(void *)a2) >> 2;
          unint64_t v47 = v46 + 1;
          uint64_t v48 = v42 - (void)v45;
          if (v48 >> 1 > v47) {
            unint64_t v47 = v48 >> 1;
          }
          else {
            unint64_t v49 = v47;
          }
          if (v49)
          {
            uint64_t v50 = (char *)sub_10000956C(a2 + 16, v49);
            uint64_t v45 = *(_DWORD **)a2;
            char v43 = *(_DWORD **)(a2 + 8);
          }

          else
          {
            uint64_t v50 = 0LL;
          }

          int v51 = &v50[4 * v46];
          *(_DWORD *)int v51 = v55;
          BOOL v44 = v51 + 4;
          while (v43 != v45)
          {
            int v52 = *--v43;
            *((_DWORD *)v51 - 1) = v52;
            v51 -= 4;
          }

          *(void *)a2 = v51;
          *(void *)(a2 + 8) = v44;
          *(void *)(a2 + 16) = &v50[4 * v49];
          if (v45) {
            operator delete(v45);
          }
        }

        else
        {
          *char v43 = v55;
          BOOL v44 = v43 + 1;
        }

        *(void *)(a2 + 8) = v44;
        *a4 = __p.__r_.__value_.__r.__words[0];
      }
    }

    else
    {
      int v41 = 2;
    }

    if (v39) {
      (*(void (**)(uint64_t))(*(void *)v39 + 8LL))(v39);
    }
    *(void *)((char *)v58
    uint64_t v59 = v53;
    std::streambuf::~streambuf(&v60);
    std::ios::~ios(&v61);
  }

  else
  {
    int v41 = 2;
  }

  return v41 == 1;
}

void sub_100235558( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a17);
  _Unwind_Resume(a1);
}

NSData *sub_1002355B4(uint64_t a1, uint64_t *a2)
{
  if (*a2
    && *(_DWORD *)(a1 + 300) != -1
    && (uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a2), sqlite3_step(v4) == 100)
    && (uint64_t v5 = (sqlite3_stmt *)sub_100019240(*a2),
        BOOL v6 = sqlite3_column_blob(v5, *(_DWORD *)(a1 + 300)),
        unint64_t v7 = (sqlite3_stmt *)sub_100019240(*a2),
        int v8 = sqlite3_column_bytes(v7, *(_DWORD *)(a1 + 300)),
        v6)
    && v8)
  {
    return -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v6, v8);
  }

  else
  {
    return 0LL;
  }

uint64_t sub_10023565C(uint64_t a1, double a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v23);
    uint64_t v5 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    int v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
    int v9 = sub_10000CF44(v8, (uint64_t)" WHERE ", 7LL);
    int v10 = *(char *)(a1 + 271);
    if (v10 >= 0) {
      uint64_t v11 = a1 + 248;
    }
    else {
      uint64_t v11 = *(void *)(a1 + 248);
    }
    if (v10 >= 0) {
      uint64_t v12 = *(unsigned __int8 *)(a1 + 271);
    }
    else {
      uint64_t v12 = *(void *)(a1 + 256);
    }
    uint64_t v13 = sub_10000CF44(v9, v11, v12);
    sub_10000CF44(v13, (uint64_t)" < ?", 4LL);
    uint64_t v14 = *(void *)(a1 + 80);
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v15 = &__p;
    }
    else {
      int v15 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v14, (char *)v15, &v21);
    uint64_t v16 = v21;
    uint64_t v21 = 0LL;
    uint64_t v17 = (sqlite3_stmt *)sub_100019240(v16);
    if (sub_1003B7480(v17, 1, a2))
    {
      uint64_t v18 = *(void *)(a1 + 80);
      uint64_t v19 = (sqlite3_stmt *)sub_100019240(v16);
      sub_1003BB2BC(v18, v19);
    }

    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
    }
    *(void *)((char *)v23
    uint64_t v24 = v20;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

void sub_100235848( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_10023589C(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = __p;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 32LL))(__p);
  if (v95 < 0) {
    uint64_t v2 = (void **)__p[0];
  }
  if (!strcmp((const char *)v2, "VO2MaxInputHistory") && !*(_BYTE *)(*(void *)(v1 + 176) + 148LL))
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    uint64_t v34 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_INFO,  "[DB] VO2MaxInputHistory table not yet ready for sync since deduplication is not complete",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_58;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    *(_WORD *)v96 = 0;
    __int16 v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  1LL,  "[DB] VO2MaxInputHistory table not yet ready for sync since deduplication is not complete",  v96,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CMHealthColdStorageDb::validateTableFormat()", "%s\n", v35);
LABEL_149:
    free(v35);
LABEL_58:
    uint64_t v27 = 0LL;
    goto LABEL_59;
  }

  if (!sub_100D8A92C(*(void *)(v1 + 184)) || !sub_100D8A92C(v1 + 72))
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    uint64_t v24 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = sub_100D8A92C(*(void *)(v1 + 184));
      int v26 = sub_100D8A92C(v1 + 72);
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v25;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "[DB] One of the DBs is not accessible. Hot: %d, Cold %d",  buf,  0xEu);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_58;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    uint64_t v76 = qword_1019347B8;
    int v77 = sub_100D8A92C(*(void *)(v1 + 184));
    int v78 = sub_100D8A92C(v1 + 72);
    *(_DWORD *)v96 = 67109376;
    *(_DWORD *)&v96[4] = v77;
    *(_WORD *)&v96[8] = 1024;
    *(_DWORD *)&v96[10] = v78;
    __int16 v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v76,  0LL,  "[DB] One of the DBs is not accessible. Hot: %d, Cold %d",  v96,  14);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CMHealthColdStorageDb::validateTableFormat()", "%s\n", v35);
    goto LABEL_149;
  }

  sub_100012A14((uint64_t *)(v1 + 200));
  __int16 v91 = 0LL;
  unint64_t v92 = 0LL;
  unint64_t v93 = 0LL;
  sub_100D8B410(*(void *)(v1 + 184), (const char *)v2, (uint64_t *)(v1 + 200), (char **)&v91);
  *(_DWORD *)(v1 + 296) = -1;
  *(_DWORD *)(v1 + 308) = -1;
  uint64_t v3 = *(void *)(v1 + 200);
  uint64_t v4 = *(void *)(v1 + 208) - v3;
  uint64_t v89 = v1;
  if (!v4) {
    goto LABEL_62;
  }
  __int16 v83 = (char *)v2;
  uint64_t v5 = 0LL;
  unint64_t v6 = v4 / 24;
  v87 = (unsigned __int8 **)(v1 + 248);
  int v88 = *(char *)(v1 + 271);
  if (v88 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(v1 + 271);
  }
  else {
    uint64_t v7 = *(void *)(v1 + 256);
  }
  v86 = (unsigned __int8 **)(v1 + 272);
  if (v6 <= 1) {
    uint64_t v8 = 1LL;
  }
  else {
    uint64_t v8 = v6;
  }
  int v84 = -1;
  int v85 = -1;
  int v9 = -1;
  int v10 = -1;
  do
  {
    uint64_t v11 = (unsigned __int8 *)(v3 + 24 * v5);
    uint64_t v12 = v11[23];
    size_t v13 = *((void *)v11 + 1);
    if ((v12 & 0x80u) == 0LL) {
      uint64_t v14 = v11[23];
    }
    else {
      uint64_t v14 = *((void *)v11 + 1);
    }
    if (v14 != v7) {
      goto LABEL_29;
    }
    if (v88 >= 0) {
      int v15 = (unsigned __int8 *)v87;
    }
    else {
      int v15 = *v87;
    }
    if ((v12 & 0x80) != 0)
    {
    }

    else if (v11[23])
    {
      uint64_t v16 = (unsigned __int8 *)(v3 + 24 * v5);
      uint64_t v17 = v11[23];
      while (*v16 == *v15)
      {
        ++v16;
        ++v15;
        if (!--v17) {
          goto LABEL_40;
        }
      }

void sub_1002364B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100236548(uint64_t a1, char *a2)
{
  if (!strcmp(a2, "SmoothedGaitMetricsHistory"))
  {
    size_t v13 = "";
    int v14 = 5;
    __int16 v15 = 0;
    char v16 = 0;
    char v17 = 0;
    int v5 = sub_1003BC790(*(void *)(a1 + 80), a2, "numGaitMetrics", (uint64_t)&v13);
    if ((_BYTE)v15) {
      int v6 = v5;
    }
    else {
      int v6 = 0;
    }
    if (v6 == 1)
    {
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182BCE8);
      }
      uint64_t v7 = (os_log_s *)qword_1019347B8;
      if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[DB] Recreate SmoothedGaitMetricsHistory table in Cold Storage if the primary key is incorrectly set",  (uint8_t *)__p,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(__p, 0x65CuLL);
        if (qword_1019347B0 != -1) {
          dispatch_once(&qword_1019347B0, &stru_10182BCE8);
        }
        v12[0] = 0;
        uint64_t v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  0LL,  "[DB] Recreate SmoothedGaitMetricsHistory table in Cold Storage if the primary key is incorrectly set",  v12,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CMHealthColdStorageDb::deleteTableIfNecessary(const char *)",  "%s\n",  v11);
      }

      uint64_t v9 = *(void *)(a1 + 80);
      uint64_t v8 = (uint64_t *)(a1 + 80);
      sub_1003C0454(v9);
      sub_1003C0200(*v8, a2);
      sub_1003C05BC(*v8);
    }

    return 1LL;
  }

  if (strcmp(a2, "VO2MaxInputHistory")) {
    return 1LL;
  }
  sub_1010DDBC0(__p, a2);
  BOOL v4 = sub_1002367DC(a1, (uint64_t)__p);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  return v4;
}

void sub_1002367B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002367DC(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  v27[19] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v28 = 256;
  if (sub_100D8A92C(v6)
    && (*(char *)(a2 + 23) >= 0 ? (uint64_t v7 = a2) : (uint64_t v7 = *(void *)a2), sub_1003B747C( *(void *)(a1 + 80),  v7)))
  {
    double Current = CFAbsoluteTimeGetCurrent();
    sub_10000CE18((uint64_t)v24);
    uint64_t v9 = sub_10000CF44(&v25, (uint64_t)"DELETE FROM ", 12LL);
    int v10 = *(char *)(a2 + 23);
    if (v10 >= 0) {
      uint64_t v11 = a2;
    }
    else {
      uint64_t v11 = *(void *)a2;
    }
    if (v10 >= 0) {
      uint64_t v12 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      uint64_t v12 = *(void *)(a2 + 8);
    }
    sub_10000CF44(v9, v11, v12);
    uint64_t v13 = *(void *)(a1 + 80);
    std::stringbuf::str(&v32, &v26);
    if ((v32.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v14 = &v32;
    }
    else {
      int v14 = (std::stringbuf::string_type *)v32.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v13, (char *)v14, v29);
    uint64_t v15 = *(void *)v29;
    *(void *)uint64_t v29 = 0LL;
    uint64_t v16 = *(void *)(a1 + 80);
    char v17 = (sqlite3_stmt *)sub_100019240(v15);
    BOOL v18 = sub_1003BB2BC(v16, v17);
    double v19 = CFAbsoluteTimeGetCurrent();
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    uint64_t v20 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v32.__r_.__value_.__l.__data_) = 134349312;
      *(double *)((char *)v32.__r_.__value_.__r.__words + 4) = v19 - Current;
      WORD2(v32.__r_.__value_.__r.__words[1]) = 1026;
      *(_DWORD *)((char *)&v32.__r_.__value_.__r.__words[1] + 6) = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "[DB] Time taken for table truncate, %{public}.2f, success, %{public}d",  (uint8_t *)&v32,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&v32, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182BCE8);
      }
      *(_DWORD *)uint64_t v29 = 134349312;
      *(double *)&v29[4] = v19 - Current;
      __int16 v30 = 1026;
      BOOL v31 = v18;
      int v23 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v32,  1628LL,  &_mh_execute_header,  qword_1019347B8,  0LL,  "[DB] Time taken for table truncate, %{public}.2f, success, %{public}d",  v29,  18);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CMHealthColdStorageDb::truncateTable(const std::string &)",  "%s\n",  (const char *)v23);
      if (v23 != &v32) {
        free(v23);
      }
    }

    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
    *(void *)((char *)v24
    uint64_t v25 = v21;
    std::streambuf::~streambuf(&v26);
    std::ios::~ios(v27);
  }

  else
  {
    BOOL v18 = 0LL;
  }

  (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
  return v18;
}

void sub_100236B54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, char a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  if (v58) {
    (*(void (**)(uint64_t))(*(void *)v58 + 8LL))(v58);
  }
  sub_1011F8850((uint64_t)&a11);
  sub_1011C52D0((uint64_t)&a46);
  _Unwind_Resume(a1);
}

uint64_t sub_100236BD0(uint64_t a1, uint64_t a2, uint64_t *a3, double a4)
{
  if ((sub_100D8A92C(*(void *)(a1 + 184)) & 1) == 0
    && (sub_100D8A92C(a1 + 72) & 1) == 0
    && MKBGetDeviceLockState(0LL) == 3)
  {
    sub_100BE71D8(*(void *)(a1 + 176));
    (*(void (**)(void))(**(void **)(a1 + 184) + 24LL))(*(void *)(a1 + 184));
    (*(void (**)(uint64_t))(*(void *)(a1 + 72) + 24LL))(a1 + 72);
  }

  if (sub_100D8A92C(*(void *)(a1 + 184)) && (uint64_t v8 = a1 + 72, sub_100D8A92C(a1 + 72)))
  {
    if (sub_10023589C(a1))
    {
      *(double *)&unint64_t v98 = -1.0;
      if (sub_100234C50((void *)a1, (double *)&v98, a2))
      {
        p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
        if (qword_1019347B0 != -1) {
          dispatch_once(&qword_1019347B0, &stru_10182BCE8);
        }
        int v10 = (os_log_s *)qword_1019347B8;
        if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_INFO))
        {
          unint64_t v11 = v98;
          (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(__p, a1);
          uint64_t v12 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)std::string buf = 134218242;
          *(void *)&uint8_t buf[4] = v11;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "[DB] Found most recent time %f for %s",  buf,  0x16u);
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_10182BCE8);
          }
          uint64_t v66 = qword_1019347B8;
          double v67 = *(double *)&v98;
          (*(void (**)(uint8_t *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(buf, a1);
          if ((buf[23] & 0x80u) == 0) {
            __int16 v68 = buf;
          }
          else {
            __int16 v68 = *(uint8_t **)buf;
          }
          *(_DWORD *)v106 = 134218242;
          *(double *)&v106[4] = v67;
          *(_WORD *)&v106[12] = 2080;
          *(void *)&v106[14] = v68;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v66,  1LL,  "[DB] Found most recent time %f for %s",  COERCE_DOUBLE(v106),  22);
          __int128 v70 = v69;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CMHealthColdStorageDb::syncFromHot(CFAbsoluteTime, const std::string &, std::shared_ptr<CLHealthColdStorageStats>)",  "%s\n",  v70);
          double v13 = v67;
          if (v70 != __p) {
            free(v70);
          }
        }

        else
        {
          double v13 = *(double *)&v98;
        }

        double v97 = -1.0;
        sub_100234F00((void *)a1, &v97, a2);
        BOOL v14 = a4 > 0.0;
        if (v13 <= 0.0) {
          BOOL v14 = 0;
        }
        if (v14 && v13 < a4)
        {
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_10182BCE8);
          }
          uint64_t v15 = (os_log_s *)qword_1019347B8;
          if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)std::stringbuf::string_type __p = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "[DB] Deleting all old records.", __p, 2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(__p, 0x65CuLL);
            if (qword_1019347B0 != -1) {
              dispatch_once(&qword_1019347B0, &stru_10182BCE8);
            }
            *(_WORD *)std::string buf = 0;
            LODWORD(v93) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  1LL,  "[DB] Deleting all old records.",  buf,  *(void *)&v93);
            __int16 v82 = (char *)v81;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CMHealthColdStorageDb::syncFromHot(CFAbsoluteTime, const std::string &, std::shared_ptr<CLHealthCo ldStorageStats>)",  "%s\n",  v81);
            if (v82 != __p) {
              free(v82);
            }
          }

          sub_100D8BAC8((void *)(a1 + 72));
        }

        else
        {
          if (v97 >= a4) {
            BOOL v14 = 0;
          }
          if (v14)
          {
            if (qword_1019347B0 != -1) {
              dispatch_once(&qword_1019347B0, &stru_10182BCE8);
            }
            uint64_t v20 = (os_log_s *)qword_1019347B8;
            if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_INFO))
            {
              *(_WORD *)std::stringbuf::string_type __p = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "[DB] Deleting all old records preceding delete request.",  __p,  2u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(__p, 0x65CuLL);
              if (qword_1019347B0 != -1) {
                dispatch_once(&qword_1019347B0, &stru_10182BCE8);
              }
              *(_WORD *)std::string buf = 0;
              LODWORD(v93) = 2;
              _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  1LL,  "[DB] Deleting all old records preceding delete request.",  buf,  *(void *)&v93);
              int v88 = (char *)v87;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CMHealthColdStorageDb::syncFromHot(CFAbsoluteTime, const std::string &, std::shared_ptr<CLHealth ColdStorageStats>)",  "%s\n",  v87);
              if (v88 != __p) {
                free(v88);
              }
            }

            sub_10023565C(a1, a4);
          }
        }

        if (!*(_DWORD *)(a1 + 132)) {
          *(_DWORD *)(a1 + 132) = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 48LL))(a1 + 72);
        }
        if (v13 >= a4) {
          double v21 = v13;
        }
        else {
          double v21 = a4;
        }
        memset(buf, 0, 24);
        sub_1002381FC(a1, (uint64_t)buf);
        double Current = CFAbsoluteTimeGetCurrent();
        uint64_t v23 = *(void *)(a1 + 184);
        (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(v106, a1);
        memset(__p, 0, 24);
        *(void *)&__int128 v104 = __p;
        BYTE8(v104) = 0;
        *(void *)std::stringbuf::string_type __p = operator new(0x18uLL);
        *(void *)&__p[8] = *(void *)__p;
        *(void *)&__p[16] = *(void *)__p + 24LL;
        *(void *)&__p[8] = sub_100036E0C((uint64_t)&__p[16], (__int128 *)v106, (__int128 *)&v107, *(char **)__p);
        if ((char)buf[23] < 0)
        {
          sub_1010DD48C(__dst, *(void **)buf, *(unint64_t *)&buf[8]);
        }

        else
        {
          *(_OWORD *)__uuid_t dst = *(_OWORD *)buf;
          *(void *)&__dst[16] = *(void *)&buf[16];
        }

        __int128 v104 = 0uLL;
        uint64_t v105 = 0LL;
        *(void *)v99 = &v104;
        v99[8] = 0;
        *(void *)&__int128 v104 = operator new(0x18uLL);
        *((void *)&v104 + 1) = v104;
        uint64_t v105 = v104 + 24;
        *((void *)&v104 + 1) = sub_100036E0C((uint64_t)&v105, (__int128 *)__dst, (__int128 *)&v103, (char *)v104);
        uint64_t v24 = (char *)(a1 + 248);
        sub_100D8B420(a1 + 72, v23, (uint64_t *)__p, &v104, v24, v21);
        *(void *)v99 = &v104;
        sub_1000129D4((void ***)v99);
        if ((__dst[23] & 0x80000000) != 0) {
          operator delete(*(void **)__dst);
        }
        *(void *)&__int128 v104 = __p;
        sub_1000129D4((void ***)&v104);
        if ((v106[23] & 0x80000000) != 0) {
          operator delete(*(void **)v106);
        }
        int v25 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 48LL))(a1 + 72);
        if (*(_BYTE *)(a1 + 312))
        {
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_10182BCE8);
          }
          std::stringbuf v26 = (os_log_s *)qword_1019347B8;
          if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
          {
            int v27 = *(unsigned __int8 *)(a1 + 312);
            *(_DWORD *)std::stringbuf::string_type __p = 67109376;
            *(_DWORD *)&__p[4] = v27;
            *(_WORD *)&__p[8] = 1024;
            *(_DWORD *)&__p[10] = 730;
            _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Cold Storage Max expiration enabled %d, expiration in days set to %d",  __p,  0xEu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(__p, 0x65CuLL);
            if (qword_1019347B0 != -1) {
              dispatch_once(&qword_1019347B0, &stru_10182BCE8);
            }
            int v76 = *(unsigned __int8 *)(a1 + 312);
            *(_DWORD *)v106 = 67109376;
            *(_DWORD *)&v106[4] = v76;
            *(_WORD *)&v106[8] = 1024;
            *(_DWORD *)&v106[10] = 730;
            _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  0LL,  "Cold Storage Max expiration enabled %d, expiration in days set to %d",  v106,  14);
            int v78 = (char *)v77;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CMHealthColdStorageDb::syncFromHot(CFAbsoluteTime, const std::string &, std::shared_ptr<CLHealthCo ldStorageStats>)",  "%s\n",  v77);
            if (v78 != __p) {
              free(v78);
            }
          }

          uint64_t v18 = 100LL;
          int v28 = 730;
        }

        else
        {
          (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(__p, a1);
          uint64_t v29 = sub_10023BD04(qword_101993D08, __p);
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
          if (v29)
          {
            int v28 = *((_DWORD *)v29 + 10);
            uint64_t v18 = 100LL;
          }

          else
          {
            if (qword_1019347B0 != -1) {
              dispatch_once(&qword_1019347B0, &stru_10182BCE8);
            }
            __int16 v30 = (os_log_s *)qword_1019347B8;
            if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_FAULT))
            {
              (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(__p, a1);
              BOOL v31 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
              *(_DWORD *)v106 = 136315138;
              *(void *)&v106[4] = v31;
              _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_FAULT,  "No expiration set for db, %s",  v106,  0xCu);
              if ((__p[23] & 0x80000000) != 0) {
                operator delete(*(void **)__p);
              }
            }

            if (sub_1002921D0(115, 0))
            {
              bzero(__p, 0x65CuLL);
              if (qword_1019347B0 != -1) {
                dispatch_once(&qword_1019347B0, &stru_10182BCE8);
              }
              uint64_t v89 = qword_1019347B8;
              (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(v106, a1);
              if (v106[23] >= 0) {
                uint64_t v90 = v106;
              }
              else {
                uint64_t v90 = *(_BYTE **)v106;
              }
              LODWORD(v104) = 136315138;
              *(void *)((char *)&v104 + 4) = v90;
              _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v89,  17LL,  "No expiration set for db, %s",  (const char *)&v104);
              unint64_t v92 = v91;
              if ((v106[23] & 0x80000000) != 0) {
                operator delete(*(void **)v106);
              }
              sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CMHealthColdStorageDb::syncFromHot(CFAbsoluteTime, const std::string &, std::shared_ptr<CLHealth ColdStorageStats>)",  "%s\n",  v92);
              if (v92 != __p) {
                free(v92);
              }
            }

            int v28 = 0;
            uint64_t v18 = 103LL;
          }
        }

        if (qword_1019347B0 != -1) {
          dispatch_once(&qword_1019347B0, &stru_10182BCE8);
        }
        std::stringbuf::string_type v32 = (os_log_s *)qword_1019347B8;
        if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEBUG))
        {
          (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(v106, a1);
          if (v106[23] >= 0) {
            char v33 = v106;
          }
          else {
            char v33 = *(_BYTE **)v106;
          }
          int v34 = *(unsigned __int8 *)(a1 + 312);
          *(_DWORD *)std::stringbuf::string_type __p = 136315650;
          *(void *)&__p[4] = v33;
          *(_WORD *)&_BYTE __p[12] = 1024;
          *(_DWORD *)&__p[14] = v28;
          *(_WORD *)&__p[18] = 1024;
          *(_DWORD *)&__p[20] = v34;
          _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "Cold Storage expiration for db, %s, set to %d days, enableMaxExpiration, %d",  __p,  0x18u);
          if ((v106[23] & 0x80000000) != 0) {
            operator delete(*(void **)v106);
          }
          p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_10182BCE8);
          }
          uint64_t v71 = qword_1019347B8;
          (*(void (**)(__int128 *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(&v104, a1);
          if (v105 >= 0) {
            uint64_t v72 = &v104;
          }
          else {
            uint64_t v72 = (__int128 *)v104;
          }
          int v73 = *(unsigned __int8 *)(a1 + 312);
          *(_DWORD *)v106 = 136315650;
          *(void *)&v106[4] = v72;
          *(_WORD *)&v106[12] = 1024;
          *(_DWORD *)&v106[14] = v28;
          *(_WORD *)&v106[18] = 1024;
          *(_DWORD *)&v106[20] = v73;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v71,  2LL,  "Cold Storage expiration for db, %s, set to %d days, enableMaxExpiration, %d",  v106,  24,  v94);
          uint64_t v75 = v74;
          if (SHIBYTE(v105) < 0) {
            operator delete((void *)v104);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CMHealthColdStorageDb::syncFromHot(CFAbsoluteTime, const std::string &, std::shared_ptr<CLHealthColdStorageStats>)",  "%s\n",  v75);
          if (v75 != __p) {
            free(v75);
          }
          p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
        }

        __int16 v35 = operator new(0x18uLL);
        *(void *)&v106[8] = v35 + 3;
        *(void *)&v106[16] = v35 + 3;
        *(double *)__int16 v35 = (double)v28 * 86400.0;
        v35[1] = 0x7FEFFFFFFFFFFFFFLL;
        *((_BYTE *)v35 + 16) = 1;
        *(void *)v106 = v35;
        int v36 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)v8 + 16LL))(a1 + 72, v106);
        unint64_t v37 = (os_log_s *)qword_1019347B8;
        if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_INFO))
        {
          (*(void (**)(__int128 *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(&v104, a1);
          int v38 = SHIBYTE(v105);
          uint64_t v39 = (__int128 *)v104;
          CFAbsoluteTime v40 = CFAbsoluteTimeGetCurrent();
          int v41 = *(_DWORD *)(a1 + 132);
          double v42 = v40 - Current;
          char v43 = &v104;
          if (v38 < 0) {
            char v43 = v39;
          }
          *(void *)std::stringbuf::string_type __p = 68290306LL;
          *(_WORD *)&__p[8] = 2082;
          *(void *)&__p[10] = "";
          *(_WORD *)&__p[18] = 2082;
          *(void *)&__p[20] = v43;
          __int16 v110 = 2050;
          double v111 = v42;
          __int16 v112 = 1026;
          int v113 = v41;
          __int16 v114 = 1026;
          int v115 = v25;
          __int16 v116 = 1026;
          int v117 = v36;
          _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:copyTablesFromOtherDatabase, tableName:%{public, location:escape_only}s, dura tion:%{public}.5f, recordCountInitial:%{public}d, recordCountAfterSync:%{public}d, recordCou ntAfterPurge:%{public}d}",  __p,  0x38u);
          if (SHIBYTE(v105) < 0) {
            operator delete((void *)v104);
          }
        }

        if (v36 >= 0) {
          int v44 = v25 - v36;
        }
        else {
          int v44 = 0;
        }
        (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(__p, a1);
        if (__p[23] >= 0) {
          __int128 v45 = __p;
        }
        else {
          __int128 v45 = *(_BYTE **)__p;
        }
        uint64_t v46 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v45);
        uint64_t v47 = &OBJC_METACLASS___CLPrivacyManager.vtable;
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
        uint64_t v48 = *a3;
        unint64_t v49 = (std::__shared_weak_count *)a3[1];
        v96[0] = v48;
        v96[1] = v49;
        if (v49)
        {
          p_shared_owners = (unint64_t *)&v49->__shared_owners_;
          do
            unint64_t v51 = __ldxr(p_shared_owners);
          while (__stxr(v51 + 1, p_shared_owners));
        }

        sub_100238460(a1, v96, v25 - *(_DWORD *)(a1 + 132), v44);
        if (v49)
        {
          int v52 = (unint64_t *)&v49->__shared_owners_;
          do
            unint64_t v53 = __ldaxr(v52);
          while (__stlxr(v53 - 1, v52));
          if (!v53)
          {
            ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
            std::__shared_weak_count::__release_weak(v49);
          }
        }

        *(_DWORD *)(a1 + 132) = v36;
        int v54 = -[NSString stringByAppendingString:](v46, "stringByAppendingString:", @"CKSyncStartTime");
        double v95 = 0.0;
        uint64_t v55 = sub_1002F8DDC();
        sub_1002A832C(v55, (uint64_t)v54, &v95);
        if (*(_BYTE *)(a1 + 344))
        {
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_10182BCE8);
          }
          uint64_t v56 = (os_log_s *)qword_1019347B8;
          if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::stringbuf::string_type __p = 134217984;
            *(double *)&__p[4] = a4;
            _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "[CloudKit] marked as dirty, start Time for cloud sync : %f",  __p,  0xCu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(__p, 0x65CuLL);
            if (qword_1019347B0 != -1) {
              dispatch_once(&qword_1019347B0, &stru_10182BCE8);
            }
            LODWORD(v104) = 134217984;
            *(double *)((char *)&v104 + 4) = a4;
            _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  0LL,  "[CloudKit] marked as dirty, start Time for cloud sync : %f",  COERCE_DOUBLE(&v104));
            int v80 = (char *)v79;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CMHealthColdStorageDb::syncFromHot(CFAbsoluteTime, const std::string &, std::shared_ptr<CLHealthCo ldStorageStats>)",  "%s\n",  v79);
            if (v80 != __p) {
              free(v80);
            }
            uint64_t v47 = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
          }

          double v95 = a4;
        }

        else
        {
          a4 = v95;
        }

        __int128 v104 = 0uLL;
        uint64_t v105 = 0LL;
        uint64_t v94 = 0LL;
        sub_1002351B0(a1, (uint64_t)&v104, a2, &v94, a4);
        __int128 v57 = (void *)v104;
        if ((void)v104 != *((void *)&v104 + 1))
        {
          if (*((void *)&v104 + 1) - (void)v104 == 2000LL)
          {
            uint64_t v58 = (os_log_s *)qword_1019347B8;
            if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
            {
              (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(__p, a1);
              uint64_t v59 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
              *(_DWORD *)__uuid_t dst = 136315394;
              *(void *)&__dst[4] = v59;
              *(_WORD *)&__dst[12] = 2048;
              *(void *)&__dst[14] = v94;
              _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "[DB] Max records fetch limit reached for %s, latest record time %f",  __dst,  0x16u);
              if ((__p[23] & 0x80000000) != 0) {
                operator delete(*(void **)__p);
              }
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(__p, 0x65CuLL);
              uint64_t v83 = qword_1019347B8;
              (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(__dst, a1);
              if (__dst[23] >= 0) {
                int v84 = __dst;
              }
              else {
                int v84 = *(_BYTE **)__dst;
              }
              *(_DWORD *)v99 = 136315394;
              *(void *)&v99[4] = v84;
              __int16 v100 = 2048;
              uint64_t v101 = v94;
              LODWORD(v93) = 22;
              _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v83,  0LL,  "[DB] Max records fetch limit reached for %s, latest record time %f",  v99,  v93);
              v86 = v85;
              if ((__dst[23] & 0x80000000) != 0) {
                operator delete(*(void **)__dst);
              }
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CMHealthColdStorageDb::syncFromHot(CFAbsoluteTime, const std::string &, std::shared_ptr<CLHealth ColdStorageStats>)",  "%s\n",  v86);
              if (v86 != __p) {
                free(v86);
              }
            }
          }

          sub_10023862C((uint64_t *)a1, (int **)&v104, a2);
          sub_10000AEE4( a1 + 320,  *(void *)(a1 + 328),  (char *)v104,  *((char **)&v104 + 1),  (uint64_t)(*((void *)&v104 + 1) - v104) >> 2);
          uint64_t v60 = sub_1002F8DDC();
          sub_1002AC820(v60, v54, &v94);
          uint64_t v61 = sub_1002F8DDC();
          (*(void (**)(uint64_t))(*(void *)v61 + 944LL))(v61);
          __int128 v57 = (void *)v104;
        }

        *(_BYTE *)(a1 + 344) = 0;
        if (v57)
        {
          *((void *)&v104 + 1) = v57;
          operator delete(v57);
        }

        if (*(void *)v106)
        {
          *(void *)&v106[8] = *(void *)v106;
          operator delete(*(void **)v106);
        }
      }

      else
      {
        return 112LL;
      }
    }

    else
    {
      return 103LL;
    }
  }

  else
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    uint64_t v16 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = sub_100D8A92C(*(void *)(a1 + 184));
      *(_DWORD *)std::stringbuf::string_type __p = 67109376;
      *(_DWORD *)&__p[4] = v17;
      *(_WORD *)&__p[8] = 1024;
      *(_DWORD *)&__p[10] = sub_100D8A92C(a1 + 72);
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "[DB] One of the DBs is not accessible. Hot: %d, Cold %d",  __p,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182BCE8);
      }
      uint64_t v62 = qword_1019347B8;
      int v63 = sub_100D8A92C(*(void *)(a1 + 184));
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v63;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = sub_100D8A92C(a1 + 72);
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v62,  0LL,  "[DB] One of the DBs is not accessible. Hot: %d, Cold %d",  buf,  14);
      int v65 = (char *)v64;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CMHealthColdStorageDb::syncFromHot(CFAbsoluteTime, const std::string &, std::shared_ptr<CLHealthColdStorageStats>)",  "%s\n",  v64);
      if (v65 != __p) {
        free(v65);
      }
    }

    return 109LL;
  }

  return v18;
}

void sub_100238090( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, void *a35, uint64_t a36, int a37, __int16 a38, char a39, char a40, uint64_t a41, void *__p, uint64_t a43, int a44, __int16 a45, char a46, char a47, uint64_t a48, uint64_t a49, uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (a47 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002381FC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (*(char *)(a2 + 23) < 0)
  {
    **(_BYTE **)a2 = 0;
    *(void *)(a2 + 8) = 0LL;
  }

  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 23) = 0;
  }

  if (*(void *)(result + 200) != *(void *)(result + 208))
  {
    sub_10000CE18((uint64_t)v21);
    uint64_t v3 = *(void *)(v2 + 200);
    uint64_t v4 = *(void *)(v2 + 208) - v3;
    if (v4)
    {
      unint64_t v5 = 0LL;
      unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * (v4 >> 3);
      do
      {
        uint64_t v7 = (unsigned __int8 *)(v3 + 24 * v5);
        signed __int8 v8 = v7[23];
        if (v8 >= 0) {
          uint64_t v9 = v7[23];
        }
        else {
          uint64_t v9 = *((void *)v7 + 1);
        }
        uint64_t v10 = *(unsigned __int8 *)(v2 + 295);
        int v11 = (char)v10;
        if ((v10 & 0x80u) != 0LL) {
          uint64_t v10 = *(void *)(v2 + 280);
        }
        if (v9 != v10) {
          goto LABEL_23;
        }
        if (v11 >= 0) {
          uint64_t v12 = (unsigned __int8 *)(v2 + 272);
        }
        else {
          uint64_t v12 = *(unsigned __int8 **)(v2 + 272);
        }
        if ((v7[23] & 0x80) != 0)
        {
        }

        else if (v7[23])
        {
          double v13 = v7;
          uint64_t v14 = v7[23];
          while (*v13 == *v12)
          {
            ++v13;
            ++v12;
            if (!--v14) {
              goto LABEL_34;
            }
          }

void sub_100238448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_100238460(uint64_t a1, void *a2, int a3, int a4)
{
  if (*a2)
  {
    unint64_t v6 = (uint64_t **)(*a2 + 24LL);
    *(void *)std::string buf = a1 + 224;
    uint64_t v7 = sub_10023BFA4(v6, (const void **)(a1 + 224), (uint64_t)&unk_1012CF090, (__int128 **)buf);
    int v8 = *((_DWORD *)v7 + 15) - a4;
    *((_DWORD *)v7 + 14) += a3;
    *((_DWORD *)v7 + 15) = v8;
  }

  else
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    uint64_t v9 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "[Database] ColdStorageStats not initialized.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182BCE8);
      }
      v12[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  2LL,  "[Database] ColdStorageStats not initialized.",  v12,  2);
      int v11 = (uint8_t *)v10;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CMHealthColdStorageDb::populateStats(std::shared_ptr<CLHealthColdStorageStats>, int, int)",  "%s\n",  v10);
      if (v11 != buf) {
        free(v11);
      }
    }
  }

void sub_10023862C(uint64_t *a1, int **a2, uint64_t a3)
{
  if (sub_100D8A92C(a1 + 9))
  {
    sub_1003C0454(a1[10]);
    sub_10000CE18((uint64_t)buf);
    unint64_t v6 = sub_10000CF44(&v39, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t *))(*a1 + 32))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    uint64_t v10 = sub_10000CF44(v9, (uint64_t)" SET ", 5LL);
    if (byte_101993D07 >= 0) {
      int v11 = &qword_101993CF0;
    }
    else {
      int v11 = (uint64_t *)qword_101993CF0;
    }
    if (byte_101993D07 >= 0) {
      uint64_t v12 = byte_101993D07;
    }
    else {
      uint64_t v12 = unk_101993CF8;
    }
    double v13 = sub_10000CF44(v10, (uint64_t)v11, v12);
    sub_10000CF44(v13, (uint64_t)" = ? WHERE ROWID = ?", 20LL);
    uint64_t v14 = a1[10];
    std::stringbuf::str(&__p, &v40);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v15 = &__p;
    }
    else {
      uint64_t v15 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v14, (char *)v15, &v36);
    uint64_t v16 = v36.__r_.__value_.__r.__words[0];
    v36.__r_.__value_.__r.__words[0] = 0LL;
    int v17 = *a2;
    uint64_t v18 = a2[1];
    if (*a2 != v18)
    {
      do
      {
        std::to_string(&v35, *v17);
        double v19 = std::string::append(&v35, "-");
        __int128 v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
        v36.__r_.__value_.__l.__cap_ = v19->__r_.__value_.__l.__cap_;
        *(_OWORD *)&v36.__r_.__value_.__l.__data_ = v20;
        v19->__r_.__value_.__l.__size_ = 0LL;
        v19->__r_.__value_.__l.__cap_ = 0LL;
        v19->__r_.__value_.__r.__words[0] = 0LL;
        int v21 = *(char *)(a3 + 23);
        if (v21 >= 0) {
          uint64_t v22 = (const std::string::value_type *)a3;
        }
        else {
          uint64_t v22 = *(const std::string::value_type **)a3;
        }
        if (v21 >= 0) {
          std::string::size_type v23 = *(unsigned __int8 *)(a3 + 23);
        }
        else {
          std::string::size_type v23 = *(void *)(a3 + 8);
        }
        uint64_t v24 = std::string::append(&v36, v22, v23);
        __int128 v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__l.__cap_ = v24->__r_.__value_.__l.__cap_;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v25;
        v24->__r_.__value_.__l.__size_ = 0LL;
        v24->__r_.__value_.__l.__cap_ = 0LL;
        v24->__r_.__value_.__r.__words[0] = 0LL;
        std::stringbuf v26 = (sqlite3_stmt *)sub_100019240(v16);
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v27 = &__p;
        }
        else {
          int v27 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
        }
        if (sub_1003BC1F0(v26, 1, (char *)v27))
        {
          int v28 = (sqlite3_stmt *)sub_100019240(v16);
          if (sub_1003C28BC(v28, 2, *v17))
          {
            uint64_t v29 = a1[10];
            __int16 v30 = (sqlite3_stmt *)sub_100019240(v16);
            sub_1003BB2BC(v29, v30);
          }
        }

        ++v17;
      }

      while (v17 != v18);
    }

    sub_1003C05BC(a1[10]);
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
    }
    uint64_t v39 = v31;
    std::streambuf::~streambuf(&v40);
    std::ios::~ios(&v41);
  }

  else
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    std::stringbuf::string_type v32 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_ERROR,  "[DB] Unable to update UUID on records.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182BCE8);
      }
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[DB] Unable to update UUID on records.",  &__p,  2);
      int v34 = (uint8_t *)v33;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CMHealthColdStorageDb::updateRecordIDForRowIDs(const std::vector<int> &, const std::string &)",  "%s\n",  v33);
      if (v34 != buf) {
        free(v34);
      }
    }
  }

void sub_100238A74( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, void *__p, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, char a32)
{
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 8LL))(v32);
  }
  sub_1011F8850((uint64_t)&a32);
  _Unwind_Resume(a1);
}

BOOL sub_100238B18(uint64_t a1)
{
  return *(void *)(a1 + 160) != 0LL;
}

uint64_t sub_100238B28(uint64_t a1, char *a2, void *a3, NSData **a4)
{
  if (a3) {
    *a3 = 0LL;
  }
  if (!*(void *)(a1 + 160)) {
    return 0LL;
  }
  if (!sub_100D8A92C(a1 + 72))
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    __int128 v45 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
    {
      (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(&__p, a1);
      uint64_t v46 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &__p
          : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v46;
      __int16 v81 = 2080;
      *(void *)__int16 v82 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "[DB] getRecordDataForID since db is not accessible for %s, recordID=%s",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182BCE8);
      }
      uint64_t v53 = qword_1019347B8;
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(buf, a1);
      if (v82[9] >= 0) {
        int v54 = buf;
      }
      else {
        int v54 = *(_BYTE **)buf;
      }
      LODWORD(v73.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)v73.__r_.__value_.__r.__words + 4) = (std::string::size_type)v54;
      WORD2(v73.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v73.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a2;
      uint64_t v55 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v53,  16LL,  "[DB] getRecordDataForID since db is not accessible for %s, recordID=%s",  (const char *)&v73,  22);
      if ((v82[9] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CMHealthColdStorageDb::getRecordDataForID(const char *, NSData **, NSData **)",  "%s\n",  (const char *)v55);
      if (v55 != &__p) {
        free(v55);
      }
    }

    return 0LL;
  }

  sub_10000CE18((uint64_t)buf);
  int v8 = sub_10000CF44(&v82[2], (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  int v11 = sub_10000CF44(v8, (uint64_t)p_p, size);
  uint64_t v12 = sub_10000CF44(v11, (uint64_t)" WHERE ", 7LL);
  if (byte_101993D07 >= 0) {
    double v13 = &qword_101993CF0;
  }
  else {
    double v13 = (uint64_t *)qword_101993CF0;
  }
  if (byte_101993D07 >= 0) {
    uint64_t v14 = byte_101993D07;
  }
  else {
    uint64_t v14 = unk_101993CF8;
  }
  uint64_t v15 = sub_10000CF44(v12, (uint64_t)v13, v14);
  sub_10000CF44(v15, (uint64_t)" = ?", 4LL);
  uint64_t v16 = *(void *)(a1 + 80);
  std::stringbuf::str(&__p, &v83);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v17 = &__p;
  }
  else {
    int v17 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v16, (char *)v17, &v73);
  uint64_t v18 = v73.__r_.__value_.__r.__words[0];
  std::string::size_type v68 = v73.__r_.__value_.__r.__words[0];
  v73.__r_.__value_.__r.__words[0] = 0LL;
  if ((char)__p.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    uint64_t v18 = v68;
  }

  double v19 = (sqlite3_stmt *)sub_100019240(v18);
  BOOL v20 = sub_1003BC1F0(v19, 1, a2);
  if (!v20)
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    uint64_t v48 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEBUG))
    {
      (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(&__p, a1);
      unint64_t v49 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &__p
          : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      LODWORD(v73.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)v73.__r_.__value_.__r.__words + 4) = (std::string::size_type)v49;
      WORD2(v73.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v73.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a2;
      _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEBUG,  "[DB] getRecordDataForID failed for %s, recordID=%s",  (uint8_t *)&v73,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182BCE8);
      }
      uint64_t v56 = qword_1019347B8;
      (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(&v73, a1);
      if ((v73.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v57 = &v73;
      }
      else {
        __int128 v57 = (std::stringbuf::string_type *)v73.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 v69 = 136315394;
      *(void *)&v69[4] = v57;
      __int16 v70 = 2080;
      uint64_t v71 = a2;
      uint64_t v58 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v56,  2LL,  "[DB] getRecordDataForID failed for %s, recordID=%s",  v69,  22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CMHealthColdStorageDb::getRecordDataForID(const char *, NSData **, NSData **)",  "%s\n",  (const char *)v58);
      if (v58 != &__p) {
        free(v58);
      }
    }

    goto LABEL_83;
  }

  id v21 = [*(id *)(a1 + 160) convertStatementToDataBlobs:&v68];
  uint64_t v22 = v21;
  if (!v21 || (uint64_t v66 = v21, ![v21 count]))
  {
    char v50 = 0;
    goto LABEL_85;
  }

  if (a4)
  {
    sub_10000CE18((uint64_t)&__p);
    std::string::size_type v23 = sub_10000CF44(&__p.__r_.__value_.__l.__cap_, (uint64_t)"SELECT * FROM ", 14LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(&v73, a1);
    if ((v73.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v24 = &v73;
    }
    else {
      uint64_t v24 = (std::stringbuf::string_type *)v73.__r_.__value_.__r.__words[0];
    }
    if ((v73.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v25 = v73.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t v25 = v73.__r_.__value_.__l.__size_;
    }
    std::stringbuf v26 = sub_10000CF44(v23, (uint64_t)v24, v25);
    int v27 = sub_10000CF44(v26, (uint64_t)" WHERE ", 7LL);
    if (byte_101993D07 >= 0) {
      int v28 = &qword_101993CF0;
    }
    else {
      int v28 = (uint64_t *)qword_101993CF0;
    }
    if (byte_101993D07 >= 0) {
      uint64_t v29 = byte_101993D07;
    }
    else {
      uint64_t v29 = unk_101993CF8;
    }
    __int16 v30 = sub_10000CF44(v27, (uint64_t)v28, v29);
    uint64_t v31 = sub_10000CF44(v30, (uint64_t)" = ", 3LL);
    uint64_t v32 = sub_10000CF44(v31, (uint64_t)"", 1LL);
    size_t v33 = strlen(a2);
    int v34 = sub_10000CF44(v32, (uint64_t)a2, v33);
    sub_10000CF44(v34, (uint64_t)"", 1LL);
    uint64_t v35 = *(void *)(a1 + 80);
    std::stringbuf::str(&v73, &v78);
    if ((v73.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string v36 = &v73;
    }
    else {
      std::string v36 = (std::stringbuf::string_type *)v73.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v35, (char *)v36, &v67);
    uint64_t v37 = v67;
    *(void *)__int128 v69 = v67;
    uint64_t v67 = 0LL;
    *a4 = sub_1002355B4(a1, (uint64_t *)v69);
    if (v37) {
      (*(void (**)(uint64_t))(*(void *)v37 + 8LL))(v37);
    }
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words
    __p.__r_.__value_.__l.__cap_ = v38;
    std::streambuf::~streambuf(&v78);
    std::ios::~ios(&v79);
  }

  if ((unint64_t)[v22 count] >= 2)
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    uint64_t v39 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_FAULT))
    {
      id v40 = [v22 count];
      (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(&v73, a1);
      int v41 = (char)v73.__r_.__value_.__s.__size_;
      std::string::size_type v42 = v73.__r_.__value_.__r.__words[0];
      char v43 = (std::locale::__imp *)[v66 description];
      int v44 = &v73;
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315906;
      if (v41 < 0) {
        int v44 = (std::stringbuf::string_type *)v42;
      }
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2048;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v40;
      HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
      v78.__vftable = (std::stringbuf_vtbl *)v44;
      LOWORD(v78.__loc_.__locale_) = 2112;
      *(std::locale::__imp **)((char *)&v78.__loc_.__locale_ + 2) = v43;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_FAULT,  "[DB] Something is not right, recordID should be unique for each table, recordId=%s, record count=%lu, table %s blobs %@",  (uint8_t *)&__p,  0x2Au);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182BCE8);
      }
      uint64_t v59 = qword_1019347B8;
      id v60 = [v66 count];
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(v69, a1);
      int v61 = v72;
      uint64_t v62 = *(_BYTE **)v69;
      id v63 = [v66 description];
      uint64_t v64 = v69;
      LODWORD(v73.__r_.__value_.__l.__data_) = 136315906;
      if (v61 < 0) {
        uint64_t v64 = v62;
      }
      *(std::string::size_type *)((char *)v73.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      WORD2(v73.__r_.__value_.__r.__words[1]) = 2048;
      *(std::string::size_type *)((char *)&v73.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v60;
      HIWORD(v73.__r_.__value_.__r.__words[2]) = 2080;
      unint64_t v74 = v64;
      __int16 v75 = 2112;
      id v76 = v63;
      int v65 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v59,  17LL,  "[DB] Something is not right, recordID should be unique for each table, reco rdId=%s, record count=%lu, table %s blobs %@",  &v73,  42);
      if (v72 < 0) {
        operator delete(*(void **)v69);
      }
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CMHealthColdStorageDb::getRecordDataForID(const char *, NSData **, NSData **)",  "%s\n",  (const char *)v65);
      if (v65 != &__p) {
        free(v65);
      }
      if (!a3) {
        goto LABEL_83;
      }
      goto LABEL_62;
    }
  }

  if (a3) {
LABEL_62:
  }
    *a3 = [v66 firstObject];
LABEL_83:
  char v50 = 1;
LABEL_85:
  std::string::size_type v51 = v68;
  std::string::size_type v68 = 0LL;
  if (v51) {
    (*(void (**)(std::string::size_type))(*(void *)v51 + 8LL))(v51);
  }
  *(void *)&v82[2] = v52;
  std::streambuf::~streambuf(&v83);
  std::ios::~ios(&v84);
  if ((v50 & 1) == 0) {
    return 1LL;
  }
  return v20;
}

void sub_100239578( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 8LL))(a14);
  }
  sub_1011F8850((uint64_t)&STACK[0x6E0]);
  _Unwind_Resume(a1);
}

uint64_t sub_10023967C(uint64_t a1, void *a2, void *a3, NSData **a4)
{
  return sub_100238B28(a1, (char *)objc_msgSend(objc_msgSend(a2, "recordName"), "UTF8String"), a3, a4);
}

uint64_t sub_1002396C4(void *a1)
{
  uint64_t v2 = sub_10000CF44(&v21, (uint64_t)"UPDATE ", 7LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 32LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  unint64_t v5 = sub_10000CF44(v2, (uint64_t)p_p, size);
  unint64_t v6 = sub_10000CF44(v5, (uint64_t)" SET ", 5LL);
  if (byte_101993CEF >= 0) {
    uint64_t v7 = &qword_101993CD8;
  }
  else {
    uint64_t v7 = (uint64_t *)qword_101993CD8;
  }
  if (byte_101993CEF >= 0) {
    uint64_t v8 = byte_101993CEF;
  }
  else {
    uint64_t v8 = unk_101993CE0;
  }
  uint64_t v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
  uint64_t v10 = sub_10000CF44(v9, (uint64_t)" = ? WHERE ", 11LL);
  if (byte_101993D07 >= 0) {
    int v11 = &qword_101993CF0;
  }
  else {
    int v11 = (uint64_t *)qword_101993CF0;
  }
  if (byte_101993D07 >= 0) {
    uint64_t v12 = byte_101993D07;
  }
  else {
    uint64_t v12 = unk_101993CF8;
  }
  double v13 = sub_10000CF44(v10, (uint64_t)v11, v12);
  sub_10000CF44(v13, (uint64_t)" = ?", 4LL);
  uint64_t v14 = a1[10];
  std::stringbuf::str(&__p, &v22);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v15 = &__p;
  }
  else {
    uint64_t v15 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  a1[44] = sub_1003BF158(v14, (char *)v15);
  a1[45] = v16;
  *(void *)((char *)v20
  uint64_t v21 = v17;
  std::streambuf::~streambuf(&v22);
  return std::ios::~ios(&v23);
}

void sub_100239880( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_1002398B8(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = a1;
  sub_100222B94(v15, (uint64_t)"CMHealthColdStorageDb.updateLocalSystemFieldsForRecord", 0);
  if (!sub_100B14D64((void *)(v5 + 352))) {
    sub_1002396C4((void *)v5);
  }
  if (!sub_100B14D64((void *)(v5 + 352)))
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    uint64_t v10 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "[DB] SQL update statement is invalid.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182BCE8);
      }
      v14[0] = 0;
      double v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[DB] SQL update statement is invalid.",  v14,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CMHealthColdStorageDb::updateLocalSystemFieldsForRecord(CKRecordID *, NSData *)",  "%s\n",  v13);
    }

    goto LABEL_14;
  }

  sub_100B14CF8((uint64_t *)(v5 + 352), buf);
  if (!*(void *)buf)
  {
LABEL_14:
    sub_1001BA1BC(v15);
LABEL_15:
    LOBYTE(v5) = 0;
    return v5 & 1;
  }

  unint64_t v6 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
  if (sub_1003C2F58(v6, 1, a3)
    && (uint64_t v7 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf),
        sub_1003BC1F0(v7, 2, (char *)objc_msgSend(objc_msgSend(a2, "recordName"), "UTF8String"))))
  {
    uint64_t v5 = *(void *)(v5 + 80);
    uint64_t v8 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
    LOBYTE(v5) = sub_1003BB2BC(v5, v8);
    char v9 = 0;
  }

  else
  {
    char v9 = 1;
  }

  uint64_t v12 = *(void *)buf;
  *(void *)std::string buf = 0LL;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
  }
  sub_1001BA1BC(v15);
  if ((v9 & 1) != 0) {
    goto LABEL_15;
  }
  return v5 & 1;
}

void sub_100239B48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100239B8C(uint64_t result)
{
  *(_BYTE *)(result + 344) = 1;
  return result;
}

void sub_100239B98(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1010DDBC0(v99, (char *)objc_msgSend(objc_msgSend(objc_msgSend(a2, "recordID"), "recordName"), "UTF8String"));
    if (*(void *)(a1 + 160))
    {
      sub_100222B94(v98, (uint64_t)"CMHealthColdStorageDb.handleFetchedRecord", 0);
      (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 32LL))(v96, a1);
      if (v97 >= 0) {
        uint64_t v4 = v96;
      }
      else {
        uint64_t v4 = (void **)v96[0];
      }
      if ((sub_1003B747C(*(void *)(a1 + 80), v4) & 1) != 0 || (sub_10023589C(a1) & 1) != 0)
      {
        sub_1010DDBC0(&v95, (char *)objc_msgSend(objc_msgSend(*(id *)(a1 + 160), "columns"), "UTF8String"));
        sub_10000CE18((uint64_t)v91);
        __uuid_t dst = 0LL;
        uint64_t v88 = 0LL;
        unint64_t v90 = 0LL;
        sub_10023A774(v84, &v95, 8);
        memset(&v83, 0, sizeof(v83));
        for (int i = 1; ; ++i)
        {
          unint64_t v6 = sub_10023A858(v84, &v83, 0x2Cu);
          if ((*((_BYTE *)v6 + *(void *)(*v6 - 24LL) + 32) & 5) != 0) {
            break;
          }
          sub_10000CF44(&v92, (uint64_t)"?,", 2LL);
          uint64_t v7 = __dst;
          if ((unint64_t)__dst >= v90)
          {
            char v9 = (void *)sub_10112142C(&v88, (__int128 *)&v83);
          }

          else
          {
            if ((char)v83.__r_.__value_.__s.__size_ < 0)
            {
              sub_1010DD48C(__dst, v83.__r_.__value_.__l.__data_, v83.__r_.__value_.__l.__size_);
            }

            else
            {
              __int128 v8 = *(_OWORD *)&v83.__r_.__value_.__l.__data_;
              *((void *)__dst + 2) = v83.__r_.__value_.__l.__cap_;
              _OWORD *v7 = v8;
            }

            char v9 = (char *)v7 + 24;
          }

          __uuid_t dst = v9;
        }

        sub_10000CF44(&v92, (uint64_t)"?,?", 3LL);
        std::stringbuf::str(&v82, &v93);
        sub_10000CE18((uint64_t)v78);
        uint64_t v77 = 0LL;
        if (sub_100238B28( a1,  (char *)objc_msgSend(objc_msgSend(objc_msgSend(a2, "recordID"), "recordName"), "UTF8String"),  &v77,  0))
        {
          if (v77)
          {
            uint64_t v10 = sub_10000CF44(&v79, (uint64_t)"UPDATE ", 7LL);
            (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(__p, a1);
            if ((__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
              int v11 = __p;
            }
            else {
              int v11 = (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
            }
            if ((__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
              uint64_t size = __p[0].__r_.__value_.__s.__size_;
            }
            else {
              uint64_t size = __p[0].__r_.__value_.__l.__size_;
            }
            double v13 = sub_10000CF44(v10, (uint64_t)v11, size);
            sub_10000CF44(v13, (uint64_t)" SET ", 5LL);
            uint64_t v14 = v88;
            for (uint64_t j = __dst; (void *)v14 != j; v14 += 24LL)
            {
              int v16 = *(char *)(v14 + 23);
              if (v16 >= 0) {
                uint64_t v17 = v14;
              }
              else {
                uint64_t v17 = *(void *)v14;
              }
              if (v16 >= 0) {
                uint64_t v18 = *(unsigned __int8 *)(v14 + 23);
              }
              else {
                uint64_t v18 = *(void *)(v14 + 8);
              }
              double v19 = sub_10000CF44(&v79, v17, v18);
              sub_10000CF44(v19, (uint64_t)"=?, ", 4LL);
            }

            if (byte_101993D07 >= 0) {
              BOOL v20 = &qword_101993CF0;
            }
            else {
              BOOL v20 = (uint64_t *)qword_101993CF0;
            }
            if (byte_101993D07 >= 0) {
              uint64_t v21 = byte_101993D07;
            }
            else {
              uint64_t v21 = unk_101993CF8;
            }
            std::stringbuf v22 = sub_10000CF44(&v79, (uint64_t)v20, v21);
            uint64_t v23 = sub_10000CF44(v22, (uint64_t)"=?, ", 4LL);
            if (byte_101993CEF >= 0) {
              uint64_t v24 = &qword_101993CD8;
            }
            else {
              uint64_t v24 = (uint64_t *)qword_101993CD8;
            }
            if (byte_101993CEF >= 0) {
              uint64_t v25 = byte_101993CEF;
            }
            else {
              uint64_t v25 = unk_101993CE0;
            }
            std::stringbuf v26 = sub_10000CF44(v23, (uint64_t)v24, v25);
            sub_10000CF44(v26, (uint64_t)"=?", 2LL);
            int v27 = sub_10000CF44(&v79, (uint64_t)" WHERE ", 7LL);
            if (byte_101993D07 >= 0) {
              int v28 = &qword_101993CF0;
            }
            else {
              int v28 = (uint64_t *)qword_101993CF0;
            }
            if (byte_101993D07 >= 0) {
              uint64_t v29 = byte_101993D07;
            }
            else {
              uint64_t v29 = unk_101993CF8;
            }
            __int16 v30 = sub_10000CF44(v27, (uint64_t)v28, v29);
            uint64_t v31 = sub_10000CF44(v30, (uint64_t)" = ", 3LL);
            uint64_t v32 = sub_10000CF44(v31, (uint64_t)"", 1LL);
            size_t v33 = (const char *)objc_msgSend(objc_msgSend(objc_msgSend(a2, "recordID"), "recordName"), "UTF8String");
            size_t v34 = strlen(v33);
            uint64_t v35 = sub_10000CF44(v32, (uint64_t)v33, v34);
            sub_10000CF44(v35, (uint64_t)"", 1LL);
          }

          else
          {
            int v44 = sub_10000CF44(&v79, (uint64_t)"INSERT INTO ", 12LL);
            (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t))(*(void *)a1 + 32LL))(__p, a1);
            if ((__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
              __int128 v45 = __p;
            }
            else {
              __int128 v45 = (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
            }
            if ((__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
              uint64_t v46 = __p[0].__r_.__value_.__s.__size_;
            }
            else {
              uint64_t v46 = __p[0].__r_.__value_.__l.__size_;
            }
            uint64_t v47 = sub_10000CF44(v44, (uint64_t)v45, v46);
            uint64_t v48 = sub_10000CF44(v47, (uint64_t)"( ", 2LL);
            if ((v95.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              unint64_t v49 = &v95;
            }
            else {
              unint64_t v49 = (std::string *)v95.__r_.__value_.__r.__words[0];
            }
            if ((v95.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              uint64_t v50 = v95.__r_.__value_.__s.__size_;
            }
            else {
              uint64_t v50 = v95.__r_.__value_.__l.__size_;
            }
            std::string::size_type v51 = sub_10000CF44(v48, (uint64_t)v49, v50);
            uint64_t v52 = sub_10000CF44(v51, (uint64_t)",", 1LL);
            if (byte_101993D07 >= 0) {
              uint64_t v53 = &qword_101993CF0;
            }
            else {
              uint64_t v53 = (uint64_t *)qword_101993CF0;
            }
            if (byte_101993D07 >= 0) {
              uint64_t v54 = byte_101993D07;
            }
            else {
              uint64_t v54 = unk_101993CF8;
            }
            uint64_t v55 = sub_10000CF44(v52, (uint64_t)v53, v54);
            uint64_t v56 = sub_10000CF44(v55, (uint64_t)",", 1LL);
            if (byte_101993CEF >= 0) {
              __int128 v57 = &qword_101993CD8;
            }
            else {
              __int128 v57 = (uint64_t *)qword_101993CD8;
            }
            if (byte_101993CEF >= 0) {
              uint64_t v58 = byte_101993CEF;
            }
            else {
              uint64_t v58 = unk_101993CE0;
            }
            uint64_t v59 = sub_10000CF44(v56, (uint64_t)v57, v58);
            id v60 = sub_10000CF44(v59, (uint64_t)") VALUES(", 12LL);
            if ((v82.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              int v61 = &v82;
            }
            else {
              int v61 = (std::stringbuf::string_type *)v82.__r_.__value_.__r.__words[0];
            }
            if ((v82.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              uint64_t v62 = v82.__r_.__value_.__s.__size_;
            }
            else {
              uint64_t v62 = v82.__r_.__value_.__l.__size_;
            }
            id v63 = sub_10000CF44(v60, (uint64_t)v61, v62);
            sub_10000CF44(v63, (uint64_t)")", 1LL);
          }

          uint64_t v64 = *(void *)(a1 + 80);
          std::stringbuf::str(__p, &v80);
          if ((__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
            int v65 = __p;
          }
          else {
            int v65 = (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
          }
          sub_1003C0D54(v64, (char *)v65, &v76);
          *(void *)uint64_t v101 = v76;
          uint64_t v76 = 0LL;
          id v66 = +[CMHealthColdStorageUtils getSystemFieldsFromCKRecord:]( &OBJC_CLASS___CMHealthColdStorageUtils,  "getSystemFieldsFromCKRecord:",  a2);
          if (objc_msgSend( *(id *)(a1 + 160),  "convertDataBlob:toBoundStatement:",  objc_msgSend( objc_msgSend(a2, "encryptedValues"),  "objectForKey:",  objc_msgSend(*(id *)(a1 + 160), "dataFieldKey")),  v101))
          {
            uint64_t v67 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v101);
            if (sub_1003C2F58(v67, i + 1, v66))
            {
              std::string::size_type v68 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v101);
              __int128 v69 = v100 >= 0 ? (char *)v99 : (char *)v99[0];
              if (sub_1003BC1F0(v68, i, v69))
              {
                uint64_t v70 = *(void *)(a1 + 80);
                uint64_t v71 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v101);
                sub_1003BB2BC(v70, v71);
              }
            }
          }

          uint64_t v72 = *(void *)v101;
          *(void *)uint64_t v101 = 0LL;
          if (v72) {
            (*(void (**)(uint64_t))(*(void *)v72 + 8LL))(v72);
          }
        }

        else
        {
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_10182BCE8);
          }
          std::string v36 = (os_log_s *)qword_1019347B8;
          if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
          {
            uint64_t v37 = v99;
            if (v100 < 0) {
              uint64_t v37 = (void **)v99[0];
            }
            std::string::size_type v38 = v96;
            if (v97 < 0) {
              std::string::size_type v38 = (void **)v96[0];
            }
            LODWORD(__p[0].__r_.__value_.__l.__data_) = 136315394;
            *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v37;
            WORD2(__p[0].__r_.__value_.__r.__words[1]) = 2080;
            *(std::string::size_type *)((char *)&__p[0].__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v38;
            _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_ERROR,  "[DB] Unable to verify if fetched record exists, ignore record=%s, for table %s",  (uint8_t *)__p,  0x16u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(__p, 0x65CuLL);
            if (qword_1019347B0 != -1) {
              dispatch_once(&qword_1019347B0, &stru_10182BCE8);
            }
            uint64_t v39 = v99;
            if (v100 < 0) {
              uint64_t v39 = (void **)v99[0];
            }
            id v40 = v96;
            if (v97 < 0) {
              id v40 = (void **)v96[0];
            }
            *(_DWORD *)uint64_t v101 = 136315394;
            *(void *)&v101[4] = v39;
            __int16 v102 = 2080;
            uint64_t v103 = v40;
            int v41 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[DB] Unable to verify if fetched record exists, ignore record=%s, for table %s",  v101,  22);
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CMHealthColdStorageDb::handleFetchedRecord(CKRecord *)",  "%s\n",  (const char *)v41);
            if (v41 != __p) {
              free(v41);
            }
          }
        }

        *(void *)((char *)v78
                              - 24LL)) = v74;
        uint64_t v79 = v75;
        std::streambuf::~streambuf(&v80);
        std::ios::~ios(&v81);
        *(void (__cdecl ***)(std::istringstream *__hidden))((char *)v84
        if (v86 < 0) {
          operator delete((void *)v85[8]);
        }
        std::streambuf::~streambuf(v85);
        std::ios::~ios(&v87);
        __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v88;
        sub_1000129D4((void ***)__p);
        v91[0] = v73;
        *(void *)((char *)v91 + *(void *)(v73 - 24)) = v74;
        uint64_t v92 = v75;
        std::streambuf::~streambuf(&v93);
        std::ios::~ios(&v94);
      }

      else
      {
        if (qword_1019347B0 != -1) {
          dispatch_once(&qword_1019347B0, &stru_10182BCE8);
        }
        std::string::size_type v42 = (os_log_s *)qword_1019347B8;
        if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
        {
          LOWORD(__p[0].__r_.__value_.__l.__data_) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_ERROR,  "[DB] unable to create table when handling fetched records",  (uint8_t *)__p,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(__p, 0x65CuLL);
          if (qword_1019347B0 != -1) {
            dispatch_once(&qword_1019347B0, &stru_10182BCE8);
          }
          LOWORD(v91[0]) = 0;
          char v43 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[DB] unable to create table when handling fetched records",  v91,  2);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CMHealthColdStorageDb::handleFetchedRecord(CKRecord *)",  "%s\n",  (const char *)v43);
          if (v43 != __p) {
            free(v43);
          }
        }
      }

      if (v97 < 0) {
        operator delete(v96[0]);
      }
      sub_1001BA1BC(v98);
    }

    if (v100 < 0) {
      operator delete(v99[0]);
    }
  }

void sub_10023A634(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x3D7]) < 0) {
    operator delete((void *)STACK[0x3C0]);
  }
  sub_1001BA1BC((id *)&STACK[0x3D8]);
  if (SLOBYTE(STACK[0x3FF]) < 0) {
    operator delete((void *)STACK[0x3E8]);
  }
  _Unwind_Resume(a1);
}

void (__cdecl ***sub_10023A774( void (__cdecl ***a1)(std::istringstream *__hidden this), const std::string *a2, int a3))(std::istringstream *__hidden this)
{
  uint64_t v6 = (uint64_t)(a1 + 2);
  *a1 = v7;
  *(void *)((char *)*(v7 - 3) + (void)a1) = v8;
  a1[1] = 0LL;
  char v9 = (std::ios_base *)((char *)*(*a1 - 3) + (void)a1);
  std::ios_base::init(v9, a1 + 2);
  v9[1].__vftable = 0LL;
  v9[1].__fmtflags_ = -1;
  sub_10023BE04(v6, a2, a3 | 8);
  return a1;
}

void sub_10023A830(_Unwind_Exception *a1)
{
}

void *sub_10023A858(void *a1, std::string *a2, unsigned __int8 a3)
{
  if (!v11) {
    return a1;
  }
  if ((char)a2->__r_.__value_.__s.__size_ < 0)
  {
    *a2->__r_.__value_.__l.__data_ = 0;
    a2->__r_.__value_.__l.__size_ = 0LL;
  }

  else
  {
    a2->__r_.__value_.__s.__data_[0] = 0;
    a2->__r_.__value_.__s.__size_ = 0;
  }

  uint64_t v6 = 0LL;
  while (1)
  {
    uint64_t v7 = *(void **)((char *)a1 + *(void *)(*a1 - 24LL) + 40);
    __int128 v8 = (_BYTE *)v7[3];
    if (v8 != (_BYTE *)v7[4])
    {
      v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }

    LODWORD(v7) = (*(uint64_t (**)(void *))(*v7 + 80LL))(v7);
    if ((_DWORD)v7 == -1) {
      break;
    }
LABEL_9:
    if (v7 == a3)
    {
      int v9 = 0;
      goto LABEL_17;
    }

    std::string::push_back(a2, (std::string::value_type)v7);
    --v6;
    if ((char)a2->__r_.__value_.__s.__size_ < 0 && a2->__r_.__value_.__l.__size_ == 0x7FFFFFFFFFFFFFF7LL)
    {
      int v9 = 4;
      goto LABEL_17;
    }
  }

  if (v6) {
    int v9 = 2;
  }
  else {
    int v9 = 6;
  }
LABEL_17:
  std::ios_base::clear( (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)),  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 32) | v9);
  return a1;
}

void sub_10023A984(void *a1)
{
  uint64_t v2 = *v1;
  *(_DWORD *)((char *)v1 + *(void *)(*v1 - 24LL) + 32) |= 1u;
  if ((*((_BYTE *)v1 + *(void *)(v2 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x10023A950LL);
  }

  __cxa_rethrow();
}

void sub_10023A9C8(_Unwind_Exception *a1)
{
}

uint64_t sub_10023A9DC(uint64_t a1)
{
  uint64_t v3 = a1 + 16;
  std::streambuf::~streambuf(v3);
  std::ios::~ios(a1 + 120);
  return a1;
}

BOOL sub_10023AA60(uint64_t a1)
{
  uint64_t v2 = a1 + 112;
  uint64_t v3 = a1 + 72;
  (*(void (**)(uint64_t))(*(void *)(a1 + 112) + 16LL))(a1 + 112);
  if (sub_100D8A92C(v3))
  {
    double Current = CFAbsoluteTimeGetCurrent();
    if (qword_101993D38 != -1) {
      dispatch_once(&qword_101993D38, &stru_10182BD08);
    }
    int v5 = dword_101993D30;
    int v6 = sub_1003C1EC0(*(void *)(a1 + 80), dword_101993D30);
    BOOL v7 = v6 == 0;
    double v8 = CFAbsoluteTimeGetCurrent();
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182BCE8);
    }
    int v9 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134349568;
      double v20 = v8 - Current;
      __int16 v21 = 2050;
      uint64_t v22 = v6;
      __int16 v23 = 1026;
      int v24 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "[DB] Time taken for incrementalVacuum, %{public}.2f ReduceFreePagesStatus, %{public}lu, incrementalVacuumPageLimit : %{public}d",  buf,  0x1Cu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182BCE8);
      }
      int v13 = 134349568;
      double v14 = v8 - Current;
      __int16 v15 = 2050;
      uint64_t v16 = v6;
      __int16 v17 = 1026;
      int v18 = v5;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  0LL,  "[DB] Time taken for incrementalVacuum, %{public}.2f ReduceFreePagesStatus, %{public}lu, incrementalVacuumPageLimit : %{public}d",  &v13,  28);
      char v11 = (uint8_t *)v10;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CMHealthColdStorageDb::performIncrementalDbVacuum()", "%s\n", v10);
      if (v11 != buf) {
        free(v11);
      }
    }
  }

  else
  {
    BOOL v7 = 0LL;
  }

  (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  return v7;
}

void sub_10023ACFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_10023AD34(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10023C0DC(a1);
  operator delete(v1);
}

char *sub_10023AD48@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[247] < 0) {
    return (char *)sub_1010DD48C((_BYTE *)a2, *((void **)result + 28), *((void *)result + 29));
  }
  *(_OWORD *)a2 = *((_OWORD *)result + 14);
  *(void *)(a2 + 16) = *((void *)result + 30);
  return result;
}

uint64_t sub_10023AD74(uint64_t a1)
{
  return sub_10023C0DC(a1 - 72);
}

void sub_10023AD7C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10023C0DC(a1 - 72);
  operator delete(v1);
}

char *sub_10023AD94@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[175] < 0) {
    return (char *)sub_1010DD48C((_BYTE *)a2, *((void **)result + 19), *((void *)result + 20));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 152);
  *(void *)(a2 + 16) = *((void *)result + 21);
  return result;
}

void sub_10023ADC0(id a1)
{
  qword_1019347B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "HealthColdStorage");
}

void sub_10023ADEC(id a1)
{
  dword_101993D30 = v2;
}

unsigned __int8 *sub_10023AE2C(unsigned __int8 *a1, const char *a2, _DWORD *a3, unsigned __int8 a4)
{
  *a1 = 0;
  *((_DWORD *)a1 + 1) = *a3;
  int v6 = a1 + 4;
  a1[8] = a4;
  uint64_t v7 = sub_1006E27E8();
  sub_100413284(v7, buf);
  *a1 = sub_1002A7CB0(*(uint64_t *)buf, a2, v6);
  double v8 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    int v9 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  sub_10000CE18((uint64_t)v33);
  std::ostream::operator<<(&v34, *v6);
  if (!a1[8])
  {
    if (*a1)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182BD28);
      }
      __int16 v15 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = *a1;
        std::stringbuf::str((std::stringbuf::string_type *)v37, &v35);
        __int16 v17 = v37[23] >= 0 ? v37 : *(_BYTE **)v37;
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v16;
        __int16 v39 = 2080;
        id v40 = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "motion default,%s,set,%d,value,%s",  buf,  0x1Cu);
        if ((v37[23] & 0x80000000) != 0) {
          operator delete(*(void **)v37);
        }
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_53;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182BD28);
      }
      uint64_t v18 = qword_1019344B8;
      int v19 = *a1;
      std::stringbuf::str(&v32, &v35);
      if ((v32.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        double v20 = &v32;
      }
      else {
        double v20 = (std::stringbuf::string_type *)v32.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t v37 = 136315650;
      *(void *)&v37[4] = a2;
      *(_WORD *)&v37[12] = 1024;
      *(_DWORD *)&v37[14] = v19;
      *(_WORD *)&v37[18] = 2080;
      *(void *)&v37[20] = v20;
      double v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v18,  0LL,  "motion default,%s,set,%d,value,%s",  v37,  28,  v32.__r_.__value_.__l.__data_);
    }

    else
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182BD28);
      }
      int v24 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        int v25 = *a1;
        std::stringbuf::str((std::stringbuf::string_type *)v37, &v35);
        std::stringbuf v26 = v37[23] >= 0 ? v37 : *(_BYTE **)v37;
        *(_DWORD *)std::string buf = 136315650;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v25;
        __int16 v39 = 2080;
        id v40 = v26;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_INFO,  "motion default,%s,set,%d,value,%s",  buf,  0x1Cu);
        if ((v37[23] & 0x80000000) != 0) {
          operator delete(*(void **)v37);
        }
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_53;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182BD28);
      }
      uint64_t v29 = qword_1019344B8;
      int v30 = *a1;
      std::stringbuf::str(&v32, &v35);
      if ((v32.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v31 = &v32;
      }
      else {
        uint64_t v31 = (std::stringbuf::string_type *)v32.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t v37 = 136315650;
      *(void *)&v37[4] = a2;
      *(_WORD *)&v37[12] = 1024;
      *(_DWORD *)&v37[14] = v30;
      *(_WORD *)&v37[18] = 2080;
      *(void *)&v37[20] = v31;
      double v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v29,  1LL,  "motion default,%s,set,%d,value,%s",  v37,  28,  v32.__r_.__value_.__l.__data_);
    }

    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLMotionDefaultsWrite<int>::CLMotionDefaultsWrite(const char *, const T &, const BOOL) [T = int]",  "%s\n",  v14);
    if (v14 == buf) {
      goto LABEL_53;
    }
    goto LABEL_64;
  }

  if (*a1)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182BD28);
    }
    char v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *a1;
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = a2;
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "motion default,%s,set,%d", buf, 0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182BD28);
      }
      int v13 = *a1;
      *(_DWORD *)uint64_t v37 = 136315394;
      *(void *)&v37[4] = a2;
      *(_WORD *)&v37[12] = 1024;
      *(_DWORD *)&v37[14] = v13;
      double v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "motion default,%s,set,%d",  v37,  18);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLMotionDefaultsWrite<int>::CLMotionDefaultsWrite(const char *, const T &, const BOOL) [T = int]",  "%s\n",  v14);
      goto LABEL_42;
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182BD28);
    }
    __int16 v21 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
    {
      int v22 = *a1;
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = a2;
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "motion default,%s,set,%d", buf, 0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182BD28);
      }
      int v23 = *a1;
      *(_DWORD *)uint64_t v37 = 136315394;
      *(void *)&v37[4] = a2;
      *(_WORD *)&v37[12] = 1024;
      *(_DWORD *)&v37[14] = v23;
      double v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "motion default,%s,set,%d",  v37,  18);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLMotionDefaultsWrite<int>::CLMotionDefaultsWrite(const char *, const T &, const BOOL) [T = int]",  "%s\n",  v14);
LABEL_42:
      if (v14 == buf) {
        goto LABEL_53;
      }
LABEL_64:
      free(v14);
    }
  }

void sub_10023B5FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_10023B648(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_10023B674(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 32 * a3;
    do
    {
      sub_10023B6E8(a1, a2, (uint64_t)a2);
      a2 += 32;
      v5 -= 32LL;
    }

    while (v5);
  }

  return a1;
}

void sub_10023B6D4(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_10023B6E8(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    int v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (int i = *v13; i; int i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_10023B964(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  int v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *int v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  int i = (unsigned __int8 *)v25[0];
  ++*v7;
  return i;
}

void sub_10023B940( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p) {
    sub_10004B64C((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *sub_10023B964@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = (char *)operator new(0x30uLL);
  *(void *)(a4 + std::istream::~istream(v2, v3 + 8) = v7;
  *(void *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  *(void *)unint64_t v8 = 0LL;
  *((void *)v8 + 1) = a2;
  uint64_t result = v8 + 16;
  if (*(char *)(a3 + 23) < 0)
  {
    uint64_t result = sub_1010DD48C(result, *(void **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)uint64_t result = *(_OWORD *)a3;
    *((void *)v8 + 4) = *(void *)(a3 + 16);
  }

  *((_DWORD *)v8 + 1sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(a3 + 24);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_10023B9F0(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0LL;
  sub_10004B64C(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10023BA0C()
{
  return 3LL;
}

void *sub_10023BA14(void *a1)
{
  *a1 = off_10182BD58;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void sub_10023BA48(void *a1)
{
  *a1 = off_10182BD58;
  sub_1001B9C98(a1 + 1);
  operator delete(a1);
}

void *sub_10023BA7C(void *a1, char *a2, uint64_t a3, int a4, float a5)
{
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_10182BDD8;
  sub_1010DDBC0(a1 + 13, a2);
  return a1;
}

void sub_10023BB24( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void sub_10023BB54(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10023BB94(a1);
  operator delete(v1);
}

char *sub_10023BB68@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  if (result[127] < 0) {
    return (char *)sub_1010DD48C((_BYTE *)a2, *((void **)result + 13), *((void *)result + 14));
  }
  *(_OWORD *)a2 = *(_OWORD *)(result + 104);
  *(void *)(a2 + 16) = *((void *)result + 15);
  return result;
}

uint64_t sub_10023BB94(uint64_t a1)
{
  *(void *)a1 = off_10182BDD8;
  return sub_100D8A88C(a1);
}

void *sub_10023BBD4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_10182BE40;
  result[1] = v3;
  return result;
}

uint64_t sub_10023BC0C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10182BE40;
  a2[1] = v2;
  return result;
}

uint64_t sub_10023BC2C(uint64_t a1, void *a2, unsigned __int8 *a3)
{
  return (*(uint64_t (**)(void, void))(a1 + 8))(*a2, *a3);
}

uint64_t sub_10023BC3C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_10023BC78()
{
  return &off_10182BEC0;
}

void *sub_10023BC84(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_10000717C(a1, a2);
    int v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8LL;
    }

    while (v8);
    a1[1] = v7;
  }

  return a1;
}

void sub_10023BCE8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::istream::~istream(v2, v3 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

unsigned __int8 *sub_10023BD04(void *a1, unsigned __int8 *a2)
{
  unint64_t v4 = sub_10004B1A4((uint64_t)(a1 + 3), (uint64_t)a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0LL;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }

  else
  {
    unint64_t v9 = (*(void *)&v5 - 1LL) & v4;
  }

  unint64_t v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10) {
    return 0LL;
  }
  uint8x8_t v11 = *v10;
  if (*v10)
  {
    uint64_t v12 = (uint64_t)(a1 + 4);
    do
    {
      unint64_t v13 = *((void *)v11 + 1);
      if (v6 == v13)
      {
        if ((sub_100022A24(v12, v11 + 16, a2) & 1) != 0) {
          return v11;
        }
      }

      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(void *)&v5) {
            v13 %= *(void *)&v5;
          }
        }

        else
        {
          v13 &= *(void *)&v5 - 1LL;
        }

        if (v13 != v9) {
          return 0LL;
        }
      }

      uint8x8_t v11 = *(unsigned __int8 **)v11;
    }

    while (v11);
  }

  return v11;
}

uint64_t sub_10023BE04(uint64_t a1, const std::string *a2, int a3)
{
  uint64_t v6 = std::streambuf::basic_streambuf(a1);
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0u;
  *(_DWORD *)(v6 + 96) = a3;
  std::string::operator=((std::string *)(v6 + 64), a2);
  sub_10023BE94(a1);
  return a1;
}

void sub_10023BE70(_Unwind_Exception *a1)
{
}

void sub_10023BE94(uint64_t a1)
{
  *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = 0LL;
  uint64_t v2 = (std::string *)(a1 + 64);
  char v3 = *(_BYTE *)(a1 + 87);
  if (v3 < 0)
  {
    unint64_t v4 = *(std::string **)(a1 + 64);
    unint64_t v5 = *(void *)(a1 + 72);
  }

  else
  {
    unint64_t v4 = v2;
    unint64_t v5 = *(unsigned __int8 *)(a1 + 87);
  }

  int v6 = *(_DWORD *)(a1 + 96);
  if ((v6 & 8) != 0)
  {
    *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = (char *)v4 + v5;
    *(void *)(a1 + 16) = v4;
    *(void *)(a1 + 24) = v4;
    *(void *)(a1 + 32) = (char *)v4 + v5;
  }

  if ((v6 & 0x10) != 0)
  {
    *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = (char *)v4 + v5;
    std::string::size_type v7 = v3 < 0 ? (*(void *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22LL;
    std::string::resize(v2, v7, 0);
    uint64_t v8 = *(char *)(a1 + 87) < 0 ? *(void *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v4;
    *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v4;
    *(void *)(a1 + 56) = (char *)v4 + v8;
    if ((*(_BYTE *)(a1 + 96) & 3) != 0)
    {
      if (v5 >> 31)
      {
        uint64_t v9 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        unint64_t v10 = 0x7FFFFFFF * ((v9 + ((v5 - 0x80000000 - v9) >> 1)) >> 30);
        unint64_t v4 = (std::string *)((char *)v4 + v10 + 0x7FFFFFFF);
        unint64_t v5 = v5 - v10 - 0x7FFFFFFF;
        *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v4;
      }

      if (v5) {
        *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = (char *)v4 + v5;
      }
    }
  }

uint64_t *sub_10023BFA4(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  int v6 = (uint64_t **)sub_1000227E8((uint64_t)a1, &v9, a2);
  uint64_t result = *v6;
  if (!*v6)
  {
    sub_10023C038((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000085FC(a1, v9, v6, v8);
    return v8;
  }

  return result;
}

_BYTE *sub_10023C038@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  int v6 = (char *)operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + std::istream::~istream(v2, v3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  uint64_t result = v6 + 32;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_1010DD48C(result, *(void **)v8, *((void *)v8 + 1));
  }

  else
  {
    __int128 v9 = *v8;
    *((void *)v6 + 6) = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }

  *((void *)v6 + 7) = 0LL;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_10023C0C0(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0LL;
  sub_100022988(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10023C0DC(uint64_t a1)
{
  *(void *)a1 = off_10182BC38;
  *(void *)(a1 + 72) = off_10182BC70;
  uint64_t v2 = a1 + 72;
  uint64_t v3 = *(void **)(a1 + 320);
  if (v3)
  {
    *(void *)(a1 + 32std::istream::~istream(v2, v3 + 8) = v3;
    operator delete(v3);
  }

  std::string::size_type v7 = (void **)(a1 + 200);
  sub_1000129D4(&v7);
  uint64_t v4 = *(void *)(a1 + 192);
  *(void *)(a1 + 192) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 24LL))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 184);
  *(void *)(a1 + 184) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  sub_100D8A88C(v2);
  *(void *)a1 = off_101826EC8;
  sub_1001B9C98((void *)(a1 + 8));
  return a1;
}

uint64_t sub_10023C1C0()
{
  int v3 = 3;
  sub_1010DDBC0(v4, "ElevationGradeHistory");
  int v5 = 3;
  sub_1010DDBC0(v6, "PredictedWalkDistanceBoutHistory");
  int v7 = 28;
  sub_1010DDBC0(v8, "WalkingSpeedStrideCal");
  int v9 = 28;
  sub_1010DDBC0(v10, "StrideCalHistory");
  int v11 = 28;
  sub_1010DDBC0(v12, "MobilityBoutMetricsHistory");
  int v13 = 90;
  sub_1010DDBC0(v14, "HRRecoveryInputHRHistory");
  int v15 = 180;
  sub_1010DDBC0(v16, "HRRecoveryInputWRHistory");
  int v17 = 180;
  sub_1010DDBC0(v18, "HRRecoverySessionHistory");
  int v19 = 180;
  sub_1010DDBC0(v20, "VO2MaxInputHistory");
  int v21 = 730;
  sub_1010DDBC0(v22, "VO2MaxHistory");
  int v23 = 730;
  sub_1010DDBC0(v24, "VO2MaxSessionAttributesHistory");
  int v25 = 730;
  sub_1010DDBC0(v26, "VO2MaxSummaryHistory");
  int v27 = 730;
  sub_10023B674((uint64_t)&unk_101993D08, v2, 13LL);
  uint64_t v0 = 416LL;
  do
  {
    v0 -= 32LL;
  }

  while (v0);
  return __cxa_atexit((void (*)(void *))sub_1002344B0, &unk_101993D08, (void *)&_mh_execute_header);
}

void sub_10023C434( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v12 = 416LL;
  while (1)
  {
    v12 -= 32LL;
    if (!v12) {
      _Unwind_Resume(exception_object);
    }
  }

void sub_10023C4B4()
{
}

void sub_10023C4BC(uint64_t a1, void *a2)
{
  uint64_t v4 = 0LL;
  int v5 = (char *)*a2;
  a2[1] = *a2;
  int v6 = a2 + 2;
  do
  {
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 == *(void *)(a1 + 16)) {
      int v8 = 0;
    }
    else {
      int v8 = *(_DWORD *)(v7 + 4 * v4);
    }
    double v9 = 1.60000002;
    if (v4)
    {
      if (v4 == 10) {
        double v9 = 10.7;
      }
      else {
        double v9 = (double)(unint64_t)(v4 - 1) + 1.60000002 + 0.5;
      }
    }

    if ((unint64_t)v5 >= *v6)
    {
      uint64_t v11 = (uint64_t)&v5[-*a2] >> 3;
      uint64_t v12 = *v6 - *a2;
      uint64_t v13 = v12 >> 2;
      else {
        unint64_t v14 = v13;
      }
      float v16 = (char *)sub_1000071BC((uint64_t)(a2 + 2), v14);
      int v17 = &v16[8 * v11];
      float v18 = v9;
      *(float *)int v17 = v18;
      *((_DWORD *)v17 + 1) = v8;
      unint64_t v20 = (char *)*a2;
      int v19 = (char *)a2[1];
      int v21 = v17;
      if (v19 != (char *)*a2)
      {
        do
        {
          uint64_t v22 = *((void *)v19 - 1);
          v19 -= 8;
          *((void *)v21 - 1) = v22;
          v21 -= 8;
        }

        while (v19 != v20);
        int v19 = (char *)*a2;
      }

      int v5 = v17 + 8;
      *a2 = v21;
      a2[1] = v17 + 8;
      a2[2] = &v16[8 * v15];
      if (v19) {
        operator delete(v19);
      }
    }

    else
    {
      float v10 = v9;
      *(float *)int v5 = v10;
      *((_DWORD *)v5 + 1) = v8;
      v5 += 8;
    }

    a2[1] = v5;
    ++v4;
  }

  while (v4 != 11);
}

uint64_t sub_10023C634(uint64_t result)
{
  if (*(double *)result == 1.79769313e308)
  {
    uint64_t v1 = (void *)result;
    uint64_t v2 = (void **)(result + 8);
    *(void *)(result + 16) = *(void *)(result + 8);
    CFTypeRef v32 = 0LL;
    uint64_t v27 = sub_1002F8DDC();
    int v3 = sub_1002A6F20(v27, (uint64_t)@"FallMetMinuteTable", &v32);
    CFTypeRef v4 = v32;
    if (v32) {
      int v5 = v3;
    }
    else {
      int v5 = 0;
    }
    if (v5 == 1)
    {
      uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSNumber);
      id v7 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v6,  objc_opt_class(&OBJC_CLASS___NSArray),  0LL),  v4,  0LL);
      __int128 v30 = 0u;
      __int128 v31 = 0u;
      __int128 v28 = 0u;
      __int128 v29 = 0u;
      id v8 = [v7 countByEnumeratingWithState:&v28 objects:v34 count:16];
      if (v8)
      {
        uint64_t v9 = *(void *)v29;
        do
        {
          for (int i = 0LL; i != v8; int i = (char *)i + 1)
          {
            if (*(void *)v29 != v9) {
              objc_enumerationMutation(v7);
            }
            unsigned int v11 = [*(id *)(*((void *)&v28 + 1) + 8 * (void)i) longValue];
            unsigned int v12 = v11;
            unint64_t v14 = (unsigned int *)v1[2];
            unint64_t v13 = v1[3];
            if ((unint64_t)v14 >= v13)
            {
              float v16 = (unsigned int *)*v2;
              uint64_t v17 = ((char *)v14 - (_BYTE *)*v2) >> 2;
              unint64_t v18 = v17 + 1;
              uint64_t v19 = v13 - (void)v16;
              if (v19 >> 1 > v18) {
                unint64_t v18 = v19 >> 1;
              }
              else {
                unint64_t v20 = v18;
              }
              if (v20)
              {
                int v21 = (char *)sub_10000956C((uint64_t)(v1 + 3), v20);
                float v16 = (unsigned int *)v1[1];
                unint64_t v14 = (unsigned int *)v1[2];
              }

              else
              {
                int v21 = 0LL;
              }

              uint64_t v22 = (unsigned int *)&v21[4 * v17];
              *uint64_t v22 = v12;
              uint64_t v15 = v22 + 1;
              while (v14 != v16)
              {
                unsigned int v23 = *--v14;
                *--uint64_t v22 = v23;
              }

              v1[1] = v22;
              v1[2] = v15;
              v1[3] = &v21[4 * v20];
              if (v16) {
                operator delete(v16);
              }
            }

            else
            {
              unsigned int *v14 = v11;
              uint64_t v15 = v14 + 1;
            }

            v1[2] = v15;
          }

          id v8 = [v7 countByEnumeratingWithState:&v28 objects:v34 count:16];
        }

        while (v8);
      }
    }

    CFTypeRef v33 = 0LL;
    int v24 = sub_1002A6F20(v27, (uint64_t)@"FallMetMinuteComputeTime", &v33);
    if (v33) {
      int v25 = v24;
    }
    else {
      int v25 = 0;
    }
    if (v25 == 1)
    {
      objc_msgSend( +[NSKeyedUnarchiver unarchivedObjectOfClass:fromData:error:]( NSKeyedUnarchiver,  "unarchivedObjectOfClass:fromData:error:",  objc_opt_class(NSDate),  v33,  0),  "timeIntervalSinceReferenceDate");
      *uint64_t v1 = v26;
    }

    return sub_10023D35C((uint64_t)v1);
  }

  return result;
}

void sub_10023C8E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, int buf, int a24, __int128 a25)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10182BEE0);
    }
    int v25 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_ERROR))
    {
      std::string buf = 68289026;
      a24 = 0;
      LOWORD(a25) = 2082;
      *(void *)((char *)&a25 + 2) = "";
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MaxMETs,Failed to receive correct MET minutes from plist.}",  (uint8_t *)&buf,  0x12u);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10182BEE0);
      }
    }

    uint64_t v26 = (os_log_s *)qword_1019345D8;
    if (os_signpost_enabled((os_log_t)qword_1019345D8))
    {
      std::string buf = 68289026;
      a24 = 0;
      LOWORD(a25) = 2082;
      *(void *)((char *)&a25 + 2) = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v26,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "MaxMETs,Failed to receive correct MET minutes from plist.",  "{msg%{public}.0s:MaxMETs,Failed to receive correct MET minutes from plist.}",  (uint8_t *)&buf,  0x12u);
    }

    objc_end_catch();
    JUMPOUT(0x10023C834LL);
  }

  _Unwind_Resume(a1);
}

BOOL sub_10023CA3C(uint64_t a1, void *a2, double a3, double a4, double a5, double a6)
{
  if (a2 && [a2 count])
  {
    sub_10023C634(a1);
    double v11 = *(double *)a1;
    __int128 v77 = 0u;
    __int128 v78 = 0u;
    __int128 v79 = 0u;
    __int128 v80 = 0u;
    id v12 = [a2 countByEnumeratingWithState:&v77 objects:v93 count:16];
    if (v12)
    {
      uint64_t v14 = *(void *)v78;
      while (2)
      {
        uint64_t v15 = 0LL;
        do
        {
          if (*(void *)v78 != v14) {
            objc_enumerationMutation(a2);
          }
          float v16 = *(void **)(*((void *)&v77 + 1) + 8LL * (void)v15);
          objc_msgSend(objc_msgSend(v16, "startDate"), "timeIntervalSinceReferenceDate");
          if (v11 <= v17)
          {
            objc_msgSend(objc_msgSend(v16, "averageIntensity"), "doubleValue");
            if (v24 < 0.0)
            {
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10182BEE0);
              }
              uint64_t v59 = (os_log_s *)qword_1019345D8;
              if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_FAULT))
              {
                objc_msgSend(objc_msgSend(v16, "startDate"), "timeIntervalSinceReferenceDate");
                uint64_t v61 = v60;
                objc_msgSend(objc_msgSend(v16, "averageIntensity"), "doubleValue");
                *(_DWORD *)std::string buf = 68289539;
                int v82 = 0;
                __int16 v83 = 2082;
                uint64_t v84 = "";
                __int16 v85 = 2049;
                *(void *)char v86 = v61;
                *(_WORD *)&v86[8] = 1025;
                *(_DWORD *)uint64_t v87 = (int)v62;
                _os_log_impl( (void *)&_mh_execute_header,  v59,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:MaxMETs,Invalid MET minute input., MET Minute time_s:%{private}.09f, MET value:%{private}d}",  buf,  0x22u);
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10182BEE0);
                }
              }

              id v63 = (os_log_s *)qword_1019345D8;
              if (os_signpost_enabled((os_log_t)qword_1019345D8))
              {
                objc_msgSend(objc_msgSend(v16, "startDate"), "timeIntervalSinceReferenceDate");
                uint64_t v65 = v64;
                objc_msgSend(objc_msgSend(v16, "averageIntensity"), "doubleValue");
                *(_DWORD *)std::string buf = 68289539;
                int v82 = 0;
                __int16 v83 = 2082;
                uint64_t v84 = "";
                __int16 v85 = 2049;
                *(void *)char v86 = v65;
                *(_WORD *)&v86[8] = 1025;
                *(_DWORD *)uint64_t v87 = (int)v66;
                _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v63,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "MaxMETs,Invalid MET minute input.",  "{msg%{public}.0s:MaxMETs,Invalid MET minute input., MET Minute time_s:%{private}.09f, MET value:%{private}d}",  buf,  0x22u);
              }

              return 0LL;
            }

            objc_msgSend(objc_msgSend(v16, "startDate"), "timeIntervalSinceReferenceDate");
            double v11 = v25 + 60.0;
          }

          else
          {
            if (qword_1019345D0 != -1) {
              dispatch_once(&qword_1019345D0, &stru_10182BEE0);
            }
            unint64_t v18 = (os_log_s *)qword_1019345D8;
            if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_ERROR))
            {
              double v19 = *(double *)a1;
              objc_msgSend(objc_msgSend(v16, "startDate"), "timeIntervalSinceReferenceDate");
              *(_DWORD *)std::string buf = 68289539;
              int v82 = 0;
              __int16 v83 = 2082;
              uint64_t v84 = "";
              __int16 v85 = 2049;
              *(double *)char v86 = v19;
              *(_WORD *)&v86[8] = 2049;
              *(void *)uint64_t v87 = v20;
              _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MaxMETs,Invalid MET minute input., MRU time_s:%{private}.09f, Input t ime_s:%{private}.09f}",  buf,  0x26u);
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10182BEE0);
              }
            }

            int v21 = (os_log_s *)qword_1019345D8;
            if (os_signpost_enabled((os_log_t)qword_1019345D8))
            {
              double v22 = *(double *)a1;
              objc_msgSend(objc_msgSend(v16, "startDate"), "timeIntervalSinceReferenceDate");
              *(_DWORD *)std::string buf = 68289539;
              int v82 = 0;
              __int16 v83 = 2082;
              uint64_t v84 = "";
              __int16 v85 = 2049;
              *(double *)char v86 = v22;
              *(_WORD *)&v86[8] = 2049;
              *(void *)uint64_t v87 = v23;
              _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v21,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "MaxMETs,Invalid MET minute input.",  "{msg%{public}.0s:MaxMETs,Invalid MET minute input., MRU time_s:%{private}.09f, Input t ime_s:%{private}.09f}",  buf,  0x26u);
            }
          }

          uint64_t v15 = (char *)v15 + 1;
        }

        while (v12 != v15);
        id v12 = [a2 countByEnumeratingWithState:&v77 objects:v93 count:16];
        if (v12) {
          continue;
        }
        break;
      }
    }

    std::stringbuf::string_type __p = 0LL;
    uint64_t v75 = 0LL;
    unint64_t v76 = 0LL;
    if (a3 < a4)
    {
      *(void *)&__int128 v13 = 68290307LL;
      __int128 v68 = v13;
      do
      {
        __int128 v72 = 0u;
        __int128 v73 = 0u;
        __int128 v70 = 0u;
        __int128 v71 = 0u;
        id v26 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v70, v92, 16, v68);
        double v28 = a3 + a5;
        if (v26)
        {
          uint64_t v29 = *(void *)v71;
          do
          {
            for (int i = 0LL; i != v26; int i = (char *)i + 1)
            {
              if (*(void *)v71 != v29) {
                objc_enumerationMutation(a2);
              }
              __int128 v31 = *(void **)(*((void *)&v70 + 1) + 8LL * (void)i);
              objc_msgSend(objc_msgSend(v31, "startDate"), "timeIntervalSinceReferenceDate");
              if (a3 <= v32)
              {
                objc_msgSend(objc_msgSend(v31, "startDate"), "timeIntervalSinceReferenceDate");
                if (v33 < v28)
                {
                  objc_msgSend(objc_msgSend(v31, "averageIntensity"), "doubleValue");
                  if (v34 > 1.60000002)
                  {
                    objc_msgSend(objc_msgSend(v31, "averageIntensity"), "doubleValue");
                    uint64_t v36 = v35;
                    uint64_t v37 = v75;
                    if ((unint64_t)v75 >= v76)
                    {
                      __int16 v39 = (double *)__p;
                      int64_t v40 = ((char *)v75 - (_BYTE *)__p) >> 3;
                      unint64_t v41 = v40 + 1;
                      uint64_t v42 = v76 - (void)__p;
                      else {
                        unint64_t v43 = v41;
                      }
                      if (v43)
                      {
                        int v44 = (char *)sub_1000071BC((uint64_t)&v76, v43);
                        __int16 v39 = (double *)__p;
                        uint64_t v37 = v75;
                      }

                      else
                      {
                        int v44 = 0LL;
                      }

                      __int128 v45 = (double *)&v44[8 * v40];
                      *(void *)__int128 v45 = v36;
                      std::string::size_type v38 = v45 + 1;
                      while (v37 != v39)
                      {
                        uint64_t v46 = *((void *)v37-- - 1);
                        *((void *)v45-- - 1) = v46;
                      }

                      std::stringbuf::string_type __p = v45;
                      uint64_t v75 = v38;
                      unint64_t v76 = (unint64_t)&v44[8 * v43];
                      if (v39) {
                        operator delete(v39);
                      }
                    }

                    else
                    {
                      *(void *)uint64_t v75 = v35;
                      std::string::size_type v38 = v37 + 1;
                    }

                    uint64_t v75 = v38;
                  }
                }
              }
            }

            id v26 = [a2 countByEnumeratingWithState:&v70 objects:v92 count:16];
          }

          while (v26);
        }

        uint64_t v47 = (double *)__p;
        uint64_t v48 = v75;
        int64_t v49 = (char *)v75 - (_BYTE *)__p;
        if (a6 >= 0.0)
        {
          uint64_t v51 = v49 >> 3;
          double v27 = 1.0;
          if (a6 <= 1.0)
          {
            double v27 = (double)(unint64_t)v51 * a6;
            unint64_t v50 = (unint64_t)v27;
          }

          else
          {
            unint64_t v50 = v51 - 1;
          }
        }

        else
        {
          unint64_t v50 = 0LL;
        }

        if (v75 != __p)
        {
          uint64_t v52 = (double *)((char *)__p + 8 * v50);
          if (v52 != v75)
          {
            sub_10023DA1C((double *)__p, v52, v75, v27);
            uint64_t v47 = (double *)__p;
          }

          double v53 = v47[v50];
          if (qword_1019345D0 != -1) {
            dispatch_once(&qword_1019345D0, &stru_10182BEE0);
          }
          uint64_t v54 = (os_log_s *)qword_1019345D8;
          if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)std::string buf = v68;
            int v82 = 0;
            __int16 v83 = 2082;
            uint64_t v84 = "";
            __int16 v85 = 1025;
            *(_DWORD *)char v86 = (unint64_t)v49 >> 3;
            *(_WORD *)&v86[4] = 1025;
            *(_DWORD *)&v86[6] = v50;
            *(_WORD *)uint64_t v87 = 2049;
            *(double *)&v87[2] = v53;
            __int16 v88 = 2049;
            double v89 = a3;
            __int16 v90 = 2049;
            double v91 = a3 + a5;
            _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Processed mets values, count:%{private}d, index:%{private}d, mets value :%{private}f, start time_s:%{private}.09f, end time_s:%{private}.09f}",  buf,  0x3Cu);
          }

          unint64_t v55 = vcvtpd_u64_f64(v53 + -1.60000002);
          if (v55 >= 0xA) {
            unint64_t v55 = 10LL;
          }
          ++*(_DWORD *)(*(void *)(a1 + 8) + 4 * v55);
          uint64_t v48 = (double *)__p;
        }

        uint64_t v75 = v48;
        a3 = a3 + a5;
      }

      while (v28 < a4);
    }

    *(double *)a1 = v11;
    BOOL v58 = sub_10023D35C(a1);
    if (__p)
    {
      uint64_t v75 = (double *)__p;
      operator delete(__p);
    }
  }

  else
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10182BEE0);
    }
    uint64_t v56 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v82 = 0;
      __int16 v83 = 2082;
      uint64_t v84 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MaxMETs,Empty MET minutes input.}",  buf,  0x12u);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10182BEE0);
      }
    }

    __int128 v57 = (os_log_s *)qword_1019345D8;
    if (os_signpost_enabled((os_log_t)qword_1019345D8))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v82 = 0;
      __int16 v83 = 2082;
      uint64_t v84 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v57,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "MaxMETs,Empty MET minutes input.",  "{msg%{public}.0s:MaxMETs,Empty MET minutes input.}",  buf,  0x12u);
    }

    BOOL v58 = 0LL;
    *(double *)a1 = a4;
  }

  return v58;
}

void sub_10023D320( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10023D35C(uint64_t a1)
{
  if (!sub_10023D6F8(a1))
  {
    int v15 = 0;
    sub_10023D8E0((char **)(a1 + 8), 0xBuLL, &v15);
    *(CFAbsoluteTime *)a1 = CFAbsoluteTimeGetCurrent() + -86400.0;
  }

  uint64_t v2 = objc_opt_new(&OBJC_CLASS___NSMutableArray);
  int v3 = *(int **)(a1 + 8);
  CFTypeRef v4 = *(int **)(a1 + 16);
  while (v3 != v4)
  {
    uint64_t v5 = *v3++;
    -[NSMutableArray addObject:]( v2,  "addObject:",  +[NSNumber numberWithLong:](&OBJC_CLASS___NSNumber, "numberWithLong:", v5));
  }

  +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v2,  1LL,  0LL);
  uint64_t v6 = sub_1002F8DDC();
  int v7 = sub_1002AB3DC(v6);
  if ((v7 & 1) == 0)
  {
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10182BEE0);
    }
    id v8 = (os_log_s *)qword_1019345D8;
    if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_ERROR))
    {
      int v15 = 68289026;
      int v16 = 0;
      __int16 v17 = 2082;
      unint64_t v18 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MaxMETs,Failed to persist MET minutes stats}",  (uint8_t *)&v15,  0x12u);
      if (qword_1019345D0 != -1) {
        dispatch_once(&qword_1019345D0, &stru_10182BEE0);
      }
    }

    uint64_t v9 = (os_log_s *)qword_1019345D8;
    if (os_signpost_enabled((os_log_t)qword_1019345D8))
    {
      int v15 = 68289026;
      int v16 = 0;
      __int16 v17 = 2082;
      unint64_t v18 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "MaxMETs,Failed to persist MET minutes stats",  "{msg%{public}.0s:MaxMETs,Failed to persist MET minutes stats}",  (uint8_t *)&v15,  0x12u);
    }
  }

  +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  *(double *)a1),  1LL,  0LL);
  uint64_t v10 = sub_1002F8DDC();
  if ((sub_1002AB3DC(v10) & 1) != 0)
  {
    if (v7)
    {
      uint64_t v11 = sub_1002F8DDC();
      (*(void (**)(uint64_t))(*(void *)v11 + 944LL))(v11);
      return 1LL;
    }

    return 0LL;
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10182BEE0);
  }
  __int128 v13 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_ERROR))
  {
    int v15 = 68289026;
    int v16 = 0;
    __int16 v17 = 2082;
    unint64_t v18 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MaxMETs,Failed to persist MET minutes stats compute time}",  (uint8_t *)&v15,  0x12u);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10182BEE0);
    }
  }

  uint64_t v14 = (os_log_s *)qword_1019345D8;
  BOOL result = os_signpost_enabled((os_log_t)qword_1019345D8);
  if (result)
  {
    int v15 = 68289026;
    int v16 = 0;
    __int16 v17 = 2082;
    unint64_t v18 = "";
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v14,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "MaxMETs,Failed to persist MET minutes stats compute time",  "{msg%{public}.0s:MaxMETs,Failed to persist MET minutes stats compute time}",  (uint8_t *)&v15,  0x12u);
    return 0LL;
  }

  return result;
}

BOOL sub_10023D6F8(uint64_t a1)
{
  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10182BEE0);
  }
  uint64_t v2 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_ERROR))
  {
    double v3 = *(double *)a1;
    uint64_t v4 = (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2;
    int v9 = 68289539;
    int v10 = 0;
    __int16 v11 = 2082;
    id v12 = "";
    __int16 v13 = 2049;
    uint64_t v14 = v4;
    __int16 v15 = 2049;
    double v16 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MaxMETs,Invalid MET minute table, table size:%{private}ld, compute time_s:%{private}.09f}",  (uint8_t *)&v9,  0x26u);
    if (qword_1019345D0 != -1) {
      dispatch_once(&qword_1019345D0, &stru_10182BEE0);
    }
  }

  uint64_t v5 = (os_log_s *)qword_1019345D8;
  BOOL result = os_signpost_enabled((os_log_t)qword_1019345D8);
  if (result)
  {
    double v7 = *(double *)a1;
    uint64_t v8 = (uint64_t)(*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 2;
    int v9 = 68289539;
    int v10 = 0;
    __int16 v11 = 2082;
    id v12 = "";
    __int16 v13 = 2049;
    uint64_t v14 = v8;
    __int16 v15 = 2049;
    double v16 = v7;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v5,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "MaxMETs,Invalid MET minute table",  "{msg%{public}.0s:MaxMETs,Invalid MET minute table, table size:%{private}ld, compute time_s:%{private}.09f}",  (uint8_t *)&v9,  0x26u);
    return 0LL;
  }

  return result;
}

char *sub_10023D8E0(char **a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  BOOL result = *a1;
  if (a2 <= (v6 - (uint64_t)result) >> 2)
  {
    __int16 v13 = a1[1];
    unint64_t v14 = (v13 - result) >> 2;
    if (v14 >= a2) {
      uint64_t v15 = a2;
    }
    else {
      uint64_t v15 = (v13 - result) >> 2;
    }
    if (v15)
    {
      double v16 = result;
      do
      {
        *(_DWORD *)double v16 = *a3;
        v16 += 4;
        --v15;
      }

      while (v15);
    }

    if (a2 <= v14)
    {
      a1[1] = &result[4 * a2];
    }

    else
    {
      __int16 v17 = &v13[4 * (a2 - v14)];
      uint64_t v18 = 4 * a2 - 4 * v14;
      do
      {
        *(_DWORD *)__int16 v13 = *a3;
        v13 += 4;
        v18 -= 4LL;
      }

      while (v18);
      a1[1] = v17;
    }
  }

  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0LL;
      *a1 = 0LL;
      a1[1] = 0LL;
      a1[2] = 0LL;
    }

    if (a2 >> 62) {
      sub_100007008();
    }
    uint64_t v8 = v6 >> 1;
    if (v6 >> 1 <= a2) {
      uint64_t v8 = a2;
    }
    else {
      unint64_t v9 = v8;
    }
    BOOL result = sub_10001B7A4(a1, v9);
    int v10 = a1[1];
    __int16 v11 = &v10[4 * a2];
    uint64_t v12 = 4 * a2;
    do
    {
      *(_DWORD *)int v10 = *a3;
      v10 += 4;
      v12 -= 4LL;
    }

    while (v12);
    a1[1] = v11;
  }

  return result;
}

void sub_10023D9F0(id a1)
{
  qword_1019345D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Fall");
}

double sub_10023DA1C(double *a1, double *a2, double *a3, double result)
{
  if (a3 != a2)
  {
    uint64_t v4 = a3;
    do
    {
      unint64_t v7 = v4 - a1;
      if (v7 < 2) {
        break;
      }
      if (v7 == 3)
      {
        sub_10023DCA4(a1, a1 + 1, v4 - 1);
        return result;
      }

      if (v7 == 2)
      {
        BOOL result = *(v4 - 1);
        double v30 = *a1;
        if (result < *a1)
        {
          *a1 = result;
          *(v4 - 1) = v30;
        }

        return result;
      }

      uint64_t v8 = &a1[v7 >> 1];
      unint64_t v9 = v4 - 1;
      int v10 = sub_10023DCA4(a1, v8, v4 - 1);
      BOOL result = *a1;
      if (*a1 >= *v8)
      {
        __int16 v11 = v4 - 1;
        while (--v11 != a1)
        {
          if (*v11 < *v8)
          {
            *a1 = *v11;
            *__int16 v11 = result;
            ++v10;
            goto LABEL_13;
          }
        }

        int v21 = a1 + 1;
        if (result >= *v9)
        {
          while (v21 != v9)
          {
            double v22 = *v21;
            if (result < *v21)
            {
              *v21++ = *v9;
              *unint64_t v9 = v22;
              goto LABEL_45;
            }

            ++v21;
          }

          return result;
        }

uint64_t sub_10023DCA4(double *a1, double *a2, double *a3)
{
  double v3 = *a2;
  double v4 = *a1;
  double v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1LL;
    }

    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4) {
      return 1LL;
    }
    *a2 = *a3;
    *a3 = v4;
    return 2LL;
  }

  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    double v6 = *a1;
    if (*a2 >= *a1) {
      return 1LL;
    }
    *a1 = *a2;
    *a2 = v6;
    return 2LL;
  }

  return 0LL;
}

double sub_10023DD2C(double *a1, double *a2, double result)
{
  while (a1 != a2 - 1)
  {
    double v3 = a1++;
    if (v3 != a2 && a1 != a2)
    {
      BOOL result = *v3;
      double v4 = a1;
      double v5 = v3;
      double v6 = a1;
      do
      {
        double v7 = *v6++;
        double v8 = v7;
        if (v7 < result)
        {
          BOOL result = v8;
          double v5 = v4;
        }

        double v4 = v6;
      }

      while (v6 != a2);
      if (v5 != v3)
      {
        BOOL result = *v3;
        *double v3 = *v5;
        *double v5 = result;
      }
    }
  }

  return result;
}

  ;
}

void sub_10023DE60(id a1)
{
  qword_101993D68 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLStreamedLocationProviderSilo");
}

uint64_t sub_10023DF14(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10023F084;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_101993D88 != -1) {
    dispatch_once(&qword_101993D88, block);
  }
  return qword_101993D90;
}

void sub_10023E0B4(id a1)
{
  if (objc_opt_class(&OBJC_CLASS___IDSService))
  {
    sub_1004F2598();
  }

  sub_1002F0B04(&v6);
  int v1 = sub_1002A6F64(v6, "EnableMultiClientStreaming", &v8);
  if (v8) {
    int v2 = v1;
  }
  else {
    int v2 = 0;
  }
  double v3 = v7;
  if (!v7) {
    goto LABEL_11;
  }
  p_shared_owners = (unint64_t *)&v7->__shared_owners_;
  do
    unint64_t v5 = __ldaxr(p_shared_owners);
  while (__stlxr(v5 - 1, p_shared_owners));
  if (!v5)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if (!v2) {
      return;
    }
  }

  else
  {
LABEL_11:
    if (!v2) {
      return;
    }
  }

  byte_101993D78 = 1;
}

void sub_10023E178(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10023E1A0(_DWORD *a1)
{
  if ((a1[40] & 0x80000000) != 0)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    unint64_t v5 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_FAULT))
    {
      int v6 = a1[40];
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v6;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fDisablementAssertionCount >= 0";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Assertion count must be non-negative, count:%{public}d, event:%{public, locatio n:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    double v7 = (os_log_s *)qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      int v8 = a1[40];
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v8;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fDisablementAssertionCount >= 0";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Assertion count must be non-negative",  "{msg%{public}.0s:Assertion count must be non-negative, count:%{public}d, event:%{public, locatio n:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    unint64_t v9 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
    {
      int v10 = a1[40];
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v10;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fDisablementAssertionCount >= 0";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Assertion count must be non-negative, count:%{public}d, event:%{public, locatio n:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
    }

    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Shared/Streaming/CLStreamedLocationProvider.mm",  839,  "takeDisablementAssertion");
  }

  else if (qword_101934990 == -1)
  {
    goto LABEL_3;
  }

  dispatch_once(&qword_101934990, &stru_10182C2F8);
LABEL_3:
  int v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = a1[40];
    *(_DWORD *)std::string buf = 68289282;
    int v12 = 0;
    __int16 v13 = 2082;
    double v14 = "";
    __int16 v15 = 1026;
    int v16 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Client took disablement assertion, before change:%{public}d}",  buf,  0x18u);
  }

  int v4 = a1[40];
  a1[40] = v4 + 1;
  if (!v4)
  {
    *(_DWORD *)std::string buf = 9;
    (*(void (**)(_DWORD *, uint8_t *, uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, buf, 1LL, 0xFFFFFFFFLL);
    sub_1002404A0((uint64_t)a1);
  }

void sub_10023E520(_DWORD *a1)
{
  if ((int)a1[40] <= 0)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    unint64_t v5 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_FAULT))
    {
      int v6 = a1[40];
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v6;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fDisablementAssertionCount > 0";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Assertion count must be positive, count:%{public}d, event:%{public, location:es cape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    double v7 = (os_log_s *)qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      int v8 = a1[40];
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v8;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fDisablementAssertionCount > 0";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Assertion count must be positive",  "{msg%{public}.0s:Assertion count must be positive, count:%{public}d, event:%{public, location:es cape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    unint64_t v9 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
    {
      int v10 = a1[40];
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v10;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fDisablementAssertionCount > 0";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Assertion count must be positive, count:%{public}d, event:%{public, location:es cape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
    }

    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Shared/Streaming/CLStreamedLocationProvider.mm",  854,  "releaseDisablementAssertion");
  }

  else if (qword_101934990 == -1)
  {
    goto LABEL_3;
  }

  dispatch_once(&qword_101934990, &stru_10182C2F8);
LABEL_3:
  int v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = a1[40];
    *(_DWORD *)std::string buf = 68289282;
    int v12 = 0;
    __int16 v13 = 2082;
    double v14 = "";
    __int16 v15 = 1026;
    int v16 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Client released disablement assertion, before change:%{public}d}",  buf,  0x18u);
  }

  int v4 = a1[40] - 1;
  a1[40] = v4;
  if (!v4)
  {
    *(_DWORD *)std::string buf = 9;
    (*(void (**)(_DWORD *, uint8_t *))(*(void *)a1 + 120LL))(a1, buf);
    sub_1002404A0((uint64_t)a1);
  }

void sub_10023E8A0(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 164) & 0x80000000) != 0)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    unint64_t v5 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_FAULT))
    {
      int v6 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v6;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fEmergencyEnablementAssertionCount >= 0";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Assertion count must be non-negative, count:%{public}d, event:%{public, locatio n:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    double v7 = (os_log_s *)qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      int v8 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v8;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fEmergencyEnablementAssertionCount >= 0";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Assertion count must be non-negative",  "{msg%{public}.0s:Assertion count must be non-negative, count:%{public}d, event:%{public, locatio n:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    unint64_t v9 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
    {
      int v10 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v10;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fEmergencyEnablementAssertionCount >= 0";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Assertion count must be non-negative, count:%{public}d, event:%{public, locatio n:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
    }

    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Shared/Streaming/CLStreamedLocationProvider.mm",  870,  "takeEmergencyEnablementAssertion");
  }

  else if (qword_101934990 == -1)
  {
    goto LABEL_3;
  }

  dispatch_once(&qword_101934990, &stru_10182C2F8);
LABEL_3:
  int v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 164);
    *(_DWORD *)std::string buf = 68289282;
    int v12 = 0;
    __int16 v13 = 2082;
    double v14 = "";
    __int16 v15 = 1026;
    int v16 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Client took emergency enablement assertion, before change:%{public}d}",  buf,  0x18u);
  }

  int v4 = *(_DWORD *)(a1 + 164);
  *(_DWORD *)(a1 + 164) = v4 + 1;
  if (!v4)
  {
    if (*(_DWORD *)(a1 + 136)) {
      sub_10023F504(a1);
    }
  }

void sub_10023EC04(uint64_t a1)
{
  if (*(int *)(a1 + 164) <= 0)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    unint64_t v5 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_FAULT))
    {
      int v6 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v6;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fEmergencyEnablementAssertionCount > 0";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Assertion count must be positive, count:%{public}d, event:%{public, location:es cape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    double v7 = (os_log_s *)qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      int v8 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v8;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fEmergencyEnablementAssertionCount > 0";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Assertion count must be positive",  "{msg%{public}.0s:Assertion count must be positive, count:%{public}d, event:%{public, location:es cape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    unint64_t v9 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
    {
      int v10 = *(_DWORD *)(a1 + 164);
      *(_DWORD *)std::string buf = 68289795;
      int v12 = 0;
      __int16 v13 = 2082;
      double v14 = "";
      __int16 v15 = 1026;
      int v16 = v10;
      __int16 v17 = 2082;
      double v18 = "assert";
      __int16 v19 = 2081;
      double v20 = "fEmergencyEnablementAssertionCount > 0";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Assertion count must be positive, count:%{public}d, event:%{public, location:es cape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x2Cu);
    }

    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Shared/Streaming/CLStreamedLocationProvider.mm",  886,  "releaseEmergencyEnablementAssertion");
  }

  else if (qword_101934990 == -1)
  {
    goto LABEL_3;
  }

  dispatch_once(&qword_101934990, &stru_10182C2F8);
LABEL_3:
  int v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 164);
    *(_DWORD *)std::string buf = 68289282;
    int v12 = 0;
    __int16 v13 = 2082;
    double v14 = "";
    __int16 v15 = 1026;
    int v16 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Client released emergency enablement assertion, before change:%{public}d}",  buf,  0x18u);
  }

  int v4 = *(_DWORD *)(a1 + 164) - 1;
  *(_DWORD *)(a1 + 164) = v4;
  if (!v4)
  {
    if (*(_DWORD *)(a1 + 136)) {
      sub_10023F504(a1);
    }
  }

void sub_10023EF88(uint64_t a1, void *a2, void *a3)
{
  if ([a2 isEqual:@"kCLLocationStreamingMessageTypeLocation"])
  {
    sub_100242E40((id *)a1, a3);
  }

  else if ([a2 isEqual:@"kCLLocationStreamingMessageTypeAliveAgain"])
  {
    if (*(_DWORD *)(a1 + 136)) {
      sub_10023F504(a1);
    }
  }

uint64_t sub_10023F084(uint64_t a1)
{
  int v2 = operator new(0xD8uLL);
  uint64_t result = sub_10023F0D0((uint64_t)v2, *(void **)(a1 + 32));
  qword_101993D90 = (uint64_t)v2;
  return result;
}

void sub_10023F0BC(_Unwind_Exception *a1)
{
}

uint64_t sub_10023F0D0(uint64_t a1, void *a2)
{
  uint64_t v3 = sub_100479C24(a1, "Streamed location provider", a2);
  *(void *)uint64_t v3 = off_10182BF50;
  *(void *)(v3 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  *(void *)(a1 + 12std::istream::~istream(v2, v3 + 8) =  objc_msgSend( objc_msgSend(*(id *)(v3 + 32), "vendor"),  "proxyForService:forClient:",  @"CLLocationStreamingConnectionManager",  @"CLStreamedLocationProvider");
  *(_DWORD *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = [*(id *)(a1 + 40) newTimer];
  *(void *)(a1 + 152) = [*(id *)(a1 + 40) newTimer];
  *(void *)(a1 + 16sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  *(void *)(a1 + 166) = 0LL;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_BYTE *)(a1 + 20std::istream::~istream(v2, v3 + 8) = 1;
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  _DWORD v16[2] = sub_10023F424;
  void v16[3] = &unk_10181D3D0;
  _DWORD v16[4] = a1;
  [*(id *)(a1 + 144) setHandler:v16];
  [*(id *)(a1 + 144) setNextFireDelay:1.79769313e308];
  [*(id *)(a1 + 144) setFireInterval:30.0];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472LL;
  id v15[2] = sub_10023F8BC;
  v15[3] = &unk_10181D3D0;
  _DWORD v15[4] = a1;
  [*(id *)(a1 + 152) setHandler:v15];
  sub_1002F0B04(buf);
  char v4 = sub_1002A6F64(*(uint64_t *)buf, "EnableMultiClientStreaming", &v17);
  if (v17) {
    char v5 = v4;
  }
  else {
    char v5 = 0;
  }
  *(_BYTE *)(a1 + 172) = v5;
  int v6 = *(std::__shared_weak_count **)v19;
  if (*(void *)v19)
  {
    double v7 = (unint64_t *)(*(void *)v19 + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182C2F8);
  }
  unint64_t v9 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
  {
    int v10 = *(unsigned __int8 *)(a1 + 172);
    *(void *)std::string buf = 68289282LL;
    *(_WORD *)__int16 v19 = 2082;
    *(void *)&v19[2] = "";
    __int16 v20 = 1026;
    int v21 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient enabled?, fEnableMultiClientStreaming:%{public}hhd}",  buf,  0x18u);
  }

  if (*(_BYTE *)(a1 + 172))
  {
    *(void *)(a1 + 184) = -[CLStreamedLocationProviderServerDiscoverer initOnQueue:]( [CLStreamedLocationProviderServerDiscoverer alloc],  "initOnQueue:",  [*(id *)(a1 + 40) queue]);
    sub_100ACD980((uint64_t)sub_10023FA70, a1, *(void **)(a1 + 32), buf);
    uint64_t v11 = *(void *)buf;
    *(void *)std::string buf = 0LL;
    uint64_t v12 = *(void *)(a1 + 120);
    *(void *)(a1 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v11;
    if (v12)
    {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
      uint64_t v13 = *(void *)buf;
      *(void *)std::string buf = 0LL;
      if (v13) {
        (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
      }
    }

    [*(id *)(*(void *)(a1 + 120) + 16) register:*(void *)(*(void *)(a1 + 120) + 8) forNotification:1 registrationInfo:0];
  }

  [*(id *)(a1 + 128) addClient:CLISP_ME_TOKEN];
  return a1;
}

void sub_10023F3D8(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 120);
  *(void *)(v1 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_10047A1C0(v1);
  _Unwind_Resume(a1);
}

void sub_10023F424(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182C2F8);
  }
  int v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 68289026;
    v3[1] = 0;
    __int16 v4 = 2082;
    char v5 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Refreshing location request}",  (uint8_t *)v3,  0x12u);
  }

  sub_10023F504(v1);
}

void sub_10023F504(uint64_t a1)
{
  if ((sub_10023FD00(a1) & 1) != 0)
  {
    int v2 = objc_alloc_init(&OBJC_CLASS___CLLocationStreamingMessage);
    -[CLLocationStreamingMessage setMessageType:]( v2,  "setMessageType:",  @"kCLLocationStreamingMessageTypeRequestLocation");
    id v3 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    objc_msgSend( v3,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 136)),  @"kCLLocationStreamingMessageGranularityKey");
    if (sub_1002423D8(a1)) {
      objc_msgSend( v3,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 1),  @"kCLLocationStreamingMessageIncludeMotionKey");
    }
    *(_DWORD *)std::string buf = 28;
    if (sub_100247620(a1, (int *)buf, 1LL)) {
      [v3 setObject:&__kCFBooleanTrue forKeyedSubscript:@"kCLLocationStreamingMessageInFitnessSessionKey"];
    }
    *(_DWORD *)std::string buf = 29;
    if (sub_100247620(a1, (int *)buf, 1LL)) {
      [v3 setObject:&__kCFBooleanTrue forKeyedSubscript:@"kCLLocationStreamingMessageActivityTypeAirborneKey"];
    }
    *(_DWORD *)std::string buf = 17;
    if (sub_100247620(a1, (int *)buf, 1LL)) {
      [v3 setObject:&__kCFBooleanTrue forKeyedSubscript:@"kCLLocationStreamingMessageMapMatching"];
    }
    if (*(_DWORD *)(a1 + 164)) {
      [v3 setObject:&__kCFBooleanTrue forKeyedSubscript:@"kCLLocationStreamingMessageEmergencyEnablementKey"];
    }
    -[CLLocationStreamingMessage setPayload:](v2, "setPayload:", v3);
    -[CLLocationStreamingMessage setPriority:](v2, "setPriority:", 300LL);
    v8[0] = IDSSendMessageOptionTimeoutKey;
    __int16 v4 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", 30.0);
    v8[1] = IDSSendMessageOptionForceLocalDeliveryKey;
    void v8[2] = IDSSendMessageOptionEncryptPayloadKey;
    v9[0] = v4;
    v9[1] = &__kCFBooleanTrue;
    _DWORD v9[2] = &__kCFBooleanTrue;
    v9[3] = &__kCFBooleanTrue;
    void v8[3] = IDSSendMessageOptionRequireBluetoothKey;
    _DWORD v8[4] = IDSSendMessageOptionQueueOneIdentifierKey;
    v9[4] = @"kCLLocationStreamingMessageTypeRequestLocation";
    -[CLLocationStreamingMessage setIdsOptions:]( v2,  "setIdsOptions:",  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v9,  v8,  5LL));
    [*(id *)(a1 + 128) sendMessage:v2];
  }

  else
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    char v5 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#ilsa,sendLocationRequest,streaming is not allowed,blocking location request",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
      v7[0] = 0;
      int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934998,  0LL,  "#ilsa,sendLocationRequest,streaming is not allowed,blocking location request",  v7,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLStreamedLocationProvider::sendLocationRequest()", "%s\n", v6);
    }
  }

uint64_t sub_10023F8BC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182C2F8);
  }
  int v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Location unavailable timer fired. Triggering kNotificationLocationUnavailable notification",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    v5[0] = 0;
    __int16 v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934998,  0LL,  "Location unavailable timer fired. Triggering kNotificationLocationUnavailable notification",  v5,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLStreamedLocationProvider::CLStreamedLocationProvider(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v4);
  }

  *(_DWORD *)std::string buf = 9;
  return (*(uint64_t (**)(uint64_t, uint8_t *, uint64_t, uint64_t))(*(void *)v1 + 144LL))( v1,  buf,  1LL,  0xFFFFFFFFLL);
}

void sub_10023FA70(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182C2D8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    unint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLStreamedLocationProvider::onDataProtectionNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182C2D8);
    }
    unint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      BOOL v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLStreamedLocationProvider::onDataProtectionNotification, event:%{public, location: escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10024155C(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_10023FC28( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10023FC48(id *a1)
{
  a1[24] = 0LL;
  [a1[25] invalidate];

  a1[25] = 0LL;
  a1[23] = 0LL;
  [0 invalidateAndReleaseProbeClients];
  [a1[22] invalidate];

  a1[22] = 0LL;
  [a1[18] invalidate];

  a1[18] = 0LL;
  [a1[19] invalidate];

  a1[19] = 0LL;
  [a1[16] retireClient:CLISP_ME_TOKEN];

  a1[16] = 0LL;
  return sub_10047A1E0((uint64_t)a1);
}

uint64_t sub_10023FD00(uint64_t a1)
{
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182C2F8);
  }
  int v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 208);
    *(_DWORD *)std::string buf = 67240192;
    int v9 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "#ilsa,CLStreamedLocationProvider,isLocationStreamingAllowed,%{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    int v5 = *(unsigned __int8 *)(a1 + 208);
    v7[0] = 67240192;
    v7[1] = v5;
    int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934998,  0LL,  "#ilsa,CLStreamedLocationProvider,isLocationStreamingAllowed,%{public}d",  v7,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLStreamedLocationProvider::isLocationStreamingAllowed() const",  "%s\n",  v6);
  }

  return *(unsigned __int8 *)(a1 + 208);
}

BOOL sub_10023FEB8(uint64_t a1, int a2, int *a3, __int128 *a4)
{
  int v51 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        int v13 = (uint64_t *)v7;
      }
      else {
        int v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      uint64_t v50 = v10;
      int v16 = *a3;
      uint64_t v19 = *(void *)(v10 + 48);
      uint64_t v18 = v10 + 48;
      uint64_t v17 = v19;
      if (!v19) {
        goto LABEL_31;
      }
      uint64_t v20 = v18;
      do
      {
        int v21 = *(_DWORD *)(v17 + 28);
        BOOL v22 = v21 < v16;
        if (v21 >= v16) {
          uint64_t v23 = (uint64_t *)v17;
        }
        else {
          uint64_t v23 = (uint64_t *)(v17 + 8);
        }
        if (!v22) {
          uint64_t v20 = v17;
        }
        uint64_t v17 = *v23;
      }

      while (*v23);
      if (v20 == v18 || v16 < *(_DWORD *)(v20 + 28)) {
LABEL_31:
      }
        uint64_t v20 = v18;
      uint64_t v24 = *(void *)(a1 + 64);
      if (!v24) {
        goto LABEL_42;
      }
      uint64_t v25 = a1 + 64;
      do
      {
        int v26 = *(_DWORD *)(v24 + 32);
        BOOL v27 = v26 < v16;
        if (v26 >= v16) {
          double v28 = (uint64_t *)v24;
        }
        else {
          double v28 = (uint64_t *)(v24 + 8);
        }
        if (!v27) {
          uint64_t v25 = v24;
        }
        uint64_t v24 = *v28;
      }

      while (*v28);
      if (v25 != a1 + 64 && v16 >= *(_DWORD *)(v25 + 32))
      {
        *(void *)uint64_t v52 = v25;
        uint64_t v34 = *(void *)(v25 + 56);
        *(void *)std::string buf = &v51;
        uint64_t v35 = sub_100246B14((uint64_t **)(v25 + 40), &v51, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        __int128 v36 = *a4;
        *(_OWORD *)((char *)v35 + 52) = *(__int128 *)((char *)a4 + 12);
        *(_OWORD *)(v35 + 5) = v36;
        sub_100246564((uint64_t)buf);
        if (v20 == v18
          && (*(unsigned int (**)(uint64_t, int *, _BYTE *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          uint64_t v37 = sub_1002469A0((uint64_t)buf);
          sub_100246A38((_BYTE *)a1, (uint64_t)&v50, (uint64_t)v52, v37);
        }

        std::string::size_type v38 = v62;
        if (v62)
        {
          p_shared_owners = (unint64_t *)&v62->__shared_owners_;
          do
            unint64_t v40 = __ldaxr(p_shared_owners);
          while (__stlxr(v40 - 1, p_shared_owners));
          if (!v40)
          {
            ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
            std::__shared_weak_count::__release_weak(v38);
          }
        }

        if (v61 < 0) {
          operator delete(v60);
        }
        unint64_t v41 = v59;
        if (v59)
        {
          uint64_t v42 = (unint64_t *)&v59->__shared_owners_;
          do
            unint64_t v43 = __ldaxr(v42);
          while (__stlxr(v43 - 1, v42));
          if (!v43)
          {
            ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
            std::__shared_weak_count::__release_weak(v41);
          }
        }

        int v44 = v58;
        if (v58)
        {
          __int128 v45 = (unint64_t *)&v58->__shared_owners_;
          do
            unint64_t v46 = __ldaxr(v45);
          while (__stlxr(v46 - 1, v45));
          if (!v46)
          {
            ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
            std::__shared_weak_count::__release_weak(v44);
          }
        }

        if (v34) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        *(void *)uint64_t v52 = a1 + 64;
        char v29 = byte_101936868;
        HIDWORD(v49) = v16;
        *(void *)std::string buf = (char *)&v49 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v49 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v29;
        HIDWORD(v49) = *a3;
        *(void *)std::string buf = (char *)&v49 + 4;
        double v30 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v49 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v30 + 8);
        HIDWORD(v49) = *a3;
        *(void *)std::string buf = (char *)&v49 + 4;
        __int128 v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v49 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)std::string buf = &v51;
        double v32 = sub_100246B14(v31 + 5, &v51, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        __int128 v33 = *a4;
        *(_OWORD *)((char *)v32 + 52) = *(__int128 *)((char *)a4 + 12);
        *(_OWORD *)(v32 + 5) = v33;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v20 == v18)
      {
        *(_DWORD *)std::string buf = *a3;
        sub_10004A8FC((uint64_t **)(v50 + 40), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182C2D8);
  }
  __int16 v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    __int16 v15 = (void *)(a1 + 8);
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    __int16 v56 = 1026;
    int v57 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL result = sub_1002921D0(115, 0);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182C2D8);
    }
    uint64_t v47 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t v52 = 136446466;
    *(void *)&v52[4] = v47;
    __int16 v53 = 1026;
    int v54 = v51;
    LODWORD(v49) = 18;
    uint64_t v48 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                    v52,
                    v49);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char, CL LocationProvider_Type::RegInfo>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLLocationProvider_Type::Notification, NotificationData_T = CLLocationProvider_Type::Notificatio nData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationProvider_Type::RegInfo]",  "%s\n",  v48);
    if (v48 != buf) {
      free(v48);
    }
    return 0LL;
  }

  return result;
}

void sub_1002403F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_100240428(uint64_t a1, int *a2)
{
  int v2 = *a2;
  if (((1LL << v2) & 0x8000000238LL) != 0) {
    return 1LL;
  }
  if (((1LL << v2) & 7) != 0)
  {
    sub_1002404A0(a1);
    return 1LL;
  }

  if (((1LL << v2) & 0x30020000) == 0) {
LABEL_9:
  }
    sub_10123153C();
  if (*(_DWORD *)(a1 + 136)) {
    sub_10023F504(a1);
  }
  return 1LL;
}

void sub_1002404A0(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 160) || (uint64_t v3 = qword_101993D50) == 0)
  {
    int v2 = 0;
  }

  else
  {
    int v2 = 0;
    do
    {
      v8[0] = *(_DWORD *)(v3 + 16);
      uint64_t v3 = *(void *)v3;
    }

    while (v3);
  }

  int v4 = *(_DWORD *)(a1 + 136);
  if (v4 != v2)
  {
    if (v4)
    {
      if (!v2)
      {
        [*(id *)(a1 + 152) setNextFireDelay:1.79769313e308];
        v8[0] = 0;
        (*(void (**)(uint64_t, int *))(*(void *)a1 + 120LL))(a1, v8);
        v8[0] = 1;
        (*(void (**)(uint64_t, int *))(*(void *)a1 + 120LL))(a1, v8);
        v8[0] = 2;
        (*(void (**)(uint64_t, int *))(*(void *)a1 + 120LL))(a1, v8);
      }
    }

    else
    {
      [*(id *)(a1 + 152) setNextFireDelay:5.0];
    }

    if (*(_BYTE *)(a1 + 172)) {
      sub_100241650((id *)a1, v2);
    }
    *(_DWORD *)(a1 + 136) = v2;
    double v5 = 30.0;
    if (!v2) {
      double v5 = 1.79769313e308;
    }
    [*(id *)(a1 + 144) setNextFireDelay:v5];
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    int v6 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(unsigned int *)(a1 + 136);
      v8[0] = 68289282;
      v8[1] = 0;
      __int16 v9 = 2082;
      uint64_t v10 = "";
      __int16 v11 = 2050;
      uint64_t v12 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Changing requested granularity, granularity:%{public, location:CLLocationStreamingGranularity}lld}",  (uint8_t *)v8,  0x1Cu);
    }

    sub_10023F504(a1);
  }

BOOL sub_1002406A8(char *a1, int a2, int *a3)
{
  HIDWORD(v33) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      unint64_t v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          __int16 v11 = (uint64_t *)v6;
        }
        else {
          __int16 v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          unint64_t v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        __int16 v14 = (char *)*((void *)v8 + 6);
        uint64_t v12 = v8 + 48;
        int v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          int v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              uint64_t v19 = (char **)v13;
            }
            else {
              uint64_t v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              int v16 = v13;
            }
            int v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            BOOL v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                uint64_t v25 = (uint64_t *)v20;
              }
              else {
                uint64_t v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                BOOL v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1002475A8((uint64_t)(v22 + 40), (int *)&v33 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10182C2D8);
              }
              int v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                BOOL v27 = a1 + 8;
                if (a1[31] < 0) {
                  BOOL v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v43 >= 0) {
                  double v28 = __p;
                }
                else {
                  double v28 = (void **)__p[0];
                }
                *(_DWORD *)std::string buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v35 = 2082;
                __int128 v36 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v43 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_10182C2D8);
                }
                char v29 = a1 + 8;
                if (a1[31] < 0) {
                  char v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v37 >= 0) {
                  __int128 v31 = buf;
                }
                else {
                  __int128 v31 = *(_BYTE **)buf;
                }
                int v38 = 136446466;
                __int16 v39 = v29;
                __int16 v40 = 2082;
                unint64_t v41 = v31;
                LODWORD(v33) = 22;
                double v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                                &v38,
                                v33);
                if (v37 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationDa ta, char, CLLocationProvider_Type::RegInfo>::unregisterForNotification(int, const Notification_T &) [N otification_T = CLLocationProvider_Type::Notification, NotificationData_T = CLLocationProvider_Type::N otificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLocationProvider_Type::RegInfo]",  "%s\n",  v32);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_100240A30(uint64_t a1, int *a2)
{
  int v2 = *a2;
  if (((1LL << v2) & 0x8000000238LL) != 0) {
    return 1LL;
  }
  if (((1LL << v2) & 7) != 0)
  {
    sub_1002404A0(a1);
    return 1LL;
  }

  if (((1LL << v2) & 0x30020000) == 0) {
LABEL_9:
  }
    sub_1012316B8();
  if (*(_DWORD *)(a1 + 136)) {
    sub_10023F504(a1);
  }
  return 1LL;
}

void sub_100240AA8(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)(a2 + 96) & 0xFFFFFFF7) == 1)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    int v3 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a2 + 4);
      uint64_t v5 = *(void *)(a2 + 12);
      uint64_t v6 = *(void *)(a2 + 20);
      uint64_t v7 = *(void *)(a2 + 44);
      uint64_t v8 = *(void *)(a2 + 60);
      int v9 = *(_DWORD *)(a2 + 96);
      uint64_t v10 = *(void *)(a2 + 28);
      uint64_t v11 = *(void *)(a2 + 36);
      uint64_t v12 = *(void *)(a2 + 144);
      uint64_t v13 = *(void *)(a2 + 52);
      uint64_t v14 = *(void *)(a2 + 68);
      int v15 = *(_DWORD *)(a2 + 140);
      uint64_t v16 = *(void *)(a2 + 76);
      *(_DWORD *)std::string buf = 134286593;
      uint64_t v58 = v4;
      __int16 v59 = 2049;
      uint64_t v60 = v5;
      __int16 v61 = 2050;
      uint64_t v62 = v6;
      __int16 v63 = 2049;
      uint64_t v64 = v7;
      __int16 v65 = 2049;
      uint64_t v66 = v8;
      __int16 v67 = 1026;
      int v68 = v9;
      __int16 v69 = 2049;
      uint64_t v70 = v10;
      __int16 v71 = 2050;
      uint64_t v72 = v11;
      __int16 v73 = 2049;
      uint64_t v74 = v12;
      __int16 v75 = 2049;
      uint64_t v76 = v13;
      __int16 v77 = 2049;
      uint64_t v78 = v14;
      __int16 v79 = 1025;
      int v80 = v15;
      __int16 v81 = 2050;
      uint64_t v82 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "@ClxStreamed, Send, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, speed, %{private}.1f, course, %{private }.1f, type, %{public}d, alt, %{private}.1f, altunc, %{public}.1f,ellipsoidalAlt,%{private}.1f,speedUnc,%{private }.1f,courseUnc,%{private}.1f,signalEnv,%{private}d,timestamp,%{public}.3f",  buf,  0x7Cu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
      uint64_t v17 = *(void *)(a2 + 4);
      uint64_t v18 = *(void *)(a2 + 12);
      uint64_t v19 = *(void *)(a2 + 20);
      uint64_t v20 = *(void *)(a2 + 44);
      uint64_t v21 = *(void *)(a2 + 60);
      int v22 = *(_DWORD *)(a2 + 96);
      uint64_t v23 = *(void *)(a2 + 28);
      uint64_t v24 = *(void *)(a2 + 36);
      uint64_t v25 = *(void *)(a2 + 144);
      uint64_t v26 = *(void *)(a2 + 52);
      uint64_t v27 = *(void *)(a2 + 68);
      int v28 = *(_DWORD *)(a2 + 140);
      uint64_t v29 = *(void *)(a2 + 76);
      int v31 = 134286593;
      uint64_t v32 = v17;
      __int16 v33 = 2049;
      uint64_t v34 = v18;
      __int16 v35 = 2050;
      uint64_t v36 = v19;
      __int16 v37 = 2049;
      uint64_t v38 = v20;
      __int16 v39 = 2049;
      uint64_t v40 = v21;
      __int16 v41 = 1026;
      int v42 = v22;
      __int16 v43 = 2049;
      uint64_t v44 = v23;
      __int16 v45 = 2050;
      uint64_t v46 = v24;
      __int16 v47 = 2049;
      uint64_t v48 = v25;
      __int16 v49 = 2049;
      uint64_t v50 = v26;
      __int16 v51 = 2049;
      uint64_t v52 = v27;
      __int16 v53 = 1025;
      int v54 = v28;
      __int16 v55 = 2050;
      uint64_t v56 = v29;
      uint64_t v30 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934998,  0LL,  "@ClxStreamed, Send, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, speed, %{private}.1f, cou rse, %{private}.1f, type, %{public}d, alt, %{private}.1f, altunc, %{public}.1f,ellipsoidalAlt,%{pr ivate}.1f,speedUnc,%{private}.1f,courseUnc,%{private}.1f,signalEnv,%{private}d,timestamp,%{public}.3f",  &v31,  124);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStreamedLocationProvider::logGPS(const CLLocationProvider_Type::NotificationData &)",  "%s\n",  v30);
    }
  }

id sub_100240DAC(uint64_t a1)
{
  if (*(void *)(a1 + 192))
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    int v2 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v8 = 0;
      __int16 v9 = 2082;
      uint64_t v10 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#Multiclient attempting to create retry discovery timer while another one still exists}",  buf,  0x12u);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    int v3 = (os_log_s *)qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      *(_DWORD *)std::string buf = 68289026;
      int v8 = 0;
      __int16 v9 = 2082;
      uint64_t v10 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v3,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Multiclient attempting to create retry discovery timer while another one still exists",  "{msg%{public}.0s:#Multiclient attempting to create retry discovery timer while another one still exists}",  buf,  0x12u);
    }

    [*(id *)(a1 + 192) invalidate];

    *(void *)(a1 + 192) = 0LL;
  }

  id v4 = [*(id *)(a1 + 40) newTimer];
  *(void *)(a1 + 192) = v4;
  [v4 setNextFireDelay:1.79769313e308];
  [*(id *)(a1 + 192) setFireInterval:5.0];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_100240F94;
  void v6[3] = &unk_10181D3D0;
  _DWORD v6[4] = a1;
  return [*(id *)(a1 + 192) setHandler:v6];
}

id sub_100240F94(uint64_t a1)
{
  return sub_100240F9C(*(void *)(a1 + 32));
}

id sub_100240F9C(uint64_t a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  _DWORD v7[2] = sub_1002417F4;
  v7[3] = &unk_10182C088;
  _DWORD v7[4] = a1;
  if (*(_BYTE *)(a1 + 173))
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    int v2 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t buf = 68289026LL;
      __int16 v9 = 2082;
      uint64_t v10 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Multiclient looking for candidate streaming sources}",  (uint8_t *)&buf,  0x12u);
    }

    int v3 = *(void **)(a1 + 184);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472LL;
    _DWORD v6[2] = sub_100241D2C;
    void v6[3] = &unk_10182C0B0;
    _DWORD v6[4] = v7;
    void v6[5] = a1;
    return [v3 findCandidateServersWithCompletion:v6];
  }

  else
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    uint64_t v5 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
    {
      uint64_t buf = 68289026LL;
      __int16 v9 = 2082;
      uint64_t v10 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient skipping discovery because first unlock has yet to happen, but will retry in case we get unlocked}",  (uint8_t *)&buf,  0x12u);
    }

    return [*(id *)(a1 + 192) setNextFireDelay:5.0];
  }

id sub_100241178(uint64_t a1)
{
  if (*(void *)(a1 + 200))
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    int v2 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v8 = 0;
      __int16 v9 = 2082;
      uint64_t v10 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#Multiclient attempting to create reassert timer while another one still exists}",  buf,  0x12u);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    int v3 = (os_log_s *)qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v8 = 0;
      __int16 v9 = 2082;
      uint64_t v10 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v3,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Multiclient attempting to create reassert timer while another one still exists",  "{msg%{public}.0s:#Multiclient attempting to create reassert timer while another one still exists}",  buf,  0x12u);
    }

    [*(id *)(a1 + 200) invalidate];

    *(void *)(a1 + 20sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  }

  id v4 = [*(id *)(a1 + 40) newTimer];
  *(void *)(a1 + 20sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v4;
  [v4 setNextFireDelay:1.79769313e308];
  [*(id *)(a1 + 200) setFireInterval:15.0];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_100241360;
  void v6[3] = &unk_10181D3D0;
  _DWORD v6[4] = a1;
  return [*(id *)(a1 + 200) setHandler:v6];
}

_DWORD *sub_100241360(uint64_t a1)
{
  BOOL result = *(_DWORD **)(a1 + 32);
  if (result[34] == 3) {
    return sub_10024137C((uint64_t)result, 0LL);
  }
  return result;
}

id sub_10024137C(uint64_t a1, uint64_t a2)
{
  id v4 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  objc_msgSend( v4,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", a2),  @"kCLLocationStreamingMessageRapportLocationStreamingActionKey");
  else {
    uint64_t v5 = (NSNumber *)&__kCFBooleanFalse;
  }
  [v4 setObject:v5 forKeyedSubscript:@"kCLLocationStreamingMessageIncludeMotionKey"];
  int v13 = 28;
  else {
    uint64_t v6 = &__kCFBooleanFalse;
  }
  [v4 setObject:v6 forKeyedSubscript:@"kCLLocationStreamingMessageInFitnessSessionKey"];
  int v13 = 29;
  else {
    uint64_t v7 = &__kCFBooleanFalse;
  }
  [v4 setObject:v7 forKeyedSubscript:@"kCLLocationStreamingMessageActivityTypeAirborneKey"];
  if (*(_DWORD *)(a1 + 164)) {
    int v8 = &__kCFBooleanTrue;
  }
  else {
    int v8 = &__kCFBooleanFalse;
  }
  [v4 setObject:v8 forKeyedSubscript:@"kCLLocationStreamingMessageEmergencyEnablementKey"];
  int v13 = 17;
  else {
    __int16 v9 = &__kCFBooleanFalse;
  }
  [v4 setObject:v9 forKeyedSubscript:@"kCLLocationStreamingMessageMapMatching"];
  uint64_t v10 = *(void **)(a1 + 176);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  v12[2] = sub_1002424A4;
  void v12[3] = &unk_10182C0D0;
  v12[4] = a2;
  return [v10 sendRequestID:@"com.apple.locationd.rapport.stream-request" request:v4 destinationID:RPDestinationIdentifierDirectPeer options:0 responseHandler:v12];
}

void sub_10024155C(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 1 && *(_BYTE *)(a4 + 4) != 0)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    uint64_t v6 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
    {
      v7[0] = 68289026;
      v7[1] = 0;
      __int16 v8 = 2082;
      __int16 v9 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Multiclient got first unlock notification, now we can stream!}",  (uint8_t *)v7,  0x12u);
    }

    *(_BYTE *)(a1 + 173) = 1;
  }

void sub_100241650(id *a1, int a2)
{
  if (a2 == 3)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    int v3 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
    {
      int v5 = 68289026;
      int v6 = 0;
      __int16 v7 = 2082;
      __int16 v8 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient want to get best possible accuracy, and will request from nearby devices}",  (uint8_t *)&v5,  0x12u);
    }

    sub_100240DAC((uint64_t)a1);
    sub_100240F9C((uint64_t)a1);
  }

  else
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    id v4 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
    {
      int v5 = 68289026;
      int v6 = 0;
      __int16 v7 = 2082;
      __int16 v8 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient no longer need to stream because granularity no longer Best}",  (uint8_t *)&v5,  0x12u);
    }

    [a1[24] invalidate];

    a1[24] = 0LL;
    [a1[23] invalidateAndReleaseProbeClients];
    [a1[22] invalidate];

    a1[22] = 0LL;
  }

BOOL sub_1002417F4(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182C2F8);
  }
  id v4 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)uint64_t buf = 68289283;
    int v14 = 0;
    __int16 v15 = 2082;
    uint64_t v16 = "";
    __int16 v17 = 2081;
    id v18 = [a2 UTF8String];
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient registering a server, effectiveID:%{private, location:escape_only}s}",  buf,  0x1Cu);
  }

  id v5 = [*(id *)(v3 + 184) deviceWithEffectiveID:a2];
  if (v5)
  {
    [*(id *)(v3 + 192) invalidate];

    *(void *)(v3 + 192) = 0LL;
    int v6 = *(void **)(v3 + 40);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    v12[2] = sub_100241A9C;
    void v12[3] = &unk_10181FA90;
    v12[4] = v5;
    void v12[5] = v3;
    [v6 afterInterval:v12 async:1.0];
  }

  else
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    __int16 v7 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_ERROR))
    {
      id v8 = [a2 UTF8String];
      *(_DWORD *)uint64_t buf = 68289283;
      int v14 = 0;
      __int16 v15 = 2082;
      uint64_t v16 = "";
      __int16 v17 = 2081;
      id v18 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Multiclient failed to find any already-discovered device with ID, id:%{private, lo cation:escape_only}s}",  buf,  0x1Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    __int16 v9 = (os_log_s *)qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      id v10 = [a2 UTF8String];
      *(_DWORD *)uint64_t buf = 68289283;
      int v14 = 0;
      __int16 v15 = 2082;
      uint64_t v16 = "";
      __int16 v17 = 2081;
      id v18 = v10;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Multiclient failed to find any already-discovered device with ID",  "{msg%{public}.0s:#Multiclient failed to find any already-discovered device with ID, id:%{private, lo cation:escape_only}s}",  buf,  0x1Cu);
    }
  }

  return v5 != 0LL;
}

void sub_100241A9C(uint64_t a1)
{
}

void sub_100241AA8(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 176))
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    int v2 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_FAULT))
    {
      uint64_t buf = 68289026LL;
      __int16 v12 = 2082;
      int v13 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#Multiclient attempting to re-register streaming link, but we already have one}",  (uint8_t *)&buf,  0x12u);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    uint64_t v3 = (os_log_s *)qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      uint64_t buf = 68289026LL;
      __int16 v12 = 2082;
      int v13 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v3,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Multiclient attempting to re-register streaming link, but we already have one",  "{msg%{public}.0s:#Multiclient attempting to re-register streaming link, but we already have one}",  (uint8_t *)&buf,  0x12u);
    }
  }

  else
  {
    if (!a2) {
      sub_101231834();
    }
    *(void *)(a1 + 176) = objc_alloc_init(&OBJC_CLASS___RPCompanionLinkClient);
    objc_msgSend(*(id *)(a1 + 176), "setDispatchQueue:", objc_msgSend(*(id *)(a1 + 40), "queue"));
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    _DWORD v10[2] = sub_10024284C;
    void v10[3] = &unk_10181D3D0;
    v10[4] = a1;
    [*(id *)(a1 + 176) setInvalidationHandler:v10];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    _DWORD v9[2] = sub_100242938;
    v9[3] = &unk_10181D3D0;
    v9[4] = a1;
    [*(id *)(a1 + 176) setDisconnectHandler:v9];
    sub_1004F2598();
    if (sub_1004F5330())
    {
      [*(id *)(a1 + 176) setFlags:1];
      uint64_t v6 = 0x380000103C04LL;
    }

    else
    {
      uint64_t v6 = 65538LL;
    }

    [*(id *)(a1 + 176) setControlFlags:v6];
    [*(id *)(a1 + 176) setDestinationDevice:a2];
    __int16 v7 = *(void **)(a1 + 176);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    int v8[2] = sub_100242A38;
    void v8[3] = &unk_10181F6F8;
    _DWORD v8[4] = a1;
    [v7 activateWithCompletion:v8];
  }

void sub_100241D2C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(_DWORD *)(v2 + 136) != 3) {
    return;
  }
  if (![a2 count]) {
    goto LABEL_40;
  }
  uint64_t v32 = v2;
  id obj =  -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [a2 count]);
  __int16 v35 =  -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [a2 count]);
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  id v4 = [a2 countByEnumeratingWithState:&v46 objects:v66 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v37 = *(void *)v47;
    while (2)
    {
      uint64_t v6 = 0LL;
      do
      {
        if (*(void *)v47 != v37) {
          objc_enumerationMutation(a2);
        }
        __int16 v7 = *(void **)(*((void *)&v46 + 1) + 8LL * (void)v6);
        id v8 = objc_msgSend(a2, "objectForKeyedSubscript:", v7, v32);
        unsigned int v9 = objc_msgSend( objc_msgSend( v8,  "objectForKeyedSubscript:",  @"kCLLocationStreamingMessageRapportHasGPSKey"),  "BOOLValue");
        unsigned int v10 = objc_msgSend( objc_msgSend( v8,  "objectForKeyedSubscript:",  @"kCLLocationStreamingMessageRapportIsPhoneKey"),  "BOOLValue");
        unsigned int v11 = objc_msgSend( objc_msgSend( v8,  "objectForKeyedSubscript:",  @"kCLLocationStreamingMessageRapportIsPadKey"),  "BOOLValue");
        if ([v8 objectForKeyedSubscript:@"kCLLocationStreamingMessageRapportIsAtLeast16_4"]) {
          unsigned int v12 = objc_msgSend( objc_msgSend( v8,  "objectForKeyedSubscript:",  @"kCLLocationStreamingMessageRapportIsAtLeast16_4"),  "BOOLValue");
        }
        else {
          unsigned int v12 = 0;
        }
        if (qword_101934990 != -1) {
          dispatch_once(&qword_101934990, &stru_10182C2F8);
        }
        int v13 = (os_log_s *)qword_101934998;
        if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
        {
          id v14 = [v7 UTF8String];
          *(_DWORD *)uint64_t buf = 68290306;
          int v53 = 0;
          __int16 v54 = 2082;
          __int16 v55 = "";
          __int16 v56 = 2082;
          uint64_t v57 = (uint64_t)v14;
          __int16 v58 = 1026;
          unsigned int v59 = v9;
          __int16 v60 = 1026;
          unsigned int v61 = v10;
          __int16 v62 = 1026;
          unsigned int v63 = v11;
          __int16 v64 = 1026;
          unsigned int v65 = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient candidate device, deviceID:%{public, location:escape_only}s, has GPS?:%{public}hhd, isIphone:%{public}hhd, isIpad:%{public}hhd, atLeast16_4:%{public}hhd}",  buf,  0x34u);
        }

        if ((v12 & v9) == 1)
        {
          if (v10 && (*(unsigned int (**)(void))(*(void *)(a1 + 32) + 16LL))())
          {
            if (qword_101934990 != -1) {
              dispatch_once(&qword_101934990, &stru_10182C2F8);
            }
            uint64_t v27 = (os_log_s *)qword_101934998;
            if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
            {
              id v28 = [v7 UTF8String];
              *(_DWORD *)uint64_t buf = 68289282;
              int v53 = 0;
              __int16 v54 = 2082;
              __int16 v55 = "";
              __int16 v56 = 2082;
              uint64_t v57 = (uint64_t)v28;
              uint64_t v29 = "{msg%{public}.0s:#Multiclient selected an iPhone, deviceID:%{public, location:escape_only}s}";
LABEL_57:
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_INFO, v29, buf, 0x1Cu);
            }

            return;
          }

          if (v11) {
            __int16 v15 = obj;
          }
          else {
            __int16 v15 = v35;
          }
          -[NSMutableArray addObject:](v15, "addObject:", v7);
        }

        uint64_t v6 = (char *)v6 + 1;
      }

      while (v5 != v6);
      id v5 = [a2 countByEnumeratingWithState:&v46 objects:v66 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }

  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  id v16 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v42,  v51,  16LL,  v32);
  uint64_t v2 = v33;
  if (!v16)
  {
LABEL_32:
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    id v21 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v35,  "countByEnumeratingWithState:objects:count:",  &v38,  v50,  16LL);
    if (v21)
    {
      id v22 = v21;
      uint64_t v23 = *(void *)v39;
LABEL_34:
      uint64_t v24 = 0LL;
      while (1)
      {
        if (*(void *)v39 != v23) {
          objc_enumerationMutation(v35);
        }
        uint64_t v25 = *(void **)(*((void *)&v38 + 1) + 8 * v24);
        if (v22 == (id)++v24)
        {
          id v22 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v35,  "countByEnumeratingWithState:objects:count:",  &v38,  v50,  16LL);
          if (v22) {
            goto LABEL_34;
          }
          goto LABEL_40;
        }
      }

      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
      uint64_t v27 = (os_log_s *)qword_101934998;
      if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
      {
        id v31 = [v25 UTF8String];
        *(_DWORD *)uint64_t buf = 68289282;
        int v53 = 0;
        __int16 v54 = 2082;
        __int16 v55 = "";
        __int16 v56 = 2082;
        uint64_t v57 = (uint64_t)v31;
        uint64_t v29 = "{msg%{public}.0s:#Multiclient selected a non-iOS device, deviceID:%{public, location:escape_only}s}";
        goto LABEL_57;
      }

      return;
    }

uint64_t sub_1002423D8(uint64_t a1)
{
  uint64_t v1 = qword_101993D50;
  if (!qword_101993D50) {
    return 0LL;
  }
  uint64_t v2 = (uint64_t **)(a1 + 56);
  while (1)
  {
    int v9 = *(_DWORD *)(v1 + 16);
    unsigned int v10 = &v9;
    uint64_t v3 = sub_10023347C(v2, &v9, (uint64_t)&unk_1012CF090, &v10);
    id v4 = v3[5];
LABEL_11:
    uint64_t v1 = *(void *)v1;
    if (!v1) {
      return 0LL;
    }
  }

  while (!*((_BYTE *)v4 + 57))
  {
    id v5 = (uint64_t *)v4[1];
    if (v5)
    {
      do
      {
        uint64_t v6 = (uint64_t **)v5;
        id v5 = (uint64_t *)*v5;
      }

      while (v5);
    }

    else
    {
      do
      {
        uint64_t v6 = (uint64_t **)v4[2];
        BOOL v7 = *v6 == v4;
        id v4 = (uint64_t *)v6;
      }

      while (!v7);
    }

    id v4 = (uint64_t *)v6;
    if (v6 == v3 + 6) {
      goto LABEL_11;
    }
  }

  return 1LL;
}

void sub_1002424A4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  if (a4
    || ![a2 objectForKeyedSubscript:@"kCLLocationStreamingMessageRapportLocationStreamingActionKey"])
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    uint64_t v6 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_ERROR))
    {
      int v17 = 68289539;
      int v18 = 0;
      __int16 v19 = 2082;
      uint64_t v20 = "";
      __int16 v21 = 2114;
      uint64_t v22 = a4;
      __int16 v23 = 2113;
      uint64_t v24 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Multiclient failed to send streaming action event, error:%{public, location:escape _only}@, resp:%{private, location:escape_only}@}",  (uint8_t *)&v17,  0x26u);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    uint64_t v7 = qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      int v17 = 68289539;
      int v18 = 0;
      __int16 v19 = 2082;
      uint64_t v20 = "";
      __int16 v21 = 2114;
      uint64_t v22 = a4;
      __int16 v23 = 2113;
      uint64_t v24 = a2;
      id v8 = "#Multiclient failed to send streaming action event";
      int v9 = "{msg%{public}.0s:#Multiclient failed to send streaming action event, error:%{public, location:esc"
           "ape_only}@, resp:%{private, location:escape_only}@}";
      unsigned int v10 = (os_log_s *)v7;
      uint32_t v11 = 38;
LABEL_9:
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v8,  v9,  (uint8_t *)&v17,  v11);
    }
  }

  else
  {
    uint64_t v13 = (int)objc_msgSend( objc_msgSend( a2,  "objectForKeyedSubscript:",  @"kCLLocationStreamingMessageRapportLocationStreamingActionKey"),  "intValue");
    if (*(void *)(a1 + 32) == v13)
    {
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
      id v14 = (os_log_s *)qword_101934998;
      if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
      {
        int v17 = 68289282;
        int v18 = 0;
        __int16 v19 = 2082;
        uint64_t v20 = "";
        __int16 v21 = 2050;
        uint64_t v22 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient action OK, action:%{public, location:CLLocationMultiStreamingAction}lld}",  (uint8_t *)&v17,  0x1Cu);
      }

      return;
    }

    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    __int16 v15 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_FAULT))
    {
      int v17 = 68289282;
      int v18 = 0;
      __int16 v19 = 2082;
      uint64_t v20 = "";
      __int16 v21 = 2050;
      uint64_t v22 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:#Multiclient unexpected action returned in response to request, action:%{public, lo cation:CLLocationMultiStreamingAction}lld}",  (uint8_t *)&v17,  0x1Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    uint64_t v16 = qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      int v17 = 68289282;
      int v18 = 0;
      __int16 v19 = 2082;
      uint64_t v20 = "";
      __int16 v21 = 2050;
      uint64_t v22 = v13;
      id v8 = "#Multiclient unexpected action returned in response to request";
      int v9 = "{msg%{public}.0s:#Multiclient unexpected action returned in response to request, action:%{public,"
           " location:CLLocationMultiStreamingAction}lld}";
      unsigned int v10 = (os_log_s *)v16;
      uint32_t v11 = 28;
      goto LABEL_9;
    }
  }

id sub_10024284C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182C2F8);
  }
  uint64_t v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    __int16 v5 = 2082;
    uint64_t v6 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Multiclient invalidating server streaming link}",  (uint8_t *)v4,  0x12u);
  }

  sub_10024137C(v1, 1LL);
  return [*(id *)(v1 + 184) invalidateAndReleaseProbeClients];
}

uint64_t sub_100242938(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_10182C318);
  }
  uint64_t v2 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    __int16 v5 = 2082;
    uint64_t v6 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Multiclient streamer got disconnected, invalidating connection and setup new discovery.}",  (uint8_t *)v4,  0x12u);
  }

  [*(id *)(v1 + 184) invalidateAndReleaseProbeClients];
  [*(id *)(v1 + 176) invalidate];

  *(void *)(v1 + 176) = 0LL;
  return sub_100241650(v1, *(unsigned int *)(v1 + 136));
}

void sub_100242A38(uint64_t a1, void *a2)
{
  if (a2)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    uint64_t v3 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      int v19 = 0;
      __int16 v20 = 2082;
      __int16 v21 = "";
      __int16 v22 = 2114;
      id v23 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Multiclient failed to activate streaming link, error:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    id v4 = (os_log_s *)qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      int v19 = 0;
      __int16 v20 = 2082;
      __int16 v21 = "";
      __int16 v22 = 2114;
      id v23 = a2;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Multiclient failed to activate streaming link",  "{msg%{public}.0s:#Multiclient failed to activate streaming link, error:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }
  }

  else
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    uint64_t v6 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
    {
      id v7 = objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(v5 + 176), "destinationDevice"), "effectiveIdentifier"),  "UTF8String");
      *(_DWORD *)uint64_t buf = 68289283;
      int v19 = 0;
      __int16 v20 = 2082;
      __int16 v21 = "";
      __int16 v22 = 2081;
      id v23 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient streaming client good to go!, remoteID:%{private, location:escape_only}s}",  buf,  0x1Cu);
    }

    sub_1004F2598();
    if (sub_1004F5330())
    {
      v16[0] = RPOptionInterest;
      v16[1] = RPOptionAllowUnauthenticated;
      v17[0] = &__kCFBooleanTrue;
      v17[1] = &__kCFBooleanTrue;
      id v8 = (void **)v17;
      int v9 = v16;
      uint64_t v10 = 2LL;
    }

    else
    {
      uint64_t v14 = RPOptionInterest;
      __int16 v15 = &__kCFBooleanTrue;
      id v8 = &v15;
      int v9 = &v14;
      uint64_t v10 = 1LL;
    }

    uint32_t v11 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v8,  v9,  v10);
    unsigned int v12 = *(void **)(v5 + 176);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472LL;
    _DWORD v13[2] = sub_100242D44;
    void v13[3] = &unk_10182C0F0;
    v13[4] = v5;
    [v12 registerEventID:@"com.apple.locationd.rapport.stream-event" options:v11 handler:v13];
    sub_10024137C(v5, 0LL);
    sub_100241178(v5);
    [*(id *)(v5 + 200) setNextFireDelay:15.0];
  }

void sub_100242D44(uint64_t a1, void *a2)
{
  uint64_t v3 = *(id **)(a1 + 32);
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182C2F8);
  }
  id v4 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
  {
    v5[0] = 68289283;
    v5[1] = 0;
    __int16 v6 = 2082;
    id v7 = "";
    __int16 v8 = 2113;
    int v9 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient got a location from our client!, message:%{private, location:escape_only}@}",  (uint8_t *)v5,  0x1Cu);
  }

  sub_100242E40(v3, a2);
}

void sub_100242E40(id *a1, void *a2)
{
  id v4 = -[NSKeyedUnarchiver decodeObjectOfClass:forKey:](  -[NSKeyedUnarchiver initForReadingFromData:error:]( [NSKeyedUnarchiver alloc],  "initForReadingFromData:error:",  [a2 objectForKeyedSubscript:@"kCLLocationStreamingMessageLocationKey"],  0),  "decodeObjectOfClass:forKey:",  objc_opt_class(CLLocation),  @"kCLLocationStreamingMessageLocationKey");
  id v5 = [a2 objectForKeyedSubscript:@"kCLLocationStreamingMessageInMotionKey"];
  id v6 = [a2 objectForKeyedSubscript:@"kCLLocationStreamingMessageLocationPrivateKey"];
  id v7 = [a2 objectForKeyedSubscript:@"kCLLocationStreamingMessageLocationInternalKey"];
  if (v4)
  {
    id v8 = v7;
    [v4 clientLocation];
    double v9 = *(double *)&__src[88];
    [v4 clientLocation];
    if (*(double *)&__src[88] <= 0.0)
    {
      double v10 = 15.0;
    }

    else
    {
      objc_msgSend(v4, "clientLocation", *(double *)&__src[88]);
      if (*(_DWORD *)&__src[96] == 1 || ([v4 clientLocation], (_DWORD)v43 == 9))
      {
      }

      [v4 clientLocation];
      double v10 = v9 + *(double *)&__src[76] - CFAbsoluteTimeGetCurrent();
    }

    if (v10 > 0.0)
    {
      sub_100246564((uint64_t)v42);
      id v16 = [v4 clientLocation];
      __int128 v43 = *(_OWORD *)&__src[96];
      __int128 v44 = *(_OWORD *)&__src[112];
      *(_OWORD *)__int128 v45 = *(_OWORD *)&__src[128];
      *(_OWORD *)&v45[12] = *(_OWORD *)&__src[140];
      *(_OWORD *)&v42[32] = *(_OWORD *)&__src[32];
      *(_OWORD *)&v42[48] = *(_OWORD *)&__src[48];
      *(_OWORD *)&v42[64] = *(_OWORD *)&__src[64];
      *(_OWORD *)&v42[80] = *(_OWORD *)&__src[80];
      *(_OWORD *)__int128 v42 = *(_OWORD *)__src;
      *(_OWORD *)&v42[16] = *(_OWORD *)&__src[16];
      if (v5)
      {
        id v16 = [v5 BOOLValue];
        if ((_DWORD)v16) {
          int v17 = 1;
        }
        else {
          int v17 = 2;
        }
      }

      else
      {
        int v17 = 0;
      }

      int v57 = v17;
      if (v6)
      {
        __int16 v20 =  -[CLStreamedLocationPrivate initWithData:]( objc_alloc(&OBJC_CLASS___CLStreamedLocationPrivate),  "initWithData:",  v6);
        if (v20)
        {
          -[CLStreamedLocationPrivate daemonLocationPrivate](v20, "daemonLocationPrivate");
          __int128 v21 = v77;
        }

        else
        {
          bzero(__src, 0x280uLL);
          __int128 v21 = 0uLL;
        }

        __int128 v41 = v21;
        id v16 = memcpy(v46, __src, 0x201uLL);
        __int128 v77 = 0u;
        __int16 v22 = (std::__shared_weak_count *)*((void *)&v47 + 1);
        __int128 v47 = v41;
        if (v22)
        {
          p_shared_owners = (unint64_t *)&v22->__shared_owners_;
          do
            unint64_t v24 = __ldaxr(p_shared_owners);
          while (__stlxr(v24 - 1, p_shared_owners));
          if (!v24)
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }

        __int128 v52 = v82;
        v53[0] = v83[0];
        *(void *)((char *)v53 + 13) = *(void *)((char *)v83 + 13);
        __int128 v48 = v78;
        __int128 v49 = v79;
        __int128 v50 = v80;
        __int128 v51 = v81;
        uint64_t v25 = (std::__shared_weak_count *)*((void *)&v77 + 1);
        if (*((void *)&v77 + 1))
        {
          uint64_t v26 = (unint64_t *)(*((void *)&v77 + 1) + 8LL);
          do
            unint64_t v27 = __ldaxr(v26);
          while (__stlxr(v27 - 1, v26));
          if (!v27)
          {
            ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
            std::__shared_weak_count::__release_weak(v25);
          }
        }
      }

      if (v8)
      {
        id v28 = -[CLStreamedLocationInternal initWithData:]( objc_alloc(&OBJC_CLASS___CLStreamedLocationInternal),  "initWithData:",  v8);
        -[CLStreamedLocationInternal mergeIntoDaemonLocation:](v28, "mergeIntoDaemonLocation:", v42);
      }

      v46[88] = 2;
      sub_100240AA8((uint64_t)v16, (uint64_t)v42);
      *(_DWORD *)__src = 9;
      (*((void (**)(id *, _BYTE *))*a1 + 15))(a1, __src);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_10182C338);
      }
      uint64_t v29 = (os_log_s *)qword_101934858;
      if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__src = 134286593;
        *(void *)&__src[4] = *(void *)&v42[4];
        *(_WORD *)&__src[12] = 2049;
        *(void *)&__src[14] = *(void *)&v42[12];
        *(_WORD *)&__src[22] = 2050;
        *(void *)&__src[24] = *(void *)&v42[20];
        *(_WORD *)&__src[32] = 2049;
        *(void *)&__src[34] = *(void *)&v42[44];
        *(_WORD *)&__src[42] = 2049;
        *(void *)&__src[44] = *(void *)&v42[60];
        *(_WORD *)&__src[52] = 1026;
        *(_DWORD *)&__src[54] = v43;
        *(_WORD *)&__src[58] = 2049;
        *(void *)&__src[60] = *(void *)&v42[28];
        *(_WORD *)&__src[68] = 2050;
        *(void *)&__src[70] = *(void *)&v42[36];
        *(_WORD *)&__src[78] = 2049;
        *(void *)&__src[80] = *(void *)&v45[16];
        *(_WORD *)&__src[88] = 2049;
        *(void *)&__src[90] = *(void *)&v42[52];
        *(_WORD *)&__src[98] = 2049;
        *(void *)&__src[100] = *(void *)&v42[68];
        *(_WORD *)&__src[108] = 1025;
        *(_DWORD *)&__src[110] = *(_DWORD *)&v45[12];
        *(_WORD *)&__src[114] = 2050;
        *(void *)&__src[116] = *(void *)&v42[76];
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "@ClxStreamed, Fix, 1, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, speed, %{private}.1f, course, %{pri vate}.1f, type, %{public}d, alt, %{private}.1f, altunc, %{public}.1f,ellipsoidalAlt,%{private}.1f,speedUnc,%{p rivate}.1f,courseUnc,%{private}.1f,signalEnv,%{private}d,timestamp,%{public}.3f",  __src,  0x7Cu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(__src, 0x65CuLL);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_10182C338);
        }
        *(_DWORD *)uint64_t buf = 134286593;
        *(void *)unsigned int v61 = *(void *)&v42[4];
        *(_WORD *)&v61[8] = 2049;
        *(void *)&v61[10] = *(void *)&v42[12];
        *(_WORD *)&v61[18] = 2050;
        *(void *)&v61[20] = *(void *)&v42[20];
        *(_WORD *)&v61[28] = 2049;
        *(void *)&v61[30] = *(void *)&v42[44];
        *(_WORD *)&v61[38] = 2049;
        *(void *)&v61[40] = *(void *)&v42[60];
        *(_WORD *)&v61[48] = 1026;
        int v62 = v43;
        __int16 v63 = 2049;
        uint64_t v64 = *(void *)&v42[28];
        __int16 v65 = 2050;
        uint64_t v66 = *(void *)&v42[36];
        __int16 v67 = 2049;
        uint64_t v68 = *(void *)&v45[16];
        __int16 v69 = 2049;
        *(void *)uint64_t v70 = *(void *)&v42[52];
        *(_WORD *)&v70[8] = 2049;
        uint64_t v71 = *(void *)&v42[68];
        __int16 v72 = 1025;
        int v73 = *(_DWORD *)&v45[12];
        __int16 v74 = 2050;
        uint64_t v75 = *(void *)&v42[76];
        __int128 v40 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __src,  1628LL,  &_mh_execute_header,  qword_101934858,  0LL,  "@ClxStreamed, Fix, 1, ll, %{private}.7f, %{private}.7f, acc, %{public}.2f, speed, %{private}.1f, course, %{private}.1f, type, %{public}d, alt, %{private}.1f, altunc, %{public}.1f,ellipsoidalAl t,%{private}.1f,speedUnc,%{private}.1f,courseUnc,%{private}.1f,signalEnv,%{private}d,timestamp,%{public}.3f",  buf,  124);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStreamedLocationProvider::handleLocationMessage(NSDictionary *)",  "%s\n",  v40);
        if (v40 != __src) {
          free(v40);
        }
      }

      *(_DWORD *)__src = 0;
      (*((void (**)(id *, _BYTE *, _BYTE *, uint64_t, uint64_t, void))*a1 + 19))( a1,  __src,  v42,  1LL,  0xFFFFFFFFLL,  0LL);
      [v4 clientLocation];
      if (*(_DWORD *)&__src[96] == 1)
      {
        double v30 = 4.0;
      }

      else
      {
        [v4 clientLocation];
        double v30 = 5.0;
        if (*(_DWORD *)&v70[6] == 9) {
          double v30 = 4.0;
        }
      }

      if (v10 > v30) {
        double v30 = v10;
      }
      [a1[19] setNextFireDelay:v30];

      id v31 = v58;
      if (v58)
      {
        uint64_t v32 = (unint64_t *)&v58->__shared_owners_;
        do
          unint64_t v33 = __ldaxr(v32);
        while (__stlxr(v33 - 1, v32));
        if (!v33)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
        }
      }

      if (v56 < 0) {
        operator delete(__p);
      }
      uint64_t v34 = v54;
      if (v54)
      {
        __int16 v35 = (unint64_t *)&v54->__shared_owners_;
        do
          unint64_t v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }

      uint64_t v37 = (std::__shared_weak_count *)*((void *)&v47 + 1);
      if (*((void *)&v47 + 1))
      {
        __int128 v38 = (unint64_t *)(*((void *)&v47 + 1) + 8LL);
        do
          unint64_t v39 = __ldaxr(v38);
        while (__stlxr(v39 - 1, v38));
        if (!v39)
        {
          ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
          std::__shared_weak_count::__release_weak(v37);
        }
      }

      return;
    }

    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    uint64_t v18 = qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
    {
      [v4 clientLocation];
      uint64_t v19 = *(void *)&__src[76];
      [v4 clientLocation];
      *(_DWORD *)uint64_t buf = 68290050;
      *(_WORD *)&v61[4] = 2082;
      *(_DWORD *)unsigned int v61 = 0;
      *(void *)&v61[6] = "";
      *(_WORD *)&v61[14] = 2050;
      *(void *)&v61[16] = v19;
      *(_WORD *)&v61[24] = 2050;
      *(double *)&v61[26] = v9;
      *(_WORD *)&v61[34] = 2050;
      *(double *)&v61[36] = v10;
      *(_WORD *)&v61[44] = 1026;
      *(_DWORD *)&v61[46] = v43;
      unsigned int v12 = "{msg%{public}.0s:Dropping expired location, timestamp:%{public}f, timeout:%{public}f"
            ", timeLeft:%{public}f, type:%{public}d}";
      uint64_t v13 = buf;
      uint64_t v14 = (os_log_s *)v18;
      uint32_t v15 = 54;
      goto LABEL_22;
    }
  }

  else
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    uint64_t v11 = qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)__src = 68289283LL;
      *(_WORD *)&__src[8] = 2082;
      *(void *)&__src[10] = "";
      *(_WORD *)&__src[18] = 2113;
      *(void *)&__src[20] = a2;
      unsigned int v12 = "{msg%{public}.0s:Missing data, payload:%{private, location:escape_only}@}";
      uint64_t v13 = __src;
      uint64_t v14 = (os_log_s *)v11;
      uint32_t v15 = 28;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v12, v13, v15);
    }
  }

void sub_100243718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100243768(uint64_t a1)
{
  return a1;
}

void sub_100243E2C(id a1, RPCompanionLinkDevice *a2)
{
  if (-[RPCompanionLinkDevice model](a2, "model")) {
    uint64_t v3 = (const char *)objc_msgSend(-[RPCompanionLinkDevice model](a2, "model"), "UTF8String");
  }
  else {
    uint64_t v3 = "Unknown Model";
  }
  if (-[RPCompanionLinkDevice name](a2, "name")) {
    id v4 = (const char *)objc_msgSend(-[RPCompanionLinkDevice name](a2, "name"), "UTF8String");
  }
  else {
    id v4 = "Unknown Name";
  }
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182C2F8);
  }
  id v5 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEBUG))
  {
    unsigned int v6 = (-[RPCompanionLinkDevice statusFlags](a2, "statusFlags") >> 24) & 1;
    if (a2)
    {
      -[RPCompanionLinkDevice operatingSystemVersion](a2, "operatingSystemVersion");
      uint64_t v7 = v13;
      -[RPCompanionLinkDevice operatingSystemVersion](a2, "operatingSystemVersion");
      uint64_t v8 = v11;
    }

    else
    {
      uint64_t v8 = 0LL;
      uint64_t v7 = 0LL;
      uint64_t v13 = 0LL;
      uint64_t v14 = 0LL;
      uint64_t v15 = 0LL;
      uint64_t v10 = 0LL;
      uint64_t v11 = 0LL;
      uint64_t v12 = 0LL;
    }

    id v9 = objc_msgSend( -[RPCompanionLinkDevice effectiveIdentifier](a2, "effectiveIdentifier", v10, v11, v12, v13, v14, v15),  "UTF8String");
    *(_DWORD *)uint64_t buf = 68290563;
    int v17 = 0;
    __int16 v18 = 2082;
    uint64_t v19 = "";
    __int16 v20 = 2082;
    __int128 v21 = v3;
    __int16 v22 = 2081;
    id v23 = v4;
    __int16 v24 = 1026;
    unsigned int v25 = v6;
    __int16 v26 = 2050;
    uint64_t v27 = v7;
    __int16 v28 = 2050;
    uint64_t v29 = v8;
    __int16 v30 = 2082;
    id v31 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#Multiclient listener found nearby device, model:%{public, location:escape_only}s,  name:%{private, location:escape_only}s, USB?:%{public}hhd, major:%{public}ld, minor:%{public}ld, e ffectiveID:%{public, location:escape_only}s}",  buf,  0x4Au);
  }

void sub_100244000(id a1, RPCompanionLinkDevice *a2)
{
  if (-[RPCompanionLinkDevice model](a2, "model")) {
    uint64_t v3 = (const char *)objc_msgSend(-[RPCompanionLinkDevice model](a2, "model"), "UTF8String");
  }
  else {
    uint64_t v3 = "Unknown Model";
  }
  if (-[RPCompanionLinkDevice name](a2, "name")) {
    id v4 = (const char *)objc_msgSend(-[RPCompanionLinkDevice name](a2, "name"), "UTF8String");
  }
  else {
    id v4 = "Unknown Name";
  }
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182C2F8);
  }
  id v5 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEBUG))
  {
    v6[0] = 68289795;
    v6[1] = 0;
    __int16 v7 = 2082;
    uint64_t v8 = "";
    __int16 v9 = 2082;
    uint64_t v10 = v3;
    __int16 v11 = 2081;
    uint64_t v12 = v4;
    __int16 v13 = 2082;
    id v14 = objc_msgSend(-[RPCompanionLinkDevice effectiveIdentifier](a2, "effectiveIdentifier"), "UTF8String");
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#Multiclient listener lost contact with nearby device, model:%{public, location:escap e_only}s, name:%{private, location:escape_only}s, effectiveID:%{public, location:escape_only}s}",  (uint8_t *)v6,  0x30u);
  }

void sub_100244158(id a1, NSError *a2)
{
  if (a2)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    uint64_t v3 = qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 68289282;
      int v10 = 0;
      __int16 v11 = 2082;
      uint64_t v12 = "";
      __int16 v13 = 2114;
      id v14 = a2;
      id v4 = "{msg%{public}.0s:#Multiclient failed to setup nearby device listener, error:%{public, location:escape_only}@}";
      id v5 = (os_log_s *)v3;
      os_log_type_t v6 = OS_LOG_TYPE_DEFAULT;
      uint32_t v7 = 28;
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v5, v6, v4, (uint8_t *)&v9, v7);
    }
  }

  else
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    uint64_t v8 = qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
    {
      int v9 = 68289026;
      int v10 = 0;
      __int16 v11 = 2082;
      uint64_t v12 = "";
      id v4 = "{msg%{public}.0s:#Multiclient nearby device listener ready}";
      id v5 = (os_log_s *)v8;
      os_log_type_t v6 = OS_LOG_TYPE_INFO;
      uint32_t v7 = 18;
      goto LABEL_10;
    }
  }

void sub_100244FBC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    uint64_t v2 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v12 = 0;
      __int16 v13 = 2082;
      id v14 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Multiclient probe client failed to register}",  buf,  0x12u);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    uint64_t v3 = (os_log_s *)qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      int v12 = 0;
      __int16 v13 = 2082;
      id v14 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v3,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Multiclient probe client failed to register",  "{msg%{public}.0s:#Multiclient probe client failed to register}",  buf,  0x12u);
    }
  }

  else
  {
    id v5 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "destinationDevice"), "effectiveIdentifier");
    id v6 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "destinationDevice"), "name");
    uint32_t v7 = (dispatch_queue_s *)[*(id *)(a1 + 40) requestQ];
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    int v8[2] = sub_1002451A8;
    void v8[3] = &unk_10182C1E0;
    _DWORD v8[4] = v5;
    void v8[5] = v6;
    v8[6] = *(void *)(a1 + 32);
    __int128 v9 = *(_OWORD *)(a1 + 48);
    uint64_t v10 = *(void *)(a1 + 64);
    dispatch_async(v7, v8);
  }

id sub_1002451A8(uint64_t a1)
{
  if (qword_101934990 != -1) {
    dispatch_once(&qword_101934990, &stru_10182C2F8);
  }
  uint64_t v2 = (os_log_s *)qword_101934998;
  if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
  {
    id v3 = [*(id *)(a1 + 32) UTF8String];
    id v4 = [*(id *)(a1 + 40) UTF8String];
    *(_DWORD *)uint64_t buf = 68289539;
    int v13 = 0;
    __int16 v14 = 2082;
    uint64_t v15 = "";
    __int16 v16 = 2082;
    id v17 = v3;
    __int16 v18 = 2081;
    id v19 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient probing potential server, remote:%{public, location:escape_only}s, nam e:%{private, location:escape_only}s}",  buf,  0x26u);
  }

  id v5 = *(void **)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  _DWORD v9[2] = sub_100245314;
  v9[3] = &unk_10182C1B8;
  int8x16_t v10 = vextq_s8(*(int8x16_t *)(a1 + 32), *(int8x16_t *)(a1 + 32), 8uLL);
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v11 = *(void *)(a1 + 72);
  return [v5 sendRequestID:@"com.apple.locationd.rapport.availability-interest" request:v6 destinationID:RPDestinationIdentifierDirectPeer options:v7 responseHandler:v9];
}

void sub_100245314(id *a1, uint64_t a2, void *a3, void *a4)
{
  if (a4)
  {
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    id v5 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_ERROR))
    {
      int v16 = 68289282;
      int v17 = 0;
      __int16 v18 = 2082;
      id v19 = "";
      __int16 v20 = 2082;
      id v21 = objc_msgSend(objc_msgSend(a4, "description"), "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Multiclient error invoking interest request, error:%{public, location:escape_only}s}",  (uint8_t *)&v16,  0x1Cu);
      if (qword_101934990 != -1) {
        dispatch_once(&qword_101934990, &stru_10182C2F8);
      }
    }

    uint64_t v6 = (os_log_s *)qword_101934998;
    if (os_signpost_enabled((os_log_t)qword_101934998))
    {
      id v7 = objc_msgSend(objc_msgSend(a4, "description"), "UTF8String");
      int v16 = 68289282;
      int v17 = 0;
      __int16 v18 = 2082;
      id v19 = "";
      __int16 v20 = 2082;
      id v21 = v7;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Multiclient error invoking interest request",  "{msg%{public}.0s:#Multiclient error invoking interest request, error:%{public, location:escape_only}s}",  (uint8_t *)&v16,  0x1Cu);
    }
  }

  else
  {
    id v11 = [a3 objectForKeyedSubscript:RPOptionSenderID];
    int v12 = +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  a2);
    -[NSMutableDictionary addEntriesFromDictionary:](v12, "addEntriesFromDictionary:", a3);
    if (qword_101934990 != -1) {
      dispatch_once(&qword_101934990, &stru_10182C2F8);
    }
    int v13 = (os_log_s *)qword_101934998;
    if (os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_INFO))
    {
      id v14 = [a1[4] UTF8String];
      id v15 = [a1[5] UTF8String];
      int v16 = 68289795;
      int v17 = 0;
      __int16 v18 = 2082;
      id v19 = "";
      __int16 v20 = 2081;
      id v21 = v14;
      __int16 v22 = 2082;
      id v23 = v15;
      __int16 v24 = 2114;
      unsigned int v25 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Multiclient received availability response, name:%{private, location:escape_only}s , remote:%{public, location:escape_only}s, resp:%{public, location:escape_only}@}",  (uint8_t *)&v16,  0x30u);
    }

    [a1[6] setObject:v12 forKeyedSubscript:v11];
  }

uint64_t sub_1002455BC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

void sub_10024560C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLStreamedLocationProvider");
  sub_10047D890((uint64_t)v8, (uint64_t *)__p, a3, a1, a2);
  void *v8 = &off_10182C260;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002456A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1002456D0(void *a1)
{
  *a1 = off_10182BF50;
  uint64_t v2 = a1[15];
  a1[15] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return sub_10047A1C0(a1);
}

void sub_100245714(void *a1)
{
  *a1 = off_10182BF50;
  uint64_t v2 = a1[15];
  a1[15] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  id v3 = (void *)sub_10047A1C0(a1);
  operator delete(v3);
}

void sub_10024575C(uint64_t a1, uint64_t a2)
{
  HIDWORD(v14) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        __int128 v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)uint64_t buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v14 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182C2D8);
      }
      char v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        id v11 = (void *)(a1 + 8);
        *(_DWORD *)uint64_t buf = 136446466;
        __int16 v20 = v11;
        __int16 v21 = 1026;
        int v22 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_10182C2D8);
        }
        int v12 = (void *)(a1 + 8);
        int v15 = 136446466;
        int v16 = v12;
        __int16 v17 = 1026;
        int v18 = a2;
        LODWORD(v14) = 18;
        int v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                        &v15,
                        v14);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char , CLLocationProvider_Type::RegInfo>::removeClient(int) [Notification_T = CLLocationProvider_Type::Notification , NotificationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_ T = CLLocationProvider_Type::RegInfo]",  "%s\n",  v13);
      }
    }
  }

uint64_t sub_1002459D0(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  id v7 = sub_10024769C(a4);
  if (v7)
  {
    int v10 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *, id))(*(void *)a1 + 96LL))(a1, a2, &v10, v7);
  }

  else
  {
    int v9 = a3;
    return (*(uint64_t (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 88LL))(a1, a2, &v9);
  }

BOOL sub_100245A50(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      int v9 = (uint64_t *)v5;
    }
    else {
      int v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        __int16 v21 = (uint64_t *)v15;
      }
      else {
        __int16 v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182C2D8);
    }
    int v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      id v11 = (void *)(a1 + 8);
      *(_DWORD *)uint64_t buf = 136446466;
      uint64_t v29 = v11;
      __int16 v30 = 1026;
      int v31 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182C2D8);
      }
      int v22 = (void *)(a1 + 8);
      int v24 = 136446466;
      unsigned int v25 = v22;
      __int16 v26 = 1026;
      int v27 = a2;
      id v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                      &v24,
                      18);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char, CLLocationProvider_Type::RegInfo>::clientRegistered(int, const Notification_T &) [Notification_T = CLLocationPro vider_Type::Notification, NotificationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = c har, RegistrationInfo_T = CLLocationProvider_Type::RegInfo]",  "%s\n",  v23);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_100245CD0(uint64_t a1, int *a2, uint64_t a3)
{
  int v10 = *a2;
  BOOL v12 = &v10;
  uint64_t v5 = sub_10023347C((uint64_t **)(a1 + 56), &v10, (uint64_t)&unk_1012CF090, &v12);
  sub_10005F550((uint64_t)(v5 + 8), &v11);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1))
  {
    int v7 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return 1LL;
}

void sub_100245D7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100245D90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = v22;
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  if (v21 < 0) {
    operator delete(__p);
  }
  __int128 v11 = v19;
  if (v19)
  {
    BOOL v12 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  uint64_t v14 = v18;
  if (v18)
  {
    uint64_t v15 = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

void sub_100245EC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100245ED4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182C2D8);
    }
    uint64_t v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      id v3 = (void *)(a1 + 8);
      *(_DWORD *)uint64_t buf = 136315138;
      uint64_t v34 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182C2D8);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v29 = 136315138;
      __int16 v30 = v4;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
                     (const char *)&v29);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char, CLLocationProvider_Type::RegInfo>::listClients() [Notification_T = CLLocationProvider_Type::Notification, Notifi cationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLoca tionProvider_Type::RegInfo]",  "%s\n",  v5);
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182C2D8);
    }
    uint64_t v6 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      int v7 = (void *)(a1 + 8);
      uint64_t v8 = *(void *)(a1 + 96);
      *(_DWORD *)uint64_t buf = 136315394;
      uint64_t v34 = v7;
      __int16 v35 = 2048;
      v36[0] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182C2D8);
      }
      unsigned int v25 = (void *)(a1 + 8);
      uint64_t v26 = *(void *)(a1 + 96);
      int v29 = 136315394;
      __int16 v30 = v25;
      __int16 v31 = 2048;
      v32[0] = v26;
      int v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
                      (const char *)&v29,
                      22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData, char, CLLocationProvider_Type::RegInfo>::listClients() [Notification_T = CLLocationProvider_Type::Notification, Notifi cationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = CLLoca tionProvider_Type::RegInfo]",  "%s\n",  v27);
    }

    int v9 = *(void **)(a1 + 80);
    if (v9 != (void *)(a1 + 88))
    {
      unint64_t v10 = (void *)(a1 + 8);
      do
      {
        __int128 v11 = (void *)v9[5];
        if (v11 != v9 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_10182C2D8);
            }
            BOOL v12 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              unint64_t v13 = (void *)(a1 + 8);
              int v14 = *((_DWORD *)v9 + 8);
              int v15 = *((_DWORD *)v11 + 7);
              *(_DWORD *)uint64_t buf = 136315650;
              uint64_t v34 = v13;
              __int16 v35 = 1024;
              LODWORD(v36[0]) = v14;
              WORD2(v36[0]) = 1024;
              *(_DWORD *)((char *)v36 + 6) = v15;
              _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10182C2D8);
              }
              int v19 = (void *)(a1 + 8);
              int v20 = *((_DWORD *)v9 + 8);
              int v21 = *((_DWORD *)v11 + 7);
              int v29 = 136315650;
              __int16 v30 = v19;
              __int16 v31 = 1024;
              LODWORD(v32[0]) = v20;
              WORD2(v32[0]) = 1024;
              *(_DWORD *)((char *)v32 + 6) = v21;
              int v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                              (const char *)&v29,
                              24,
                              v28);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLLocationProvider_Type::Notification, CLLocationProvider_Type::NotificationData , char, CLLocationProvider_Type::RegInfo>::listClients() [Notification_T = CLLocationProvider_Type::Noti fication, NotificationData_T = CLLocationProvider_Type::NotificationData, NotificationInfo_T = char, Reg istrationInfo_T = CLLocationProvider_Type::RegInfo]",  "%s\n",  v22);
            }

            unint64_t v16 = (void *)v11[1];
            if (v16)
            {
              do
              {
                int v17 = v16;
                unint64_t v16 = (void *)*v16;
              }

              while (v16);
            }

            else
            {
              do
              {
                int v17 = (void *)v11[2];
                BOOL v18 = *v17 == (void)v11;
                __int128 v11 = v17;
              }

              while (!v18);
            }

            __int128 v11 = v17;
          }

          while (v17 != v9 + 6);
        }

        id v23 = (void *)v9[1];
        if (v23)
        {
          do
          {
            int v24 = v23;
            id v23 = (void *)*v23;
          }

          while (v23);
        }

        else
        {
          do
          {
            int v24 = (void *)v9[2];
            BOOL v18 = *v24 == (void)v9;
            int v9 = v24;
          }

          while (!v18);
        }

        int v9 = v24;
      }

      while (v24 != (void *)(a1 + 88));
    }
  }

void sub_100246480(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100247BE4(a1);
  operator delete(v1);
}

id sub_100246494(uint64_t a1, int a2, void *a3)
{
  id result = sub_100246EF4(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_1002464E0(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_10024650C(id a1)
{
  qword_101934998 = (uint64_t)os_log_create("com.apple.locationd.Core", "Streaming");
}

void sub_100246538(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

uint64_t sub_100246564(uint64_t a1)
{
  *(_DWORD *)a1 = 0xFFFF;
  *(_OWORD *)(a1 + 4) = 0u;
  *(_OWORD *)(a1 + 2sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = xmmword_1012E0070;
  __asm { FMOV            V0.2D, #-1.0 }

  __int128 v9 = _Q0;
  *(_OWORD *)(a1 + 36) = _Q0;
  *(_OWORD *)(a1 + 52) = _Q0;
  *(_OWORD *)(a1 + 6std::istream::~istream(v2, v3 + 8) = _Q0;
  *(_DWORD *)(a1 + 84) = 0;
  *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = 0xBFF0000000000000LL;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 116) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 124) = 0x7FFFFFFF;
  *(void *)(a1 + 12std::istream::~istream(v2, v3 + 8) = 0LL;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_BYTE *)(a1 + 152) = 0;
  sub_100869DC8(a1 + 160);
  *(_BYTE *)(a1 + 824) = 0;
  *(_OWORD *)(a1 + 80sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0u;
  *(void *)(a1 + 813) = 0LL;
  *(void *)(a1 + 832) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 84sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
  *(_OWORD *)(a1 + 84std::istream::~istream(v2, v3 + 8) = xmmword_1012E4CC0;
  *(_OWORD *)(a1 + 864) = unk_1012E4CD0;
  *(_OWORD *)(a1 + 88sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = xmmword_1012E4CB0;
  *(void *)(a1 + 896) = 0xBFF0000000000000LL;
  *(void *)(a1 + 904) = 0LL;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_DWORD *)(a1 + 92std::istream::~istream(v2, v3 + 8) = 0;
  *(void *)(a1 + 936) = 0xBFF0000000000000LL;
  *(_OWORD *)(a1 + 944) = v9;
  *(_OWORD *)(a1 + 116sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0u;
  *(_DWORD *)(a1 + 1176) = 78;
  *(_OWORD *)(a1 + 132sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0u;
  *(_OWORD *)(a1 + 1336) = 0u;
  *(_OWORD *)(a1 + 1352) = 0u;
  __asm { FMOV            V0.2S, #-1.0 }

  *(void *)(a1 + 136std::istream::~istream(v2, v3 + 8) = _D0;
  *(void *)(a1 + 1376) = 0x7FF8000000000000LL;
  *(_DWORD *)(a1 + 1384) = -1082130432;
  *(void *)(a1 + 1392) = 0x7FF8000000000000LL;
  *(void *)(a1 + 140sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  *(_DWORD *)(a1 + 140std::istream::~istream(v2, v3 + 8) = -1082130432;
  *(_WORD *)(a1 + 1416) = 0x8000;
  *(_BYTE *)(a1 + 141std::istream::~istream(v2, v3 + 8) = 0;
  *(void *)(a1 + 1424) = 0LL;
  *(_WORD *)(a1 + 1432) = 0x8000;
  *(void *)(a1 + 144sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0x100000003LL;
  *(_DWORD *)(a1 + 144std::istream::~istream(v2, v3 + 8) = 2;
  *(_BYTE *)(a1 + 1452) = 0;
  *(_DWORD *)(a1 + 1456) = -1;
  *(void *)(a1 + 1464) = 0LL;
  *(_BYTE *)(a1 + 1472) = 0;
  *(_DWORD *)(a1 + 1476) = 0;
  *(_BYTE *)(a1 + 148sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
  *(void *)(a1 + 152sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  *(_DWORD *)(a1 + 1512) = 0;
  *(void *)(a1 + 1504) = 0LL;
  *(_OWORD *)(a1 + 148std::istream::~istream(v2, v3 + 8) = 0u;
  return a1;
}

void sub_1002466E8(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

uint64_t sub_100246714(uint64_t a1, int *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 8 * a3;
    do
    {
      sub_100246788(a1, a2, a2);
      a2 += 2;
      v5 -= 8LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100246774(_Unwind_Exception *a1)
{
}

void *sub_100246788(uint64_t a1, int *a2, void *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }

    __int128 v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          unint64_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = 0LL;
  v10[1] = v6;
  _DWORD v10[2] = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_100019E10(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }

  uint64_t v18 = *(void *)a1;
  int v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *unint64_t v10 = *v19;
LABEL_38:
    *int v19 = v10;
    goto LABEL_39;
  }

  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    int v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_10024698C(_Unwind_Exception *a1)
{
}

CLCppContainer *sub_1002469A0(uint64_t a1)
{
  uint64_t v2 = operator new(0x5F8uLL);
  sub_100246C40((uint64_t)v2, a1);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_100246BDC;
  void v4[3] = &unk_10181D3D0;
  v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  1LL,  1528LL);
}

void sub_100246A24(_Unwind_Exception *a1)
{
}

_BYTE *sub_100246A38(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    unint64_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_100246EF4(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    unint64_t v11 = (uint64_t **)(*(void *)a3 + 40LL);
    BOOL v14 = (int *)(*(void *)a2 + 32LL);
    float v12 = sub_100246B14(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    id result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 5);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

uint64_t **sub_100246B14(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        id v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    id v9 = a1 + 1;
LABEL_10:
    unint64_t v11 = (char *)operator new(0x48uLL);
    *((_DWORD *)v11 + std::istream::~istream(v2, v3 + 8) = **a4;
    *((void *)v11 + 7) = 0LL;
    *((void *)v11 + std::istream::~istream(v2, v3 + 8) = 0LL;
    __asm { FMOV            V0.2D, #-1.0 }

    *(_OWORD *)(v11 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = _Q0;
    sub_1000085FC(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }

  return v9;
}

void sub_100246BDC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {

    sub_10000AE14(v1 + 1160);
    sub_10000AE14(v1 + 800);
    sub_10000AE14(v1 + 680);
    operator delete((void *)v1);
  }

uint64_t sub_100246C40(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  __int128 v5 = *(_OWORD *)(a2 + 32);
  __int128 v6 = *(_OWORD *)(a2 + 48);
  __int128 v7 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v7;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v6;
  __int128 v8 = *(_OWORD *)(a2 + 96);
  __int128 v9 = *(_OWORD *)(a2 + 112);
  __int128 v10 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 14sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_OWORD *)(a2 + 140);
  *(_OWORD *)(a1 + 112) = v9;
  *(_OWORD *)(a1 + 12std::istream::~istream(v2, v3 + 8) = v10;
  *(_OWORD *)(a1 + 96) = v8;
  memcpy((void *)(a1 + 160), (const void *)(a2 + 160), 0x201uLL);
  *(void *)(a1 + 68sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(a2 + 680);
  uint64_t v11 = *(void *)(a2 + 688);
  *(void *)(a1 + 68std::istream::~istream(v2, v3 + 8) = v11;
  if (v11)
  {
    float v12 = (unint64_t *)(v11 + 8);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  __int128 v14 = *(_OWORD *)(a2 + 696);
  __int128 v15 = *(_OWORD *)(a2 + 728);
  *(_OWORD *)(a1 + 712) = *(_OWORD *)(a2 + 712);
  *(_OWORD *)(a1 + 72std::istream::~istream(v2, v3 + 8) = v15;
  *(_OWORD *)(a1 + 696) = v14;
  __int128 v16 = *(_OWORD *)(a2 + 744);
  __int128 v17 = *(_OWORD *)(a2 + 760);
  __int128 v18 = *(_OWORD *)(a2 + 776);
  *(void *)(a1 + 789) = *(void *)(a2 + 789);
  *(_OWORD *)(a1 + 76sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v17;
  *(_OWORD *)(a1 + 776) = v18;
  *(_OWORD *)(a1 + 744) = v16;
  *(void *)(a1 + 80sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(a2 + 800);
  uint64_t v19 = *(void *)(a2 + 808);
  *(void *)(a1 + 80std::istream::~istream(v2, v3 + 8) = v19;
  if (v19)
  {
    unint64_t v20 = (unint64_t *)(v19 + 8);
    do
      unint64_t v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }

  *(_OWORD *)(a1 + 816) = *(_OWORD *)(a2 + 816);
  __int128 v22 = *(_OWORD *)(a2 + 832);
  __int128 v23 = *(_OWORD *)(a2 + 848);
  __int128 v24 = *(_OWORD *)(a2 + 880);
  *(_OWORD *)(a1 + 864) = *(_OWORD *)(a2 + 864);
  *(_OWORD *)(a1 + 88sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v24;
  *(_OWORD *)(a1 + 832) = v22;
  *(_OWORD *)(a1 + 84std::istream::~istream(v2, v3 + 8) = v23;
  *(void *)(a1 + 896) = *(void *)(a2 + 896);
  if (*(char *)(a2 + 927) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 904), *(void **)(a2 + 904), *(void *)(a2 + 912));
  }

  else
  {
    __int128 v25 = *(_OWORD *)(a2 + 904);
    *(void *)(a1 + 92sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(a2 + 920);
    *(_OWORD *)(a1 + 904) = v25;
  }

  __int128 v26 = *(_OWORD *)(a2 + 928);
  __int128 v27 = *(_OWORD *)(a2 + 960);
  *(_OWORD *)(a1 + 944) = *(_OWORD *)(a2 + 944);
  *(_OWORD *)(a1 + 96sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v27;
  *(_OWORD *)(a1 + 92std::istream::~istream(v2, v3 + 8) = v26;
  __int128 v28 = *(_OWORD *)(a2 + 976);
  __int128 v29 = *(_OWORD *)(a2 + 992);
  __int128 v30 = *(_OWORD *)(a2 + 1024);
  *(_OWORD *)(a1 + 100std::istream::~istream(v2, v3 + 8) = *(_OWORD *)(a2 + 1008);
  *(_OWORD *)(a1 + 1024) = v30;
  *(_OWORD *)(a1 + 976) = v28;
  *(_OWORD *)(a1 + 992) = v29;
  __int128 v31 = *(_OWORD *)(a2 + 1040);
  __int128 v32 = *(_OWORD *)(a2 + 1056);
  __int128 v33 = *(_OWORD *)(a2 + 1072);
  *(_OWORD *)(a1 + 108std::istream::~istream(v2, v3 + 8) = *(_OWORD *)(a2 + 1088);
  *(_OWORD *)(a1 + 1072) = v33;
  *(_OWORD *)(a1 + 1056) = v32;
  *(_OWORD *)(a1 + 104sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v31;
  __int128 v34 = *(_OWORD *)(a2 + 1104);
  __int128 v35 = *(_OWORD *)(a2 + 1120);
  __int128 v36 = *(_OWORD *)(a2 + 1136);
  *(void *)(a1 + 1152) = *(void *)(a2 + 1152);
  *(_OWORD *)(a1 + 1136) = v36;
  *(_OWORD *)(a1 + 112sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v35;
  *(_OWORD *)(a1 + 1104) = v34;
  *(void *)(a1 + 116sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(a2 + 1160);
  uint64_t v37 = *(void *)(a2 + 1168);
  *(void *)(a1 + 116std::istream::~istream(v2, v3 + 8) = v37;
  if (v37)
  {
    __int128 v38 = (unint64_t *)(v37 + 8);
    do
      unint64_t v39 = __ldxr(v38);
    while (__stxr(v39 + 1, v38));
  }

  *(_OWORD *)(a1 + 1176) = *(_OWORD *)(a2 + 1176);
  __int128 v40 = *(_OWORD *)(a2 + 1192);
  __int128 v41 = *(_OWORD *)(a2 + 1208);
  __int128 v42 = *(_OWORD *)(a2 + 1240);
  *(_OWORD *)(a1 + 1224) = *(_OWORD *)(a2 + 1224);
  *(_OWORD *)(a1 + 124sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v42;
  *(_OWORD *)(a1 + 1192) = v40;
  *(_OWORD *)(a1 + 120std::istream::~istream(v2, v3 + 8) = v41;
  __int128 v43 = *(_OWORD *)(a2 + 1256);
  __int128 v44 = *(_OWORD *)(a2 + 1272);
  __int128 v45 = *(_OWORD *)(a2 + 1304);
  *(_OWORD *)(a1 + 128std::istream::~istream(v2, v3 + 8) = *(_OWORD *)(a2 + 1288);
  *(_OWORD *)(a1 + 1304) = v45;
  *(_OWORD *)(a1 + 1256) = v43;
  *(_OWORD *)(a1 + 1272) = v44;
  *(void *)(a1 + 132sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  *(void *)(a1 + 132sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(id *)(a2 + 1320);
  *(_OWORD *)(a1 + 132std::istream::~istream(v2, v3 + 8) = *(_OWORD *)(a2 + 1328);
  __int128 v46 = *(_OWORD *)(a2 + 1344);
  __int128 v47 = *(_OWORD *)(a2 + 1360);
  __int128 v48 = *(_OWORD *)(a2 + 1376);
  *(_OWORD *)(a1 + 1392) = *(_OWORD *)(a2 + 1392);
  *(_OWORD *)(a1 + 1376) = v48;
  *(_OWORD *)(a1 + 136sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v47;
  *(_OWORD *)(a1 + 1344) = v46;
  __int128 v49 = *(_OWORD *)(a2 + 1408);
  __int128 v50 = *(_OWORD *)(a2 + 1424);
  __int128 v51 = *(_OWORD *)(a2 + 1440);
  *(_OWORD *)(a1 + 1456) = *(_OWORD *)(a2 + 1456);
  *(_OWORD *)(a1 + 144sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v51;
  *(_OWORD *)(a1 + 1424) = v50;
  *(_OWORD *)(a1 + 140std::istream::~istream(v2, v3 + 8) = v49;
  __int128 v52 = *(_OWORD *)(a2 + 1472);
  __int128 v53 = *(_OWORD *)(a2 + 1488);
  __int128 v54 = *(_OWORD *)(a2 + 1504);
  *(void *)(a1 + 152sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(a2 + 1520);
  *(_OWORD *)(a1 + 1504) = v54;
  *(_OWORD *)(a1 + 148std::istream::~istream(v2, v3 + 8) = v53;
  *(_OWORD *)(a1 + 1472) = v52;
  return a1;
}

void sub_100246EB4(_Unwind_Exception *a1)
{
}

id sub_100246EF4(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_100246F40(a1);
  }
  else {
    return 0LL;
  }
}

id sub_100246F40(void *a1)
{
  id v2 = [a1 binaryVersion];
  id v3 = [a1 sizeOfType];
  if (v2 == (id)1)
  {
    id v4 = v3;
    id result = [a1 cppObjectPtr];
    if (v4 == (id)1528) {
      return result;
    }
    if (getenv("_INTERSILO_UNIT_TEST"))
    {
      if (qword_101934470 != -1) {
        dispatch_once(&qword_101934470, &stru_10182C358);
      }
      __int128 v6 = (os_log_s *)qword_101934478;
      if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 134218498;
        id v17 = v4;
        __int16 v18 = 2048;
        uint64_t v19 = 1528LL;
        __int16 v20 = 2080;
        unint64_t v21 = 0x80000001012EE968LL & 0x7FFFFFFFFFFFFFFFLL;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Size mismatch between encoded (%zu) and decoded (%zu) objects! This is possibly because the version has change d on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
      }

      if (!sub_1002921D0(115, 0)) {
        return 0LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934470 != -1) {
        dispatch_once(&qword_101934470, &stru_10182C358);
      }
      uint64_t v7 = qword_101934478;
      *(_DWORD *)__int128 v14 = 134218498;
      *(void *)&v14[4] = v4;
      *(_WORD *)&v14[12] = 2048;
      *(void *)&v14[14] = 1528LL;
      *(_WORD *)&v14[22] = 2080;
      unint64_t v15 = 0x80000001012EE968LL & 0x7FFFFFFFFFFFFFFFLL;
      __int128 v8 = "Size mismatch between encoded (%zu) and decoded (%zu) objects! This is possibly because the version has chang"
           "ed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly";
      goto LABEL_21;
    }

    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182C358);
    }
    float v12 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 134218498;
      id v17 = v4;
      __int16 v18 = 2048;
      uint64_t v19 = 1528LL;
      __int16 v20 = 2080;
      unint64_t v21 = 0x80000001012EE968LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "Size mismatch between encoded (%zu) and decoded (%zu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182C358);
    }
    uint64_t v7 = qword_101934478;
    *(_DWORD *)__int128 v14 = 134218498;
    *(void *)&v14[4] = v4;
    *(_WORD *)&v14[12] = 2048;
    *(void *)&v14[14] = 1528LL;
    *(_WORD *)&v14[22] = 2080;
    unint64_t v15 = 0x80000001012EE968LL & 0x7FFFFFFFFFFFFFFFLL;
    __int128 v8 = "Size mismatch between encoded (%zu) and decoded (%zu) objects! This is possibly because the version has changed"
         " on one side and possibly broken ABI compatibility. Please update your type for %s accordingly";
  }

  else
  {
    if (getenv("_INTERSILO_UNIT_TEST"))
    {
      if (qword_101934470 != -1) {
        dispatch_once(&qword_101934470, &stru_10182C358);
      }
      __int128 v9 = (os_log_s *)qword_101934478;
      if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 134218498;
        id v17 = v2;
        __int16 v18 = 2048;
        uint64_t v19 = 1LL;
        __int16 v20 = 2080;
        unint64_t v21 = 0x80000001012EE968LL & 0x7FFFFFFFFFFFFFFFLL;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version h as changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
      }

      if (!sub_1002921D0(115, 0)) {
        return 0LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934470 != -1) {
        dispatch_once(&qword_101934470, &stru_10182C358);
      }
      uint64_t v7 = qword_101934478;
      *(_DWORD *)__int128 v14 = 134218498;
      *(void *)&v14[4] = v2;
      *(_WORD *)&v14[12] = 2048;
      *(void *)&v14[14] = 1LL;
      *(_WORD *)&v14[22] = 2080;
      unint64_t v15 = 0x80000001012EE968LL & 0x7FFFFFFFFFFFFFFFLL;
      __int128 v8 = "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version "
           "has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly";
LABEL_21:
      uint64_t v10 = 16LL;
      goto LABEL_41;
    }

    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182C358);
    }
    uint64_t v11 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 134218498;
      id v17 = v2;
      __int16 v18 = 2048;
      uint64_t v19 = 1LL;
      __int16 v20 = 2080;
      unint64_t v21 = 0x80000001012EE968LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182C358);
    }
    uint64_t v7 = qword_101934478;
    *(_DWORD *)__int128 v14 = 134218498;
    *(void *)&v14[4] = v2;
    *(_WORD *)&v14[12] = 2048;
    *(void *)&v14[14] = 1LL;
    *(_WORD *)&v14[22] = 2080;
    unint64_t v15 = 0x80000001012EE968LL & 0x7FFFFFFFFFFFFFFFLL;
    __int128 v8 = "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version ha"
         "s changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly";
  }

  uint64_t v10 = 17LL;
LABEL_41:
  unint64_t v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  v10,  v8,  v14,  32,  *(_OWORD *)v14,  *(void *)&v14[16],  v15);
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLLocationProvider_Type::NotificationData, Callb ack = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:228:46)]",  "%s\n",  v13);
  return 0LL;
}

void sub_10024757C(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

uint64_t sub_1002475A8(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      uint64_t v7 = (uint64_t *)v2;
    }
    else {
      uint64_t v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }

  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0LL;
  }
  sub_1000087E8((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1LL;
}

uint64_t sub_100247620(uint64_t a1, int *a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 108) || !a3) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = &a2[a3];
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v5 = a1 + 64;
  uint64_t v6 = v7;
  do
  {
    if (v6)
    {
      int v8 = *a2;
      uint64_t v9 = v5;
      uint64_t v10 = v6;
      do
      {
        int v11 = *(_DWORD *)(v10 + 32);
        BOOL v12 = v11 < v8;
        if (v11 >= v8) {
          unint64_t v13 = (uint64_t *)v10;
        }
        else {
          unint64_t v13 = (uint64_t *)(v10 + 8);
        }
        if (!v12) {
          uint64_t v9 = v10;
        }
        uint64_t v10 = *v13;
      }

      while (*v13);
      if (v9 != v5 && v8 >= *(_DWORD *)(v9 + 32)) {
        uint64_t v3 = (v3 + *(_DWORD *)(v9 + 56));
      }
    }

    ++a2;
  }

  while (a2 != v4);
  return v3;
}

id sub_10024769C(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_1002476E8(a1);
  }
  else {
    return 0LL;
  }
}

id sub_1002476E8(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182C358);
    }
    uint64_t v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012EACF0LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182C358);
    }
    LODWORD(vstd::istream::~istream(v2, v3 + 8) = 134218498;
    HIDWORD(vstd::istream::~istream(v2, v3 + 8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182C358);
    }
    uint64_t v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)uint64_t buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012EACF0LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182C358);
    }
    LODWORD(vstd::istream::~istream(v2, v3 + 8) = 134218498;
    HIDWORD(vstd::istream::~istream(v2, v3 + 8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  uint64_t v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLLocationProvider_Type::RegInfo, Callback = (la mbda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:228:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

void *sub_100247A94@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x610uLL);
  id result = sub_100247AEC(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100247AD8(_Unwind_Exception *a1)
{
}

void *sub_100247AEC(void *a1, uint64_t a2)
{
  a1[2] = 0LL;
  *a1 = off_10182C388;
  a1[1] = 0LL;
  sub_100246C40((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_100247B24(_Unwind_Exception *a1)
{
}

void sub_100247B38(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182C388;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100247B4C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182C388;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100247B70(uint64_t a1)
{
  return sub_100247B98((uint64_t)&v2, a1 + 24);
}

uint64_t sub_100247B98(uint64_t a1, uint64_t a2)
{
  return sub_10000AE14(a2 + 680);
}

uint64_t sub_100247BE4(uint64_t a1)
{
  *(void *)a1 = off_10182C3D8;
  char v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *char v2 = 0LL;
  *(void *)(a1 + 16) = 0LL;
  return a1;
}

  ;
}

void sub_100247C7C( void *a1, int a2, int a3, int a4, const char *a5, const char *a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint8_t buf)
{
}

BOOL sub_100247C9C()
{
  return os_log_type_enabled((os_log_t)qword_101934998, OS_LOG_TYPE_FAULT);
}

void sub_100247CB0( void *a1, int a2, int a3, const char *a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint8_t buf)
{
}

void sub_100247CC4( void *a1, int a2, int a3, const char *a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint8_t buf)
{
}

BOOL sub_100247CD8()
{
  return os_log_type_enabled(*(os_log_t *)(v0 + 2456), OS_LOG_TYPE_INFO);
}

BOOL sub_100247CE8()
{
  return os_signpost_enabled(*(os_log_t *)(v0 + 2456));
}

void sub_100247CF4()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_1012E2C90;
      v1[3] = unk_1012E2CA0;
      unsigned __int8 v1[4] = xmmword_1012E2CB0;
      v1[0] = xmmword_1012E2C70;
      v1[1] = unk_1012E2C80;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_100247DC8(_Unwind_Exception *a1)
{
}

uint64_t sub_100247DE0()
{
  __int128 v1 = xmmword_1012E2CC8;
  uint64_t v2 = 0x100000002LL;
  sub_100246714((uint64_t)&unk_101993D40, (int *)&v1, 3LL);
  return __cxa_atexit((void (*)(void *))sub_10023DDB8, &unk_101993D40, (void *)&_mh_execute_header);
}

uint64_t sub_100248094(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v10 = v5++ >= 9;
      if (v10)
      {
        unint64_t v6 = 0LL;
        int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v11 || (v6 & 7) == 4) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    switch((v6 >> 3))
    {
      case 1u:
        *(_BYTE *)(a1 + 36) |= 1u;
        unint64_t v13 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v13 <= 0xFFFFFFFFFFFFFFF7LL && v13 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v14 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v13);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v13 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v14 = 0LL;
        }

        *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v14;
        goto LABEL_42;
      case 2u:
        __int128 v16 = objc_alloc_init(&OBJC_CLASS___ALCMMotionContextMotionState);

        *(void *)(a1 + 16) = v16;
        goto LABEL_28;
      case 3u:
        id v17 = objc_alloc_init(&OBJC_CLASS___ALCLNatalieFeatures);

        *(void *)(a1 + 24) = v17;
        if (PBReaderPlaceMark(a2, v24) && (sub_100253FF0((uint64_t)v17, a2) & 1) != 0)
        {
LABEL_28:
          PBReaderRecallMark(a2, v24);
LABEL_42:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }

        return 0LL;
      case 4u:
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0LL;
        while (2)
        {
          uint64_t v21 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v22 = v21 + 1;
          if (v21 == -1 || v22 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v23 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v21);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v22;
            v20 |= (unint64_t)(v23 & 0x7F) << v18;
            if (v23 < 0)
            {
              v18 += 7;
              BOOL v10 = v19++ >= 9;
              if (v10)
              {
                uint64_t v20 = 0LL;
                goto LABEL_39;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v20 = 0LL;
        }
LABEL_39:
        *(_BYTE *)(a1 + 32) = v20 != 0;
        goto LABEL_42;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_42;
    }
  }

uint64_t sub_100249CC4(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0LL;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      break;
    }
    switch((v6 >> 3))
    {
      case 1u:
        char v12 = 0;
        unsigned int v13 = 0;
        uint64_t v14 = 0LL;
        while (1)
        {
          unint64_t v15 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v15 == -1LL || v15 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v16 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v15);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v15 + 1;
          v14 |= (unint64_t)(v16 & 0x7F) << v12;
          if ((v16 & 0x80) == 0) {
            goto LABEL_84;
          }
          v12 += 7;
          BOOL v9 = v13++ >= 9;
          if (v9)
          {
            LODWORD(v14) = 0;
            goto LABEL_86;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_84:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v14) = 0;
        }
LABEL_86:
        uint64_t v53 = 36LL;
        goto LABEL_116;
      case 2u:
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v14 = 0LL;
        while (2)
        {
          unint64_t v20 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v20 == -1LL || v20 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v21 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v20);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v20 + 1;
            v14 |= (unint64_t)(v21 & 0x7F) << v18;
            if (v21 < 0)
            {
              v18 += 7;
              BOOL v9 = v19++ >= 9;
              if (v9)
              {
                LODWORD(v14) = 0;
                goto LABEL_90;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v14) = 0;
        }
LABEL_90:
        uint64_t v53 = 16LL;
        goto LABEL_116;
      case 3u:
        char v22 = 0;
        unsigned int v23 = 0;
        uint64_t v14 = 0LL;
        *(_BYTE *)(a1 + 44) |= 4u;
        while (2)
        {
          unint64_t v24 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v24 == -1LL || v24 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v25 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v24);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v24 + 1;
            v14 |= (unint64_t)(v25 & 0x7F) << v22;
            if (v25 < 0)
            {
              v22 += 7;
              BOOL v9 = v23++ >= 9;
              if (v9)
              {
                LODWORD(v14) = 0;
                goto LABEL_94;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v14) = 0;
        }
LABEL_94:
        uint64_t v53 = 24LL;
        goto LABEL_116;
      case 4u:
        char v26 = 0;
        unsigned int v27 = 0;
        uint64_t v14 = 0LL;
        *(_BYTE *)(a1 + 44) |= 8u;
        while (2)
        {
          unint64_t v28 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v28 == -1LL || v28 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v29 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v28);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v28 + 1;
            v14 |= (unint64_t)(v29 & 0x7F) << v26;
            if (v29 < 0)
            {
              v26 += 7;
              BOOL v9 = v27++ >= 9;
              if (v9)
              {
                LODWORD(v14) = 0;
                goto LABEL_98;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v14) = 0;
        }
LABEL_98:
        uint64_t v53 = 28LL;
        goto LABEL_116;
      case 5u:
        char v30 = 0;
        unsigned int v31 = 0;
        uint64_t v14 = 0LL;
        *(_BYTE *)(a1 + 44) |= 0x10u;
        while (2)
        {
          unint64_t v32 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v32 == -1LL || v32 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v33 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v32);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v32 + 1;
            v14 |= (unint64_t)(v33 & 0x7F) << v30;
            if (v33 < 0)
            {
              v30 += 7;
              BOOL v9 = v31++ >= 9;
              if (v9)
              {
                LODWORD(v14) = 0;
                goto LABEL_102;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v14) = 0;
        }
LABEL_102:
        uint64_t v53 = 32LL;
        goto LABEL_116;
      case 6u:
        char v34 = 0;
        unsigned int v35 = 0;
        uint64_t v36 = 0LL;
        *(_BYTE *)(a1 + 44) |= 0x40u;
        while (2)
        {
          unint64_t v37 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v37 == -1LL || v37 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v38 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v37);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v37 + 1;
            v36 |= (unint64_t)(v38 & 0x7F) << v34;
            if (v38 < 0)
            {
              v34 += 7;
              BOOL v9 = v35++ >= 9;
              if (v9)
              {
                uint64_t v36 = 0LL;
                goto LABEL_106;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v36 = 0LL;
        }
LABEL_106:
        BOOL v54 = v36 != 0;
        uint64_t v55 = 41LL;
        goto LABEL_111;
      case 7u:
        char v39 = 0;
        unsigned int v40 = 0;
        uint64_t v41 = 0LL;
        *(_BYTE *)(a1 + 44) |= 0x20u;
        while (2)
        {
          unint64_t v42 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v42 == -1LL || v42 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v43 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v42);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v42 + 1;
            v41 |= (unint64_t)(v43 & 0x7F) << v39;
            if (v43 < 0)
            {
              v39 += 7;
              BOOL v9 = v40++ >= 9;
              if (v9)
              {
                uint64_t v41 = 0LL;
                goto LABEL_110;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v41 = 0LL;
        }
LABEL_110:
        BOOL v54 = v41 != 0;
        uint64_t v55 = 40LL;
LABEL_111:
        *(_BYTE *)(a1 + v55) = v54;
        continue;
      case 8u:
        char v44 = 0;
        unsigned int v45 = 0;
        uint64_t v14 = 0LL;
        *(_BYTE *)(a1 + 44) |= 2u;
        while (2)
        {
          unint64_t v46 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v46 == -1LL || v46 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v47 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v46);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v46 + 1;
            v14 |= (unint64_t)(v47 & 0x7F) << v44;
            if (v47 < 0)
            {
              v44 += 7;
              BOOL v9 = v45++ >= 9;
              if (v9)
              {
                LODWORD(v14) = 0;
                goto LABEL_115;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v14) = 0;
        }
LABEL_115:
        uint64_t v53 = 20LL;
LABEL_116:
        *(_DWORD *)(a1 + v53) = v14;
        continue;
      case 9u:
        char v48 = 0;
        unsigned int v49 = 0;
        uint64_t v50 = 0LL;
        *(_BYTE *)(a1 + 44) |= 1u;
        break;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        continue;
    }

    while (1)
    {
      unint64_t v51 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v51 == -1LL || v51 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v52 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v51);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v51 + 1;
      v50 |= (unint64_t)(v52 & 0x7F) << v48;
      if ((v52 & 0x80) == 0) {
        goto LABEL_120;
      }
      v48 += 7;
      BOOL v9 = v49++ >= 9;
      if (v9)
      {
        uint64_t v50 = 0LL;
        goto LABEL_122;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_120:
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      uint64_t v50 = 0LL;
    }
LABEL_122:
    *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v50;
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_10024ACA8(id a1)
{
  v1[0] = @"gsp10-ssl.apple.com";
  v2[0] = +[NSNull null](&OBJC_CLASS___NSNull, "null");
  v1[1] = @"gs-loc.apple.com";
  v2[1] = +[NSNull null](&OBJC_CLASS___NSNull, "null");
  v2[2] = @"1.2.840.113635.100.6.27.35";
  v1[2] = @"iphone-ld.apple.com";
  v1[3] = @"configuration.apple.com";
  v2[3] = +[NSNull null](&OBJC_CLASS___NSNull, "null");
  unsigned __int8 v1[4] = @"cl5.apple.com";
  v2[4] = +[NSNull null](&OBJC_CLASS___NSNull, "null");
  _OWORD v1[5] = @"cl4.apple.com";
  v2[5] = +[NSNull null](&OBJC_CLASS___NSNull, "null");
  v1[6] = @"cl3.apple.com";
  v2[6] = +[NSNull null](&OBJC_CLASS___NSNull, "null");
  v1[7] = @"cl2.apple.com";
  v2[7] = +[NSNull null](&OBJC_CLASS___NSNull, "null");
  v1[8] = @"ingest.apple-studies.com";
  v2[8] = +[NSNull null](&OBJC_CLASS___NSNull, "null");
  v1[9] = @"ingest.stg.apple-studies.com";
  v2[9] = +[NSNull null](&OBJC_CLASS___NSNull, "null");
  qword_101993DA0 =  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v2,  v1,  10LL);
}

void sub_10024B470(id a1)
{
  qword_101934A48 = (uint64_t)os_log_create("com.apple.locationd.Utility", "Utility");
}

uint64_t sub_10024B8EC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)&OBJC_IVAR___PBDataReader__error;
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    unsigned int v5 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    unint64_t v6 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    unint64_t v7 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    char v8 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    BOOL v9 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    int v10 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    int v11 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    char v12 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    unsigned int v13 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    uint64_t v14 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    unint64_t v15 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    char v16 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    do
    {
      if (*(_BYTE *)(a2 + *v3)) {
        break;
      }
      char v17 = 0;
      unsigned int v18 = 0;
      unint64_t v19 = 0LL;
      while (1)
      {
        uint64_t v20 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        unint64_t v21 = v20 + 1;
        if (v20 == -1 || v21 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v22 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v20);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v21;
        v19 |= (unint64_t)(v22 & 0x7F) << v17;
        if ((v22 & 0x80) == 0) {
          goto LABEL_12;
        }
        v17 += 7;
        BOOL v23 = v18++ >= 9;
        if (v23)
        {
          unint64_t v19 = 0LL;
          uint64_t v24 = *v3;
          int v25 = *(unsigned __int8 *)(a2 + v24);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + *v3) = 1;
LABEL_12:
      uint64_t v24 = *v3;
      int v25 = *(unsigned __int8 *)(a2 + v24);
      if (*(_BYTE *)(a2 + v24)) {
        unint64_t v19 = 0LL;
      }
LABEL_14:
      if (v25 || (v19 & 7) == 4) {
        break;
      }
      switch((v19 >> 3))
      {
        case 1u:
          char v27 = 0;
          unsigned int v28 = 0;
          uint64_t v29 = 0LL;
          *(_BYTE *)(a1 + *((int *)v5 + 468)) |= 4u;
          while (1)
          {
            uint64_t v30 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v31 = v30 + 1;
            if (v30 == -1 || v31 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
              break;
            }
            char v32 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v30);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v31;
            v29 |= (unint64_t)(v32 & 0x7F) << v27;
            if ((v32 & 0x80) == 0) {
              goto LABEL_81;
            }
            v27 += 7;
            BOOL v23 = v28++ >= 9;
            if (v23)
            {
              LODWORD(v29) = 0;
              goto LABEL_83;
            }
          }

          *(_BYTE *)(a2 + *v3) = 1;
LABEL_81:
          if (*(_BYTE *)(a2 + *v3)) {
            LODWORD(v29) = 0;
          }
LABEL_83:
          uint64_t v71 = *((int *)v6 + 469);
          goto LABEL_96;
        case 2u:
          unint64_t v40 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v40 <= 0xFFFFFFFFFFFFFFF7LL && v40 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v41 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v40);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v40 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + v24) = 1;
            uint64_t v41 = 0LL;
          }

          uint64_t v72 = *((int *)v7 + 473);
          goto LABEL_118;
        case 3u:
          char v42 = 0;
          unsigned int v43 = 0;
          uint64_t v29 = 0LL;
          *(_BYTE *)(a1 + *((int *)v5 + 468)) |= 2u;
          while (2)
          {
            uint64_t v44 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v45 = v44 + 1;
            if (v44 == -1 || v45 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + *v3) = 1;
            }

            else
            {
              char v46 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v44);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v45;
              v29 |= (unint64_t)(v46 & 0x7F) << v42;
              if (v46 < 0)
              {
                v42 += 7;
                BOOL v23 = v43++ >= 9;
                if (v23)
                {
                  LODWORD(v29) = 0;
                  goto LABEL_87;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + *v3)) {
            LODWORD(v29) = 0;
          }
LABEL_87:
          uint64_t v71 = *((int *)v8 + 470);
          goto LABEL_96;
        case 4u:
          unint64_t v47 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v47 <= 0xFFFFFFFFFFFFFFFBLL && v47 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            int v48 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v47);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v47 + 4;
          }

          else
          {
            *(_BYTE *)(a2 + v24) = 1;
            int v48 = 0;
          }

          uint64_t v73 = *((int *)v9 + 474);
          goto LABEL_115;
        case 5u:
          unint64_t v49 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v49 <= 0xFFFFFFFFFFFFFFFBLL && v49 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            int v48 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v49);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v49 + 4;
          }

          else
          {
            *(_BYTE *)(a2 + v24) = 1;
            int v48 = 0;
          }

          uint64_t v73 = *((int *)v10 + 475);
          goto LABEL_115;
        case 6u:
          unint64_t v50 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v50 <= 0xFFFFFFFFFFFFFFFBLL && v50 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            int v48 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v50);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v50 + 4;
          }

          else
          {
            *(_BYTE *)(a2 + v24) = 1;
            int v48 = 0;
          }

          uint64_t v73 = *((int *)v11 + 476);
          goto LABEL_115;
        case 7u:
          unint64_t v51 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v51 <= 0xFFFFFFFFFFFFFFF7LL && v51 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v41 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v51);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v51 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + v24) = 1;
            uint64_t v41 = 0LL;
          }

          uint64_t v72 = *((int *)v12 + 477);
          goto LABEL_118;
        case 8u:
          unint64_t v52 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v52 <= 0xFFFFFFFFFFFFFFFBLL && v52 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            int v48 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v52);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v52 + 4;
          }

          else
          {
            *(_BYTE *)(a2 + v24) = 1;
            int v48 = 0;
          }

          uint64_t v73 = *((int *)v13 + 478);
          goto LABEL_115;
        case 9u:
          char v53 = 0;
          unsigned int v54 = 0;
          uint64_t v29 = 0LL;
          while (2)
          {
            uint64_t v55 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v56 = v55 + 1;
            if (v55 == -1 || v56 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + *v3) = 1;
            }

            else
            {
              char v57 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v55);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v56;
              v29 |= (unint64_t)(v57 & 0x7F) << v53;
              if (v57 < 0)
              {
                v53 += 7;
                BOOL v23 = v54++ >= 9;
                if (v23)
                {
                  LODWORD(v29) = 0;
                  goto LABEL_91;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + *v3)) {
            LODWORD(v29) = 0;
          }
LABEL_91:
          uint64_t v71 = *((int *)v14 + 479);
          goto LABEL_96;
        case 0xAu:
          char v58 = 0;
          unsigned int v59 = 0;
          uint64_t v29 = 0LL;
          while (2)
          {
            uint64_t v60 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v61 = v60 + 1;
            if (v60 == -1 || v61 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + *v3) = 1;
            }

            else
            {
              char v62 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v60);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v61;
              v29 |= (unint64_t)(v62 & 0x7F) << v58;
              if (v62 < 0)
              {
                v58 += 7;
                BOOL v23 = v59++ >= 9;
                if (v23)
                {
                  LODWORD(v29) = 0;
                  goto LABEL_95;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + *v3)) {
            LODWORD(v29) = 0;
          }
LABEL_95:
          uint64_t v71 = *((int *)v15 + 480);
LABEL_96:
          *(_DWORD *)(a1 + v71) = v29;
          continue;
        case 0xBu:
          unint64_t v63 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v63 <= 0xFFFFFFFFFFFFFFFBLL && v63 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            int v48 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v63);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v63 + 4;
          }

          else
          {
            *(_BYTE *)(a2 + v24) = 1;
            int v48 = 0;
          }

          uint64_t v73 = *((int *)v16 + 481);
LABEL_115:
          *(_DWORD *)(a1 + v73) = v48;
          continue;
        case 0xCu:
          *(_BYTE *)(a1 + *((int *)v5 + 468)) |= 1u;
          unint64_t v64 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v64 <= 0xFFFFFFFFFFFFFFF7LL && v64 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v41 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v64);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v64 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + *v3) = 1;
            uint64_t v41 = 0LL;
          }

          uint64_t v72 = 24LL;
LABEL_118:
          *(void *)(a1 + v72) = v41;
          continue;
        case 0xDu:
          char v65 = 0;
          unsigned int v66 = 0;
          uint64_t v67 = 0LL;
          *(_BYTE *)(a1 + *((int *)v5 + 468)) |= 8u;
          break;
        default:
          char v33 = v6;
          char v34 = v7;
          unsigned int v35 = v5;
          uint64_t v36 = v8;
          unint64_t v37 = v9;
          uint64_t v74 = a1;
          char v38 = v3;
          uint64_t result = PBReaderSkipValueWithTag(a2);
          char v16 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          uint64_t v3 = v38;
          int v11 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          a1 = v74;
          BOOL v9 = v37;
          int v10 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          char v8 = v36;
          char v12 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          unsigned int v5 = v35;
          unint64_t v15 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          unint64_t v7 = v34;
          unsigned int v13 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          unint64_t v6 = v33;
          uint64_t v14 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          if (!(_DWORD)result) {
            return result;
          }
          continue;
      }

      while (1)
      {
        uint64_t v68 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        unint64_t v69 = v68 + 1;
        if (v68 == -1 || v69 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v70 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v68);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v69;
        v67 |= (unint64_t)(v70 & 0x7F) << v65;
        if ((v70 & 0x80) == 0) {
          goto LABEL_98;
        }
        v65 += 7;
        BOOL v23 = v66++ >= 9;
        if (v23)
        {
          uint64_t v67 = 0LL;
          goto LABEL_100;
        }
      }

      *(_BYTE *)(a2 + *v3) = 1;
LABEL_98:
      if (*(_BYTE *)(a2 + *v3)) {
        uint64_t v67 = 0LL;
      }
LABEL_100:
      *(_BYTE *)(a1 + 6std::istream::~istream(v2, v3 + 8) = v67 != 0;
    }

    while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length));
  }

  return *(_BYTE *)(a2 + *v3) == 0;
}

void *sub_10024CD10(void *a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_10182C488;
  a1[9] = off_10182C538;
  sub_10024D4F8((uint64_t)a1);
  return a1;
}

void sub_10024CD98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_10024CDC4(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = 0u;
  char v12 = (void *)(a1 + 8);
  *(void *)a1 = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 8));
  *char v12 = &off_101826EF8;
  *(void *)a1 = off_10182C6E8;
  *(void *)(a1 + 72) = off_10182C790;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_10182C6E8;
  *(void *)(a1 + 72) = off_10182C790;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20std::istream::~istream(v2, v3 + 8) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_DWORD *)(a1 + 24sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = -1;
  *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = 0LL;
  *(_DWORD *)(a1 + 256) = 12000;
  *(void *)(a1 + 264) = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 272));
  *(void *)(a1 + 272) = &off_101826EF8;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v28 = a1 + 112;
  (*(void (**)(void))(v13 + 16))();
  __int16 v30 = 256;
  if (a3)
  {
    *(void *)(a1 + 232) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v28 + 24LL))(v28);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a4;
    uint64_t v27 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  unint64_t v15 = (int *)(a1 + 256);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 256));
  char v17 = v33;
  if (v33)
  {
    p_shared_owners = (unint64_t *)&v33->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    *unint64_t v15 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10182C7D0);
  }
  uint64_t v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v15;
    *(_DWORD *)uint64_t buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182C7D0);
    }
    int v24 = *v15;
    v31[0] = 67109120;
    v31[1] = v24;
    int v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v31);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<CLCardioChange::AggregateFeatureEntry, CLActivityDB::ClassBDataProtectionPolicy>::CLActivityR ecorderDb(const char *, BOOL, float, const std::string &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = CLCardioChange::AggregateFeatureEntry, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v25);
  }

  int v22 = HIBYTE(v30);
  *(void *)(a1 + 232) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v30)
    {
      pthread_mutex_unlock(v29);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_10024D17C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[33] = off_101826EC8;
  sub_1001B9C98(v27);
  sub_1000EAA04(v26);
  sub_100D8A88C(a12);
  *int v24 = off_101826EC8;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_10024D220()
{
}

void *sub_10024D228(void *a1)
{
  a1[9] = off_10182C790;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_10182C6E8;
  a1[33] = off_101826EC8;
  sub_1001B9C98(a1 + 34);
  sub_1000EAA04(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_101826EC8;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_10024D2A8(uint64_t a1)
{
  return sub_10024D228((void *)(a1 - 72));
}

void sub_10024D2B0(void *a1)
{
  __int128 v1 = sub_10024D228(a1);
  operator delete(v1);
}

void sub_10024D2C4(uint64_t a1)
{
  __int128 v1 = sub_10024D228((void *)(a1 - 72));
  operator delete(v1);
}

uint64_t sub_10024D2DC(uint64_t *a1, uint64_t a2)
{
  double Current = CFAbsoluteTimeGetCurrent();
  sub_1003C0D54(a1[10], "DELETE FROM CardioChangeFeatureHistory WHERE startTime < ?", &v13);
  uint64_t v5 = v13;
  char v6 = (sqlite3_stmt *)sub_100019240(v13);
  if (sub_1003B7480(v6, 1, Current - *(double *)(*(void *)(a2 + 8) - 24LL)))
  {
    uint64_t v7 = a1[10];
    char v8 = (sqlite3_stmt *)sub_100019240(v5);
    sub_1003BB2BC(v7, v8);
    uint64_t v9 = (*(int (**)(uint64_t *))(*a1 + 152))(a1);
  }

  else
  {
    uint64_t v9 = -1LL;
  }

  sub_1003C05BC(a1[10]);
  uint64_t v10 = a1[10];
  else {
    uint64_t v11 = *(void *)(v10 + 88);
  }
  sub_1003C1EC0(v10, v11);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return v9;
}

void sub_10024D3F4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10024D414(uint64_t a1, uint64_t a2)
{
  return sub_10024D2DC((uint64_t *)(a1 - 72), a2);
}

uint64_t sub_10024D41C(uint64_t a1)
{
  uint64_t v3 = v8;
  char v4 = (sqlite3_stmt *)sub_100019240(v8);
  int v5 = sqlite3_step(v4);
  if (v5 == 100)
  {
    char v6 = (sqlite3_stmt *)sub_100019240(v3);
    uint64_t v1 = sqlite3_column_int(v6, 0);
  }

  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v5 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_10024D4BC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10024D4E0(uint64_t a1)
{
  return sub_10024D41C(a1 - 72);
}

uint64_t sub_10024D4E8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 120LL))(a1, a2, 0LL);
}

uint64_t sub_10024D4F8(uint64_t a1)
{
  uint64_t result = sub_1003C1048(*(void *)(a1 + 80));
  if ((_DWORD)result) {
    return sub_1003B59A0( *(void *)(a1 + 80),  "CardioChangeFeatureHistory",  (const char **)&off_10182C5C8,  (const std::string::value_type **)&off_101936870,  0);
  }
  return result;
}

uint64_t sub_10024D54C(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54( *(void *)(a1 + 80),  "INSERT INTO CardioChangeFeatureHistory (startTime, aggregateFeatureName, aggregateFeatureValue) VALUES (?, ?, ?)",  &v11);
    uint64_t v5 = v11;
    char v6 = (sqlite3_stmt *)sub_100019240(v11);
    uint64_t result = sub_1003B7480(v6, 1, *(double *)(a2 + 8));
    if ((_DWORD)result)
    {
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v5);
      uint64_t result = sub_1003C28BC(v7, 2, *(_DWORD *)(a2 + 16));
      if ((_DWORD)result)
      {
        uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
        uint64_t result = sub_1003B7480(v8, 3, *(double *)(a2 + 24));
        if ((_DWORD)result)
        {
          uint64_t v9 = *(void *)(a1 + 80);
          uint64_t v10 = (sqlite3_stmt *)sub_100019240(v5);
          uint64_t result = sub_1003BB2BC(v9, v10);
        }
      }
    }

    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_10024D614(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10024D634(uint64_t a1, uint64_t *a2, uint64_t a3)
{
}

void sub_10024D640(uint64_t *a1, uint64_t a2)
{
  char v4 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)a2 = sqlite3_column_int(v4, 0);
  uint64_t v5 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + std::istream::~istream(v2, v3 + 8) = sqlite3_column_double(v5, 1);
  char v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)(a2 + 16) = sqlite3_column_int(v6, 2);
  uint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 24) = sqlite3_column_double(v7, 3);
}

uint64_t sub_10024D6B4(uint64_t a1, char **a2, double a3)
{
  if ((sub_100D8A92C(a1 + 72) & 1) != 0)
  {
    a2[1] = *a2;
    sub_1003C0D54( *(void *)(a1 + 80),  "SELECT * FROM CardioChangeFeatureHistory WHERE startTime >= ? ORDER BY startTime",  buf);
    uint64_t v6 = *(void *)buf;
    v25[0] = *(void *)buf;
    memset(buf, 0, sizeof(buf));
    LODWORD(v27) = -1;
    *((void *)&v27 + 1) = 0LL;
    uint64_t v7 = (sqlite3_stmt *)sub_100019240(v25[0]);
    if (sub_1003B7480(v7, 1, a3))
    {
      while (!sub_10024D9F4(v25, (uint64_t)buf))
      {
        uint64_t v8 = a2[1];
        unint64_t v9 = (unint64_t)a2[2];
        if ((unint64_t)v8 >= v9)
        {
          uint64_t v11 = (v8 - *a2) >> 5;
          unint64_t v12 = v11 + 1;
          uint64_t v13 = v9 - (void)*a2;
          if (v13 >> 4 > v12) {
            unint64_t v12 = v13 >> 4;
          }
          else {
            unint64_t v14 = v12;
          }
          if (v14) {
            unint64_t v15 = (char *)sub_10000835C((uint64_t)(a2 + 2), v14);
          }
          else {
            unint64_t v15 = 0LL;
          }
          char v16 = &v15[32 * v11];
          *(_OWORD *)char v16 = *(_OWORD *)buf;
          *((_OWORD *)v16 + 1) = v27;
          unsigned int v18 = *a2;
          char v17 = a2[1];
          unint64_t v19 = v16;
          if (v17 != *a2)
          {
            do
            {
              __int128 v20 = *((_OWORD *)v17 - 1);
              *((_OWORD *)v19 - 2) = *((_OWORD *)v17 - 2);
              *((_OWORD *)v19 - 1) = v20;
              v19 -= 32;
              v17 -= 32;
            }

            while (v17 != v18);
            char v17 = *a2;
          }

          uint64_t v10 = v16 + 32;
          *a2 = v19;
          a2[1] = v16 + 32;
          a2[2] = &v15[32 * v14];
          if (v17) {
            operator delete(v17);
          }
        }

        else
        {
          *(_OWORD *)uint64_t v8 = *(_OWORD *)buf;
          *((_OWORD *)v8 + 1) = v27;
          uint64_t v10 = v8 + 32;
        }

        a2[1] = v10;
      }
    }

    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
    return 100LL;
  }

  else
  {
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_10182C6B8);
    }
    int v21 = (os_log_s *)qword_101934768;
    if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "CardioChangeFeatureHistory, DB not accessible",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934760 != -1) {
        dispatch_once(&qword_101934760, &stru_10182C6B8);
      }
      LOWORD(v25[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934768,  2LL,  "CardioChangeFeatureHistory, DB not accessible",  v25,  2);
      int v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLCardioChangeFeatureHistoryDb::querySinceTime(CFAbsoluteTime, std::vector<CLCardioChange::AggregateFeat ureEntry> &) const",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
    }

    return 109LL;
  }

void sub_10024D9C8(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10024D9F4(uint64_t *a1, uint64_t a2)
{
  char v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  sub_10024D640(a1, a2);
  return 0LL;
}

uint64_t sub_10024DA50(uint64_t a1, uint64_t a2, int a3)
{
  if ((sub_100D8A92C(a1 + 72) & 1) != 0)
  {
    sub_1003C0D54( *(void *)(a1 + 80),  "SELECT * FROM CardioChangeFeatureHistory WHERE aggregateFeatureName = ? ORDER BY id DESC LIMIT 1",  buf);
    uint64_t v6 = *(void *)buf;
    v17[0] = *(void *)buf;
    uint64_t v7 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
    if (sub_1003C28BC(v7, 1, a3) && sub_10024D9F4(v17, a2) != 2)
    {
      uint64_t v9 = 100LL;
      if (!v6) {
        return v9;
      }
    }

    else
    {
      if (qword_101934760 != -1) {
        dispatch_once(&qword_101934760, &stru_10182C6B8);
      }
      uint64_t v8 = (os_log_s *)qword_101934768;
      if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "CardioChangeFeatureHistory, DB query error",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934760 != -1) {
          dispatch_once(&qword_101934760, &stru_10182C6B8);
        }
        v16[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934768,  16LL,  "CardioChangeFeatureHistory, DB query error",  v16,  2);
        unint64_t v15 = (uint8_t *)v14;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLCardioChangeFeatureHistoryDb::getMostRecentEntryForFeature(CLCardioChange::AggregateFeatureEntry &, CLCardioChange::AggregateFeatureType) const",  "%s\n",  v14);
        if (v15 != buf) {
          free(v15);
        }
      }

      uint64_t v9 = 109LL;
      if (!v6) {
        return v9;
      }
    }

    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    return v9;
  }

  if (qword_101934760 != -1) {
    dispatch_once(&qword_101934760, &stru_10182C6B8);
  }
  uint64_t v10 = (os_log_s *)qword_101934768;
  if (os_log_type_enabled((os_log_t)qword_101934768, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "CardioChangeFeatureHistory, DB not accessible",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934760 != -1) {
      dispatch_once(&qword_101934760, &stru_10182C6B8);
    }
    LOWORD(v17[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934768,  2LL,  "CardioChangeFeatureHistory, DB not accessible",  v17,  2);
    uint64_t v13 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLCardioChangeFeatureHistoryDb::getMostRecentEntryForFeature(CLCardioChange::AggregateFeatureEntry &, CLCa rdioChange::AggregateFeatureType) const",  "%s\n",  v12);
    if (v13 != buf) {
      free(v13);
    }
  }

  return 109LL;
}

void sub_10024DD9C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10024DDC8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v7;
  uint64_t v8 = v7;
  uint64_t v5 = sub_10024D9F4(&v8, a2);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  return v5;
}

void sub_10024DE48(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10024DE68(uint64_t *a1, char **a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v35);
  if ((SHIBYTE(v36) & 0x80000000) == 0)
  {
    if (HIBYTE(v36)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_1012319DC(v4);
LABEL_44:
    sub_100007008();
  }

  __int16 v30 = v35[1];
  operator delete(v35[0]);
  if (!v30) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v35);
    uint64_t v6 = sub_10000CF44(&v36, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(void **__return_ptr, uint64_t *))(*a1 + 64))(__p, a1);
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v7 = __p;
    }
    else {
      uint64_t v7 = (void **)__p[0];
    }
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v8 = BYTE7(v32);
    }
    else {
      uint64_t v8 = (uint64_t)__p[1];
    }
    uint64_t v9 = sub_10000CF44(v6, (uint64_t)v7, v8);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v10 = a1[10];
    std::stringbuf::str((std::stringbuf::string_type *)__p, &v37);
    if ((SBYTE7(v32) & 0x80u) == 0) {
      uint64_t v11 = (char *)__p;
    }
    else {
      uint64_t v11 = (char *)__p[0];
    }
    sub_1003C0D54(v10, v11, &v33);
    uint64_t v12 = v33;
    uint64_t v33 = 0LL;
    uint64_t v34 = v12;
    if (SBYTE7(v32) < 0) {
      operator delete(__p[0]);
    }
    sub_1003C0454(a1[10]);
    __p[0] = 0LL;
    __p[1] = 0LL;
    LODWORD(v32) = -1;
    *((void *)&v32 + 1) = 0LL;
    while (!sub_1001BA11C((uint64_t)a1, &v34, (uint64_t)__p))
    {
      uint64_t v13 = a2[1];
      unint64_t v14 = (unint64_t)a2[2];
      if ((unint64_t)v13 >= v14)
      {
        uint64_t v17 = (v13 - *a2) >> 5;
        unint64_t v18 = v17 + 1;
        uint64_t v19 = v14 - (void)*a2;
        if (v19 >> 4 > v18) {
          unint64_t v18 = v19 >> 4;
        }
        else {
          unint64_t v20 = v18;
        }
        if (v20) {
          int v21 = (char *)sub_10000835C((uint64_t)(a2 + 2), v20);
        }
        else {
          int v21 = 0LL;
        }
        int v22 = &v21[32 * v17];
        __int128 v23 = v32;
        *(_OWORD *)int v22 = *(_OWORD *)__p;
        *((_OWORD *)v22 + 1) = v23;
        int v25 = *a2;
        int v24 = a2[1];
        char v26 = v22;
        if (v24 != *a2)
        {
          do
          {
            __int128 v27 = *((_OWORD *)v24 - 1);
            *((_OWORD *)v26 - 2) = *((_OWORD *)v24 - 2);
            *((_OWORD *)v26 - 1) = v27;
            v26 -= 32;
            v24 -= 32;
          }

          while (v24 != v25);
          int v24 = *a2;
        }

        char v16 = v22 + 32;
        *a2 = v26;
        a2[1] = v22 + 32;
        a2[2] = &v21[32 * v20];
        if (v24) {
          operator delete(v24);
        }
      }

      else
      {
        __int128 v15 = v32;
        *(_OWORD *)uint64_t v13 = *(_OWORD *)__p;
        *((_OWORD *)v13 + 1) = v15;
        char v16 = v13 + 32;
      }

      a2[1] = v16;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v28 = v34;
    uint64_t v34 = 0LL;
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
    }
    *(void **)((char *)v35
    uint64_t v36 = v29;
    std::streambuf::~streambuf(&v37);
    return std::ios::~ios(&v38);
  }

  return result;
}

void sub_10024E138( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  sub_1011F8850((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_10024E1A0(void *a1, void **a2, double a3, double a4)
{
  uint64_t v10 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v41);
  if ((SHIBYTE(v42) & 0x80000000) == 0)
  {
    if (HIBYTE(v42)) {
      goto LABEL_3;
    }
LABEL_40:
    sub_101231B48(v10);
    goto LABEL_41;
  }

  uint64_t v4 = (std::stringbuf *)v41[1];
  operator delete(v41[0]);
  if (!v4) {
    goto LABEL_40;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v41);
  uint64_t v11 = sub_10000CF44(&v42, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(void **__return_ptr, void *))(*a1 + 64LL))(__p, a1);
  if ((SBYTE7(v38) & 0x80u) == 0) {
    uint64_t v12 = __p;
  }
  else {
    uint64_t v12 = (void **)__p[0];
  }
  if ((SBYTE7(v38) & 0x80u) == 0) {
    uint64_t v13 = BYTE7(v38);
  }
  else {
    uint64_t v13 = (uint64_t)__p[1];
  }
  unint64_t v14 = sub_10000CF44(v11, (uint64_t)v12, v13);
  sub_10000CF44(v14, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v15 = a1[10];
  uint64_t v4 = &v43;
  std::stringbuf::str((std::stringbuf::string_type *)__p, &v43);
  if ((SBYTE7(v38) & 0x80u) == 0) {
    char v16 = (char *)__p;
  }
  else {
    char v16 = (char *)__p[0];
  }
  sub_1003C0D54(v15, v16, &v39);
  uint64_t v5 = v39;
  uint64_t v39 = 0LL;
  uint64_t v40 = v5;
  if (SBYTE7(v38) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v17 = (sqlite3_stmt *)sub_100019240(v5);
  if (sub_1003B7480(v17, 1, a3))
  {
    unint64_t v18 = (sqlite3_stmt *)sub_100019240(v5);
    if (sub_1003B7480(v18, 2, a4))
    {
      __p[0] = 0LL;
      __p[1] = 0LL;
      LODWORD(v3std::istream::~istream(v2, v3 + 8) = -1;
      *((void *)&v38 + 1) = 0LL;
      while (1)
      {
        uint64_t v19 = sub_1001BA11C((uint64_t)a1, &v40, (uint64_t)__p);
        if ((_DWORD)v19) {
          break;
        }
        unint64_t v20 = a2[1];
        unint64_t v21 = (unint64_t)a2[2];
        if ((unint64_t)v20 >= v21)
        {
          uint64_t v24 = ((char *)v20 - (_BYTE *)*a2) >> 5;
          unint64_t v25 = v24 + 1;
          uint64_t v26 = v21 - (void)*a2;
          if (v26 >> 4 > v25) {
            unint64_t v25 = v26 >> 4;
          }
          else {
            unint64_t v27 = v25;
          }
          if (v27) {
            uint64_t v28 = (char *)sub_10000835C((uint64_t)(a2 + 2), v27);
          }
          else {
            uint64_t v28 = 0LL;
          }
          uint64_t v29 = &v28[32 * v24];
          __int128 v30 = v38;
          *(_OWORD *)uint64_t v29 = *(_OWORD *)__p;
          *((_OWORD *)v29 + 1) = v30;
          __int128 v32 = (char *)*a2;
          unint64_t v31 = (char *)a2[1];
          uint64_t v33 = v29;
          if (v31 != *a2)
          {
            do
            {
              __int128 v34 = *((_OWORD *)v31 - 1);
              *((_OWORD *)v33 - 2) = *((_OWORD *)v31 - 2);
              *((_OWORD *)v33 - 1) = v34;
              v33 -= 32;
              v31 -= 32;
            }

            while (v31 != v32);
            unint64_t v31 = (char *)*a2;
          }

          __int128 v23 = v29 + 32;
          *a2 = v33;
          a2[1] = v29 + 32;
          a2[2] = &v28[32 * v27];
          if (v31) {
            operator delete(v31);
          }
        }

        else
        {
          __int128 v22 = v38;
          *unint64_t v20 = *(_OWORD *)__p;
          v20[1] = v22;
          __int128 v23 = v20 + 2;
        }

        a2[1] = v23;
      }

      uint64_t v5 = v40;
      goto LABEL_43;
    }
  }

void sub_10024E4B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_10024E51C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v36 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182C7D0);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v40 = 0;
      *(_WORD *)&v40[4] = 2082;
      *(void *)&v40[6] = "";
      __int16 v41 = 2082;
      uint64_t v42 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182C7D0);
      }
      uint64_t v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)uint64_t buf = 134349056;
        *(void *)uint64_t v40 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182C7D0);
        }
        uint64_t v33 = *(void *)(a1 + 216);
        int v37 = 134349056;
        uint64_t v38 = v33;
        __int128 v34 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v37,  12);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<CLCardioChange::AggregateFeatureEntry, CLActivityDB::ClassBDataProtectionPol icy>::setDatabaseAccessible() [T = CLCardioChange::AggregateFeatureEntry, DataProtectionPolicy = CLActivityDB: :ClassBDataProtectionPolicy]",  "%s\n",  v34);
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182C7D0);
    }
    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)uint64_t buf = 68289539;
      *(_DWORD *)uint64_t v40 = 0;
      *(_WORD *)&v40[4] = 2082;
      *(void *)&v40[6] = "";
      __int16 v41 = 2082;
      uint64_t v42 = v11;
      __int16 v43 = 2049;
      uint64_t v44 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    uint64_t v13 = *(void *)(a1 + 184);
    uint64_t v14 = *(void *)(a1 + 192);
    uint64_t v15 = (void *)(v13 + 8LL * (*(void *)(a1 + 208) >> 7));
    if (v14 == v13) {
      uint64_t v16 = 0LL;
    }
    else {
      uint64_t v16 = *v15 + 32 * (*(void *)(a1 + 208) & 0x7FLL);
    }
    while (1)
    {
      if (v14 == v13)
      {
        uint64_t v22 = 0LL;
      }

      else
      {
        unint64_t v21 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        uint64_t v22 = *(void *)(v13 + ((v21 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v21 & 0x7F);
      }

      if (v16 == v22) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10182C7F0);
      }
      __int128 v23 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10182C7F0);
        }
        LOWORD(v37) = 0;
        LODWORD(v35) = 2;
        unint64_t v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v37,  v35);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<CLCardioChange::AggregateFeatureEntry, CLActivityDB::ClassBDataProtectionPol icy>::setDatabaseAccessible() [T = CLCardioChange::AggregateFeatureEntry, DataProtectionPolicy = CLActivityDB: :ClassBDataProtectionPolicy]",  "%s\n",  v25);
      }

      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v16, 1LL);
      v16 += 32LL;
      if (v16 - *v15 == 4096)
      {
        uint64_t v24 = v15[1];
        ++v15;
        uint64_t v16 = v24;
      }

      uint64_t v13 = *(void *)(a1 + 184);
      uint64_t v14 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182C7D0);
    }
    uint64_t v17 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      unint64_t v18 = (void *)(a1 + 88);
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v40 = 0;
      *(_WORD *)&v40[4] = 2082;
      *(void *)&v40[6] = "";
      __int16 v41 = 2082;
      uint64_t v42 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182C7D0);
      }
    }

    uint64_t v19 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      unint64_t v20 = (void *)(a1 + 88);
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)uint64_t v40 = 0;
      *(_WORD *)&v40[4] = 2082;
      *(void *)&v40[6] = "";
      __int16 v41 = 2082;
      uint64_t v42 = v20;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12std::istream::~istream(v2, v3 + 8) = 1;
  }

  uint64_t v26 = *(void ***)(a1 + 184);
  uint64_t v27 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v28 = v27 - (void)v26;
  if (v28 >= 0x11)
  {
    do
    {
      operator delete(*v26);
      uint64_t v29 = *(void *)(a1 + 192);
      uint64_t v26 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v26;
      unint64_t v28 = v29 - (void)v26;
    }

    while (v28 > 0x10);
  }

  if (v28 >> 3 == 1)
  {
    uint64_t v30 = 64LL;
  }

  else
  {
    if (v28 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v30 = 128LL;
  }

  *(void *)(a1 + 20std::istream::~istream(v2, v3 + 8) = v30;
LABEL_61:
  unint64_t v31 = *(void **)(a1 + 144);
  if (v31)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_10024EC24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

__n128 sub_10024EC58(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  __int128 v4 = *(_OWORD *)(a3 + 16);
  *a2 = *(_OWORD *)a3;
  a2[1] = v4;
  return result;
}

id *sub_10024EC64(uint64_t a1, uint64_t a2, char a3)
{
  v32[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v32[1] = 0LL;
  if (*(double *)(a1 + 232) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v32);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  uint64_t v28 = 0LL;
  double v29 = 0.0;
  int v30 = -1;
  uint64_t v31 = 0LL;
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 104LL))(a1, &v28);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182C7D0);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182C7D0);
        }
        LOWORD(v33) = 0;
        uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v33,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<CLCardioChange::AggregateFeatureEntry, CLActivityDB::ClassBDataProtectionPol icy>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLCardioChange::AggregateFeatureEntry, DataProtectionPoli cy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v15);
      }

      goto LABEL_43;
    }

    double v7 = *(double *)(a2 + 8);
    double v8 = v29;
    double v9 = v7 - v29;
    if (v7 - v29 < 0.0) {
      double v9 = -(v7 - v29);
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182C7D0);
      }
      uint64_t v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a2 + 8);
        *(_DWORD *)uint64_t buf = 134349312;
        double v38 = v29;
        __int16 v39 = 2050;
        uint64_t v40 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182C7D0);
        }
        uint64_t v22 = *(void *)(a2 + 8);
        int v33 = 134349312;
        double v34 = v29;
        __int16 v35 = 2050;
        uint64_t v36 = v22;
        __int128 v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v33,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLCardioChange::AggregateFeatureEntry, CLActivityDB::ClassBDataProtectionPol icy>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLCardioChange::AggregateFeatureEntry, DataProtectionPoli cy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v23);
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *(double *)(a2 + 8);
      double v8 = v29;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182C7D0);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *(double *)(a2 + 8);
          *(_DWORD *)uint64_t buf = 134217984;
          double v38 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10182C7D0);
          }
          double v24 = *(double *)(a2 + 8);
          int v33 = 134217984;
          double v34 = v24;
          unint64_t v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v33));
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLCardioChange::AggregateFeatureEntry, CLActivityDB::ClassBDataProtectionP olicy>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLCardioChange::AggregateFeatureEntry, DataProtection Policy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v25);
        }

        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v16 = v7 - v8;
      double v17 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v27 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_10182C7D0);
        double v17 = v27;
      }

      double v18 = v16 - v17;
      uint64_t v19 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)uint64_t buf = 134217984;
        double v38 = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182C7D0);
        }
        int v33 = 134217984;
        double v34 = v18;
        uint64_t v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v33));
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLCardioChange::AggregateFeatureEntry, CLActivityDB::ClassBDataProtectionPol icy>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLCardioChange::AggregateFeatureEntry, DataProtectionPoli cy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v26);
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v18);
    }

    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)a1 + 144LL))(a1, &v28, a1 + 224, a2);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_10024F3B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10024F3DC(void *a1, uint64_t a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    __int128 v20 = (_Unwind_Exception *)sub_101231CB4(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  uint64_t v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 8)))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_10024F63C(void *a1, double a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_101231E20(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_10024F874(uint64_t a1)
{
  return sub_10024E51C(a1 - 72);
}

void sub_10024F87C(id a1)
{
  qword_101934768 = (uint64_t)os_log_create("com.apple.locationd.Motion", "CardioChange");
}

uint64_t sub_10024F8A8(void *a1, uint64_t a2)
{
  __int128 v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_101231F8C(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  uint64_t v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  double v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

void sub_10024FAD0(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_10024FAFC(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

uint64_t sub_10024FE48(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v10 = v5++ >= 9;
      if (v10)
      {
        unint64_t v6 = 0LL;
        uint64_t v11 = OBJC_IVAR___PBDataReader__error;
        int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    uint64_t v11 = OBJC_IVAR___PBDataReader__error;
    int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v12 || (v6 & 7) == 4) {
      break;
    }
    switch((v6 >> 3))
    {
      case 1u:
        *(_BYTE *)(a1 + 52) |= 2u;
        unint64_t v14 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v14 <= 0xFFFFFFFFFFFFFFF7LL && v14 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v15 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v14);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v14 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v15 = 0LL;
        }

        uint64_t v47 = 24LL;
        goto LABEL_91;
      case 2u:
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0LL;
        while (2)
        {
          uint64_t v20 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v21 = v20 + 1;
          if (v20 == -1 || v21 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v22 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v20);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v21;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if (v22 < 0)
            {
              v17 += 7;
              BOOL v10 = v18++ >= 9;
              if (v10)
              {
                LODWORD(v19) = 0;
                goto LABEL_67;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v19) = 0;
        }
LABEL_67:
        uint64_t v46 = 32LL;
        goto LABEL_80;
      case 3u:
        unint64_t v23 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v23 <= 0xFFFFFFFFFFFFFFF7LL && v23 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v15 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v23);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v23 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + v11) = 1;
          uint64_t v15 = 0LL;
        }

        uint64_t v47 = 8LL;
        goto LABEL_91;
      case 4u:
        char v24 = 0;
        unsigned int v25 = 0;
        uint64_t v19 = 0LL;
        while (2)
        {
          uint64_t v26 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v27 = v26 + 1;
          if (v26 == -1 || v27 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v28 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v26);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v27;
            v19 |= (unint64_t)(v28 & 0x7F) << v24;
            if (v28 < 0)
            {
              v24 += 7;
              BOOL v10 = v25++ >= 9;
              if (v10)
              {
                LODWORD(v19) = 0;
                goto LABEL_71;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v19) = 0;
        }
LABEL_71:
        uint64_t v46 = 36LL;
        goto LABEL_80;
      case 5u:
        char v29 = 0;
        unsigned int v30 = 0;
        uint64_t v19 = 0LL;
        while (2)
        {
          uint64_t v31 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v32 = v31 + 1;
          if (v31 == -1 || v32 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v33 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v31);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v32;
            v19 |= (unint64_t)(v33 & 0x7F) << v29;
            if (v33 < 0)
            {
              v29 += 7;
              BOOL v10 = v30++ >= 9;
              if (v10)
              {
                LODWORD(v19) = 0;
                goto LABEL_75;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v19) = 0;
        }
LABEL_75:
        uint64_t v46 = 40LL;
        goto LABEL_80;
      case 6u:
        *(_BYTE *)(a1 + 52) |= 1u;
        unint64_t v34 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v34 <= 0xFFFFFFFFFFFFFFF7LL && v34 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v15 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v34);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v34 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v15 = 0LL;
        }

        uint64_t v47 = 16LL;
LABEL_91:
        *(void *)(a1 + v47) = v15;
        continue;
      case 7u:
        char v35 = 0;
        unsigned int v36 = 0;
        uint64_t v19 = 0LL;
        *(_BYTE *)(a1 + 52) |= 4u;
        while (2)
        {
          uint64_t v37 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v38 = v37 + 1;
          if (v37 == -1 || v38 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v39 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v37);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v38;
            v19 |= (unint64_t)(v39 & 0x7F) << v35;
            if (v39 < 0)
            {
              v35 += 7;
              BOOL v10 = v36++ >= 9;
              if (v10)
              {
                LODWORD(v19) = 0;
                goto LABEL_79;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v19) = 0;
        }
LABEL_79:
        uint64_t v46 = 44LL;
LABEL_80:
        *(_DWORD *)(a1 + v46) = v19;
        continue;
      case 8u:
        char v40 = 0;
        unsigned int v41 = 0;
        uint64_t v42 = 0LL;
        break;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        continue;
    }

    while (1)
    {
      uint64_t v43 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v44 = v43 + 1;
      if (v43 == -1 || v44 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v45 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v43);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v44;
      v42 |= (unint64_t)(v45 & 0x7F) << v40;
      if ((v45 & 0x80) == 0) {
        goto LABEL_82;
      }
      v40 += 7;
      BOOL v10 = v41++ >= 9;
      if (v10)
      {
        uint64_t v42 = 0LL;
        goto LABEL_84;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_82:
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      uint64_t v42 = 0LL;
    }
LABEL_84:
    *(_BYTE *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v42 != 0;
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_100250B68()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361B8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361B8))
    {
      qword_1019361A0 = 0LL;
      qword_1019361A8 = 0LL;
      qword_1019361B0 = 0LL;
      uint64_t v1 = operator new(6uLL);
      qword_1019361A8 = (uint64_t)(v1 + 3);
      qword_1019361B0 = (uint64_t)(v1 + 3);
      *(_DWORD *)uint64_t v1 = 151521030;
      v1[2] = 3082;
      qword_1019361A0 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1001CDCD0, &qword_1019361A0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361B8);
    }
  }

void sub_100250C04(_Unwind_Exception *a1)
{
}

void sub_100250C1C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361D8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361D8))
    {
      qword_1019361C0 = 0LL;
      qword_1019361C8 = 0LL;
      qword_1019361D0 = 0LL;
      uint64_t v1 = operator new(2uLL);
      qword_1019361C0 = (uint64_t)v1;
      *uint64_t v1 = 256;
      qword_1019361C8 = (uint64_t)(v1 + 1);
      qword_1019361D0 = (uint64_t)(v1 + 1);
      __cxa_atexit((void (*)(void *))sub_1001CDD00, &qword_1019361C0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361D8);
    }
  }

void sub_100250CA8(_Unwind_Exception *a1)
{
}

void sub_100250CC0(uint64_t a1, void *a2, uint64_t a3, char a4, int a5)
{
  if (a4)
  {
    uint64_t v7 = 26LL;
    int64x2_t v17 = vdupq_n_s64(0x1AuLL);
    uint64_t v18 = 0LL;
    int v8 = (int)(sub_101171D4C() - *(double *)&a3);
    int v19 = v8;
    unint64_t v20 = 0xFFFFFFFF00000000LL;
    switch(a5)
    {
      case 0:
        uint64_t v9 = 0LL;
        uint64_t v7 = 26LL;
        int64x2_t v17 = vdupq_n_s64(0x1AuLL);
        int v10 = 4;
        uint64_t v11 = 26LL;
        goto LABEL_17;
      case 1:
        uint64_t v11 = a2[15];
        uint64_t v7 = a2[5];
        v17.i64[0] = v11;
        v17.i64[1] = v7;
        uint64_t v9 = a2[8];
        int v10 = 5;
        goto LABEL_17;
      case 2:
        uint64_t v11 = a2[15];
        uint64_t v7 = a2[5];
        v17.i64[0] = v11;
        v17.i64[1] = v7;
        uint64_t v9 = a2[8];
        int v10 = 6;
        goto LABEL_17;
      case 3:
        uint64_t v11 = a2[15];
        uint64_t v7 = a2[4];
        v17.i64[0] = v11;
        v17.i64[1] = v7;
        uint64_t v9 = a2[7];
        int v10 = 7;
LABEL_17:
        uint64_t v18 = v9;
        LODWORD(v2sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v10;
        break;
      default:
        uint64_t v9 = 0LL;
        int v10 = 0;
        uint64_t v11 = 26LL;
        break;
    }

    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10182C810);
    }
    unint64_t v14 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 67110144;
      int v32 = v10;
      __int16 v33 = 2048;
      uint64_t v34 = v11;
      __int16 v35 = 2048;
      uint64_t v36 = v7;
      __int16 v37 = 2048;
      uint64_t v38 = v9;
      __int16 v39 = 1024;
      int v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Escalation analytics, attempting to send event with resolution, %d, escalation type, %ld, workout type, %ld, loc ation type, %ld, escalation durationS, %d",  buf,  0x2Cu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10182C810);
      }
      int v21 = 67110144;
      int v22 = v10;
      __int16 v23 = 2048;
      uint64_t v24 = v11;
      __int16 v25 = 2048;
      uint64_t v26 = v7;
      __int16 v27 = 2048;
      uint64_t v28 = v9;
      __int16 v29 = 1024;
      int v30 = v8;
      LODWORD(v16) = 44;
      uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "Escalation analytics, attempting to send event with resolution, %d, escalation type, %ld, workout type, %ld, location type, %ld, escalation durationS, %d",  &v21,  v16,  v17.i64[0],  v17.i64[1],  v18);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutEscalationMetrics::feedEarlyEscalationUpdate(const CLWorkoutPredictor_Type::WorkoutPrediction &, s td::optional<CFTimeInterval>, EarlyEscalationResolution)",  "%s\n",  v15);
    }

    sub_100251104(v17.i64);
  }

  else
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10182C810);
    }
    int v12 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 67109120;
      int v32 = a5;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Escalation analytics, not tracking an early escalation for resolution %d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10182C810);
      }
      int v21 = 67109120;
      int v22 = a5;
      uint64_t v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "Escalation analytics, not tracking an early escalation for resolution %d",  &v21);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutEscalationMetrics::feedEarlyEscalationUpdate(const CLWorkoutPredictor_Type::WorkoutPrediction &, s td::optional<CFTimeInterval>, EarlyEscalationResolution)",  "%s\n",  v13);
    }
  }

void sub_100251104(uint64_t *a1)
{
  if (objc_opt_class(&OBJC_CLASS___MCProfileConnection)
    && (objc_msgSend( +[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"),  "isHealthDataSubmissionAllowed") & 1) != 0)
  {
    if (*((int *)a1 + 6) > 0)
    {
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10182C810);
      }
      uint64_t v2 = (os_log_s *)qword_101934688;
      if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v3 = *a1;
        uint64_t v4 = a1[1];
        uint64_t v5 = a1[2];
        int v6 = *((_DWORD *)a1 + 6);
        int v7 = *((_DWORD *)a1 + 7);
        int v8 = *((_DWORD *)a1 + 8);
        *(_DWORD *)uint64_t buf = 68290562;
        int v17 = 0;
        __int16 v18 = 2082;
        int v19 = "";
        __int16 v20 = 1026;
        int v21 = v3;
        __int16 v22 = 1026;
        int v23 = v4;
        __int16 v24 = 1026;
        int v25 = v5;
        __int16 v26 = 1026;
        int v27 = v6;
        __int16 v28 = 1026;
        int v29 = v7;
        __int16 v30 = 1026;
        int v31 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Sending escalation event to CoreAnalytics, escType:%{public}d, workoutType:%{ public}d, workoutLocation:%{public}d, escTime:%{public}d, escToWorkout:%{public}d, pctBackground Escalation:%{public}d}",  buf,  0x36u);
      }

      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472LL;
      v14[2] = sub_100251628;
      void v14[3] = &unk_101820718;
      v14[4] = a1;
      AnalyticsSendEventLazy(@"com.apple.CoreMotion.FitnessEscalation", v14);
      return;
    }

    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10182C810);
    }
    int v10 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_ERROR))
    {
      int v11 = *((_DWORD *)a1 + 6);
      *(_DWORD *)uint64_t buf = 67109120;
      int v17 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "Not sending escalation event to CoreAnalytics, invalid escalation time recorded %d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10182C810);
      }
      int v12 = *((_DWORD *)a1 + 6);
      v15[0] = 67109120;
      v15[1] = v12;
      uint64_t v13 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  16LL,  "Not sending escalation event to CoreAnalytics, invalid escalation time recorded %d",  v15);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "static void CLWorkoutEscalationMetrics::sendEventToCoreAnalytics(const WorkoutEscalationEvent &)",  "%s\n");
LABEL_26:
      if (v13 != buf) {
        free(v13);
      }
    }
  }

  else
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10182C810);
    }
    uint64_t v9 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "Not sending escalation event to CoreAnalytics, no IHA permission",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10182C810);
      }
      LOWORD(v15[0]) = 0;
      uint64_t v13 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  1LL,  "Not sending escalation event to CoreAnalytics, no IHA permission",  v15,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLWorkoutEscalationMetrics::sendEventToCoreAnalytics(const WorkoutEscalationEvent &)",  "%s\n");
      goto LABEL_26;
    }
  }

double sub_100251504(uint64_t a1, uint64_t a2)
{
  switch(*(void *)(a2 + 16))
  {
    case 0LL:
      if (*(_BYTE *)a1)
      {
        uint64_t v3 = (uint64_t *)(a1 + 16);
        int v4 = 2;
        goto LABEL_11;
      }

      break;
    case 8LL:
      *(int64x2_t *)(a1 + 16) = vdupq_n_s64(0x1AuLL);
      *(void *)(a1 + 32) = 0LL;
      *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0xFFFFFFFFLL;
      *(_DWORD *)(a1 + 4std::istream::~istream(v2, v3 + 8) = -1;
      *(_BYTE *)a1 = 1;
      *(void *)&__int128 v5 = *(void *)(a2 + 24);
      *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v5;
      *(void *)(a1 + 16) = *(void *)(a2 + 48);
      break;
    case 9LL:
      if (*(_BYTE *)a1)
      {
        __int128 v5 = *(_OWORD *)(a2 + 112);
        *(_OWORD *)(a1 + 24) = v5;
      }

      break;
    case 0xALL:
      if (*(_BYTE *)a1)
      {
        uint64_t v3 = (uint64_t *)(a1 + 16);
        int v4 = 1;
        goto LABEL_11;
      }

      break;
    case 0xBLL:
      if (*(_BYTE *)a1)
      {
        uint64_t v3 = (uint64_t *)(a1 + 16);
        int v4 = 3;
LABEL_11:
        *(_DWORD *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = (int)(*(double *)(a2 + 24) - *(double *)(a1 + 8));
        *(_DWORD *)(a1 + 44) = v4;
        *(_DWORD *)(a1 + 4std::istream::~istream(v2, v3 + 8) = (int)(*(double *)(a2 + 40) * 100.0);
        sub_100251104(v3);
        *(int64x2_t *)(a1 + 16) = vdupq_n_s64(0x1AuLL);
        *(void *)(a1 + 32) = 0LL;
        *(void *)&__int128 v5 = 0xFFFFFFFFLL;
        *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0xFFFFFFFFLL;
        *(_DWORD *)(a1 + 4std::istream::~istream(v2, v3 + 8) = -1;
        *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0xBFF0000000000000LL;
        *(_BYTE *)a1 = 0;
      }

      break;
    default:
      return *(double *)&v5;
  }

  return *(double *)&v5;
}

NSDictionary *sub_100251628(uint64_t a1)
{
  v3[0] = @"escType";
  v4[0] = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", **(void **)(a1 + 32));
  v3[1] = @"workoutType";
  v4[1] = +[NSNumber numberWithInteger:]( &OBJC_CLASS___NSNumber,  "numberWithInteger:",  *(void *)(*(void *)(a1 + 32) + 8LL));
  _DWORD v3[2] = @"workoutLocation";
  _DWORD v4[2] = +[NSNumber numberWithInteger:]( &OBJC_CLASS___NSNumber,  "numberWithInteger:",  *(void *)(*(void *)(a1 + 32) + 16LL));
  v3[3] = @"escTime";
  void v4[3] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 24LL));
  v3[4] = @"escToWorkout";
  v4[4] = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 28LL));
  v3[5] = @"pctBackgroundEscalation";
  void v4[5] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 32LL));
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v4,  v3,  6LL);
}

void sub_100251754(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

void sub_100251780(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (sub_100E02D88() == 1)
  {
    int v4 = operator new(0x18uLL);
    *(void *)int v4 = off_10182C840;
    _DWORD v4[2] = 1;
    *((_BYTE *)v4 + 12) = 0;
    *((void *)v4 + 2) = a1;
  }

  else
  {
    int v4 = operator new(0x110uLL);
    sub_100C4ED10((uint64_t)v4, a1);
  }

  *a2 = v4;
}

void sub_1002517F8(_Unwind_Exception *a1)
{
}

uint64_t sub_10025180C(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = off_10182C840;
  *(_DWORD *)(result + std::istream::~istream(v2, v3 + 8) = 1;
  *(_BYTE *)(result + 12) = 0;
  *(void *)(result + 16) = a2;
  return result;
}

void sub_10025182C(uint64_t a1, uint64_t a2)
{
  if ((_DWORD)a2 == 1)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C888);
    }
    int v4 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32LL))(a1, 1LL);
      *(_DWORD *)uint64_t buf = 67240192;
      int v27 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "FitnessMode, checking to start collector in active energy mode, should start %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C888);
      }
      uint64_t v12 = qword_1019344D8;
      int v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32LL))(a1, 1LL);
      int v20 = 67240192;
      int v21 = v13;
      unint64_t v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v12,  0LL,  "FitnessMode, checking to start collector in active energy mode, should start %{public}d",  &v20,  8);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLFitnessModeControllerBase::feedMoveModeUpdate(CLFitnessTrackingNotifier_Type::ActivityMoveMode)",  "%s\n",  v14);
    }
  }

  if (*(_DWORD *)(a1 + 8) != (_DWORD)a2)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C888);
    }
    int v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *(_DWORD *)(a1 + 8);
      int v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32LL))(a1, a2);
      *(_DWORD *)uint64_t buf = 67240704;
      int v27 = v7;
      __int16 v28 = 1026;
      int v29 = a2;
      __int16 v30 = 1026;
      int v31 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "FitnessMode, activity move mode changed from %{public}d to %{public}d, should start %{public}d",  buf,  0x14u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C888);
      }
      uint64_t v15 = qword_1019344D8;
      int v16 = *(_DWORD *)(a1 + 8);
      int v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32LL))(a1, a2);
      int v20 = 67240704;
      int v21 = v16;
      __int16 v22 = 1026;
      int v23 = a2;
      __int16 v24 = 1026;
      int v25 = v17;
      LODWORD(v19) = 20;
      __int16 v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  0LL,  "FitnessMode, activity move mode changed from %{public}d to %{public}d, should start %{public}d",  &v20,  v19);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLFitnessModeControllerBase::feedMoveModeUpdate(CLFitnessTrackingNotifier_Type::ActivityMoveMode)",  "%s\n",  v18);
    }

    *(_DWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = a2;
    uint64_t v9 = *(void (****)(void, uint64_t))(a1 + 16);
    if (v9)
    {
      (**v9)(v9, a2);
      uint64_t v10 = *(void *)(a1 + 16);
      if (v10)
      {
        (*(void (**)(uint64_t))(*(void *)v10 + 16LL))(v10);
        if (*(void *)(a1 + 16))
        {
          int v11 = *(_DWORD *)(a1 + 8);
          if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 32LL))(a1, a2)) {
            (*(void (**)(void, uint64_t, BOOL))(**(void **)(a1 + 16) + 8LL))( *(void *)(a1 + 16),  a2,  v11 == 1);
          }
        }
      }
    }
  }

void *sub_100251C64(void *result, uint64_t a2, uint64_t a3)
{
  if (result[2])
  {
    int v5 = result;
    uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 32LL))(result);
    if ((_DWORD)result) {
      return (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v5[2] + 8LL))(v5[2], a2, a3);
    }
  }

  return result;
}

void sub_100251CCC(uint64_t a1, int a2)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10182C888);
  }
  int v4 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(unsigned __int8 *)(a1 + 12);
    *(_DWORD *)uint64_t buf = 67240448;
    int v14 = v5;
    __int16 v15 = 1026;
    int v16 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "FitnessMode, fitness tracking update from %{public}d to %{public}d",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C888);
    }
    int v8 = *(unsigned __int8 *)(a1 + 12);
    v10[0] = 67240448;
    v10[1] = v8;
    __int16 v11 = 1026;
    int v12 = a2;
    uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "FitnessMode, fitness tracking update from %{public}d to %{public}d",  v10,  14);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLFitnessModeControllerBase::feedFitnessTrackingUpdate(BOOL)",  "%s\n",  v9);
  }

  *(_BYTE *)(a1 + 12) = a2;
  if (a2)
  {
    if (*(void *)(a1 + 16))
    {
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a1 + 32LL))(a1, v6)) {
        (*(void (**)(void, uint64_t, BOOL))(**(void **)(a1 + 16) + 8LL))( *(void *)(a1 + 16),  v6,  (_DWORD)v6 == 1);
      }
    }
  }

  else
  {
    uint64_t v7 = *(void *)(a1 + 16);
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 16LL))(v7);
    }
  }

uint64_t sub_100251EF8(void *a1)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 32LL))(a1);
  if ((result & 1) == 0)
  {
    uint64_t result = a1[2];
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 16LL))(result);
    }
  }

  return result;
}

uint64_t sub_100251F40(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 12);
}

void sub_100251F48(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_1002522C0(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v10 = v5++ >= 9;
      if (v10)
      {
        unint64_t v6 = 0LL;
        uint64_t v11 = OBJC_IVAR___PBDataReader__error;
        int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    uint64_t v11 = OBJC_IVAR___PBDataReader__error;
    int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v12 || (v6 & 7) == 4) {
      break;
    }
    switch((v6 >> 3))
    {
      case 1u:
        unint64_t v14 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v14 <= 0xFFFFFFFFFFFFFFF7LL && v14 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v15 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v14);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v14 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + v11) = 1;
          uint64_t v15 = 0LL;
        }

        uint64_t v38 = 8LL;
        goto LABEL_64;
      case 2u:
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0LL;
        while (2)
        {
          uint64_t v20 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v21 = v20 + 1;
          if (v20 == -1 || v21 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v22 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v20);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v21;
            v19 |= (unint64_t)(v22 & 0x7F) << v17;
            if (v22 < 0)
            {
              v17 += 7;
              BOOL v10 = v18++ >= 9;
              if (v10)
              {
                LODWORD(v19) = 0;
                goto LABEL_50;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v19) = 0;
        }
LABEL_50:
        *(_DWORD *)(a1 + 24) = v19;
        continue;
      case 3u:
        char v23 = 0;
        unsigned int v24 = 0;
        uint64_t v25 = 0LL;
        while (2)
        {
          uint64_t v26 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v27 = v26 + 1;
          if (v26 == -1 || v27 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v28 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v26);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v27;
            v25 |= (unint64_t)(v28 & 0x7F) << v23;
            if (v28 < 0)
            {
              v23 += 7;
              BOOL v10 = v24++ >= 9;
              if (v10)
              {
                uint64_t v25 = 0LL;
                goto LABEL_54;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v25 = 0LL;
        }
LABEL_54:
        BOOL v36 = v25 != 0;
        uint64_t v37 = 28LL;
        goto LABEL_59;
      case 4u:
        *(_BYTE *)(a1 + 32) |= 1u;
        unint64_t v29 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v29 <= 0xFFFFFFFFFFFFFFF7LL && v29 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v15 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v29);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v29 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v15 = 0LL;
        }

        uint64_t v38 = 16LL;
LABEL_64:
        *(void *)(a1 + v3std::istream::~istream(v2, v3 + 8) = v15;
        continue;
      case 5u:
        char v30 = 0;
        unsigned int v31 = 0;
        uint64_t v32 = 0LL;
        break;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        continue;
    }

    while (1)
    {
      uint64_t v33 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v34 = v33 + 1;
      if (v33 == -1 || v34 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v35 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v33);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v34;
      v32 |= (unint64_t)(v35 & 0x7F) << v30;
      if ((v35 & 0x80) == 0) {
        goto LABEL_56;
      }
      v30 += 7;
      BOOL v10 = v31++ >= 9;
      if (v10)
      {
        uint64_t v32 = 0LL;
        goto LABEL_58;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_56:
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      uint64_t v32 = 0LL;
    }
LABEL_58:
    BOOL v36 = v32 != 0;
    uint64_t v37 = 29LL;
LABEL_59:
    *(_BYTE *)(a1 + v37) = v36;
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_100252BA4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 16);
  if (v2 > 9)
  {
    if (v2 == 10)
    {
      if (!*(_BYTE *)a1) {
        return;
      }
      int v3 = 3;
      goto LABEL_13;
    }

    if (v2 == 11)
    {
      *(int64x2_t *)(a1 + 16) = vdupq_n_s64(0x1AuLL);
      *(void *)(a1 + 32) = 0xFFFFFFFFLL;
      *(_BYTE *)a1 = 1;
      *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = *(void *)(a2 + 24);
    }
  }

  else
  {
    if (!v2)
    {
      if (!*(_BYTE *)a1) {
        return;
      }
      int v3 = 1;
      goto LABEL_13;
    }

    if (v2 == 6 && *(_BYTE *)a1)
    {
      int v3 = 2;
LABEL_13:
      *(_DWORD *)(a1 + 32) = (int)(*(double *)(a2 + 24) - *(double *)(a1 + 8));
      *(_DWORD *)(a1 + 36) = v3;
      sub_100252C3C(a1);
    }
  }

void sub_100252C3C(uint64_t a1)
{
  if (objc_opt_class(&OBJC_CLASS___MCProfileConnection)
    && (objc_msgSend( +[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"),  "isHealthDataSubmissionAllowed") & 1) != 0)
  {
    if (*(int *)(a1 + 32) > 0)
    {
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10182C8E8);
      }
      uint64_t v2 = (os_log_s *)qword_101934688;
      if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v3 = *(void *)(a1 + 16);
        uint64_t v4 = *(void *)(a1 + 24);
        int v5 = *(_DWORD *)(a1 + 32);
        int v6 = *(_DWORD *)(a1 + 36);
        *(_DWORD *)uint64_t buf = 68290050;
        int v16 = 0;
        __int16 v17 = 2082;
        unsigned int v18 = "";
        __int16 v19 = 1026;
        int v20 = v3;
        __int16 v21 = 1026;
        int v22 = v4;
        __int16 v23 = 1026;
        int v24 = v5;
        __int16 v25 = 1026;
        int v26 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Sending alert event to CoreAnalytics, alertWorkoutType:%{public}d, acceptedWork outType:%{public}d, alertActiveTime:%{public}d, alertStatus:%{public}d}",  buf,  0x2Au);
      }

      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472LL;
      _DWORD v13[2] = sub_100253014;
      void v13[3] = &unk_101820718;
      v13[4] = a1;
      AnalyticsSendEventLazy(@"com.apple.CoreMotion.FitnessAlert", v13);
      *(int64x2_t *)(a1 + 16) = vdupq_n_s64(0x1AuLL);
      *(void *)(a1 + 32) = 0xFFFFFFFFLL;
      *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0xBFF0000000000000LL;
      *(_BYTE *)a1 = 0;
      return;
    }

    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10182C8E8);
    }
    unint64_t v8 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
    {
      int v9 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)uint64_t buf = 67109120;
      int v16 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Not sending alert event to CoreAnalytics, invalid escalation time recorded %d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10182C8E8);
      }
      int v10 = *(_DWORD *)(a1 + 32);
      v14[0] = 67109120;
      v14[1] = v10;
      uint64_t v11 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  2LL,  "Not sending alert event to CoreAnalytics, invalid escalation time recorded %d",  v14);
LABEL_26:
      int v12 = (uint8_t *)v11;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLWorkoutAlertMetrics::sendEventToCoreAnalytics()", "%s\n", v11);
      if (v12 != buf) {
        free(v12);
      }
    }
  }

  else
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10182C8E8);
    }
    uint64_t v7 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "Not sending alert event to CoreAnalytics, no IHA permission",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10182C8E8);
      }
      LOWORD(v14[0]) = 0;
      uint64_t v11 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  1LL,  "Not sending alert event to CoreAnalytics, no IHA permission");
      goto LABEL_26;
    }
  }

NSDictionary *sub_100253014(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  v3[0] = @"alertWorkoutType";
  v4[0] = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", *(void *)(v1 + 16));
  v3[1] = @"acceptedWorkoutType";
  v4[1] = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", *(void *)(v1 + 24));
  _DWORD v3[2] = @"alertActiveTime";
  _DWORD v4[2] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(v1 + 32));
  v3[3] = @"alertStatus";
  void v4[3] = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v1 + 36));
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v4,  v3,  4LL);
}

void sub_1002530F0(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

uint64_t sub_10025324C(uint64_t a1, uint64_t a2, double a3)
{
  if ((*(unsigned int (**)(void))(**(void **)(a2 + 48) + 48LL))(*(void *)(a2 + 48)))
  {
    (*(void (**)(void, _BYTE *, double))(**(void **)(a2 + 48) + 24LL))(*(void *)(a2 + 48), v7, a3);
    if (v7[208])
    {
      sub_100253308(*(void *)(a2 + 8));
      sub_100253308(*(void *)(a2 + 80));
    }
  }

  return nullsub_1227(a1 + 8, a2, a3);
}

BOOL sub_100253308(uint64_t a1)
{
  double v2 = *(double *)(a1 + 104);
  double v3 = *(double *)(a1 + 112);
  if (*(_BYTE *)(a1 + 80))
  {
    BOOL result = 1LL;
  }

  else if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 64LL))(a1) & 1) != 0)
  {
    *(double *)(a1 + 72) = v2;
    BOOL result = 1LL;
    *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
    *(_BYTE *)(a1 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
  }

  else
  {
    BOOL result = *(_BYTE *)(a1 + 80) != 0;
  }

  double v5 = v2 + v3;
  *(double *)(a1 + 8std::istream::~istream(v2, v3 + 8) = v5;
  return result;
}

uint64_t sub_100253388(double a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a3 + 8) + 48LL))(*(void *)(a3 + 8));
  if ((_DWORD)result) {
    return (*(uint64_t (**)(void, double))(**(void **)(a3 + 80) + 48LL))(*(void *)(a3 + 80), a1);
  }
  return result;
}

void sub_1002533E4(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  float v4 = *(float *)(a1 + 1232);
  double v5 = *(float *)(a1 + 1236);
  BOOL v6 = v5 <= 0.1;
  HIDWORD(v37) = *(_DWORD *)(a1 + 296);
  double v38 = v4;
  BOOL v7 = v4 < 0.6;
  int v8 = 2;
  if (v5 < 0.2) {
    int v9 = 1;
  }
  else {
    int v9 = 2;
  }
  int v10 = v6 && v7;
  if (v6 && v7) {
    unsigned int v11 = 0;
  }
  else {
    unsigned int v11 = v9;
  }
  float v12 = *(double *)(a1 + 560);
  int v13 = 0;
  if (sub_1003DBFB4(a1))
  {
    if (v12 <= 120.0) {
      int v14 = 1;
    }
    else {
      int v14 = 2;
    }
    else {
      int v13 = v14;
    }
  }

  *(void *)a2 = 0LL;
  *(void *)(a2 + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(void *)(a2 + 24) = 3LL;
  *(void *)(a2 + 32) = 3LL;
  double v15 = *(double *)(a1 + 1416);
  float v16 = v15;
  double v36 = v12;
  float v17 = (*(float *)(a1 + 1380) - v12) / (*(float *)(a1 + 1380) - *(float *)(a1 + 1376));
  float v19 = (float)(sub_100D086F8(v17, *(float *)(a1 + 1372)) * *(float *)(a1 + 1368)) / (float)(v16 + 1.0);
  *(float *)a2 = v19;
  double v20 = 8.5;
  if (v5 <= 2.1) {
    double v20 = sub_100253944(v18, (float *)a1);
  }
  float v21 = v20;
  if ((v10 & 1) != 0) {
    float v21 = 1.6;
  }
  if (!(v10 & 1 | (v5 >= 0.2))) {
    float v21 = v21 / 1.27;
  }
  *(float *)(a2 + 4) = v21;
  *(float *)(a2 + 12) = v21;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0x500000000LL;
  double v22 = 1.0;
  double v23 = 2.0999999;
  if (v13 == 2)
  {
    if (v11 < 2)
    {
      int v8 = 1;
      *(_DWORD *)(a2 + 24) = 1;
      *(_DWORD *)(a2 + 32) = 1;
      double v22 = 0.0;
      goto LABEL_33;
    }

    goto LABEL_32;
  }

  if (v13 == 1)
  {
    int v8 = 0;
    if ((v10 & 1) != 0 || v5 < 0.2) {
      goto LABEL_33;
    }
    int v8 = 2;
LABEL_32:
    *(_DWORD *)(a2 + 24) = 2;
    *(_DWORD *)(a2 + 32) = 2;
    double v22 = 0.5;
    double v23 = 4.40208912;
    goto LABEL_33;
  }

  int v8 = 0;
  double v23 = 2.0999999;
  if (((v5 >= 0.2) & ~v10) != 0) {
    double v23 = 4.40208912;
  }
LABEL_33:
  double v24 = v19;
  double v25 = v21;
  float v26 = v22 * v21 + (1.0 - v22) * v24;
  *(float *)(a2 + 2sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v26;
  *(float *)(a2 + 2std::istream::~istream(v2, v3 + 8) = v26;
  double v27 = v26;
  if (v23 > v26)
  {
    float v26 = v23;
    *(float *)(a2 + 2sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v26;
    int v8 = 3;
    *(_DWORD *)(a2 + 24) = 3;
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10182C968);
  }
  char v28 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v29 = *(void *)(a1 + 128);
    *(_DWORD *)uint64_t buf = 134221568;
    double v70 = v25;
    __int16 v71 = 2048;
    double v72 = v24;
    __int16 v73 = 2048;
    double v74 = v27;
    __int16 v75 = 2048;
    double v76 = v26;
    __int16 v77 = 2048;
    uint64_t v78 = v29;
    __int16 v79 = 2048;
    double v80 = v20;
    __int16 v81 = 1024;
    unsigned int v82 = v11;
    __int16 v83 = 2048;
    double v84 = v15;
    __int16 v85 = 2048;
    double v86 = v22;
    __int16 v87 = 1024;
    int v88 = v8;
    __int16 v89 = 2048;
    double v90 = v5;
    __int16 v91 = 2048;
    double v92 = *((float *)&v37 + 1);
    __int16 v93 = 2048;
    double v94 = v36;
    __int16 v95 = 1024;
    int v96 = v13;
    __int16 v97 = 2048;
    double v98 = v38;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "Dance,metsWR,%f,metsHR,%f,truthMets,%f,userMets,%f,endTime,%f,danceWrMets,%f,motionIntensity,%d,hrDrift,%f,wrWeigh t,%f,metsSource,%d,accelZ,%f,vm,%f,hr,%f,hrIntensity,%d,rotationRate,%f",  buf,  0x8Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C968);
    }
    double v30 = *(float *)(a2 + 20);
    uint64_t v31 = *(void *)(a1 + 128);
    int v32 = *(_DWORD *)(a2 + 24);
    int v39 = 134221568;
    double v40 = v25;
    __int16 v41 = 2048;
    double v42 = v24;
    __int16 v43 = 2048;
    double v44 = v27;
    __int16 v45 = 2048;
    double v46 = v30;
    __int16 v47 = 2048;
    uint64_t v48 = v31;
    __int16 v49 = 2048;
    double v50 = v20;
    __int16 v51 = 1024;
    unsigned int v52 = v11;
    __int16 v53 = 2048;
    double v54 = v15;
    __int16 v55 = 2048;
    double v56 = v22;
    __int16 v57 = 1024;
    int v58 = v32;
    __int16 v59 = 2048;
    double v60 = v5;
    __int16 v61 = 2048;
    double v62 = *((float *)&v37 + 1);
    __int16 v63 = 2048;
    double v64 = v36;
    __int16 v65 = 1024;
    int v66 = v13;
    __int16 v67 = 2048;
    double v68 = v38;
    LODWORD(v34) = 140;
    uint64_t v33 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Dance,metsWR,%f,metsHR,%f,truthMets,%f,userMets,%f,endTime,%f,danceWrMets,%f,motionIntensity,%d,hrDr ift,%f,wrWeight,%f,metsSource,%d,accelZ,%f,vm,%f,hr,%f,hrIntensity,%d,rotationRate,%f",  COERCE_DOUBLE(&v39),  v34,  v35,  v36,  v37,  v38);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLNatalieDanceModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v33);
  }

float sub_100253944(uint64_t a1, float *a2)
{
  uint64_t v2 = 0LL;
  float v3 = a2[308];
  float v4 = a2[309];
  float v5 = a2[310];
  float v6 = a2[341];
  float v7 = a2[340] * 100.0;
  *((float *)&v12 + 1) = v4;
  *(float *)&double v13 = v3;
  *((float *)&v13 + 1) = v3 * v5;
  unint64_t v14 = __PAIR64__(LODWORD(v7), LODWORD(v6));
  float v8 = -1.8389;
  do
  {
    float v8 = v8 + (float)(*(float *)((char *)&v12 + v2 * 4 + 4) * *(float *)&dword_1012E2EC0[v2]);
    ++v2;
  }

  while (v2 != 5);
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10182C968);
  }
  int v9 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 134219264;
    double v28 = v4;
    __int16 v29 = 2048;
    double v30 = v3;
    __int16 v31 = 2048;
    double v32 = v5;
    __int16 v33 = 2048;
    double v34 = v6;
    __int16 v35 = 2048;
    double v36 = v7;
    __int16 v37 = 2048;
    double v38 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "iz,%f,w,%f,cr,%f,weight,%f,height,%f,wr,%f",  buf,  0x3Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C968);
    }
    int v15 = 134219264;
    double v16 = v4;
    __int16 v17 = 2048;
    double v18 = v3;
    __int16 v19 = 2048;
    double v20 = v5;
    __int16 v21 = 2048;
    double v22 = v6;
    __int16 v23 = 2048;
    double v24 = v7;
    __int16 v25 = 2048;
    double v26 = v8;
    LODWORD(v12) = 62;
    unsigned int v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "iz,%f,w,%f,cr,%f,weight,%f,height,%f,wr,%f",  COERCE_DOUBLE(&v15),  v12,  v13,  *(double *)&v14);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "float CLNatalieDanceModel::computeWRRegression(const CLNatalieModelInput &) const",  "%s\n",  v11);
  }

  return v8;
}

void sub_100253BF0(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_100253FF0(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v10 = v5++ >= 9;
      if (v10)
      {
        unint64_t v6 = 0LL;
        uint64_t v11 = OBJC_IVAR___PBDataReader__error;
        int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    uint64_t v11 = OBJC_IVAR___PBDataReader__error;
    int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v12 || (v6 & 7) == 4) {
      break;
    }
    switch((v6 >> 3))
    {
      case 1u:
        unint64_t v14 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v14 <= 0xFFFFFFFFFFFFFFFBLL && v14 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          int v15 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v14);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v14 + 4;
        }

        else
        {
          *(_BYTE *)(a2 + v11) = 1;
          int v15 = 0;
        }

        uint64_t v33 = 28LL;
        goto LABEL_67;
      case 2u:
        unint64_t v17 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v17 <= 0xFFFFFFFFFFFFFFFBLL && v17 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          int v15 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v17);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v17 + 4;
        }

        else
        {
          *(_BYTE *)(a2 + v11) = 1;
          int v15 = 0;
        }

        uint64_t v33 = 12LL;
        goto LABEL_67;
      case 3u:
        unint64_t v18 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v18 <= 0xFFFFFFFFFFFFFFFBLL && v18 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          int v15 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v18);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v18 + 4;
        }

        else
        {
          *(_BYTE *)(a2 + v11) = 1;
          int v15 = 0;
        }

        uint64_t v33 = 16LL;
        goto LABEL_67;
      case 4u:
        unint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v19 <= 0xFFFFFFFFFFFFFFFBLL && v19 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          int v15 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v19 + 4;
        }

        else
        {
          *(_BYTE *)(a2 + v11) = 1;
          int v15 = 0;
        }

        uint64_t v33 = 20LL;
        goto LABEL_67;
      case 5u:
        unint64_t v20 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v20 <= 0xFFFFFFFFFFFFFFFBLL && v20 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          int v15 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v20);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v20 + 4;
        }

        else
        {
          *(_BYTE *)(a2 + v11) = 1;
          int v15 = 0;
        }

        uint64_t v33 = 24LL;
LABEL_67:
        *(_DWORD *)(a1 + v33) = v15;
        continue;
      case 6u:
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v23 = 0LL;
        while (2)
        {
          uint64_t v24 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v25 = v24 + 1;
          if (v24 == -1 || v25 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v26 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v24);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v25;
            v23 |= (unint64_t)(v26 & 0x7F) << v21;
            if (v26 < 0)
            {
              v21 += 7;
              BOOL v10 = v22++ >= 9;
              if (v10)
              {
                LODWORD(v23) = 0;
                goto LABEL_52;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v23) = 0;
        }
LABEL_52:
        *(_DWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = v23;
        continue;
      case 7u:
        char v27 = 0;
        unsigned int v28 = 0;
        uint64_t v29 = 0LL;
        break;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        continue;
    }

    while (1)
    {
      uint64_t v30 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v31 = v30 + 1;
      if (v30 == -1 || v31 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v32 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v30);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v31;
      v29 |= (unint64_t)(v32 & 0x7F) << v27;
      if ((v32 & 0x80) == 0) {
        goto LABEL_54;
      }
      v27 += 7;
      BOOL v10 = v28++ >= 9;
      if (v10)
      {
        uint64_t v29 = 0LL;
        goto LABEL_56;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_54:
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      uint64_t v29 = 0LL;
    }
LABEL_56:
    *(_BYTE *)(a1 + 32) = v29 != 0;
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

BOOL sub_100254C74(uint64_t a1)
{
  uint64_t v2 = (char *)sub_1002F8DDC();
  sub_10030AC8C(v2, (uint64_t)&__str);
  if (*(char *)(a1 + 79) < 0)
  {
    sub_1010DD48C(__p, *(void **)(a1 + 56), *(void *)(a1 + 64));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)(a1 + 56);
    uint64_t v9 = *(void *)(a1 + 72);
  }

  if (v9 >= 0) {
    float v3 = __p;
  }
  else {
    float v3 = (void **)__p[0];
  }
  if (v9 >= 0) {
    std::string::size_type v4 = HIBYTE(v9);
  }
  else {
    std::string::size_type v4 = (std::string::size_type)__p[1];
  }
  std::string::append(&__str, (const std::string::value_type *)v3, v4);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  std::string::operator=((std::string *)(a1 + 32), &__str);
  if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_str = &__str;
  }
  else {
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  BOOL v6 = sub_100292D28((const char *)p_str);
  if (!v6) {
    *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
  }
  return v6;
}

void sub_100254D50( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100254D88(uint64_t a1)
{
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_10182C9A0);
  }
  uint64_t v2 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "HRSE,clear AVL status cache", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_10182C9A0);
    }
    v5[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "HRSE,clear AVL status cache",  v5,  2);
    std::string::size_type v4 = (uint8_t *)v3;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLHrseTileAvailability::clearAvlCache()", "%s\n", v3);
    if (v4 != buf) {
      free(v4);
    }
  }

  *(_DWORD *)(a1 + 24) = 0;
  *(_WORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = 0;
}

BOOL sub_100254F20(uint64_t a1, double *a2, double *a3)
{
  *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
  double v4 = *a3;
  double v5 = *a2;
  uint64_t v6 = vcvtmd_s64_f64((*a2 + 90.0) * 20.0) + (int)(floor(*a3 * 20.0) * 100000.0);
  uint64_t v7 = a1;
  if (*(_BYTE *)(a1 + 28) && (uint64_t v7 = a1, (_DWORD)v6 == *(_DWORD *)(a1 + 24)))
  {
    int v8 = *(unsigned __int8 *)(a1 + 29);
    return v8 != 0;
  }

  else
  {
    while (1)
    {
      uint64_t v7 = *(void *)(v7 + 8);
      if (v7 == a1) {
        break;
      }
      if ((_DWORD)v6 == *(_DWORD *)(v7 + 16))
      {
        int v8 = *(unsigned __int8 *)(v7 + 20);
        return v8 != 0;
      }
    }

    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = 0;
    uint64_t v9 = sub_100255040(a1, v5, v4);
    BOOL v10 = operator new(0x18uLL);
    if ((_DWORD)v9) {
      _DWORD v10[2] = v6 | (unint64_t)&_mh_execute_header;
    }
    else {
      _DWORD v10[2] = v6;
    }
    uint64_t v11 = *(void *)a1;
    *BOOL v10 = *(void *)a1;
    v10[1] = a1;
    *(void *)(v11 + std::istream::~istream(v2, v3 + 8) = v10;
    *(void *)a1 = v10;
    ++*(void *)(a1 + 16);
    if (!*(_BYTE *)(a1 + 80))
    {
      *(_BYTE *)(a1 + 2std::istream::~istream(v2, v3 + 8) = 1;
      *(_DWORD *)(a1 + 24) = v6;
      *(_BYTE *)(a1 + 29) = v9;
    }
  }

  return v9;
}

uint64_t sub_100255040(uint64_t a1, double a2, double a3)
{
  if ((sub_10025609C(a1) & 1) == 0)
  {
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    unint64_t v17 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
    {
      int v18 = *(unsigned __int8 *)(a1 + 80);
      int buf = 67240192;
      *(_DWORD *)double v84 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_INFO,  "#Warning,HRSE,isTileAvailableBasedOnAvlFile,availability file is not valid,fNeedToDownloadAvlFile,%{public}d",  (uint8_t *)&buf,  8u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 0LL;
    }
    bzero(&buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v19 = *(unsigned __int8 *)(a1 + 80);
    LODWORD(v71[0]) = 67240192;
    DWORD1(v71[0]) = v19;
    LODWORD(v63) = 8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  1LL,  "#Warning,HRSE,isTileAvailableBasedOnAvlFile,availability file is not valid,fNeedToDownloadAvlFile,%{public}d",  v71,  v63);
    char v21 = (int *)v20;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::isTileAvailableBasedOnAvlFile(double, double)",  "%s\n",  v20);
    if (v21 == &buf) {
      return 0LL;
    }
LABEL_117:
    free(v21);
    return 0LL;
  }

  uint64_t v81 = 0LL;
  uint64_t v80 = 0LL;
  uint64_t v82 = 0LL;
  __int128 v72 = 0u;
  __int128 v73 = 0u;
  __int128 v74 = 0u;
  __int128 v75 = 0u;
  __int128 v76 = 0u;
  __int128 v77 = 0u;
  __int128 v78 = 0u;
  memset(v79, 0, sizeof(v79));
  uint64_t v65 = 0LL;
  if (qword_101934880 != -1) {
    dispatch_once(&qword_101934880, &stru_10182C9C0);
  }
  uint64_t v6 = (os_log_s *)qword_101934888;
  if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v7 = (void *)(a1 + 32);
    int buf = 136446210;
    *(void *)double v84 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "HRSE,isTileAvailableBasedOnAvlFile,Reading,%{public}s",  (uint8_t *)&buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    double v54 = (void *)(a1 + 32);
    int v66 = 136446210;
    *(void *)__int16 v67 = v54;
    LODWORD(v63) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  2LL,  "HRSE,isTileAvailableBasedOnAvlFile,Reading,%{public}s",  &v66,  v63);
    double v56 = (int *)v55;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::isTileAvailableBasedOnAvlFile(double, double)",  "%s\n",  v55);
    if (v56 != &buf) {
      free(v56);
    }
  }

  int v8 = (const char **)(a1 + 32);
  uint64_t v9 = (const char *)(a1 + 32);
  BOOL v10 = fopen(v9, "rb");
  uint64_t v11 = v10;
  if (!v10)
  {
    *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    unsigned int v22 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
    {
      uint64_t v23 = (const char *)(a1 + 32);
      int v24 = *(unsigned __int8 *)(a1 + 80);
      int v25 = *__error();
      int buf = 136446722;
      *(void *)double v84 = v23;
      *(_WORD *)&v84[8] = 1026;
      int v85 = v24;
      __int16 v86 = 1026;
      int v87 = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,isTileAvailableBasedOnAvlFile,could not open,%{public}s,fNeedToDownloadAvlFile,%{public}d,errno,%{public}d",  (uint8_t *)&buf,  0x18u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(&buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    uint64_t v57 = qword_101934888;
    int v58 = *(unsigned __int8 *)(a1 + 80);
    int v59 = *__error();
    int v66 = 136446722;
    *(void *)__int16 v67 = v8;
    *(_WORD *)&v67[8] = 1026;
    int v68 = v58;
    __int16 v69 = 1026;
    int v70 = v59;
    LODWORD(v63) = 24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v57,  16LL,  "#Error,HRSE,isTileAvailableBasedOnAvlFile,could not open,%{public}s,fNeedToDownloadAvlFile,%{public}d,errno,%{public}d",  &v66,  v63);
    char v21 = (int *)v60;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLHrseTileAvailability::isTileAvailableBasedOnAvlFile(double, double)",  "%s\n",  v60);
    if (v21 == &buf) {
      return 0LL;
    }
    goto LABEL_117;
  }

  uint64_t v64 = 0LL;
  if ((sub_100256D40(v10, v71, (uint64_t)&v72, (int *)&v65, &v64) & 1) == 0)
  {
    *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    char v27 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
    {
      int v28 = *(unsigned __int8 *)(a1 + 80);
      int buf = 67240192;
      *(_DWORD *)double v84 = v28;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_INFO,  "#Warning,HRSE,isTileAvailableBasedOnAvlFile,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d",  (uint8_t *)&buf,  8u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_44;
    }
    bzero(&buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v61 = *(unsigned __int8 *)(a1 + 80);
    int v66 = 67240192;
    *(_DWORD *)__int16 v67 = v61;
    LODWORD(v63) = 8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  1LL,  "#Warning,HRSE,isTileAvailableBasedOnAvlFile,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d",  &v66,  v63);
    double v16 = (int *)v62;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::isTileAvailableBasedOnAvlFile(double, double)",  "%s\n",  v62);
    goto LABEL_121;
  }

  int v12 = v79[24];
  double v13 = (double)v79[24];
  if (v13 <= a2)
  {
    int v30 = v79[25];
    if ((double)v79[25] <= a2)
    {
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      double v34 = (os_log_s *)qword_101934888;
      if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
      {
        int buf = 134283777;
        *(double *)double v84 = a2;
        *(_WORD *)&v84[8] = 1025;
        int v85 = v30;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_INFO,  "HRSE,isTileAvailableBasedOnAvlFile,input latitude, %{private}.3lf, beyond maximum acceptable latitude, %{private}d",  (uint8_t *)&buf,  0x12u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_44;
      }
      bzero(&buf, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      int v66 = 134283777;
      *(double *)__int16 v67 = a2;
      *(_WORD *)&v67[8] = 1025;
      int v68 = v30;
      LODWORD(v63) = 18;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  1LL,  "HRSE,isTileAvailableBasedOnAvlFile,input latitude, %{private}.3lf, beyond maximum acceptable latitude, %{private}d",  &v66,  v63);
      double v16 = (int *)v35;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::isTileAvailableBasedOnAvlFile(double, double)",  "%s\n",  v35);
      goto LABEL_121;
    }

    sub_100292890(a3);
    signed int v32 = vcvtmd_s64_f64(v31 * 20.0) + 7200 * (vcvtmd_s64_f64((a2 + 90.0) * 20.0) - (int)((v13 + 90.0) * 20.0));
    if (v32 >= 0) {
      int v33 = v32;
    }
    else {
      int v33 = v32 + 7;
    }
    HIBYTE(v63) = 0;
    if (v33 >> 3 >= v82)
    {
      *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      double v36 = (os_log_s *)qword_101934888;
      if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
      {
        int v37 = *(unsigned __int8 *)(a1 + 80);
        int buf = 67240448;
        *(_DWORD *)double v84 = v33 >> 3;
        *(_WORD *)&v84[4] = 1026;
        *(_DWORD *)&v84[6] = v37;
        _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_INFO,  "#Warning,HRSE,isTileAvailableBasedOnAvlFile,avl byte index,%{public}d,is larger than the data available in the availabilty file,fNeedToDownloadAvlFile,%{public}d",  (uint8_t *)&buf,  0xEu);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_44;
      }
      bzero(&buf, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      int v38 = *(unsigned __int8 *)(a1 + 80);
      int v66 = 67240448;
      *(_DWORD *)__int16 v67 = v33 >> 3;
      *(_WORD *)&v67[4] = 1026;
      *(_DWORD *)&v67[6] = v38;
      LODWORD(v63) = 14;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  1LL,  "#Warning,HRSE,isTileAvailableBasedOnAvlFile,avl byte index,%{public}d,is larger than the data available in the a vailabilty file,fNeedToDownloadAvlFile,%{public}d",  &v66,  v63);
      double v16 = (int *)v39;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::isTileAvailableBasedOnAvlFile(double, double)",  "%s\n",  v39);
      goto LABEL_121;
    }

    fseek(v11, v33 >> 3, 1);
    if (fread((char *)&v63 + 7, 1uLL, 1uLL, v11) == 1)
    {
      fclose(v11);
      switch(v32 - (v33 & 0xFFFFFFF8))
      {
        case 0u:
          uint64_t v26 = v63 < 0;
          break;
        case 1u:
          uint64_t v26 = (HIBYTE(v63) >> 6) & 1;
          break;
        case 2u:
          uint64_t v26 = (HIBYTE(v63) >> 5) & 1;
          break;
        case 3u:
          uint64_t v26 = (HIBYTE(v63) >> 4) & 1;
          break;
        case 4u:
          uint64_t v26 = (HIBYTE(v63) >> 3) & 1;
          break;
        case 5u:
          uint64_t v26 = (HIBYTE(v63) >> 2) & 1;
          break;
        case 6u:
          uint64_t v26 = (HIBYTE(v63) >> 1) & 1;
          break;
        case 7u:
          uint64_t v26 = HIBYTE(v63) & 1;
          break;
        default:
          *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
          if (qword_101934880 != -1) {
            dispatch_once(&qword_101934880, &stru_10182C9C0);
          }
          __int16 v49 = (os_log_s *)qword_101934888;
          if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_FAULT))
          {
            int v50 = *(unsigned __int8 *)(a1 + 80);
            int buf = 67240192;
            *(_DWORD *)double v84 = v50;
            _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_FAULT,  "HRSE,isTileAvailableBasedOnAvlFile,unexpected case,fNeedToDownloadAvlFile,%{public}d",  (uint8_t *)&buf,  8u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(&buf, 0x65CuLL);
            if (qword_101934880 != -1) {
              dispatch_once(&qword_101934880, &stru_10182C9C0);
            }
            int v51 = *(unsigned __int8 *)(a1 + 80);
            int v66 = 67240192;
            *(_DWORD *)__int16 v67 = v51;
            LODWORD(v63) = 8;
            _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  17LL,  "HRSE,isTileAvailableBasedOnAvlFile,unexpected case,fNeedToDownloadAvlFile,%{public}d",  &v66,  v63);
            __int16 v53 = (int *)v52;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLHrseTileAvailability::isTileAvailableBasedOnAvlFile(double, double)",  "%s\n",  v52);
            if (v53 != &buf) {
              free(v53);
            }
          }

          goto LABEL_45;
      }

      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      double v44 = (os_log_s *)qword_101934888;
      if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_DEBUG))
      {
        int v45 = *(unsigned __int8 *)(a1 + 80);
        int buf = 67240448;
        *(_DWORD *)double v84 = v26;
        *(_WORD *)&v84[4] = 1026;
        *(_DWORD *)&v84[6] = v45;
        _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEBUG,  "HRSE,isTileAvailableBasedOnAvlFile,isTileAvailable,%{public}d,fNeedToDownloadAvlFile,%{public}d",  (uint8_t *)&buf,  0xEu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_101934880 != -1) {
          dispatch_once(&qword_101934880, &stru_10182C9C0);
        }
        int v46 = *(unsigned __int8 *)(a1 + 80);
        int v66 = 67240448;
        *(_DWORD *)__int16 v67 = v26;
        *(_WORD *)&v67[4] = 1026;
        *(_DWORD *)&v67[6] = v46;
        LODWORD(v63) = 14;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  2LL,  "HRSE,isTileAvailableBasedOnAvlFile,isTileAvailable,%{public}d,fNeedToDownloadAvlFile,%{public}d",  &v66,  v63);
        uint64_t v48 = (int *)v47;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::isTileAvailableBasedOnAvlFile(double, double)",  "%s\n",  v47);
        if (v48 != &buf) {
          free(v48);
        }
      }

      goto LABEL_46;
    }

    *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    double v40 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
    {
      int v41 = *(unsigned __int8 *)(a1 + 80);
      int buf = 67240192;
      *(_DWORD *)double v84 = v41;
      _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_INFO,  "#Warning,HRSE,isTileAvailableBasedOnAvlFile,unable to get data byte,fNeedToDownloadAvlFile,%{public}d",  (uint8_t *)&buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      int v42 = *(unsigned __int8 *)(a1 + 80);
      int v66 = 67240192;
      *(_DWORD *)__int16 v67 = v42;
      LODWORD(v63) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  1LL,  "#Warning,HRSE,isTileAvailableBasedOnAvlFile,unable to get data byte,fNeedToDownloadAvlFile,%{public}d",  &v66,  v63);
      double v16 = (int *)v43;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::isTileAvailableBasedOnAvlFile(double, double)",  "%s\n",  v43);
      goto LABEL_121;
    }
  }

  else
  {
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    unint64_t v14 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
    {
      int buf = 134283777;
      *(double *)double v84 = a2;
      *(_WORD *)&v84[8] = 1025;
      int v85 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "HRSE,isTileAvailableBasedOnAvlFile,input latitude, %{private}.3lf, below minimum acceptable latitude, %{private}d",  (uint8_t *)&buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      int v66 = 134283777;
      *(double *)__int16 v67 = a2;
      *(_WORD *)&v67[8] = 1025;
      int v68 = v12;
      LODWORD(v63) = 18;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  1LL,  "HRSE,isTileAvailableBasedOnAvlFile,input latitude, %{private}.3lf, below minimum acceptable latitude, %{private}d",  &v66,  v63);
      double v16 = (int *)v15;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::isTileAvailableBasedOnAvlFile(double, double)",  "%s\n",  v15);
LABEL_121:
      if (v16 != &buf) {
        free(v16);
      }
    }
  }

void sub_100256020( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (a54 < 0) {
    operator delete(*v54);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10025609C(uint64_t a1)
{
  __int128 v77 = 0uLL;
  uint64_t v78 = 0LL;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v71 = 0u;
  __int128 v72 = 0u;
  __int128 v73 = 0u;
  __int128 v74 = 0u;
  __int128 v75 = 0u;
  memset(v76, 0, sizeof(v76));
  uint64_t v54 = 0LL;
  if (qword_101934880 != -1) {
    dispatch_once(&qword_101934880, &stru_10182C9C0);
  }
  uint64_t v2 = (os_log_s *)qword_101934888;
  if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_DEBUG))
  {
    int v3 = *(unsigned __int8 *)(a1 + 80);
    *(_DWORD *)int buf = 67240192;
    LODWORD(v63) = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "HRSE,checkAvlFileValidityAndSetDownloadFlag,fNeedToDownloadAvlFile,%{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v35 = *(unsigned __int8 *)(a1 + 80);
    *(_DWORD *)uint64_t v57 = 67240192;
    *(_DWORD *)&v57[4] = v35;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934888,  2LL,  "HRSE,checkAvlFileValidityAndSetDownloadFlag,fNeedToDownloadAvlFile,%{public}d",  v57,  8);
    int v37 = (uint8_t *)v36;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::checkAvlFileValidityAndSetDownloadFlag()",  "%s\n",  v36);
    if (v37 != buf) {
      free(v37);
    }
  }

  if (!sub_100254C74(a1))
  {
    *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v18 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
    {
      int v19 = *(unsigned __int8 *)(a1 + 80);
      *(_DWORD *)int buf = 67240192;
      LODWORD(v63) = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file does not exist,fNeedToDownloadAvlFile,%{public}d",  buf,  8u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v20 = *(unsigned __int8 *)(a1 + 80);
    *(_DWORD *)uint64_t v57 = 67240192;
    *(_DWORD *)&v57[4] = v20;
    LODWORD(v53) = 8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934888,  1LL,  "#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file does not exist,fNeedToDownloadAvlFile,%{public}d",  v57,  v53);
    unsigned int v22 = (uint8_t *)v21;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::checkAvlFileValidityAndSetDownloadFlag()",  "%s\n",  v21);
    if (v22 == buf) {
      return 0LL;
    }
LABEL_81:
    free(v22);
    return 0LL;
  }

  if (qword_101934880 != -1) {
    dispatch_once(&qword_101934880, &stru_10182C9C0);
  }
  double v4 = (os_log_s *)qword_101934888;
  if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_DEBUG))
  {
    double v5 = (const char *)(a1 + 32);
    *(_DWORD *)int buf = 136446210;
    uint64_t v63 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "HRSE,checkAvlFileValidityAndSetDownloadFlag,Reading,%{public}s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v38 = (void *)(a1 + 32);
    *(_DWORD *)uint64_t v57 = 136446210;
    *(void *)&v57[4] = v38;
    LODWORD(v53) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934888,  2LL,  "HRSE,checkAvlFileValidityAndSetDownloadFlag,Reading,%{public}s",  v57,  v53);
    double v40 = (uint8_t *)v39;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::checkAvlFileValidityAndSetDownloadFlag()",  "%s\n",  v39);
    if (v40 != buf) {
      free(v40);
    }
  }

  uint64_t v6 = (const char **)(a1 + 32);
  uint64_t v7 = (const char *)(a1 + 32);
  int v8 = fopen(v7, "rb");
  uint64_t v9 = v8;
  if (!v8)
  {
    *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    uint64_t v23 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
    {
      int v24 = (const char *)(a1 + 32);
      int v25 = *(unsigned __int8 *)(a1 + 80);
      int v26 = *__error();
      *(_DWORD *)int buf = 136446722;
      uint64_t v63 = v24;
      __int16 v64 = 1026;
      int v65 = v25;
      __int16 v66 = 1026;
      int v67 = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,checkAvlFileValidityAndSetDownloadFlag,could not open,%{public}s,fNeedToDownloadAvlFile,%{public}d,errno,%{public}d",  buf,  0x18u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    uint64_t v41 = qword_101934888;
    int v42 = *(unsigned __int8 *)(a1 + 80);
    int v43 = *__error();
    *(_DWORD *)uint64_t v57 = 136446722;
    *(void *)&v57[4] = v6;
    __int16 v58 = 1026;
    int v59 = v42;
    __int16 v60 = 1026;
    int v61 = v43;
    LODWORD(v53) = 24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v41,  16LL,  "#Error,HRSE,checkAvlFileValidityAndSetDownloadFlag,could not open,%{public}s,fNeedToDownloadAvlFile,%{public}d,errno,%{public}d",  v57,  v53);
    unsigned int v22 = (uint8_t *)v44;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLHrseTileAvailability::checkAvlFileValidityAndSetDownloadFlag()",  "%s\n",  v44);
    if (v22 == buf) {
      return 0LL;
    }
    goto LABEL_81;
  }

  *(void *)uint64_t v57 = 0LL;
  if ((sub_100256D40(v8, v68, (uint64_t)&v69, (int *)&v54, v57) & 1) == 0)
  {
    *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v28 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
    {
      int v29 = *(unsigned __int8 *)(a1 + 80);
      *(_DWORD *)int buf = 67240192;
      LODWORD(v63) = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_INFO,  "#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      int v45 = *(unsigned __int8 *)(a1 + 80);
      int v55 = 67240192;
      int v56 = v45;
      LODWORD(v53) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934888,  1LL,  "#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,readAvlHelper failed,fNeedToDownloadAvlFile,%{public}d",  &v55,  v53);
      __int16 v47 = (uint8_t *)v46;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::checkAvlFileValidityAndSetDownloadFlag()",  "%s\n",  v46);
      if (v47 != buf) {
        free(v47);
      }
    }

    fclose(v9);
    goto LABEL_56;
  }

  fclose(v9);
  if (v76[22] != 1)
  {
    *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v30 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
    {
      int v31 = *(unsigned __int8 *)(a1 + 80);
      *(_DWORD *)int buf = 67240192;
      LODWORD(v63) = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_INFO,  "#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file version does not match expected,fNeedToDo wnloadAvlFile,%{public}d",  buf,  8u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_56;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v48 = *(unsigned __int8 *)(a1 + 80);
    int v55 = 67240192;
    int v56 = v48;
    LODWORD(v53) = 8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934888,  1LL,  "#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file version does not match expected,fNeedToDown loadAvlFile,%{public}d",  &v55,  v53);
    unint64_t v17 = (uint8_t *)v49;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::checkAvlFileValidityAndSetDownloadFlag()",  "%s\n",  v49);
    goto LABEL_89;
  }

  double Current = CFAbsoluteTimeGetCurrent();
  double v11 = *(double *)((char *)&v77 + 4);
  unsigned int v12 = HIDWORD(v77);
  if (Current <= v11 + (double)v12 + (double)(random() % 86400))
  {
    *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v33 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_DEBUG))
    {
      int v34 = *(unsigned __int8 *)(a1 + 80);
      *(_DWORD *)int buf = 67240192;
      LODWORD(v63) = v34;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEBUG,  "HRSE,checkAvlFileValidityAndSetDownloadFlag,reached end of function,fNeedToDownloadAvlFile,%{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      int v50 = *(unsigned __int8 *)(a1 + 80);
      int v55 = 67240192;
      int v56 = v50;
      LODWORD(v53) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934888,  2LL,  "HRSE,checkAvlFileValidityAndSetDownloadFlag,reached end of function,fNeedToDownloadAvlFile,%{public}d",  &v55,  v53);
      unsigned int v52 = (uint8_t *)v51;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::checkAvlFileValidityAndSetDownloadFlag()",  "%s\n",  v51);
      if (v52 != buf) {
        free(v52);
      }
    }

    uint64_t v27 = 1LL;
    goto LABEL_57;
  }

  *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
  if (qword_101934880 != -1) {
    dispatch_once(&qword_101934880, &stru_10182C9C0);
  }
  double v13 = (os_log_s *)qword_101934888;
  if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
  {
    int v14 = *(unsigned __int8 *)(a1 + 80);
    *(_DWORD *)int buf = 67240192;
    LODWORD(v63) = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file has expired,fNeedToDownloadAvlFile,%{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v15 = *(unsigned __int8 *)(a1 + 80);
    int v55 = 67240192;
    int v56 = v15;
    LODWORD(v53) = 8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934888,  1LL,  "#Warning,HRSE,checkAvlFileValidityAndSetDownloadFlag,availability file has expired,fNeedToDownloadAvlFile,%{public}d",  &v55,  v53);
    unint64_t v17 = (uint8_t *)v16;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLHrseTileAvailability::checkAvlFileValidityAndSetDownloadFlag()",  "%s\n",  v16);
LABEL_89:
    if (v17 != buf) {
      free(v17);
    }
  }

void sub_100256CF4(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100256D40(FILE *a1, _OWORD *a2, uint64_t a3, int *a4, void *a5)
{
  if (a1)
  {
    if (a2)
    {
      if (!feof(a1))
      {
        unsigned int v19 = 0;
        int v20 = (void *)(a3 + 24);
        while (1)
        {
          HIBYTE(v92) = 0;
          uint64_t v21 = ftell(a1);
          if (HIBYTE(v92) == 67)
          {
            uint64_t v22 = v21;
            LOBYTE(v107) = 67;
            *(_BYTE *)(a3 + 32) = v108;
            *int v20 = v107;
            if (*(void *)(a3 + 24) == 0x5641455352484C43LL && *(_BYTE *)(a3 + 32) == 76)
            {
              unint64_t v24 = 0LL;
              *(void *)a4 = 9LL;
              do
              {
                *((_BYTE *)a2 + v24) = *((_BYTE *)v20 + v24);
                ++v24;
                uint64_t v25 = *(void *)a4;
              }

              while (*(void *)a4 > v24);
              size_t v26 = (110 - v25);
              if (fread((char *)a2 + v25, 1uLL, v26, a1) == v26)
              {
                __int128 v27 = *a2;
                __int128 v28 = a2[2];
                *(_OWORD *)(a3 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = a2[1];
                *(_OWORD *)(a3 + 56) = v28;
                *(_OWORD *)int v20 = v27;
                __int128 v29 = a2[3];
                __int128 v30 = a2[4];
                __int128 v31 = a2[5];
                *(_OWORD *)(a3 + 11std::istream::~istream(v2, v3 + 8) = *(_OWORD *)((char *)a2 + 94);
                *(_OWORD *)(a3 + 8std::istream::~istream(v2, v3 + 8) = v30;
                *(_OWORD *)(a3 + 104) = v31;
                *(_OWORD *)(a3 + 72) = v29;
                size_t v32 = *(void *)a4 + v26;
                *(void *)a4 = v32;
                if (*(void *)(a3 + 24) == 0x5641455352484C43LL && *(_BYTE *)(a3 + 32) == 76)
                {
                  if (fread((char *)a2 + v32, 1uLL, 1uLL, a1) == 1)
                  {
                    uint64_t v33 = *(void *)a4;
                    *(_BYTE *)(a3 + 134) = *((_BYTE *)a2 + *(void *)a4);
                    *(void *)a4 = ++v33;
                    if (fread((char *)a2 + v33, 1uLL, 1uLL, a1) == 1)
                    {
                      uint64_t v34 = *(void *)a4;
                      *(_BYTE *)(a3 + 135) = *((_BYTE *)a2 + *(void *)a4);
                      *(void *)a4 = ++v34;
                      if (fread((char *)a2 + v34, 1uLL, 1uLL, a1) == 1)
                      {
                        uint64_t v35 = *(void *)a4;
                        *(_BYTE *)(a3 + 136) = *((_BYTE *)a2 + *(void *)a4);
                        *(void *)a4 = ++v35;
                        if (fread((char *)a2 + v35, 1uLL, 1uLL, a1) == 1)
                        {
                          uint64_t v36 = *(void *)a4;
                          *(_BYTE *)(a3 + 137) = *((_BYTE *)a2 + *(void *)a4);
                          *(void *)a4 = ++v36;
                          if (fread((char *)a2 + v36, 1uLL, 4uLL, a1) == 4)
                          {
                            uint64_t v37 = *(void *)a4;
                            float v38 = COERCE_FLOAT(bswap32(*(_DWORD *)((char *)a2 + *(void *)a4)));
                            *(float *)(a3 + 14sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v38;
                            uint64_t v39 = v37 + 4;
                            *(void *)a4 = v39;
                            if (fabsf(v38 + -0.05) <= 0.0001)
                            {
                              if (fread((char *)a2 + v39, 1uLL, 8uLL, a1) == 8)
                              {
                                uint64_t v59 = *(void *)a4;
                                *(void *)(a3 + 144) = bswap64(*(void *)((char *)a2 + *(void *)a4));
                                v59 += 8LL;
                                *(void *)a4 = v59;
                                if (fread((char *)a2 + v59, 1uLL, 4uLL, a1) == 4)
                                {
                                  uint64_t v60 = *(void *)a4;
                                  *(_DWORD *)(a3 + 152) = bswap32(*(_DWORD *)((char *)a2 + *(void *)a4));
                                  v60 += 4LL;
                                  *(void *)a4 = v60;
                                  if (fread((char *)a2 + v60, 1uLL, 4uLL, a1) == 4)
                                  {
                                    uint64_t v61 = *(void *)a4;
                                    *(_DWORD *)(a3 + 156) = bswap32(*(_DWORD *)((char *)a2 + *(void *)a4));
                                    v61 += 4LL;
                                    *(void *)a4 = v61;
                                    if (fread((char *)a2 + v61, 1uLL, 4uLL, a1) == 4)
                                    {
                                      *a5 = *a4;
                                      uint64_t v62 = *(void *)a4;
                                      *(_DWORD *)(a3 + 16sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = bswap32(*(_DWORD *)((char *)a2 + *(void *)a4));
                                      *(void *)a4 = v62 + 4;
                                      if (qword_101934880 != -1) {
                                        dispatch_once(&qword_101934880, &stru_10182C9C0);
                                      }
                                      uint64_t v63 = (os_log_s *)qword_101934888;
                                      if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_DEBUG))
                                      {
                                        int v64 = *(unsigned __int8 *)(a3 + 134);
                                        int v65 = *(unsigned __int8 *)(a3 + 135);
                                        int v66 = *(char *)(a3 + 136);
                                        int v67 = *(char *)(a3 + 137);
                                        double v68 = *(float *)(a3 + 140);
                                        uint64_t v69 = *(void *)(a3 + 144);
                                        int v70 = *(_DWORD *)(a3 + 152);
                                        int v71 = *(_DWORD *)(a3 + 156);
                                        int v72 = *(_DWORD *)(a3 + 160);
                                        int buf = 67176705;
                                        *(_DWORD *)__int16 v110 = v64;
                                        *(_WORD *)&v110[4] = 1025;
                                        *(_DWORD *)&v110[6] = v65;
                                        __int16 v111 = 1025;
                                        int v112 = v66;
                                        __int16 v113 = 1025;
                                        int v114 = v67;
                                        __int16 v115 = 2049;
                                        double v116 = v68;
                                        __int16 v117 = 2049;
                                        uint64_t v118 = v69;
                                        __int16 v119 = 1025;
                                        int v120 = v70;
                                        __int16 v121 = 1025;
                                        int v122 = v71;
                                        __int16 v123 = 1025;
                                        int v124 = v72;
                                        _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_DEBUG,  "HRSE,readAvlHelper,vers,%{private}d,headerLen,%{private}d,minLat,%{private}d,m axLat,%{private}d,binsize,%{private}.7f,timestamp,%{private}.1f,expirationAge, %{private}d,dataSizeBytes,%{private}d,crc,%{private}d",  (uint8_t *)&buf,  0x40u);
                                      }

                                      if (sub_1002921D0(115, 2))
                                      {
                                        bzero(&buf, 0x65CuLL);
                                        if (qword_101934880 != -1) {
                                          dispatch_once(&qword_101934880, &stru_10182C9C0);
                                        }
                                        int v81 = *(unsigned __int8 *)(a3 + 134);
                                        int v82 = *(unsigned __int8 *)(a3 + 135);
                                        int v83 = *(char *)(a3 + 136);
                                        int v84 = *(char *)(a3 + 137);
                                        double v85 = *(float *)(a3 + 140);
                                        uint64_t v86 = *(void *)(a3 + 144);
                                        int v87 = *(_DWORD *)(a3 + 152);
                                        int v88 = *(_DWORD *)(a3 + 156);
                                        int v89 = *(_DWORD *)(a3 + 160);
                                        LODWORD(v93) = 67176705;
                                        DWORD1(v93) = v81;
                                        WORD4(v93) = 1025;
                                        *(_DWORD *)((char *)&v93 + 1sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v82;
                                        HIWORD(v93) = 1025;
                                        int v94 = v83;
                                        __int16 v95 = 1025;
                                        int v96 = v84;
                                        __int16 v97 = 2049;
                                        double v98 = v85;
                                        __int16 v99 = 2049;
                                        uint64_t v100 = v86;
                                        __int16 v101 = 1025;
                                        int v102 = v87;
                                        __int16 v103 = 1025;
                                        int v104 = v88;
                                        __int16 v105 = 1025;
                                        int v106 = v89;
                                        LODWORD(v92) = 64;
                                        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  2LL,  "HRSE,readAvlHelper,vers,%{private}d,headerLen,%{private}d,minLat,%{private}d,m axLat,%{private}d,binsize,%{private}.7f,timestamp,%{private}.1f,expirationAge, %{private}d,dataSizeBytes,%{private}d,crc,%{private}d",  &v93,  v92);
                                        __int16 v91 = (int *)v90;
                                        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLHrseTileAvailability::readAvlHelper(FILE *, unsigned char *, CLH RSETileAvailability &, size_t &, size_t &)",  "%s\n",  v90);
                                        if (v91 != &buf) {
                                          free(v91);
                                        }
                                      }

                                      return 1LL;
                                    }

                                    if (qword_101934880 != -1) {
                                      dispatch_once(&qword_101934880, &stru_10182C9C0);
                                    }
                                    __int16 v79 = (os_log_s *)qword_101934888;
                                    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                                    {
                                      LOWORD(buf) = 0;
                                      _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file - crc",  (uint8_t *)&buf,  2u);
                                    }

                                    BOOL v80 = sub_1002921D0(115, 0);
                                    uint64_t result = 0LL;
                                    if (v80)
                                    {
                                      bzero(&buf, 0x65CuLL);
                                      if (qword_101934880 != -1) {
                                        dispatch_once(&qword_101934880, &stru_10182C9C0);
                                      }
                                      LOWORD(v93) = 0;
                                      LODWORD(v92) = 2;
                                      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file - crc",  &v93,  v92,  v93);
                                      goto LABEL_28;
                                    }
                                  }

                                  else
                                  {
                                    if (qword_101934880 != -1) {
                                      dispatch_once(&qword_101934880, &stru_10182C9C0);
                                    }
                                    __int128 v77 = (os_log_s *)qword_101934888;
                                    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                                    {
                                      LOWORD(buf) = 0;
                                      _os_log_impl( (void *)&_mh_execute_header,  v77,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file - data size",  (uint8_t *)&buf,  2u);
                                    }

                                    BOOL v78 = sub_1002921D0(115, 0);
                                    uint64_t result = 0LL;
                                    if (v78)
                                    {
                                      bzero(&buf, 0x65CuLL);
                                      if (qword_101934880 != -1) {
                                        dispatch_once(&qword_101934880, &stru_10182C9C0);
                                      }
                                      LOWORD(v93) = 0;
                                      LODWORD(v92) = 2;
                                      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file - data size",  &v93,  v92,  v93);
                                      goto LABEL_28;
                                    }
                                  }
                                }

                                else
                                {
                                  if (qword_101934880 != -1) {
                                    dispatch_once(&qword_101934880, &stru_10182C9C0);
                                  }
                                  __int128 v75 = (os_log_s *)qword_101934888;
                                  if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                                  {
                                    LOWORD(buf) = 0;
                                    _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file - expiration age",  (uint8_t *)&buf,  2u);
                                  }

                                  BOOL v76 = sub_1002921D0(115, 0);
                                  uint64_t result = 0LL;
                                  if (v76)
                                  {
                                    bzero(&buf, 0x65CuLL);
                                    if (qword_101934880 != -1) {
                                      dispatch_once(&qword_101934880, &stru_10182C9C0);
                                    }
                                    LOWORD(v93) = 0;
                                    LODWORD(v92) = 2;
                                    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file - expiration age",  &v93,  v92,  v93);
                                    goto LABEL_28;
                                  }
                                }
                              }

                              else
                              {
                                if (qword_101934880 != -1) {
                                  dispatch_once(&qword_101934880, &stru_10182C9C0);
                                }
                                __int128 v73 = (os_log_s *)qword_101934888;
                                if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                                {
                                  LOWORD(buf) = 0;
                                  _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file - timestamp",  (uint8_t *)&buf,  2u);
                                }

                                BOOL v74 = sub_1002921D0(115, 0);
                                uint64_t result = 0LL;
                                if (v74)
                                {
                                  bzero(&buf, 0x65CuLL);
                                  if (qword_101934880 != -1) {
                                    dispatch_once(&qword_101934880, &stru_10182C9C0);
                                  }
                                  LOWORD(v93) = 0;
                                  LODWORD(v92) = 2;
                                  _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file - timestamp",  &v93,  v92,  v93);
                                  goto LABEL_28;
                                }
                              }
                            }

                            else
                            {
                              if (qword_101934880 != -1) {
                                dispatch_once(&qword_101934880, &stru_10182C9C0);
                              }
                              double v40 = (os_log_s *)qword_101934888;
                              if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                              {
                                double v41 = *(float *)(a3 + 140);
                                int buf = 134349056;
                                *(double *)__int16 v110 = v41;
                                _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,coarse avl file is not 0.05 deg by 0.05 deg,spacing unexpect ed,%{public}.1f,re-download needed",  (uint8_t *)&buf,  0xCu);
                              }

                              BOOL v42 = sub_1002921D0(115, 0);
                              uint64_t result = 0LL;
                              if (v42)
                              {
                                bzero(&buf, 0x65CuLL);
                                if (qword_101934880 != -1) {
                                  dispatch_once(&qword_101934880, &stru_10182C9C0);
                                }
                                double v43 = *(float *)(a3 + 140);
                                LODWORD(v93) = 134349056;
                                *(double *)((char *)&v93 + 4) = v43;
                                LODWORD(v92) = 12;
                                _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,coarse avl file is not 0.05 deg by 0.05 deg,spacing unexpect ed,%{public}.1f,re-download needed",  &v93,  v92,  v93);
                                goto LABEL_28;
                              }
                            }
                          }

                          else
                          {
                            if (qword_101934880 != -1) {
                              dispatch_once(&qword_101934880, &stru_10182C9C0);
                            }
                            uint64_t v57 = (os_log_s *)qword_101934888;
                            if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                            {
                              LOWORD(buf) = 0;
                              _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file - binsize",  (uint8_t *)&buf,  2u);
                            }

                            BOOL v58 = sub_1002921D0(115, 0);
                            uint64_t result = 0LL;
                            if (v58)
                            {
                              bzero(&buf, 0x65CuLL);
                              if (qword_101934880 != -1) {
                                dispatch_once(&qword_101934880, &stru_10182C9C0);
                              }
                              LOWORD(v93) = 0;
                              LODWORD(v92) = 2;
                              _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file - binsize",  &v93,  v92,  v93);
                              goto LABEL_28;
                            }
                          }
                        }

                        else
                        {
                          if (qword_101934880 != -1) {
                            dispatch_once(&qword_101934880, &stru_10182C9C0);
                          }
                          int v55 = (os_log_s *)qword_101934888;
                          if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                          {
                            LOWORD(buf) = 0;
                            _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file - maxLat",  (uint8_t *)&buf,  2u);
                          }

                          BOOL v56 = sub_1002921D0(115, 0);
                          uint64_t result = 0LL;
                          if (v56)
                          {
                            bzero(&buf, 0x65CuLL);
                            if (qword_101934880 != -1) {
                              dispatch_once(&qword_101934880, &stru_10182C9C0);
                            }
                            LOWORD(v93) = 0;
                            LODWORD(v92) = 2;
                            _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file - maxLat",  &v93,  v92,  v93);
                            goto LABEL_28;
                          }
                        }
                      }

                      else
                      {
                        if (qword_101934880 != -1) {
                          dispatch_once(&qword_101934880, &stru_10182C9C0);
                        }
                        uint64_t v53 = (os_log_s *)qword_101934888;
                        if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                        {
                          LOWORD(buf) = 0;
                          _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file - minLat",  (uint8_t *)&buf,  2u);
                        }

                        BOOL v54 = sub_1002921D0(115, 0);
                        uint64_t result = 0LL;
                        if (v54)
                        {
                          bzero(&buf, 0x65CuLL);
                          if (qword_101934880 != -1) {
                            dispatch_once(&qword_101934880, &stru_10182C9C0);
                          }
                          LOWORD(v93) = 0;
                          LODWORD(v92) = 2;
                          _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file - minLat",  &v93,  v92,  v93);
                          goto LABEL_28;
                        }
                      }
                    }

                    else
                    {
                      if (qword_101934880 != -1) {
                        dispatch_once(&qword_101934880, &stru_10182C9C0);
                      }
                      int v51 = (os_log_s *)qword_101934888;
                      if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                      {
                        LOWORD(buf) = 0;
                        _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file - headerLength",  (uint8_t *)&buf,  2u);
                      }

                      BOOL v52 = sub_1002921D0(115, 0);
                      uint64_t result = 0LL;
                      if (v52)
                      {
                        bzero(&buf, 0x65CuLL);
                        if (qword_101934880 != -1) {
                          dispatch_once(&qword_101934880, &stru_10182C9C0);
                        }
                        LOWORD(v93) = 0;
                        LODWORD(v92) = 2;
                        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file - headerLength",  &v93,  v92,  v93);
                        goto LABEL_28;
                      }
                    }
                  }

                  else
                  {
                    if (qword_101934880 != -1) {
                      dispatch_once(&qword_101934880, &stru_10182C9C0);
                    }
                    __int16 v49 = (os_log_s *)qword_101934888;
                    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                    {
                      LOWORD(buf) = 0;
                      _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file - version",  (uint8_t *)&buf,  2u);
                    }

                    BOOL v50 = sub_1002921D0(115, 0);
                    uint64_t result = 0LL;
                    if (v50)
                    {
                      bzero(&buf, 0x65CuLL);
                      if (qword_101934880 != -1) {
                        dispatch_once(&qword_101934880, &stru_10182C9C0);
                      }
                      LOWORD(v93) = 0;
                      LODWORD(v92) = 2;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file - version",  &v93,  v92,  v93);
                      goto LABEL_28;
                    }
                  }
                }

                else
                {
                  if (qword_101934880 != -1) {
                    dispatch_once(&qword_101934880, &stru_10182C9C0);
                  }
                  __int16 v47 = (os_log_s *)qword_101934888;
                  if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                  {
                    LOWORD(buf) = 0;
                    _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file - invalid header string",  (uint8_t *)&buf,  2u);
                  }

                  BOOL v48 = sub_1002921D0(115, 0);
                  uint64_t result = 0LL;
                  if (v48)
                  {
                    bzero(&buf, 0x65CuLL);
                    if (qword_101934880 != -1) {
                      dispatch_once(&qword_101934880, &stru_10182C9C0);
                    }
                    LOWORD(v93) = 0;
                    LODWORD(v92) = 2;
                    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file - invalid header string",  &v93,  v92,  v93);
                    goto LABEL_28;
                  }
                }
              }

              else
              {
                if (qword_101934880 != -1) {
                  dispatch_once(&qword_101934880, &stru_10182C9C0);
                }
                int v45 = (os_log_s *)qword_101934888;
                if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(buf) = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file - header string",  (uint8_t *)&buf,  2u);
                }

                BOOL v46 = sub_1002921D0(115, 0);
                uint64_t result = 0LL;
                if (v46)
                {
                  bzero(&buf, 0x65CuLL);
                  if (qword_101934880 != -1) {
                    dispatch_once(&qword_101934880, &stru_10182C9C0);
                  }
                  LOWORD(v93) = 0;
                  LODWORD(v92) = 2;
                  _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file - header string",  &v93,  v92,  v93);
                  goto LABEL_28;
                }
              }

              return result;
            }

            if (fseek(a1, v22, 0))
            {
              if (qword_101934880 != -1) {
                dispatch_once(&qword_101934880, &stru_10182C9C0);
              }
              double v44 = (os_log_s *)qword_101934888;
              if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf) = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,fseek returned non-zero",  (uint8_t *)&buf,  2u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(&buf, 0x65CuLL);
                if (qword_101934880 != -1) {
                  dispatch_once(&qword_101934880, &stru_10182C9C0);
                }
                LOWORD(v93) = 0;
                LODWORD(v92) = 2;
                _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,fseek returned non-zero",  &v93,  v92,  v93);
                goto LABEL_28;
              }

              return 0LL;
            }
          }

          if (!feof(a1) && v19++ < 0x1FF) {
            continue;
          }
          break;
        }
      }

      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      BOOL v10 = (os_log_s *)qword_101934888;
      if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,did not synchronize to tile header_string",  (uint8_t *)&buf,  2u);
      }

      BOOL v11 = sub_1002921D0(115, 0);
      uint64_t result = 0LL;
      if (v11)
      {
        bzero(&buf, 0x65CuLL);
        if (qword_101934880 != -1) {
          dispatch_once(&qword_101934880, &stru_10182C9C0);
        }
        LOWORD(v93) = 0;
        LODWORD(v92) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,did not synchronize to tile header_string",  &v93,  v92,  v93);
LABEL_28:
        int v18 = (int *)v13;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLHrseTileAvailability::readAvlHelper(FILE *, unsigned char *, CLHRSETileAvailability &, size_t &, size_t &)",  "%s\n",  v13);
        if (v18 != &buf) {
          free(v18);
        }
        return 0LL;
      }
    }

    else
    {
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      double v16 = (os_log_s *)qword_101934888;
      if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,null buffer",  (uint8_t *)&buf,  2u);
      }

      BOOL v17 = sub_1002921D0(115, 0);
      uint64_t result = 0LL;
      if (v17)
      {
        bzero(&buf, 0x65CuLL);
        if (qword_101934880 != -1) {
          dispatch_once(&qword_101934880, &stru_10182C9C0);
        }
        LOWORD(v107) = 0;
        LODWORD(v92) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,null buffer",  &v107,  v92,  v93);
        goto LABEL_28;
      }
    }
  }

  else
  {
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_10182C9C0);
    }
    int v14 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "#Error,HRSE,readAvlHelper,invalid availability file",  (uint8_t *)&buf,  2u);
    }

    BOOL v15 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v15)
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_10182C9C0);
      }
      LOWORD(v107) = 0;
      LODWORD(v92) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "#Error,HRSE,readAvlHelper,invalid availability file",  &v107,  v92,  v93);
      goto LABEL_28;
    }
  }

  return result;
}

uint64_t sub_1002581D4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 80);
}

void *sub_1002581DC(uint64_t a1)
{
  uint64_t result = sub_1001B4C40((void *)a1);
  *(_DWORD *)(a1 + 24) = 0;
  *(_WORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = 0;
  return result;
}

void sub_100258204(id a1)
{
  qword_101934838 = (uint64_t)os_log_create("com.apple.locationd.Position", "Position");
}

void sub_100258230(id a1)
{
  qword_101934888 = (uint64_t)os_log_create("com.apple.locationd.Position", "Gnss");
}

uint64_t sub_10025825C(uint64_t a1, __int128 *a2, uint64_t a3)
{
  *(void *)a1 = a3;
  sub_100C87434(a1 + 8, a2);
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 16sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 12std::istream::~istream(v2, v3 + 8) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  uint64_t v12 = 0LL;
  __asm { FMOV            V0.2D, #-1.0 }

  __int128 v10 = _Q0;
  __int128 v11 = _Q0;
  sub_10025B4D8(a1 + 208, 0xCuLL, &v11);
  *(_OWORD *)(a1 + 256) = v10;
  *(_OWORD *)(a1 + 272) = v10;
  *(void *)(a1 + 28std::istream::~istream(v2, v3 + 8) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 296) = 0;
  sub_100258338(a1);
  return a1;
}

void sub_1002582FC(_Unwind_Exception *a1)
{
  uint64_t v7 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v7;
    operator delete(v7);
  }

  _Unwind_Resume(a1);
}

double sub_100258338(uint64_t a1)
{
  int v2 = (int)-[NSTimeZone secondsFromGMT]( +[NSTimeZone localTimeZone](&OBJC_CLASS___NSTimeZone, "localTimeZone"),  "secondsFromGMT")
     % 3600;
  if (v2 != *(_DWORD *)(a1 + 296))
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C9E0);
    }
    double v4 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 296);
      *(_DWORD *)int buf = 67109376;
      int v12 = v5;
      __int16 v13 = 1024;
      int v14 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "StandPlus,time zone change,clearing everything,old,%d,new,%d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      int v6 = *(_DWORD *)(a1 + 296);
      v8[0] = 67109376;
      v8[1] = v6;
      __int16 v9 = 1024;
      int v10 = v2;
      uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "StandPlus,time zone change,clearing everything,old,%d,new,%d",  v8,  14);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLStandPlusMinuteEstimator::computeTimezoneOffset()", "%s\n", v7);
    }

    *(_DWORD *)(a1 + 296) = v2;
    *(void *)&double result = sub_100258550(a1).n128_u64[0];
  }

  return result;
}

__n128 sub_100258550(uint64_t a1)
{
  int v2 = *(void ***)(a1 + 120);
  uint64_t v3 = *(void *)(a1 + 128);
  *(void *)(a1 + 152) = 0LL;
  unint64_t v4 = v3 - (void)v2;
  if (v4 >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v5 = *(void *)(a1 + 128);
      int v2 = (void **)(*(void *)(a1 + 120) + 8LL);
      *(void *)(a1 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v2;
      unint64_t v4 = v5 - (void)v2;
    }

    while (v4 > 0x10);
  }

  if (v4 >> 3 == 1)
  {
    uint64_t v6 = 128LL;
  }

  else
  {
    if (v4 >> 3 != 2) {
      goto LABEL_8;
    }
    uint64_t v6 = 256LL;
  }

  *(void *)(a1 + 144) = v6;
LABEL_8:
  uint64_t v7 = *(void ***)(a1 + 168);
  uint64_t v8 = *(void *)(a1 + 176);
  *(void *)(a1 + 20sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  unint64_t v9 = v8 - (void)v7;
  if (v9 >= 0x11)
  {
    do
    {
      operator delete(*v7);
      uint64_t v10 = *(void *)(a1 + 176);
      uint64_t v7 = (void **)(*(void *)(a1 + 168) + 8LL);
      *(void *)(a1 + 16std::istream::~istream(v2, v3 + 8) = v7;
      unint64_t v9 = v10 - (void)v7;
    }

    while (v9 > 0x10);
  }

  if (v9 >> 3 == 1)
  {
    uint64_t v11 = 51LL;
    goto LABEL_14;
  }

  if (v9 >> 3 == 2)
  {
    uint64_t v11 = 102LL;
LABEL_14:
    *(void *)(a1 + 192) = v11;
  }

  unint64_t v20 = 0LL;
  uint64_t v22 = 0LL;
  __asm { FMOV            V0.2D, #-1.0 }

  __n128 v18 = (__n128)_Q0;
  memset(v19, 0, sizeof(v19));
  __int128 v21 = _Q0;
  sub_10025B4D8((uint64_t)v19, 0xCuLL, &v21);
  unint64_t v20 = 0xBFF0000000000000LL;
  sub_10025BCE8((void *)(a1 + 208), (uint64_t)v19);
  *(void *)(a1 + 256) = v20;
  sub_100210A00(v19);
  *(void *)(a1 + 264) = 0xBFF0000000000000LL;
  __n128 result = v18;
  *(__n128 *)(a1 + 272) = v18;
  *(void *)(a1 + 28std::istream::~istream(v2, v3 + 8) = 0xBFF0000000000000LL;
  return result;
}

void sub_10025868C(uint64_t a1, __int128 *a2)
{
  double v4 = *(double *)a2;
  *(void *)(a1 + 28sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)a2;
  if (*(double *)(a1 + 288) > *(double *)(a1 + 256))
  {
    sub_100258B54(a1);
    uint64_t v6 = *(void *)(a1 + 168);
    if (*(void *)(a1 + 176) == v6)
    {
      unint64_t v8 = 0LL;
    }

    else
    {
      unint64_t v7 = *(void *)(a1 + 200) + *(void *)(a1 + 192);
      unint64_t v8 = *(void *)(v6 + 8 * (v7 / 0x66)) + 40 * (v7 % 0x66);
    }

    if (v8 == v5 || v4 < *(double *)(v5 + 8))
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      unint64_t v9 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)int buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "StandPlus,ignoring calorimetry input", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10182C9E0);
        }
        v28.n128_u16[0] = 0;
        uint64_t v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "StandPlus,ignoring calorimetry input",  &v28,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStandPlusMinuteEstimator::feed(const CLStandMinuteInputData &)",  "%s\n",  v25);
      }

      sub_100258CA0((void *)a1);
      sub_1002590AC(a1);
      return;
    }

    *(void *)(a1 + 28std::istream::~istream(v2, v3 + 8) = 0xBFF0000000000000LL;
  }

  sub_100C87464((void **)(a1 + 8), a2);
  v28.n128_f64[0] = v10;
  v28.n128_u64[1] = v11;
  sub_100258CA0((void *)a1);
  sub_1002590AC(a1);
  if (*(void *)(a1 + 200) >= 8uLL)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C9E0);
    }
    __int16 v13 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "StandPlus,maxReached,sedentaryTimer",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      v27[0] = 0;
      size_t v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "StandPlus,maxReached,sedentaryTimer",  v27,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStandPlusMinuteEstimator::feed(const CLStandMinuteInputData &)",  "%s\n",  v26);
    }

    unint64_t v14 = *(void *)(a1 + 192);
    uint64_t v15 = *(void *)(a1 + 168);
    double v16 = (void *)(v15 + 8 * (v14 / 0x66));
    if (*(void *)(a1 + 176) == v15) {
      BOOL v17 = 0LL;
    }
    else {
      BOOL v17 = (char *)(*v16 + 40 * (v14 % 0x66));
    }
    uint64_t v18 = *(void *)(a1 + 200);
    *(void *)int buf = v15 + 8 * (v14 / 0x66);
    __int128 v30 = v17;
    sub_10025BF98(buf, v18);
    uint64_t v19 = (uint64_t)&v30[-**(void **)buf];
    unint64_t v20 = 0xCCCCCCCCCCCCCCCDLL * (v19 >> 3);
    if (v19 < 321)
    {
      unint64_t v24 = 109 - v20;
      uint64_t v22 = (void *)(*(void *)buf - 8 * (v24 / 0x66));
      uint64_t v23 = (char *)(*v22 + 40 * (102 * (v24 / 0x66) - v24) + 4040);
    }

    else
    {
      unint64_t v21 = v20 - 8;
      uint64_t v22 = (void *)(*(void *)buf + 8 * (v21 / 0x66));
      uint64_t v23 = (char *)(*v22 + 40 * (v21 % 0x66));
    }

    sub_10025955C((void *)(a1 + 160), v16, v17, v22, v23);
  }

void *sub_100258B54(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 192);
  unint64_t v2 = v1 + *(void *)(a1 + 200);
  uint64_t v3 = *(void *)(a1 + 168);
  uint64_t v4 = *(void *)(a1 + 176);
  uint64_t v5 = (void *)(v3 + 8 * (v2 / 0x66));
  double v6 = (double)*(int *)(a1 + 296);
  double v7 = floor(*(double *)(a1 + 280) + v6) - (double)((int)vcvtmd_s64_f64(*(double *)(a1 + 280) + v6) % 3600);
  unint64_t v8 = (void *)(v3 + 8 * (v1 / 0x66));
  if (v4 == v3) {
    unint64_t v9 = 0LL;
  }
  else {
    unint64_t v9 = *v8 + 40 * (v1 % 0x66);
  }
  double v10 = v7 - v6;
  unint64_t v11 = v2 % 0x66;
  double v12 = 1.79769313e308;
  __n128 result = v5;
LABEL_5:
  unint64_t v14 = v9;
  while (1)
  {
    uint64_t v15 = v4 == v3 ? 0LL : *v5 + 40 * v11;
    if (v14 == v15) {
      return result;
    }
    if (*(_DWORD *)(v14 + 16) == 2)
    {
      double v16 = *(double *)(v14 + 8);
      if (v16 > v10 && v16 < v12)
      {
        double v12 = *(double *)(v14 + 8);
        __n128 result = v8;
      }
    }

    v9 += 40LL;
    v14 += 40LL;
    if (*v8 + 4080LL == v9)
    {
      unint64_t v18 = v8[1];
      ++v8;
      unint64_t v9 = v18;
      goto LABEL_5;
    }
  }

void *sub_100258CA0(void *result)
{
  double v1 = floor(*((double *)result + 35) + (double)*((int *)result + 74))
  if (v1 > *((double *)result + 32))
  {
    unint64_t v2 = result;
    uint64_t v3 = result + 26;
    sub_1002590AC((uint64_t)result);
    unint64_t v51 = 0LL;
    memset(v50, 0, sizeof(v50));
    uint64_t v53 = 0LL;
    __asm { FMOV            V0.2D, #-1.0 }

    __int128 v52 = _Q0;
    sub_10025B4D8((uint64_t)v50, 0xCuLL, &v52);
    unint64_t v51 = 0xBFF0000000000000LL;
    sub_10025BCE8(v3, (uint64_t)v50);
    v2[32] = v51;
    sub_100210A00(v50);
    uint64_t v9 = v2[27];
    if (v2[28] != v9)
    {
      unint64_t v10 = v2[30];
      unint64_t v11 = (double **)(v9 + 8 * (v10 / 0xAA));
      double v12 = *v11;
      __int16 v13 = &(*v11)[3 * (v10 % 0xAA)];
      unint64_t v14 = *(void *)(v9 + 8 * ((v2[31] + v10) / 0xAA)) + 24 * ((v2[31] + v10) % 0xAA);
      if (v13 != (double *)v14)
      {
        int v15 = 0;
        do
        {
          double v16 = v1 + (double)v15;
          double *v13 = v16;
          v13[1] = v16 + 300.0;
          v13 += 3;
          if ((char *)v13 - (char *)v12 == 4080)
          {
            BOOL v17 = v11[1];
            ++v11;
            double v12 = v17;
            __int16 v13 = v17;
          }

          v15 += 300;
        }

        while (v13 != (double *)v14);
      }
    }

    *((double *)v2 + 32) = v1;
    sub_100648D60(v2 + 1);
    v2[36] = 0xBFF0000000000000LL;
    unint64_t v18 = v2[24];
    uint64_t v19 = v2[21];
    uint64_t v20 = v2[22];
    unint64_t v21 = (void *)(v19 + 8 * (v18 / 0x66));
    if (v20 == v19)
    {
      unint64_t v22 = 0LL;
      uint64_t v23 = v2 + 25;
    }

    else
    {
      unint64_t v22 = *(void *)(v19 + 8 * (v18 / 0x66)) + 40 * (v18 % 0x66);
      uint64_t v23 = v2 + 25;
      unint64_t v24 = *(void *)(v19 + 8 * ((v2[25] + v18) / 0x66)) + 40 * ((v2[25] + v18) % 0x66);
      if (v22 != v24)
      {
        while (*(double *)(v22 + 8) >= v1)
        {
          v22 += 40LL;
          if (v22 - *v21 == 4080)
          {
            unint64_t v25 = v21[1];
            ++v21;
            unint64_t v22 = v25;
          }

          if (v22 == v24) {
            goto LABEL_24;
          }
        }
      }

      if (v22 == v24)
      {
LABEL_24:
        unint64_t v22 = *(void *)(v19 + 8 * ((v2[25] + v18) / 0x66)) + 40 * ((v2[25] + v18) % 0x66);
      }

      else
      {
        unint64_t v26 = v22;
        __int128 v27 = v21;
        while (1)
        {
          v26 += 40LL;
          if (v26 - *v27 == 4080)
          {
            unint64_t v28 = v27[1];
            ++v27;
            unint64_t v26 = v28;
          }

          if (v26 == v24) {
            break;
          }
          if (*(double *)(v26 + 8) >= v1)
          {
            __int128 v29 = *(_OWORD *)v26;
            __int128 v30 = *(_OWORD *)(v26 + 16);
            *(_BYTE *)(v22 + 32) = *(_BYTE *)(v26 + 32);
            *(_OWORD *)unint64_t v22 = v29;
            *(_OWORD *)(v22 + 16) = v30;
            v22 += 40LL;
            if (v22 - *v21 == 4080)
            {
              unint64_t v31 = v21[1];
              ++v21;
              unint64_t v22 = v31;
            }
          }
        }

        unint64_t v18 = v2[24];
        uint64_t v19 = v2[21];
        uint64_t v20 = v2[22];
      }
    }

    unint64_t v32 = v18 + *v23;
    uint64_t v33 = (void *)(v19 + 8 * (v32 / 0x66));
    if (v20 == v19) {
      uint64_t v34 = 0LL;
    }
    else {
      uint64_t v34 = (char *)(*v33 + 40 * (v32 % 0x66));
    }
    sub_10025955C(v2 + 20, v21, (char *)v22, v33, v34);
    unint64_t v35 = v2[18];
    uint64_t v36 = v2[15];
    uint64_t v37 = v2[16];
    float v38 = (void *)(v36 + 8 * (v35 >> 8));
    if (v37 == v36)
    {
      uint64_t v39 = 0LL;
      double v40 = v2 + 19;
    }

    else
    {
      uint64_t v39 = *v38 + 16LL * v35;
      double v40 = v2 + 19;
      uint64_t v41 = *(void *)(v36 + (((v2[19] + v35) >> 5) & 0x7FFFFFFFFFFFFF8LL))
          + 16LL * (*((_BYTE *)v2 + 152) + v35);
      if (v39 != v41)
      {
        while (*(double *)(v39 + 8) >= v1)
        {
          v39 += 16LL;
          if (v39 - *v38 == 4096)
          {
            uint64_t v42 = v38[1];
            ++v38;
            uint64_t v39 = v42;
          }

          if (v39 == v41) {
            goto LABEL_45;
          }
        }
      }

      if (v39 == v41)
      {
LABEL_45:
        uint64_t v39 = *(void *)(v36 + (((v2[19] + v35) >> 5) & 0x7FFFFFFFFFFFFF8LL))
            + 16LL * (*((_BYTE *)v2 + 152) + v35);
      }

      else
      {
        uint64_t v43 = v39;
        double v44 = v38;
        while (1)
        {
          v43 += 16LL;
          if (v43 - *v44 == 4096)
          {
            uint64_t v45 = v44[1];
            ++v44;
            uint64_t v43 = v45;
          }

          if (v43 == v41) {
            break;
          }
          if (*(double *)(v43 + 8) >= v1)
          {
            *(_OWORD *)uint64_t v39 = *(_OWORD *)v43;
            v39 += 16LL;
            if (v39 - *v38 == 4096)
            {
              uint64_t v46 = v38[1];
              ++v38;
              uint64_t v39 = v46;
            }
          }
        }

        unint64_t v35 = v2[18];
        uint64_t v36 = v2[15];
        uint64_t v37 = v2[16];
      }
    }

    unint64_t v47 = v35 + *v40;
    BOOL v48 = (char *)(v36 + 8 * (v47 >> 8));
    if (v37 == v36) {
      uint64_t v49 = 0LL;
    }
    else {
      uint64_t v49 = *(void *)v48 + 16LL * v47;
    }
    return sub_10025A918(v2 + 14, (char *)v38, v39, v48, v49);
  }

  return result;
}

void sub_1002590AC(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 240);
  uint64_t v3 = *(void *)(*(void *)(a1 + 216) + 8 * (v2 / 0xAA));
  uint64_t v4 = (double *)(v3 + 24 * (v2 % 0xAA));
  double v5 = v4[1];
  if (*(double *)(a1 + 280) > v5)
  {
    double v6 = *v4;
    int v7 = sub_10025AB40((void *)a1, *v4, v5);
    if (v7 >= 5) {
      int v8 = 5;
    }
    else {
      int v8 = v7;
    }
    *(_DWORD *)(v3 + 24 * (v2 % 0xAA) + 16) = v8;
    uint64_t v9 = *(void (****)(void, __int128 *))a1;
    if (v6 > 0.0 && v9 != 0LL)
    {
      __int128 v11 = *(_OWORD *)v4;
      uint64_t v14 = *((void *)v4 + 2);
      __int128 v13 = v11;
      (**v9)(v9, &v13);
      unint64_t v2 = *(void *)(a1 + 240);
    }

    uint64_t v12 = *(void *)(a1 + 248) - 1LL;
    *(void *)(a1 + 24sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v2 + 1;
    *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = v12;
    sub_100211164(a1 + 208, 1);
    sub_100258338(a1);
  }

void sub_1002591B4(uint64_t a1, __n128 *a2)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_10182C9E0);
  }
  uint64_t v4 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v5 = a2->n128_u64[0];
    unint64_t v6 = a2->n128_u64[1];
    *(_DWORD *)int buf = 134349312;
    unint64_t v20 = v5;
    __int16 v21 = 2050;
    unint64_t v22 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "StandPlus,minuteAdded,startTime,%{public}f,endTime,%{public}f",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C9E0);
    }
    unint64_t v9 = a2->n128_u64[0];
    unint64_t v10 = a2->n128_u64[1];
    int v15 = 134349312;
    unint64_t v16 = v9;
    __int16 v17 = 2050;
    unint64_t v18 = v10;
    __int128 v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "StandPlus,minuteAdded,startTime,%{public}f,endTime,%{public}f",  &v15,  22);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStandPlusMinuteEstimator::addMinute(const CLStandPlusMinute &)",  "%s\n",  v11);
  }

  if (*(void *)(a1 + 152) >= 0xF0uLL)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C9E0);
    }
    int v7 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 120) + ((*(void *)(a1 + 144) >> 5) & 0x7FFFFFFFFFFFFF8LL))
                     + 16LL * *(void *)(a1 + 144));
      *(_DWORD *)int buf = 134349056;
      unint64_t v20 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "StandPlus,maxReached,minutes,startTime,%{public}f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      unint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 120) + ((*(void *)(a1 + 144) >> 5) & 0x7FFFFFFFFFFFFF8LL))
                      + 16LL * *(void *)(a1 + 144));
      int v15 = 134349056;
      unint64_t v16 = v12;
      LODWORD(v14) = 12;
      __int128 v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "StandPlus,maxReached,minutes,startTime,%{public}f",  &v15,  v14);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStandPlusMinuteEstimator::addMinute(const CLStandPlusMinute &)",  "%s\n",  v13);
    }

    *(int64x2_t *)(a1 + 144) = vaddq_s64(*(int64x2_t *)(a1 + 144), (int64x2_t)xmmword_1012CE4D0);
    sub_100232D40(a1 + 112, 1);
  }

  sub_10025ABC4((void *)(a1 + 112), a2);
  *(__n128 *)(a1 + 264) = *a2;
  sub_10025AE5C(a1, (uint64_t)a2);
}

unint64_t sub_10025955C(void *a1, void *a2, char *a3, void *a4, char *a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = 102 * (a4 - a2)
  }
  unint64_t v7 = a1[4];
  uint64_t v8 = a1[1];
  unint64_t v9 = (char **)(v8 + 8 * (v7 / 0x66));
  if (a1[2] == v8) {
    unint64_t v10 = 0LL;
  }
  else {
    unint64_t v10 = &(*v9)[40 * (v7 % 0x66)];
  }
  if (a3 == v10) {
    unint64_t v11 = 0LL;
  }
  else {
    unint64_t v11 = 102 * ((char **)a2 - v9)
  }
  v24[0].n128_u64[0] = v8 + 8 * (v7 / 0x66);
  v24[0].n128_u64[1] = (unint64_t)v10;
  sub_10025BF98(v24, v11);
  if (v6 >= 1)
  {
    __n128 v12 = v24[0];
    if (v11 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      sub_10025BF98(v24, v6);
      sub_10025C114( v9,  v10,  (char **)v12.n128_u64[0],  (char *)v12.n128_u64[1],  v24[0].n128_u64[0],  (char *)v24[0].n128_u64[1],  v24);
      uint64_t v18 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v18;
    }

    else
    {
      sub_10025BF98(v24, v6);
      __n128 v13 = v24[0];
      unint64_t v14 = a1[4] + a1[5];
      uint64_t v15 = a1[1];
      unint64_t v16 = (_BYTE **)(v15 + 8 * (v14 / 0x66));
      if (a1[2] == v15) {
        __int16 v17 = 0LL;
      }
      else {
        __int16 v17 = &(*v16)[40 * (v14 % 0x66)];
      }
      v24[0] = v12;
      sub_10025C2CC(v13.n128_u64[0], (_BYTE *)v13.n128_u64[1], v16, v17, (uint64_t)v24);
      a1[5] -= v6;
      while ((sub_10025C0A0(a1, 1) & 1) != 0)
        ;
    }
  }

  unint64_t v19 = a1[4];
  uint64_t v20 = a1[1];
  __int16 v21 = (void *)(v20 + 8 * (v19 / 0x66));
  if (a1[2] == v20) {
    unint64_t v22 = 0LL;
  }
  else {
    unint64_t v22 = *v21 + 40 * (v19 % 0x66);
  }
  v24[0].n128_u64[0] = (unint64_t)v21;
  v24[0].n128_u64[1] = v22;
  sub_10025BF98(v24, v11);
  return v24[0].n128_u64[0];
}

double sub_1002597DC(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = sub_100C87934(a1 + 8, a2).n128_u64[0];
  return result;
}

void sub_1002597E4(uint64_t a1, uint64_t a2)
{
  double v4 = (double)*(int *)(a1 + 296);
  double v5 = floor(*(double *)a2 + v4) - (double)((int)vcvtmd_s64_f64(*(double *)a2 + v4) % 3600) - v4;
  double v6 = floor(*(double *)a2 + 3600.0 + v4) - (double)((int)vcvtmd_s64_f64(*(double *)a2 + 3600.0 + v4) % 3600) - v4;
  else {
    double v7 = v5;
  }
  int v8 = *(_DWORD *)(a2 + 16);
  if (v8 == 2)
  {
    *(double *)int buf = v7 + 3600.0 + -1.0;
    unint64_t v9 = (uint8_t *)(a2 + 8);
  }

  else
  {
    unint64_t v9 = (uint8_t *)(a2 + 8);
  }

  unint64_t v10 = *(char **)v9;
  *(double *)int buf = v7;
  unint64_t v26 = v10;
  int v27 = v8;
  char v28 = *(_BYTE *)(a2 + 20);
  uint64_t v29 = *(void *)(a2 + 24);
  char v30 = 0;
  sub_100259BDC((void *)(a1 + 160), (uint64_t)buf);
  switch(*(_DWORD *)(a2 + 16))
  {
    case 0:
    case 3:
    case 4:
      sub_100259C90((uint64_t *)a1);
      break;
    case 1:
      sub_10025A24C((uint64_t *)a1);
      break;
    case 2:
      sub_10025A3E4(a1);
      break;
    default:
      break;
  }

  if (*(void *)(a1 + 200) >= 8uLL)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C9E0);
    }
    unint64_t v11 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "StandPlus,maxReached,sedentaryTimer",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      v24[0] = 0;
      uint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "StandPlus,maxReached,sedentaryTimer",  v24,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStandPlusMinuteEstimator::feedSedentaryTimerAlarm(const CLSedentaryAlarmData &)",  "%s\n",  v23);
    }

    unint64_t v12 = *(void *)(a1 + 192);
    uint64_t v13 = *(void *)(a1 + 168);
    unint64_t v14 = (void *)(v13 + 8 * (v12 / 0x66));
    if (*(void *)(a1 + 176) == v13) {
      uint64_t v15 = 0LL;
    }
    else {
      uint64_t v15 = (char *)(*v14 + 40 * (v12 % 0x66));
    }
    uint64_t v16 = *(void *)(a1 + 200);
    *(void *)int buf = v13 + 8 * (v12 / 0x66);
    unint64_t v26 = v15;
    sub_10025BF98(buf, v16);
    uint64_t v17 = (uint64_t)&v26[-**(void **)buf];
    unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * (v17 >> 3);
    if (v17 < 321)
    {
      unint64_t v22 = 109 - v18;
      uint64_t v20 = (void *)(*(void *)buf - 8 * (v22 / 0x66));
      __int16 v21 = (char *)(*v20 + 40 * (102 * (v22 / 0x66) - v22) + 4040);
    }

    else
    {
      unint64_t v19 = v18 - 8;
      uint64_t v20 = (void *)(*(void *)buf + 8 * (v19 / 0x66));
      __int16 v21 = (char *)(*v20 + 40 * (v19 % 0x66));
    }

    sub_10025955C((void *)(a1 + 160), v14, v15, v20, v21);
  }

__n128 sub_100259BDC(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 102 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_10025C44C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x66)) + 40 * (v7 % 0x66);
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  *(void *)(v8 + 32) = *(void *)(a2 + 32);
  *(__n128 *)unint64_t v8 = result;
  *(_OWORD *)(v8 + 16) = v10;
  ++a1[5];
  return result;
}

void sub_100259C90(uint64_t *a1)
{
  uint64_t v2 = a1[21];
  if (a1[22] == v2)
  {
    sub_100258B54((uint64_t)a1);
    uint64_t v20 = v21;
    unint64_t v8 = 0LL;
LABEL_20:
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C9E0);
    }
    uint64_t v23 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = a1[21];
      if (a1[22] == v24)
      {
        unint64_t v26 = 0LL;
        unint64_t v27 = 0LL;
      }

      else
      {
        unint64_t v25 = a1[24];
        unint64_t v26 = *(void *)(v24 + 8 * (v25 / 0x66)) + 40 * (v25 % 0x66);
        unint64_t v27 = *(void *)(v24 + 8 * ((a1[25] + v25) / 0x66)) + 40 * ((a1[25] + v25) % 0x66);
      }

      *(_DWORD *)int buf = 67109376;
      LODWORD(v46[0]) = v8 == v26;
      WORD2(v46[0]) = 1024;
      *(_DWORD *)((char *)v46 + 6) = v27 != v20;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "StandPlus,no reminder %d,hour earned %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      uint64_t v34 = a1[21];
      if (a1[22] == v34)
      {
        unint64_t v36 = 0LL;
        unint64_t v37 = 0LL;
      }

      else
      {
        unint64_t v35 = a1[24];
        unint64_t v36 = *(void *)(v34 + 8 * (v35 / 0x66)) + 40 * (v35 % 0x66);
        unint64_t v37 = *(void *)(v34 + 8 * ((a1[25] + v35) / 0x66)) + 40 * ((a1[25] + v35) % 0x66);
      }

      int v43 = 67109376;
      *(_DWORD *)double v44 = v8 == v36;
      *(_WORD *)&v44[4] = 1024;
      *(_DWORD *)&v44[6] = v37 != v20;
      float v38 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "StandPlus,no reminder %d,hour earned %d",  &v43,  14);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLStandPlusMinuteEstimator::checkAndFireReminder()", "%s\n", v38);
    }

    return;
  }

  unint64_t v3 = a1[24];
  unint64_t v4 = v3 + a1[25];
  uint64_t v5 = *(void *)(v2 + 8 * (v4 / 0x66));
  uint64_t v6 = (void *)(v2 + 8 * (v4 / 0x66));
  unint64_t v7 = v4 % 0x66;
  unint64_t v8 = v5 + 40 * (v4 % 0x66);
  unint64_t v9 = v3 / 0x66;
  unint64_t v10 = v3 % 0x66;
  unint64_t v11 = *(void *)(v2 + 8 * (v3 / 0x66)) + 40 * (v3 % 0x66);
  if (v8 == v11)
  {
    sub_100258B54((uint64_t)a1);
    uint64_t v20 = v22;
    unint64_t v12 = v6;
  }

  else
  {
    unint64_t v12 = (void *)(v2 + 8 * (v4 / 0x66));
    while (1)
    {
      uint64_t v13 = v8;
      if (v8 == v5) {
        uint64_t v13 = *(v12 - 1) + 4080LL;
      }
      unsigned int v14 = *(_DWORD *)(v13 - 24);
      BOOL v15 = v14 > 4;
      int v16 = (1 << v14) & 0x19;
      if (!v15 && v16 != 0) {
        break;
      }
      if (v8 == v5)
      {
        uint64_t v18 = *--v12;
        uint64_t v5 = v18;
        unint64_t v8 = v18 + 4080;
      }

      v8 -= 40LL;
      if (v8 == v11)
      {
        unint64_t v8 = v11;
        break;
      }
    }

    sub_100258B54((uint64_t)a1);
    uint64_t v20 = v19;
  }

  if (v8 == *(void *)(v2 + 8 * v9) + 40 * v10 || *v6 + 40 * v7 != v20) {
    goto LABEL_20;
  }
  a1[36] = a1[35];
  sub_100648D60(a1 + 1);
  uint64_t v28 = v8;
  if (v8 == *v12) {
    uint64_t v28 = *(v12 - 1) + 4080LL;
  }
  if (!*(_BYTE *)(v28 - 8))
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C9E0);
    }
    uint64_t v29 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
    {
      uint64_t v30 = v8;
      if (v8 == *v12) {
        uint64_t v30 = *(v12 - 1) + 4080LL;
      }
      uint64_t v31 = *(void *)(v30 - 32);
      *(_DWORD *)int buf = 134217984;
      v46[0] = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_INFO,  "StandPlus,firing reminder immediately,firedTime,%f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      uint64_t v39 = v8;
      if (v8 == *v12) {
        uint64_t v39 = *(v12 - 1) + 4080LL;
      }
      uint64_t v40 = *(void *)(v39 - 32);
      int v43 = 134217984;
      *(void *)double v44 = v40;
      uint64_t v41 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "StandPlus,firing reminder immediately,firedTime,%f",  COERCE_DOUBLE(&v43));
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLStandPlusMinuteEstimator::checkAndFireReminder()", "%s\n", v41);
    }

    if (v8 == *v12)
    {
      uint64_t v32 = *(v12 - 1);
      *(_BYTE *)(v32 + 4072) = 1;
      unint64_t v8 = v32 + 4080;
    }

    else
    {
      *(_BYTE *)(v8 - std::istream::~istream(v2, v3 + 8) = 1;
    }

    __int128 v33 = *(_OWORD *)(v8 - 24);
    v42[0] = *(_OWORD *)(v8 - 40);
    v42[1] = v33;
    sub_10025AC4C(a1, (uint64_t *)v42);
  }

uint64_t *sub_10025A24C(uint64_t *result)
{
  double v1 = *((double *)result + 32);
  if (*((double *)result + 35) > v1 + 3600.0)
  {
    uint64_t v2 = result;
    uint64_t v3 = result[21];
    if (result[22] != v3)
    {
      unint64_t v4 = result[24];
      unint64_t v5 = v4 + result[25];
      uint64_t v6 = (unint64_t *)(v3 + 8 * (v5 / 0x66));
      unint64_t v7 = *v6;
      unint64_t v8 = *v6 + 40 * (v5 % 0x66);
      unint64_t v9 = v4 / 0x66;
      uint64_t v10 = *(void *)(v3 + 8 * (v4 / 0x66));
      unint64_t v11 = v4 % 0x66;
      unint64_t v12 = v10 + 40 * v11;
      if (v8 == v12)
      {
        unint64_t v7 = v8;
      }

      else
      {
        uint64_t v13 = v6;
        do
        {
          if (v8 == v7)
          {
            unint64_t v15 = *--v13;
            unint64_t v14 = v15;
            if (*(_DWORD *)(v15 + 4056) == 1) {
              goto LABEL_13;
            }
            unint64_t v8 = v14 + 4080;
            uint64_t v6 = v13;
          }

          else
          {
            unint64_t v14 = v7;
            unint64_t v7 = v8;
            if (*(_DWORD *)(v8 - 24) == 1) {
              goto LABEL_13;
            }
          }

          v8 -= 40LL;
          unint64_t v7 = v14;
        }

        while (v8 != v12);
        unint64_t v7 = v12;
      }

void sub_10025A3E4(uint64_t a1)
{
  uint64_t v3 = v2;
  uint64_t v4 = *(void *)(a1 + 168);
  if (*(void *)(a1 + 176) == v4)
  {
    unint64_t v6 = 0LL;
  }

  else
  {
    unint64_t v5 = *(void *)(a1 + 200) + *(void *)(a1 + 192);
    unint64_t v6 = *(void *)(v4 + 8 * (v5 / 0x66)) + 40 * (v5 % 0x66);
  }

  if (v6 == v2)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C9E0);
    }
    unint64_t v12 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "StandPlus,no hour earned", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      LOWORD(v23) = 0;
      uint64_t v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "StandPlus,no hour earned",  &v23,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLStandPlusMinuteEstimator::checkAndFireReset()", "%s\n", v13);
      if (v13 != buf) {
        free(v13);
      }
    }
  }

  else
  {
    if (*(double *)(a1 + 280) > *(double *)(v2 + 8) && !*(void *)(a1 + 152))
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      unint64_t v7 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
      {
        double v8 = *(double *)v3;
        uint64_t v9 = *(void *)(v3 + 8);
        *(_DWORD *)int buf = 134349312;
        *(double *)&uint8_t buf[4] = v8;
        *(_WORD *)&_BYTE buf[12] = 2050;
        *(void *)&buf[14] = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "StandPlus,empty minute buffer,forcing minute from early stand hour,startTime,%{public}f,firedTime,%{public}f",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10182C9E0);
        }
        double v19 = *(double *)v3;
        uint64_t v20 = *(void *)(v3 + 8);
        int v23 = 134349312;
        double v24 = v19;
        __int16 v25 = 2050;
        uint64_t v26 = v20;
        uint64_t v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "StandPlus,empty minute buffer,forcing minute from early stand hour,startTime,%{public}f,firedTime,%{public}f",  &v23,  22);
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLStandPlusMinuteEstimator::checkAndFireReset()", "%s\n", v21);
        if (v21 != buf) {
          free(v21);
        }
      }

      double v11 = *(double *)v3;
      double v10 = *(double *)(v3 + 8);
      if (vabdd_f64(v10, *(double *)v3) >= 60.0)
      {
        *(double *)int buf = v10 + -60.0;
        *(double *)&uint8_t buf[8] = v10;
      }

      else
      {
        *(void *)int buf = *(void *)v3;
        *(double *)&uint8_t buf[8] = v11 + 60.0;
      }

      sub_10025ABC4((void *)(a1 + 112), (__n128 *)buf);
      sub_100648D60((void *)(a1 + 8));
    }

    if (!*(_BYTE *)(v3 + 32))
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      unint64_t v14 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
      {
        uint64_t v15 = *(void *)(v3 + 8);
        *(_DWORD *)int buf = 134217984;
        *(void *)&uint8_t buf[4] = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "StandPlus,firing stand hour immediately,firedTime,%f",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10182C9E0);
        }
        double v17 = *(double *)(v3 + 8);
        int v23 = 134217984;
        double v24 = v17;
        BOOL v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "StandPlus,firing stand hour immediately,firedTime,%f",  COERCE_DOUBLE(&v23));
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLStandPlusMinuteEstimator::checkAndFireReset()", "%s\n", v18);
        if (v18 != buf) {
          free(v18);
        }
      }

      *(_BYTE *)(v3 + 32) = 1;
      __int128 v16 = *(_OWORD *)(v3 + 16);
      v22[0] = *(_OWORD *)v3;
      v22[1] = v16;
      sub_10025AC4C((uint64_t *)a1, (uint64_t *)v22);
    }
  }

void *sub_10025A918(void *a1, char *a2, uint64_t a3, char *a4, uint64_t a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((a5 - *(void *)a4) >> 4) + 32 * (a4 - a2) - ((a3 - *(void *)a2) >> 4);
  }
  unint64_t v7 = a1[4];
  uint64_t v8 = a1[1];
  uint64_t v9 = (char *)(v8 + 8 * (v7 >> 8));
  if (a1[2] == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = *(void *)v9 + 16LL * v7;
  }
  unint64_t v36 = (char **)v9;
  unint64_t v37 = (char *)v10;
  if (v10 == a3) {
    unint64_t v11 = 0LL;
  }
  else {
    unint64_t v11 = ((a3 - *(void *)a2) >> 4) + 32 * (a2 - v9) - ((v10 - *(void *)v9) >> 4);
  }
  unint64_t v12 = (char **)sub_10025C760((uint64_t)&v36, v11);
  v35.n128_u64[0] = (unint64_t)v12;
  v35.n128_u64[1] = (unint64_t)v13;
  if (v6 >= 1)
  {
    if (v11 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      uint64_t v20 = v12;
      uint64_t v21 = v13;
      uint64_t v22 = v36;
      int v23 = v37;
      double v24 = sub_10025C760((uint64_t)&v35, v6);
      sub_10025C7BC(v22, v23, v20, v21, v24, v25, &v38);
      uint64_t v26 = v37;
      if (v37 != v39)
      {
        unint64_t v27 = v36;
        do
        {
          v26 += 16;
          unint64_t v37 = v26;
          if (v26 - *v27 == 4096)
          {
            uint64_t v28 = v27[1];
            ++v27;
            uint64_t v26 = v28;
            unint64_t v36 = v27;
            unint64_t v37 = v28;
          }
        }

        while (v26 != v39);
      }

      uint64_t v29 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v29;
    }

    else
    {
      unint64_t v14 = (char **)sub_10025C760((uint64_t)&v35, v6);
      unint64_t v16 = a1[4] + a1[5];
      uint64_t v17 = a1[1];
      BOOL v18 = (char **)(v17 + 8 * (v16 >> 8));
      if (a1[2] == v17) {
        double v19 = 0LL;
      }
      else {
        double v19 = &(*v18)[16 * v16];
      }
      __n128 v38 = v35;
      sub_10025C940(v14, v15, v18, v19, (uint64_t)&v38);
      a1[5] -= v6;
      while ((sub_100232D9C(a1, 1) & 1) != 0)
        ;
    }
  }

  unint64_t v30 = a1[4];
  uint64_t v31 = a1[1];
  uint64_t v32 = (void *)(v31 + 8 * (v30 >> 8));
  if (a1[2] == v31) {
    uint64_t v33 = 0LL;
  }
  else {
    uint64_t v33 = *v32 + 16LL * v30;
  }
  v38.n128_u64[0] = (unint64_t)v32;
  v38.n128_u64[1] = v33;
  return sub_10025C760((uint64_t)&v38, v11);
}

uint64_t sub_10025AB40(void *a1, double a2, double a3)
{
  uint64_t v3 = a1[15];
  if (a1[16] == v3) {
    return 0LL;
  }
  unint64_t v4 = a1[18];
  unint64_t v5 = (uint64_t *)(v3 + 8 * (v4 >> 8));
  uint64_t v6 = *v5;
  uint64_t v7 = *v5 + 16LL * v4;
  uint64_t v8 = *(void *)(v3 + (((a1[19] + v4) >> 5) & 0x7FFFFFFFFFFFFF8LL))
     + 16LL * (*((_BYTE *)a1 + 152) + v4);
  if (v7 == v8) {
    return 0LL;
  }
  LODWORD(result) = 0;
  do
  {
    double v10 = *(double *)(v7 + 8);
    BOOL v11 = v10 >= a2;
    if (v10 >= a3) {
      BOOL v11 = 0;
    }
    v7 += 16LL;
    if (v7 - v6 == 4096)
    {
      uint64_t v12 = v5[1];
      ++v5;
      uint64_t v6 = v12;
      uint64_t v7 = v12;
    }

    uint64_t result = (result + v11);
  }

  while (v7 != v8);
  return result;
}

__n128 sub_10025ABC4(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_10025CAC8(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  __n128 result = *a2;
  *(__n128 *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v7) = *a2;
  ++a1[5];
  return result;
}

uint64_t *sub_10025AC4C(uint64_t *result, uint64_t *a2)
{
  if (*result)
  {
    uint64_t v3 = result;
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C9E0);
    }
    uint64_t v4 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *a2;
      uint64_t v6 = a2[1];
      int v7 = *((_DWORD *)a2 + 4);
      *(_DWORD *)int buf = 134349568;
      uint64_t v22 = v5;
      __int16 v23 = 2050;
      uint64_t v24 = v6;
      __int16 v25 = 1026;
      int v26 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "StandPlus,enforced alarm,startTime,%{public}f,firedTime,%{public}f,type,%{public}d",  buf,  0x1Cu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      uint64_t v10 = *a2;
      uint64_t v11 = a2[1];
      int v12 = *((_DWORD *)a2 + 4);
      int v15 = 134349568;
      uint64_t v16 = v10;
      __int16 v17 = 2050;
      uint64_t v18 = v11;
      __int16 v19 = 1026;
      int v20 = v12;
      uint64_t v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "StandPlus,enforced alarm,startTime,%{public}f,firedTime,%{public}f,type,%{public}d",  &v15,  28);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStandPlusMinuteEstimator::sendAlarm(const CLSedentaryAlarmData) const",  "%s\n",  v13);
    }

    uint64_t v8 = *v3;
    __int128 v9 = *((_OWORD *)a2 + 1);
    v14[0] = *(_OWORD *)a2;
    v14[1] = v9;
    return (uint64_t *)(*(uint64_t (**)(uint64_t, _OWORD *))(*(void *)v8 + 8LL))(v8, v14);
  }

  return result;
}

void sub_10025AE5C(uint64_t a1, uint64_t a2)
{
  unint64_t v5 = (unint64_t)v4;
  uint64_t v6 = *(void *)(a1 + 168);
  if (*(void *)(a1 + 176) == v6)
  {
    unint64_t v8 = 0LL;
  }

  else
  {
    unint64_t v7 = *(void *)(a1 + 200) + *(void *)(a1 + 192);
    unint64_t v8 = *(void *)(v6 + 8 * (v7 / 0x66)) + 40 * (v7 % 0x66);
  }

  if ((double *)v8 == v4)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_10182C9E0);
    }
    uint64_t v22 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = *(void *)(a2 + 8);
      *(_DWORD *)int buf = 134349056;
      *(void *)&uint8_t buf[4] = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "StandPlus,forcing reset from early stand minute,endTime,%{public}f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      uint64_t v34 = *(void *)(a2 + 8);
      int v40 = 134349056;
      uint64_t v41 = v34;
      __n128 v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "StandPlus,forcing reset from early stand minute,endTime,%{public}f",  &v40,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStandPlusMinuteEstimator::checkAndFireResetWithMinute(const CLStandPlusMinute &)",  "%s\n",  v35);
      if (v35 != buf) {
        free(v35);
      }
    }

    double v24 = *(double *)(a2 + 8);
    *(double *)int buf = floor(v24 + (double)*(int *)(a1 + 296))
    *(void *)&uint8_t buf[8] = floor(v24);
    *(_DWORD *)&uint8_t buf[16] = 2;
    buf[20] = 1;
    uint64_t v45 = 0LL;
    char v46 = 0;
    sub_100259BDC((void *)(a1 + 160), (uint64_t)buf);
    unint64_t v25 = *(void *)(a1 + 192) + *(void *)(a1 + 200);
    uint64_t v26 = *(void *)(a1 + 168);
    unint64_t v27 = (uint64_t *)(v26 + 8 * (v25 / 0x66));
    uint64_t v28 = *v27;
    unint64_t v29 = *v27 + 40 * (v25 % 0x66);
    if (*(void *)(a1 + 176) == v26) {
      unint64_t v29 = 0LL;
    }
    uint64_t v30 = v29 - v28;
    unint64_t v31 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v29 - v28) >> 3);
    if (v30 < 41) {
      unint64_t v5 = v27[-((102 - v31) / 0x66)] + 40 * (102 * ((102 - v31) / 0x66) - (102 - v31)) + 4040;
    }
    else {
      unint64_t v5 = v27[(v31 - 1) / 0x66] + 40 * ((v31 - 1) % 0x66);
    }
  }

  else
  {
    double v9 = *v4 + 60.0;
    if (v4[1] >= v9) {
      double v9 = v4[1];
    }
    if (v9 < floor(*(double *)(*(void *)(*(void *)(a1 + 120) + ((*(void *)(a1 + 144) >> 5) & 0x7FFFFFFFFFFFFF8LL))
                              + 16LL * *(void *)(a1 + 144)
                              + 8)))
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_10182C9E0);
      }
      uint64_t v10 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(v5 + 8);
        uint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 120) + ((*(void *)(a1 + 144) >> 5) & 0x7FFFFFFFFFFFFF8LL))
        *(_DWORD *)int buf = 134349312;
        *(void *)&uint8_t buf[4] = v11;
        *(_WORD *)&_BYTE buf[12] = 2050;
        *(void *)&buf[14] = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "StandPlus,forcing minute from early stand hour,%{public}f,endTime,%{public}f",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_10182C9E0);
        }
        uint64_t v36 = *(void *)(v5 + 8);
        uint64_t v37 = *(void *)(*(void *)(*(void *)(a1 + 120) + ((*(void *)(a1 + 144) >> 5) & 0x7FFFFFFFFFFFFF8LL))
        int v40 = 134349312;
        uint64_t v41 = v36;
        __int16 v42 = 2050;
        uint64_t v43 = v37;
        __n128 v38 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "StandPlus,forcing minute from early stand hour,%{public}f,endTime,%{public}f",  &v40,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStandPlusMinuteEstimator::checkAndFireResetWithMinute(const CLStandPlusMinute &)",  "%s\n",  v38);
        if (v38 != buf) {
          free(v38);
        }
      }

      double v13 = *(double *)(v5 + 8);
      unint64_t v14 = *(void *)(a1 + 144);
      uint64_t v15 = *(void *)(*(void *)(a1 + 120) + ((v14 >> 5) & 0x7FFFFFFFFFFFFF8LL));
      uint64_t v16 = v15 + 16LL * v14;
      double v18 = *(double *)(v16 + 8);
      __int16 v17 = (double *)(v16 + 8);
      if (vabdd_f64(v13, v18) >= 60.0)
      {
        double v32 = *(double *)v5;
        if (vabdd_f64(v13, *(double *)v5) >= 60.0)
        {
          *(double *)int buf = v13 + -60.0;
          *(double *)&uint8_t buf[8] = v13;
        }

        else
        {
          *(void *)int buf = *(void *)v5;
          *(double *)&uint8_t buf[8] = v32 + 60.0;
        }

        sub_10025B45C(a1 + 112, buf);
      }

      else
      {
        double v19 = v13 + -60.0;
        double v20 = *(double *)v5;
        *(double *)(v15 + 16LL * *(void *)(a1 + 144)) = v19;
        double v21 = v20 + 60.0;
        double *v17 = v21;
      }
    }
  }

  if (!*(_BYTE *)(v5 + 32))
  {
    *(_BYTE *)(v5 + 32) = 1;
    __int128 v33 = *(_OWORD *)(v5 + 16);
    v39[0] = *(_OWORD *)v5;
    v39[1] = v33;
    sub_10025AC4C((uint64_t *)a1, (uint64_t *)v39);
  }

int64x2_t sub_10025B45C(uint64_t a1, _OWORD *a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_10025CDDC((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }

  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 >> 8));
  uint64_t v7 = *v6 + 16LL * v4;
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0LL;
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4096LL;
  }
  *(_OWORD *)(v7 - 16) = *a2;
  int64x2_t result = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1012E2F20);
  *(int64x2_t *)(a1 + 32) = result;
  return result;
}

uint64_t sub_10025B4D8(uint64_t a1, unint64_t a2, __int128 *a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  if (a2) {
    sub_10025B524((void *)a1, a2, a3);
  }
  return a1;
}

void sub_10025B510(_Unwind_Exception *a1)
{
}

void *sub_10025B524(void *a1, unint64_t a2, __int128 *a3)
{
  uint64_t v6 = a1[1];
  uint64_t v7 = a1[2];
  if (v7 == v6) {
    uint64_t v8 = 0LL;
  }
  else {
    uint64_t v8 = 170 * ((v7 - v6) >> 3) - 1;
  }
  unint64_t v9 = a1[5] + a1[4];
  unint64_t v10 = v8 - v9;
  BOOL v11 = a2 > v10;
  unint64_t v12 = a2 - v10;
  if (v11)
  {
    sub_10025B674(a1, v12);
    uint64_t v6 = a1[1];
    uint64_t v7 = a1[2];
    unint64_t v9 = a1[4] + a1[5];
  }

  double v13 = (void *)(v6 + 8 * (v9 / 0xAA));
  if (v7 == v6) {
    unint64_t v14 = 0LL;
  }
  else {
    unint64_t v14 = *v13 + 24 * (v9 % 0xAA);
  }
  uint64_t v22 = (void *)(v6 + 8 * (v9 / 0xAA));
  unint64_t v23 = v14;
  int64x2_t result = sub_10025BC20(&v22, a2);
  uint64_t v16 = v23;
  if (v14 != v23)
  {
    __int16 v17 = v22;
    do
    {
      if (v13 == v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = *v13 + 4080LL;
      }
      if (v14 == v18)
      {
        uint64_t v18 = v14;
      }

      else
      {
        unint64_t v19 = v14;
        do
        {
          __int128 v20 = *a3;
          *(void *)(v19 + 16) = *((void *)a3 + 2);
          *(_OWORD *)unint64_t v19 = v20;
          v19 += 24LL;
        }

        while (v19 != v18);
      }

      a1[5] -= 0x5555555555555555LL * ((uint64_t)(v18 - v14) >> 3);
      if (v13 == v17) {
        break;
      }
      unint64_t v21 = v13[1];
      ++v13;
      unint64_t v14 = v21;
    }

    while (v21 != v16);
  }

  return result;
}

void sub_10025B674(void *a1, unint64_t a2)
{
  uint64_t v3 = (char *)a1[2];
  uint64_t v4 = (uint64_t)&v3[-a1[1]];
  if (v4) {
    unint64_t v5 = a2;
  }
  else {
    unint64_t v5 = a2 + 1;
  }
  if (v5 % 0xAA) {
    unint64_t v6 = v5 / 0xAA + 1;
  }
  else {
    unint64_t v6 = v5 / 0xAA;
  }
  unint64_t v7 = a1[4];
  if (v6 >= v7 / 0xAA) {
    unint64_t v8 = v7 / 0xAA;
  }
  else {
    unint64_t v8 = v6;
  }
  if (v6 <= v7 / 0xAA)
  {
    for (a1[4] = v7 - 170 * v8; v8; --v8)
    {
      uint64_t v16 = (void *)a1[1];
      uint64_t v19 = *v16;
      __int16 v17 = (char *)(v16 + 1);
      uint64_t v18 = v19;
      a1[1] = v17;
      if (v3 == (char *)a1[3])
      {
        uint64_t v20 = (uint64_t)&v17[-*a1];
        if ((unint64_t)v17 <= *a1)
        {
          else {
            unint64_t v28 = (uint64_t)&v3[-*a1] >> 2;
          }
          unint64_t v29 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v28);
          unint64_t v31 = &v29[8 * (v28 >> 2)];
          double v32 = (uint64_t *)a1[1];
          uint64_t v3 = v31;
          uint64_t v33 = a1[2] - (void)v32;
          if (v33)
          {
            uint64_t v3 = &v31[v33 & 0xFFFFFFFFFFFFFFF8LL];
            uint64_t v34 = 8 * (v33 >> 3);
            __n128 v35 = &v29[8 * (v28 >> 2)];
            do
            {
              uint64_t v36 = *v32++;
              *(void *)__n128 v35 = v36;
              v35 += 8;
              v34 -= 8LL;
            }

            while (v34);
          }

          uint64_t v37 = (char *)*a1;
          *a1 = v29;
          a1[1] = v31;
          a1[2] = v3;
          a1[3] = &v29[8 * v30];
          if (v37)
          {
            operator delete(v37);
            uint64_t v3 = (char *)a1[2];
          }
        }

        else
        {
          uint64_t v21 = v20 >> 3;
          BOOL v22 = v20 >> 3 < -1;
          uint64_t v23 = (v20 >> 3) + 2;
          if (v22) {
            uint64_t v24 = v23;
          }
          else {
            uint64_t v24 = v21 + 1;
          }
          unint64_t v25 = &v17[-8 * (v24 >> 1)];
          int64_t v26 = v3 - v17;
          if (v3 != v17)
          {
            memmove(&v17[-8 * (v24 >> 1)], v17, v3 - v17);
            uint64_t v3 = (char *)a1[1];
          }

          unint64_t v27 = &v3[-8 * (v24 >> 1)];
          uint64_t v3 = &v25[v26];
          a1[1] = v27;
          a1[2] = &v25[v26];
        }
      }

      *(void *)uint64_t v3 = v18;
      uint64_t v3 = (char *)(a1[2] + 8LL);
      a1[2] = v3;
    }
  }

  else
  {
    unint64_t v9 = v6 - v8;
    uint64_t v10 = a1[3] - *a1;
    if (v6 - v8 <= (v10 >> 3) - (v4 >> 3))
    {
      if (v9)
      {
        while (a1[3] != a1[2])
        {
          __p[0] = operator new(0xFF0uLL);
          sub_1000EC960(a1, __p);
          --v6;
          if (!--v9) {
            goto LABEL_75;
          }
        }

        for (uint64_t i = 0LL; i != v9; ++i)
        {
          __p[0] = operator new(0xFF0uLL);
          sub_1000ECA74((uint64_t)a1, __p);
          if (a1[2] - a1[1] == 8LL) {
            uint64_t v64 = 169LL;
          }
          else {
            uint64_t v64 = 170LL;
          }
          uint64_t v65 = v64 + a1[4];
          a1[4] = v65;
        }

        unint64_t v8 = v6;
      }

      else
      {
LABEL_75:
        uint64_t v65 = a1[4];
      }

      a1[4] = v65 - 170 * v8;
      if (v8)
      {
        int v66 = (char *)a1[2];
        do
        {
          int v67 = (void *)a1[1];
          uint64_t v70 = *v67;
          double v68 = (char *)(v67 + 1);
          uint64_t v69 = v70;
          a1[1] = v68;
          if (v66 == (char *)a1[3])
          {
            uint64_t v71 = (uint64_t)&v68[-*a1];
            if ((unint64_t)v68 <= *a1)
            {
              else {
                unint64_t v78 = (uint64_t)&v66[-*a1] >> 2;
              }
              __int16 v79 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v78);
              int v81 = &v79[8 * (v78 >> 2)];
              int v82 = (uint64_t *)a1[1];
              int v66 = v81;
              uint64_t v83 = a1[2] - (void)v82;
              if (v83)
              {
                int v66 = &v81[v83 & 0xFFFFFFFFFFFFFFF8LL];
                uint64_t v84 = 8 * (v83 >> 3);
                double v85 = &v79[8 * (v78 >> 2)];
                do
                {
                  uint64_t v86 = *v82++;
                  *(void *)double v85 = v86;
                  v85 += 8;
                  v84 -= 8LL;
                }

                while (v84);
              }

              int v87 = (char *)*a1;
              *a1 = v79;
              a1[1] = v81;
              a1[2] = v66;
              a1[3] = &v79[8 * v80];
              if (v87)
              {
                operator delete(v87);
                int v66 = (char *)a1[2];
              }
            }

            else
            {
              uint64_t v72 = v71 >> 3;
              BOOL v22 = v71 >> 3 < -1;
              uint64_t v73 = (v71 >> 3) + 2;
              if (v22) {
                uint64_t v74 = v73;
              }
              else {
                uint64_t v74 = v72 + 1;
              }
              __int128 v75 = &v68[-8 * (v74 >> 1)];
              int64_t v76 = v66 - v68;
              if (v66 != v68)
              {
                memmove(&v68[-8 * (v74 >> 1)], v68, v66 - v68);
                int v66 = (char *)a1[1];
              }

              __int128 v77 = &v66[-8 * (v74 >> 1)];
              int v66 = &v75[v76];
              a1[1] = v77;
              a1[2] = &v75[v76];
            }
          }

          *(void *)int v66 = v69;
          int v66 = (char *)(a1[2] + 8LL);
          a1[2] = v66;
          --v8;
        }

        while (v8);
      }
    }

    else
    {
      uint64_t v11 = v4 >> 3;
      unint64_t v12 = v10 >> 2;
      if (v12 <= v9 + v11) {
        unint64_t v13 = v9 + v11;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v14 = v11 - v8;
      __int16 v91 = a1 + 3;
      if (v13) {
        uint64_t v15 = (char *)sub_1000071BC((uint64_t)(a1 + 3), v13);
      }
      else {
        uint64_t v15 = 0LL;
      }
      uint64_t v38 = -170LL * v8;
      __p[0] = v15;
      __p[1] = &v15[8 * v14];
      *(void **)&__int128 v90 = __p[1];
      *((void *)&v90 + 1) = &v15[8 * v13];
      do
      {
        int v88 = operator new(0xFF0uLL);
        sub_1000ECB90(__p, &v88);
        --v9;
      }

      while (v9);
      if (v8)
      {
        uint64_t v39 = (void *)a1[1];
        int v40 = (char *)v90;
        do
        {
          if (v40 == *((char **)&v90 + 1))
          {
            int64_t v41 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (v40 == __p[0]) {
                unint64_t v48 = 1LL;
              }
              else {
                unint64_t v48 = (v40 - (char *)__p[0]) >> 2;
              }
              uint64_t v49 = (char *)sub_1000071BC((uint64_t)v91, v48);
              unint64_t v51 = (uint64_t *)__p[1];
              int v40 = &v49[8 * (v48 >> 2)];
              uint64_t v52 = v90 - (unint64_t)__p[1];
              if ((void *)v90 != __p[1])
              {
                int v40 = &v49[8 * (v48 >> 2) + (v52 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v53 = 8 * (v52 >> 3);
                BOOL v54 = &v49[8 * (v48 >> 2)];
                do
                {
                  uint64_t v55 = *v51++;
                  *(void *)BOOL v54 = v55;
                  v54 += 8;
                  v53 -= 8LL;
                }

                while (v53);
              }

              BOOL v56 = __p[0];
              __p[0] = v49;
              __p[1] = &v49[8 * (v48 >> 2)];
              *(void *)&__int128 v90 = v40;
              *((void *)&v90 + 1) = &v49[8 * v50];
              if (v56)
              {
                operator delete(v56);
                int v40 = (char *)v90;
              }
            }

            else
            {
              uint64_t v42 = v41 >> 3;
              BOOL v22 = v41 >> 3 < -1;
              uint64_t v43 = (v41 >> 3) + 2;
              if (v22) {
                uint64_t v44 = v43;
              }
              else {
                uint64_t v44 = v42 + 1;
              }
              uint64_t v45 = (char *)__p[1] - 8 * (v44 >> 1);
              int64_t v46 = v40 - (char *)__p[1];
              if (v40 != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v44 >> 1), __p[1], v40 - (char *)__p[1]);
                int v40 = (char *)__p[1];
              }

              unint64_t v47 = &v40[-8 * (v44 >> 1)];
              int v40 = &v45[v46];
              __p[1] = v47;
              *(void *)&__int128 v90 = &v45[v46];
            }
          }

          *(void *)int v40 = *v39;
          int v40 = (char *)(v90 + 8);
          *(void *)&__int128 v90 = v90 + 8;
          uint64_t v39 = (void *)(a1[1] + 8LL);
          a1[1] = v39;
          --v8;
        }

        while (v8);
      }

      uint64_t v57 = (void *)a1[2];
      uint64_t v58 = -7LL - (void)v57;
      while (v57 != (void *)a1[1])
      {
        --v57;
        v58 += 8LL;
        sub_1000ECCA4((uint64_t)__p, v57);
      }

      uint64_t v59 = (char *)*a1;
      __int128 v60 = *(_OWORD *)__p;
      __int128 v61 = v90;
      __p[0] = *(void **)a1;
      __p[1] = v57;
      __int128 v62 = *((_OWORD *)a1 + 1);
      *(_OWORD *)a1 = v60;
      *((_OWORD *)a1 + 1) = v61;
      __int128 v90 = v62;
      a1[4] += v38;
      if (v57 != (void *)v62) {
        *(void *)&__int128 v90 = v62 + (-(v62 + v58) & 0xFFFFFFFFFFFFFFF8LL);
      }
      if (v59) {
        operator delete(v59);
      }
    }
  }

void sub_10025BBAC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10025BC20(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x5555555555555555LL * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 169 - v3;
      unint64_t v6 = &v2[-(v5 / 0xAA)];
      *int64x2_t result = v6;
      unint64_t v4 = *v6 + 24 * (170 * (v5 / 0xAA) - v5) + 4056;
    }

    else
    {
      *int64x2_t result = &v2[v3 / 0xAA];
      unint64_t v4 = v2[v3 / 0xAA] + 24 * (v3 % 0xAA);
    }

    result[1] = v4;
  }

  return result;
}

void sub_10025BCBC(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_10025BCE8(void *a1, uint64_t a2)
{
  unint64_t v4 = (void **)a1[1];
  uint64_t v5 = a1[2];
  a1[5] = 0LL;
  unint64_t v6 = v5 - (void)v4;
  if (v6 >= 0x11)
  {
    do
    {
      operator delete(*v4);
      uint64_t v7 = a1[2];
      unint64_t v4 = (void **)(a1[1] + 8LL);
      a1[1] = v4;
      unint64_t v6 = v7 - (void)v4;
    }

    while (v6 > 0x10);
  }

  if (v6 >> 3 == 1)
  {
    uint64_t v8 = 85LL;
    goto LABEL_7;
  }

  if (v6 >> 3 == 2)
  {
    uint64_t v8 = 170LL;
LABEL_7:
    a1[4] = v8;
  }

  sub_10025BD88(a1);
  uint64_t result = sub_10025BF2C((uint64_t)a1, a2);
  a1[4] = *(void *)(a2 + 32);
  a1[5] = *(void *)(a2 + 40);
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  return result;
}

void sub_10025BD88(void *a1)
{
  if (a1[5])
  {
    sub_100211164((uint64_t)a1, 0);
    sub_10025BDF8(a1, 0);
  }

  else
  {
    uint64_t v3 = a1[1];
    for (uint64_t i = a1[2]; i != v3; a1[2] = i)
    {
      operator delete(*(void **)(i - 8));
      uint64_t v3 = a1[1];
      uint64_t i = a1[2] - 8LL;
    }

    a1[4] = 0LL;
  }

  sub_10025BE6C((uint64_t)a1);
}

uint64_t sub_10025BDF8(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = 170 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0xAA) {
    a2 = 1;
  }
  if (v5 < 0x154) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

void sub_10025BE6C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v2 = a1 + 24;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  unint64_t v6 = (v5 - v4) >> 3;
  if (v6 < (v3 - *(void *)a1) >> 3)
  {
    if (v5 == v4)
    {
      uint64_t v10 = 0LL;
      int v7 = 0LL;
    }

    else
    {
      int v7 = (char *)sub_1000071BC(v2, v6);
      uint64_t v8 = *(void *)(a1 + 8);
      uint64_t v5 = *(void *)(a1 + 16);
      uint64_t v10 = &v7[8 * v9];
      uint64_t v11 = v5 - v8;
      if (v5 != v8)
      {
        uint64_t v12 = 0LL;
        uint64_t v13 = 8 * (v11 >> 3);
        do
        {
          *(void *)&v7[v12] = *(void *)(v8 + v12);
          v12 += 8LL;
        }

        while (v13 != v12);
        uint64_t v5 = *(void *)(a1 + 8);
        uint64_t v14 = *(void *)(a1 + 16);
        goto LABEL_9;
      }
    }

    uint64_t v14 = v5;
LABEL_9:
    uint64_t v15 = v14 - v5;
    uint64_t v16 = *(void **)a1;
    *(void *)a1 = v7;
    *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v7;
    *(void *)(a1 + 16) = &v7[v15];
    *(void *)(a1 + 24) = v10;
    if (v16) {
      operator delete(v16);
    }
  }

uint64_t sub_10025BF2C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4 != v5) {
    *(void *)(a1 + 16) = v4 + ((v5 - v4 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  }
  sub_10025BE6C(a1);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  return a1;
}

void *sub_10025BF98(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x3333333333333333LL * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 101 - v3;
      unint64_t v6 = &v2[-(v5 / 0x66)];
      *uint64_t result = v6;
      unint64_t v4 = *v6 + 40 * (102 * (v5 / 0x66) - v5) + 4040;
    }

    else
    {
      *uint64_t result = &v2[v3 / 0x66];
      unint64_t v4 = v2[v3 / 0x66] + 40 * (v3 % 0x66);
    }

    result[1] = v4;
  }

  return result;
}

uint64_t sub_10025C044(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x66) {
    a2 = 1;
  }
  if (v2 < 0xCC) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 102LL;
  }

  return v4 ^ 1u;
}

uint64_t sub_10025C0A0(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = 102 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x66) {
    a2 = 1;
  }
  if (v5 < 0xCC) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

__n128 sub_10025C114@<Q0>( char **a1@<X1>, char *a2@<X2>, char **a3@<X3>, char *a4@<X4>, void *a5@<X5>, char *a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    uint64_t v19 = a2;
    uint64_t v18 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
  }

  else
  {
    uint64_t v13 = a3 - 1;
    uint64_t v12 = *a3;
    uint64_t v14 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
    while (1)
    {
      sub_10025C1E0(v12, v14, v15, v16, &v21);
      uint64_t v16 = (char *)v22.n128_u64[1];
      uint64_t v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      __int16 v17 = *v13--;
      uint64_t v12 = v17;
      uint64_t v14 = v17 + 4080;
    }

    uint64_t v18 = *a1 + 4080;
    uint64_t v19 = a2;
  }

  sub_10025C1E0(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = (unint64_t)a4;
  a7[1] = result;
  return result;
}

void *sub_10025C1E0@<X0>(char *a1@<X1>, char *a2@<X2>, void *a3@<X3>, char *a4@<X4>, void *a5@<X8>)
{
  unint64_t v6 = a3;
  if (a1 == a2)
  {
    uint64_t v9 = a1;
  }

  else
  {
    uint64_t v9 = a2;
    uint64_t v10 = *a3;
    uint64_t v11 = a2;
    while (1)
    {
      int64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&a4[-v10] >> 3);
      v11 -= 40 * v12;
      a4 -= 40 * v12;
      if (v12) {
        __n128 result = memmove(a4, v11, 40 * v12 - 7);
      }
      if (v11 == a1) {
        break;
      }
      uint64_t v14 = *--v6;
      uint64_t v10 = v14;
      a4 = (char *)(v14 + 4080);
    }

    if ((char *)(*v6 + 4080LL) == a4)
    {
      uint64_t v15 = (char *)v6[1];
      ++v6;
      a4 = v15;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = a4;
  return result;
}

double sub_10025C2CC(void *a1, _BYTE *a2, _BYTE **a3, _BYTE *a4, uint64_t a5)
{
  int v7 = *(void ***)a5;
  uint64_t v8 = *(char **)(a5 + 8);
  if (a1 != a3)
  {
    uint64_t v10 = a1 + 1;
    for (uint64_t i = (_BYTE *)(*a1 + 4080LL); ; uint64_t i = v12 + 4080)
    {
      sub_10025C35C(a2, v8, i, v7, &v14);
      uint64_t v8 = (char *)*((void *)&v15 + 1);
      int v7 = (void **)v15;
      *(void *)a5 = v15;
      *(void *)(a5 + std::istream::~istream(v2, v3 + 8) = v8;
      if (v10 == a3) {
        break;
      }
      int64_t v12 = (_BYTE *)*v10++;
      a2 = v12;
    }

    a2 = *a3;
  }

  sub_10025C35C(a2, v8, a4, v7, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

void *sub_10025C35C@<X0>( _BYTE *__src@<X1>, char *__dst@<X4>, _BYTE *a3@<X2>, void **a4@<X3>, void *a5@<X8>)
{
  unint64_t v6 = a4;
  int v7 = __src;
  if (__src == a3)
  {
    uint64_t v9 = __src;
  }

  else
  {
    uint64_t v9 = a3;
    unint64_t v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      int64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((v10 - __dst + 4080) >> 3);
      unint64_t v12 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * ((v9 - v7) >> 3)) >= v11 ? v11 : 0xCCCCCCCCCCCCCCCDLL * ((v9 - v7) >> 3);
      if (v12) {
        double result = memmove(__dst, v7, 40 * v12 - 7);
      }
      v7 += 40 * v12;
      if (v7 == v9) {
        break;
      }
      uint64_t v14 = (char *)*v6++;
      uint64_t v10 = v14;
      __uuid_t dst = v14;
    }

    __dst += 40 * v12;
    else {
      --v6;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = __dst;
  return result;
}

void sub_10025C44C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x66;
  unint64_t v4 = v2 - 102;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    int v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __n128 v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_10025C714( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_10025C760(uint64_t a1, uint64_t a2)
{
  double result = *(void **)a1;
  if (a2)
  {
    uint64_t v4 = a2 + ((uint64_t)(*(void *)(a1 + 8) - *result) >> 4);
    if (v4 < 1) {
      result -= (unint64_t)(255 - v4) >> 8;
    }
    else {
      result += (unint64_t)v4 >> 8;
    }
  }

  return result;
}

__n128 sub_10025C7BC@<Q0>( char **a1@<X1>, char *a2@<X2>, char **a3@<X3>, char *a4@<X4>, void *a5@<X5>, char *a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    uint64_t v19 = a2;
    uint64_t v18 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
  }

  else
  {
    uint64_t v13 = a3 - 1;
    uint64_t v12 = *a3;
    BOOL v14 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
    while (1)
    {
      sub_10025C888(v12, v14, v15, v16, &v21);
      uint64_t v16 = (char *)v22.n128_u64[1];
      uint64_t v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      uint64_t v17 = *v13--;
      uint64_t v12 = v17;
      BOOL v14 = v17 + 4096;
    }

    uint64_t v18 = *a1 + 4096;
    uint64_t v19 = a2;
  }

  sub_10025C888(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = (unint64_t)a4;
  a7[1] = result;
  return result;
}

void *sub_10025C888@<X0>(char *a1@<X1>, char *a2@<X2>, void *a3@<X3>, char *a4@<X4>, void *a5@<X8>)
{
  unint64_t v6 = a3;
  if (a1 == a2)
  {
    uint64_t v9 = a1;
  }

  else
  {
    uint64_t v9 = a2;
    uint64_t v10 = *a3;
    uint64_t v11 = a2;
    while (1)
    {
      uint64_t v12 = (uint64_t)&a4[-v10];
      if ((v11 - a1) >> 4 >= v12 >> 4) {
        uint64_t v13 = v12 >> 4;
      }
      else {
        uint64_t v13 = (v11 - a1) >> 4;
      }
      v11 -= 16 * v13;
      a4 -= 16 * v13;
      if (v13) {
        __n128 result = memmove(a4, v11, 16 * v13);
      }
      if (v11 == a1) {
        break;
      }
      uint64_t v15 = *--v6;
      uint64_t v10 = v15;
      a4 = (char *)(v15 + 4096);
    }

    if ((char *)(*v6 + 4096LL) == a4)
    {
      uint64_t v16 = (char *)v6[1];
      ++v6;
      a4 = v16;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = a4;
  return result;
}

double sub_10025C940(char **a1, char *__src, char **a3, char *a4, uint64_t a5)
{
  if (a1 == a3)
  {
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
    uint64_t v10 = __src;
  }

  else
  {
    uint64_t v8 = a1 + 1;
    sub_10025CA0C(__src, *(char **)(a5 + 8), *a1 + 4096, *(void ***)a5, &v14);
    for (*(_OWORD *)a5 = v15; v8 != a3; *(_OWORD *)a5 = v15)
    {
      uint64_t v9 = *v8++;
      sub_10025CA0C(v9, *(char **)(a5 + 8), v9 + 4096, *(void ***)a5, &v14);
    }

    uint64_t v10 = *a3;
    uint64_t v11 = *(void ***)a5;
    uint64_t v12 = *(char **)(a5 + 8);
  }

  sub_10025CA0C(v10, v12, a4, v11, &v14);
  double result = *(double *)&v15;
  *(_OWORD *)a5 = v15;
  return result;
}

char *sub_10025CA0C@<X0>(char *__src@<X0>, char *__dst@<X3>, char *a3@<X1>, void **a4@<X2>, char **a5@<X8>)
{
  unint64_t v6 = a4;
  if (__src != a3)
  {
    uint64_t v9 = __src;
    unint64_t v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      uint64_t v11 = v10 - __dst + 4096;
      uint64_t v12 = (a3 - v9) >> 4 >= v11 >> 4 ? v11 >> 4 : (a3 - v9) >> 4;
      if (v12) {
        __src = (char *)memmove(__dst, v9, 16 * v12);
      }
      v9 += 16 * v12;
      if (v9 == a3) {
        break;
      }
      uint64_t v13 = (char *)*v6++;
      uint64_t v10 = v13;
      __uuid_t dst = v13;
    }

    __dst += 16 * v12;
    else {
      --v6;
    }
  }

  *a5 = a3;
  a5[1] = (char *)v6;
  a5[2] = __dst;
  return __src;
}

void sub_10025CAC8(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    unint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    int v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __n128 v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        int64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)int64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_10025CD90( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_10025CDDC(void **a1)
{
  unint64_t v2 = a1[1];
  BOOL v3 = a1[2];
  unint64_t v4 = v3 - v2;
  if (v3 == v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = 32 * (v3 - v2) - 1;
  }
  unint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x100)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = a1[3];
    uint64_t v9 = *a1;
    uint64_t v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10)
    {
      if (v8 == v9) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      unint64_t v46 = a1 + 3;
      std::stringbuf::string_type __p = sub_1000071BC(v7, v11);
      uint64_t v43 = (char *)__p;
      uint64_t v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      int64_t v41 = operator new(0x1000uLL);
      sub_1000ECB90(&__p, &v41);
      uint64_t v13 = (char *)a1[1];
      BOOL v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }

      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1LL;
              }
              else {
                unint64_t v23 = (v14 - (_BYTE *)__p) >> 2;
              }
              uint64_t v24 = (char *)sub_1000071BC((uint64_t)v46, v23);
              uint64_t v26 = v43;
              BOOL v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                BOOL v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v28 = 8 * (v27 >> 3);
                unint64_t v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)unint64_t v29 = v30;
                  v29 += 8;
                  v28 -= 8LL;
                }

                while (v28);
              }

              __int128 v31 = __p;
              std::stringbuf::string_type __p = v24;
              uint64_t v43 = &v24[8 * (v23 >> 2)];
              uint64_t v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                BOOL v14 = v44;
              }
            }

            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              int64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                BOOL v14 = v43;
              }

              unint64_t v22 = &v14[-8 * (v19 >> 1)];
              BOOL v14 = &v20[v21];
              uint64_t v43 = v22;
              uint64_t v44 = &v20[v21];
            }
          }

          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)BOOL v14 = v32;
          BOOL v14 = v44 + 8;
          v44 += 8;
        }

        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }

      uint64_t v36 = *a1;
      uint64_t v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      std::stringbuf::string_type __p = v36;
      uint64_t v43 = v33;
      uint64_t v38 = (char *)a1[3];
      uint64_t v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      uint64_t v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 128LL;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 256;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        uint64_t v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v36) {
        operator delete(v36);
      }
    }

    else
    {
      if (v2 == v9)
      {
        std::stringbuf::string_type __p = operator new(0x1000uLL);
        sub_1000EC960(a1, &__p);
        uint64_t v34 = a1[2];
        std::stringbuf::string_type __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }

      else
      {
        std::stringbuf::string_type __p = operator new(0x1000uLL);
      }

      sub_1000ECA74((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8) {
        uint64_t v35 = 128LL;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 256;
      }
      a1[4] = (void *)v35;
    }
  }

  else
  {
    a1[4] = v6 + 256;
    std::stringbuf::string_type __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1000ECA74((uint64_t)a1, &__p);
  }

void sub_10025D0A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10025D0EC(uint64_t result, int a2, int a3, double a4)
{
  *(_DWORD *)double result = a2;
  *(void *)(result + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 2sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = a3;
  *(double *)(result + 24) = a4;
  return result;
}

BOOL sub_10025D100(uint64_t a1, double a2)
{
  int v4 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 == *(_DWORD *)(a1 + 16)) {
    *(double *)(a1 + std::istream::~istream(v2, v3 + 8) = a2;
  }
  if (v4 >= 1) {
    *(_DWORD *)a1 = v4 - 1;
  }
  return v4 > 0;
}

uint64_t sub_10025D154(double *a1, double a2)
{
  double v3 = a1[1];
  double v4 = vabdd_f64(a2, v3);
  double v5 = a1[3];
  if (v4 < v5) {
    return *(unsigned int *)a1;
  }
  uint64_t result = *((unsigned int *)a1 + 4);
  if (v4 >= v5 * (double)(int)result)
  {
    *(_DWORD *)a1 = result;
  }

  else
  {
    int v7 = vcvtmd_s64_f64(v4 / v5);
    int v8 = *(_DWORD *)a1 + *((_DWORD *)a1 + 5) * v7;
    else {
      uint64_t result = v8;
    }
    *(_DWORD *)a1 = result;
    a2 = v3 + (double)v7 * v5;
  }

  a1[1] = a2;
  return result;
}

BOOL sub_10025D1C0(double *a1, double a2)
{
  return *(_DWORD *)a1 > 0;
}

BOOL sub_10025D1EC(uint64_t a1, double a2)
{
  return vabdd_f64(a2, *(double *)(a1 + 8)) > *(double *)(a1 + 24) * (double)*(int *)(a1 + 16);
}

uint64_t sub_10025D4FC(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    while (2)
    {
      if (!*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error))
      {
        char v4 = 0;
        unsigned int v5 = 0;
        unint64_t v6 = 0LL;
        while (1)
        {
          uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v8 = v7 + 1;
          if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v9 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
          v6 |= (unint64_t)(v9 & 0x7F) << v4;
          if ((v9 & 0x80) == 0) {
            goto LABEL_11;
          }
          v4 += 7;
          BOOL v10 = v5++ >= 9;
          if (v10)
          {
            unint64_t v6 = 0LL;
            uint64_t v11 = OBJC_IVAR___PBDataReader__error;
            int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
            goto LABEL_13;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
        uint64_t v11 = OBJC_IVAR___PBDataReader__error;
        int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          unint64_t v6 = 0LL;
        }
LABEL_13:
        if (v12) {
          BOOL v13 = 1;
        }
        else {
          BOOL v13 = (v6 & 7) == 4;
        }
        if (!v13)
        {
          switch((v6 >> 3))
          {
            case 1u:
              char v14 = 0;
              unsigned int v15 = 0;
              uint64_t v16 = 0LL;
              break;
            case 2u:
              unint64_t v21 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v21 <= 0xFFFFFFFFFFFFFFFBLL && v21 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                int v22 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v21);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v21 + 4;
              }

              else
              {
                *(_BYTE *)(a2 + v11) = 1;
                int v22 = 0;
              }

              uint64_t v30 = 16LL;
              goto LABEL_71;
            case 3u:
              unint64_t v23 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v23 <= 0xFFFFFFFFFFFFFFFBLL && v23 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                int v22 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v23);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v23 + 4;
              }

              else
              {
                *(_BYTE *)(a2 + v11) = 1;
                int v22 = 0;
              }

              uint64_t v30 = 40LL;
              goto LABEL_71;
            case 4u:
              unint64_t v24 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v24 <= 0xFFFFFFFFFFFFFFFBLL && v24 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                int v22 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v24);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v24 + 4;
              }

              else
              {
                *(_BYTE *)(a2 + v11) = 1;
                int v22 = 0;
              }

              uint64_t v30 = 36LL;
              goto LABEL_71;
            case 5u:
              unint64_t v25 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v25 <= 0xFFFFFFFFFFFFFFFBLL && v25 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                int v22 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v25);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v25 + 4;
              }

              else
              {
                *(_BYTE *)(a2 + v11) = 1;
                int v22 = 0;
              }

              uint64_t v30 = 8LL;
              goto LABEL_71;
            case 6u:
              unint64_t v26 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v26 <= 0xFFFFFFFFFFFFFFFBLL && v26 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                int v22 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v26);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v26 + 4;
              }

              else
              {
                *(_BYTE *)(a2 + v11) = 1;
                int v22 = 0;
              }

              uint64_t v30 = 24LL;
              goto LABEL_71;
            case 7u:
              unint64_t v27 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v27 <= 0xFFFFFFFFFFFFFFFBLL && v27 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                int v22 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v27);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v27 + 4;
              }

              else
              {
                *(_BYTE *)(a2 + v11) = 1;
                int v22 = 0;
              }

              uint64_t v30 = 20LL;
              goto LABEL_71;
            case 8u:
              unint64_t v28 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v28 <= 0xFFFFFFFFFFFFFFFBLL && v28 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                int v22 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v28);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v28 + 4;
              }

              else
              {
                *(_BYTE *)(a2 + v11) = 1;
                int v22 = 0;
              }

              uint64_t v30 = 28LL;
              goto LABEL_71;
            case 9u:
              unint64_t v29 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v29 <= 0xFFFFFFFFFFFFFFFBLL && v29 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                int v22 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v29);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v29 + 4;
              }

              else
              {
                *(_BYTE *)(a2 + v11) = 1;
                int v22 = 0;
              }

              uint64_t v30 = 32LL;
LABEL_71:
              *(_DWORD *)(a1 + v3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v22;
              goto LABEL_72;
            default:
              uint64_t result = PBReaderSkipValueWithTag(a2);
              if (!(_DWORD)result) {
                return result;
              }
LABEL_72:
              if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
                return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
              }
              continue;
          }

          while (1)
          {
            uint64_t v17 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v18 = v17 + 1;
            if (v17 == -1 || v18 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
              break;
            }
            char v19 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v17);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v18;
            v16 |= (unint64_t)(v19 & 0x7F) << v14;
            if ((v19 & 0x80) == 0) {
              goto LABEL_52;
            }
            v14 += 7;
            BOOL v10 = v15++ >= 9;
            if (v10)
            {
              LODWORD(v16) = 0;
              goto LABEL_54;
            }
          }

          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_52:
          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v16) = 0;
          }
LABEL_54:
          *(_DWORD *)(a1 + 12) = v16;
          goto LABEL_72;
        }
      }

      break;
    }
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

uint64_t sub_10025E204(uint64_t a1, int a2, char a3, char a4)
{
  uint64_t result = sub_1003070C0(a1, a2);
  *(void *)uint64_t result = off_10182CA10;
  *(_BYTE *)(result + 20sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = a3;
  *(_BYTE *)(result + 201) = a4;
  *(_BYTE *)(result + 202) = 0;
  *(void *)(result + 20std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(result + 216) = 0LL;
  return result;
}

uint64_t sub_10025E244(void *a1)
{
  *a1 = off_10182CA10;
  sub_10025E538((uint64_t)a1);
  sub_10000AE14((uint64_t)(a1 + 26));
  return sub_100307A9C((uint64_t)a1);
}

void sub_10025E284(void *a1)
{
  uint64_t v1 = (void *)sub_10025E244(a1);
  operator delete(v1);
}

void sub_10025E298(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 201))
  {
    BOOL v2 = sub_100CFE554(*(void *)(a1 + 208), 0LL);
    *(_BYTE *)(a1 + 202) = v2;
    if (v2)
    {
      if (qword_101934560 != -1) {
        dispatch_once(&qword_101934560, &stru_10182CA68);
      }
      double v3 = (os_log_s *)qword_101934568;
      if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v4 = sub_100719C6C(*(void *)(a1 + 208));
        *(_DWORD *)int buf = 134349056;
        uint64_t v11 = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Fast path has been initialized,serviceRef,%{public}p",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934560 != -1) {
          dispatch_once(&qword_101934560, &stru_10182CA68);
        }
        uint64_t v5 = qword_101934568;
        uint64_t v6 = sub_100719C6C(*(void *)(a1 + 208));
        int v8 = 134349056;
        uint64_t v9 = v6;
        uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v5,  0LL,  "Fast path has been initialized,serviceRef,%{public}p",  &v8,  12);
        sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLSensorFusionServiceSPU::start()", "%s\n", v7);
      }
    }
  }

void sub_10025E478(uint64_t a1, double *a2)
{
  uint64_t v5 = (uint64_t *)(a1 + 208);
  uint64_t v4 = *(void *)(a1 + 208);
  if (!v4)
  {
    int v6 = *(unsigned __int8 *)(a1 + 200);
    uint64_t v7 = (uint64_t *)sub_10071542C();
    v11[0] = 65292;
    v11[1] = v6;
    char v12 = 0;
    sub_10025E724(v7, (uint64_t)v11, (uint64_t *)&v13);
    sub_10005F550((uint64_t)v5, &v13);
    int v8 = (std::__shared_weak_count *)*((void *)&v13 + 1);
    if (*((void *)&v13 + 1))
    {
      uint64_t v9 = (unint64_t *)(*((void *)&v13 + 1) + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    uint64_t v4 = *v5;
  }

  sub_10071A73C(v4, *a2);
  sub_100719D78(*(uint64_t **)(a1 + 208), (uint64_t)sub_10025E7E4, a1);
}

void sub_10025E538(uint64_t a1)
{
  *(void *)int buf = 0LL;
  sub_10025E478(a1, (double *)buf);
  if (*(_BYTE *)(a1 + 202))
  {
    *(_BYTE *)(a1 + 202) = 0;
    sub_100CFE4EC(*(void *)(a1 + 208));
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_10182CA68);
    }
    BOOL v2 = (os_log_s *)qword_101934568;
    if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = sub_100719C6C(*(void *)(a1 + 208));
      *(_DWORD *)int buf = 134349056;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Fast path closed,serviceRef,%{public}p",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934560 != -1) {
        dispatch_once(&qword_101934560, &stru_10182CA68);
      }
      uint64_t v4 = qword_101934568;
      uint64_t v5 = sub_100719C6C(*(void *)(a1 + 208));
      int v7 = 134349056;
      uint64_t v8 = v5;
      int v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v4,  0LL,  "Fast path closed,serviceRef,%{public}p",  &v7,  12);
      sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLSensorFusionServiceSPU::stop()", "%s\n", v6);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

void sub_10025E714(uint64_t a1, void *a2)
{
  *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *a2;
  sub_10025E478(a1, (double *)(a1 + 40));
}

void sub_10025E724(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  __int128 v13 = a1;
  sub_10025F194((int *)a2, (int *)(a2 + 4), (char *)(a2 + 8), (uint64_t *)&v13, a3);
  uint64_t v5 = (std::__shared_weak_count *)a3[1];
  uint64_t v11 = *a3;
  char v12 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  sub_100715828(a1, &v11);
  uint64_t v8 = v12;
  if (v12)
  {
    uint64_t v9 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

void sub_10025E7C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10025E7E4(uint64_t a1, float32x4_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v8[0] = 0uLL;
  unint64_t v7 = 0xBFF0000000000000LL;
  sub_100833700(v8, a2);
  int v9 = 0;
  memset(&v8[1], 0, 32);
  __int128 v10 = xmmword_1012E2F40;
  uint64_t v11 = 0x1FF00000000LL;
  int v12 = 0;
  char v13 = 0;
  uint64_t v14 = 0LL;
}

void sub_10025E870(uint64_t a1, uint64_t a2, float32x4_t a3)
{
  uint64_t v5 = *(void *)(a1 + 208);
  if (v5)
  {
    if (*(_BYTE *)(a1 + 202) && (uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32LL))(v5)) != 0)
    {
      uint64_t v8 = (const void *)v6;
      sub_10025E950(v6, 0, a2, v7);
      CFRelease(v8);
    }

    else
    {
      sub_100307C7C(a1, a2);
    }
  }

  else
  {
    *(void *)a2 = 0xBFF0000000000000LL;
    int v9 = (float32x4_t *)(a2 + 8);
    float32x4_t v10 = 0uLL;
    sub_100833700(&v10, a3);
    if (v9 != &v10) {
      *int v9 = v10;
    }
    *(void *)(a2 + 24) = 0LL;
    *(_DWORD *)(a2 + 32) = 0;
    *(void *)(a2 + 96) = 0LL;
    *(void *)(a2 + 36) = 0LL;
    *(void *)(a2 + 52) = 0LL;
    *(void *)(a2 + 44) = 0LL;
    *(void *)(a2 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
    *(_BYTE *)(a2 + 8std::istream::~istream(v2, v3 + 8) = 0;
  }

BOOL sub_10025E950(uint64_t a1, int a2, uint64_t a3, float32x4_t a4)
{
  *(void *)a3 = 0xBFF0000000000000LL;
  float32x4_t v7 = (_BYTE *)(a3 + 8);
  *(void *)int buf = 0LL;
  *(void *)&uint8_t buf[8] = 0LL;
  sub_100833700((float32x4_t *)buf, a4);
  if (v7 != buf) {
    *(_OWORD *)float32x4_t v7 = *(_OWORD *)buf;
  }
  *(void *)(a3 + 96) = 0LL;
  *(_OWORD *)(a3 + 24) = 0u;
  *(_OWORD *)(a3 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0u;
  *(_DWORD *)(a3 + 56) = 0;
  *(void *)(a3 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  *(_BYTE *)(a3 + 8std::istream::~istream(v2, v3 + 8) = 0;
  if (!a1)
  {
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_10182CA68);
    }
    int v12 = (os_log_s *)qword_101934568;
    if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "#Warning Device motion event ref invalid",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_10182CA68);
    }
    LOWORD(__dst) = 0;
    uint64_t v14 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934568,  1LL,  "#Warning Device motion event ref invalid",  &__dst,  2);
LABEL_30:
    uint64_t v16 = (_BYTE *)v14;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLSensorFusionServiceSPU::populateDeviceMotion(IOHIDEventRef, uint32_t, CLSensorFusionService::Sample &)",  "%s\n");
    goto LABEL_31;
  }

  int64_t v61 = 0LL;
  __int128 v62 = 0LL;
  IOHIDEventGetVendorDefinedData(a1, &v62, &v61);
  if (!v62 || v61 <= 0)
  {
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_10182CA68);
    }
    unsigned int v15 = (os_log_s *)qword_101934568;
    if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)int buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "Empty payload, returning", buf, 2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_10182CA68);
    }
    LOWORD(__dst) = 0;
    uint64_t v14 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934568,  1LL,  "Empty payload, returning",  &__dst,  2);
    goto LABEL_30;
  }

  unint64_t TimeStamp = IOHIDEventGetTimeStamp(a1);
  double v9 = sub_101171C7C(TimeStamp);
  sub_100313710(&__dst, v62, v61);
  if (__dst <= 3u)
  {
    if (__dst == 2)
    {
      if (a2 && v48 != a2) {
        return 0LL;
      }
      *(float32x4_t *)int buf = v50;
      sub_100833700((float32x4_t *)buf, v50);
      float v23 = v49.f32[3] - v58;
      float32x2_t v44 = vsub_f32(*(float32x2_t *)&v49.i32[1], v57);
      float32x2_t v45 = v44;
      float v46 = v49.f32[3] - v58;
      float v24 = sub_100833470((float *)buf);
      uint64_t v26 = 0LL;
      float v27 = 0.0;
      do
      {
        float v27 = v27 + (float)(v45.f32[v26] * v45.f32[v26]);
        ++v26;
      }

      while (v26 != 3);
      float v28 = sqrtf(v27);
      _V4.S[1] = v44.i32[1];
      __asm { FMLA            S2, S1, V4.S[1] }

      float v35 = vmlas_n_f32(_S2, v24, v44.f32[0]);
      float v36 = v28 * sqrtf(1.0 - (float)((float)(v35 / v28) * (float)(v35 / v28)));
      uint64_t v37 = sub_1007492FC();
      sub_10071DE3C(v37, v56, fabsf(v36));
      int v39 = v38;
      *(double *)a3 = v9;
      *(float32x4_t *)uint64_t v63 = v50;
      sub_100833700((float32x4_t *)v63, v50);
      if (v7 != v63) {
        *(_OWORD *)float32x4_t v7 = *(_OWORD *)v63;
      }
      *(void *)&__int128 v40 = v54;
      *((void *)&v40 + 1) = v51;
      int v41 = v52;
      *(_DWORD *)(a3 + 24) = v53;
      *(_OWORD *)(a3 + 2std::istream::~istream(v2, v3 + 8) = v40;
      *(_DWORD *)(a3 + 44) = v41;
      *(float32x2_t *)(a3 + 4std::istream::~istream(v2, v3 + 8) = v44;
      *(_BYTE *)(a3 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = BYTE1(__dst);
      LODWORD(v4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v55;
      *(float *)(a3 + 56) = v23;
      *(_DWORD *)(a3 + 6sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v40;
      *(_DWORD *)(a3 + 64) = v39;
      *(void *)(a3 + 6std::istream::~istream(v2, v3 + 8) = v59;
      *(_DWORD *)(a3 + 76) = v60;
      *(_BYTE *)(a3 + 81) = 2;
      *(_WORD *)(a3 + 82) = HIWORD(__dst);
      *(_DWORD *)(a3 + 84) = 15;
      *(void *)(a3 + 96) = v48;
      BOOL result = 1LL;
      *(_BYTE *)(a3 + 8std::istream::~istream(v2, v3 + 8) = 0;
      return result;
    }

    if (__dst == 3)
    {
      if (!a2 || v48 == a2)
      {
        *(double *)a3 = v9;
        *(float32x4_t *)int buf = v49;
        sub_100833700((float32x4_t *)buf, v49);
        if (v7 != buf) {
          *(_OWORD *)float32x4_t v7 = *(_OWORD *)buf;
        }
        *(void *)&__int128 v10 = v51;
        *((void *)&v10 + 1) = v50.i64[0];
        __int32 v11 = v50.i32[2];
        *(_DWORD *)(a3 + 24) = v50.i32[3];
        *(_OWORD *)(a3 + 2std::istream::~istream(v2, v3 + 8) = v10;
        *(_DWORD *)(a3 + 44) = v11;
        *(_WORD *)(a3 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 511;
        *(_OWORD *)(a3 + 4std::istream::~istream(v2, v3 + 8) = xmmword_1012E2F50;
        *(_DWORD *)(a3 + 64) = -1082130432;
        *(_WORD *)(a3 + 82) = *(_WORD *)((char *)&__dst + 1);
        *(_DWORD *)(a3 + 84) = 3;
        *(void *)(a3 + 96) = v48;
        *(_BYTE *)(a3 + 8std::istream::~istream(v2, v3 + 8) = 0;
        return 1LL;
      }

      return 0LL;
    }

    goto LABEL_44;
  }

  if (__dst == 4)
  {
    *(double *)a3 = v9;
    *(float32x4_t *)int buf = v49;
    sub_100833700((float32x4_t *)buf, v49);
    if (v7 != buf) {
      *(_OWORD *)float32x4_t v7 = *(_OWORD *)buf;
    }
    *(void *)&__int128 v18 = v51;
    __int32 v19 = v50.i32[2];
    *((void *)&v18 + 1) = v50.i64[0];
    *(_DWORD *)(a3 + 24) = v50.i32[3];
    *(_OWORD *)(a3 + 2std::istream::~istream(v2, v3 + 8) = v18;
    *(_DWORD *)(a3 + 44) = v19;
    *(_DWORD *)(a3 + 84) = 2;
    return 1LL;
  }

  if (__dst != 255)
  {
LABEL_44:
    if (qword_101934560 != -1) {
      dispatch_once(&qword_101934560, &stru_10182CA68);
    }
    int64_t v20 = (os_log_s *)qword_101934568;
    if (os_log_type_enabled((os_log_t)qword_101934568, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = __dst;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_FAULT,  "Unexpected device motion report type %{public}d, returning",  buf,  8u);
    }

    BOOL v21 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v21)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934560 != -1) {
        dispatch_once(&qword_101934560, &stru_10182CA68);
      }
      *(_DWORD *)uint64_t v63 = 67240192;
      *(_DWORD *)&v63[4] = __dst;
      uint64_t v22 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934568,  17LL,  "Unexpected device motion report type %{public}d, returning",  v63,  8);
LABEL_67:
      uint64_t v16 = (_BYTE *)v22;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLSensorFusionServiceSPU::populateDeviceMotion(IOHIDEventRef, uint32_t, CLSensorFusionService::Sample &)",  "%s\n");
LABEL_31:
      if (v16 != buf) {
        free(v16);
      }
      return 0LL;
    }

    return result;
  }

  if (v61 < 1) {
    int v17 = 0;
  }
  else {
    int v17 = *v62;
  }
  if (qword_1019344C0 != -1) {
    dispatch_once(&qword_1019344C0, &stru_10182CA88);
  }
  uint64_t v42 = (os_log_s *)qword_1019344C8;
  if (os_log_type_enabled((os_log_t)qword_1019344C8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)int buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = v17;
    *(_WORD *)&uint8_t buf[8] = 2048;
    *(void *)&buf[10] = v61;
    _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_FAULT,  "Bad device motion report,type,%d,size,%lu",  buf,  0x12u);
  }

  BOOL v43 = sub_1002921D0(115, 0);
  BOOL result = 0LL;
  if (v43)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_10182CA88);
    }
    *(_DWORD *)uint64_t v63 = 67109376;
    *(_DWORD *)&v63[4] = v17;
    *(_WORD *)&v63[8] = 2048;
    *(void *)&v63[10] = v61;
    uint64_t v22 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344C8,  17LL,  "Bad device motion report,type,%d,size,%lu",  v63,  18);
    goto LABEL_67;
  }

  return result;
}

void sub_10025F13C(id a1)
{
  qword_101934568 = (uint64_t)os_log_create("com.apple.locationd.Motion", "DeviceMotion");
}

void sub_10025F168(id a1)
{
  qword_1019344C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "AOP");
}

void *sub_10025F194@<X0>(int *a1@<X1>, int *a2@<X2>, char *a3@<X3>, uint64_t *a4@<X4>, void *a5@<X8>)
{
  __int128 v10 = operator new(0xC8uLL);
  BOOL result = sub_10025F20C(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  return result;
}

void sub_10025F1F8(_Unwind_Exception *a1)
{
}

void *sub_10025F20C(void *a1, int *a2, int *a3, char *a4, uint64_t *a5)
{
  a1[2] = 0LL;
  *a1 = off_10182CAB8;
  a1[1] = 0LL;
  sub_100CFE490((uint64_t)(a1 + 3), *a2, *a3, *a4, *a5);
  return a1;
}

void sub_10025F254(_Unwind_Exception *a1)
{
}

void sub_10025F268(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182CAB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10025F27C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182CAB8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10025F2A0(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t sub_10026085C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    uint64_t v4 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    uint64_t v5 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    uint64_t v6 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    float32x4_t v7 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    uint64_t v8 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    double v9 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    __int128 v10 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    __int32 v11 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    int v12 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    char v13 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    uint64_t v14 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    unsigned int v15 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
    do
    {
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        break;
      }
      char v16 = 0;
      unsigned int v17 = 0;
      unint64_t v18 = 0LL;
      while (1)
      {
        uint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        unint64_t v20 = v19 + 1;
        if (v19 == -1 || v20 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v21 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v20;
        v18 |= (unint64_t)(v21 & 0x7F) << v16;
        if ((v21 & 0x80) == 0) {
          goto LABEL_12;
        }
        v16 += 7;
        BOOL v22 = v17++ >= 9;
        if (v22)
        {
          unint64_t v18 = 0LL;
          uint64_t v23 = OBJC_IVAR___PBDataReader__error;
          int v24 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_12:
      uint64_t v23 = OBJC_IVAR___PBDataReader__error;
      int v24 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        unint64_t v18 = 0LL;
      }
LABEL_14:
      if (v24 || (v18 & 7) == 4) {
        break;
      }
      switch((v18 >> 3))
      {
        case 1u:
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0LL;
          while (1)
          {
            uint64_t v29 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v30 = v29 + 1;
            if (v29 == -1 || v30 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
              break;
            }
            char v31 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v29);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v30;
            v28 |= (unint64_t)(v31 & 0x7F) << v26;
            if ((v31 & 0x80) == 0) {
              goto LABEL_83;
            }
            v26 += 7;
            BOOL v22 = v27++ >= 9;
            if (v22)
            {
              LODWORD(v2std::istream::~istream(v2, v3 + 8) = 0;
              goto LABEL_85;
            }
          }

          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_83:
          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v2std::istream::~istream(v2, v3 + 8) = 0;
          }
LABEL_85:
          uint64_t v77 = *((int *)v4 + 525);
          goto LABEL_106;
        case 2u:
          char v39 = 0;
          unsigned int v40 = 0;
          uint64_t v28 = 0LL;
          *(_WORD *)(a1 + *((int *)v5 + 515)) |= 4u;
          while (2)
          {
            uint64_t v41 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v42 = v41 + 1;
            if (v41 == -1 || v42 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v43 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v41);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v42;
              v28 |= (unint64_t)(v43 & 0x7F) << v39;
              if (v43 < 0)
              {
                v39 += 7;
                BOOL v22 = v40++ >= 9;
                if (v22)
                {
                  LODWORD(v2std::istream::~istream(v2, v3 + 8) = 0;
                  goto LABEL_89;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v2std::istream::~istream(v2, v3 + 8) = 0;
          }
LABEL_89:
          uint64_t v77 = *((int *)v6 + 516);
          goto LABEL_106;
        case 3u:
          char v44 = 0;
          unsigned int v45 = 0;
          uint64_t v28 = 0LL;
          *(_WORD *)(a1 + *((int *)v5 + 515)) |= 0x20u;
          while (2)
          {
            uint64_t v46 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v47 = v46 + 1;
            if (v46 == -1 || v47 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v48 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v46);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v47;
              v28 |= (unint64_t)(v48 & 0x7F) << v44;
              if (v48 < 0)
              {
                v44 += 7;
                BOOL v22 = v45++ >= 9;
                if (v22)
                {
                  LODWORD(v2std::istream::~istream(v2, v3 + 8) = 0;
                  goto LABEL_93;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v2std::istream::~istream(v2, v3 + 8) = 0;
          }
LABEL_93:
          uint64_t v77 = *((int *)v7 + 517);
          goto LABEL_106;
        case 4u:
          char v49 = 0;
          unsigned int v50 = 0;
          uint64_t v28 = 0LL;
          *(_WORD *)(a1 + *((int *)v5 + 515)) |= 0x10u;
          while (2)
          {
            uint64_t v51 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v52 = v51 + 1;
            if (v51 == -1 || v52 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v53 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v51);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v52;
              v28 |= (unint64_t)(v53 & 0x7F) << v49;
              if (v53 < 0)
              {
                v49 += 7;
                BOOL v22 = v50++ >= 9;
                if (v22)
                {
                  LODWORD(v2std::istream::~istream(v2, v3 + 8) = 0;
                  goto LABEL_97;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v2std::istream::~istream(v2, v3 + 8) = 0;
          }
LABEL_97:
          uint64_t v77 = *((int *)v8 + 518);
          goto LABEL_106;
        case 5u:
          char v54 = 0;
          unsigned int v55 = 0;
          uint64_t v56 = 0LL;
          *(_WORD *)(a1 + *((int *)v5 + 515)) |= 0x80u;
          while (2)
          {
            uint64_t v57 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v58 = v57 + 1;
            if (v57 == -1 || v58 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v59 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v57);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v58;
              v56 |= (unint64_t)(v59 & 0x7F) << v54;
              if (v59 < 0)
              {
                v54 += 7;
                BOOL v22 = v55++ >= 9;
                if (v22)
                {
                  uint64_t v56 = 0LL;
                  goto LABEL_101;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v56 = 0LL;
          }
LABEL_101:
          BOOL v78 = v56 != 0;
          uint64_t v79 = *((int *)v9 + 519);
          goto LABEL_111;
        case 6u:
          *(_WORD *)(a1 + *((int *)v5 + 515)) |= 0x40u;
          unint64_t v60 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v60 <= 0xFFFFFFFFFFFFFFFBLL && v60 + 4 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            int v61 = *(_DWORD *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v60);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v60 + 4;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            int v61 = 0;
          }

          *(_DWORD *)(a1 + *((int *)v10 + 520)) = v61;
          continue;
        case 7u:
          unint64_t v62 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v62 <= 0xFFFFFFFFFFFFFFF7LL && v62 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v63 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v62);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v62 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + v23) = 1;
            uint64_t v63 = 0LL;
          }

          uint64_t v80 = *((int *)v11 + 526);
          goto LABEL_120;
        case 8u:
          char v64 = 0;
          unsigned int v65 = 0;
          uint64_t v28 = 0LL;
          *(_WORD *)(a1 + *((int *)v5 + 515)) |= 8u;
          while (2)
          {
            uint64_t v66 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            unint64_t v67 = v66 + 1;
            if (v66 == -1 || v67 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v68 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v66);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v67;
              v28 |= (unint64_t)(v68 & 0x7F) << v64;
              if (v68 < 0)
              {
                v64 += 7;
                BOOL v22 = v65++ >= 9;
                if (v22)
                {
                  LODWORD(v2std::istream::~istream(v2, v3 + 8) = 0;
                  goto LABEL_105;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            LODWORD(v2std::istream::~istream(v2, v3 + 8) = 0;
          }
LABEL_105:
          uint64_t v77 = *((int *)v12 + 521);
LABEL_106:
          *(_DWORD *)(a1 + v77) = v28;
          continue;
        case 9u:
          *(_WORD *)(a1 + *((int *)v5 + 515)) |= 1u;
          unint64_t v69 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v69 <= 0xFFFFFFFFFFFFFFF7LL && v69 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v63 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v69);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v69 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v63 = 0LL;
          }

          uint64_t v80 = *((int *)v13 + 522);
          goto LABEL_120;
        case 0xAu:
          *(_WORD *)(a1 + *((int *)v5 + 515)) |= 2u;
          unint64_t v70 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v70 <= 0xFFFFFFFFFFFFFFF7LL && v70 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            uint64_t v63 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v70);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v70 + 8;
          }

          else
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            uint64_t v63 = 0LL;
          }

          uint64_t v80 = *((int *)v14 + 523);
LABEL_120:
          *(void *)(a1 + v8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v63;
          continue;
        case 0xBu:
          char v71 = 0;
          unsigned int v72 = 0;
          uint64_t v73 = 0LL;
          *(_WORD *)(a1 + *((int *)v5 + 515)) |= 0x100u;
          break;
        default:
          uint64_t v32 = v4;
          unint64_t v33 = v6;
          uint64_t v34 = v5;
          float v35 = v7;
          float v36 = v8;
          uint64_t v37 = a1;
          uint64_t result = PBReaderSkipValueWithTag(a2);
          unsigned int v15 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          a1 = v37;
          double v9 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          uint64_t v8 = v36;
          __int128 v10 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          float32x4_t v7 = v35;
          __int32 v11 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          uint64_t v5 = v34;
          uint64_t v14 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          uint64_t v6 = v33;
          char v13 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          uint64_t v4 = v32;
          int v12 = &selRef_resetClientForBundleId_orBundlePath_withReplyBlock_;
          if (!(_DWORD)result) {
            return result;
          }
          continue;
      }

      while (1)
      {
        uint64_t v74 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        unint64_t v75 = v74 + 1;
        if (v74 == -1 || v75 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v76 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v74);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v75;
        v73 |= (unint64_t)(v76 & 0x7F) << v71;
        if ((v76 & 0x80) == 0) {
          goto LABEL_108;
        }
        v71 += 7;
        BOOL v22 = v72++ >= 9;
        if (v22)
        {
          uint64_t v73 = 0LL;
          goto LABEL_110;
        }
      }

      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_108:
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v73 = 0LL;
      }
LABEL_110:
      BOOL v78 = v73 != 0;
      uint64_t v79 = *((int *)v15 + 524);
LABEL_111:
      *(_BYTE *)(a1 + v79) = v78;
    }

    while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length));
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

uint64_t sub_100261E44(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0LL;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      break;
    }
    if ((v6 >> 3) == 2)
    {
      unsigned int v17 = objc_alloc_init(&OBJC_CLASS___ALCLMotionActivity);

      *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v17;
      PBReaderRecallMark(a2, v19);
    }

    else if ((v6 >> 3) == 1)
    {
      char v12 = 0;
      unsigned int v13 = 0;
      uint64_t v14 = 0LL;
      while (1)
      {
        unint64_t v15 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v15 == -1LL || v15 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v16 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v15);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v15 + 1;
        v14 |= (unint64_t)(v16 & 0x7F) << v12;
        if ((v16 & 0x80) == 0) {
          goto LABEL_32;
        }
        v12 += 7;
        BOOL v9 = v13++ >= 9;
        if (v9)
        {
          LODWORD(v14) = 0;
          goto LABEL_34;
        }
      }

      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_32:
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v14) = 0;
      }
LABEL_34:
      *(_DWORD *)(a1 + 16) = v14;
    }

    else
    {
      uint64_t result = PBReaderSkipValueWithTag(a2);
      if (!(_DWORD)result) {
        return result;
      }
    }
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

uint64_t sub_100262B98(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      if (v5++ >= 9)
      {
        unint64_t v6 = 0LL;
        uint64_t v11 = OBJC_IVAR___PBDataReader__error;
        int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    uint64_t v11 = OBJC_IVAR___PBDataReader__error;
    int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v12 || (v6 & 7) == 4) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    switch((v6 >> 3))
    {
      case 1u:
        unint64_t v14 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v14 <= 0xFFFFFFFFFFFFFFF7LL && v14 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v15 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v14);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v14 + 8;
        }

        else
        {
          *(_BYTE *)(a2 + v11) = 1;
          uint64_t v15 = 0LL;
        }

        *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v15;
        goto LABEL_101;
      case 2u:
        char v16 = objc_alloc_init(&OBJC_CLASS___ALActivityOverrideMsg);

        *(void *)(a1 + 16) = v16;
        goto LABEL_100;
      case 3u:
        unsigned int v17 = objc_alloc_init(&OBJC_CLASS___ALCLBodyMetrics);

        *(void *)(a1 + 32) = v17;
        goto LABEL_100;
      case 4u:
        unint64_t v18 = objc_alloc_init(&OBJC_CLASS___ALMotionState);

        *(void *)(a1 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v18;
        goto LABEL_100;
      case 5u:
        uint64_t v19 = objc_alloc_init(&OBJC_CLASS___ALCLNatalieDataDeprecated);

        *(void *)(a1 + 12std::istream::~istream(v2, v3 + 8) = v19;
        goto LABEL_100;
      case 6u:
        unint64_t v30 = objc_alloc_init(&OBJC_CLASS___ALCLSedentaryAlarmDataDeprecated);

        *(void *)(a1 + 16sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v30;
        goto LABEL_100;
      case 7u:
        char v31 = objc_alloc_init(&OBJC_CLASS___ALCLStepCountEntry);

        *(void *)(a1 + 184) = v31;
        goto LABEL_100;
      case 8u:
        unint64_t v20 = objc_alloc_init(&OBJC_CLASS___ALCLStrideCalEntryDeprecated);

        *(void *)(a1 + 20sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v20;
        goto LABEL_100;
      case 9u:
        uint64_t v32 = objc_alloc_init(&OBJC_CLASS___ALCLSessionCatherine);

        *(void *)(a1 + 16std::istream::~istream(v2, v3 + 8) = v32;
        goto LABEL_100;
      case 0xAu:
        char v21 = objc_alloc_init(&OBJC_CLASS___ALCLJacksonData);

        *(void *)(a1 + 112) = v21;
        goto LABEL_100;
      case 0xBu:
        unint64_t v33 = objc_alloc_init(&OBJC_CLASS___ALCLStrideCalEntry);

        *(void *)(a1 + 192) = v33;
        goto LABEL_100;
      case 0xCu:
        BOOL v22 = objc_alloc_init(&OBJC_CLASS___ALCLSedentaryAlarmData);

        *(void *)(a1 + 152) = v22;
        goto LABEL_100;
      case 0xDu:
        uint64_t v23 = objc_alloc_init(&OBJC_CLASS___ALCLAllDayHeartRate);

        *(void *)(a1 + 24) = v23;
        goto LABEL_100;
      case 0xEu:
        uint64_t v34 = objc_alloc_init(&OBJC_CLASS___ALCMCalorieDataDeprecated);

        *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v34;
        goto LABEL_100;
      case 0xFu:
        int v24 = objc_alloc_init(&OBJC_CLASS___ALCMCoarseElevationDeprecated);

        *(void *)(a1 + 64) = v24;
        goto LABEL_100;
      case 0x10u:
        unint64_t v25 = objc_alloc_init(&OBJC_CLASS___ALCMFitnessTracking);

        *(void *)(a1 + 96) = v25;
        goto LABEL_100;
      case 0x11u:
        char v26 = objc_alloc_init(&OBJC_CLASS___ALCLOdometer);

        *(void *)(a1 + 136) = v26;
        goto LABEL_100;
      case 0x12u:
        float v35 = objc_alloc_init(&OBJC_CLASS___ALCLElevationDeprecated);

        *(void *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v35;
        goto LABEL_100;
      case 0x13u:
        float v36 = objc_alloc_init(&OBJC_CLASS___ALCLIDSStatus);

        *(void *)(a1 + 104) = v36;
        goto LABEL_100;
      case 0x14u:
        uint64_t v37 = objc_alloc_init(&OBJC_CLASS___ALCLStairClimbingModel);

        *(void *)(a1 + 176) = v37;
        goto LABEL_100;
      case 0x15u:
        int v38 = objc_alloc_init(&OBJC_CLASS___ALCLRowingModel);

        *(void *)(a1 + 144) = v38;
        goto LABEL_100;
      case 0x16u:
        char v39 = objc_alloc_init(&OBJC_CLASS___ALCMExerciseMinute);

        *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = v39;
        goto LABEL_100;
      case 0x17u:
        unsigned int v40 = objc_alloc_init(&OBJC_CLASS___ALCMWorkoutEventDeprecated);

        *(void *)(a1 + 216) = v40;
        goto LABEL_100;
      case 0x18u:
        uint64_t v41 = objc_alloc_init(&OBJC_CLASS___ALCMElevation);

        *(void *)(a1 + 72) = v41;
        goto LABEL_100;
      case 0x19u:
        unsigned int v27 = objc_alloc_init(&OBJC_CLASS___ALCMCoarseElevation);

        *(void *)(a1 + 56) = v27;
        goto LABEL_100;
      case 0x1Au:
        uint64_t v28 = objc_alloc_init(&OBJC_CLASS___ALCMCalorieData);

        *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v28;
        goto LABEL_100;
      case 0x1Bu:
        unint64_t v42 = objc_alloc_init(&OBJC_CLASS___ALCMWorkoutEvent);

        *(void *)(a1 + 20std::istream::~istream(v2, v3 + 8) = v42;
        if (PBReaderPlaceMark(a2, v43) && (sub_100FA5A40((uint64_t)v42, a2) & 1) != 0)
        {
LABEL_100:
          PBReaderRecallMark(a2, v43);
LABEL_101:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }

        return 0LL;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_101;
    }
  }

void *sub_100264C84(void *a1, void *a2)
{
  *a1 = a2;
  a1[1] = 0LL;
  uint64_t v3 = operator new(0x30uLL);
  sub_1009859D4(v3, 1048320LL, a1);
  sub_1002659F8(a1 + 2, (uint64_t)v3);
  sub_1002E4C3C(a1 + 4, "ActLogger", 1LL, 1LL);
  char v4 = (NSData *)CFPreferencesCopyValue( @"MsgEnableBitMask",  @"com.apple.locationd",  @"mobile",  kCFPreferencesAnyHost);
  unsigned int v5 = v4;
  if (v4)
  {
    unint64_t v6 = v4;
  }

  else
  {
    *(void *)&__int128 v7 = -1LL;
    *((void *)&v7 + 1) = -1LL;
    *(_OWORD *)int buf = v7;
    __int128 v44 = v7;
    unsigned int v5 = +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 32LL);
  }

  unint64_t v8 = +[NSMutableString stringWithCapacity:]( &OBJC_CLASS___NSMutableString,  "stringWithCapacity:",  2 * -[NSData length](v5, "length"));
  char v9 = -[NSData bytes](v5, "bytes");
  for (unint64_t i = 0LL; i < -[NSData length](v5, "length"); ++i)
    -[NSMutableString appendFormat:](v8, "appendFormat:", @"%02x", v9[i]);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182CB40);
  }
  uint64_t v11 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    id v12 = -[NSMutableString UTF8String](v8, "UTF8String");
    *(_DWORD *)int buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "MsgEnabledBitMask is %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182CB40);
    }
    uint64_t v37 = qword_101934A78;
    LODWORD(v42) = 136315138;
    *(void *)((char *)&v42 + 4) = -[NSMutableString UTF8String](v8, "UTF8String");
    int v38 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v37,  2LL,  "MsgEnabledBitMask is %s",  (const char *)&v42);
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLActivityLoggerWriter::CLActivityLoggerWriter(NSString *)", "%s\n", v38);
  }

  unsigned int v13 = operator new(0x20uLL);
  sub_100E03114(v13, v5);
  sub_100265AD0(&v42, (uint64_t)v13);
  unint64_t v14 = (NSData *)CFPreferencesCopyValue( @"MsgRateMask",  @"com.apple.locationd",  @"mobile",  kCFPreferencesAnyHost);
  uint64_t v15 = v14;
  if (v14)
  {
    char v16 = v14;
  }

  else
  {
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    *(_OWORD *)int buf = 0u;
    __int128 v44 = 0u;
    uint64_t v15 = +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", buf, 128LL);
  }

  unsigned int v17 = operator new(0x38uLL);
  sub_100DE4F4C(v17, v15);
  sub_100265B90(buf, (uint64_t)v17);
  uint64_t v18 = v42;
  uint64_t v40 = *(void *)buf;
  uint64_t v41 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    uint64_t v19 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }

  sub_1000F2F30((void *)(v18 + 8), &v40);
  char v21 = v41;
  if (v41)
  {
    p_shared_owners = (unint64_t *)&v41->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(p_shared_owners);
    while (__stlxr(v23 - 1, p_shared_owners));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  uint64_t v24 = a1[2];
  __int128 v39 = v42;
  if (*((void *)&v42 + 1))
  {
    unint64_t v25 = (unint64_t *)(*((void *)&v42 + 1) + 8LL);
    do
      unint64_t v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }

  sub_1000F2F30((void *)(v24 + 8), (uint64_t *)&v39);
  unsigned int v27 = (std::__shared_weak_count *)*((void *)&v39 + 1);
  if (*((void *)&v39 + 1))
  {
    uint64_t v28 = (unint64_t *)(*((void *)&v39 + 1) + 8LL);
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

  unint64_t v30 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    char v31 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }

  unint64_t v33 = (std::__shared_weak_count *)*((void *)&v42 + 1);
  if (*((void *)&v42 + 1))
  {
    uint64_t v34 = (unint64_t *)(*((void *)&v42 + 1) + 8LL);
    do
      unint64_t v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }

  return a1;
}

void sub_100265148(_Unwind_Exception *a1)
{
}

BOOL sub_1002651D8(void *a1)
{
  uint64_t v2 = a1 + 4;
  (*(void (**)(void *))(a1[4] + 16LL))(a1 + 4);
  if (!-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  *a1)) {
    -[NSFileManager createFileAtPath:contents:attributes:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "createFileAtPath:contents:attributes:",  *a1,  0LL,  0LL);
  }
  uint64_t v3 = (void *)a1[1];
  if (v3)
  {
    [v3 closeFile];
  }

  char v4 = +[NSFileHandle fileHandleForWritingAtPath:](&OBJC_CLASS___NSFileHandle, "fileHandleForWritingAtPath:", *a1);
  unsigned int v5 = v4;
  a1[1] = v4;
  if (v4)
  {
    -[NSFileHandle seekToEndOfFile](v4, "seekToEndOfFile");
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182CB40);
    }
    unint64_t v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      id v7 = [(id)*a1 UTF8String];
      uint64_t v8 = a1[1];
      *(_DWORD *)int buf = 136315394;
      id v19 = v7;
      __int16 v20 = 2048;
      uint64_t v21 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "CLActivityLoggerWriter open log file filePath is %s, file is %p.",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182CB40);
      }
      uint64_t v10 = qword_101934A78;
      id v11 = [(id)*a1 UTF8String];
      uint64_t v12 = a1[1];
      int v14 = 136315394;
      id v15 = v11;
      __int16 v16 = 2048;
      uint64_t v17 = v12;
      unsigned int v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  2LL,  "CLActivityLoggerWriter open log file filePath is %s, file is %p.",  (const char *)&v14,  22);
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLActivityLoggerWriter::open()", "%s\n", v13);
    }
  }

  (*(void (**)(void *))(*v2 + 24LL))(v2);
  return v5 != 0LL;
}

void sub_100265460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

id sub_100265490(uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  (*(void (**)(uint64_t))(*(void *)(a1 + 32) + 16LL))(a1 + 32);
  id v2 = [*(id *)(v1 - 24) offsetInFile];
  (*(void (**)(uint64_t))(*(void *)v1 + 24LL))(v1);
  return v2;
}

void sub_1002654F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100265508(void *a1, void *a2)
{
  uint64_t v4 = a1[4];
  unsigned int v13 = a1 + 4;
  (*(void (**)(void))(v4 + 16))();
  __int16 v15 = 256;
  if (-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  *a1)
    && a1[1]
    || sub_1002651D8(a1))
  {
    id v5 = [a2 data];
    unsigned __int16 v6 = (unsigned __int16)[v5 length];
    unsigned __int16 v12 = v6;
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182CB40);
    }
    id v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 67109120;
      int v18 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "CLActivityLoggerWriter logData, prepare to log %d bytes",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182CB40);
      }
      v16[0] = 67109120;
      v16[1] = v12;
      id v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "CLActivityLoggerWriter logData, prepare to log %d bytes",  v16);
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLActivityLoggerWriter::logData(PBCodable *)", "%s\n", v11);
    }

    uint64_t v8 = a1[2];
    while (1)
    {
      uint64_t v9 = (**(uint64_t (***)(uint64_t, id))v8)(v8, v5);
      if (!(_DWORD)v9) {
        break;
      }
      uint64_t v8 = *(void *)(v8 + 8);
      if (!v8)
      {
        objc_msgSend( (id)a1[1],  "writeData:",  +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v12, 2));
        [(id)a1[1] writeData:v5];
        break;
      }
    }
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  if ((_BYTE)v15) {
    pthread_mutex_unlock(v14);
  }
  else {
    (*(void (**)(void *))(*v13 + 24LL))(v13);
  }
  return v9;
}

void sub_1002657A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

id *sub_10026597C(id *a1)
{
  sub_1002E4CB0(a1 + 4);
  sub_10000AE14((uint64_t)(a1 + 2));
  return a1;
}

void sub_1002659CC(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void *sub_1002659F8(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &off_10182CB70;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  void v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100265A40(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100265A64(std::__shared_weak_count *a1)
{
}

uint64_t sub_100265A78(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 16LL))(result);
  }
  return result;
}

uint64_t sub_100265A90(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *sub_100265AD0(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &off_10182CBE8;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  void v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100265B18(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100265B38(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 16LL))(result);
  }
  return result;
}

uint64_t sub_100265B50(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *sub_100265B90(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &off_10182CC60;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  void v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100265BD8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 16LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100265BF8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 16LL))(result);
  }
  return result;
}

uint64_t sub_100265C10(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

uint64_t sub_100265C50(uint64_t a1)
{
  uint64_t v1 = a1 + 56;
  if (!*(void *)(a1 + 56))
  {
    sub_1006666AC((uint64_t)sub_100265CD4, a1, *(void **)(a1 + 8), &v7);
    uint64_t v3 = v7;
    uint64_t v7 = 0LL;
    uint64_t v4 = *(void *)(a1 + 56);
    *(void *)(a1 + 56) = v3;
    if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
      uint64_t v5 = v7;
      uint64_t v7 = 0LL;
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
      }
    }
  }

  return v1;
}

void sub_100265CD4(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182CD58);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFenceSubscription::onFenceNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182CD58);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFenceSubscription::onFenceNotification, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_10026EF6C(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100265E8C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100265EAC(uint64_t a1)
{
  uint64_t v1 = a1 + 48;
  if (!*(void *)(a1 + 48))
  {
    sub_100E91C44((uint64_t)sub_100265F30, a1, *(void **)(a1 + 8), &v7);
    uint64_t v3 = v7;
    uint64_t v7 = 0LL;
    uint64_t v4 = *(void *)(a1 + 48);
    *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v3;
    if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
      uint64_t v5 = v7;
      uint64_t v7 = 0LL;
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
      }
    }
  }

  return v1;
}

void sub_100265F30(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182CD58);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLFenceSubscription::onBTLEFenceNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182CD58);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLFenceSubscription::onBTLEFenceNotification, event:%{public, location:escape_only} s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100270AF8(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1002660E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100266108(void *a1)
{
  *a1 = off_10182CCD8;
  sub_1002A5590(a1 + 9);
  uint64_t v2 = a1[7];
  a1[7] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = a1[6];
  a1[6] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return sub_100C6AB50((uint64_t)a1);
}

void sub_10026616C(void *a1)
{
  uint64_t v1 = (void *)sub_100266108(a1);
  operator delete(v1);
}

uint64_t sub_100266180(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  unsigned __int16 v6 = (void *)sub_100C6AAF0(a1, a2, a3, a4, a5);
  *unsigned __int16 v6 = off_10182CCD8;
  void v6[6] = 0LL;
  uint64_t v7 = v6 + 6;
  v6[7] = 0LL;
  *(_BYTE *)(a1 + 64) = +[CLFenceManagerAdapter isSupported](&OBJC_CLASS___CLFenceManagerAdapter, "isSupported");
  *(_BYTE *)(a1 + 65) = 0;
  sub_1002A5370((void *)(a1 + 72));
  sub_1010DDBC0(__p, (char *)objc_msgSend(objc_msgSend(*(id *)(a1 + 24), "legacyClientKey"), "UTF8String"));
  if (*(void *)sub_100265EAC(a1))
  {
    [*(id *)(*v7 + 16) register:*(void *)(*v7 + 8) forNotification:0 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*v7 + 16) register:*(void *)(*v7 + 8) forNotification:3 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*v7 + 16) register:*(void *)(*v7 + 8) forNotification:2 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*v7 + 16) register:*(void *)(*v7 + 8) forNotification:1 registrationInfo:sub_100272358((uint64_t)__p)];
  }

  if (*(_BYTE *)(a1 + 64))
  {
    uint64_t v8 = sub_100265C50(a1);
    [*(id *)(*(void *)v8 + 16) register:*(void *)(*(void *)v8 + 8) forNotification:0 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*(void *)v8 + 16) register:*(void *)(*(void *)v8 + 8) forNotification:1 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*(void *)v8 + 16) register:*(void *)(*(void *)v8 + 8) forNotification:8 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*(void *)v8 + 16) register:*(void *)(*(void *)v8 + 8) forNotification:2 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*(void *)v8 + 16) register:*(void *)(*(void *)v8 + 8) forNotification:3 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*(void *)v8 + 16) register:*(void *)(*(void *)v8 + 8) forNotification:4 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*(void *)v8 + 16) register:*(void *)(*(void *)v8 + 8) forNotification:7 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*(void *)v8 + 16) register:*(void *)(*(void *)v8 + 8) forNotification:5 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*(void *)v8 + 16) register:*(void *)(*(void *)v8 + 8) forNotification:6 registrationInfo:sub_100272358((uint64_t)__p)];
    [*(id *)(*(void *)v8 + 16) register:*(void *)(*(void *)v8 + 8) forNotification:9 registrationInfo:sub_100272358((uint64_t)__p)];
  }

  if (v11 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_1002663C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1002A5590(v16);
  uint64_t v19 = *(void *)(v15 + 56);
  *(void *)(v15 + 56) = 0LL;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  uint64_t v20 = *v17;
  uint64_t *v17 = 0LL;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  }
  sub_100C6AB50(v15);
  _Unwind_Resume(a1);
}

void *sub_100266474@<X0>(uint64_t a1@<X8>)
{
  v11[0] = &off_10182CE60;
  v11[1] = sub_1002666E8;
  _DWORD v11[2] = 0LL;
  unsigned __int16 v12 = v11;
  sub_1010DDBC0(v13, "kCLConnectionMessageRegionState");
  sub_100271834((uint64_t)&v14, (uint64_t)v11);
  v9[0] = &off_10182CEF0;
  v9[1] = sub_100269F34;
  _DWORD v9[2] = 0LL;
  uint64_t v10 = v9;
  sub_1010DDBC0(v15, "kCLConnectionMessageRegionMonitoring");
  sub_100271834((uint64_t)v16, (uint64_t)v9);
  sub_100272924(a1, (unsigned __int8 *)v13, 2LL);
  for (uint64_t i = 0LL; i != -14; i -= 7LL)
  {
    uint64_t v3 = *(_BYTE **)&v16[i * 8 + 24];
    if (&v16[i * 8] == v3)
    {
      uint64_t v3 = &v16[i * 8];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE(v15[i + 2]) < 0) {
      operator delete((void *)v15[i]);
    }
  }

  uint64_t v5 = v10;
  if (v10 == v9)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v9;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v10)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  uint64_t result = v12;
  if (v12 == v11)
  {
    uint64_t v8 = 4LL;
    uint64_t result = v11;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  else if (v12)
  {
    uint64_t v8 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  return result;
}

void sub_100266618( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  for (uint64_t i = 56LL; i != -56; i -= 56LL)
    sub_10026E430(v17 + i);
  uint64_t v20 = a13;
  if (a13 == &a10)
  {
    uint64_t v21 = 4LL;
    uint64_t v20 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_8;
    }
    uint64_t v21 = 5LL;
  }

  (*(void (**)(void))(*(void *)v20 + 8 * v21))();
LABEL_8:
  BOOL v22 = a17;
  if (a17 == &a14)
  {
    uint64_t v23 = 4LL;
    BOOL v22 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_13;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void))(*(void *)v22 + 8 * v23))();
LABEL_13:
  _Unwind_Resume(a1);
}

void sub_1002666E8(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  memset(&v177, 0, sizeof(v177));
  id v5 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageRegionTypeKey"];
  if (v5 && (sub_1002A96F8(v5, &v178) & 1) != 0)
  {
    uint64_t v6 = (const __CFString *)[(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageNameKey"];
    if (v6 && sub_1002AA05C(v6, &v177))
    {
      id v7 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageNotifyOnEntryKey"];
      if (v7 && (sub_1002A9230(v7, &v176) & 1) != 0)
      {
        id v8 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageNotifyOnExitKey"];
        if (v8 && (sub_1002A9230(v8, &v175) & 1) != 0)
        {
          id v9 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageConservativeEntry"];
          if (v9 && (sub_1002A9230(v9, &v174) & 1) != 0)
          {
            id v10 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageEmergencyKey"];
            if (v10 && (sub_1002A9230(v10, &v173) & 1) != 0)
            {
              if (!v173 || (sub_10026E5EC(a1) & 1) != 0)
              {
                sub_1010DDBC0( &__src,  (char *)objc_msgSend(objc_msgSend(*(id *)(a1 + 24), "legacyClientKey"), "UTF8String"));
                __int128 __p = 0uLL;
                v170 = 0LL;
                id v11 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageOnBehalfOfKey"];
                if (v11)
                {
                  sub_1010DDBC0(&__str, (char *)[v11 UTF8String]);
                  sub_100FE2D54(&__str, (uint64_t)buf);
                  sub_100FE3FB4((uint64_t)buf, (uint64_t)v179);
                  if (SHIBYTE(v170) < 0) {
                    operator delete((void *)__p);
                  }
                  __int128 __p = *(_OWORD *)v179;
                  v170 = v179[2];
                  HIBYTE(v179[2]) = 0;
                  LOBYTE(v179[0]) = 0;
                  sub_1011F6920((uint64_t)buf);
                }

                else
                {
                  if (qword_101934870 != -1) {
                    dispatch_once(&qword_101934870, &stru_10182CD98);
                  }
                  uint64_t v28 = (os_log_s *)qword_101934878;
                  if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t p_src = (uint64_t)&__src;
                    if (v172 < 0) {
                      uint64_t p_src = __src;
                    }
                    unint64_t v30 = &v177;
                    if ((v177.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                      unint64_t v30 = (std::string *)v177.__r_.__value_.__r.__words[0];
                    }
                    *(_DWORD *)int buf = 136381187;
                    *(void *)&uint8_t buf[4] = "kCLConnectionMessageOnBehalfOfKey";
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = p_src;
                    *(_WORD *)&_BYTE buf[22] = 2081;
                    *(void *)&uint8_t buf[24] = v30;
                    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "#Warning Couldn't get value for key %{private}s, %{public}s/%{private}s",  buf,  0x20u);
                  }

                  if (sub_1002921D0(115, 2))
                  {
                    bzero(buf, 0x65CuLL);
                    if (qword_101934870 != -1) {
                      dispatch_once(&qword_101934870, &stru_10182CD98);
                    }
                    __int16 v117 = &__src;
                    if (v172 < 0) {
                      __int16 v117 = (__int128 *)__src;
                    }
                    uint64_t v118 = &v177;
                    if ((v177.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                      uint64_t v118 = (std::string *)v177.__r_.__value_.__r.__words[0];
                    }
                    LODWORD(v179[0]) = 136381187;
                    *(void **)((char *)v179 + 4) = "kCLConnectionMessageOnBehalfOfKey";
                    WORD2(v179[1]) = 2082;
                    *(void **)((char *)&v179[1] + 6) = v117;
                    HIWORD(v179[2]) = 2081;
                    v180 = v118;
                    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  0LL,  "#Warning Couldn't get value for key %{private}s, %{public}s/%{private}s",  v179,  32);
                    int v120 = (char *)v119;
                    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v119);
                    if (v120 != buf) {
                      free(v120);
                    }
                  }
                }

                uint64_t v31 = HIBYTE(v170);
                if (SHIBYTE(v170) < 0) {
                  uint64_t v31 = *((void *)&__p + 1);
                }
                if (v31 && (sub_10026E490(a1) & 1) == 0)
                {
                  if (qword_101934870 != -1) {
                    dispatch_once(&qword_101934870, &stru_10182CD98);
                  }
                  __int128 v45 = (os_log_s *)qword_101934878;
                  if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_FAULT))
                  {
                    uint64_t v46 = *(void *)(a1 + 24);
                    uint64_t p_p = (uint64_t)&__p;
                    if (SHIBYTE(v170) < 0) {
                      uint64_t p_p = __p;
                    }
                    *(_DWORD *)int buf = 138543618;
                    *(void *)&uint8_t buf[4] = v46;
                    *(_WORD *)&_BYTE buf[12] = 2082;
                    *(void *)&buf[14] = p_p;
                    _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_FAULT,  "Client %{public}@ does not have appropriate entitlement to act as a proxy service to %{public}s",  buf,  0x16u);
                  }

                  if (sub_1002921D0(115, 0))
                  {
                    bzero(buf, 0x65CuLL);
                    if (qword_101934870 != -1) {
                      dispatch_once(&qword_101934870, &stru_10182CD98);
                    }
                    __int128 v48 = *(void **)(a1 + 24);
                    __int128 v49 = &__p;
                    if (SHIBYTE(v170) < 0) {
                      __int128 v49 = (__int128 *)__p;
                    }
                    LODWORD(v179[0]) = 138543618;
                    *(void **)((char *)v179 + 4) = v48;
                    WORD2(v179[1]) = 2082;
                    *(void **)((char *)&v179[1] + 6) = v49;
                    LODWORD(v143) = 22;
                    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  17LL,  "Client %{public}@ does not have appropriate entitlement to act as a proxy service to %{public}s",  v179,  v143);
                    uint64_t v51 = (char *)v50;
                    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v50);
LABEL_349:
                    if (v51 != buf) {
                      free(v51);
                    }
                  }

                  goto LABEL_308;
                }

                int v32 = v178;
                switch(v178)
                {
                  case 0:
                    if (qword_101934970 != -1) {
                      dispatch_once(&qword_101934970, &stru_10182CD78);
                    }
                    char v54 = (os_log_s *)qword_101934978;
                    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v55 = (uint64_t)&__p;
                      if (SHIBYTE(v170) < 0) {
                        uint64_t v55 = __p;
                      }
                      uint64_t v56 = (uint64_t)&__src;
                      if (v172 < 0) {
                        uint64_t v56 = __src;
                      }
                      uint64_t v57 = &v177;
                      if ((v177.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                        uint64_t v57 = (std::string *)v177.__r_.__value_.__r.__words[0];
                      }
                      *(_DWORD *)int buf = 136315650;
                      *(void *)&uint8_t buf[4] = v55;
                      *(_WORD *)&_BYTE buf[12] = 2080;
                      *(void *)&buf[14] = v56;
                      *(_WORD *)&_BYTE buf[22] = 2080;
                      *(void *)&uint8_t buf[24] = v57;
                      _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEBUG,  "iB: requesting, kCLClientRegionBeacon for, [%s]/%s/%s",  buf,  0x20u);
                    }

                    if (sub_1002921D0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_101934970 != -1) {
                        dispatch_once(&qword_101934970, &stru_10182CD78);
                      }
                      v130 = &__p;
                      if (SHIBYTE(v170) < 0) {
                        v130 = (__int128 *)__p;
                      }
                      v131 = &__src;
                      if (v172 < 0) {
                        v131 = (__int128 *)__src;
                      }
                      v132 = &v177;
                      if ((v177.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                        v132 = (std::string *)v177.__r_.__value_.__r.__words[0];
                      }
                      LODWORD(v179[0]) = 136315650;
                      *(void **)((char *)v179 + 4) = v130;
                      WORD2(v179[1]) = 2080;
                      *(void **)((char *)&v179[1] + 6) = v131;
                      HIWORD(v179[2]) = 2080;
                      v180 = v132;
                      LODWORD(v143) = 32;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  2LL,  "iB: requesting, kCLClientRegionBeacon for, [%s]/%s/%s",  (const char *)v179,  v143,  v144);
                      v134 = (char *)v133;
                      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v133);
                      if (v134 != buf) {
                        free(v134);
                      }
                    }

                    sub_100271AF0((uint64_t)v179, &__src, (__int128 *)&v177, &__p);
                    unint64_t v58 = (const __CFString *)[(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageProximityUUIDKey"];
                    if (v58 && sub_1002AA05C(v58, (std::string *)&v179[1]))
                    {
                      id v59 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageMajorKey"];
                      if (v59 && (sub_1002A9298(v59, &v181) & 1) != 0)
                      {
                        id v60 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageMinorKey"];
                        if (v60 && (sub_1002A9298(v60, &v182) & 1) != 0)
                        {
                          id v61 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageRegionDefinitionKey"];
                          if (v61 && (sub_1002A96F8(v61, &v168) & 1) != 0)
                          {
                            *(_DWORD *)((char *)&v182 + 2) = v168 & 7;
                            id v62 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageNotifyEntryStateOnDisplayKey"];
                            if (v62 && (sub_1002A9230(v62, (BOOL *)&v167) & 1) != 0)
                            {
                              if (v176) {
                                v183 |= 1u;
                              }
                              if (v175) {
                                v183 |= 2u;
                              }
                              if ((_BYTE)v167) {
                                v183 |= 4u;
                              }
                              if (v174) {
                                v183 |= 4u;
                              }
                              uint64_t v63 = *(void **)(*(void *)sub_100265EAC(a1) + 16LL);
                              v145[0] = _NSConcreteStackBlock;
                              v145[1] = 3321888768LL;
                              v145[2] = sub_10026EF54;
                              v145[3] = &unk_10182CCF8;
                              sub_100272138((uint64_t)v146, (uint64_t)v179);
                              [v63 doAsync:v145];
                              sub_1002722AC((uint64_t)v146);
LABEL_307:
                              sub_1002722AC((uint64_t)v179);
                              goto LABEL_308;
                            }

                            if (qword_101934980 != -1) {
                              dispatch_once(&qword_101934980, &stru_10182CE30);
                            }
                            uint64_t v107 = (os_log_s *)qword_101934988;
                            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                            {
                              *(_DWORD *)int buf = 136446210;
                              *(void *)&uint8_t buf[4] = "kCLConnectionMessageNotifyEntryStateOnDisplayKey";
                              _os_log_impl( (void *)&_mh_execute_header,  v107,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                            }

                            if (!sub_1002921D0(115, 0)) {
                              goto LABEL_307;
                            }
                            bzero(buf, 0x65CuLL);
                            if (qword_101934980 != -1) {
                              dispatch_once(&qword_101934980, &stru_10182CE30);
                            }
                            LODWORD(__str.__r_.__value_.__l.__data_) = 136446210;
                            *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"kCLConnectionMessageNotifyEntryStateOnDisplayKey";
                            LODWORD(v143) = 12;
                            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  &__str,  v143);
                            uint64_t v80 = (char *)v142;
                            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v142);
                          }

                          else
                          {
                            if (qword_101934980 != -1) {
                              dispatch_once(&qword_101934980, &stru_10182CE30);
                            }
                            __int16 v101 = (os_log_s *)qword_101934988;
                            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                            {
                              *(_DWORD *)int buf = 136446210;
                              *(void *)&uint8_t buf[4] = "kCLConnectionMessageRegionDefinitionKey";
                              _os_log_impl( (void *)&_mh_execute_header,  v101,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                            }

                            if (!sub_1002921D0(115, 0)) {
                              goto LABEL_307;
                            }
                            bzero(buf, 0x65CuLL);
                            if (qword_101934980 != -1) {
                              dispatch_once(&qword_101934980, &stru_10182CE30);
                            }
                            LODWORD(__str.__r_.__value_.__l.__data_) = 136446210;
                            *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"kCLConnectionMessageRegionDefinitionKey";
                            LODWORD(v143) = 12;
                            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  &__str,  v143);
                            uint64_t v80 = (char *)v102;
                            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v102);
                          }
                        }

                        else
                        {
                          if (qword_101934980 != -1) {
                            dispatch_once(&qword_101934980, &stru_10182CE30);
                          }
                          __int16 v95 = (os_log_s *)qword_101934988;
                          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)int buf = 136446210;
                            *(void *)&uint8_t buf[4] = "kCLConnectionMessageMinorKey";
                            _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                          }

                          if (!sub_1002921D0(115, 0)) {
                            goto LABEL_307;
                          }
                          bzero(buf, 0x65CuLL);
                          if (qword_101934980 != -1) {
                            dispatch_once(&qword_101934980, &stru_10182CE30);
                          }
                          LODWORD(__str.__r_.__value_.__l.__data_) = 136446210;
                          *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"kCLConnectionMessageMinorKey";
                          LODWORD(v143) = 12;
                          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  &__str,  v143);
                          uint64_t v80 = (char *)v96;
                          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v96);
                        }
                      }

                      else
                      {
                        if (qword_101934980 != -1) {
                          dispatch_once(&qword_101934980, &stru_10182CE30);
                        }
                        int v89 = (os_log_s *)qword_101934988;
                        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)int buf = 136446210;
                          *(void *)&uint8_t buf[4] = "kCLConnectionMessageMajorKey";
                          _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                        }

                        if (!sub_1002921D0(115, 0)) {
                          goto LABEL_307;
                        }
                        bzero(buf, 0x65CuLL);
                        if (qword_101934980 != -1) {
                          dispatch_once(&qword_101934980, &stru_10182CE30);
                        }
                        LODWORD(__str.__r_.__value_.__l.__data_) = 136446210;
                        *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"kCLConnectionMessageMajorKey";
                        LODWORD(v143) = 12;
                        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  &__str,  v143);
                        uint64_t v80 = (char *)v90;
                        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v90);
                      }
                    }

                    else
                    {
                      if (qword_101934980 != -1) {
                        dispatch_once(&qword_101934980, &stru_10182CE30);
                      }
                      BOOL v78 = (os_log_s *)qword_101934988;
                      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "kCLConnectionMessageProximityUUIDKey";
                        _os_log_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                      }

                      if (!sub_1002921D0(115, 0)) {
                        goto LABEL_307;
                      }
                      bzero(buf, 0x65CuLL);
                      if (qword_101934980 != -1) {
                        dispatch_once(&qword_101934980, &stru_10182CE30);
                      }
                      LODWORD(__str.__r_.__value_.__l.__data_) = 136446210;
                      *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = (std::string::size_type)"kCLConnectionMessageProximityUUIDKey";
                      LODWORD(v143) = 12;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  &__str,  v143);
                      uint64_t v80 = (char *)v79;
                      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v79);
                    }

                    if (v80 != buf) {
                      free(v80);
                    }
                    goto LABEL_307;
                  case 1:
                  case 3:
                    if (qword_101934870 != -1) {
                      dispatch_once(&qword_101934870, &stru_10182CD98);
                    }
                    unint64_t v33 = (os_log_s *)qword_101934878;
                    if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v34 = "kCLClientRegionCircular";
                      if (v32 == 3) {
                        uint64_t v34 = "kCLClientRegionSignificant";
                      }
                      uint64_t v35 = (uint64_t)&__p;
                      if (SHIBYTE(v170) < 0) {
                        uint64_t v35 = __p;
                      }
                      uint64_t v36 = (uint64_t)&__src;
                      if (v172 < 0) {
                        uint64_t v36 = __src;
                      }
                      uint64_t v37 = &v177;
                      *(_DWORD *)int buf = 136446978;
                      if ((v177.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                        uint64_t v37 = (std::string *)v177.__r_.__value_.__r.__words[0];
                      }
                      *(void *)&uint8_t buf[4] = v34;
                      *(_WORD *)&_BYTE buf[12] = 2080;
                      *(void *)&buf[14] = v35;
                      *(_WORD *)&_BYTE buf[22] = 2080;
                      *(void *)&uint8_t buf[24] = v36;
                      __int16 v186 = 2080;
                      v187 = v37;
                      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEBUG,  "Fence: requesting, %{public}s for, [%s]/%s/%s",  buf,  0x2Au);
                    }

                    if (sub_1002921D0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_101934870 != -1) {
                        dispatch_once(&qword_101934870, &stru_10182CD98);
                      }
                      __int16 v123 = "kCLClientRegionCircular";
                      if (v32 == 3) {
                        __int16 v123 = "kCLClientRegionSignificant";
                      }
                      int v124 = &__p;
                      if (SHIBYTE(v170) < 0) {
                        int v124 = (__int128 *)__p;
                      }
                      v125 = (std::string *)&__src;
                      if (v172 < 0) {
                        v125 = (std::string *)__src;
                      }
                      v126 = &v177;
                      if ((v177.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                        v126 = (std::string *)v177.__r_.__value_.__r.__words[0];
                      }
                      LODWORD(v179[0]) = 136446978;
                      *(void **)((char *)v179 + 4) = (void *)v123;
                      WORD2(v179[1]) = 2080;
                      *(void **)((char *)&v179[1] + 6) = v124;
                      HIWORD(v179[2]) = 2080;
                      v180 = v125;
                      __int16 v181 = 2080;
                      v182 = v126;
                      LODWORD(v143) = 42;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "Fence: requesting, %{public}s for, [%s]/%s/%s",  v179,  v143);
                      v128 = (char *)v127;
                      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v127);
                      if (v128 != buf) {
                        free(v128);
                      }
                    }

                    __str.__r_.__value_.__r.__words[0] = 0LL;
                    CFTypeRef v168 = 0LL;
                    uint64_t v167 = 0LL;
                    uint64_t v166 = 0LL;
                    id v38 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageLatitudeKey"];
                    if (v38 && (sub_1002A9AE8(v38, &__str) & 1) != 0)
                    {
                      id v39 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageLongitudeKey"];
                      if (v39 && (sub_1002A9AE8(v39, &v168) & 1) != 0)
                      {
                        id v40 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageRadiusKey"];
                        if (v40 && (sub_1002A9AE8(v40, &v167) & 1) != 0)
                        {
                          id v41 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageDesiredAccuracyKey"];
                          if (v41 && (sub_1002A9AE8(v41, &v166) & 1) != 0)
                          {
                            id v42 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageReferenceFrameKey"];
                            if (v42 && (sub_1002A96F8(v42, &v165) & 1) != 0)
                            {
                              BOOL v164 = 0;
                              id v43 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageMonitoringNearby"];
                              if (v43 && (sub_1002A9230(v43, &v164) & 1) != 0)
                              {
                                BOOL v163 = 0;
                                id v44 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageLowPowerFenceKey"];
                                if (v44 && (sub_1002A9230(v44, &v163) & 1) != 0)
                                {
                                  if (SHIBYTE(v172) < 0)
                                  {
                                    sub_1010DD48C(&v161, (void *)__src, *((unint64_t *)&__src + 1));
                                  }

                                  else
                                  {
                                    __int128 v161 = __src;
                                    uint64_t v162 = v172;
                                  }

                                  else {
                                    std::string v160 = v177;
                                  }
                                  if (SHIBYTE(v170) < 0)
                                  {
                                    sub_1010DD48C(&v158, (void *)__p, *((unint64_t *)&__p + 1));
                                  }

                                  else
                                  {
                                    __int128 v158 = __p;
                                    v159 = v170;
                                  }

                                  sub_1010DDBC0(&v156, "");
                                  sub_100922EB8(buf);
                                  if (v157 < 0) {
                                    operator delete(v156);
                                  }
                                  if (SHIBYTE(v159) < 0) {
                                    operator delete((void *)v158);
                                  }
                                  if (SHIBYTE(v162) < 0) {
                                    operator delete((void *)v161);
                                  }
                                  if (v176) {
                                    v188 |= 1uLL;
                                  }
                                  if (v175) {
                                    v188 |= 2uLL;
                                  }
                                  if (v163) {
                                    v188 |= 0x20uLL;
                                  }
                                  if (v32 == 3) {
                                    v188 |= 0x80uLL;
                                  }
                                  if (v174) {
                                    v188 |= 4uLL;
                                  }
                                  if (v164) {
                                    v188 |= 0x40uLL;
                                  }
                                  if (v173) {
                                    v188 |= 0x10uLL;
                                  }
                                  int v189 = v165;
                                  v140 = *(void **)(*(void *)sub_100265C50(a1) + 16LL);
                                  sub_1002718F0((char *)v155, (__int128 *)buf);
                                  [v140 requestRegionState:sub_10026ECB8(v155)];
                                  sub_10026EDA4((uint64_t)v155);
                                  sub_10026EDA4((uint64_t)buf);
                                }

                                else
                                {
                                  if (qword_101934980 != -1) {
                                    dispatch_once(&qword_101934980, &stru_10182CE30);
                                  }
                                  __int16 v121 = (os_log_s *)qword_101934988;
                                  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                                  {
                                    *(_DWORD *)int buf = 136446210;
                                    *(void *)&uint8_t buf[4] = "kCLConnectionMessageLowPowerFenceKey";
                                    _os_log_impl( (void *)&_mh_execute_header,  v121,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                                  }

                                  if (sub_1002921D0(115, 0))
                                  {
                                    bzero(buf, 0x65CuLL);
                                    if (qword_101934980 != -1) {
                                      dispatch_once(&qword_101934980, &stru_10182CE30);
                                    }
                                    LODWORD(v179[0]) = 136446210;
                                    *(void **)((char *)v179 + 4) = "kCLConnectionMessageLowPowerFenceKey";
                                    LODWORD(v143) = 12;
                                    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  v143);
                                    uint64_t v51 = (char *)v122;
                                    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v122);
                                    goto LABEL_349;
                                  }
                                }
                              }

                              else
                              {
                                if (qword_101934980 != -1) {
                                  dispatch_once(&qword_101934980, &stru_10182CE30);
                                }
                                char v108 = (os_log_s *)qword_101934988;
                                if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                                {
                                  *(_DWORD *)int buf = 136446210;
                                  *(void *)&uint8_t buf[4] = "kCLConnectionMessageMonitoringNearby";
                                  _os_log_impl( (void *)&_mh_execute_header,  v108,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                                }

                                if (sub_1002921D0(115, 0))
                                {
                                  bzero(buf, 0x65CuLL);
                                  if (qword_101934980 != -1) {
                                    goto LABEL_450;
                                  }
                                  goto LABEL_250;
                                }
                              }
                            }

                            else
                            {
                              if (qword_101934980 != -1) {
                                dispatch_once(&qword_101934980, &stru_10182CE30);
                              }
                              __int16 v103 = (os_log_s *)qword_101934988;
                              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                              {
                                *(_DWORD *)int buf = 136446210;
                                *(void *)&uint8_t buf[4] = "kCLConnectionMessageReferenceFrameKey";
                                _os_log_impl( (void *)&_mh_execute_header,  v103,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                              }

                              if (sub_1002921D0(115, 0))
                              {
                                bzero(buf, 0x65CuLL);
                                if (qword_101934980 != -1) {
                                  dispatch_once(&qword_101934980, &stru_10182CE30);
                                }
                                LODWORD(v179[0]) = 136446210;
                                *(void **)((char *)v179 + 4) = "kCLConnectionMessageReferenceFrameKey";
                                LODWORD(v143) = 12;
                                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  v143);
                                uint64_t v51 = (char *)v104;
                                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v104);
                                goto LABEL_349;
                              }
                            }
                          }

                          else
                          {
                            if (qword_101934980 != -1) {
                              dispatch_once(&qword_101934980, &stru_10182CE30);
                            }
                            __int16 v97 = (os_log_s *)qword_101934988;
                            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                            {
                              *(_DWORD *)int buf = 136446210;
                              *(void *)&uint8_t buf[4] = "kCLConnectionMessageDesiredAccuracyKey";
                              _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                            }

                            if (sub_1002921D0(115, 0))
                            {
                              bzero(buf, 0x65CuLL);
                              if (qword_101934980 != -1) {
                                dispatch_once(&qword_101934980, &stru_10182CE30);
                              }
                              LODWORD(v179[0]) = 136446210;
                              *(void **)((char *)v179 + 4) = "kCLConnectionMessageDesiredAccuracyKey";
                              LODWORD(v143) = 12;
                              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  v143);
                              uint64_t v51 = (char *)v98;
                              sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v98);
                              goto LABEL_349;
                            }
                          }
                        }

                        else
                        {
                          if (qword_101934980 != -1) {
                            dispatch_once(&qword_101934980, &stru_10182CE30);
                          }
                          __int16 v91 = (os_log_s *)qword_101934988;
                          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)int buf = 136446210;
                            *(void *)&uint8_t buf[4] = "kCLConnectionMessageRadiusKey";
                            _os_log_impl( (void *)&_mh_execute_header,  v91,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                          }

                          if (sub_1002921D0(115, 0))
                          {
                            bzero(buf, 0x65CuLL);
                            if (qword_101934980 != -1) {
                              dispatch_once(&qword_101934980, &stru_10182CE30);
                            }
                            LODWORD(v179[0]) = 136446210;
                            *(void **)((char *)v179 + 4) = "kCLConnectionMessageRadiusKey";
                            LODWORD(v143) = 12;
                            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  v143);
                            uint64_t v51 = (char *)v92;
                            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v92);
                            goto LABEL_349;
                          }
                        }
                      }

                      else
                      {
                        if (qword_101934980 != -1) {
                          dispatch_once(&qword_101934980, &stru_10182CE30);
                        }
                        double v85 = (os_log_s *)qword_101934988;
                        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)int buf = 136446210;
                          *(void *)&uint8_t buf[4] = "kCLConnectionMessageLongitudeKey";
                          _os_log_impl( (void *)&_mh_execute_header,  v85,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                        }

                        if (sub_1002921D0(115, 0))
                        {
                          bzero(buf, 0x65CuLL);
                          if (qword_101934980 != -1) {
                            dispatch_once(&qword_101934980, &stru_10182CE30);
                          }
                          LODWORD(v179[0]) = 136446210;
                          *(void **)((char *)v179 + 4) = "kCLConnectionMessageLongitudeKey";
                          LODWORD(v143) = 12;
                          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  v143);
                          uint64_t v51 = (char *)v86;
                          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v86);
                          goto LABEL_349;
                        }
                      }
                    }

                    else
                    {
                      if (qword_101934980 != -1) {
                        dispatch_once(&qword_101934980, &stru_10182CE30);
                      }
                      unint64_t v52 = (os_log_s *)qword_101934988;
                      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "kCLConnectionMessageLatitudeKey";
                        _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                      }

                      if (sub_1002921D0(115, 0))
                      {
                        bzero(buf, 0x65CuLL);
                        if (qword_101934980 != -1) {
                          dispatch_once(&qword_101934980, &stru_10182CE30);
                        }
                        LODWORD(v179[0]) = 136446210;
                        *(void **)((char *)v179 + 4) = "kCLConnectionMessageLatitudeKey";
                        LODWORD(v143) = 12;
                        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  v143);
                        uint64_t v51 = (char *)v53;
                        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v53);
                        goto LABEL_349;
                      }
                    }

                    goto LABEL_308;
                  case 2:
                    if ((sub_10026E578(a1) & 1) == 0)
                    {
                      if (qword_101934970 != -1) {
                        dispatch_once(&qword_101934970, &stru_10182CD78);
                      }
                      int v81 = (os_log_s *)qword_101934978;
                      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                      {
                        uint64_t v82 = *(void *)(a1 + 24);
                        *(_DWORD *)int buf = 138543362;
                        *(void *)&uint8_t buf[4] = v82;
                        _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_FAULT,  "Client %{public}@ does not have appropriate entitlement to use polygonal regions",  buf,  0xCu);
                      }

                      if (sub_1002921D0(115, 0))
                      {
                        bzero(buf, 0x65CuLL);
                        if (qword_101934970 != -1) {
                          dispatch_once(&qword_101934970, &stru_10182CD78);
                        }
                        uint64_t v83 = *(void **)(a1 + 24);
                        LODWORD(v179[0]) = 138543362;
                        *(void **)((char *)v179 + 4) = v83;
                        LODWORD(v143) = 12;
                        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Client %{public}@ does not have appropriate entitlement to use polygonal regions",  v179,  v143);
                        uint64_t v51 = (char *)v84;
                        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v84);
                        goto LABEL_349;
                      }

                      goto LABEL_308;
                    }

                    if (qword_101934870 != -1) {
                      dispatch_once(&qword_101934870, &stru_10182CD98);
                    }
                    char v64 = (os_log_s *)qword_101934878;
                    if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
                    {
                      uint64_t v65 = (uint64_t)&__p;
                      if (SHIBYTE(v170) < 0) {
                        uint64_t v65 = __p;
                      }
                      uint64_t v66 = (uint64_t)&__src;
                      if (v172 < 0) {
                        uint64_t v66 = __src;
                      }
                      unint64_t v67 = &v177;
                      if ((v177.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                        unint64_t v67 = (std::string *)v177.__r_.__value_.__r.__words[0];
                      }
                      *(_DWORD *)int buf = 136315650;
                      *(void *)&uint8_t buf[4] = v65;
                      *(_WORD *)&_BYTE buf[12] = 2080;
                      *(void *)&buf[14] = v66;
                      *(_WORD *)&_BYTE buf[22] = 2080;
                      *(void *)&uint8_t buf[24] = v67;
                      _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEBUG,  "Fence: requesting, kCLClientRegionPolygonal for, [%s]/%s/%s",  buf,  0x20u);
                    }

                    if (sub_1002921D0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_101934870 != -1) {
                        dispatch_once(&qword_101934870, &stru_10182CD98);
                      }
                      v135 = &__p;
                      if (SHIBYTE(v170) < 0) {
                        v135 = (__int128 *)__p;
                      }
                      v136 = &__src;
                      if (v172 < 0) {
                        v136 = (__int128 *)__src;
                      }
                      v137 = &v177;
                      if ((v177.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                        v137 = (std::string *)v177.__r_.__value_.__r.__words[0];
                      }
                      LODWORD(v179[0]) = 136315650;
                      *(void **)((char *)v179 + 4) = v135;
                      WORD2(v179[1]) = 2080;
                      *(void **)((char *)&v179[1] + 6) = v136;
                      HIWORD(v179[2]) = 2080;
                      v180 = v137;
                      LODWORD(v143) = 32;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "Fence: requesting, kCLClientRegionPolygonal for, [%s]/%s/%s",  (const char *)v179,  v143,  v144);
                      v139 = (char *)v138;
                      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v138);
                      if (v139 != buf) {
                        free(v139);
                      }
                    }

                    BOOL v164 = 0;
                    id v68 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageReferenceFrameKey"];
                    if (!v68 || (sub_1002A96F8(v68, &v166) & 1) == 0)
                    {
                      if (qword_101934980 != -1) {
                        dispatch_once(&qword_101934980, &stru_10182CE30);
                      }
                      int v87 = (os_log_s *)qword_101934988;
                      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "kCLConnectionMessageReferenceFrameKey";
                        _os_log_impl( (void *)&_mh_execute_header,  v87,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                      }

                      if (sub_1002921D0(115, 0))
                      {
                        bzero(buf, 0x65CuLL);
                        if (qword_101934980 != -1) {
                          dispatch_once(&qword_101934980, &stru_10182CE30);
                        }
                        LODWORD(v179[0]) = 136446210;
                        *(void **)((char *)v179 + 4) = "kCLConnectionMessageReferenceFrameKey";
                        LODWORD(v143) = 12;
                        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  v143);
                        uint64_t v51 = (char *)v88;
                        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v88);
                        goto LABEL_349;
                      }

                      goto LABEL_308;
                    }

                    id v69 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessageMonitoringNearby"];
                    if (!v69 || (sub_1002A9230(v69, &v164) & 1) == 0)
                    {
                      if (qword_101934980 != -1) {
                        dispatch_once(&qword_101934980, &stru_10182CE30);
                      }
                      __int128 v93 = (os_log_s *)qword_101934988;
                      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "kCLConnectionMessageMonitoringNearby";
                        _os_log_impl( (void *)&_mh_execute_header,  v93,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                      }

                      if (sub_1002921D0(115, 0))
                      {
                        bzero(buf, 0x65CuLL);
                        if (qword_101934980 != -1) {
LABEL_450:
                        }
                          dispatch_once(&qword_101934980, &stru_10182CE30);
LABEL_250:
                        LODWORD(v179[0]) = 136446210;
                        *(void **)((char *)v179 + 4) = "kCLConnectionMessageMonitoringNearby";
                        LODWORD(v143) = 12;
                        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  v143);
                        uint64_t v51 = (char *)v94;
                        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v94);
                        goto LABEL_349;
                      }

                      goto LABEL_308;
                    }

                    id v70 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:@"kCLConnectionMessagePolygonalVerticesCountKey"];
                    if (!v70 || (sub_1002A96F8(v70, &v165) & 1) == 0)
                    {
                      if (qword_101934980 != -1) {
                        dispatch_once(&qword_101934980, &stru_10182CE30);
                      }
                      __int16 v99 = (os_log_s *)qword_101934988;
                      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "kCLConnectionMessagePolygonalVerticesCountKey";
                        _os_log_impl( (void *)&_mh_execute_header,  v99,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                      }

                      if (sub_1002921D0(115, 0))
                      {
                        bzero(buf, 0x65CuLL);
                        if (qword_101934980 != -1) {
                          dispatch_once(&qword_101934980, &stru_10182CE30);
                        }
                        LODWORD(v179[0]) = 136446210;
                        *(void **)((char *)v179 + 4) = "kCLConnectionMessagePolygonalVerticesCountKey";
                        LODWORD(v143) = 12;
                        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  v143);
                        uint64_t v51 = (char *)v100;
                        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v100);
                        goto LABEL_349;
                      }

                      goto LABEL_308;
                    }

                    Dictionary = (const __CFDictionary *)CLConnectionMessage::getDictionary(*a2);
                    sub_1002A5550((int)&__str, Dictionary);
                    if (sub_1002AA8F4((uint64_t)&__str, @"kCLConnectionMessagePolygonalVerticesKey", &v168))
                    {
                      CFTypeRef v72 = v168;
                      uint64_t v167 = 0LL;
                      *(void *)&double v73 = objc_opt_class(&OBJC_CLASS____CLVertex).n128_u64[0];
                      unint64_t v75 = +[NSKeyedUnarchiver unarchivedArrayOfObjectsOfClass:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedArrayOfObjectsOfClass:fromData:error:",  v74,  v72,  &v167,  v73);
                      if (v167)
                      {
                        if (qword_101934970 != -1) {
                          dispatch_once(&qword_101934970, &stru_10182CD78);
                        }
                        char v76 = (os_log_s *)qword_101934978;
                        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)int buf = 68289282;
                          *(_DWORD *)&uint8_t buf[4] = 0;
                          *(_WORD *)&uint8_t buf[8] = 2082;
                          *(void *)&buf[10] = "";
                          *(_WORD *)&_BYTE buf[18] = 2114;
                          *(void *)&buf[20] = v167;
                          _os_log_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unable to get vertices from data in handleMessageRegionState, err or:%{public, location:escape_only}@}",  buf,  0x1Cu);
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                        }

                        uint64_t v77 = (os_log_s *)qword_101934978;
                        if (os_signpost_enabled((os_log_t)qword_101934978))
                        {
                          *(_DWORD *)int buf = 68289282;
                          *(_DWORD *)&uint8_t buf[4] = 0;
                          *(_WORD *)&uint8_t buf[8] = 2082;
                          *(void *)&buf[10] = "";
                          *(_WORD *)&_BYTE buf[18] = 2114;
                          *(void *)&buf[20] = v167;
                          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v77,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unable to get vertices from data in handleMessageRegionState",  "{msg%{public}.0s:Unable to get vertices from data in handleMessageRegionState, err or:%{public, location:escape_only}@}",  buf,  0x1Cu);
                        }

LABEL_301:
                        sub_1002A5590(&__str);
LABEL_308:
                        if (SHIBYTE(v170) < 0) {
                          operator delete((void *)__p);
                        }
                        if (SHIBYTE(v172) < 0) {
                          operator delete((void *)__src);
                        }
                        goto LABEL_65;
                      }

                      v109 = v75;
                      id v110 = -[NSArray count](v75, "count");
                      if (v165 == (_DWORD)v110)
                      {
                        memset(v179, 0, sizeof(v179));
                        sub_10005A29C(v179, v165);
                        if (v165 >= 1)
                        {
                          for (uint64_t i = 0LL; i < v165; ++i)
                          {
                            objc_msgSend( -[NSArray objectAtIndexedSubscript:](v109, "objectAtIndexedSubscript:", i),  "coordinate");
                            *(void *)int buf = v112;
                            objc_msgSend( -[NSArray objectAtIndexedSubscript:](v109, "objectAtIndexedSubscript:", i),  "coordinate");
                            *(void *)&uint8_t buf[8] = v113;
                            sub_10026EE20(v179, buf);
                          }
                        }

                        if (SHIBYTE(v172) < 0)
                        {
                          sub_1010DD48C(&__dst, (void *)__src, *((unint64_t *)&__src + 1));
                        }

                        else
                        {
                          __uuid_t dst = __src;
                          uint64_t v154 = v172;
                        }

                        else {
                          std::string v152 = v177;
                        }
                        if (SHIBYTE(v170) < 0)
                        {
                          sub_1010DD48C(&v150, (void *)__p, *((unint64_t *)&__p + 1));
                        }

                        else
                        {
                          __int128 v150 = __p;
                          v151 = v170;
                        }

                        sub_1010DDBC0(v148, "");
                        sub_1009230D4( buf,  (uint64_t)&__dst,  (uint64_t)&v152,  (uint64_t)&v150,  (uint64_t)v179,  -1,  (uint64_t)v148,  0LL,  0);
                        if (v149 < 0) {
                          operator delete(v148[0]);
                        }
                        if (SHIBYTE(v151) < 0) {
                          operator delete((void *)v150);
                        }
                        if (SHIBYTE(v154) < 0) {
                          operator delete((void *)__dst);
                        }
                        if (v176) {
                          v188 |= 1uLL;
                        }
                        if (v175) {
                          v188 |= 2uLL;
                        }
                        if (v174) {
                          v188 |= 4uLL;
                        }
                        if (v164) {
                          v188 |= 8uLL;
                        }
                        if (v173) {
                          v188 |= 0x10uLL;
                        }
                        int v189 = v166;
                        v129 = *(void **)(*(void *)sub_100265C50(a1) + 16LL);
                        sub_1002718F0((char *)v147, (__int128 *)buf);
                        [v129 requestRegionState:sub_10026ECB8(v147)];
                        sub_10026EDA4((uint64_t)v147);
                        sub_10026EDA4((uint64_t)buf);
                        if (v179[0])
                        {
                          v179[1] = v179[0];
                          operator delete(v179[0]);
                        }

                        goto LABEL_301;
                      }

                      if (qword_101934970 != -1) {
                        dispatch_once(&qword_101934970, &stru_10182CD78);
                      }
                      int v114 = (os_log_s *)qword_101934978;
                      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)int buf = 67240448;
                        *(_DWORD *)&uint8_t buf[4] = v165;
                        *(_WORD *)&uint8_t buf[8] = 2050;
                        *(void *)&buf[10] = v110;
                        _os_log_impl( (void *)&_mh_execute_header,  v114,  OS_LOG_TYPE_FAULT,  "Number of vertices received doesn't match stored, %{public}d, %{public}lu",  buf,  0x12u);
                      }

                      if (!sub_1002921D0(115, 0)) {
                        goto LABEL_301;
                      }
                      bzero(buf, 0x65CuLL);
                      if (qword_101934970 != -1) {
                        dispatch_once(&qword_101934970, &stru_10182CD78);
                      }
                      LODWORD(v179[0]) = 67240448;
                      HIDWORD(v179[0]) = v165;
                      LOWORD(v179[1]) = 2050;
                      *(void **)((char *)&v179[1] + 2) = v110;
                      LODWORD(v143) = 18;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Number of vertices received doesn't match stored, %{public}d, %{public}lu",  v179,  v143);
                      double v116 = (char *)v115;
                      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v115);
                    }

                    else
                    {
                      if (qword_101934970 != -1) {
                        dispatch_once(&qword_101934970, &stru_10182CD78);
                      }
                      int v106 = (os_log_s *)qword_101934978;
                      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "kCLConnectionMessagePolygonalVerticesKey";
                        _os_log_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                      }

                      if (!sub_1002921D0(115, 0)) {
                        goto LABEL_301;
                      }
                      bzero(buf, 0x65CuLL);
                      if (qword_101934970 != -1) {
                        dispatch_once(&qword_101934970, &stru_10182CD78);
                      }
                      LODWORD(v179[0]) = 136446210;
                      *(void **)((char *)v179 + 4) = "kCLConnectionMessagePolygonalVerticesKey";
                      LODWORD(v143) = 12;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v179,  v143);
                      double v116 = (char *)v141;
                      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v141);
                    }

                    if (v116 != buf) {
                      free(v116);
                    }
                    goto LABEL_301;
                  default:
                    goto LABEL_308;
                }
              }

              if (qword_101934970 != -1) {
                dispatch_once(&qword_101934970, &stru_10182CD78);
              }
              uint64_t v24 = (os_log_s *)qword_101934978;
              if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
              {
                uint64_t v25 = *(void *)(a1 + 24);
                *(_DWORD *)int buf = 138543362;
                *(void *)&uint8_t buf[4] = v25;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "Client %{public}@ does not have the appropriate entitlement to act as an emergency service",  buf,  0xCu);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934970 != -1) {
                  dispatch_once(&qword_101934970, &stru_10182CD78);
                }
                unint64_t v26 = *(void **)(a1 + 24);
                LODWORD(v179[0]) = 138543362;
                *(void **)((char *)v179 + 4) = v26;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Client %{public}@ does not have the appropriate entitlement to act as an emergency service",  v179,  12);
                uint64_t v14 = (char *)v27;
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v27);
LABEL_294:
                if (v14 != buf) {
                  free(v14);
                }
              }
            }

            else
            {
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_10182CE30);
              }
              uint64_t v23 = (os_log_s *)qword_101934988;
              if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "kCLConnectionMessageEmergencyKey";
                _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934980 != -1) {
                  dispatch_once(&qword_101934980, &stru_10182CE30);
                }
                LODWORD(v179[0]) = 136446210;
                *(void **)((char *)v179 + 4) = "kCLConnectionMessageEmergencyKey";
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  12);
                uint64_t v14 = (char *)v105;
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v105);
                goto LABEL_294;
              }
            }
          }

          else
          {
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_10182CE30);
            }
            uint64_t v21 = (os_log_s *)qword_101934988;
            if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "kCLConnectionMessageConservativeEntry";
              _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
            }

            if (sub_1002921D0(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934980 != -1) {
                dispatch_once(&qword_101934980, &stru_10182CE30);
              }
              LODWORD(v179[0]) = 136446210;
              *(void **)((char *)v179 + 4) = "kCLConnectionMessageConservativeEntry";
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  12);
              uint64_t v14 = (char *)v22;
              sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v22);
              goto LABEL_294;
            }
          }
        }

        else
        {
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_10182CE30);
          }
          uint64_t v19 = (os_log_s *)qword_101934988;
          if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "kCLConnectionMessageNotifyOnExitKey";
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934980 != -1) {
              dispatch_once(&qword_101934980, &stru_10182CE30);
            }
            LODWORD(v179[0]) = 136446210;
            *(void **)((char *)v179 + 4) = "kCLConnectionMessageNotifyOnExitKey";
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  12);
            uint64_t v14 = (char *)v20;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v20);
            goto LABEL_294;
          }
        }
      }

      else
      {
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_10182CE30);
        }
        uint64_t v17 = (os_log_s *)qword_101934988;
        if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "kCLConnectionMessageNotifyOnEntryKey";
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934980 != -1) {
            dispatch_once(&qword_101934980, &stru_10182CE30);
          }
          LODWORD(v179[0]) = 136446210;
          *(void **)((char *)v179 + 4) = "kCLConnectionMessageNotifyOnEntryKey";
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  12);
          uint64_t v14 = (char *)v18;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v18);
          goto LABEL_294;
        }
      }
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_10182CE30);
      }
      uint64_t v15 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "kCLConnectionMessageNameKey";
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_10182CE30);
        }
        LODWORD(v179[0]) = 136446210;
        *(void **)((char *)v179 + 4) = "kCLConnectionMessageNameKey";
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  12);
        uint64_t v14 = (char *)v16;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v16);
        goto LABEL_294;
      }
    }
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_10182CE30);
    }
    unsigned __int16 v12 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "kCLConnectionMessageRegionTypeKey";
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_10182CE30);
      }
      LODWORD(v179[0]) = 136446210;
      *(void **)((char *)v179 + 4) = "kCLConnectionMessageRegionTypeKey";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  17LL,  "Couldn't get value for key %{public}s",  v179,  12);
      uint64_t v14 = (char *)v13;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleMessageRegionState(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v13);
      goto LABEL_294;
    }
  }

      char v149 = ++v150;
    }

    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10183C380);
    }
    std::string v152 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      sub_1003D2324((unsigned int *)(*a5 + 88 * v149), v459);
      v153 = v459;
      if (v459[23] < 0) {
        v153 = *(_BYTE **)v459;
      }
      *(_DWORD *)int buf = 136315650;
      *(void *)&uint8_t buf[4] = v153;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(double *)&buf[14] = Current - *((double *)&v437 + 1);
      *(_WORD *)&_BYTE buf[22] = 2048;
      *(void *)&uint8_t buf[24] = 0x40DC200000000000LL;
      _os_log_impl( (void *)&_mh_execute_header,  v152,  OS_LOG_TYPE_DEBUG,  "CELL_LOC: lte cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying",  buf,  0x20u);
      if ((v459[23] & 0x80000000) != 0) {
        operator delete(*(void **)v459);
      }
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_301;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10183C380);
    }
    uint64_t v154 = qword_101934A78;
    sub_1003D2324((unsigned int *)(*a5 + 88 * v149), &v451);
    v155 = &v451;
    if (SHIBYTE(v452) < 0) {
      v155 = (__int128 *)v451;
    }
    *(_DWORD *)v459 = 136315650;
    *(void *)&v459[4] = v155;
    *(_WORD *)&v459[12] = 2048;
    *(double *)&v459[14] = Current - *((double *)&v437 + 1);
    *(_WORD *)&v459[22] = 2048;
    *(void *)&v459[24] = 0x40DC200000000000LL;
    LODWORD(v417) = 32;
    v156 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v154,  2LL,  "CELL_LOC: lte cell, %s, last updated %.3f ago (%.3fs minimum), not re-querying",  v459,  v417,  v418);
    if (SHIBYTE(v452) < 0) {
      operator delete((void *)v451);
    }
    goto LABEL_272;
  }

  *(void *)int buf = &v231;
  sub_100D73A50((void ***)buf);
LABEL_302:
  v197 = v235;
  if (v235)
  {
    v198 = (unint64_t *)&v235->__shared_owners_;
    do
      v199 = __ldaxr(v198);
    while (__stlxr(v199 - 1, v198));
    if (!v199)
    {
      ((void (*)(std::__shared_weak_count *))v197->__on_zero_shared)(v197);
      std::__shared_weak_count::__release_weak(v197);
    }
  }

  return v23;
}

void sub_100269C58(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x3C7]) < 0) {
    operator delete((void *)STACK[0x3B0]);
  }
  if (SLOBYTE(STACK[0x3E7]) < 0) {
    operator delete((void *)STACK[0x3D0]);
  }
  if (SLOBYTE(STACK[0x407]) < 0) {
    operator delete((void *)STACK[0x3F0]);
  }

  _Unwind_Resume(a1);
}

void sub_100269F34(uint64_t a1, BOOL a2, uint64_t a3)
{
  BOOL v207 = a2;
  id v5 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  char v204 = 1;
  char v203 = 1;
  if ((sub_1002A7CB0(a3, "kCLConnectionMessageRegionTypeKey", &v206) & 1) != 0)
  {
    if ((sub_1002A6F64(a3, "kCLConnectionMessageSubscribeKey", &v207) & 1) != 0)
    {
      if ((sub_1002A8804(a3, "kCLConnectionMessageNameKey", (CFTypeRef *)&v205) & 1) != 0)
      {
        if ((sub_1002A6F64(a3, "kCLConnectionMessageNotifyOnEntryKey", (BOOL *)&v204) & 1) != 0)
        {
          if ((sub_1002A6F64(a3, "kCLConnectionMessageNotifyOnExitKey", (BOOL *)&v203) & 1) != 0)
          {
            __int16 v202 = 0;
            if ((sub_1002A6F64(a3, "kCLConnectionMessageConservativeEntry", (BOOL *)&v202 + 1) & 1) != 0)
            {
              if ((sub_1002A6F64(a3, "kCLConnectionMessageEmergencyKey", (BOOL *)&v202) & 1) != 0)
              {
                if (!(_BYTE)v202 || (sub_10026E5EC(a1) & 1) != 0)
                {
                  sub_1002A6C50(v205, &v201);
                  sub_1010DDBC0( &__src,  (char *)objc_msgSend(objc_msgSend(*(id *)(a1 + 24), "legacyClientKey"), "UTF8String"));
                  sub_1010DDBC0(&__p, "");
                  sub_1010DDBC0(&__str, "");
                  if (sub_1002A8560(a3, "kCLConnectionMessageOnBehalfOfKey", &__str))
                  {
                    std::string::size_type size = __str.__r_.__value_.__s.__size_;
                    if ((__str.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                      std::string::size_type size = __str.__r_.__value_.__l.__size_;
                    }
                    if (size)
                    {
                      if ((sub_10026E490(a1) & 1) == 0)
                      {
                        if (qword_101934970 != -1) {
                          dispatch_once(&qword_101934970, &stru_10182CD78);
                        }
                        uint64_t v51 = (os_log_s *)qword_101934978;
                        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                        {
                          uint64_t v52 = *(void *)(a1 + 24);
                          uint64_t p_p = (uint64_t)&__p;
                          if (SHIBYTE(v198) < 0) {
                            uint64_t p_p = __p;
                          }
                          *(_DWORD *)int buf = 138543618;
                          *(void *)&uint8_t buf[4] = v52;
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = p_p;
                          _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_FAULT,  "Client %{public}@ does not have appropriate entitlement to act as a proxy service to %{public}s",  buf,  0x16u);
                        }

                        if (!sub_1002921D0(115, 0)) {
                          goto LABEL_385;
                        }
                        bzero(buf, 0x65CuLL);
                        if (qword_101934970 != -1) {
                          dispatch_once(&qword_101934970, &stru_10182CD78);
                        }
                        char v54 = *(void **)(a1 + 24);
                        uint64_t v55 = &__p;
                        if (SHIBYTE(v198) < 0) {
                          uint64_t v55 = (__int128 *)__p;
                        }
                        LODWORD(v213[0]) = 138543618;
                        *(void **)((char *)v213 + 4) = v54;
                        WORD2(v213[1]) = 2082;
                        *(void **)((char *)&v213[1] + 6) = v55;
                        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Client %{public}@ does not have appropriate entitlement to act as a proxy service to %{public}s",  v213,  22);
                        __int128 v50 = (char *)v56;
                        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v56);
                        goto LABEL_479;
                      }

                      sub_100FE2D54(&__str, (uint64_t)buf);
                      sub_100FE3FB4((uint64_t)buf, (uint64_t)v213);
                      if (SHIBYTE(v198) < 0) {
                        operator delete((void *)__p);
                      }
                      __int128 __p = *(_OWORD *)v213;
                      v198 = v213[2];
                      HIBYTE(v213[2]) = 0;
                      LOBYTE(v213[0]) = 0;
                      sub_1011F6920((uint64_t)buf);
                    }
                  }

                  else
                  {
                    if (qword_101934970 != -1) {
                      dispatch_once(&qword_101934970, &stru_10182CD78);
                    }
                    BOOL v22 = (os_log_s *)qword_101934978;
                    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t p_src = (uint64_t)&__src;
                      if (v200 < 0) {
                        uint64_t p_src = __src;
                      }
                      uint64_t v24 = &v201;
                      if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                        uint64_t v24 = (std::string *)v201.__r_.__value_.__r.__words[0];
                      }
                      *(_DWORD *)int buf = 136381187;
                      *(void *)&uint8_t buf[4] = "kCLConnectionMessageOnBehalfOfKey";
                      *(_WORD *)&_BYTE buf[12] = 2081;
                      *(void *)&buf[14] = p_src;
                      *(_WORD *)&_BYTE buf[22] = 2081;
                      *(void *)&uint8_t buf[24] = v24;
                      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#Warning Couldn't get value for key %{private}s, %{private}s/%{private}s",  buf,  0x20u);
                    }

                    if (sub_1002921D0(115, 2))
                    {
                      bzero(buf, 0x65CuLL);
                      if (qword_101934970 != -1) {
                        dispatch_once(&qword_101934970, &stru_10182CD78);
                      }
                      v125 = &__src;
                      if (v200 < 0) {
                        v125 = (__int128 *)__src;
                      }
                      v126 = &v201;
                      if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                        v126 = (std::string *)v201.__r_.__value_.__r.__words[0];
                      }
                      LODWORD(v213[0]) = 136381187;
                      *(void **)((char *)v213 + 4) = "kCLConnectionMessageOnBehalfOfKey";
                      WORD2(v213[1]) = 2081;
                      *(void **)((char *)&v213[1] + 6) = v125;
                      HIWORD(v213[2]) = 2081;
                      v214 = v126;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  0LL,  "#Warning Couldn't get value for key %{private}s, %{private}s/%{private}s",  v213,  32);
                      v128 = (char *)v127;
                      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v127);
                      if (v128 != buf) {
                        free(v128);
                      }
                    }
                  }

                  switch(v206)
                  {
                    case 0:
                      sub_100271AF0((uint64_t)v213, &__src, (__int128 *)&v201, &__p);
                      if (sub_1002A8560(a3, "kCLConnectionMessageProximityUUIDKey", (std::string *)&v213[1]))
                      {
                        if ((sub_1002A7208(a3, "kCLConnectionMessageMajorKey", &v215) & 1) != 0)
                        {
                          if ((sub_1002A7208(a3, "kCLConnectionMessageMinorKey", &v216) & 1) != 0)
                          {
                            if ((sub_1002A7CB0(a3, "kCLConnectionMessageRegionDefinitionKey", &v195) & 1) != 0)
                            {
                              *(_DWORD *)((char *)&v216 + 2) = v195 & 7;
                              if ((sub_1002A6F64(a3, "kCLConnectionMessageNotifyEntryStateOnDisplayKey", (BOOL *)&v194) & 1) != 0)
                              {
                                if (v204) {
                                  v223 |= 1u;
                                }
                                if (v203) {
                                  v223 |= 2u;
                                }
                                if ((_BYTE)v194) {
                                  v223 |= 4u;
                                }
                                if (HIBYTE(v202)) {
                                  v223 |= 8u;
                                }
                                if (!v207)
                                {
                                  v109 = *(void **)(*(void *)sub_100265EAC(a1) + 16LL);
                                  v158[0] = _NSConcreteStackBlock;
                                  v158[1] = 3321888768LL;
                                  v158[2] = sub_10026EF3C;
                                  v158[3] = &unk_10182CCF8;
                                  uint64_t v35 = v159;
                                  sub_100272138((uint64_t)v159, (uint64_t)v213);
                                  [v109 doAsync:v158];
                                  goto LABEL_372;
                                }

                                if (sub_100E9E5A4((uint64_t)v213))
                                {
                                  uint64_t v34 = *(void **)(*(void *)sub_100265EAC(a1) + 16LL);
                                  v160[0] = _NSConcreteStackBlock;
                                  v160[1] = 3321888768LL;
                                  v160[2] = sub_10026EF0C;
                                  v160[3] = &unk_10182CCF8;
                                  uint64_t v35 = v161;
                                  sub_100272138((uint64_t)v161, (uint64_t)v213);
                                  [v34 doAsync:v160];
                                  sub_100C6ACCC(a1);
LABEL_372:
                                  sub_1002722AC((uint64_t)v35);
                                  sub_1002722AC((uint64_t)v213);
                                  int v47 = 1;
                                  goto LABEL_361;
                                }

                                if (qword_101934970 != -1) {
                                  dispatch_once(&qword_101934970, &stru_10182CD78);
                                }
                                id v110 = (os_log_s *)qword_101934978;
                                if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                                {
                                  uint64_t v111 = (uint64_t)&__p;
                                  if (SHIBYTE(v198) < 0) {
                                    uint64_t v111 = __p;
                                  }
                                  uint64_t v112 = (uint64_t)&__src;
                                  if (v200 < 0) {
                                    uint64_t v112 = __src;
                                  }
                                  uint64_t v113 = &v201;
                                  if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                                    uint64_t v113 = (std::string *)v201.__r_.__value_.__r.__words[0];
                                  }
                                  *(_DWORD *)int buf = 136446722;
                                  *(void *)&uint8_t buf[4] = v111;
                                  *(_WORD *)&_BYTE buf[12] = 2082;
                                  *(void *)&buf[14] = v112;
                                  *(_WORD *)&_BYTE buf[22] = 2082;
                                  *(void *)&uint8_t buf[24] = v113;
                                  _os_log_impl( (void *)&_mh_execute_header,  v110,  OS_LOG_TYPE_FAULT,  "Invalid beacon region request [%{public}s]/%{public}s/%{public}s.",  buf,  0x20u);
                                }

                                if (!sub_1002921D0(115, 0)) {
                                  goto LABEL_384;
                                }
                                bzero(buf, 0x65CuLL);
                                if (qword_101934970 != -1) {
                                  dispatch_once(&qword_101934970, &stru_10182CD78);
                                }
                                uint64_t v143 = (uint64_t)&__p;
                                if (SHIBYTE(v198) < 0) {
                                  uint64_t v143 = __p;
                                }
                                uint64_t v144 = (uint64_t)&__src;
                                if (v200 < 0) {
                                  uint64_t v144 = __src;
                                }
                                v145 = &v201;
                                if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                                  v145 = (std::string *)v201.__r_.__value_.__r.__words[0];
                                }
                                *(_DWORD *)v208 = 136446722;
                                *(void *)&v208[4] = v143;
                                __int16 v209 = 2082;
                                uint64_t v210 = v144;
                                __int16 v211 = 2082;
                                v212 = v145;
                                LODWORD(v157) = 32;
                                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Invalid beacon region request [%{public}s]/%{public}s/%{public}s.",  v208,  v157);
                                uint64_t v63 = (char *)v146;
                                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v146);
LABEL_537:
                                if (v63 != buf) {
                                  free(v63);
                                }
                                goto LABEL_384;
                              }

                              if (qword_101934970 != -1) {
                                dispatch_once(&qword_101934970, &stru_10182CD78);
                              }
                              double v98 = (os_log_s *)qword_101934978;
                              if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                              {
                                *(_DWORD *)int buf = 136446210;
                                *(void *)&uint8_t buf[4] = "kCLConnectionMessageNotifyEntryStateOnDisplayKey";
                                _os_log_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                              }

                              if (sub_1002921D0(115, 0))
                              {
                                bzero(buf, 0x65CuLL);
                                if (qword_101934970 != -1) {
                                  dispatch_once(&qword_101934970, &stru_10182CD78);
                                }
                                *(_DWORD *)v208 = 136446210;
                                *(void *)&v208[4] = "kCLConnectionMessageNotifyEntryStateOnDisplayKey";
                                LODWORD(v157) = 12;
                                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v208,  v157);
                                uint64_t v63 = (char *)v99;
                                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v99);
                                goto LABEL_537;
                              }
                            }

                            else
                            {
                              if (qword_101934970 != -1) {
                                dispatch_once(&qword_101934970, &stru_10182CD78);
                              }
                              uint64_t v84 = (os_log_s *)qword_101934978;
                              if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                              {
                                *(_DWORD *)int buf = 136446210;
                                *(void *)&uint8_t buf[4] = "kCLConnectionMessageRegionDefinitionKey";
                                _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                              }

                              if (sub_1002921D0(115, 0))
                              {
                                bzero(buf, 0x65CuLL);
                                if (qword_101934970 != -1) {
                                  dispatch_once(&qword_101934970, &stru_10182CD78);
                                }
                                *(_DWORD *)v208 = 136446210;
                                *(void *)&v208[4] = "kCLConnectionMessageRegionDefinitionKey";
                                LODWORD(v157) = 12;
                                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v208,  v157);
                                uint64_t v63 = (char *)v85;
                                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v85);
                                goto LABEL_537;
                              }
                            }
                          }

                          else
                          {
                            if (qword_101934970 != -1) {
                              dispatch_once(&qword_101934970, &stru_10182CD78);
                            }
                            uint64_t v74 = (os_log_s *)qword_101934978;
                            if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                            {
                              *(_DWORD *)int buf = 136446210;
                              *(void *)&uint8_t buf[4] = "kCLConnectionMessageMinorKey";
                              _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                            }

                            if (sub_1002921D0(115, 0))
                            {
                              bzero(buf, 0x65CuLL);
                              if (qword_101934970 != -1) {
                                dispatch_once(&qword_101934970, &stru_10182CD78);
                              }
                              *(_DWORD *)v208 = 136446210;
                              *(void *)&v208[4] = "kCLConnectionMessageMinorKey";
                              LODWORD(v157) = 12;
                              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v208,  v157);
                              uint64_t v63 = (char *)v75;
                              sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v75);
                              goto LABEL_537;
                            }
                          }
                        }

                        else
                        {
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          CFTypeRef v72 = (os_log_s *)qword_101934978;
                          if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)int buf = 136446210;
                            *(void *)&uint8_t buf[4] = "kCLConnectionMessageMajorKey";
                            _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                          }

                          if (sub_1002921D0(115, 0))
                          {
                            bzero(buf, 0x65CuLL);
                            if (qword_101934970 != -1) {
                              dispatch_once(&qword_101934970, &stru_10182CD78);
                            }
                            *(_DWORD *)v208 = 136446210;
                            *(void *)&v208[4] = "kCLConnectionMessageMajorKey";
                            LODWORD(v157) = 12;
                            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v208,  v157);
                            uint64_t v63 = (char *)v73;
                            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v73);
                            goto LABEL_537;
                          }
                        }
                      }

                      else
                      {
                        if (qword_101934970 != -1) {
                          dispatch_once(&qword_101934970, &stru_10182CD78);
                        }
                        id v61 = (os_log_s *)qword_101934978;
                        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)int buf = 136446210;
                          *(void *)&uint8_t buf[4] = "kCLConnectionMessageProximityUUIDKey";
                          _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                        }

                        if (sub_1002921D0(115, 0))
                        {
                          bzero(buf, 0x65CuLL);
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          *(_DWORD *)v208 = 136446210;
                          *(void *)&v208[4] = "kCLConnectionMessageProximityUUIDKey";
                          LODWORD(v157) = 12;
                          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v208,  v157);
                          uint64_t v63 = (char *)v62;
                          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v62);
                          goto LABEL_537;
                        }
                      }

LABEL_384:
                      sub_1002722AC((uint64_t)v213);
LABEL_385:
                      if (SHIBYTE(v198) < 0) {
                        operator delete((void *)__p);
                      }
                      if (SHIBYTE(v200) < 0) {
                        operator delete((void *)__src);
                      }
                      goto LABEL_393;
                    case 1:
                    case 3:
                      BOOL v192 = 0;
                      if ((sub_1002A6F64(a3, "kCLConnectionMessageMonitoringNearby", &v192) & 1) != 0)
                      {
                        int v25 = v206;
                        if (v206 == 3 && (sub_10026E6D4(a1) & 1) == 0)
                        {
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          id v68 = (os_log_s *)qword_101934978;
                          if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                          {
                            uint64_t v69 = *(void *)(a1 + 24);
                            *(_DWORD *)int buf = 138543362;
                            *(void *)&uint8_t buf[4] = v69;
                            _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_FAULT,  "Client %{public}@ does not have appropriate entitlement to use significant",  buf,  0xCu);
                          }

                          if (sub_1002921D0(115, 0))
                          {
                            bzero(buf, 0x65CuLL);
                            if (qword_101934970 != -1) {
                              dispatch_once(&qword_101934970, &stru_10182CD78);
                            }
                            id v70 = *(void **)(a1 + 24);
                            LODWORD(v213[0]) = 138543362;
                            *(void **)((char *)v213 + 4) = v70;
                            LODWORD(v157) = 12;
                            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Client %{public}@ does not have appropriate entitlement to use significant",  v213,  v157);
                            __int128 v50 = (char *)v71;
                            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v71);
                            break;
                          }
                        }

                        else
                        {
                          BOOL v191 = 0;
                          if ((sub_1002A6F64(a3, "kCLConnectionMessageLowPowerFenceKey", &v191) & 1) != 0)
                          {
                            if (v191 && (sub_10026E660(a1) & 1) == 0)
                            {
                              if (qword_101934970 != -1) {
                                dispatch_once(&qword_101934970, &stru_10182CD78);
                              }
                              char v76 = (os_log_s *)qword_101934978;
                              if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                              {
                                uint64_t v77 = *(void *)(a1 + 24);
                                *(_DWORD *)int buf = 138543362;
                                *(void *)&uint8_t buf[4] = v77;
                                _os_log_impl( (void *)&_mh_execute_header,  v76,  OS_LOG_TYPE_FAULT,  "Client %{public}@ does not have appropriate entitlement to use low power fence",  buf,  0xCu);
                              }

                              if (sub_1002921D0(115, 0))
                              {
                                bzero(buf, 0x65CuLL);
                                if (qword_101934970 != -1) {
                                  dispatch_once(&qword_101934970, &stru_10182CD78);
                                }
                                BOOL v78 = *(void **)(a1 + 24);
                                LODWORD(v213[0]) = 138543362;
                                *(void **)((char *)v213 + 4) = v78;
                                LODWORD(v157) = 12;
                                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Client %{public}@ does not have appropriate entitlement to use low power fence",  v213,  v157);
                                __int128 v50 = (char *)v79;
                                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v79);
                                break;
                              }
                            }

                            else
                            {
                              sub_1002A576C(a1 + 72, a3);
                              *(_BYTE *)(a1 + 65) = 1;
                              if (!*(_BYTE *)(a1 + 64)) {
                                goto LABEL_360;
                              }
                              if (!v207)
                              {
                                if (qword_101934870 != -1) {
                                  dispatch_once(&qword_101934870, &stru_10182CD98);
                                }
                                uint64_t v86 = (os_log_s *)qword_101934878;
                                if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEFAULT))
                                {
                                  uint64_t v87 = (uint64_t)&__p;
                                  if (SHIBYTE(v198) < 0) {
                                    uint64_t v87 = __p;
                                  }
                                  uint64_t v88 = (uint64_t)&__src;
                                  if (v200 < 0) {
                                    uint64_t v88 = __src;
                                  }
                                  int v89 = &v201;
                                  if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                                    int v89 = (std::string *)v201.__r_.__value_.__r.__words[0];
                                  }
                                  *(_DWORD *)int buf = 136446723;
                                  *(void *)&uint8_t buf[4] = v87;
                                  *(_WORD *)&_BYTE buf[12] = 2082;
                                  *(void *)&buf[14] = v88;
                                  *(_WORD *)&_BYTE buf[22] = 2081;
                                  *(void *)&uint8_t buf[24] = v89;
                                  _os_log_impl( (void *)&_mh_execute_header,  v86,  OS_LOG_TYPE_DEFAULT,  "Removing geographic fence [%{public}s]/%{public}s/%{private}s",  buf,  0x20u);
                                }

                                if (sub_1002921D0(115, 2))
                                {
                                  bzero(buf, 0x65CuLL);
                                  if (qword_101934870 != -1) {
                                    dispatch_once(&qword_101934870, &stru_10182CD98);
                                  }
                                  v133 = &__p;
                                  if (SHIBYTE(v198) < 0) {
                                    v133 = (__int128 *)__p;
                                  }
                                  v134 = &__src;
                                  if (v200 < 0) {
                                    v134 = (__int128 *)__src;
                                  }
                                  v135 = &v201;
                                  if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                                    v135 = (std::string *)v201.__r_.__value_.__r.__words[0];
                                  }
                                  LODWORD(v213[0]) = 136446723;
                                  *(void **)((char *)v213 + 4) = v133;
                                  WORD2(v213[1]) = 2082;
                                  *(void **)((char *)&v213[1] + 6) = v134;
                                  HIWORD(v213[2]) = 2081;
                                  v214 = v135;
                                  LODWORD(v157) = 32;
                                  _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  0LL,  "Removing geographic fence [%{public}s]/%{public}s/%{private}s",  v213,  v157);
                                  v137 = (char *)v136;
                                  sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v136);
                                  if (v137 != buf) {
                                    free(v137);
                                  }
                                }

                                if (SHIBYTE(v200) < 0)
                                {
                                  sub_1010DD48C(&__dst, (void *)__src, *((unint64_t *)&__src + 1));
                                }

                                else
                                {
                                  __uuid_t dst = __src;
                                  uint64_t v181 = v200;
                                }

                                else {
                                  std::string v179 = v201;
                                }
                                if (SHIBYTE(v198) < 0)
                                {
                                  sub_1010DD48C(&v177, (void *)__p, *((unint64_t *)&__p + 1));
                                }

                                else
                                {
                                  __int128 v177 = __p;
                                  int v178 = v198;
                                }

                                sub_100922A7C(buf, (uint64_t)&__dst, (uint64_t)&v179, (uint64_t)&v177);
                                if (SHIBYTE(v178) < 0) {
                                  operator delete((void *)v177);
                                }
                                if (SHIBYTE(v181) < 0) {
                                  operator delete((void *)__dst);
                                }
                                int v102 = *(void **)(*(void *)sub_100265C50(a1) + 16LL);
                                sub_1002718F0((char *)v176, (__int128 *)buf);
                                [v102 removeFence:sub_10026ECB8(v176)];
                                __int16 v103 = v176;
                                goto LABEL_358;
                              }

                              if ((sub_1002A82BC(a3, "kCLConnectionMessageLatitudeKey", v208) & 1) != 0)
                              {
                                if ((sub_1002A82BC(a3, "kCLConnectionMessageLongitudeKey", &v195) & 1) != 0)
                                {
                                  if ((sub_1002A82BC(a3, "kCLConnectionMessageRadiusKey", &v194) & 1) != 0)
                                  {
                                    if ((sub_1002A82BC(a3, "kCLConnectionMessageDesiredAccuracyKey", &v193) & 1) != 0)
                                    {
                                      if ((sub_1002A7CB0(a3, "kCLConnectionMessageReferenceFrameKey", v190) & 1) != 0)
                                      {
                                        if (qword_101934870 != -1) {
                                          dispatch_once(&qword_101934870, &stru_10182CD98);
                                        }
                                        unint64_t v26 = (os_log_s *)qword_101934878;
                                        if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEFAULT))
                                        {
                                          uint64_t v27 = (uint64_t)&__p;
                                          if (SHIBYTE(v198) < 0) {
                                            uint64_t v27 = __p;
                                          }
                                          uint64_t v28 = (uint64_t)&__src;
                                          if (v200 < 0) {
                                            uint64_t v28 = __src;
                                          }
                                          unint64_t v29 = &v201;
                                          if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                                            unint64_t v29 = (std::string *)v201.__r_.__value_.__r.__words[0];
                                          }
                                          *(_DWORD *)int buf = 136447747;
                                          *(void *)&uint8_t buf[4] = v27;
                                          *(_WORD *)&_BYTE buf[12] = 2082;
                                          *(void *)&buf[14] = v28;
                                          *(_WORD *)&_BYTE buf[22] = 2081;
                                          *(void *)&uint8_t buf[24] = v29;
                                          __int16 v225 = 2049;
                                          uint64_t v226 = *(void *)v208;
                                          __int16 v227 = 2049;
                                          uint64_t v228 = v195;
                                          __int16 v229 = 2050;
                                          uint64_t v230 = v194;
                                          __int16 v231 = 2050;
                                          uint64_t v232 = v193;
                                          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Adding geographic fence [%{public}s]/%{public}s/%{private}s, center, %{priva te}f, %{private}f, radius, %{public}.2f, desiredAccuracy, %{public}.2f",  buf,  0x48u);
                                        }

                                        if (sub_1002921D0(115, 2))
                                        {
                                          bzero(buf, 0x65CuLL);
                                          if (qword_101934870 != -1) {
                                            dispatch_once(&qword_101934870, &stru_10182CD98);
                                          }
                                          std::string v152 = &__p;
                                          if (SHIBYTE(v198) < 0) {
                                            std::string v152 = (__int128 *)__p;
                                          }
                                          v153 = &__src;
                                          if (v200 < 0) {
                                            v153 = (__int128 *)__src;
                                          }
                                          uint64_t v154 = &v201;
                                          if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                                            uint64_t v154 = (std::string *)v201.__r_.__value_.__r.__words[0];
                                          }
                                          LODWORD(v213[0]) = 136447747;
                                          *(void **)((char *)v213 + 4) = v152;
                                          WORD2(v213[1]) = 2082;
                                          *(void **)((char *)&v213[1] + 6) = v153;
                                          HIWORD(v213[2]) = 2081;
                                          v214 = v154;
                                          __int16 v215 = 2049;
                                          uint64_t v216 = *(void *)v208;
                                          __int16 v217 = 2049;
                                          uint64_t v218 = v195;
                                          __int16 v219 = 2050;
                                          uint64_t v220 = v194;
                                          __int16 v221 = 2050;
                                          uint64_t v222 = v193;
                                          LODWORD(v157) = 72;
                                          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  0LL,  "Adding geographic fence [%{public}s]/%{public}s/%{private}s, center, %{priva te}f, %{private}f, radius, %{public}.2f, desiredAccuracy, %{public}.2f",  v213,  v157);
                                          v156 = (char *)v155;
                                          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v155);
                                          if (v156 != buf) {
                                            free(v156);
                                          }
                                        }

                                        if (SHIBYTE(v200) < 0)
                                        {
                                          sub_1010DD48C(&v188, (void *)__src, *((unint64_t *)&__src + 1));
                                        }

                                        else
                                        {
                                          __int128 v188 = __src;
                                          uint64_t v189 = v200;
                                        }

                                        if ((char)v201.__r_.__value_.__s.__size_ < 0) {
                                          sub_1010DD48C( &v187,  v201.__r_.__value_.__l.__data_,  v201.__r_.__value_.__l.__size_);
                                        }
                                        else {
                                          std::string v187 = v201;
                                        }
                                        if (SHIBYTE(v198) < 0)
                                        {
                                          sub_1010DD48C(&v185, (void *)__p, *((unint64_t *)&__p + 1));
                                        }

                                        else
                                        {
                                          __int128 v185 = __p;
                                          __int16 v186 = v198;
                                        }

                                        sub_1010DDBC0(&v183, "");
                                        sub_100922EB8(buf);
                                        if (v184 < 0) {
                                          operator delete(v183);
                                        }
                                        if (SHIBYTE(v186) < 0) {
                                          operator delete((void *)v185);
                                        }
                                        if (SHIBYTE(v189) < 0) {
                                          operator delete((void *)v188);
                                        }
                                        if (v204) {
                                          v233 |= 1uLL;
                                        }
                                        if (v203) {
                                          v233 |= 2uLL;
                                        }
                                        if (v191) {
                                          v233 |= 0x20uLL;
                                        }
                                        if (v25 == 3) {
                                          v233 |= 0x80uLL;
                                        }
                                        if (HIBYTE(v202)) {
                                          v233 |= 4uLL;
                                        }
                                        if ((_BYTE)v202) {
                                          v233 |= 0x10uLL;
                                        }
                                        if (v192) {
                                          v233 |= 0x40uLL;
                                        }
                                        int v234 = *(_DWORD *)v190;
                                        v129 = *(void **)(*(void *)sub_100265C50(a1) + 16LL);
                                        sub_1002718F0((char *)v182, (__int128 *)buf);
                                        [v129 addFence:sub_10026ECB8(v182)];
                                        sub_10026EDA4((uint64_t)v182);
                                        sub_100C6ACCC(a1);
                                        goto LABEL_359;
                                      }

                                      if (qword_101934970 != -1) {
                                        dispatch_once(&qword_101934970, &stru_10182CD78);
                                      }
                                      uint64_t v118 = (os_log_s *)qword_101934978;
                                      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                                      {
                                        *(_DWORD *)int buf = 136446210;
                                        *(void *)&uint8_t buf[4] = "kCLConnectionMessageReferenceFrameKey";
                                        _os_log_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                                      }

                                      if (sub_1002921D0(115, 0))
                                      {
                                        bzero(buf, 0x65CuLL);
                                        if (qword_101934970 != -1) {
                                          goto LABEL_559;
                                        }
                                        goto LABEL_305;
                                      }
                                    }

                                    else
                                    {
                                      if (qword_101934970 != -1) {
                                        dispatch_once(&qword_101934970, &stru_10182CD78);
                                      }
                                      double v116 = (os_log_s *)qword_101934978;
                                      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                                      {
                                        *(_DWORD *)int buf = 136446210;
                                        *(void *)&uint8_t buf[4] = "kCLConnectionMessageDesiredAccuracyKey";
                                        _os_log_impl( (void *)&_mh_execute_header,  v116,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                                      }

                                      if (sub_1002921D0(115, 0))
                                      {
                                        bzero(buf, 0x65CuLL);
                                        if (qword_101934970 != -1) {
                                          dispatch_once(&qword_101934970, &stru_10182CD78);
                                        }
                                        LODWORD(v213[0]) = 136446210;
                                        *(void **)((char *)v213 + 4) = "kCLConnectionMessageDesiredAccuracyKey";
                                        LODWORD(v157) = 12;
                                        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  v157);
                                        __int128 v50 = (char *)v117;
                                        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v117);
                                        break;
                                      }
                                    }
                                  }

                                  else
                                  {
                                    if (qword_101934970 != -1) {
                                      dispatch_once(&qword_101934970, &stru_10182CD78);
                                    }
                                    uint64_t v107 = (os_log_s *)qword_101934978;
                                    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                                    {
                                      *(_DWORD *)int buf = 136446210;
                                      *(void *)&uint8_t buf[4] = "kCLConnectionMessageRadiusKey";
                                      _os_log_impl( (void *)&_mh_execute_header,  v107,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                                    }

                                    if (sub_1002921D0(115, 0))
                                    {
                                      bzero(buf, 0x65CuLL);
                                      if (qword_101934970 != -1) {
                                        dispatch_once(&qword_101934970, &stru_10182CD78);
                                      }
                                      LODWORD(v213[0]) = 136446210;
                                      *(void **)((char *)v213 + 4) = "kCLConnectionMessageRadiusKey";
                                      LODWORD(v157) = 12;
                                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  v157);
                                      __int128 v50 = (char *)v108;
                                      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v108);
                                      break;
                                    }
                                  }
                                }

                                else
                                {
                                  if (qword_101934970 != -1) {
                                    dispatch_once(&qword_101934970, &stru_10182CD78);
                                  }
                                  uint64_t v100 = (os_log_s *)qword_101934978;
                                  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                                  {
                                    *(_DWORD *)int buf = 136446210;
                                    *(void *)&uint8_t buf[4] = "kCLConnectionMessageLongitudeKey";
                                    _os_log_impl( (void *)&_mh_execute_header,  v100,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                                  }

                                  if (sub_1002921D0(115, 0))
                                  {
                                    bzero(buf, 0x65CuLL);
                                    if (qword_101934970 != -1) {
                                      dispatch_once(&qword_101934970, &stru_10182CD78);
                                    }
                                    LODWORD(v213[0]) = 136446210;
                                    *(void **)((char *)v213 + 4) = "kCLConnectionMessageLongitudeKey";
                                    LODWORD(v157) = 12;
                                    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  v157);
                                    __int128 v50 = (char *)v101;
                                    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v101);
                                    break;
                                  }
                                }
                              }

                              else
                              {
                                if (qword_101934970 != -1) {
                                  dispatch_once(&qword_101934970, &stru_10182CD78);
                                }
                                __int128 v90 = (os_log_s *)qword_101934978;
                                if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                                {
                                  *(_DWORD *)int buf = 136446210;
                                  *(void *)&uint8_t buf[4] = "kCLConnectionMessageLatitudeKey";
                                  _os_log_impl( (void *)&_mh_execute_header,  v90,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                                }

                                if (sub_1002921D0(115, 0))
                                {
                                  bzero(buf, 0x65CuLL);
                                  if (qword_101934970 != -1) {
                                    dispatch_once(&qword_101934970, &stru_10182CD78);
                                  }
                                  LODWORD(v213[0]) = 136446210;
                                  *(void **)((char *)v213 + 4) = "kCLConnectionMessageLatitudeKey";
                                  LODWORD(v157) = 12;
                                  _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  v157);
                                  __int128 v50 = (char *)v91;
                                  sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v91);
                                  break;
                                }
                              }
                            }
                          }

                          else
                          {
                            if (qword_101934970 != -1) {
                              dispatch_once(&qword_101934970, &stru_10182CD78);
                            }
                            char v64 = (os_log_s *)qword_101934978;
                            if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                            {
                              *(_DWORD *)int buf = 136446210;
                              *(void *)&uint8_t buf[4] = "kCLConnectionMessageLowPowerFenceKey";
                              _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                            }

                            if (sub_1002921D0(115, 0))
                            {
                              bzero(buf, 0x65CuLL);
                              if (qword_101934970 != -1) {
                                dispatch_once(&qword_101934970, &stru_10182CD78);
                              }
                              LODWORD(v213[0]) = 136446210;
                              *(void **)((char *)v213 + 4) = "kCLConnectionMessageLowPowerFenceKey";
                              LODWORD(v157) = 12;
                              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  v157);
                              __int128 v50 = (char *)v65;
                              sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v65);
                              break;
                            }
                          }
                        }
                      }

                      else
                      {
                        if (qword_101934970 != -1) {
                          dispatch_once(&qword_101934970, &stru_10182CD78);
                        }
                        __int128 v48 = (os_log_s *)qword_101934978;
                        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)int buf = 136446210;
                          *(void *)&uint8_t buf[4] = "kCLConnectionMessageMonitoringNearby";
                          _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                        }

                        if (sub_1002921D0(115, 0))
                        {
                          bzero(buf, 0x65CuLL);
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          LODWORD(v213[0]) = 136446210;
                          *(void **)((char *)v213 + 4) = "kCLConnectionMessageMonitoringNearby";
                          LODWORD(v157) = 12;
                          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  v157);
                          __int128 v50 = (char *)v49;
                          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v49);
                          break;
                        }
                      }

                      goto LABEL_385;
                    case 2:
                      if ((sub_10026E578(a1) & 1) == 0)
                      {
                        if (qword_101934970 != -1) {
                          dispatch_once(&qword_101934970, &stru_10182CD78);
                        }
                        uint64_t v57 = (os_log_s *)qword_101934978;
                        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                        {
                          uint64_t v58 = *(void *)(a1 + 24);
                          *(_DWORD *)int buf = 138543362;
                          *(void *)&uint8_t buf[4] = v58;
                          _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_FAULT,  "Client %{public}@ does not have appropriate entitlement to use polygonal regions",  buf,  0xCu);
                        }

                        if (sub_1002921D0(115, 0))
                        {
                          bzero(buf, 0x65CuLL);
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          id v59 = *(void **)(a1 + 24);
                          LODWORD(v213[0]) = 138543362;
                          *(void **)((char *)v213 + 4) = v59;
                          LODWORD(v157) = 12;
                          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Client %{public}@ does not have appropriate entitlement to use polygonal regions",  v213,  v157);
                          __int128 v50 = (char *)v60;
                          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v60);
                          break;
                        }

                        goto LABEL_385;
                      }

                      v190[0] = 0;
                      if ((sub_1002A6F64(a3, "kCLConnectionMessageMonitoringNearby", v190) & 1) == 0)
                      {
                        if (qword_101934970 != -1) {
                          dispatch_once(&qword_101934970, &stru_10182CD78);
                        }
                        uint64_t v66 = (os_log_s *)qword_101934978;
                        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)int buf = 136446210;
                          *(void *)&uint8_t buf[4] = "kCLConnectionMessageMonitoringNearby";
                          _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                        }

                        if (sub_1002921D0(115, 0))
                        {
                          bzero(buf, 0x65CuLL);
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          LODWORD(v213[0]) = 136446210;
                          *(void **)((char *)v213 + 4) = "kCLConnectionMessageMonitoringNearby";
                          LODWORD(v157) = 12;
                          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  v157);
                          __int128 v50 = (char *)v67;
                          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v67);
                          break;
                        }

                        goto LABEL_385;
                      }

                      if (v190[0] && (sub_10026E504(a1) & 1) == 0)
                      {
                        if (qword_101934970 != -1) {
                          dispatch_once(&qword_101934970, &stru_10182CD78);
                        }
                        uint64_t v80 = (os_log_s *)qword_101934978;
                        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                        {
                          uint64_t v81 = *(void *)(a1 + 24);
                          *(_DWORD *)int buf = 138543362;
                          *(void *)&uint8_t buf[4] = v81;
                          _os_log_impl( (void *)&_mh_execute_header,  v80,  OS_LOG_TYPE_FAULT,  "Client %{public}@ does not have appropriate entitlement to monitor while nearby",  buf,  0xCu);
                        }

                        if (sub_1002921D0(115, 0))
                        {
                          bzero(buf, 0x65CuLL);
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          uint64_t v82 = *(void **)(a1 + 24);
                          LODWORD(v213[0]) = 138543362;
                          *(void **)((char *)v213 + 4) = v82;
                          LODWORD(v157) = 12;
                          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Client %{public}@ does not have appropriate entitlement to monitor while nearby",  v213,  v157);
                          __int128 v50 = (char *)v83;
                          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v83);
                          break;
                        }

                        goto LABEL_385;
                      }

                      if (!*(_BYTE *)(a1 + 64)) {
                        goto LABEL_360;
                      }
                      if (!v207)
                      {
                        if (qword_101934870 != -1) {
                          dispatch_once(&qword_101934870, &stru_10182CD98);
                        }
                        uint64_t v92 = (os_log_s *)qword_101934878;
                        if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
                        {
                          uint64_t v93 = (uint64_t)&__p;
                          if (SHIBYTE(v198) < 0) {
                            uint64_t v93 = __p;
                          }
                          uint64_t v94 = (uint64_t)&__src;
                          if (v200 < 0) {
                            uint64_t v94 = __src;
                          }
                          __int16 v95 = &v201;
                          if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                            __int16 v95 = (std::string *)v201.__r_.__value_.__r.__words[0];
                          }
                          *(_DWORD *)int buf = 136446723;
                          *(void *)&uint8_t buf[4] = v93;
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v94;
                          *(_WORD *)&_BYTE buf[22] = 2081;
                          *(void *)&uint8_t buf[24] = v95;
                          _os_log_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_DEBUG,  "Removing geographic polygonal fence [%{public}s]/%{public}s/%{private}s",  buf,  0x20u);
                        }

                        if (sub_1002921D0(115, 2))
                        {
                          bzero(buf, 0x65CuLL);
                          if (qword_101934870 != -1) {
                            dispatch_once(&qword_101934870, &stru_10182CD98);
                          }
                          v138 = &__p;
                          if (SHIBYTE(v198) < 0) {
                            v138 = (__int128 *)__p;
                          }
                          v139 = &__src;
                          if (v200 < 0) {
                            v139 = (__int128 *)__src;
                          }
                          v140 = &v201;
                          if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                            v140 = (std::string *)v201.__r_.__value_.__r.__words[0];
                          }
                          LODWORD(v213[0]) = 136446723;
                          *(void **)((char *)v213 + 4) = v138;
                          WORD2(v213[1]) = 2082;
                          *(void **)((char *)&v213[1] + 6) = v139;
                          HIWORD(v213[2]) = 2081;
                          v214 = v140;
                          LODWORD(v157) = 32;
                          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "Removing geographic polygonal fence [%{public}s]/%{public}s/%{private}s",  v213,  v157);
                          v142 = (char *)v141;
                          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v141);
                          if (v142 != buf) {
                            free(v142);
                          }
                        }

                        if (SHIBYTE(v200) < 0)
                        {
                          sub_1010DD48C(&v166, (void *)__src, *((unint64_t *)&__src + 1));
                        }

                        else
                        {
                          __int128 v166 = __src;
                          uint64_t v167 = v200;
                        }

                        else {
                          std::string v165 = v201;
                        }
                        if (SHIBYTE(v198) < 0)
                        {
                          sub_1010DD48C(&v163, (void *)__p, *((unint64_t *)&__p + 1));
                        }

                        else
                        {
                          __int128 v163 = __p;
                          BOOL v164 = v198;
                        }

                        sub_100922A7C(buf, (uint64_t)&v166, (uint64_t)&v165, (uint64_t)&v163);
                        if (SHIBYTE(v164) < 0) {
                          operator delete((void *)v163);
                        }
                        if (SHIBYTE(v167) < 0) {
                          operator delete((void *)v166);
                        }
                        int v106 = *(void **)(*(void *)sub_100265C50(a1) + 16LL);
                        sub_1002718F0((char *)v162, (__int128 *)buf);
                        [v106 removeFence:sub_10026ECB8(v162)];
                        __int16 v103 = v162;
LABEL_358:
                        sub_10026EDA4((uint64_t)v103);
LABEL_359:
                        sub_10026EDA4((uint64_t)buf);
                        goto LABEL_360;
                      }

                      if ((sub_1002A7CB0(a3, "kCLConnectionMessageReferenceFrameKey", &v194) & 1) != 0)
                      {
                        if ((sub_1002A7CB0(a3, "kCLConnectionMessagePolygonalVerticesCountKey", &v193) & 1) == 0)
                        {
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          int v104 = (os_log_s *)qword_101934978;
                          if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)int buf = 136446210;
                            *(void *)&uint8_t buf[4] = "kCLConnectionMessagePolygonalVerticesCountKey";
                            _os_log_impl( (void *)&_mh_execute_header,  v104,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                          }

                          if (sub_1002921D0(115, 0))
                          {
                            bzero(buf, 0x65CuLL);
                            if (qword_101934970 != -1) {
                              dispatch_once(&qword_101934970, &stru_10182CD78);
                            }
                            LODWORD(v213[0]) = 136446210;
                            *(void **)((char *)v213 + 4) = "kCLConnectionMessagePolygonalVerticesCountKey";
                            LODWORD(v157) = 12;
                            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  v157);
                            __int128 v50 = (char *)v105;
                            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v105);
                            break;
                          }

                          goto LABEL_385;
                        }

                        if (!sub_1002AA8F4(a3, @"kCLConnectionMessagePolygonalVerticesKey", (CFTypeRef *)v208))
                        {
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          int v114 = (os_log_s *)qword_101934978;
                          if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)int buf = 136446210;
                            *(void *)&uint8_t buf[4] = "kCLConnectionMessagePolygonalVerticesKey";
                            _os_log_impl( (void *)&_mh_execute_header,  v114,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                          }

                          if (sub_1002921D0(115, 0))
                          {
                            bzero(buf, 0x65CuLL);
                            if (qword_101934970 != -1) {
                              dispatch_once(&qword_101934970, &stru_10182CD78);
                            }
                            LODWORD(v213[0]) = 136446210;
                            *(void **)((char *)v213 + 4) = "kCLConnectionMessagePolygonalVerticesKey";
                            LODWORD(v157) = 12;
                            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  v157);
                            __int128 v50 = (char *)v115;
                            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v115);
                            break;
                          }

                          goto LABEL_385;
                        }

                        if (qword_101934870 != -1) {
                          dispatch_once(&qword_101934870, &stru_10182CD98);
                        }
                        uint64_t v36 = (os_log_s *)qword_101934878;
                        if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
                        {
                          uint64_t v37 = (uint64_t)&__p;
                          if (SHIBYTE(v198) < 0) {
                            uint64_t v37 = __p;
                          }
                          uint64_t v38 = (uint64_t)&__src;
                          if (v200 < 0) {
                            uint64_t v38 = __src;
                          }
                          id v39 = &v201;
                          if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                            id v39 = (std::string *)v201.__r_.__value_.__r.__words[0];
                          }
                          *(_DWORD *)int buf = 136446723;
                          *(void *)&uint8_t buf[4] = v37;
                          *(_WORD *)&_BYTE buf[12] = 2082;
                          *(void *)&buf[14] = v38;
                          *(_WORD *)&_BYTE buf[22] = 2081;
                          *(void *)&uint8_t buf[24] = v39;
                          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEBUG,  "Adding geographic polygonal fence [%{public}s]/%{public}s/%{private}s",  buf,  0x20u);
                        }

                        if (sub_1002921D0(115, 2))
                        {
                          bzero(buf, 0x65CuLL);
                          if (qword_101934870 != -1) {
                            dispatch_once(&qword_101934870, &stru_10182CD98);
                          }
                          v147 = &__p;
                          if (SHIBYTE(v198) < 0) {
                            v147 = (__int128 *)__p;
                          }
                          v148 = &__src;
                          if (v200 < 0) {
                            v148 = (__int128 *)__src;
                          }
                          char v149 = &v201;
                          if ((v201.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                            char v149 = (std::string *)v201.__r_.__value_.__r.__words[0];
                          }
                          LODWORD(v213[0]) = 136446723;
                          *(void **)((char *)v213 + 4) = v147;
                          WORD2(v213[1]) = 2082;
                          *(void **)((char *)&v213[1] + 6) = v148;
                          HIWORD(v213[2]) = 2081;
                          v214 = v149;
                          LODWORD(v157) = 32;
                          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "Adding geographic polygonal fence [%{public}s]/%{public}s/%{private}s",  v213,  v157);
                          v151 = (char *)v150;
                          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v150);
                          if (v151 != buf) {
                            free(v151);
                          }
                        }

                        uint64_t v40 = *(void *)v208;
                        uint64_t v195 = 0LL;
                        *(void *)&double v41 = objc_opt_class(&OBJC_CLASS____CLVertex).n128_u64[0];
                        id v43 = +[NSKeyedUnarchiver unarchivedArrayOfObjectsOfClass:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedArrayOfObjectsOfClass:fromData:error:",  v42,  v40,  &v195,  v41);
                        id v44 = -[NSArray count](v43, "count");
                        if (v195)
                        {
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          __int128 v45 = (os_log_s *)qword_101934978;
                          if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)int buf = 68289282;
                            *(_DWORD *)&uint8_t buf[4] = 0;
                            *(_WORD *)&uint8_t buf[8] = 2082;
                            *(void *)&buf[10] = "";
                            *(_WORD *)&_BYTE buf[18] = 2114;
                            *(void *)&buf[20] = v195;
                            _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unable to get vertices from data in handleRequestRegionMonitoring , error:%{public, location:escape_only}@}",  buf,  0x1Cu);
                            if (qword_101934970 != -1) {
                              dispatch_once(&qword_101934970, &stru_10182CD78);
                            }
                          }

                          uint64_t v46 = (os_log_s *)qword_101934978;
                          if (os_signpost_enabled((os_log_t)qword_101934978))
                          {
                            *(_DWORD *)int buf = 68289282;
                            *(_DWORD *)&uint8_t buf[4] = 0;
                            *(_WORD *)&uint8_t buf[8] = 2082;
                            *(void *)&buf[10] = "";
                            *(_WORD *)&_BYTE buf[18] = 2114;
                            *(void *)&buf[20] = v195;
                            _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v46,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unable to get vertices from data in handleRequestRegionMonitoring",  "{msg%{public}.0s:Unable to get vertices from data in handleRequestRegionMonitoring , error:%{public, location:escape_only}@}",  buf,  0x1Cu);
                          }

                          goto LABEL_385;
                        }

                        __int16 v119 = v44;
                        if ((_DWORD)v193 != (_DWORD)v44)
                        {
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          __int16 v123 = (os_log_s *)qword_101934978;
                          if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)int buf = 67240448;
                            *(_DWORD *)&uint8_t buf[4] = v193;
                            *(_WORD *)&uint8_t buf[8] = 2050;
                            *(void *)&buf[10] = v119;
                            _os_log_impl( (void *)&_mh_execute_header,  v123,  OS_LOG_TYPE_FAULT,  "Number of vertices received doesn't match stored, %{public}d, %{public}lu",  buf,  0x12u);
                          }

                          if (sub_1002921D0(115, 0))
                          {
                            bzero(buf, 0x65CuLL);
                            if (qword_101934970 != -1) {
                              dispatch_once(&qword_101934970, &stru_10182CD78);
                            }
                            LODWORD(v213[0]) = 67240448;
                            HIDWORD(v213[0]) = v193;
                            LOWORD(v213[1]) = 2050;
                            *(void **)((char *)&v213[1] + 2) = v119;
                            LODWORD(v157) = 18;
                            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Number of vertices received doesn't match stored, %{public}d, %{public}lu",  v213,  v157);
                            __int128 v50 = (char *)v124;
                            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v124);
                            break;
                          }

                          goto LABEL_385;
                        }

                        if (kCLPolygonalRegionMinVertices > (unint64_t)(int)v193
                          || kCLPolygonalRegionMaxVertices < (unint64_t)(int)v193)
                        {
                          if (qword_101934970 != -1) {
                            dispatch_once(&qword_101934970, &stru_10182CD78);
                          }
                          v130 = (os_log_s *)qword_101934978;
                          if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)int buf = 67240192;
                            *(_DWORD *)&uint8_t buf[4] = v193;
                            _os_log_impl( (void *)&_mh_execute_header,  v130,  OS_LOG_TYPE_FAULT,  "Number of vertices received invalid, %{public}d, monitoring",  buf,  8u);
                          }

                          if (sub_1002921D0(115, 0))
                          {
                            bzero(buf, 0x65CuLL);
                            if (qword_101934970 != -1) {
                              dispatch_once(&qword_101934970, &stru_10182CD78);
                            }
                            LODWORD(v213[0]) = 67240192;
                            HIDWORD(v213[0]) = v193;
                            LODWORD(v157) = 8;
                            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Number of vertices received invalid, %{public}d, monitoring",  v213,  v157);
                            __int128 v50 = (char *)v131;
                            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v131);
                            break;
                          }

                          goto LABEL_385;
                        }

                        memset(v213, 0, sizeof(v213));
                        sub_10005A29C(v213, (int)v193);
                        if ((int)v193 >= 1)
                        {
                          uint64_t v120 = 0LL;
                          do
                          {
                            objc_msgSend( -[NSArray objectAtIndexedSubscript:](v43, "objectAtIndexedSubscript:", v120),  "coordinate");
                            *(void *)int buf = v121;
                            objc_msgSend( -[NSArray objectAtIndexedSubscript:](v43, "objectAtIndexedSubscript:", v120),  "coordinate");
                            *(void *)&uint8_t buf[8] = v122;
                            sub_10026EE20(v213, buf);
                            ++v120;
                          }

                          while (v120 < (int)v193);
                        }

                        if (SHIBYTE(v200) < 0)
                        {
                          sub_1010DD48C(&v174, (void *)__src, *((unint64_t *)&__src + 1));
                        }

                        else
                        {
                          __int128 v174 = __src;
                          uint64_t v175 = v200;
                        }

                        else {
                          std::string v173 = v201;
                        }
                        if (SHIBYTE(v198) < 0)
                        {
                          sub_1010DD48C(&v171, (void *)__p, *((unint64_t *)&__p + 1));
                        }

                        else
                        {
                          __int128 v171 = __p;
                          uint64_t v172 = v198;
                        }

                        sub_1010DDBC0(v169, "");
                        sub_1009230D4( buf,  (uint64_t)&v174,  (uint64_t)&v173,  (uint64_t)&v171,  (uint64_t)v213,  -1,  (uint64_t)v169,  0LL,  0);
                        if (v170 < 0) {
                          operator delete(v169[0]);
                        }
                        if (SHIBYTE(v172) < 0) {
                          operator delete((void *)v171);
                        }
                        if (SHIBYTE(v175) < 0) {
                          operator delete((void *)v174);
                        }
                        if (v204) {
                          v233 |= 1uLL;
                        }
                        if (v203) {
                          v233 |= 2uLL;
                        }
                        if (HIBYTE(v202)) {
                          v233 |= 4uLL;
                        }
                        if (v190[0]) {
                          v233 |= 8uLL;
                        }
                        if ((_BYTE)v202) {
                          v233 |= 0x10uLL;
                        }
                        int v234 = v194;
                        v132 = *(void **)(*(void *)sub_100265C50(a1) + 16LL);
                        sub_1002718F0((char *)v168, (__int128 *)buf);
                        [v132 addFence:sub_10026ECB8(v168)];
                        sub_10026EDA4((uint64_t)v168);
                        sub_100C6ACCC(a1);
                        sub_10026EDA4((uint64_t)buf);
                        if (v213[0])
                        {
                          v213[1] = v213[0];
                          operator delete(v213[0]);
                        }

            if (qword_1019345D0 != -1) {
              dispatch_once(&qword_1019345D0, &stru_10184D4F8);
            }
            uint64_t v88 = (os_log_s *)qword_1019345D8;
            if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
            {
              *(_WORD *)int buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOffWristPre",  buf,  2u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              LOWORD(v31sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
              LODWORD(v309) = 2;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOffWristPre",  &v310,  v309);
              v266 = (uint8_t *)v265;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v265);
              if (v266 != buf) {
                free(v266);
              }
            }

            int v89 = sub_1008D9630();
            sub_1007382F4(v89);
            unint64_t v75 = 1;
            if ((a4 & 0x20000000) == 0)
            {
LABEL_396:
              if (v75 | v52)
              {
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                uint64_t v92 = (os_log_s *)qword_1019345D8;
                if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                {
                  *(_WORD *)int buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledAggregate",  buf,  2u);
                }

                if (sub_1002921D0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_1019345D0 != -1) {
                    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                  }
                  LOWORD(v31sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
                  LODWORD(v309) = 2;
                  _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledAggregate",  &v310,  v309);
                  uint64_t v232 = (uint8_t *)v231;
                  sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::F allCancelReason)",  "%s\n",  v231);
                  if (v232 != buf) {
                    free(v232);
                  }
                }

                uint64_t v93 = sub_1008D9630();
                sub_1007383AC(v93);
              }

              uint64_t v94 = (a4 >> 30) & 1;
              if ((a4 & 0x40000000) != 0)
              {
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                __int16 v95 = (os_log_s *)qword_1019345D8;
                if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
                {
                  *(_WORD *)int buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfFeatureDisabled",  buf,  2u);
                }

                if (sub_1002921D0(115, 2))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_1019345D0 != -1) {
                    dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                  }
                  LOWORD(v31sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
                  LODWORD(v309) = 2;
                  _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfFeatureDisabled",  &v310,  v309);
                  v270 = (uint8_t *)v269;
                  sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::F allCancelReason)",  "%s\n",  v269);
                  if (v270 != buf) {
                    free(v270);
                  }
                }

                int v96 = sub_1008D9630();
                sub_100738408(v96);
                if ((a4 & 0x80000000) == 0)
                {
LABEL_405:
                  if ((a4 & 0x100000000LL) == 0) {
                    goto LABEL_406;
                  }
                  goto LABEL_429;
                }
              }

              else if ((a4 & 0x80000000) == 0)
              {
                goto LABEL_405;
              }

              if (qword_1019345D0 != -1) {
                dispatch_once(&qword_1019345D0, &stru_10184D4F8);
              }
              __int16 v97 = (os_log_s *)qword_1019345D8;
              if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_DEBUG))
              {
                *(_WORD *)int buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_DEBUG,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOnCharger",  buf,  2u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019345D0 != -1) {
                  dispatch_once(&qword_1019345D0, &stru_10184D4F8);
                }
                LOWORD(v31sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
                LODWORD(v309) = 2;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345D8,  2LL,  "CLFitnessTrackingAllDayAWD: Increasing NumAlertCanceledBecauseOfOnCharger",  &v310,  v309);
                v272 = (uint8_t *)v271;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFallNotifier::trackCancelationReason(const uint64_t, const uint32_t, const CMSPUFall_Types::FallCancelReason)",  "%s\n",  v271);
                if (v272 != buf) {
                  free(v272);
                }
              }

              double v98 = sub_1008D9630();
              sub_10073845C(v98);
              LODWORD(v94) = 1;
              if ((a4 & 0x100000000LL) == 0)
              {
LABEL_406:
                if ((a4 & 0x200000000LL) == 0) {
                  goto LABEL_407;
                }
                goto LABEL_435;
              }

          *(_DWORD *)(a1 + 72) = v62;
          goto LABEL_210;
        case 0xAu:
          *(void *)(a1 + 156) |= 0x10000000uLL;
          uint64_t v65 = *((void *)this + 1);
          if (v65 > 0xFFFFFFFFFFFFFFFBLL || v65 + 4 > *((void *)this + 2)) {
            goto LABEL_209;
          }
          *(_DWORD *)(a1 + 136) = *(_DWORD *)(*(void *)this + v65);
          goto LABEL_191;
        case 0xBu:
          *(void *)(a1 + 156) |= 0x20000000uLL;
          uint64_t v66 = *((void *)this + 1);
          if (v66 > 0xFFFFFFFFFFFFFFFBLL || v66 + 4 > *((void *)this + 2)) {
            goto LABEL_209;
          }
          *(_DWORD *)(a1 + 14sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)this + v66);
          goto LABEL_191;
        case 0xCu:
          *(void *)(a1 + 156) |= 0x8000000uLL;
          unint64_t v67 = *((void *)this + 1);
          if (v67 > 0xFFFFFFFFFFFFFFFBLL || v67 + 4 > *((void *)this + 2)) {
            goto LABEL_209;
          }
          *(_DWORD *)(a1 + 132) = *(_DWORD *)(*(void *)this + v67);
          goto LABEL_191;
        case 0xDu:
          *(void *)(a1 + 156) |= 0x40000uLL;
          id v68 = *((void *)this + 1);
          uint64_t v69 = *((void *)this + 2);
          id v70 = *(void *)this;
          if (v68 <= 0xFFFFFFFFFFFFFFF5LL && v68 + 10 <= v69)
          {
            char v71 = 0;
            CFTypeRef v72 = 0;
            double v73 = 0LL;
            do
            {
              uint64_t v74 = v68 + 1;
              *((void *)this + 1) = v68 + 1;
              unint64_t v75 = *(_BYTE *)(v70 + v68);
              v73 |= (unint64_t)(v75 & 0x7F) << v71;
              if ((v75 & 0x80) == 0) {
                goto LABEL_388;
              }
              v71 += 7;
              id v68 = v74;
              uint64_t v14 = v72++ > 8;
            }

            while (!v14);
LABEL_256:
            LODWORD(v73) = 0;
            goto LABEL_388;
          }

          __int16 v231 = 0;
          uint64_t v232 = 0;
          double v73 = 0LL;
          if (v69 <= v68) {
            uint64_t v69 = *((void *)this + 1);
          }
          while (2)
          {
            if (v69 == v68)
            {
              LODWORD(v73) = 0;
              *((_BYTE *)this + 24) = 1;
            }

            else
            {
              uint64_t v233 = v68 + 1;
              int v234 = *(_BYTE *)(v70 + v68);
              *((void *)this + 1) = v233;
              v73 |= (unint64_t)(v234 & 0x7F) << v231;
              if (v234 < 0)
              {
                v231 += 7;
                id v68 = v233;
                uint64_t v14 = v232++ > 8;
                if (v14) {
                  goto LABEL_256;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v73) = 0;
              }
            }

            break;
          }

          *(_DWORD *)(a1 + 10sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v90;
          goto LABEL_356;
        case 0x12u:
          *(void *)(a1 + 184) |= 0x20000uLL;
          uint64_t v93 = *((void *)this + 1);
          uint64_t v94 = *((void *)this + 2);
          __int16 v95 = *(void *)this;
          if (v93 <= 0xFFFFFFFFFFFFFFF5LL && v93 + 10 <= v94)
          {
            int v96 = 0;
            __int16 v97 = 0;
            double v98 = 0LL;
            do
            {
              __int16 v99 = v93 + 1;
              *((void *)this + 1) = v93 + 1;
              uint64_t v100 = *(_BYTE *)(v95 + v93);
              v98 |= (unint64_t)(v100 & 0x7F) << v96;
              if ((v100 & 0x80) == 0) {
                goto LABEL_388;
              }
              v96 += 7;
              uint64_t v93 = v99;
              uint64_t v14 = v97++ > 8;
            }

            while (!v14);
LABEL_278:
            LODWORD(v9std::istream::~istream(v2, v3 + 8) = 0;
            goto LABEL_388;
          }

          uint64_t v228 = 0;
          __int16 v229 = 0;
          double v98 = 0LL;
          if (v94 <= v93) {
            uint64_t v94 = *((void *)this + 1);
          }
          while (2)
          {
            if (v94 == v93)
            {
              LODWORD(v9std::istream::~istream(v2, v3 + 8) = 0;
              *((_BYTE *)this + 24) = 1;
            }

            else
            {
              uint64_t v230 = v93 + 1;
              __int16 v231 = *(_BYTE *)(v95 + v93);
              *((void *)this + 1) = v230;
              v98 |= (unint64_t)(v231 & 0x7F) << v228;
              if (v231 < 0)
              {
                v228 += 7;
                uint64_t v93 = v230;
                uint64_t v14 = v229++ > 8;
                if (v14) {
                  goto LABEL_278;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v9std::istream::~istream(v2, v3 + 8) = 0;
              }
            }

            break;
          }

LABEL_360:
                        int v47 = 1;
LABEL_361:
                        goto LABEL_385;
                      }

                      if (qword_101934970 != -1) {
                        dispatch_once(&qword_101934970, &stru_10182CD78);
                      }
                      int v96 = (os_log_s *)qword_101934978;
                      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)int buf = 136446210;
                        *(void *)&uint8_t buf[4] = "kCLConnectionMessageReferenceFrameKey";
                        _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                      }

                      if (!sub_1002921D0(115, 0)) {
                        goto LABEL_385;
                      }
                      bzero(buf, 0x65CuLL);
                      if (qword_101934970 != -1) {
LABEL_559:
                      }
                        dispatch_once(&qword_101934970, &stru_10182CD78);
LABEL_305:
                      LODWORD(v213[0]) = 136446210;
                      *(void **)((char *)v213 + 4) = "kCLConnectionMessageReferenceFrameKey";
                      LODWORD(v157) = 12;
                      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  v157);
                      __int128 v50 = (char *)v97;
                      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v97);
                      break;
                    default:
                      int v47 = 0;
                      goto LABEL_361;
                  }

            *(void *)(a1 + 72) = v67;
            goto LABEL_336;
          case 10:
            *(void *)v8 |= 0x20000uLL;
            id v70 = *((void *)this + 1);
            if (v70 > 0xFFFFFFFFFFFFFFFBLL || v70 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 112) = *(_DWORD *)(*(void *)this + v70);
            goto LABEL_335;
          case 11:
            *(void *)v8 |= 0x10000uLL;
            char v71 = *((void *)this + 1);
            if (v71 > 0xFFFFFFFFFFFFFFFBLL || v71 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 10std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(*(void *)this + v71);
            goto LABEL_335;
          case 12:
            *(void *)v8 |= 0x2000000uLL;
            CFTypeRef v72 = *((void *)this + 1);
            if (v72 > 0xFFFFFFFFFFFFFFFBLL || v72 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 144) = *(_DWORD *)(*(void *)this + v72);
            goto LABEL_335;
          case 13:
            *(void *)v8 |= 0x200uLL;
            double v73 = *((void *)this + 1);
            if (v73 > 0xFFFFFFFFFFFFFFFBLL || v73 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)this + v73);
            goto LABEL_335;
          case 14:
            *(void *)v8 |= 0x400uLL;
            uint64_t v74 = *((void *)this + 1);
            if (v74 > 0xFFFFFFFFFFFFFFFBLL || v74 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 84) = *(_DWORD *)(*(void *)this + v74);
            goto LABEL_335;
          case 15:
            *(void *)v8 |= 0x800000uLL;
            unint64_t v75 = *((void *)this + 1);
            if (v75 > 0xFFFFFFFFFFFFFFFBLL || v75 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 136) = *(_DWORD *)(*(void *)this + v75);
            goto LABEL_335;
          case 16:
            *(void *)v8 |= 0x4000uLL;
            char v76 = *((void *)this + 1);
            if (v76 > 0xFFFFFFFFFFFFFFFBLL || v76 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 10sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)this + v76);
            goto LABEL_335;
          case 17:
            *(void *)v8 |= 0x400000uLL;
            uint64_t v77 = *((void *)this + 1);
            if (v77 > 0xFFFFFFFFFFFFFFFBLL || v77 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 132) = *(_DWORD *)(*(void *)this + v77);
            goto LABEL_335;
          case 18:
            *(void *)v8 |= 0x2000uLL;
            BOOL v78 = *((void *)this + 1);
            if (v78 > 0xFFFFFFFFFFFFFFFBLL || v78 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 96) = *(_DWORD *)(*(void *)this + v78);
            goto LABEL_335;
          case 19:
            *(void *)v8 |= 0x8000000uLL;
            uint64_t v79 = *((void *)this + 1);
            if (v79 > 0xFFFFFFFFFFFFFFFBLL || v79 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 152) = *(_DWORD *)(*(void *)this + v79);
            goto LABEL_335;
          case 20:
            *(void *)v8 |= 0x100000uLL;
            uint64_t v80 = *((void *)this + 1);
            if (v80 > 0xFFFFFFFFFFFFFFFBLL || v80 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(void *)this + v80);
            goto LABEL_335;
          case 21:
            *(void *)v8 |= 0x1000uLL;
            uint64_t v81 = *((void *)this + 1);
            if (v81 > 0xFFFFFFFFFFFFFFFBLL || v81 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 92) = *(_DWORD *)(*(void *)this + v81);
            goto LABEL_335;
          case 22:
            *(void *)v8 |= 0x80000uLL;
            uint64_t v82 = *((void *)this + 1);
            if (v82 > 0xFFFFFFFFFFFFFFFBLL || v82 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)this + v82);
            goto LABEL_335;
          case 23:
            *(void *)v8 |= 0x800uLL;
            uint64_t v83 = *((void *)this + 1);
            if (v83 > 0xFFFFFFFFFFFFFFFBLL || v83 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 8std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(*(void *)this + v83);
            goto LABEL_335;
          case 24:
            *(void *)v8 |= 0x4000000uLL;
            uint64_t v84 = *((void *)this + 1);
            if (v84 > 0xFFFFFFFFFFFFFFFBLL || v84 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 14std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(*(void *)this + v84);
            goto LABEL_335;
          case 25:
            *(void *)v8 |= 0x40000000000000uLL;
            double v85 = *((void *)this + 1);
            if (v85 > 0xFFFFFFFFFFFFFFFBLL || v85 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 26sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)this + v85);
            goto LABEL_335;
          case 26:
            *(void *)v8 |= 0x20000000000000uLL;
            uint64_t v86 = *((void *)this + 1);
            if (v86 > 0xFFFFFFFFFFFFFFFBLL || v86 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 256) = *(_DWORD *)(*(void *)this + v86);
            goto LABEL_335;
          case 27:
            *(void *)v8 |= 0x4000000000000000uLL;
            uint64_t v87 = *((void *)this + 1);
            if (v87 > 0xFFFFFFFFFFFFFFFBLL || v87 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 292) = *(_DWORD *)(*(void *)this + v87);
            goto LABEL_335;
          case 28:
            *(void *)v8 |= 0x800000000000uLL;
            uint64_t v88 = *((void *)this + 1);
            if (v88 > 0xFFFFFFFFFFFFFFFBLL || v88 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 232) = *(_DWORD *)(*(void *)this + v88);
            goto LABEL_335;
          case 29:
            *(void *)v8 |= 0x1000000000000uLL;
            int v89 = *((void *)this + 1);
            if (v89 > 0xFFFFFFFFFFFFFFFBLL || v89 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 236) = *(_DWORD *)(*(void *)this + v89);
            goto LABEL_335;
          case 30:
            *(void *)v8 |= 0x1000000000000000uLL;
            __int128 v90 = *((void *)this + 1);
            if (v90 > 0xFFFFFFFFFFFFFFFBLL || v90 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 284) = *(_DWORD *)(*(void *)this + v90);
            goto LABEL_335;
          case 31:
            *(void *)v8 |= 0x10000000000000uLL;
            __int16 v91 = *((void *)this + 1);
            if (v91 > 0xFFFFFFFFFFFFFFFBLL || v91 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 252) = *(_DWORD *)(*(void *)this + v91);
            goto LABEL_335;
          case 32:
            *(void *)v8 |= 0x800000000000000uLL;
            uint64_t v92 = *((void *)this + 1);
            if (v92 > 0xFFFFFFFFFFFFFFFBLL || v92 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 28sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)this + v92);
            goto LABEL_335;
          case 33:
            *(void *)v8 |= 0x8000000000000uLL;
            uint64_t v93 = *((void *)this + 1);
            if (v93 > 0xFFFFFFFFFFFFFFFBLL || v93 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 24std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(*(void *)this + v93);
            goto LABEL_335;
          case 34:
            *(_BYTE *)(v8 + 8) |= 1u;
            uint64_t v94 = *((void *)this + 1);
            if (v94 > 0xFFFFFFFFFFFFFFFBLL || v94 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 30sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)this + v94);
            goto LABEL_335;
          case 35:
            *(void *)v8 |= 0x200000000000000uLL;
            __int16 v95 = *((void *)this + 1);
            if (v95 > 0xFFFFFFFFFFFFFFFBLL || v95 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 272) = *(_DWORD *)(*(void *)this + v95);
            goto LABEL_335;
          case 36:
            *(void *)v8 |= 0x4000000000000uLL;
            int v96 = *((void *)this + 1);
            if (v96 > 0xFFFFFFFFFFFFFFFBLL || v96 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 244) = *(_DWORD *)(*(void *)this + v96);
            goto LABEL_335;
          case 37:
            *(void *)v8 |= 0x100000000000000uLL;
            __int16 v97 = *((void *)this + 1);
            if (v97 > 0xFFFFFFFFFFFFFFFBLL || v97 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 26std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(*(void *)this + v97);
            goto LABEL_335;
          case 38:
            *(void *)v8 |= 0x2000000000000uLL;
            double v98 = *((void *)this + 1);
            if (v98 > 0xFFFFFFFFFFFFFFFBLL || v98 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 24sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)this + v98);
            goto LABEL_335;
          case 39:
            *(void *)v8 |= 0x8000000000000000LL;
            __int16 v99 = *((void *)this + 1);
            if (v99 > 0xFFFFFFFFFFFFFFFBLL || v99 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 296) = *(_DWORD *)(*(void *)this + v99);
            goto LABEL_335;
          case 40:
            *(void *)v8 |= 0x800000000uLL;
            uint64_t v100 = *((void *)this + 1);
            if (v100 > 0xFFFFFFFFFFFFFFFBLL || v100 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 184) = *(_DWORD *)(*(void *)this + v100);
            goto LABEL_335;
          case 41:
            *(void *)v8 |= 0x400000000uLL;
            __int16 v101 = *((void *)this + 1);
            if (v101 > 0xFFFFFFFFFFFFFFFBLL || v101 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 18sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)this + v101);
            goto LABEL_335;
          case 42:
            *(void *)v8 |= 0x80000000000uLL;
            int v102 = *((void *)this + 1);
            if (v102 > 0xFFFFFFFFFFFFFFFBLL || v102 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 216) = *(_DWORD *)(*(void *)this + v102);
            goto LABEL_335;
          case 43:
            *(void *)v8 |= 0x10000000uLL;
            __int16 v103 = *((void *)this + 1);
            if (v103 > 0xFFFFFFFFFFFFFFFBLL || v103 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 156) = *(_DWORD *)(*(void *)this + v103);
            goto LABEL_335;
          case 44:
            *(void *)v8 |= 0x20000000uLL;
            int v104 = *((void *)this + 1);
            if (v104 > 0xFFFFFFFFFFFFFFFBLL || v104 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 16sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)this + v104);
            goto LABEL_335;
          case 45:
            *(void *)v8 |= 0x20000000000uLL;
            __int16 v105 = *((void *)this + 1);
            if (v105 > 0xFFFFFFFFFFFFFFFBLL || v105 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 20std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(*(void *)this + v105);
            goto LABEL_335;
          case 46:
            *(void *)v8 |= 0x200000000uLL;
            int v106 = *((void *)this + 1);
            if (v106 > 0xFFFFFFFFFFFFFFFBLL || v106 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 176) = *(_DWORD *)(*(void *)this + v106);
            goto LABEL_335;
          case 47:
            *(void *)v8 |= 0x10000000000uLL;
            uint64_t v107 = *((void *)this + 1);
            if (v107 > 0xFFFFFFFFFFFFFFFBLL || v107 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 204) = *(_DWORD *)(*(void *)this + v107);
            goto LABEL_335;
          case 48:
            *(void *)v8 |= (unint64_t)&_mh_execute_header;
            char v108 = *((void *)this + 1);
            if (v108 > 0xFFFFFFFFFFFFFFFBLL || v108 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 172) = *(_DWORD *)(*(void *)this + v108);
            goto LABEL_335;
          case 49:
            *(void *)v8 |= 0x200000000000uLL;
            v109 = *((void *)this + 1);
            if (v109 > 0xFFFFFFFFFFFFFFFBLL || v109 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 224) = *(_DWORD *)(*(void *)this + v109);
            goto LABEL_335;
          case 50:
            *(void *)v8 |= 0x4000000000uLL;
            id v110 = *((void *)this + 1);
            if (v110 > 0xFFFFFFFFFFFFFFFBLL || v110 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 196) = *(_DWORD *)(*(void *)this + v110);
            goto LABEL_335;
          case 51:
            *(void *)v8 |= 0x80000000uLL;
            uint64_t v111 = *((void *)this + 1);
            if (v111 > 0xFFFFFFFFFFFFFFFBLL || v111 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 16std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(*(void *)this + v111);
            goto LABEL_335;
          case 52:
            *(void *)v8 |= 0x2000000000uLL;
            uint64_t v112 = *((void *)this + 1);
            if (v112 > 0xFFFFFFFFFFFFFFFBLL || v112 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 192) = *(_DWORD *)(*(void *)this + v112);
            goto LABEL_335;
          case 53:
            *(void *)v8 |= 0x40000000uLL;
            uint64_t v113 = *((void *)this + 1);
            if (v113 > 0xFFFFFFFFFFFFFFFBLL || v113 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 164) = *(_DWORD *)(*(void *)this + v113);
            goto LABEL_335;
          case 54:
            *(void *)v8 |= 0x100000000000uLL;
            int v114 = *((void *)this + 1);
            if (v114 > 0xFFFFFFFFFFFFFFFBLL || v114 + 4 > *((void *)this + 2)) {
              goto LABEL_251;
            }
            *(_DWORD *)(a1 + 22sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)this + v114);
            goto LABEL_335;
          case 55:
            *(void *)v8 |= 8uLL;
            __int16 v115 = *((void *)this + 1);
            double v116 = *((void *)this + 2);
            __int16 v117 = *(void *)this;
            if (v115 <= 0xFFFFFFFFFFFFFFF5LL && v115 + 10 <= v116)
            {
              uint64_t v118 = 0;
              __int16 v119 = 0;
              uint64_t v120 = 0LL;
              do
              {
                uint64_t v121 = v115 + 1;
                *((void *)this + 1) = v115 + 1;
                uint64_t v122 = *(_BYTE *)(v117 + v115);
                v120 |= (unint64_t)(v122 & 0x7F) << v118;
                if ((v122 & 0x80) == 0) {
                  goto LABEL_364;
                }
                v118 += 7;
                __int16 v115 = v121;
                uint64_t v15 = v119++ > 8;
              }

              while (!v15);
LABEL_311:
              uint64_t v120 = 0LL;
              goto LABEL_364;
            }

            __int128 v177 = 0;
            int v178 = 0;
            uint64_t v120 = 0LL;
            if (v116 <= v115) {
              double v116 = *((void *)this + 1);
            }
            while (2)
            {
              if (v116 == v115)
              {
                uint64_t v120 = 0LL;
                *((_BYTE *)this + 24) = 1;
              }

              else
              {
                std::string v179 = v115 + 1;
                v180 = *(_BYTE *)(v117 + v115);
                *((void *)this + 1) = v179;
                v120 |= (unint64_t)(v180 & 0x7F) << v177;
                if (v180 < 0)
                {
                  v177 += 7;
                  __int16 v115 = v179;
                  uint64_t v15 = v178++ > 8;
                  if (v15) {
                    goto LABEL_311;
                  }
                  continue;
                }

                if (*((_BYTE *)this + 24)) {
                  uint64_t v120 = 0LL;
                }
              }

              break;
            }

LABEL_479:
                  if (v50 != buf) {
                    free(v50);
                  }
                  goto LABEL_385;
                }

                if (qword_101934970 != -1) {
                  dispatch_once(&qword_101934970, &stru_10182CD78);
                }
                unint64_t v30 = (os_log_s *)qword_101934978;
                if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                {
                  uint64_t v31 = *(void *)(a1 + 24);
                  *(_DWORD *)int buf = 138543362;
                  *(void *)&uint8_t buf[4] = v31;
                  _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_FAULT,  "Client %{public}@ does not have the appropriate entitlement to act as an emergency service",  buf,  0xCu);
                }

                if (sub_1002921D0(115, 0))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_101934970 != -1) {
                    dispatch_once(&qword_101934970, &stru_10182CD78);
                  }
                  int v32 = *(void **)(a1 + 24);
                  LODWORD(v213[0]) = 138543362;
                  *(void **)((char *)v213 + 4) = v32;
                  _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Client %{public}@ does not have the appropriate entitlement to act as an emergency service",  v213,  12);
                  id v9 = (char *)v33;
                  sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v33);
LABEL_118:
                  if (v9 != buf) {
                    free(v9);
                  }
                }
              }

              else
              {
                if (qword_101934970 != -1) {
                  dispatch_once(&qword_101934970, &stru_10182CD78);
                }
                uint64_t v20 = (os_log_s *)qword_101934978;
                if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)int buf = 136446210;
                  *(void *)&uint8_t buf[4] = "kCLConnectionMessageEmergencyKey";
                  _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
                }

                if (sub_1002921D0(115, 0))
                {
                  bzero(buf, 0x65CuLL);
                  if (qword_101934970 != -1) {
                    dispatch_once(&qword_101934970, &stru_10182CD78);
                  }
                  LODWORD(v213[0]) = 136446210;
                  *(void **)((char *)v213 + 4) = "kCLConnectionMessageEmergencyKey";
                  _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  12);
                  id v9 = (char *)v21;
                  sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v21);
                  goto LABEL_118;
                }
              }
            }

            else
            {
              if (qword_101934970 != -1) {
                dispatch_once(&qword_101934970, &stru_10182CD78);
              }
              __int16 v18 = (os_log_s *)qword_101934978;
              if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)int buf = 136446210;
                *(void *)&uint8_t buf[4] = "kCLConnectionMessageConservativeEntry";
                _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934970 != -1) {
                  dispatch_once(&qword_101934970, &stru_10182CD78);
                }
                LODWORD(v213[0]) = 136446210;
                *(void **)((char *)v213 + 4) = "kCLConnectionMessageConservativeEntry";
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  12);
                id v9 = (char *)v19;
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v19);
                goto LABEL_118;
              }
            }
          }

          else
          {
            if (qword_101934970 != -1) {
              dispatch_once(&qword_101934970, &stru_10182CD78);
            }
            uint64_t v16 = (os_log_s *)qword_101934978;
            if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "kCLConnectionMessageNotifyOnExitKey";
              _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
            }

            if (sub_1002921D0(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934970 != -1) {
                dispatch_once(&qword_101934970, &stru_10182CD78);
              }
              LODWORD(v213[0]) = 136446210;
              *(void **)((char *)v213 + 4) = "kCLConnectionMessageNotifyOnExitKey";
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  12);
              id v9 = (char *)v17;
              sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v17);
              goto LABEL_118;
            }
          }
        }

        else
        {
          if (qword_101934970 != -1) {
            dispatch_once(&qword_101934970, &stru_10182CD78);
          }
          uint64_t v14 = (os_log_s *)qword_101934978;
          if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "kCLConnectionMessageNotifyOnEntryKey";
            _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934970 != -1) {
              dispatch_once(&qword_101934970, &stru_10182CD78);
            }
            LODWORD(v213[0]) = 136446210;
            *(void **)((char *)v213 + 4) = "kCLConnectionMessageNotifyOnEntryKey";
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  12);
            id v9 = (char *)v15;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v15);
            goto LABEL_118;
          }
        }
      }

      else
      {
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_10182CD78);
        }
        unsigned __int16 v12 = (os_log_s *)qword_101934978;
        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "kCLConnectionMessageNameKey";
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934970 != -1) {
            dispatch_once(&qword_101934970, &stru_10182CD78);
          }
          LODWORD(v213[0]) = 136446210;
          *(void **)((char *)v213 + 4) = "kCLConnectionMessageNameKey";
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  12);
          id v9 = (char *)v13;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v13);
          goto LABEL_118;
        }
      }
    }

    else
    {
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_10182CD78);
      }
      id v10 = (os_log_s *)qword_101934978;
      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "kCLConnectionMessageSubscribeKey";
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_10182CD78);
        }
        LODWORD(v213[0]) = 136446210;
        *(void **)((char *)v213 + 4) = "kCLConnectionMessageSubscribeKey";
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  12);
        id v9 = (char *)v11;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v11);
        goto LABEL_118;
      }
    }
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_10182CD78);
    }
    id v7 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "kCLConnectionMessageRegionTypeKey";
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Couldn't get value for key %{public}s",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_10182CD78);
      }
      LODWORD(v213[0]) = 136446210;
      *(void **)((char *)v213 + 4) = "kCLConnectionMessageRegionTypeKey";
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Couldn't get value for key %{public}s",  v213,  12);
      id v9 = (char *)v8;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::handleRequestRegionMonitoring(BOOL, const CLNameValuePair &)",  "%s\n",  v8);
      goto LABEL_118;
    }
  }

        *(void *)(a1 + 16) = v109;
        goto LABEL_522;
      case 0xEu:
        *(void *)(a1 + 192) |= 0x80uLL;
        uint64_t v112 = *((void *)this + 1);
        uint64_t v113 = *((void *)this + 2);
        int v114 = *(void *)this;
        if (v112 <= 0xFFFFFFFFFFFFFFF5LL && v112 + 10 <= v113)
        {
          __int16 v115 = 0;
          double v116 = 0;
          __int16 v117 = 0LL;
          do
          {
            uint64_t v118 = v112 + 1;
            *((void *)this + 1) = v112 + 1;
            __int16 v119 = *(_BYTE *)(v114 + v112);
            v117 |= (unint64_t)(v119 & 0x7F) << v115;
            if ((v119 & 0x80) == 0) {
              goto LABEL_482;
            }
            v115 += 7;
            uint64_t v112 = v118;
            uint64_t v14 = v116++ > 8;
          }

          while (!v14);
LABEL_327:
          LODWORD(v117) = 0;
          goto LABEL_482;
        }

        v283 = 0;
        v284 = 0;
        __int16 v117 = 0LL;
        if (v113 <= v112) {
          uint64_t v113 = *((void *)this + 1);
        }
        while (2)
        {
          if (v113 == v112)
          {
            LODWORD(v117) = 0;
            *((_BYTE *)this + 24) = 1;
          }

          else
          {
            v285 = v112 + 1;
            v286 = *(_BYTE *)(v114 + v112);
            *((void *)this + 1) = v285;
            v117 |= (unint64_t)(v286 & 0x7F) << v283;
            if (v286 < 0)
            {
              v283 += 7;
              uint64_t v112 = v285;
              uint64_t v14 = v284++ > 8;
              if (v14) {
                goto LABEL_327;
              }
              continue;
            }

            if (*((_BYTE *)this + 24)) {
              LODWORD(v117) = 0;
            }
          }

          break;
        }

LABEL_393:
}

                                                                id v39 = (unsigned __int8 *)*((void *)this + 1);
                                                                int v178 = *v39;
                                                                if (v178 == 145)
                                                                {
                                                                  if (v39[1] == 1)
                                                                  {
                                                                    while (1)
                                                                    {
                                                                      *((void *)this + 1) = v39 + 2;
LABEL_400:
                                                                      if (wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback( (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)0x91,  TagFallback) != 2)
                                                                      {
                                                                        wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v224,  3LL,  "/AppleInternal/Library/BuildRoots/9fd3fc02-a7d b-11ef-98ff-a6e88e557b55/Applications/Xcode.ap p/Contents/Developer/Platforms/AppleTVOS.platf orm/Developer/SDKs/AppleTVOS18.2.Internal.sdk/ usr/local/include/google/protobuf/wire_format_lite_inl.h",  247LL);
                                                                        std::string v179 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v224,  "CHECK failed: (UInt32Size(tag)) == (tag_size): ");
                                                                        wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=( &v223,  v179);
                                                                        wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v224);
                                                                      }

                                                                      if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v224) & 1) == 0) {
                                                                        return 0LL;
                                                                      }
                                                                      v180 = *(void *)v224;
                                                                      uint64_t v181 = *(_DWORD *)(a1 + 248);
                                                                      if (v181 == *(_DWORD *)(a1 + 252))
                                                                      {
                                                                        sub_10008D024(v206, v181 + 1);
                                                                        uint64_t v181 = *(_DWORD *)(a1 + 248);
                                                                      }

                                                                      v182 = *(void *)(a1 + 240);
                                                                      int v183 = v181 + 1;
                                                                      *(_DWORD *)(a1 + 24std::istream::~istream(v2, v3 + 8) = v181 + 1;
                                                                      *(void *)(v182 + 8LL * v181) = v180;
                                                                      char v184 = (unsigned __int8 *)*((void *)this + 1);
                                                                      __int128 v185 = *((_DWORD *)this + 4) - (_DWORD)v184;
                                                                      if (v185 >= 1)
                                                                      {
                                                                        __int16 v186 = v185 / 0xAu;
                                                                        std::string v187 = v186 >= *(_DWORD *)(a1 + 252) - v183
                                                                             ? *(_DWORD *)(a1 + 252) - v183
                                                                             : v186;
                                                                        if (v187 >= 1)
                                                                        {
                                                                          __int128 v188 = 0;
                                                                          while (*v184 == 145 && v184[1] == 1)
                                                                          {
                                                                            uint64_t v189 = *(void *)(v184 + 2);
                                                                            if (v183 >= *(_DWORD *)(a1 + 252))
                                                                            {
                                                                              wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v224,  3LL,  "/AppleInternal/Library/BuildRoots/9fd3fc 02-a7db-11ef-98ff-a6e88e557b55/Applicati ons/Xcode.app/Contents/Developer/Platfor ms/AppleTVOS.platform/Developer/SDKs/App leTVOS18.2.Internal.sdk/usr/local/includ e/google/protobuf/repeated_field.h",  602LL);
                                                                              v190 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v224,  "CHECK failed: (size()) < (Capacity()): ");
                                                                              wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=( &v223,  v190);
                                                                              wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v224);
                                                                              int v183 = *(_DWORD *)(a1 + 248);
                                                                              v182 = *(void *)(a1 + 240);
                                                                            }

                                                                            *(_DWORD *)(a1 + 24std::istream::~istream(v2, v3 + 8) = v183 + 1;
                                                                            *(void *)(v182 + 8LL * v183) = v189;
                                                                            ++v188;
                                                                            v184 += 10;
                                                                            ++v183;
                                                                            if (v187 == v188)
                                                                            {
                                                                              __int128 v188 = v187;
                                                                              break;
                                                                            }
                                                                          }

                                                                          if (v188) {
                                                                            wireless_diagnostics::google::protobuf::io::CodedInputStream::Skip( this,  10 * v188);
                                                                          }
                                                                        }
                                                                      }

void sub_10026E0B4(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x6FF]) < 0) {
    operator delete((void *)STACK[0x6E8]);
  }
  if (SLOBYTE(STACK[0x717]) < 0) {
    operator delete((void *)STACK[0x700]);
  }
  if (SLOBYTE(STACK[0x72F]) < 0) {
    operator delete((void *)STACK[0x718]);
  }
  if (SLOBYTE(STACK[0x747]) < 0) {
    operator delete((void *)STACK[0x730]);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10026E430(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 24);
  uint64_t v3 = *(void **)(a1 + 48);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  return a1;
}

uint64_t sub_10026E490(uint64_t a1)
{
  uint64_t v2 = sub_100C6AC9C(a1);
  if (v5 < 0) {
    operator delete(__p);
  }
  return v2;
}

void sub_10026E4E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10026E504(uint64_t a1)
{
  uint64_t v2 = sub_100C6AC9C(a1);
  if (v5 < 0) {
    operator delete(__p);
  }
  return v2;
}

void sub_10026E55C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10026E578(uint64_t a1)
{
  uint64_t v2 = sub_100C6AC9C(a1);
  if (v5 < 0) {
    operator delete(__p);
  }
  return v2;
}

void sub_10026E5D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10026E5EC(uint64_t a1)
{
  uint64_t v2 = sub_100C6AC9C(a1);
  if (v5 < 0) {
    operator delete(__p);
  }
  return v2;
}

void sub_10026E644( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10026E660(uint64_t a1)
{
  uint64_t v2 = sub_100C6AC9C(a1);
  if (v5 < 0) {
    operator delete(__p);
  }
  return v2;
}

void sub_10026E6B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10026E6D4(uint64_t a1)
{
  uint64_t v2 = sub_100C6AC9C(a1);
  if (v5 < 0) {
    operator delete(__p);
  }
  return v2;
}

void sub_10026E72C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10026E748(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = v30;
  if ((v30 & 0x80u) != 0) {
    unint64_t v4 = (unint64_t)v29[1];
  }
  if (v4)
  {
    sub_100FE370C((uint64_t)v21);
    char v5 = (char *)v29;
  }

  else
  {
    char v5 = (char *)&v25;
  }

  sub_1002ACD58(a2, "kCLConnectionMessageOnBehalfOfKey", v5);
  LODWORD(buf) = *(_DWORD *)(a1 + 180);
  sub_1002AC220(a2, "kCLConnectionMessageReferenceFrameKey", &buf);
  LOBYTE(buf) = *(_BYTE *)(a1 + 160) & 1;
  sub_1002AB3FC(a2, "kCLConnectionMessageNotifyOnEntryKey", &buf);
  LOBYTE(buf) = (*(_BYTE *)(a1 + 160) & 2) != 0;
  sub_1002AB3FC(a2, "kCLConnectionMessageNotifyOnExitKey", &buf);
  LOBYTE(buf) = (*(_BYTE *)(a1 + 160) & 4) != 0;
  sub_1002AB3FC(a2, "kCLConnectionMessageConservativeEntry", &buf);
  LOBYTE(buf) = (*(_BYTE *)(a1 + 160) & 0x10) != 0;
  sub_1002AB3FC(a2, "kCLConnectionMessageEmergencyKey", &buf);
  if (*(void *)(a1 + 232) == *(void *)(a1 + 224))
  {
    LOBYTE(v19) = (*(_BYTE *)(a1 + 160) & 0x40) != 0;
    sub_1002AB3FC(a2, "kCLConnectionMessageMonitoringNearby", &v19);
    if ((*(_BYTE *)(a1 + 160) & 0x80) != 0) {
      LODWORD(buf) = 3;
    }
    else {
      LODWORD(buf) = 1;
    }
    sub_1002AC220(a2, "kCLConnectionMessageRegionTypeKey", &buf);
    sub_1002AC7B8(a2, "kCLConnectionMessageLatitudeKey", (const void *)(a1 + 72));
    sub_1002AC7B8(a2, "kCLConnectionMessageLongitudeKey", (const void *)(a1 + 80));
    sub_1002AC7B8(a2, "kCLConnectionMessageRadiusKey", (const void *)(a1 + 88));
    sub_1002AC7B8(a2, "kCLConnectionMessageDesiredAccuracyKey", (const void *)(a1 + 104));
    LOBYTE(buf) = (*(_BYTE *)(a1 + 160) & 0x20) != 0;
    sub_1002AB3FC(a2, "kCLConnectionMessageLowPowerFenceKey", &buf);
    goto LABEL_24;
  }

  LOBYTE(buf) = (*(_BYTE *)(a1 + 160) & 8) != 0;
  sub_1002AB3FC(a2, "kCLConnectionMessageMonitoringNearby", &buf);
  LODWORD(buf) = 2;
  sub_1002AC220(a2, "kCLConnectionMessageRegionTypeKey", &buf);
  uint64_t v6 = *(void *)(a1 + 232) - *(void *)(a1 + 224);
  unint64_t v7 = (unint64_t)v6 >> 4;
  int v20 = (unint64_t)v6 >> 4;
  uint64_t v8 = (int)(v6 >> 4);
  id v9 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v8);
  if ((int)v7 >= 1)
  {
    uint64_t v10 = 0LL;
    uint64_t v11 = 0LL;
    do
    {
      id v12 = objc_msgSend( [_CLVertex alloc],  "initWithClientCoordinate:",  *(double *)(*(void *)(a1 + 224) + v10),  *(double *)(*(void *)(a1 + 224) + v10 + 8));
      -[NSMutableArray addObject:](v9, "addObject:", v12);

      ++v11;
      v10 += 16LL;
    }

    while (v11 < v8);
  }

  uint64_t v19 = 0LL;
  int v13 = +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v9,  1LL,  &v19);
  if (!v19)
  {
    uint64_t v17 = (uint64_t)v13;

    sub_1002AC220(a2, "kCLConnectionMessagePolygonalVerticesCountKey", &v20);
    sub_1002AB370(a2, "kCLConnectionMessagePolygonalVerticesKey", v17);
LABEL_24:
    uint64_t v16 = 1LL;
    goto LABEL_25;
  }

  if (qword_101934970 != -1) {
    dispatch_once(&qword_101934970, &stru_10182CD78);
  }
  uint64_t v14 = (os_log_s *)qword_101934978;
  if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
  {
    uint64_t buf = 68289282LL;
    __int16 v36 = 2082;
    uint64_t v37 = "";
    __int16 v38 = 2114;
    uint64_t v39 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unable to encode vertices in populateGeographicRegion, error:%{public, location:escape_only}@}",  (uint8_t *)&buf,  0x1Cu);
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_10182CD78);
    }
  }

  uint64_t v15 = (os_log_s *)qword_101934978;
  if (os_signpost_enabled((os_log_t)qword_101934978))
  {
    uint64_t buf = 68289282LL;
    __int16 v36 = 2082;
    uint64_t v37 = "";
    __int16 v38 = 2114;
    uint64_t v39 = v19;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unable to encode vertices in populateGeographicRegion",  "{msg%{public}.0s:Unable to encode vertices in populateGeographicRegion, error:%{public, location:escape_only}@}",  (uint8_t *)&buf,  0x1Cu);
  }

  uint64_t v16 = 0LL;
LABEL_25:
  if (v34 < 0) {
    operator delete(__p);
  }
  if (v32 < 0) {
    operator delete(v31);
  }
  if (v28 < 0) {
    operator delete(v27);
  }
  if (v26 < 0) {
    operator delete(v25);
  }
  if (v24 < 0) {
    operator delete(v23);
  }
  if (v22 < 0) {
    operator delete(v21[0]);
  }
  return v16;
}

void sub_10026EC64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

id sub_10026ECB8(__int128 *a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3321888768LL;
  _DWORD v3[2] = sub_100272E20;
  v3[3] = &unk_10182CF60;
  sub_1002718F0((char *)&v4, a1);
  id v1 = [v3 copy];
  if (__p)
  {
    uint64_t v14 = __p;
    operator delete(__p);
  }

  if (v11 < 0) {
    operator delete(v10);
  }
  if (v9 < 0) {
    operator delete(v8);
  }
  if (v7 < 0) {
    operator delete(v6);
  }
  if (v5 < 0) {
    operator delete(v4);
  }
  return v1;
}

void sub_10026ED90(_Unwind_Exception *a1)
{
}

uint64_t sub_10026EDA4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 224);
  if (v2)
  {
    *(void *)(a1 + 232) = v2;
    operator delete(v2);
  }

  return a1;
}

void sub_10026EE20(void **a1, _OWORD *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  char v7 = *(_OWORD **)(v4 - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = ((char *)v7 - (_BYTE *)*a1) >> 4;
    unint64_t v10 = v9 + 1;
    uint64_t v11 = v5 - (void)*a1;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12) {
      int v13 = (char *)sub_100037038(v4, v12);
    }
    else {
      int v13 = 0LL;
    }
    uint64_t v14 = &v13[16 * v9];
    uint64_t v15 = &v13[16 * v12];
    *(_OWORD *)uint64_t v14 = *a2;
    uint64_t v8 = v14 + 16;
    uint64_t v17 = (char *)*a1;
    uint64_t v16 = (char *)a1[1];
    if (v16 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v16 - 1);
        v14 -= 16;
        v16 -= 16;
      }

      while (v16 != v17);
      uint64_t v16 = (char *)*a1;
    }

    *a1 = v14;
    a1[1] = v8;
    a1[2] = v15;
    if (v16) {
      operator delete(v16);
    }
  }

  else
  {
    _OWORD *v7 = *a2;
    uint64_t v8 = v7 + 1;
  }

  a1[1] = v8;
}

uint64_t sub_10026EF0C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 216LL))(a2, a1 + 32);
}

uint64_t sub_10026EF24(uint64_t a1, uint64_t a2)
{
  return sub_100272138(a1 + 32, a2 + 32);
}

uint64_t sub_10026EF30(uint64_t a1)
{
  return sub_1002722AC(a1 + 32);
}

uint64_t sub_10026EF3C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 240LL))(a2, a1 + 32);
}

uint64_t sub_10026EF54(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 248LL))(a2, a1 + 32);
}

void sub_10026EF6C(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v7 = *(unsigned __int8 *)(a4 + 23);
  if ((v7 & 0x80u) == 0LL) {
    uint64_t v8 = (void *)*(unsigned __int8 *)(a4 + 23);
  }
  else {
    uint64_t v8 = *(void **)(a4 + 8);
  }
  unint64_t v9 = v107;
  if ((v107 & 0x80u) != 0) {
    unint64_t v9 = (unint64_t)__p[1];
  }
  if ((v107 & 0x80u) == 0) {
    unint64_t v10 = __p;
  }
  else {
    unint64_t v10 = (void **)__p[0];
  }
  if ((v7 & 0x80) != 0)
  {
    goto LABEL_17;
  }

  if (!*(_BYTE *)(a4 + 23))
  {
LABEL_17:
    sub_1002A5370(v105);
    sub_1002A5370(v104);
    if ((*(_BYTE *)(a4 + 161) & 1) == 0)
    {
      switch(*a3)
      {
        case 0:
        case 1:
          if (sub_10026E748(a4, (uint64_t)v105))
          {
            LODWORD(buf.__r_.__value_.__l.__data_) = *a3 != 0;
            sub_1002AC220((uint64_t)v105, "kCLConnectionMessageEventKey", &buf);
            if (qword_101934870 != -1) {
              dispatch_once(&qword_101934870, &stru_10182CD98);
            }
            int v102 = (uint64_t *)(a4 + 500);
            unint64_t v12 = (os_log_s *)qword_101934878;
            if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
            {
              int v13 = *a3;
              int v14 = *(char *)(a4 + 23);
              uint64_t v15 = *(const void **)a4;
              uint64_t v16 = *(void *)(a4 + 24);
              int v17 = *(char *)(a4 + 47);
              uint64_t v94 = *v102;
              uint64_t v95 = *(void *)(a4 + 508);
              uint64_t v96 = *(void *)(a4 + 516);
              int v98 = *(_DWORD *)(a4 + 592);
              uint64_t v100 = *(void *)(a4 + 152);
              BOOL v18 = sub_100270760(a4);
              double v19 = *(double *)(a4 + 96);
              if (v17 >= 0) {
                uint64_t v20 = a4 + 24;
              }
              else {
                uint64_t v20 = v16;
              }
              uint64_t v21 = "exit";
              if (v14 >= 0) {
                std::string::size_type v22 = a4;
              }
              else {
                std::string::size_type v22 = (std::string::size_type)v15;
              }
              unsigned int v23 = *(_DWORD *)(a4 + 160);
              if (!v13) {
                uint64_t v21 = "entry";
              }
              uint64_t v25 = *(void *)(a4 + 224);
              uint64_t v24 = *(void *)(a4 + 232);
              int v26 = *(unsigned __int8 *)(a4 + 188);
              LODWORD(buf.__r_.__value_.__l.__data_) = 136383747;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
              WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
              *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v22;
              HIWORD(buf.__r_.__value_.__r.__words[2]) = 2081;
              *(void *)v130 = v20;
              *(_WORD *)&v130[8] = 2049;
              *(void *)&v130[10] = v94;
              __int16 v131 = 2049;
              uint64_t v132 = v95;
              __int16 v133 = 2050;
              uint64_t v134 = v96;
              __int16 v135 = 1026;
              int v136 = v98;
              __int16 v137 = 2049;
              uint64_t v138 = v100;
              __int16 v139 = 1025;
              BOOL v140 = v18;
              __int16 v141 = 1025;
              BOOL v142 = v19 >= 7000.0;
              __int16 v143 = 1025;
              int v144 = (v23 >> 4) & 1;
              __int16 v145 = 1025;
              BOOL v146 = v24 != v25;
              __int16 v147 = 1025;
              int v148 = v26;
              _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "Notifying client of fence %{private}s for %{public}s/%{private}s (location <%{private}+.8f,%{private}+.8 f> acc %{public}.2f type %{public}d, \t\t\t\t\t\t\tsinceLast,%{private}.1f, fence,%{private}d,%{private} d,%{private}d,%{private}d,%{private}d",  (uint8_t *)&buf,  0x6Cu);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(&buf, 0x65CuLL);
              if (qword_101934870 != -1) {
                dispatch_once(&qword_101934870, &stru_10182CD98);
              }
              int v56 = *a3;
              int v57 = *(char *)(a4 + 23);
              uint64_t v58 = *(const void **)a4;
              uint64_t v59 = *(void *)(a4 + 24);
              int v60 = *(char *)(a4 + 47);
              uint64_t v61 = *v102;
              uint64_t v62 = *(void *)(a4 + 508);
              uint64_t v97 = *(void *)(a4 + 516);
              int v99 = *(_DWORD *)(a4 + 592);
              uint64_t v101 = qword_101934878;
              uint64_t v103 = *(void *)(a4 + 152);
              BOOL v63 = sub_100270760(a4);
              double v64 = *(double *)(a4 + 96);
              if (v60 >= 0) {
                uint64_t v65 = a4 + 24;
              }
              else {
                uint64_t v65 = v59;
              }
              uint64_t v66 = "exit";
              if (v57 >= 0) {
                std::string::size_type v67 = a4;
              }
              else {
                std::string::size_type v67 = (std::string::size_type)v58;
              }
              unsigned int v68 = *(_DWORD *)(a4 + 160);
              if (!v56) {
                uint64_t v66 = "entry";
              }
              uint64_t v70 = *(void *)(a4 + 224);
              uint64_t v69 = *(void *)(a4 + 232);
              int v71 = *(unsigned __int8 *)(a4 + 188);
              LODWORD(v108.__r_.__value_.__l.__data_) = 136383747;
              *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v66;
              WORD2(v108.__r_.__value_.__r.__words[1]) = 2082;
              *(std::string::size_type *)((char *)&v108.__r_.__value_.__r.__words[1] + 6) = v67;
              HIWORD(v108.__r_.__value_.__r.__words[2]) = 2081;
              *(void *)v109 = v65;
              *(_WORD *)&v109[8] = 2049;
              *(void *)&v109[10] = v61;
              __int16 v110 = 2049;
              uint64_t v111 = v62;
              __int16 v112 = 2050;
              uint64_t v113 = v97;
              __int16 v114 = 1026;
              int v115 = v99;
              __int16 v116 = 2049;
              uint64_t v117 = v103;
              __int16 v118 = 1025;
              BOOL v119 = v63;
              __int16 v120 = 1025;
              BOOL v121 = v64 >= 7000.0;
              __int16 v122 = 1025;
              int v123 = (v68 >> 4) & 1;
              __int16 v124 = 1025;
              BOOL v125 = v69 != v70;
              __int16 v126 = 1025;
              int v127 = v71;
              CFTypeRef v72 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v101,  2LL,  "Notifying client of fence %{private}s for %{public}s/%{private}s (l ocation <%{private}+.8f,%{private}+.8f> acc %{public}.2f type %{pub lic}d, \t\t\t\t\t\t\tsinceLast,%{private}.1f, fence,%{private}d,%{p rivate}d,%{private}d,%{private}d,%{private}d",  &v108,  108);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CLFe nceManager_Type::NotificationData &)",  "%s\n",  (const char *)v72);
              if (v72 != &buf) {
                free(v72);
              }
            }

            buf.__r_.__value_.__r.__words[0] = sub_1002A59CC((uint64_t)v105);
            sub_1002707B0(a1, &buf);
          }

          break;
        case 2:
          if (sub_10026E748(a4, (uint64_t)v105))
          {
            buf.__r_.__value_.__r.__words[0] = 6LL;
            sub_1002AC4EC((uint64_t)v105, "kCLConnectionMessageErrorKey", &buf);
            buf.__r_.__value_.__r.__words[0] = sub_1002A59CC((uint64_t)v105);
            sub_100270858(a1, &buf);
          }

          break;
        case 3:
          if (sub_10026E748(a4, (uint64_t)v105))
          {
            buf.__r_.__value_.__r.__words[0] = sub_1002A59CC((uint64_t)v105);
            sub_100270900(a1, &buf);
          }

          break;
        case 4:
          if (qword_101934870 != -1) {
            dispatch_once(&qword_101934870, &stru_10182CD98);
          }
          uint64_t v27 = (os_log_s *)qword_101934878;
          if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEBUG,  "Fence: received, kNotificationFenceFailure",  (uint8_t *)&buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(&buf, 0x65CuLL);
            if (qword_101934870 != -1) {
              dispatch_once(&qword_101934870, &stru_10182CD98);
            }
            LOWORD(v108.__r_.__value_.__l.__data_) = 0;
            char v54 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "Fence: received, kNotificationFenceFailure",  &v108,  2);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CLFenc eManager_Type::NotificationData &)",  "%s\n",  (const char *)v54);
            if (v54 != &buf) {
              free(v54);
            }
          }

          buf.__r_.__value_.__r.__words[0] = 5LL;
          sub_1002AC4EC((uint64_t)v105, "kCLConnectionMessageErrorKey", &buf);
          buf.__r_.__value_.__r.__words[0] = sub_1002A59CC((uint64_t)v105);
          sub_100270858(a1, &buf);
          break;
        case 5:
          if ((sub_10026E748(a4, (uint64_t)v105) & 1) != 0)
          {
            uint64_t v34 = *(unsigned __int8 *)(a4 + 271);
            if ((v34 & 0x80u) != 0LL) {
              uint64_t v34 = *(void *)(a4 + 256);
            }
            if (v34)
            {
              sub_1002A5370(&v108);
              if ((sub_10026E748(a4 + 248, (uint64_t)&v108) & 1) == 0)
              {
                if (qword_101934870 != -1) {
                  dispatch_once(&qword_101934870, &stru_10182CD98);
                }
                uint64_t v35 = (os_log_s *)qword_101934878;
                if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "#Warning Couldn't populate alternate region",  (uint8_t *)&buf,  2u);
                }

                if (sub_1002921D0(115, 2))
                {
                  bzero(&buf, 0x65CuLL);
                  if (qword_101934870 != -1) {
                    dispatch_once(&qword_101934870, &stru_10182CD98);
                  }
                  LOWORD(v128.__r_.__value_.__l.__data_) = 0;
                  __int128 v90 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934878,  0LL,  "#Warning Couldn't populate alternate region",  &v128,  2);
                  sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CLFenceManager_Type::NotificationData &)",  "%s\n",  (const char *)v90);
                  if (v90 != &buf) {
                    free(v90);
                  }
                }

                sub_1002ACD58((uint64_t)v105, "kCLConnectionMessageNameKey", (char *)(a4 + 24));
              }

              sub_1002ACE6C((uint64_t)v105, "kCLConnectionMessageAlternateRegionKey", (uint64_t)&v108);
              sub_1002A5590(&v108);
            }

            else
            {
              if (qword_101934870 != -1) {
                dispatch_once(&qword_101934870, &stru_10182CD98);
              }
              __int128 v50 = (os_log_s *)qword_101934878;
              if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEBUG,  "No alternate region available",  (uint8_t *)&buf,  2u);
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(&buf, 0x65CuLL);
                if (qword_101934870 != -1) {
                  dispatch_once(&qword_101934870, &stru_10182CD98);
                }
                LOWORD(v108.__r_.__value_.__l.__data_) = 0;
                int v89 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "No alternate region available",  &v108,  2);
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CL FenceManager_Type::NotificationData &)",  "%s\n",  (const char *)v89);
                if (v89 != &buf) {
                  free(v89);
                }
              }
            }

            buf.__r_.__value_.__r.__words[0] = sub_1002A59CC((uint64_t)v105);
            sub_1002709A8(a1, &buf);
            goto LABEL_138;
          }

          if (qword_101934870 != -1) {
            dispatch_once(&qword_101934870, &stru_10182CD98);
          }
          __int128 v45 = (os_log_s *)qword_101934878;
          if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEFAULT))
          {
            sub_100923668(a4, &buf);
            uint64_t v46 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
                ? &buf
                : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
            LODWORD(v108.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v46;
            _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "#Warning Can't populate fence, %s",  (uint8_t *)&v108,  0xCu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(&buf, 0x65CuLL);
            if (qword_101934870 != -1) {
              dispatch_once(&qword_101934870, &stru_10182CD98);
            }
            uint64_t v47 = qword_101934878;
            sub_100923668(a4, &v108);
            if ((v108.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              __int128 v48 = &v108;
            }
            else {
              __int128 v48 = (std::stringbuf::string_type *)v108.__r_.__value_.__r.__words[0];
            }
            LODWORD(v128.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)v128.__r_.__value_.__r.__words + 4) = (std::string::size_type)v48;
            id v44 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v47,  0LL,  "#Warning Can't populate fence, %s",  (const char *)&v128);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CLFenc eManager_Type::NotificationData &)",  "%s\n",  (const char *)v44);
            goto LABEL_121;
          }

          break;
        case 6:
          goto LABEL_43;
        case 7:
          if (qword_101934870 != -1) {
            dispatch_once(&qword_101934870, &stru_10182CD98);
          }
          __int16 v36 = (os_log_s *)qword_101934878;
          if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEBUG,  "Fence: received, kNotificationFenceNotAuthorized",  (uint8_t *)&buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(&buf, 0x65CuLL);
            if (qword_101934870 != -1) {
              dispatch_once(&qword_101934870, &stru_10182CD98);
            }
            LOWORD(v108.__r_.__value_.__l.__data_) = 0;
            uint64_t v55 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "Fence: received, kNotificationFenceNotAuthorized",  &v108,  2);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CLFenc eManager_Type::NotificationData &)",  "%s\n",  (const char *)v55);
            if (v55 != &buf) {
              free(v55);
            }
          }

          if ((sub_10026E748(a4, (uint64_t)v105) & 1) != 0)
          {
            if (qword_101934870 != -1) {
              dispatch_once(&qword_101934870, &stru_10182CD98);
            }
            uint64_t v37 = (os_log_s *)qword_101934878;
            if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEFAULT))
            {
              else {
                __int16 v38 = *(const void **)a4;
              }
              else {
                std::string::size_type v39 = *(void *)(a4 + 24);
              }
              LODWORD(buf.__r_.__value_.__l.__data_) = 136446466;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
              WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
              *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v39;
              _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "#Notice Fence: kNotificationFenceNotAuthorized, bundle not authorized for location, %{public}s, fence, %{public}s",  (uint8_t *)&buf,  0x16u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(&buf, 0x65CuLL);
              if (qword_101934870 != -1) {
                dispatch_once(&qword_101934870, &stru_10182CD98);
              }
              else {
                uint64_t v79 = *(const void **)a4;
              }
              int v80 = *(char *)(a4 + 47);
              std::string::size_type v83 = *(void *)(a4 + 24);
              std::string::size_type v82 = a4 + 24;
              std::string::size_type v81 = v83;
              if (v80 >= 0) {
                std::string::size_type v84 = v82;
              }
              else {
                std::string::size_type v84 = v81;
              }
              LODWORD(v108.__r_.__value_.__l.__data_) = 136446466;
              *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v79;
              WORD2(v108.__r_.__value_.__r.__words[1]) = 2082;
              *(std::string::size_type *)((char *)&v108.__r_.__value_.__r.__words[1] + 6) = v84;
              LODWORD(v91) = 22;
              double v85 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934878,  0LL,  "#Notice Fence: kNotificationFenceNotAuthorized, bundle not authoriz ed for location, %{public}s, fence, %{public}s",  &v108,  v91);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CLFe nceManager_Type::NotificationData &)",  "%s\n",  (const char *)v85);
              if (v85 != &buf) {
                free(v85);
              }
            }

            buf.__r_.__value_.__r.__words[0] = 4LL;
            sub_1002AC4EC((uint64_t)v105, "kCLConnectionMessageErrorKey", &buf);
            buf.__r_.__value_.__r.__words[0] = sub_1002A59CC((uint64_t)v105);
            sub_100270858(a1, &buf);
            break;
          }

          if (qword_101934870 != -1) {
            dispatch_once(&qword_101934870, &stru_10182CD98);
          }
          __int128 v49 = (os_log_s *)qword_101934878;
          if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_FAULT))
          {
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_FAULT,  "Fence: kNotificationFenceNotAuthorized, failed to populate fence",  (uint8_t *)&buf,  2u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(&buf, 0x65CuLL);
            if (qword_101934870 != -1) {
              dispatch_once(&qword_101934870, &stru_10182CD98);
            }
            LOWORD(v108.__r_.__value_.__l.__data_) = 0;
            LODWORD(v91) = 2;
            id v44 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934878,  17LL,  "Fence: kNotificationFenceNotAuthorized, failed to populate fence",  &v108,  v91);
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CLFenc eManager_Type::NotificationData &)",  "%s\n",  (const char *)v44);
            if (v44 != &buf) {
              goto LABEL_131;
            }
          }

          break;
        case 8:
          if ((sub_100C6ADD0(a1) & 1) == 0) {
            break;
          }
LABEL_43:
          if ((sub_10026E748(a4, (uint64_t)v105) & 1) != 0)
          {
            if (qword_101934870 != -1) {
              dispatch_once(&qword_101934870, &stru_10182CD98);
            }
            char v28 = (os_log_s *)qword_101934878;
            if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
            {
              int v29 = *a3;
              sub_100923668(a4, &v108);
              unsigned __int8 v30 = "kNotificationFenceState";
              if (v29 != 8) {
                unsigned __int8 v30 = "kNotificationRegionStateRequest";
              }
              uint64_t v31 = (std::stringbuf::string_type *)v108.__r_.__value_.__r.__words[0];
              if ((v108.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                uint64_t v31 = &v108;
              }
              int v32 = *(_DWORD *)(a4 + 652);
              else {
                unint64_t v33 = (&off_10182CFC0)[v32 + 1];
              }
              LODWORD(buf.__r_.__value_.__l.__data_) = 136315906;
              *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v30;
              WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v31;
              HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
              *(_DWORD *)v130 = v32;
              *(_WORD *)&v130[4] = 2080;
              *(void *)&v130[6] = v33;
              _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "Fence: received, %s, %s, state, %d, %s",  (uint8_t *)&buf,  0x26u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(&buf, 0x65CuLL);
              if (qword_101934870 != -1) {
                dispatch_once(&qword_101934870, &stru_10182CD98);
              }
              uint64_t v73 = qword_101934878;
              int v74 = *a3;
              sub_100923668(a4, &v128);
              unint64_t v75 = "kNotificationFenceState";
              if (v74 != 8) {
                unint64_t v75 = "kNotificationRegionStateRequest";
              }
              char v76 = (std::stringbuf::string_type *)v128.__r_.__value_.__r.__words[0];
              if ((v128.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                char v76 = &v128;
              }
              int v77 = *(_DWORD *)(a4 + 652);
              else {
                BOOL v78 = (&off_10182CFC0)[v77 + 1];
              }
              LODWORD(v108.__r_.__value_.__l.__data_) = 136315906;
              *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v75;
              WORD2(v108.__r_.__value_.__r.__words[1]) = 2080;
              *(std::string::size_type *)((char *)&v108.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v76;
              HIWORD(v108.__r_.__value_.__r.__words[2]) = 1024;
              *(_DWORD *)v109 = v77;
              *(_WORD *)&v109[4] = 2080;
              *(void *)&v109[6] = v78;
              LODWORD(v91) = 38;
              uint64_t v88 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v73,  2LL,  "Fence: received, %s, %s, state, %d, %s",  (const char *)&v108,  v91,  v92,  v93);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CLFe nceManager_Type::NotificationData &)",  "%s\n",  (const char *)v88);
              if (v88 != &buf) {
                free(v88);
              }
            }

            unsigned int v51 = *(_DWORD *)(a4 + 652) + 1;
            if (v51 >= 3)
            {
              if (qword_101934870 != -1) {
                dispatch_once(&qword_101934870, &stru_10182CD98);
              }
              uint64_t v52 = (os_log_s *)qword_101934878;
              if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_FAULT))
              {
                int v53 = *(_DWORD *)(a4 + 652);
                LODWORD(buf.__r_.__value_.__l.__data_) = 67240192;
                HIDWORD(buf.__r_.__value_.__r.__words[0]) = v53;
                _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_FAULT,  "Fence: unknown state, %{public}d",  (uint8_t *)&buf,  8u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(&buf, 0x65CuLL);
                if (qword_101934870 != -1) {
                  dispatch_once(&qword_101934870, &stru_10182CD98);
                }
                int v86 = *(_DWORD *)(a4 + 652);
                LODWORD(v108.__r_.__value_.__l.__data_) = 67240192;
                HIDWORD(v108.__r_.__value_.__r.__words[0]) = v86;
                LODWORD(v91) = 8;
                uint64_t v87 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934878,  17LL,  "Fence: unknown state, %{public}d",  &v108,  v91);
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CL FenceManager_Type::NotificationData &)",  "%s\n",  (const char *)v87);
                if (v87 != &buf) {
                  free(v87);
                }
              }

              unsigned int v51 = 0;
            }

            LODWORD(buf.__r_.__value_.__l.__data_) = v51;
            sub_1002AC220((uint64_t)v105, "kCLConnectionMessageStatusKey", &buf);
            buf.__r_.__value_.__r.__words[0] = sub_1002A59CC((uint64_t)v105);
            sub_1002706B8(a1, &buf);
          }

          else
          {
            if (qword_101934870 != -1) {
              dispatch_once(&qword_101934870, &stru_10182CD98);
            }
            uint64_t v40 = (os_log_s *)qword_101934878;
            if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_FAULT))
            {
              sub_100923668(a4, &buf);
              double v41 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
                  ? &buf
                  : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
              LODWORD(v108.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)v108.__r_.__value_.__r.__words + 4) = (std::string::size_type)v41;
              _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_FAULT,  "Fence: kNotificationRegionStateRequest, failed to populateGeographicRegion, %s",  (uint8_t *)&v108,  0xCu);
            }

            if (sub_1002921D0(115, 0))
            {
              bzero(&buf, 0x65CuLL);
              if (qword_101934870 != -1) {
                dispatch_once(&qword_101934870, &stru_10182CD98);
              }
              uint64_t v42 = qword_101934878;
              sub_100923668(a4, &v108);
              if ((v108.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                id v43 = &v108;
              }
              else {
                id v43 = (std::stringbuf::string_type *)v108.__r_.__value_.__r.__words[0];
              }
              LODWORD(v128.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)v128.__r_.__value_.__r.__words + 4) = (std::string::size_type)v43;
              id v44 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v42,  17LL,  "Fence: kNotificationRegionStateRequest, failed to populateGeographicRegion, %s",  (const char *)&v128);
              sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::onFenceNotification(int, const CLFenceManager_Type::Notification &, const CLFe nceManager_Type::NotificationData &)",  "%s\n",  (const char *)v44);
LABEL_121:
              if (v44 != &buf) {
LABEL_131:
              }
                free(v44);
            }
          }

          break;
        case 9:
LABEL_138:
          if ((sub_10026E748(a4, (uint64_t)v105) & 1) != 0)
          {
            buf.__r_.__value_.__r.__words[0] = *(void *)(a4 + 656);
            sub_1002AC7B8((uint64_t)v105, "kCLConnectionMessageRegionWatchdogSinceLast", &buf);
            buf.__r_.__value_.__r.__words[0] = sub_1002A59CC((uint64_t)v105);
            sub_100270A50(a1, &buf);
          }

          break;
        default:
          break;
      }
    }

    sub_1002A5590(v104);
    sub_1002A5590(v105);
    goto LABEL_153;
  }

  uint64_t v11 = (unsigned __int8 *)a4;
  while (*v11 == *(unsigned __int8 *)v10)
  {
    ++v11;
    unint64_t v10 = (void **)((char *)v10 + 1);
    if (!--v7) {
      goto LABEL_17;
    }
  }

void sub_1002705B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, char a20, uint64_t a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27, char a28)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1002706B8(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_10027074C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL sub_100270760(uint64_t a1)
{
  return *(double *)(a1 + 96) <= 400.0
      && !*(_BYTE *)(a1 + 188)
      && *(_DWORD *)(a1 + 180) != 2
      && *(void *)(a1 + 232) == *(void *)(a1 + 224)
      && (*(_BYTE *)(a1 + 160) & 0x20) == 0;
}

void sub_1002707B0(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100270844(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100270858(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_1002708EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100270900(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100270994(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1002709A8(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100270A3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100270A50(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100270AE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100270AF8(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v7 = *(unsigned __int8 *)(a4 + 63);
  if ((v7 & 0x80u) == 0LL) {
    uint64_t v8 = (void *)*(unsigned __int8 *)(a4 + 63);
  }
  else {
    uint64_t v8 = *(void **)(a4 + 48);
  }
  unint64_t v9 = v58;
  if ((v58 & 0x80u) != 0) {
    unint64_t v9 = (unint64_t)__p[1];
  }
  unint64_t v10 = (const void **)(a4 + 40);
  if ((v58 & 0x80u) == 0) {
    uint64_t v11 = __p;
  }
  else {
    uint64_t v11 = (void **)__p[0];
  }
  if ((v7 & 0x80) != 0)
  {
    if (memcmp(*v10, v11, *(void *)(a4 + 48))) {
      goto LABEL_97;
    }
LABEL_17:
    sub_1002A5370(v56);
    int v13 = *a3;
    if (*a3 == 3)
    {
      if (!*(_DWORD *)(a4 + 120))
      {
        int v24 = *(_DWORD *)(a4 + 168);
        if (v24 == 2) {
          int v25 = 1;
        }
        else {
          int v25 = 2 * (v24 == 4);
        }
        *(_DWORD *)std::stringbuf::string_type buf = v25;
        sub_1002AC220((uint64_t)v56, "kCLConnectionMessageStatusKey", buf);
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_10182CD78);
        }
        int v26 = (os_log_s *)qword_101934978;
        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v27 = a4 + 88;
          else {
            uint64_t v28 = *(void *)(a4 + 40);
          }
          *(_DWORD *)std::stringbuf::string_type buf = 136446467;
          *(void *)&uint8_t buf[4] = v28;
          __int16 v64 = 2081;
          uint64_t v65 = v27;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "@iB: Sending kCLConnectionMessageRegionState for region,'%{public}s/%{private}s'.",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934970 != -1) {
            dispatch_once(&qword_101934970, &stru_10182CD78);
          }
          uint64_t v50 = *(void *)(a4 + 88);
          uint64_t v49 = a4 + 88;
          uint64_t v48 = v50;
          else {
            unsigned int v51 = *(const void ***)(v49 - 48);
          }
          int v59 = 136446467;
          uint64_t v60 = (uint64_t)v51;
          __int16 v61 = 2081;
          uint64_t v62 = v48;
          uint64_t v52 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  0LL,  "@iB: Sending kCLConnectionMessageRegionState for region,'%{public}s/%{private}s'.",  &v59,  22);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onBTLEFenceNotification(int, const CLBTLEFenceManager_Type::Notification &, const CLBTLEFenceManager_Type::NotificationData &)",  "%s\n",  v52);
          if (v52 != buf) {
            free(v52);
          }
        }

        *(void *)std::stringbuf::string_type buf = sub_1002A59CC((uint64_t)v56);
        sub_1002706B8(a1, buf);
        goto LABEL_96;
      }

      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_10182CD78);
      }
      uint64_t v21 = (os_log_s *)qword_101934978;
      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = a4 + 88;
        else {
          uint64_t v23 = *(void *)(a4 + 40);
        }
        *(_DWORD *)std::stringbuf::string_type buf = 136446467;
        *(void *)&uint8_t buf[4] = v23;
        __int16 v64 = 2081;
        uint64_t v65 = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "@iB: Sending kCLConnectionMessageRegionMonitoringError for region,'%{public}s/%{private}s'.",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_10182CD78);
        }
        uint64_t v40 = a4 + 88;
        else {
          uint64_t v41 = *(void *)(a4 + 40);
        }
        int v59 = 136446467;
        uint64_t v60 = v41;
        __int16 v61 = 2081;
        uint64_t v62 = v40;
        uint64_t v42 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  0LL,  "@iB: Sending kCLConnectionMessageRegionMonitoringError for region,'%{public}s/%{private}s'.",  &v59,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onBTLEFenceNotification(int, const CLBTLEFenceManager_Type::Notification &, const CL BTLEFenceManager_Type::NotificationData &)",  "%s\n",  v42);
        if (v42 != buf) {
          free(v42);
        }
      }

      if (*(_DWORD *)(a4 + 120) == 1) {
        *(void *)std::stringbuf::string_type buf = 4LL;
      }
      else {
        *(void *)std::stringbuf::string_type buf = 5LL;
      }
    }

    else
    {
      if (v13 == 2)
      {
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_10182CD78);
        }
        int v17 = (os_log_s *)qword_101934978;
        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = a4 + 88;
          else {
            uint64_t v19 = *(void *)(a4 + 40);
          }
          *(_DWORD *)std::stringbuf::string_type buf = 136446467;
          *(void *)&uint8_t buf[4] = v19;
          __int16 v64 = 2081;
          uint64_t v65 = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "@iB: Sending kCLConnectionMessageRegionMonitoring for region,'%{public}s/%{private}s'.",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934970 != -1) {
            dispatch_once(&qword_101934970, &stru_10182CD78);
          }
          uint64_t v34 = a4 + 88;
          else {
            uint64_t v35 = *(void *)(a4 + 40);
          }
          int v59 = 136446467;
          uint64_t v60 = v35;
          __int16 v61 = 2081;
          uint64_t v62 = v34;
          __int16 v36 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  0LL,  "@iB: Sending kCLConnectionMessageRegionMonitoring for region,'%{public}s/%{private}s'.",  &v59,  22);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onBTLEFenceNotification(int, const CLBTLEFenceManager_Type::Notification &, const CLBTLEFenceManager_Type::NotificationData &)",  "%s\n",  v36);
          if (v36 != buf) {
            free(v36);
          }
        }

        int v20 = *(_DWORD *)(a4 + 168);
        if (v20 == 4)
        {
          *(_DWORD *)std::stringbuf::string_type buf = 1;
          sub_1002AC220((uint64_t)v56, "kCLConnectionMessageEventKey", buf);
        }

        else if (v20 == 2)
        {
          *(_DWORD *)std::stringbuf::string_type buf = 0;
          sub_1002AC220((uint64_t)v56, "kCLConnectionMessageEventKey", buf);
        }

        else
        {
          if (qword_101934970 != -1) {
            dispatch_once(&qword_101934970, &stru_10182CD78);
          }
          int v32 = (os_log_s *)qword_101934978;
          if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
          {
            int v33 = *(_DWORD *)(a4 + 168);
            *(_DWORD *)std::stringbuf::string_type buf = 67240192;
            *(_DWORD *)&uint8_t buf[4] = v33;
            _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_FAULT,  "Unsupported region transition state,%{public}d will not be reported.",  buf,  8u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934970 != -1) {
              dispatch_once(&qword_101934970, &stru_10182CD78);
            }
            int v53 = *(_DWORD *)(a4 + 168);
            int v59 = 67240192;
            LODWORD(v6sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v53;
            LODWORD(v55) = 8;
            char v54 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Unsupported region transition state,%{public}d will not be reported.",  &v59,  v55);
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLFenceSubscription::onBTLEFenceNotification(int, const CLBTLEFenceManager_Type::Notification &, cons t CLBTLEFenceManager_Type::NotificationData &)",  "%s\n",  v54);
            if (v54 != buf) {
              free(v54);
            }
          }
        }

        *(void *)std::stringbuf::string_type buf = sub_1002A59CC((uint64_t)v56);
        sub_1002707B0(a1, buf);
        goto LABEL_96;
      }

      if (v13)
      {
LABEL_96:
        sub_1002A5590(v56);
        goto LABEL_97;
      }

      if (!*(_DWORD *)(a4 + 120))
      {
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_10182CD78);
        }
        int v29 = (os_log_s *)qword_101934978;
        if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v30 = a4 + 88;
          else {
            uint64_t v31 = *(void *)(a4 + 40);
          }
          *(_DWORD *)std::stringbuf::string_type buf = 136446467;
          *(void *)&uint8_t buf[4] = v31;
          __int16 v64 = 2081;
          uint64_t v65 = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "@iB: Sending kCLConnectionMessageRegionMonitoringSetupCompleted for region,'%{public}s/%{private}s'.",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934970 != -1) {
            dispatch_once(&qword_101934970, &stru_10182CD78);
          }
          uint64_t v45 = *(void *)(a4 + 88);
          uint64_t v44 = a4 + 88;
          uint64_t v43 = v45;
          else {
            uint64_t v46 = *(const void ***)(v44 - 48);
          }
          int v59 = 136446467;
          uint64_t v60 = (uint64_t)v46;
          __int16 v61 = 2081;
          uint64_t v62 = v43;
          uint64_t v47 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  0LL,  "@iB: Sending kCLConnectionMessageRegionMonitoringSetupCompleted for region,'%{public}s/%{private}s'.",  &v59,  22);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onBTLEFenceNotification(int, const CLBTLEFenceManager_Type::Notification &, const CLBTLEFenceManager_Type::NotificationData &)",  "%s\n",  v47);
          if (v47 != buf) {
            free(v47);
          }
        }

        *(void *)std::stringbuf::string_type buf = sub_1002A59CC((uint64_t)v56);
        sub_100270900(a1, buf);
        goto LABEL_96;
      }

      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_10182CD78);
      }
      int v14 = (os_log_s *)qword_101934978;
      if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = a4 + 88;
        else {
          uint64_t v16 = *(void *)(a4 + 40);
        }
        *(_DWORD *)std::stringbuf::string_type buf = 136446467;
        *(void *)&uint8_t buf[4] = v16;
        __int16 v64 = 2081;
        uint64_t v65 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "@iB: Sending kCLConnectionMessageRegionMonitoringError for region,'%{public}s/%{private}s'.",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934970 != -1) {
          dispatch_once(&qword_101934970, &stru_10182CD78);
        }
        uint64_t v37 = a4 + 88;
        else {
          uint64_t v38 = *(void *)(a4 + 40);
        }
        int v59 = 136446467;
        uint64_t v60 = v38;
        __int16 v61 = 2081;
        uint64_t v62 = v37;
        std::string::size_type v39 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  0LL,  "@iB: Sending kCLConnectionMessageRegionMonitoringError for region,'%{public}s/%{private}s'.",  &v59,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceSubscription::onBTLEFenceNotification(int, const CLBTLEFenceManager_Type::Notification &, const CL BTLEFenceManager_Type::NotificationData &)",  "%s\n",  v39);
        if (v39 != buf) {
          free(v39);
        }
      }

      if (*(_DWORD *)(a4 + 120) == 1) {
        *(void *)std::stringbuf::string_type buf = 4LL;
      }
      else {
        *(void *)std::stringbuf::string_type buf = 5LL;
      }
    }

    sub_1002AC4EC((uint64_t)v56, "kCLConnectionMessageErrorKey", buf);
    *(void *)std::stringbuf::string_type buf = sub_1002A59CC((uint64_t)v56);
    sub_100270858(a1, buf);
    goto LABEL_96;
  }

  if (!*(_BYTE *)(a4 + 63)) {
    goto LABEL_17;
  }
  unint64_t v12 = (unsigned __int8 *)(a4 + 40);
  while (*v12 == *(unsigned __int8 *)v11)
  {
    ++v12;
    uint64_t v11 = (void **)((char *)v11 + 1);
    if (!--v7) {
      goto LABEL_17;
    }
  }

void sub_100271788( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100271808(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_100271834(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  *uint64_t v3 = 0LL;
  return a1;
}

void sub_100271898(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

void sub_1002718C4(id a1)
{
  qword_101934878 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeoFencing");
}

char *sub_1002718F0(char *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)__uuid_t dst = v4;
  }

  if (*((char *)a2 + 47) < 0)
  {
    sub_1010DD48C(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }

  else
  {
    __int128 v5 = *(__int128 *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }

  if (*((char *)a2 + 71) < 0)
  {
    sub_1010DD48C(__dst + 48, *((void **)a2 + 6), *((void *)a2 + 7));
  }

  else
  {
    __int128 v6 = a2[3];
    *((void *)__dst + std::istream::~istream(v2, v3 + 8) = *((void *)a2 + 8);
    *((_OWORD *)__dst + 3) = v6;
  }

  __int128 v7 = *(__int128 *)((char *)a2 + 72);
  __int128 v8 = *(__int128 *)((char *)a2 + 88);
  __int128 v9 = *(__int128 *)((char *)a2 + 104);
  *(_OWORD *)(__dst + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(__int128 *)((char *)a2 + 120);
  *(_OWORD *)(__dst + 104) = v9;
  *(_OWORD *)(__dst + 8std::istream::~istream(v2, v3 + 8) = v8;
  *(_OWORD *)(__dst + 72) = v7;
  __int128 v10 = *(__int128 *)((char *)a2 + 136);
  __int128 v11 = *(__int128 *)((char *)a2 + 152);
  __int128 v12 = *(__int128 *)((char *)a2 + 168);
  *(void *)(__dst + 181) = *(void *)((char *)a2 + 181);
  *(_OWORD *)(__dst + 16std::istream::~istream(v2, v3 + 8) = v12;
  *(_OWORD *)(__dst + 152) = v11;
  *(_OWORD *)(__dst + 136) = v10;
  if (*((char *)a2 + 215) < 0)
  {
    sub_1010DD48C(__dst + 192, *((void **)a2 + 24), *((void *)a2 + 25));
  }

  else
  {
    __int128 v13 = a2[12];
    *((void *)__dst + 26) = *((void *)a2 + 26);
    *((_OWORD *)__dst + 12) = v13;
  }

  *((void *)__dst + 27) = 0LL;
  id v14 = *((id *)a2 + 27);
  *((void *)__dst + 2std::istream::~istream(v2, v3 + 8) = 0LL;
  *((void *)__dst + 27) = v14;
  *((void *)__dst + 29) = 0LL;
  *((void *)__dst + 3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  sub_1000577B4( (void *)__dst + 28,  *((const void **)a2 + 28),  *((void *)a2 + 29),  (uint64_t)(*((void *)a2 + 29) - *((void *)a2 + 28)) >> 4);
  return __dst;
}

void sub_100271A50(_Unwind_Exception *exception_object)
{
}

id *sub_100271AC4(id *a1)
{
  return a1;
}

uint64_t sub_100271AF0(uint64_t a1, __int128 *a2, __int128 *a3, __int128 *a4)
{
  *(_OWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)a1 = off_10182CDC8;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 40), *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v7 = *a2;
    *(void *)(a1 + 56) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v7;
  }

  if (*((char *)a4 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 64), *(void **)a4, *((void *)a4 + 1));
  }

  else
  {
    __int128 v8 = *a4;
    *(void *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 64) = v8;
  }

  __int128 v9 = (_BYTE *)(a1 + 88);
  if (*((char *)a3 + 23) < 0)
  {
    sub_1010DD48C(v9, *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 v10 = *a3;
    *(void *)(a1 + 104) = *((void *)a3 + 2);
    *(_OWORD *)__int128 v9 = v10;
  }

  *(_DWORD *)(a1 + 112) = 0;
  return a1;
}

void sub_100271BD0(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = &off_10182CE18;
  _Unwind_Resume(exception_object);
}

void sub_100271C2C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002722AC(a1);
  operator delete(v1);
}

uint64_t sub_100271C40@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  __int128 v4 = sub_10000CF44(&v24, (uint64_t)"[", 1LL);
  int v5 = *(char *)(a1 + 87);
  if (v5 >= 0) {
    uint64_t v6 = a1 + 64;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 64);
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 87);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 72);
  }
  __int128 v8 = sub_10000CF44(v4, v6, v7);
  __int128 v9 = sub_10000CF44(v8, (uint64_t)"]/", 2LL);
  int v10 = *(char *)(a1 + 63);
  if (v10 >= 0) {
    uint64_t v11 = a1 + 40;
  }
  else {
    uint64_t v11 = *(void *)(a1 + 40);
  }
  if (v10 >= 0) {
    uint64_t v12 = *(unsigned __int8 *)(a1 + 63);
  }
  else {
    uint64_t v12 = *(void *)(a1 + 48);
  }
  __int128 v13 = sub_10000CF44(v9, v11, v12);
  id v14 = sub_10000CF44(v13, (uint64_t)"/", 1LL);
  int v15 = *(char *)(a1 + 111);
  if (v15 >= 0) {
    uint64_t v16 = a1 + 88;
  }
  else {
    uint64_t v16 = *(void *)(a1 + 88);
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(a1 + 111);
  }
  else {
    uint64_t v17 = *(void *)(a1 + 96);
  }
  uint64_t v18 = sub_10000CF44(v14, v16, v17);
  uint64_t v19 = sub_10000CF44(v18, (uint64_t)"/", 1LL);
  sub_100271E94(a1, &__p);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t p_p = &__p;
  }
  else {
    uint64_t p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  sub_10000CF44(v19, (uint64_t)p_p, size);
  std::stringbuf::str(a2, &v25);
  std::streambuf::~streambuf(&v25);
  return std::ios::~ios(&v26);
}

void sub_100271DE4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1002720B4((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_100271E14(uint64_t a1)
{
  *(void *)a1 = &off_10182CE18;
  return a1;
}

void sub_100271E54(void **__p)
{
  void *__p = &off_10182CE18;
  operator delete(__p);
}

uint64_t sub_100271E94@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  if ((*(_BYTE *)(a1 + 36) & 1) != 0)
  {
    int v4 = *(char *)(a1 + 31);
    uint64_t v5 = v4 >= 0 ? a1 + 8 : *(void *)(a1 + 8);
    uint64_t v6 = v4 >= 0 ? *(unsigned __int8 *)(a1 + 31) : *(void *)(a1 + 16);
    sub_10000CF44(&v10, v5, v6);
    if ((*(_BYTE *)(a1 + 36) & 2) != 0)
    {
      uint64_t v7 = sub_10000CF44(&v10, (uint64_t)".", 1LL);
      std::ostream::operator<<(v7, *(unsigned __int16 *)(a1 + 32));
      if ((*(_BYTE *)(a1 + 36) & 4) != 0)
      {
        __int128 v8 = sub_10000CF44(&v10, (uint64_t)".", 1LL);
        std::ostream::operator<<(v8, *(unsigned __int16 *)(a1 + 34));
      }
    }
  }

  std::stringbuf::str(a2, &v11);
  std::streambuf::~streambuf(&v11);
  return std::ios::~ios(&v12);
}

void sub_100271FB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100271FC8(uint64_t a1)
{
  uint64_t v2 = a1 + 8;
  *(void *)a1 = v3;
  *(void *)(a1 + *(void *)(v3 - 24)) = v4;
  uint64_t v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24LL));
  std::ios_base::init(v5, (void *)(a1 + 8));
  v5[1].__vftable = 0LL;
  v5[1].__fmtflags_ = -1;
  std::streambuf::basic_streambuf(v2);
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 8std::istream::~istream(v2, v3 + 8) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_10027208C(_Unwind_Exception *a1)
{
}

uint64_t sub_1002720B4(uint64_t a1)
{
  uint64_t v3 = a1 + 8;
  std::streambuf::~streambuf(v3);
  std::ios::~ios(a1 + 112);
  return a1;
}

uint64_t sub_100272138(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_10182CE18;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }

  else
  {
    __int128 v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + std::ostream::~ostream(v2, v3 + 8) = v4;
  }

  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)a1 = off_10182CDC8;
  if (*(char *)(a2 + 63) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v5;
  }

  if (*(char *)(a2 + 87) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 64), *(void **)(a2 + 64), *(void *)(a2 + 72));
  }

  else
  {
    __int128 v6 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = v6;
  }

  uint64_t v7 = (_BYTE *)(a1 + 88);
  if (*(char *)(a2 + 111) < 0)
  {
    sub_1010DD48C(v7, *(void **)(a2 + 88), *(void *)(a2 + 96));
  }

  else
  {
    __int128 v8 = *(_OWORD *)(a2 + 88);
    *(void *)(a1 + 104) = *(void *)(a2 + 104);
    *(_OWORD *)uint64_t v7 = v8;
  }

  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
  return a1;
}

void sub_100272258(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v5 + 16;
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002722AC(uint64_t a1)
{
  *(void *)a1 = off_10182CDC8;
  *(void *)a1 = &off_10182CE18;
  return a1;
}

void sub_10027232C(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

CLCppContainer *sub_100272358(uint64_t a1)
{
  uint64_t v2 = operator new(0x18uLL);
  uint64_t v3 = v2;
  if (*(char *)(a1 + 23) < 0)
  {
    sub_1010DD48C(v2, *(void **)a1, *(void *)(a1 + 8));
  }

  else
  {
    *(_OWORD *)uint64_t v2 = *(_OWORD *)a1;
    v2[2] = *(void *)(a1 + 16);
  }

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_100272410;
  v5[3] = &unk_10181D3D0;
  v5[4] = v3;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v3,  v5,  0LL,  24LL);
}

void sub_1002723FC(_Unwind_Exception *a1)
{
}

void sub_100272410(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    operator delete((void *)v1);
  }

__n128 sub_100272450(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_10182CE60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + std::ostream::~ostream(v2, v3 + 8) = result;
  return result;
}

__n128 sub_10027248C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_10182CE60;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + std::ostream::~ostream(v2, v3 + 8) = result;
  return result;
}

void sub_1002724B0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_1002724B8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1002724F4()
{
}

void sub_100272500(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  int v15 = v3;
  *a3 = 0LL;
  a3[1] = 0LL;
  uint64_t v5 = *(void (**)(void *, uint64_t *))a1;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = (void *)(a2 + (v6 >> 1));
  if ((v6 & 1) != 0) {
    uint64_t v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
  }
  uint64_t v16 = v4;
  uint64_t v17 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  v5(v7, &v16);
  uint64_t v10 = v17;
  if (v17)
  {
    std::stringbuf v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (v15)
  {
    __int128 v13 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_1002725D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

__n128 sub_1002725F0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_10182CEF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + std::ostream::~ostream(v2, v3 + 8) = result;
  return result;
}

__n128 sub_10027262C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_10182CEF0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + std::ostream::~ostream(v2, v3 + 8) = result;
  return result;
}

void sub_100272650(uint64_t a1, uint64_t a2, __int128 *a3)
{
}

uint64_t sub_100272658(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100272694()
{
}

void sub_1002726A0(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v6 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  sub_100272724(a1, a2, (CLConnectionMessage **)&v6);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)&v6 + 1);
  if (*((void *)&v6 + 1))
  {
    uint64_t v4 = (unint64_t *)(*((void *)&v6 + 1) + 8LL);
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_10027270C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1012310A8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100272724(uint64_t a1, uint64_t a2, CLConnectionMessage **a3)
{
  __int128 v6 = (NSSet *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  DictionaryOfClasses = (const __CFDictionary *)CLConnectionMessage::getDictionaryOfClasses(*a3, v6);
  sub_1002A5550((int)v15, DictionaryOfClasses);
  if ((sub_1002A6F64((uint64_t)v15, "kCLConnectionMessageSubscribeKey", &v14) & 1) != 0)
  {
    __int128 v8 = *(void (**)(void *, BOOL, uint8_t *))a1;
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v10 = (void *)(a2 + (v9 >> 1));
    if ((v9 & 1) != 0) {
      __int128 v8 = *(void (**)(void *, BOOL, uint8_t *))(*v10 + v8);
    }
    v8(v10, v14, v15);
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_10182CD78);
    }
    std::stringbuf v11 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_10182CD78);
      }
    }

    unint64_t v12 = (os_log_s *)qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Couldn't get value for kCLConnectionMessageSubscribeKey key",  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
    }
  }

  return sub_1002A5590(v15);
}

void sub_100272908( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100272924(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_10027299C(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100272988(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_10027299C(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  uint64_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    __int128 v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_100272C1C(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  uint64_t v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *uint64_t v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_100272C04(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100272C1C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + std::ostream::~ostream(v2, v3 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  void *v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_100272C90(v8 + 2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100272C78(_Unwind_Exception *a1)
{
}

void *sub_100272C90(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)__uuid_t dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100272CE8(_Unwind_Exception *exception_object)
{
}

void sub_100272D04(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100272D48((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }

void sub_100272D48(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 24);
  unint64_t v3 = *(void **)(a1 + 48);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    unint64_t v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
}

uint64_t sub_100272DAC(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100272DE4(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      unint64_t v3 = (void *)*v2;
      sub_100272D48((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

char *sub_100272E20@<X0>(uint64_t a1@<X0>, char *a2@<X8>)
{
  return sub_1002718F0(a2, (__int128 *)(a1 + 32));
}

char *sub_100272E2C(uint64_t a1, uint64_t a2)
{
  return sub_1002718F0((char *)(a1 + 32), (__int128 *)(a2 + 32));
}

void sub_100272E38(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 256);
  if (v2)
  {
    *(void *)(a1 + 264) = v2;
    operator delete(v2);
  }
}

void *sub_100272EB8@<X0>(char **a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  __int128 v6 = operator new(0x70uLL);
  __n128 result = sub_100272F18(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_100272F04(_Unwind_Exception *a1)
{
}

void *sub_100272F18(void *a1, char **a2, void *a3)
{
  a1[2] = 0LL;
  *a1 = off_10182B4B0;
  a1[1] = 0LL;
  sub_100272F7C((uint64_t)&v5, (uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_100272F68(_Unwind_Exception *a1)
{
}

void sub_100272F7C(uint64_t a1, uint64_t a2, char **a3, void *a4)
{
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100272FD0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100272FEC()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936068);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936068))
    {
      qword_101936050 = 0LL;
      *(void *)algn_101936058 = 0LL;
      qword_101936060 = 0LL;
      __cxa_atexit((void (*)(void *))sub_1001BA3E4, &qword_101936050, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936068);
    }
  }

void sub_100273050()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936118);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936118))
    {
      std::__shared_mutex_base::__shared_mutex_base(&stru_101936070);
      __cxa_atexit((void (*)(void *))sub_1001BA414, &stru_101936070, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936118);
    }
  }

void sub_1002730C4(_Unwind_Exception *a1)
{
}

void sub_100273180(id a1)
{
  qword_101993DA8 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLHRRecoveryServiceSilo");
}

void sub_100273234(id a1)
{
}

void sub_1002738C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_10027390C(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  unint64_t v8 = operator new(0x188uLL);
  unint64_t v9 = v8;
  unint64_t v10 = (std::__shared_weak_count *)a1[1];
  uint64_t v32 = *a1;
  int v33 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  __int128 v13 = (std::__shared_weak_count *)a2[1];
  uint64_t v30 = *a2;
  uint64_t v31 = v13;
  if (v13)
  {
    BOOL v14 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }

  float v16 = (std::__shared_weak_count *)a3[1];
  uint64_t v28 = *a3;
  int v29 = v16;
  if (v16)
  {
    float v17 = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }

  sub_10066E668(v8, &v32, &v30, &v28);
  *a4 = v9;
  unint64_t v19 = v29;
  if (v29)
  {
    unint64_t v20 = (unint64_t *)&v29->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  uint64_t v22 = v31;
  if (v31)
  {
    unint64_t v23 = (unint64_t *)&v31->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  std::stringbuf v25 = v33;
  if (v33)
  {
    uint64_t v26 = (unint64_t *)&v33->__shared_owners_;
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

void sub_100273A78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
}

id sub_100273AAC(void *__src, void *a2)
{
  return [a2 onHRRecoveryEstimate:__dst];
}

id sub_100273AF4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return _[a4 onCatherineNotification:a2 data:a3];
}

id sub_100273B04(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return [a4 onMotionStateMediatorNotification:a2 data:a3];
}

id sub_100273B14(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return _[a4 onNatalimetryNotification:a2 data:a3];
}

void sub_100273E58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_100273E6C(void **a1, double a2)
{
  if (a2 >= 0.0)
  {
    unint64_t v8 = a1[2];
    uint64_t v6 = (uint64_t)(a1 + 2);
    char v7 = v8;
    unint64_t v9 = *(void *)(v6 - 8);
    if (v9 >= (unint64_t)v8)
    {
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (void)*a1) >> 3);
      unint64_t v12 = v11 + 1;
      if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100007008();
      }
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (_BYTE *)*a1) >> 3);
      if (2 * v13 > v12) {
        unint64_t v12 = 2 * v13;
      }
      if (v13 >= 0x555555555555555LL) {
        unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14) {
        unint64_t v15 = (char *)sub_10000701C(v6, v14);
      }
      else {
        unint64_t v15 = 0LL;
      }
      float v16 = &v15[24 * v11];
      float v17 = &v15[24 * v14];
      *(double *)float v16 = a2;
      *((void *)v16 + 1) = 0x7FEFFFFFFFFFFFFFLL;
      v16[16] = 0;
      unint64_t v10 = v16 + 24;
      unint64_t v19 = (char *)*a1;
      unint64_t v18 = (char *)a1[1];
      if (v18 != *a1)
      {
        do
        {
          __int128 v20 = *(_OWORD *)(v18 - 24);
          *(v16 - std::ostream::~ostream(v2, v3 + 8) = *(v18 - 8);
          *(_OWORD *)(v16 - 24) = v20;
          v16 -= 24;
          v18 -= 24;
        }

        while (v18 != v19);
        unint64_t v18 = (char *)*a1;
      }

      *a1 = v16;
      a1[1] = v10;
      a1[2] = v17;
      if (v18) {
        operator delete(v18);
      }
    }

    else
    {
      *(double *)unint64_t v9 = a2;
      *(void *)(v9 + std::ostream::~ostream(v2, v3 + 8) = 0x7FEFFFFFFFFFFFFFLL;
      *(_BYTE *)(v9 + 16) = 0;
      unint64_t v10 = (char *)(v9 + 24);
    }

    a1[1] = v10;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    unint64_t v3 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134349056;
      double v24 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Programmer error, this expiration rule with time %{public}fis not valid.",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182D138);
      }
      int v21 = 134349056;
      double v22 = a2;
      uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Programmer error, this expiration rule with time %{public}fis not valid.",  &v21,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLActivityAggregator<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::setExpirationRule(CFTime Interval) [T = HRRecoveryInputHR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v4);
    }
  }

void sub_100274120(void **a1, double a2)
{
  if (a2 >= 0.0)
  {
    unint64_t v8 = a1[2];
    uint64_t v6 = (uint64_t)(a1 + 2);
    char v7 = v8;
    unint64_t v9 = *(void *)(v6 - 8);
    if (v9 >= (unint64_t)v8)
    {
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (void)*a1) >> 3);
      unint64_t v12 = v11 + 1;
      if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100007008();
      }
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (_BYTE *)*a1) >> 3);
      if (2 * v13 > v12) {
        unint64_t v12 = 2 * v13;
      }
      if (v13 >= 0x555555555555555LL) {
        unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14) {
        unint64_t v15 = (char *)sub_10000701C(v6, v14);
      }
      else {
        unint64_t v15 = 0LL;
      }
      float v16 = &v15[24 * v11];
      float v17 = &v15[24 * v14];
      *(double *)float v16 = a2;
      *((void *)v16 + 1) = 0x7FEFFFFFFFFFFFFFLL;
      v16[16] = 0;
      unint64_t v10 = v16 + 24;
      unint64_t v19 = (char *)*a1;
      unint64_t v18 = (char *)a1[1];
      if (v18 != *a1)
      {
        do
        {
          __int128 v20 = *(_OWORD *)(v18 - 24);
          *(v16 - std::ostream::~ostream(v2, v3 + 8) = *(v18 - 8);
          *(_OWORD *)(v16 - 24) = v20;
          v16 -= 24;
          v18 -= 24;
        }

        while (v18 != v19);
        unint64_t v18 = (char *)*a1;
      }

      *a1 = v16;
      a1[1] = v10;
      a1[2] = v17;
      if (v18) {
        operator delete(v18);
      }
    }

    else
    {
      *(double *)unint64_t v9 = a2;
      *(void *)(v9 + std::ostream::~ostream(v2, v3 + 8) = 0x7FEFFFFFFFFFFFFFLL;
      *(_BYTE *)(v9 + 16) = 0;
      unint64_t v10 = (char *)(v9 + 24);
    }

    a1[1] = v10;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    unint64_t v3 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134349056;
      double v24 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Programmer error, this expiration rule with time %{public}fis not valid.",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182D138);
      }
      int v21 = 134349056;
      double v22 = a2;
      uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Programmer error, this expiration rule with time %{public}fis not valid.",  &v21,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLActivityAggregator<HRRecoveryInputWR, CLActivityDB::ClassBDataProtectionPolicy>::setExpirationRule(CFTime Interval) [T = HRRecoveryInputWR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v4);
    }
  }

void sub_1002743D4(void **a1, double a2)
{
  if (a2 >= 0.0)
  {
    unint64_t v8 = a1[2];
    uint64_t v6 = (uint64_t)(a1 + 2);
    char v7 = v8;
    unint64_t v9 = *(void *)(v6 - 8);
    if (v9 >= (unint64_t)v8)
    {
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (void)*a1) >> 3);
      unint64_t v12 = v11 + 1;
      if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100007008();
      }
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (_BYTE *)*a1) >> 3);
      if (2 * v13 > v12) {
        unint64_t v12 = 2 * v13;
      }
      if (v13 >= 0x555555555555555LL) {
        unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14) {
        unint64_t v15 = (char *)sub_10000701C(v6, v14);
      }
      else {
        unint64_t v15 = 0LL;
      }
      float v16 = &v15[24 * v11];
      float v17 = &v15[24 * v14];
      *(double *)float v16 = a2;
      *((void *)v16 + 1) = 0x7FEFFFFFFFFFFFFFLL;
      v16[16] = 0;
      unint64_t v10 = v16 + 24;
      unint64_t v19 = (char *)*a1;
      unint64_t v18 = (char *)a1[1];
      if (v18 != *a1)
      {
        do
        {
          __int128 v20 = *(_OWORD *)(v18 - 24);
          *(v16 - std::ostream::~ostream(v2, v3 + 8) = *(v18 - 8);
          *(_OWORD *)(v16 - 24) = v20;
          v16 -= 24;
          v18 -= 24;
        }

        while (v18 != v19);
        unint64_t v18 = (char *)*a1;
      }

      *a1 = v16;
      a1[1] = v10;
      a1[2] = v17;
      if (v18) {
        operator delete(v18);
      }
    }

    else
    {
      *(double *)unint64_t v9 = a2;
      *(void *)(v9 + std::ostream::~ostream(v2, v3 + 8) = 0x7FEFFFFFFFFFFFFFLL;
      *(_BYTE *)(v9 + 16) = 0;
      unint64_t v10 = (char *)(v9 + 24);
    }

    a1[1] = v10;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    unint64_t v3 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134349056;
      double v24 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Programmer error, this expiration rule with time %{public}fis not valid.",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182D138);
      }
      int v21 = 134349056;
      double v22 = a2;
      uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Programmer error, this expiration rule with time %{public}fis not valid.",  &v21,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLActivityAggregator<HRRecoverySession, CLActivityDB::ClassBDataProtectionPolicy>::setExpirationRule(CFTime Interval) [T = HRRecoverySession, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v4);
    }
  }

uint64_t sub_100274688(uint64_t a1)
{
  if (qword_101934770 != -1) {
    dispatch_once(&qword_101934770, &stru_10182D028);
  }
  uint64_t v2 = (os_log_s *)qword_101934778;
  if (os_log_type_enabled((os_log_t)qword_101934778, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Aggregating HRRecovery db records", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934770 != -1) {
      dispatch_once(&qword_101934770, &stru_10182D028);
    }
    v5[0] = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934778,  0LL,  "Aggregating HRRecovery db records",  v5,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "-[CLHRRecoveryService setUpAggregationOnTimer]_block_invoke", "%s\n", v4);
  }

  sub_100274854(*(void *)(*(void *)(a1 + 32) + 24LL));
  sub_100274DC8(*(void *)(*(void *)(a1 + 32) + 48LL));
  return sub_10027533C(*(void *)(*(void *)(a1 + 32) + 72LL));
}

uint64_t sub_100274854(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 40)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182D138);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v3 = sub_101171D38();
    int v4 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::stringbuf::string_type buf = 134218240;
    *(double *)int v33 = v3;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Aggregating records start %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    uint64_t v16 = qword_101934A78;
    double v17 = sub_101171D38();
    int v18 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)uint64_t v30 = v17;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v18;
    unint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  2LL,  "Aggregating records start %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = HR RecoveryInputHR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v19);
  }

  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182D138);
  }
  uint64_t v6 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v7 = sub_101171D38();
    int v8 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::stringbuf::string_type buf = 134218240;
    *(double *)int v33 = v7;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Aggregating records stop %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    uint64_t v20 = qword_101934A78;
    double v21 = sub_101171D38();
    int v22 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)uint64_t v30 = v21;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v22;
    unint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  2LL,  "Aggregating records stop %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = HR RecoveryInputHR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v23);
  }

  uint64_t v9 = *(void *)(a1 + 24);
  double v10 = (double)*(int *)(v9 + 132);
  if ((double)(int)sub_100277B04(v9, (double **)a1) * 1.2 < v10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    unint64_t v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 24);
      int v13 = *(_DWORD *)(v12 + 132);
      int v14 = sub_100277B04(v12, (double **)a1);
      *(_DWORD *)std::stringbuf::string_type buf = 67109376;
      *(_DWORD *)int v33 = v13;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182D138);
      }
      uint64_t v24 = qword_101934A78;
      uint64_t v25 = *(void *)(a1 + 24);
      int v26 = *(_DWORD *)(v25 + 132);
      int v27 = sub_100277B04(v25, (double **)a1);
      int v29 = 67109376;
      *(_DWORD *)uint64_t v30 = v26;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = v27;
      uint64_t v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v24,  0LL,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records es timated to be needed %d",  &v29,  14);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = HRRecoveryInputHR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v28);
    }
  }

  return v5;
}

uint64_t sub_100274DC8(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 40)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182D138);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v3 = sub_101171D38();
    int v4 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::stringbuf::string_type buf = 134218240;
    *(double *)int v33 = v3;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Aggregating records start %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    uint64_t v16 = qword_101934A78;
    double v17 = sub_101171D38();
    int v18 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)uint64_t v30 = v17;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v18;
    unint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  2LL,  "Aggregating records start %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<HRRecoveryInputWR, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = HR RecoveryInputWR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v19);
  }

  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182D138);
  }
  uint64_t v6 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v7 = sub_101171D38();
    int v8 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::stringbuf::string_type buf = 134218240;
    *(double *)int v33 = v7;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Aggregating records stop %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    uint64_t v20 = qword_101934A78;
    double v21 = sub_101171D38();
    int v22 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)uint64_t v30 = v21;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v22;
    unint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  2LL,  "Aggregating records stop %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<HRRecoveryInputWR, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = HR RecoveryInputWR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v23);
  }

  uint64_t v9 = *(void *)(a1 + 24);
  double v10 = (double)*(int *)(v9 + 132);
  if ((double)(int)sub_100277D2C(v9, (double **)a1) * 1.2 < v10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    unint64_t v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 24);
      int v13 = *(_DWORD *)(v12 + 132);
      int v14 = sub_100277D2C(v12, (double **)a1);
      *(_DWORD *)std::stringbuf::string_type buf = 67109376;
      *(_DWORD *)int v33 = v13;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182D138);
      }
      uint64_t v24 = qword_101934A78;
      uint64_t v25 = *(void *)(a1 + 24);
      int v26 = *(_DWORD *)(v25 + 132);
      int v27 = sub_100277D2C(v25, (double **)a1);
      int v29 = 67109376;
      *(_DWORD *)uint64_t v30 = v26;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = v27;
      uint64_t v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v24,  0LL,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records es timated to be needed %d",  &v29,  14);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<HRRecoveryInputWR, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = HRRecoveryInputWR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v28);
    }
  }

  return v5;
}

uint64_t sub_10027533C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 40)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182D138);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v3 = sub_101171D38();
    int v4 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::stringbuf::string_type buf = 134218240;
    *(double *)int v33 = v3;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Aggregating records start %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    uint64_t v16 = qword_101934A78;
    double v17 = sub_101171D38();
    int v18 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)uint64_t v30 = v17;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v18;
    unint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  2LL,  "Aggregating records start %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<HRRecoverySession, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = HR RecoverySession, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v19);
  }

  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182D138);
  }
  uint64_t v6 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v7 = sub_101171D38();
    int v8 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::stringbuf::string_type buf = 134218240;
    *(double *)int v33 = v7;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Aggregating records stop %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    uint64_t v20 = qword_101934A78;
    double v21 = sub_101171D38();
    int v22 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)uint64_t v30 = v21;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v22;
    unint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  2LL,  "Aggregating records stop %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<HRRecoverySession, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = HR RecoverySession, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v23);
  }

  uint64_t v9 = *(void *)(a1 + 24);
  double v10 = (double)*(int *)(v9 + 132);
  if ((double)(int)sub_100277F28(v9, (double **)a1) * 1.2 < v10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182D138);
    }
    unint64_t v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 24);
      int v13 = *(_DWORD *)(v12 + 132);
      int v14 = sub_100277F28(v12, (double **)a1);
      *(_DWORD *)std::stringbuf::string_type buf = 67109376;
      *(_DWORD *)int v33 = v13;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182D138);
      }
      uint64_t v24 = qword_101934A78;
      uint64_t v25 = *(void *)(a1 + 24);
      int v26 = *(_DWORD *)(v25 + 132);
      int v27 = sub_100277F28(v25, (double **)a1);
      int v29 = 67109376;
      *(_DWORD *)uint64_t v30 = v26;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = v27;
      uint64_t v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v24,  0LL,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records es timated to be needed %d",  &v29,  14);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<HRRecoverySession, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = HRRecoverySession, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v28);
    }
  }

  return v5;
}

void sub_100276D64(_Unwind_Exception *a1)
{
}

NSDictionary *sub_100276DA4(uint64_t a1)
{
  v45[0] = @"age_bin";
  float v2 = *(float *)(*(void *)(a1 + 32) + 100LL);
  uint64_t v43 = 0LL;
  uint64_t v44 = 0LL;
  uint64_t v42 = 0LL;
  sub_10001B72C( &v42,  (const void *)qword_101993DE8,  *(uint64_t *)algn_101993DF0,  (*(void *)algn_101993DF0 - qword_101993DE8) >> 2);
  if (v43 == v42)
  {
    unint64_t v3 = 0LL;
  }

  else
  {
    unint64_t v3 = 0LL;
    unint64_t v4 = (v43 - (_BYTE *)v42) >> 2;
    if (v4 <= 1) {
      unint64_t v4 = 1LL;
    }
    while (*((float *)v42 + v3) < v2)
    {
      if (v4 == ++v3)
      {
        unint64_t v3 = v4;
        break;
      }
    }
  }

  v46[0] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v3);
  v45[1] = @"gender";
  v46[1] = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 96LL));
  v45[2] = @"useBetaBlocker";
  id v46[2] = +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(a1 + 32) + 108LL));
  v45[3] = @"userBMI_bin";
  float v5 = *(float *)(*(void *)(a1 + 32) + 104LL);
  uint64_t v40 = 0LL;
  uint64_t v41 = 0LL;
  std::string::size_type v39 = 0LL;
  sub_10001B72C( &v39,  (const void *)qword_101993E08,  *(uint64_t *)algn_101993E10,  (*(void *)algn_101993E10 - qword_101993E08) >> 2);
  if (v40 == v39)
  {
    unint64_t v6 = 0LL;
  }

  else
  {
    unint64_t v6 = 0LL;
    unint64_t v7 = (v40 - (_BYTE *)v39) >> 2;
    if (v7 <= 1) {
      unint64_t v7 = 1LL;
    }
    while (*((float *)v39 + v6) < v5)
    {
      if (v7 == ++v6)
      {
        unint64_t v6 = v7;
        break;
      }
    }
  }

  v46[3] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v6);
  v45[4] = @"restingHR";
  LODWORD(vstd::ostream::~ostream(v2, v3 + 8) = *(_DWORD *)(*(void *)(a1 + 32) + 220LL);
  v46[4] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v8);
  v45[5] = @"hrmax";
  LODWORD(v9) = *(_DWORD *)(*(void *)(a1 + 32) + 224LL);
  v46[5] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v9);
  v45[6] = @"HRRecoveryEstimateStatus";
  v46[6] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 112LL));
  v45[7] = @"diffTimeRecoveryOnsetWorkout";
  v46[7] = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(*(void *)(a1 + 32) + 120LL));
  v45[8] = @"diffTimeTDropWorkoutEnd";
  v46[8] = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(*(void *)(a1 + 32) + 128LL));
  v45[9] = @"hrRecovery";
  v46[9] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 136LL));
  v45[10] = @"hrRecoverySession";
  v46[10] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 140LL));
  v45[11] = @"peakHR";
  LODWORD(v1sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)(a1 + 32) + 144LL);
  v46[11] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v10);
  v45[12] = @"steadyStateHR";
  LODWORD(v11) = *(_DWORD *)(*(void *)(a1 + 32) + 148LL);
  v46[12] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v11);
  v45[13] = @"hrMinAdjusted";
  LODWORD(v12) = *(_DWORD *)(*(void *)(a1 + 32) + 152LL);
  v46[13] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v12);
  v45[14] = @"observedHRRecovery";
  LODWORD(v13) = *(_DWORD *)(*(void *)(a1 + 32) + 156LL);
  v46[14] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v13);
  v45[15] = @"recoveryLoad";
  LODWORD(v14) = *(_DWORD *)(*(void *)(a1 + 32) + 160LL);
  v46[15] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v14);
  v45[16] = @"maxRecoveryHR";
  LODWORD(v15) = *(_DWORD *)(*(void *)(a1 + 32) + 164LL);
  v46[16] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v15);
  v45[17] = @"minRecoveryHR";
  LODWORD(v16) = *(_DWORD *)(*(void *)(a1 + 32) + 168LL);
  v46[17] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v16);
  v45[18] = @"recoveryMetsMean";
  LODWORD(v17) = *(_DWORD *)(*(void *)(a1 + 32) + 172LL);
  v46[18] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v17);
  v45[19] = @"recoveryMetsStdDev";
  LODWORD(v1std::ostream::~ostream(v2, v3 + 8) = *(_DWORD *)(*(void *)(a1 + 32) + 176LL);
  v46[19] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v18);
  v45[20] = @"biasAdjustment";
  LODWORD(v19) = *(_DWORD *)(*(void *)(a1 + 32) + 180LL);
  v46[20] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v19);
  v45[21] = @"isOtherwiseEligibleForLongitudinal";
  v46[21] = +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(a1 + 32) + 184LL));
  v45[22] = @"hrRecoveryReference";
  LODWORD(v2sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)(a1 + 32) + 188LL);
  v46[22] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v20);
  v45[23] = @"hrRecoveryReferencePeak";
  LODWORD(v21) = *(_DWORD *)(*(void *)(a1 + 32) + 192LL);
  v46[23] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v21);
  v45[24] = @"hrOneMinPostRecovery";
  LODWORD(v22) = *(_DWORD *)(*(void *)(a1 + 32) + 196LL);
  v46[24] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v22);
  v45[25] = @"hrOneMinExponential";
  LODWORD(v23) = *(_DWORD *)(*(void *)(a1 + 32) + 200LL);
  v46[25] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v23);
  v45[26] = @"isEligibleForHK";
  v46[26] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned __int8 *)(*(void *)(a1 + 32) + 204LL));
  v45[27] = @"minHRAfterWorkoutEnd";
  LODWORD(v24) = *(_DWORD *)(*(void *)(a1 + 32) + 208LL);
  v46[27] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v24);
  _BYTE v45[28] = @"maxHRAfterWorkoutEnd";
  LODWORD(v25) = *(_DWORD *)(*(void *)(a1 + 32) + 212LL);
  v46[28] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v25);
  v45[29] = @"oneMinusFHRAfterWorkoutEnd";
  LODWORD(v26) = *(_DWORD *)(*(void *)(a1 + 32) + 216LL);
  v46[29] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v26);
  v45[30] = @"peakHrOneMinusFhr";
  LODWORD(v27) = *(_DWORD *)(*(void *)(a1 + 32) + 228LL);
  v46[30] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v27);
  v45[31] = @"vo2MaxEstimationStatus";
  v46[31] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 232LL));
  v45[32] = @"VO2MaxValue";
  v46[32] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 236LL));
  v45[33] = @"lambda";
  LODWORD(v2std::ostream::~ostream(v2, v3 + 8) = *(_DWORD *)(*(void *)(a1 + 32) + 240LL);
  v46[33] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v28);
  v45[34] = @"mse";
  LODWORD(v29) = *(_DWORD *)(*(void *)(a1 + 32) + 244LL);
  v46[34] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v29);
  v45[35] = @"evs";
  LODWORD(v3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_DWORD *)(*(void *)(a1 + 32) + 248LL);
  v46[35] = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v30);
  v45[36] = @"sessionType";
  v46[36] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 252LL));
  v45[37] = @"workoutType";
  v46[37] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 256LL));
  v45[38] = @"sessionDuration_bin";
  float v31 = *(float *)(*(void *)(a1 + 32) + 264LL);
  uint64_t v37 = 0LL;
  uint64_t v38 = 0LL;
  std::stringbuf::string_type __p = 0LL;
  sub_10001B72C( &__p,  (const void *)qword_101993DC8,  *(uint64_t *)algn_101993DD0,  (*(void *)algn_101993DD0 - qword_101993DC8) >> 2);
  if (v37 == __p)
  {
    unint64_t v32 = 0LL;
  }

  else
  {
    unint64_t v32 = 0LL;
    unint64_t v33 = (v37 - (_BYTE *)__p) >> 2;
    if (v33 <= 1) {
      unint64_t v33 = 1LL;
    }
    while (*((float *)__p + v32) < v31)
    {
      if (v33 == ++v32)
      {
        unint64_t v32 = v33;
        break;
      }
    }
  }

  v46[38] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v32);
  v45[39] = @"LyonAlgVersion";
  v46[39] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 268LL));
  int v34 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v46,  v45,  40LL);
  if (__p)
  {
    uint64_t v37 = __p;
    operator delete(__p);
  }

  if (v39)
  {
    uint64_t v40 = v39;
    operator delete(v39);
  }

  if (v42)
  {
    uint64_t v43 = v42;
    operator delete(v42);
  }

  return v34;
}

void sub_10027753C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16)
{
}

void sub_10027779C(id a1)
{
  qword_101934778 = (uint64_t)os_log_create("com.apple.locationd.Motion", "HRRecovery");
}

void *sub_1002777C8@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x170uLL);
  __n128 result = sub_100277820(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10027780C(_Unwind_Exception *a1)
{
}

void *sub_100277820(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10182D058;
  sub_100F6130C(a1 + 3, *a2);
  return a1;
}

void sub_10027785C(_Unwind_Exception *a1)
{
}

void sub_100277870(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182D058;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100277884(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182D058;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1002778A8(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void *sub_1002778B8@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x190uLL);
  __n128 result = sub_100277910(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1002778FC(_Unwind_Exception *a1)
{
}

void *sub_100277910(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10182D0A8;
  sub_100CB2710(a1 + 3, *a2);
  return a1;
}

void sub_10027794C(_Unwind_Exception *a1)
{
}

void sub_100277960(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182D0A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100277974(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182D0A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100277998(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void *sub_1002779A8@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x1F0uLL);
  __n128 result = sub_100277A00(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1002779EC(_Unwind_Exception *a1)
{
}

void *sub_100277A00(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10182D0F8;
  sub_1007F330C(a1 + 3, *a2);
  return a1;
}

void sub_100277A3C(_Unwind_Exception *a1)
{
}

void sub_100277A50(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182D0F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100277A64(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182D0F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100277A88(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void sub_100277A98(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10000AE14((uint64_t)a2 + 80);
    sub_10000AE14((uint64_t)a2 + 64);
    sub_10000AE14((uint64_t)a2 + 48);
    operator delete(a2);
  }

void sub_100277AD8(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_100277B04(uint64_t a1, double **a2)
{
  unint64_t v3 = *a2;
  float v2 = a2[1];
  double v4 = (*a2)[1];
  double v5 = *(float *)(a1 + 136);
  if (v4 <= v5) {
    double v4 = *(float *)(a1 + 136);
  }
  unint64_t v6 = v3 + 3;
  if (v3 + 3 == v2)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    LODWORD(v7) = 0;
    double v8 = *v3;
    do
    {
      double v9 = *v6;
      double v10 = v6[1];
      v6 += 3;
      uint64_t v7 = (v7 + (int)((v9 - v8) / v4));
      if (v10 <= v5) {
        double v4 = *(float *)(a1 + 136);
      }
      else {
        double v4 = v10;
      }
      double v8 = v9;
    }

    while (v6 != v2);
  }

  if (v4 != 1.79769313e308)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182D158);
    }
    double v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning No expiration rule was added so the number of records will be unbounded.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182D158);
      }
      v14[0] = 0;
      double v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning No expiration rule was added so the number of records will be unbounded.",  v14,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLActivityRecorderDb<HRRecoveryInputHR, CLActivityDB::ClassBDataProtectionPolicy>::estimateRecordsNeeded(con st CLAggregationRules &) [T = HRRecoveryInputHR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v13);
    }
  }

  return v7;
}

void sub_100277D00(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_100277D2C(uint64_t a1, double **a2)
{
  unint64_t v3 = *a2;
  float v2 = a2[1];
  double v4 = (*a2)[1];
  double v5 = *(float *)(a1 + 136);
  if (v4 <= v5) {
    double v4 = *(float *)(a1 + 136);
  }
  unint64_t v6 = v3 + 3;
  if (v3 + 3 == v2)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    LODWORD(v7) = 0;
    double v8 = *v3;
    do
    {
      double v9 = *v6;
      double v10 = v6[1];
      v6 += 3;
      uint64_t v7 = (v7 + (int)((v9 - v8) / v4));
      if (v10 <= v5) {
        double v4 = *(float *)(a1 + 136);
      }
      else {
        double v4 = v10;
      }
      double v8 = v9;
    }

    while (v6 != v2);
  }

  if (v4 != 1.79769313e308)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182D158);
    }
    double v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning No expiration rule was added so the number of records will be unbounded.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182D158);
      }
      v14[0] = 0;
      double v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning No expiration rule was added so the number of records will be unbounded.",  v14,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLActivityRecorderDb<HRRecoveryInputWR, CLActivityDB::ClassBDataProtectionPolicy>::estimateRecordsNeeded(con st CLAggregationRules &) [T = HRRecoveryInputWR, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v13);
    }
  }

  return v7;
}

uint64_t sub_100277F28(uint64_t a1, double **a2)
{
  unint64_t v3 = *a2;
  float v2 = a2[1];
  double v4 = (*a2)[1];
  double v5 = *(float *)(a1 + 136);
  if (v4 <= v5) {
    double v4 = *(float *)(a1 + 136);
  }
  unint64_t v6 = v3 + 3;
  if (v3 + 3 == v2)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    LODWORD(v7) = 0;
    double v8 = *v3;
    do
    {
      double v9 = *v6;
      double v10 = v6[1];
      v6 += 3;
      uint64_t v7 = (v7 + (int)((v9 - v8) / v4));
      if (v10 <= v5) {
        double v4 = *(float *)(a1 + 136);
      }
      else {
        double v4 = v10;
      }
      double v8 = v9;
    }

    while (v6 != v2);
  }

  if (v4 != 1.79769313e308)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182D158);
    }
    double v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning No expiration rule was added so the number of records will be unbounded.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182D158);
      }
      v14[0] = 0;
      double v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning No expiration rule was added so the number of records will be unbounded.",  v14,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLActivityRecorderDb<HRRecoverySession, CLActivityDB::ClassBDataProtectionPolicy>::estimateRecordsNeeded(con st CLAggregationRules &) [T = HRRecoverySession, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v13);
    }
  }

  return v7;
}

void sub_1002781C8(id a1)
{
  qword_101993E40 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLActivityLoggerAdapterSilo");
}

uint64_t sub_100278280(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10027839C;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_101993E50 != -1) {
    dispatch_once(&qword_101993E50, block);
  }
  return qword_1019A0E08;
}

uint64_t sub_10027839C(uint64_t a1)
{
  float v2 = operator new(0x90uLL);
  uint64_t result = sub_1002783E8((uint64_t)v2, *(void *)(a1 + 32));
  qword_1019A0E08 = (uint64_t)v2;
  return result;
}

void sub_1002783D4(_Unwind_Exception *a1)
{
}

uint64_t sub_1002783E8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  sub_100309D64(0, __p);
  if ((__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
    unint64_t v3 = __p;
  }
  else {
    unint64_t v3 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
  }
  double v4 =  -[NSString stringByAppendingPathComponent:]( +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v3),  "stringByAppendingPathComponent:",  @"activityLog.pb");
  *(void *)(a1 + std::ostream::~ostream(v2, v3 + 8) = v4;
  *(void *)(a1 + 16) = 0LL;
  sub_1002651D4((void *)(a1 + 24), v4);
  sub_100D7A214( a1 + 72,  "CMActivityLog",  objc_msgSend(objc_msgSend(*(id *)a1, "silo"), "queue"),  objc_msgSend(*(id *)(a1 + 8), "UTF8String"));
  [*(id *)a1 silo];
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10182D198);
  }
  double v5 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(__p[0].__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "CLActivityLogger being constructed.",  (uint8_t *)__p,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182D198);
    }
    v13[0] = 0;
    double v12 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "CLActivityLogger being constructed.",  v13,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityLogger::CLActivityLogger(id<CLIntersiloUniverse>)",  "%s\n",  (const char *)v12);
    if (v12 != __p) {
      free(v12);
    }
  }

  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver( DarwinNotifyCenter,  (const void *)a1,  (CFNotificationCallback)sub_100278748,  @"NanoLifestyleEnableFitnessDataCollectionSettingDidChangeNotification",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  uint64_t v7 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver( v7,  (const void *)a1,  (CFNotificationCallback)sub_100278748,  @"com.apple.managedconfiguration.defaultsdidchange",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  sub_100468458((uint64_t)sub_100278968, a1, *(void **)a1, __p);
  std::string::size_type v8 = __p[0].__r_.__value_.__r.__words[0];
  __p[0].__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v9 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    std::string::size_type v10 = __p[0].__r_.__value_.__r.__words[0];
    __p[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v10) {
      (*(void (**)(std::string::size_type))(*(void *)v10 + 8LL))(v10);
    }
  }

  [*(id *)(*(void *)(a1 + 16) + 16) register:*(void *)(*(void *)(a1 + 16) + 8) forNotification:1 registrationInfo:0];
  return a1;
}

void sub_1002786D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  uint64_t v22 = *(void *)(v18 + 16);
  *(void *)(v18 + 16) = 0LL;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
  }
  _Unwind_Resume(a1);
}

void sub_100278748(uint64_t a1, id *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182D1D8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v15 = 1;
    std::string::size_type v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLActivityLogger::onFitnessDataCollectionSettingChangedNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182D1D8);
    }
    double v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      __int16 v20 = 2082;
      double v21 = "activity";
      __int16 v22 = 2050;
      double v23 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLActivityLogger::onFitnessDataCollectionSettingChangedNotification, event:%{public , location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v15 = 0;
  }

  id v12 = [*a2 silo];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  _DWORD v13[2] = sub_1002793D8;
  void v13[3] = &unk_10182D1B8;
  v13[4] = a2;
  void v13[5] = a1;
  v13[6] = a3;
  v13[7] = a4;
  _WORD v13[8] = a5;
  [v12 sync:v13];
  if (v15) {
    os_activity_scope_leave(&state);
  }
}

void sub_100278948( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state, char a19)
{
  if (a19) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100278968(uint64_t a1, int *a2, unsigned int *a3, id *a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182D1D8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    std::string::size_type v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLActivityLogger::onMotionStateMediatorNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182D1D8);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      char v15 = "";
      __int16 v16 = 2082;
      int v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLActivityLogger::onMotionStateMediatorNotification, event:%{public, location:escap e_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100278BE0((uint64_t)a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100278B20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100278B40(uint64_t a1)
{
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver( DarwinNotifyCenter,  (const void *)a1,  @"NanoLifestyleEnableFitnessDataCollectionSettingDidChangeNotification",  0LL);
  unint64_t v3 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver( v3,  (const void *)a1,  @"com.apple.managedconfiguration.defaultsdidchange",  0LL);
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }

  *(void *)(a1 + std::ostream::~ostream(v2, v3 + 8) = 0LL;
  sub_100D7B78C(a1 + 72);
  sub_1002659C8(a1 + 24);
  uint64_t v5 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return a1;
}

void sub_100278BE0(uint64_t a1, uint64_t a2, int *a3, unsigned int *a4)
{
  if (*a3 == 1)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182D198);
    }
    uint64_t v7 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v8 = *a4;
      unsigned int v9 = a4[2];
      unsigned int v10 = a4[3];
      unsigned int v11 = a4[5];
      unsigned int v12 = a4[6];
      unsigned int v13 = a4[15];
      uint64_t v14 = *((void *)a4 + 8);
      uint64_t v15 = *((void *)a4 + 11);
      *(_DWORD *)std::stringbuf::string_type buf = 67110912;
      *(_DWORD *)uint64_t v38 = v8;
      *(_WORD *)&v38[4] = 1024;
      *(_DWORD *)&v38[6] = v9;
      __int16 v39 = 1024;
      unsigned int v40 = v10;
      __int16 v41 = 1024;
      unsigned int v42 = v11;
      __int16 v43 = 1024;
      unsigned int v44 = v12;
      __int16 v45 = 1024;
      unsigned int v46 = v13;
      __int16 v47 = 2048;
      uint64_t v48 = v14;
      __int16 v49 = 2048;
      uint64_t v50 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "CLActivityLogger, kNotificationActivityOverride,overrideAction,%d,activity{State,%d,Confidence,%d,MountedState,% d,MountedConfidence,%d,exitState,%d,estExitTime,%f,startTime,%f}",  buf,  0x3Au);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182D198);
      }
      unsigned int v23 = a4[2];
      unsigned int v24 = a4[3];
      unsigned int v25 = a4[5];
      unsigned int v26 = a4[15];
      double v27 = *((double *)a4 + 8);
      uint64_t v28 = *((void *)a4 + 11);
      WORD2(v32) = 1024;
      HIWORD(v32) = v23;
      LOWORD(v33) = HIWORD(v25);
      HIWORD(v33) = 1024;
      LOWORD(v34) = 1024;
      *(_DWORD *)((char *)&v34 + 2) = v26;
      HIWORD(v34) = 2048;
      __int16 v35 = 2048;
      uint64_t v36 = v28;
      double v29 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "CLActivityLogger, kNotificationActivityOverride,overrideAction,%d,activity{State,%d,Confidence,%d, MountedState,%d,MountedConfidence,%d,exitState,%d,estExitTime,%f,startTime,%f}",  &v31,  58,  67110912,  HIDWORD(v32),  v24,  v33,  v34,  v27);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityLogger::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)",  "%s\n",  v29);
    }

    __int16 v16 = objc_alloc_init(&OBJC_CLASS___ALActivityLog);
    -[ALActivityLog setTimestamp:](v16, "setTimestamp:", CFAbsoluteTimeGetCurrent());
    -[ALActivityLog setActivityOverrideMsg:]( v16,  "setActivityOverrideMsg:",  objc_alloc_init(&OBJC_CLASS___ALActivityOverrideMsg));
    -[ALActivityOverrideMsg setOverrideAction:]( -[ALActivityLog activityOverrideMsg](v16, "activityOverrideMsg"),  "setOverrideAction:",  *a4);
    -[ALActivityOverrideMsg setActivity:]( -[ALActivityLog activityOverrideMsg](v16, "activityOverrideMsg"),  "setActivity:",  objc_alloc_init(&OBJC_CLASS___ALCLMotionActivity));
    -[ALCLMotionActivity setType:]( -[ALActivityOverrideMsg activity](-[ALActivityLog activityOverrideMsg](v16, "activityOverrideMsg"), "activity"),  "setType:",  a4[2]);
    -[ALCLMotionActivity setConfidence:]( -[ALActivityOverrideMsg activity](-[ALActivityLog activityOverrideMsg](v16, "activityOverrideMsg"), "activity"),  "setConfidence:",  a4[3]);
    -[ALCLMotionActivity setMountedState:]( -[ALActivityOverrideMsg activity](-[ALActivityLog activityOverrideMsg](v16, "activityOverrideMsg"), "activity"),  "setMountedState:",  a4[5]);
    -[ALCLMotionActivity setMountedConfidence:]( -[ALActivityOverrideMsg activity](-[ALActivityLog activityOverrideMsg](v16, "activityOverrideMsg"), "activity"),  "setMountedConfidence:",  a4[6]);
    -[ALCLMotionActivity setExitState:]( -[ALActivityOverrideMsg activity](-[ALActivityLog activityOverrideMsg](v16, "activityOverrideMsg"), "activity"),  "setExitState:",  a4[15]);
    -[ALCLMotionActivity setEstExitTime:]( -[ALActivityOverrideMsg activity](-[ALActivityLog activityOverrideMsg](v16, "activityOverrideMsg"), "activity"),  "setEstExitTime:",  *((double *)a4 + 8));
    -[ALCLMotionActivity setStartTime:]( -[ALActivityOverrideMsg activity](-[ALActivityLog activityOverrideMsg](v16, "activityOverrideMsg"), "activity"),  "setStartTime:",  *((double *)a4 + 11));
    -[ALCLMotionActivity setTimestamp:]( -[ALActivityOverrideMsg activity](-[ALActivityLog activityOverrideMsg](v16, "activityOverrideMsg"), "activity"),  "setTimestamp:",  *((double *)a4 + 6));
    [*(id *)a1 silo];
    if (*(_BYTE *)(a1 + 72)) {
      sub_100265508((void *)(a1 + 24), v16);
    }
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182D198);
    }
    int v17 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      id v18 = objc_msgSend(-[ALActivityLog formattedText](v16, "formattedText"), "UTF8String");
      *(_DWORD *)std::stringbuf::string_type buf = 136315138;
      *(void *)uint64_t v38 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "CLActivityLogger,log kNotificationActivityOverride:%s",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182D198);
      }
      uint64_t v19 = qword_1019344B8;
      objc_msgSend(-[ALActivityLog formattedText](v16, "formattedText"), "UTF8String");
      __int16 v20 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v19,  2LL,  "CLActivityLogger,log kNotificationActivityOverride:%s",  &v31);
LABEL_30:
      double v30 = (uint8_t *)v20;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityLogger::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)",  "%s\n",  v20);
      if (v30 != buf) {
        free(v30);
      }
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182D198);
    }
    double v21 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = *a3;
      *(_DWORD *)std::stringbuf::string_type buf = 67109120;
      *(_DWORD *)uint64_t v38 = v22;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "#Warning CLActivityLogger, Unhandled notification %d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182D198);
      }
      __int16 v20 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning CLActivityLogger, Unhandled notification %d",  &v31);
      goto LABEL_30;
    }
  }

void sub_100279214(uint64_t a1)
{
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10182D198);
  }
  float v2 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "CLActivityLogger, dataCollection setting changed",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182D198);
    }
    v4[0] = 0;
    unint64_t v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "CLActivityLogger, dataCollection setting changed",  v4,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityLogger::onFitnessDataCollectionSettingChangedNotification(CFNotificationCenterRef, CFStringRef, con st void *, CFDictionaryRef)",  "%s\n",  v3);
  }

  sub_100D799C4(a1 + 72);
}

void sub_1002793AC(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_1002793D8(uint64_t a1)
{
}

void sub_1002793E0(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_10027940C()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_101993E28, (void *)&_mh_execute_header);
}

void sub_1002794F4(id a1)
{
  qword_101993E70 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLHarvestControllerSilo");
}

void sub_100279560(id a1)
{
  if (sub_1004F9FF4())
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10182D2C0);
    }
    uint64_t v1 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "Harvest is not supported in multiuser mode",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10182D2C0);
      }
      LOWORD(v8[0]) = 0;
      float v2 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  0LL,  "Harvest is not supported in multiuser mode",  v8,  2,  v8[0]);
LABEL_29:
      unint64_t v6 = (uint8_t *)v2;
      sub_10029211C("Generic", 1LL, 0, 2LL, "+[CLHarvesterService isSupported]_block_invoke", "%s\n", v2);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else if (sub_1004FC938())
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10182D2C0);
    }
    unint64_t v3 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Harvest is not supported in diagnostics mode",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10182D2C0);
      }
      LOWORD(v8[0]) = 0;
      float v2 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  0LL,  "Harvest is not supported in diagnostics mode",  v8,  2,  v8[0]);
      goto LABEL_29;
    }
  }

  if (qword_1019349B0 != -1) {
    dispatch_once(&qword_1019349B0, &stru_10182D2C0);
  }
  uint64_t v4 = (os_log_s *)qword_1019349B8;
  if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 67240192;
    int v10 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "CLHarvesterService is supported, %{public}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10182D2C0);
    }
    v8[0] = 67240192LL;
    LODWORD(v7) = 8;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  0LL,  "CLHarvesterService is supported, %{public}d",  v8,  v7);
    sub_10029211C("Generic", 1LL, 0, 2LL, "+[CLHarvesterService isSupported]_block_invoke", "%s\n", v5);
  }

void sub_100279A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100279CA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_10027A628( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  *(void *)(v11 - 56) = v10;
  sub_10004CC28((void ***)(v11 - 56));
  sub_10000AE14((uint64_t)va);
  sub_10000AE14((uint64_t)va1);
  sub_10000AE14(v11 - 72);
  _Unwind_Resume(a1);
}

void sub_10027A660(id a1)
{
  if (qword_1019349B0 != -1) {
    dispatch_once(&qword_1019349B0, &stru_10182D2C0);
  }
  uint64_t v1 = (os_log_s *)qword_1019349B8;
  if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
  {
    v2[0] = 68289026;
    v2[1] = 0;
    __int16 v3 = 2082;
    uint64_t v4 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Classifier has been set up}",  (uint8_t *)v2,  0x12u);
  }

void sub_10027A734(id a1, int a2)
{
  if (qword_1019349B0 != -1) {
    dispatch_once(&qword_1019349B0, &stru_10182D2C0);
  }
  float v2 = (os_log_s *)qword_1019349B8;
  if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEBUG))
  {
    v3[0] = 68289026;
    v3[1] = 0;
    __int16 v4 = 2082;
    uint64_t v5 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:flushing archivemanager to disk as result of a darwin notification.}",  (uint8_t *)v3,  0x12u);
  }

uint64_t sub_10027A808(uint64_t a1)
{
  id v2 = objc_msgSend( +[GEOCountryConfiguration sharedConfiguration](GEOCountryConfiguration, "sharedConfiguration"),  "countryCode");
  if ([*(id *)(*(void *)(a1 + 32) + 152) isEqualToString:@"CN"]
    && ([v2 isEqualToString:@"CN"] & 1) == 0)
  {
    sub_100318B58(*(void *)(*(void *)(a1 + 32) + 64LL));
  }

  [*(id *)(a1 + 32) setLastCountryCode:v2];
  [*(id *)(*(void *)(a1 + 32) + 16) refresh];
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 32) + 64LL) + 48LL))(*(void *)(*(void *)(a1 + 32) + 64LL));
}

void sub_10027AA28(uint64_t a1)
{
}

BOOL sub_10027AC04(void *a1, uint64_t a2)
{
  id v2 = [a1 valueForEntitlement:a2];
  if (v2)
  {
    uint64_t v3 = objc_opt_class(&OBJC_CLASS___NSNumber);
  }

  if (qword_1019349B0 != -1) {
    dispatch_once(&qword_1019349B0, &stru_10182D2C0);
  }
  uint64_t v5 = (os_log_s *)qword_1019349B8;
  if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543362;
    id v10 = v2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "connecting process isn't entitled, they shall not pass %{public}@",  buf,  0xCu);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10182D2C0);
    }
    int v7 = 138543362;
    id v8 = v2;
    unint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  0LL,  "connecting process isn't entitled, they shall not pass %{public}@",  &v7,  12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL connectionHasEntitlement(NSXPCConnection *, NSString *)", "%s\n", v6);
    return 0LL;
  }

  return result;
}

void sub_10027B234(id a1)
{
  qword_1019349B8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

void *sub_10027B260@<X0>(void *a1@<X1>, void *a2@<X8>)
{
  __int16 v4 = operator new(0x158uLL);
  BOOL result = sub_10027B2B8(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10027B2A4(_Unwind_Exception *a1)
{
}

void *sub_10027B2B8(void *a1, void *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10182D2F0;
  sub_100F3F758(a1 + 3, *a2);
  return a1;
}

void sub_10027B2F4(_Unwind_Exception *a1)
{
}

void sub_10027B308(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182D2F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10027B31C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182D2F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10027B340(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_10027B350@<X0>(uint64_t *a1@<X1>, __int128 *a2@<X2>, void *a3@<X8>)
{
  unint64_t v6 = operator new(0x4D8uLL);
  BOOL result = sub_10027B3B0(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_10027B39C(_Unwind_Exception *a1)
{
}

void *sub_10027B3B0(void *a1, uint64_t *a2, __int128 *a3)
{
  a1[2] = 0LL;
  *a1 = off_10182D340;
  a1[1] = 0LL;
  sub_10027B45C((uint64_t)&v5, (uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_10027B400(_Unwind_Exception *a1)
{
}

void sub_10027B414(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182D340;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10027B428(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182D340;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10027B44C(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_10027B45C(uint64_t a1, uint64_t a2, uint64_t *a3, __int128 *a4)
{
  uint64_t v5 = *a3;
  __int128 v9 = *a4;
  *(void *)a4 = 0LL;
  *((void *)a4 + 1) = 0LL;
  sub_10031492C(a2, v5, &v9);
  unint64_t v6 = (std::__shared_weak_count *)*((void *)&v9 + 1);
  if (*((void *)&v9 + 1))
  {
    int v7 = (unint64_t *)(*((void *)&v9 + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_10027B4D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10027B4E4@<X0>(void *a1@<X1>, void *a2@<X8>)
{
  __int16 v4 = operator new(0x48uLL);
  BOOL result = sub_10027B53C(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10027B528(_Unwind_Exception *a1)
{
}

void *sub_10027B53C(void *a1, void *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10182D390;
  sub_1002B55A0(a1 + 3, *a2);
  return a1;
}

void sub_10027B578(_Unwind_Exception *a1)
{
}

void sub_10027B58C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182D390;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10027B5A0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182D390;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10027B5C4(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_10027B5D4@<X0>( uint64_t *a1@<X1>, __int128 *a2@<X2>, uint64_t *a3@<X3>, void *a4@<X4>, void *a5@<X8>)
{
  id v10 = operator new(0x120uLL);
  BOOL result = sub_10027B64C(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  return result;
}

void sub_10027B638(_Unwind_Exception *a1)
{
}

void *sub_10027B64C(void *a1, uint64_t *a2, __int128 *a3, uint64_t *a4, void *a5)
{
  a1[2] = 0LL;
  *a1 = off_10182D3E0;
  a1[1] = 0LL;
  sub_10027B700((uint64_t)&v7, (uint64_t)(a1 + 3), a2, a3, a4, a5);
  return a1;
}

void sub_10027B6A4(_Unwind_Exception *a1)
{
}

void sub_10027B6B8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182D3E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10027B6CC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182D3E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10027B6F0(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_10027B700(uint64_t a1, uint64_t a2, uint64_t *a3, __int128 *a4, uint64_t *a5, void *a6)
{
  uint64_t v7 = *a3;
  __int128 v28 = *a4;
  *(void *)a4 = 0LL;
  *((void *)a4 + 1) = 0LL;
  unint64_t v8 = (std::__shared_weak_count *)a5[1];
  uint64_t v26 = *a5;
  double v27 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }

  uint64_t v11 = (std::__shared_weak_count *)a6[1];
  if (*a6) {
    uint64_t v12 = *a6 + 32LL;
  }
  else {
    uint64_t v12 = 0LL;
  }
  uint64_t v24 = v12;
  unsigned int v25 = v11;
  if (v11)
  {
    uint64_t v13 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  sub_1006B699C(a2, v7, &v28, &v26, &v24);
  uint64_t v15 = v25;
  if (v25)
  {
    __int16 v16 = (unint64_t *)&v25->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  id v18 = v27;
  if (v27)
  {
    uint64_t v19 = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  double v21 = (std::__shared_weak_count *)*((void *)&v28 + 1);
  if (*((void *)&v28 + 1))
  {
    int v22 = (unint64_t *)(*((void *)&v28 + 1) + 8LL);
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

void sub_10027B838( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
}

void *sub_10027B85C@<X0>(void *a1@<X1>, void *a2@<X8>)
{
  __int16 v4 = operator new(0xF8uLL);
  BOOL result = sub_10027B8B4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10027B8A0(_Unwind_Exception *a1)
{
}

void *sub_10027B8B4(void *a1, void *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10182D430;
  sub_100EF4490(a1 + 3, *a2);
  return a1;
}

void sub_10027B8F0(_Unwind_Exception *a1)
{
}

void sub_10027B904(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182D430;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10027B918(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182D430;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10027B93C(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_10027B94C@<X0>( uint64_t *a1@<X1>, __int128 *a2@<X2>, uint64_t *a3@<X3>, void *a4@<X4>, uint64_t *a5@<X5>, void *a6@<X6>, void *a7@<X8>)
{
  unint64_t v14 = operator new(0x1A0uLL);
  BOOL result = sub_10027B9DC(v14, a1, a2, a3, a4, a5, a6);
  *a7 = v14 + 3;
  a7[1] = v14;
  return result;
}

void sub_10027B9C8(_Unwind_Exception *a1)
{
}

void *sub_10027B9DC( void *a1, uint64_t *a2, __int128 *a3, uint64_t *a4, void *a5, uint64_t *a6, void *a7)
{
  a1[2] = 0LL;
  *a1 = off_10182D480;
  a1[1] = 0LL;
  sub_10027BA98((uint64_t)&v9, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7);
  return a1;
}

void sub_10027BA3C(_Unwind_Exception *a1)
{
}

void sub_10027BA50(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182D480;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10027BA64(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182D480;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10027BA88(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_10027BA98( uint64_t a1, uint64_t a2, uint64_t *a3, __int128 *a4, uint64_t *a5, void *a6, uint64_t *a7, void *a8)
{
  uint64_t v9 = *a3;
  __int128 v47 = *a4;
  *(void *)a4 = 0LL;
  *((void *)a4 + 1) = 0LL;
  unint64_t v10 = (std::__shared_weak_count *)a5[1];
  uint64_t v45 = *a5;
  unsigned int v46 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }

  uint64_t v13 = (std::__shared_weak_count *)a6[1];
  if (*a6) {
    uint64_t v14 = *a6 + 16LL;
  }
  else {
    uint64_t v14 = 0LL;
  }
  uint64_t v43 = v14;
  unsigned int v44 = v13;
  if (v13)
  {
    uint64_t v15 = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  unint64_t v17 = (std::__shared_weak_count *)a7[1];
  uint64_t v41 = *a7;
  unsigned int v42 = v17;
  if (v17)
  {
    id v18 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }

  unint64_t v20 = (std::__shared_weak_count *)a8[1];
  if (*a8) {
    uint64_t v21 = *a8 + 8LL;
  }
  else {
    uint64_t v21 = 0LL;
  }
  uint64_t v39 = v21;
  unsigned int v40 = v20;
  if (v20)
  {
    int v22 = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
  }

  sub_100CFA730(a2, v9, &v47, &v45, &v43, &v41, &v39);
  uint64_t v24 = v40;
  if (v40)
  {
    unsigned int v25 = (unint64_t *)&v40->__shared_owners_;
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  double v27 = v42;
  if (v42)
  {
    __int128 v28 = (unint64_t *)&v42->__shared_owners_;
    do
      unint64_t v29 = __ldaxr(v28);
    while (__stlxr(v29 - 1, v28));
    if (!v29)
    {
      ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
      std::__shared_weak_count::__release_weak(v27);
    }
  }

  double v30 = v44;
  if (v44)
  {
    int v31 = (unint64_t *)&v44->__shared_owners_;
    do
      unint64_t v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }

  int v33 = v46;
  if (v46)
  {
    double v34 = (unint64_t *)&v46->__shared_owners_;
    do
      unint64_t v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
  }

  uint64_t v36 = (std::__shared_weak_count *)*((void *)&v47 + 1);
  if (*((void *)&v47 + 1))
  {
    uint64_t v37 = (unint64_t *)(*((void *)&v47 + 1) + 8LL);
    do
      unint64_t v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }

void sub_10027BC94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13, uint64_t a14, char a15)
{
}

void *sub_10027BCC8@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  __int16 v4 = operator new(0x28uLL);
  BOOL result = sub_10027BD20(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10027BD0C(_Unwind_Exception *a1)
{
}

void *sub_10027BD20(void *a1, uint64_t *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10182D4D0;
  sub_1005C86B0(a1 + 3, *a2);
  return a1;
}

void sub_10027BD5C(_Unwind_Exception *a1)
{
}

void sub_10027BD70(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182D4D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10027BD84(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182D4D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10027BDA8(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void *sub_10027BDB8@<X0>( __int128 *a1@<X1>, uint64_t *a2@<X2>, uint64_t *a3@<X3>, uint64_t *a4@<X4>, void *a5@<X8>)
{
  unint64_t v10 = operator new(0x2C8uLL);
  BOOL result = sub_10027BE30(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  return result;
}

void sub_10027BE1C(_Unwind_Exception *a1)
{
}

void *sub_10027BE30(void *a1, __int128 *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  a1[2] = 0LL;
  *a1 = off_10182D520;
  a1[1] = 0LL;
  sub_10027BEE4((uint64_t)&v7, (uint64_t)(a1 + 3), a2, a3, a4, a5);
  return a1;
}

void sub_10027BE88(_Unwind_Exception *a1)
{
}

void sub_10027BE9C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182D520;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10027BEB0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182D520;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10027BED4(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_10027BEE4(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6)
{
  __int128 v33 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  unint64_t v6 = (std::__shared_weak_count *)a4[1];
  uint64_t v31 = *a4;
  unint64_t v32 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }

  uint64_t v9 = (std::__shared_weak_count *)a5[1];
  uint64_t v29 = *a5;
  double v30 = v9;
  if (v9)
  {
    unint64_t v10 = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  unint64_t v12 = (std::__shared_weak_count *)a6[1];
  uint64_t v27 = *a6;
  __int128 v28 = v12;
  if (v12)
  {
    uint64_t v13 = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  sub_100F6A828(a2, &v33, &v31, &v29, &v27);
  uint64_t v15 = v28;
  if (v28)
  {
    unint64_t v16 = (unint64_t *)&v28->__shared_owners_;
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  id v18 = v30;
  if (v30)
  {
    unint64_t v19 = (unint64_t *)&v30->__shared_owners_;
    do
      unint64_t v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }

  uint64_t v21 = v32;
  if (v32)
  {
    int v22 = (unint64_t *)&v32->__shared_owners_;
    do
      unint64_t v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }

  uint64_t v24 = (std::__shared_weak_count *)*((void *)&v33 + 1);
  if (*((void *)&v33 + 1))
  {
    unsigned int v25 = (unint64_t *)(*((void *)&v33 + 1) + 8LL);
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

void sub_10027C068( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, char a13)
{
}

char *sub_10027C094(char *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    BOOL result = sub_10005782C(result, a4);
    char v7 = (void *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      void *v7 = *a2;
      uint64_t v8 = a2[1];
      v7[1] = v8;
      if (v8)
      {
        uint64_t v9 = (unint64_t *)(v8 + 8);
        do
          unint64_t v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }

      a2 += 2;
      v7 += 2;
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

void sub_10027C120( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

BOOL sub_10027C134()
{
  return os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_FAULT);
}

BOOL sub_10027C148()
{
  return os_log_type_enabled(*(os_log_t *)(v0 + 2488), OS_LOG_TYPE_INFO);
}

BOOL sub_10027C158()
{
  return os_signpost_enabled(*(os_log_t *)(v0 + 2488));
}

void sub_10027C164()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936068);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936068))
    {
      qword_101936050 = 0LL;
      *(void *)algn_101936058 = 0LL;
      qword_101936060 = 0LL;
      __cxa_atexit((void (*)(void *))sub_1001BA3E4, &qword_101936050, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936068);
    }
  }

void sub_10027C1C8()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936118);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936118))
    {
      std::__shared_mutex_base::__shared_mutex_base(&stru_101936070);
      __cxa_atexit((void (*)(void *))sub_1001BA414, &stru_101936070, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936118);
    }
  }

void sub_10027C23C(_Unwind_Exception *a1)
{
}

void sub_10027C254()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_1012E3970;
      v1[3] = unk_1012E3980;
      unsigned __int8 v1[4] = xmmword_1012E3990;
      v1[0] = xmmword_1012E3950;
      v1[1] = unk_1012E3960;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_10027C328(_Unwind_Exception *a1)
{
}

void sub_10027C340()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361B8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361B8))
    {
      qword_1019361A0 = 0LL;
      qword_1019361A8 = 0LL;
      qword_1019361B0 = 0LL;
      uint64_t v1 = operator new(6uLL);
      qword_1019361A8 = (uint64_t)(v1 + 3);
      qword_1019361B0 = (uint64_t)(v1 + 3);
      *(_DWORD *)uint64_t v1 = 151521030;
      v1[2] = 3082;
      qword_1019361A0 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1001CDCD0, &qword_1019361A0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361B8);
    }
  }

void sub_10027C3DC(_Unwind_Exception *a1)
{
}

void sub_10027C3F4()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361D8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361D8))
    {
      qword_1019361C0 = 0LL;
      qword_1019361C8 = 0LL;
      qword_1019361D0 = 0LL;
      uint64_t v1 = operator new(2uLL);
      qword_1019361C0 = (uint64_t)v1;
      *uint64_t v1 = 256;
      qword_1019361C8 = (uint64_t)(v1 + 1);
      qword_1019361D0 = (uint64_t)(v1 + 1);
      __cxa_atexit((void (*)(void *))sub_1001CDD00, &qword_1019361C0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361D8);
    }
  }

void sub_10027C480(_Unwind_Exception *a1)
{
}

uint64_t sub_10027C498()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_101993E58, (void *)&_mh_execute_header);
}

void *sub_10027C560(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    uint64_t v3 = 4LL;
    uint64_t v2 = a1;
    goto LABEL_5;
  }

  if (v2)
  {
    uint64_t v3 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }

  return a1;
}

void *sub_10027C5AC(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    uint64_t v3 = 4LL;
    uint64_t v2 = a1;
    goto LABEL_5;
  }

  if (v2)
  {
    uint64_t v3 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v2 + 8 * v3))();
  }

  return a1;
}

void sub_10027C69C(id a1)
{
  qword_101993F10 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLOdometerNotifierSilo");
}

uint64_t sub_10027C750(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10027D6AC;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_101993F30 != -1) {
    dispatch_once(&qword_101993F30, block);
  }
  return qword_1019A0E10;
}

void sub_10027C8F0(id a1)
{
}

void sub_10027CA28(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(_OWORD *)(a2 + sub_10000AE14(v13 - 32) = 0u;
  *(_OWORD *)(a2 + 4std::ostream::~ostream(v2, v3 + 8) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  __asm { FMOV            V2.2D, #-1.0 }

  *(_OWORD *)(a2 + 24) = _Q2;
  uint64_t v13 = 0LL;
  unint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  sub_100CF50E8(*(void *)(a1 + 112), (void **)&v13, a3, a4);
  unint64_t v10 = v13;
  if ((unint64_t)((char *)v14 - (char *)v13) < 0x41)
  {
    if (!v13) {
      return;
    }
  }

  else
  {
    int32x2_t v11 = v14[-4];
    int32x2_t v12 = v14[-3];
    *(int32x2_t *)(a2 + 24) = v13[11];
    *(int32x2_t *)(a2 + sub_10000AE14(v13 - 32) = v11;
    *(int32x2_t *)(a2 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = vsub_s32(v12, v10[5]);
  }

  unint64_t v14 = v10;
  operator delete(v10);
}

void sub_10027CAAC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10027CB4C(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)sub_10027CDE8(a1, "CLOdometerNotifier", a2);
  *uint64_t v3 = off_10182D5B0;
  __int16 v4 = v3 + 14;
  uint64_t v5 = operator new(0x240uLL);
  sub_100CF4CD4(v5, 0LL);
  sub_1002807C0(v4, (uint64_t)v5);
  unint64_t v6 = operator new(0x30uLL);
  uint64_t v7 = (uint64_t)v6;
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 120);
  uint64_t v20 = *(void *)(a1 + 112);
  uint64_t v21 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }

  sub_1001B4E14((uint64_t)v6, &v20);
  sub_100280880((void *)(a1 + 128), v7);
  int32x2_t v11 = v21;
  if (v21)
  {
    int32x2_t v12 = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  sub_1010DDBC0(__p, "WorkoutSignificantElevation");
  sub_1005FCFDC(a1 + 144, __p);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  *(void *)(a1 + 84sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = a1 + 840;
  *(void *)(a1 + 84std::ostream::~ostream(v2, v3 + 8) = a1 + 840;
  *(void *)(a1 + 856) = 0LL;
  *(void *)(a1 + 88sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) =  objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "proxyForService:",  @"CLClientAuthorizationCache");
  sub_10027CE84((std::string::size_type)"MotionCalibration", (void *)(a1 + 888));
  *(void *)(a1 + 912) = 0LL;
  sub_10023AE2C((unsigned __int8 *)v22, "DataRetentionPeriodElevationDB", &dword_1012E3BF8, 0);
  int v14 = HIDWORD(v22[0]);
  *(_DWORD *)(a1 + 864) = HIDWORD(v22[0]);
  sub_10027D224(*(void ***)(a1 + 128), (double)v14);
  sub_10027D4D8(a1);
  uint64_t v15 = *(void *)(a1 + 112);
  unint64_t v16 = *(void **)(a1 + 40);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472LL;
  _OWORD v22[2] = sub_10027E60C;
  void v22[3] = &unk_10182D6A0;
  _OWORD v22[4] = a1;
  sub_100CF4D1C(v15, v16, v22);
  return a1;
}

void sub_10027CD2C(_Unwind_Exception *a1)
{
}

uint64_t sub_10027CDE8(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_10182D9D8;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + sub_10000AE14(v13 - 32) = a3;
  *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = [a3 silo];
  *(void *)(a1 + 4std::ostream::~ostream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 8std::ostream::~ostream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 10std::ostream::~ostream(v2, v3 + 8) = 0;
  return a1;
}

void sub_10027CE68(_Unwind_Exception *exception_object)
{
}

void sub_10027CE84(std::string::size_type a1@<X0>, void *a2@<X8>)
{
  uint64_t v3 = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, 0x408uLL, 0);
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  id v4 = -[NSArray countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v11,  v30,  16LL);
  if (v4)
  {
    uint64_t v5 = *(void *)v12;
LABEL_3:
    uint64_t v6 = 0LL;
    while (1)
    {
      if (*(void *)v12 != v5) {
        objc_enumerationMutation(v3);
      }
      id v7 = objc_msgSend( objc_msgSend( objc_msgSend( *(id *)(*((void *)&v11 + 1) + 8 * v6),  "stringByAppendingPathComponent:",  @"LocationBundles/"),  "stringByAppendingPathComponent:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1)),  "stringByAppendingPathExtension:",  @"bundle");
      if (-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  v7))
      {
        break;
      }

      if (v4 == (id)++v6)
      {
        id v4 = -[NSArray countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v11,  v30,  16LL);
        if (v4) {
          goto LABEL_3;
        }
        goto LABEL_27;
      }
    }

    if (!v7) {
      goto LABEL_27;
    }
    sub_1010DDBC0(&__p, (char *)[v7 UTF8String]);
    sub_100FE2DDC(&__p, (uint64_t)buf);
    sub_100FE3FB4((uint64_t)buf, (uint64_t)a2);
    if (v29 < 0) {
      operator delete(v28);
    }
    if (v27 < 0) {
      operator delete(v26);
    }
    if (v25 < 0) {
      operator delete(v24);
    }
    if (v23 < 0) {
      operator delete(v22);
    }
    if (v21 < 0) {
      operator delete(v20);
    }
    if (v19 < 0) {
      operator delete(v18);
    }
    if (v17 < 0) {
      operator delete(*(void **)buf);
    }
  }

  else
  {
LABEL_27:
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10182D768);
    }
    uint64_t v8 = (os_log_s *)qword_101934638;
    if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 136446210;
      *(void *)&uint8_t buf[4] = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "Unable to resolve bundle path for service: %{public}s",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10182D768);
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = a1;
      uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  17LL,  "Unable to resolve bundle path for service: %{public}s",  &__p,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "static std::string CLOdometerNotifier::getClientKeyFromServiceName(const char *)",  "%s\n",  v9);
      if (v9 != buf) {
        free(v9);
      }
    }

    sub_1010DDBC0(a2, "");
  }

void sub_10027D1F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, char a28)
{
}

void sub_10027D224(void **a1, double a2)
{
  if (a2 >= 0.0)
  {
    uint64_t v8 = a1[2];
    uint64_t v6 = (uint64_t)(a1 + 2);
    id v7 = v8;
    unint64_t v9 = *(void *)(v6 - 8);
    if (v9 >= (unint64_t)v8)
    {
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (void)*a1) >> 3);
      unint64_t v12 = v11 + 1;
      if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100007008();
      }
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (_BYTE *)*a1) >> 3);
      if (2 * v13 > v12) {
        unint64_t v12 = 2 * v13;
      }
      if (v13 >= 0x555555555555555LL) {
        unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14) {
        uint64_t v15 = (char *)sub_10000701C(v6, v14);
      }
      else {
        uint64_t v15 = 0LL;
      }
      unint64_t v16 = &v15[24 * v11];
      char v17 = &v15[24 * v14];
      *(double *)unint64_t v16 = a2;
      *((void *)v16 + 1) = 0x7FEFFFFFFFFFFFFFLL;
      v16[16] = 0;
      unint64_t v10 = v16 + 24;
      char v19 = (char *)*a1;
      id v18 = (char *)a1[1];
      if (v18 != *a1)
      {
        do
        {
          __int128 v20 = *(_OWORD *)(v18 - 24);
          *(v16 - std::ostream::~ostream(v2, v3 + 8) = *(v18 - 8);
          *(_OWORD *)(v16 - 24) = v20;
          v16 -= 24;
          v18 -= 24;
        }

        while (v18 != v19);
        id v18 = (char *)*a1;
      }

      *a1 = v16;
      a1[1] = v10;
      a1[2] = v17;
      if (v18) {
        operator delete(v18);
      }
    }

    else
    {
      *(double *)unint64_t v9 = a2;
      *(void *)(v9 + std::ostream::~ostream(v2, v3 + 8) = 0x7FEFFFFFFFFFFFFFLL;
      *(_BYTE *)(v9 + 16) = 0;
      unint64_t v10 = (char *)(v9 + 24);
    }

    a1[1] = v10;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182DBB8);
    }
    uint64_t v3 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134349056;
      double v24 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Programmer error, this expiration rule with time %{public}fis not valid.",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182DBB8);
      }
      int v21 = 134349056;
      double v22 = a2;
      id v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Programmer error, this expiration rule with time %{public}fis not valid.",  &v21,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLActivityAggregator<CLSignificantElevation>::setExpirationRule(CFTimeInterval) [T = CLSignificantElevation , DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v4);
    }
  }

void sub_10027D4D8(uint64_t a1)
{
  uint64_t v2 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0,  0,  (dispatch_queue_t)[*(id *)(a1 + 40) queue]);
  *(void *)(a1 + 872) = v2;
  dispatch_source_set_timer(v2, 0LL, 0xD18C2E2800uLL, 0xDF8475800uLL);
  uint64_t v3 = *(dispatch_source_s **)(a1 + 872);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10027E08C;
  handler[3] = &unk_10181D3D0;
  handler[4] = a1;
  dispatch_source_set_event_handler(v3, handler);
  dispatch_resume(*(dispatch_object_t *)(a1 + 872));
}

uint64_t sub_10027D584(uint64_t a1)
{
  *(void *)a1 = off_10182D9D8;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

uint64_t sub_10027D5F8(uint64_t a1)
{
  *(void *)a1 = off_10182D5B0;

  *(void *)(a1 + 88sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  *(_BYTE *)(a1 + 10std::ostream::~ostream(v2, v3 + 8) = 1;
  sub_1001B4C40((void *)(a1 + 840));
  sub_10000AE14(a1 + 128);
  sub_10000AE14(a1 + 112);
  return sub_10027D584(a1);
}

void sub_10027D67C(uint64_t a1)
{
  *(void *)(a1 + 88sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  *(_BYTE *)(a1 + 10std::ostream::~ostream(v2, v3 + 8) = 1;
}

uint64_t sub_10027D6AC(uint64_t a1)
{
  if (sub_1001B9A1C())
  {
    uint64_t v2 = operator new(0xF90uLL);
    uint64_t result = sub_100536FA0(v2, *(void *)(a1 + 32));
  }

  else
  {
    sub_1004F2598();
    uint64_t result = sub_1004F7000();
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v2 = operator new(0x788uLL);
    uint64_t result = sub_1005F8690(v2, *(void *)(a1 + 32));
  }

  qword_1019A0E10 = (uint64_t)v2;
  return result;
}

void sub_10027D714(_Unwind_Exception *a1)
{
}

uint64_t sub_10027D72C(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10027D7A0;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_101993F40 != -1) {
    dispatch_once(&qword_101993F40, block);
  }
  return byte_101993F38;
}

id sub_10027D7A0(uint64_t a1)
{
  id result = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "isServiceEnabled:", @"CLOdometerNotifier");
  byte_101993F38 = (char)result;
  return result;
}

void *sub_10027D7CC@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  int v3 = *a1 - 2;
  else {
    id v4 = (char *)*((void *)&off_10182DC70 + v3);
  }
  return sub_1010DDBC0(a2, v4);
}

void sub_10027D7FC(uint64_t **a1, int a2, int *a3, int a4)
{
  int v22 = a2;
  if (qword_101934630 != -1) {
    dispatch_once(&qword_101934630, &stru_10182D768);
  }
  id v7 = (os_log_s *)qword_101934638;
  if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = a4 ? "Registration" : "Unregistration";
    *(void *)std::stringbuf::string_type buf = &v22;
    id v9 = objc_msgSend( objc_msgSend(sub_10023311C(a1 + 10, &v22, (uint64_t)&unk_1012CF090, (_DWORD **)buf)[8], "description"),  "UTF8String");
    int v10 = *a3;
    *(_DWORD *)std::stringbuf::string_type buf = *a3;
    int v11 = sub_100247620((uint64_t)a1, (int *)buf, 1LL);
    ((void (*)(_BYTE *__return_ptr, uint64_t **, int *))(*a1)[20])(__p, a1, a3);
    unint64_t v12 = v26 >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)std::stringbuf::string_type buf = 136448770;
    *(void *)&uint8_t buf[4] = "MotionOdometer";
    __int16 v45 = 2082;
    unsigned int v46 = "action";
    __int16 v47 = 2082;
    uint64_t v48 = v8;
    __int16 v49 = 2082;
    uint64_t v50 = "client";
    __int16 v51 = 2082;
    id v52 = v9;
    __int16 v53 = 2082;
    char v54 = "notification";
    __int16 v55 = 1026;
    int v56 = v10;
    __int16 v57 = 2082;
    unsigned __int8 v58 = "notificationClientCount";
    __int16 v59 = 1026;
    int v60 = v11;
    __int16 v61 = 2082;
    uint64_t v62 = "notificationString";
    __int16 v63 = 2082;
    __int16 v64 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}d, %{public}s, %{public}d, %{publ ic}s, %{public}s",  buf,  0x68u);
    if (SHIBYTE(v26) < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10182D768);
    }
    uint64_t v13 = qword_101934638;
    if (a4) {
      unint64_t v14 = "Registration";
    }
    else {
      unint64_t v14 = "Unregistration";
    }
    *(void *)std::string __p = &v22;
    id v15 = objc_msgSend( objc_msgSend(sub_10023311C(a1 + 10, &v22, (uint64_t)&unk_1012CF090, (_DWORD **)__p)[8], "description"),  "UTF8String");
    int v16 = *a3;
    *(_DWORD *)std::string __p = *a3;
    int v17 = sub_100247620((uint64_t)a1, (int *)__p, 1LL);
    ((void (*)(void **__return_ptr, uint64_t **, int *))(*a1)[20])(v20, a1, a3);
    if (v21 >= 0) {
      id v18 = v20;
    }
    else {
      id v18 = (void **)v20[0];
    }
    *(_DWORD *)std::string __p = 136448770;
    *(void *)&__p[4] = "MotionOdometer";
    __int16 v24 = 2082;
    char v25 = "action";
    __int16 v26 = 2082;
    char v27 = v14;
    __int16 v28 = 2082;
    char v29 = "client";
    __int16 v30 = 2082;
    id v31 = v15;
    __int16 v32 = 2082;
    __int128 v33 = "notification";
    __int16 v34 = 1026;
    int v35 = v16;
    __int16 v36 = 2082;
    uint64_t v37 = "notificationClientCount";
    __int16 v38 = 1026;
    int v39 = v17;
    __int16 v40 = 2082;
    uint64_t v41 = "notificationString";
    __int16 v42 = 2082;
    uint64_t v43 = v18;
    char v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  0LL,  "%{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}d, %{public}s, %{pu blic}d, %{public}s, %{public}s",  __p,  104);
    if (v21 < 0) {
      operator delete(v20[0]);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOdometerNotifier::logClient(int, const CLOdometerNotifier_Type::Notification &, BOOL)",  "%s\n",  v19);
    if (v19 != buf) {
      free(v19);
    }
  }

uint64_t sub_10027DC28(uint64_t **a1, uint64_t a2, int *a3)
{
  int v4 = a2;
  uint64_t v6 = ((uint64_t (*)(uint64_t **, uint64_t, int *, void *))(*a1)[12])(a1, a2, a3, &unk_101936BE0);
  sub_10027D7FC(a1, v4, a3, 1);
  ((void (*)(uint64_t **))(*a1)[29])(a1);
  return v6;
}

uint64_t sub_10027DC94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_101936BE0);
}

BOOL sub_10027DCA8(char *a1, int a2, int *a3)
{
  BOOL v6 = sub_10027DD04(a1, a2, a3);
  sub_10027D7FC((uint64_t **)a1, a2, a3, 0);
  (*(void (**)(char *))(*(void *)a1 + 232LL))(a1);
  return v6;
}

BOOL sub_10027DD04(char *a1, int a2, int *a3)
{
  HIDWORD(v33) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      uint64_t v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          uint64_t v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        unint64_t v14 = (char *)*((void *)v8 + 6);
        unint64_t v12 = v8 + 48;
        uint64_t v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          int v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              char v19 = (char **)v13;
            }
            else {
              char v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              int v16 = v13;
            }
            uint64_t v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            int v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                char v25 = (uint64_t *)v20;
              }
              else {
                char v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                int v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v33 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10182D748);
              }
              __int16 v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                char v27 = a1 + 8;
                if (a1[31] < 0) {
                  char v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v43 >= 0) {
                  __int16 v28 = __p;
                }
                else {
                  __int16 v28 = (void **)__p[0];
                }
                *(_DWORD *)std::stringbuf::string_type buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v35 = 2082;
                __int16 v36 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v43 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_10182D748);
                }
                char v29 = a1 + 8;
                if (a1[31] < 0) {
                  char v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v37 >= 0) {
                  id v31 = buf;
                }
                else {
                  id v31 = *(_BYTE **)buf;
                }
                int v38 = 136446466;
                int v39 = v29;
                __int16 v40 = 2082;
                uint64_t v41 = v31;
                LODWORD(v33) = 22;
                __int16 v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                                &v38,
                                v33);
                if (v37 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationDa ta>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLOdometerNotifier_Type: :Notification, NotificationData_T = CLOdometerNotifier_Type::NotificationData, NotificationInfo_T = ch ar, RegistrationInfo_T = char]",  "%s\n",  v32);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_10027E08C(uint64_t a1)
{
  return sub_10027E098(*(void *)(*(void *)(a1 + 32) + 128LL));
}

uint64_t sub_10027E098(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 40)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182DBB8);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v3 = sub_101171D38();
    int v4 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::stringbuf::string_type buf = 134218240;
    *(double *)uint64_t v33 = v3;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Aggregating records start %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182DBB8);
    }
    uint64_t v16 = qword_101934A78;
    double v17 = sub_101171D38();
    int v18 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)uint64_t v30 = v17;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v18;
    char v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  2LL,  "Aggregating records start %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLSignificantElevation>::aggregateRecords() [T = CLSignificantElevation, DataProtectionP olicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v19);
  }

  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182DBB8);
  }
  uint64_t v6 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v7 = sub_101171D38();
    int v8 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::stringbuf::string_type buf = 134218240;
    *(double *)uint64_t v33 = v7;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Aggregating records stop %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182DBB8);
    }
    uint64_t v20 = qword_101934A78;
    double v21 = sub_101171D38();
    int v22 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)uint64_t v30 = v21;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v22;
    int v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  2LL,  "Aggregating records stop %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLSignificantElevation>::aggregateRecords() [T = CLSignificantElevation, DataProtectionP olicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v23);
  }

  uint64_t v9 = *(void *)(a1 + 24);
  double v10 = (double)*(int *)(v9 + 132);
  if ((double)(int)sub_1002809A0(v9, (double **)a1) * 1.2 < v10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182DBB8);
    }
    int v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 24);
      int v13 = *(_DWORD *)(v12 + 132);
      int v14 = sub_1002809A0(v12, (double **)a1);
      *(_DWORD *)std::stringbuf::string_type buf = 67109376;
      *(_DWORD *)uint64_t v33 = v13;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182DBB8);
      }
      uint64_t v24 = qword_101934A78;
      uint64_t v25 = *(void *)(a1 + 24);
      int v26 = *(_DWORD *)(v25 + 132);
      int v27 = sub_1002809A0(v25, (double **)a1);
      int v29 = 67109376;
      *(_DWORD *)uint64_t v30 = v26;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = v27;
      __int16 v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v24,  0LL,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records es timated to be needed %d",  &v29,  14);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLSignificantElevation>::aggregateRecords() [T = CLSignificantElevation, DataProtectio nPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v28);
    }
  }

  return v5;
}

uint64_t sub_10027E60C(uint64_t a1, __int128 *a2)
{
  double v3 = *(double **)(a1 + 32);
  __int128 v4 = a2[1];
  __int128 v18 = *a2;
  __int128 v19 = v4;
  __int128 v5 = a2[3];
  __int128 v20 = a2[2];
  __int128 v21 = v5;
  double Current = CFAbsoluteTimeGetCurrent();
  if (Current - v3[114] > 15.0)
  {
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_10182D788);
    }
    double v7 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *((void *)a2 + 3);
      uint64_t v9 = *((void *)a2 + 4);
      int v10 = *((_DWORD *)a2 + 10);
      int v11 = *((_DWORD *)a2 + 11);
      *(_DWORD *)std::stringbuf::string_type buf = 134349825;
      uint64_t v31 = v8;
      __int16 v32 = 2050;
      uint64_t v33 = v9;
      __int16 v34 = 1025;
      int v35 = v10;
      __int16 v36 = 1025;
      int v37 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "SignificantElevation,startTime,%{public}.3f,endTime,%{public}.3f,ascended,%{private}d,descended,%{private}d",  buf,  0x22u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_10182D788);
      }
      uint64_t v13 = *((void *)a2 + 3);
      uint64_t v14 = *((void *)a2 + 4);
      int v15 = *((_DWORD *)a2 + 10);
      int v16 = *((_DWORD *)a2 + 11);
      int v22 = 134349825;
      uint64_t v23 = v13;
      __int16 v24 = 2050;
      uint64_t v25 = v14;
      __int16 v26 = 1025;
      int v27 = v15;
      __int16 v28 = 1025;
      int v29 = v16;
      double v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "SignificantElevation,startTime,%{public}.3f,endTime,%{public}.3f,ascended,%{private}d,descended,%{private}d",  &v22,  34,  v18,  v19,  v20,  v21);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOdometerNotifier::setUpDbUpdateFinishedHandler()_block_invoke",  "%s\n",  v17);
    }

    v3[114] = Current;
  }

  *(_DWORD *)std::stringbuf::string_type buf = 6;
  return (*(uint64_t (**)(double *, uint8_t *, __int128 *, uint64_t, uint64_t, void))(*(void *)v3 + 152LL))( v3,  buf,  &v18,  1LL,  0xFFFFFFFFLL,  0LL);
}

id sub_10027E878(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 888);
  id v2 = objc_msgSend( objc_msgSend( *(id *)(a1 + 880),  "syncgetAuthorizationContextIfClientIsNonZonal:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v1)),  "isAuthorizedForServiceTypeMask:",  16);
  if ((v2 & 1) == 0)
  {
    if (qword_101934630 != -1) {
      dispatch_once(&qword_101934630, &stru_10182D768);
    }
    double v3 = (os_log_s *)qword_101934638;
    if (os_log_type_enabled((os_log_t)qword_101934638, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Motion calibration system service is disabled.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934630 != -1) {
        dispatch_once(&qword_101934630, &stru_10182D768);
      }
      v6[0] = 0;
      __int128 v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934638,  0LL,  "Motion calibration system service is disabled.",  v6,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLOdometerNotifier::checkAuthorization() const", "%s\n", v5);
    }
  }

  return v2;
}

void sub_10027EA48(uint64_t a1, uint64_t a2)
{
  id v2 = (uint64_t *)(a1 + 840);
  v5[0] = sub_100F4B61C(a2);
  v5[1] = v3;
  _DWORD v5[2] = v4;
  sub_100F4B62C(v2, (uint64_t)v5);
}

uint64_t sub_10027EA88(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = off_10182DC58;
  *(void *)(a1 + std::ostream::~ostream(v2, v3 + 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + sub_10000AE14(v13 - 32) = a6;
  else {
    uint64_t v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

void sub_10027EB5C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLOdometerNotifier");
  sub_10027EA88((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  void *v8 = &off_10182D6D0;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_10027EBF8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

void sub_10027EC24(uint64_t a1, uint64_t a2)
{
  HIDWORD(v14) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)std::stringbuf::string_type buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v14 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182D748);
      }
      char v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        int v11 = (void *)(a1 + 8);
        *(_DWORD *)std::stringbuf::string_type buf = 136446466;
        __int128 v20 = v11;
        __int16 v21 = 1026;
        int v22 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_10182D748);
        }
        uint64_t v12 = (void *)(a1 + 8);
        int v15 = 136446466;
        int v16 = v12;
        __int16 v17 = 1026;
        int v18 = a2;
        LODWORD(v14) = 18;
        id v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                        &v15,
                        v14);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::rem oveClient(int) [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdometerNotifie r_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
      }
    }
  }

uint64_t sub_10027EE98(uint64_t a1, int a2, int *a3, char *a4)
{
  int v41 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)__int16 v42 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          __int16 v24 = (uint64_t *)v18;
        }
        else {
          __int16 v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }

      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          int v29 = (uint64_t *)v25;
        }
        else {
          int v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }

      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v40 = v26;
        uint64_t v34 = *(void *)(v26 + 56);
        char v35 = *a4;
        *(void *)&buf[0] = &v41;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v26 + 40), &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + sub_10000AE14(v13 - 32) = v35;
        memset(buf, 0, 192);
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, _OWORD *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          __int16 v36 = sub_1002819F0(buf);
          sub_100281018((_BYTE *)a1, (uint64_t)v42, (uint64_t)&v40, v36);
        }

        if (v34) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        uint64_t v40 = a1 + 64;
        char v30 = byte_1019386F8;
        HIDWORD(v39) = v17;
        *(void *)&buf[0] = (char *)&v39 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v30;
        HIDWORD(v39) = *a3;
        *(void *)&buf[0] = (char *)&v39 + 4;
        uint64_t v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v31 + 8);
        char v32 = *a4;
        HIDWORD(v39) = *a3;
        *(void *)&buf[0] = (char *)&v39 + 4;
        uint64_t v33 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)&buf[0] = &v41;
        *((_BYTE *)sub_1004EF3D4(v33 + 5, &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + sub_10000AE14(v13 - 32) = v32;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v21 == v19)
      {
        LODWORD(buf[0]) = *a3;
        sub_10004A8FC((uint64_t **)(*(void *)v42 + 40LL), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182D748);
  }
  uint64_t v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    int v15 = (void *)(a1 + 8);
    LODWORD(buf[0]) = 136446466;
    *(void *)((char *)buf + 4) = v15;
    WORD6(buf[0]) = 1026;
    *(_DWORD *)((char *)buf + 14) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      (uint8_t *)buf,
      0x12u);
  }

  BOOL v16 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182D748);
    }
    int v37 = (void *)(a1 + 8);
    *(_DWORD *)__int16 v42 = 136446466;
    *(void *)&v42[4] = v37;
    __int16 v43 = 1026;
    int v44 = a2;
    LODWORD(v39) = 18;
    int v38 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                    v42,
                    v39);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::registe rForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLOdometerNotifier_Typ e::Notification, NotificationData_T = CLOdometerNotifier_Type::NotificationData, NotificationInfo_T = char, Regist rationInfo_T = char]",  "%s\n",  v38);
    return 0LL;
  }

  return result;
}

BOOL sub_10027F314(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        uint64_t v21 = (uint64_t *)v15;
      }
      else {
        uint64_t v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182D748);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)std::stringbuf::string_type buf = 136446466;
      int v29 = v11;
      __int16 v30 = 1026;
      int v31 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182D748);
      }
      int v22 = (void *)(a1 + 8);
      int v24 = 136446466;
      uint64_t v25 = v22;
      __int16 v26 = 1026;
      int v27 = a2;
      BOOL v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                      &v24,
                      18);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::clien tRegistered(int, const Notification_T &) [Notification_T = CLOdometerNotifier_Type::Notification, NotificationDa ta_T = CLOdometerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_10027F594(uint64_t a1, int *a2, _OWORD *a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      uint64_t v10 = (uint64_t *)v4;
    }
    else {
      uint64_t v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }

  while (*v10);
  if (v7 == v3) {
    return 0LL;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0LL;
  }
  int v11 = *(__int128 **)(v7 + 64);
  if (!v11) {
    return 0LL;
  }
  __int128 v12 = *v11;
  __int128 v13 = v11[1];
  __int128 v14 = v11[3];
  a3[2] = v11[2];
  a3[3] = v14;
  *a3 = v12;
  a3[1] = v13;
  __int128 v15 = v11[4];
  __int128 v16 = v11[5];
  __int128 v17 = v11[7];
  a3[6] = v11[6];
  a3[7] = v17;
  a3[4] = v15;
  a3[5] = v16;
  __int128 v18 = v11[8];
  __int128 v19 = v11[9];
  __int128 v20 = v11[11];
  a3[10] = v11[10];
  a3[11] = v20;
  a3[8] = v18;
  a3[9] = v19;
  return 1LL;
}

uint64_t sub_10027F61C(uint64_t a1, int *a2, _OWORD *a3)
{
  int v6 = (char *)operator new(0xD8uLL);
  __int128 v7 = a3[9];
  *(_OWORD *)(v6 + 152) = a3[8];
  *(_OWORD *)(v6 + 16std::ostream::~ostream(v2, v3 + 8) = v7;
  __int128 v8 = a3[11];
  *(_OWORD *)(v6 + 184) = a3[10];
  *(_OWORD *)(v6 + 20sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v8;
  __int128 v9 = a3[5];
  *(_OWORD *)(v6 + 8std::ostream::~ostream(v2, v3 + 8) = a3[4];
  *(_OWORD *)(v6 + 104) = v9;
  __int128 v10 = a3[7];
  *(_OWORD *)(v6 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = a3[6];
  *(_OWORD *)(v6 + 136) = v10;
  __int128 v11 = a3[1];
  *(_OWORD *)(v6 + 24) = *a3;
  *(_OWORD *)(v6 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v11;
  __int128 v12 = a3[3];
  *(_OWORD *)(v6 + 56) = a3[2];
  *((void *)v6 + 2) = 0LL;
  *(void *)int v6 = off_10182DBE8;
  *((void *)v6 + 1) = 0LL;
  *(_OWORD *)(v6 + 72) = v12;
  *(void *)&__int128 v19 = v6 + 24;
  *((void *)&v19 + 1) = v6;
  int v18 = *a2;
  __int128 v20 = &v18;
  __int128 v13 = sub_10023347C((uint64_t **)(a1 + 56), &v18, (uint64_t)&unk_1012CF090, &v20);
  sub_10005F550((uint64_t)(v13 + 8), &v19);
  __int128 v14 = (std::__shared_weak_count *)*((void *)&v19 + 1);
  if (*((void *)&v19 + 1))
  {
    __int128 v15 = (unint64_t *)(*((void *)&v19 + 1) + 8LL);
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  return 1LL;
}

void sub_10027F730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10027F744(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  v5,  a3,  a4,  0LL);
}

void sub_10027F794(uint64_t a1, unsigned int *a2, _OWORD *a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    __int128 v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182D748);
    }
    __int128 v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      __int128 v12 = (void *)(a1 + 8);
      __int128 v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)std::stringbuf::string_type buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = "activity";
      __int16 v72 = 2082;
      uint64_t v73 = v12;
      __int16 v74 = 2050;
      unint64_t v75 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    __int128 v15 = (__n128 *)(a1 + 64);
    __int128 v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    __int128 v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        __int128 v20 = (__n128 **)v14;
      }
      else {
        __int128 v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        __int128 v17 = v14;
      }
      __int128 v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)char v76 = &v76[8];
      memset(&v76[8], 0, 24);
      int v77 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v76);
      __int128 v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      uint64_t v21 = v75;
      if (v75)
      {
        p_shared_owners = (unint64_t *)&v75->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&buf[8], *(void **)&buf[16]);
      int v24 = v77;
      if (v77)
      {
        uint64_t v25 = (unint64_t *)&v77->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v76, *(void **)&v76[8]);
    }

    if (a4)
    {
      int v27 = (char *)operator new(0xD8uLL);
      __int128 v28 = a3[9];
      *(_OWORD *)(v27 + 152) = a3[8];
      *(_OWORD *)(v27 + 16std::ostream::~ostream(v2, v3 + 8) = v28;
      __int128 v29 = a3[11];
      *(_OWORD *)(v27 + 184) = a3[10];
      *(_OWORD *)(v27 + 20sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v29;
      __int128 v30 = a3[5];
      *(_OWORD *)(v27 + 8std::ostream::~ostream(v2, v3 + 8) = a3[4];
      *(_OWORD *)(v27 + 104) = v30;
      __int128 v31 = a3[7];
      *(_OWORD *)(v27 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = a3[6];
      *(_OWORD *)(v27 + 136) = v31;
      __int128 v32 = a3[1];
      *(_OWORD *)(v27 + 24) = *a3;
      *(_OWORD *)(v27 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v32;
      __int128 v33 = a3[3];
      *(_OWORD *)(v27 + 56) = a3[2];
      *((void *)v27 + 2) = 0LL;
      *(void *)int v27 = off_10182DBE8;
      *((void *)v27 + 1) = 0LL;
      *(_OWORD *)(v27 + 72) = v33;
      *(void *)std::stringbuf::string_type buf = v27 + 24;
      *(void *)&uint8_t buf[8] = v27;
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      uint64_t v34 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        char v35 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    int v37 = sub_100280B9C(a3);
    if (a5 == -1)
    {
      sub_100280C44((void *)a1, (int *)a2, v37);
    }

    else
    {
      uint64_t v38 = a1 + 88;
      uint64_t v39 = *(void *)(a1 + 88);
      if (!v39) {
        goto LABEL_48;
      }
      uint64_t v40 = a1 + 88;
      do
      {
        int v41 = *(_DWORD *)(v39 + 32);
        BOOL v42 = v41 < a5;
        if (v41 >= a5) {
          __int16 v43 = (uint64_t *)v39;
        }
        else {
          __int16 v43 = (uint64_t *)(v39 + 8);
        }
        if (!v42) {
          uint64_t v40 = v39;
        }
        uint64_t v39 = *v43;
      }

      while (*v43);
      if (v40 == v38 || *(_DWORD *)(v40 + 32) > a5) {
LABEL_48:
      }
        uint64_t v40 = a1 + 88;
      uint64_t v69 = v40;
      unint64_t v44 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v45 = *a2;
      unsigned int v46 = (__n128 *)(a1 + 64);
      do
      {
        int v47 = *(_DWORD *)(v44 + 32);
        BOOL v48 = v47 < v45;
        if (v47 >= v45) {
          __int16 v49 = (unint64_t *)v44;
        }
        else {
          __int16 v49 = (unint64_t *)(v44 + 8);
        }
        if (!v48) {
          unsigned int v46 = (__n128 *)v44;
        }
        unint64_t v44 = *v49;
      }

      while (*v49);
      if (v46 == v15 || v45 < (signed __int32)v46[2].n128_u32[0])
      {
LABEL_59:
        unsigned int v68 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_10182D748);
        }
        uint64_t v50 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          __int16 v51 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v76, a1, a2);
          if (v76[23] >= 0) {
            id v52 = v76;
          }
          else {
            id v52 = *(_BYTE **)v76;
          }
          *(_DWORD *)std::stringbuf::string_type buf = 136315650;
          *(void *)&uint8_t buf[4] = v51;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a5;
          *(_WORD *)&_BYTE buf[18] = 2080;
          *(void *)&buf[20] = v52;
          _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v76[23] & 0x80000000) != 0) {
            operator delete(*(void **)v76);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_10182D748);
          }
          __int16 v53 = (void *)(a1 + 8);
          uint64_t v54 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v67 >= 0) {
            __int16 v55 = __p;
          }
          else {
            __int16 v55 = (void **)__p[0];
          }
          *(_DWORD *)char v76 = 136315650;
          *(void *)&v76[4] = v53;
          *(_WORD *)&v76[12] = 1024;
          *(_DWORD *)&v76[14] = a5;
          *(_WORD *)&v76[18] = 2080;
          *(void *)&v76[20] = v55;
          int v56 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v54,  2LL,  "%s; client %d has deregistered, not notifying %s",
                          v76,
                          28,
                          v65);
          if (v67 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::n otifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdometerNotifier_Type::NotificationData, Notif icationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v56);
          if (v56 != buf) {
            free(v56);
          }
        }

        goto LABEL_83;
      }

      unsigned int v68 = v46;
      if (v40 == v38) {
        goto LABEL_60;
      }
      uint64_t v59 = v46[3].n128_i64[0];
      __int16 v57 = v46 + 3;
      unsigned __int8 v58 = (__n128 *)v59;
      if (!v59) {
        goto LABEL_60;
      }
      int v60 = *(_DWORD *)(v40 + 32);
      __int16 v61 = v57;
      do
      {
        int v62 = v58[1].n128_i32[3];
        BOOL v63 = v62 < v60;
        if (v62 >= v60) {
          __int16 v64 = v58;
        }
        else {
          __int16 v64 = (__n128 *)&v58->n128_i8[8];
        }
        if (!v63) {
          __int16 v61 = v58;
        }
        unsigned __int8 v58 = (__n128 *)v64->n128_u64[0];
      }

      while (v64->n128_u64[0]);
      sub_100281018((_BYTE *)a1, (uint64_t)&v69, (uint64_t)&v68, v37);
    }

void sub_10027FE10( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_10027FE5C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182D748);
    }
    id v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)std::stringbuf::string_type buf = 136315138;
      uint64_t v34 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182D748);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v29 = 136315138;
      __int128 v30 = v4;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
                     (const char *)&v29);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::listC lients() [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdometerNotifier_Type:: NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182D748);
    }
    int v6 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      __int128 v7 = (void *)(a1 + 8);
      uint64_t v8 = *(void *)(a1 + 96);
      *(_DWORD *)std::stringbuf::string_type buf = 136315394;
      uint64_t v34 = v7;
      __int16 v35 = 2048;
      v36[0] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182D748);
      }
      uint64_t v25 = (void *)(a1 + 8);
      uint64_t v26 = *(void *)(a1 + 96);
      int v29 = 136315394;
      __int128 v30 = v25;
      __int16 v31 = 2048;
      v32[0] = v26;
      int v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
                      (const char *)&v29,
                      22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::listC lients() [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdometerNotifier_Type:: NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v27);
    }

    __int128 v9 = *(void **)(a1 + 80);
    if (v9 != (void *)(a1 + 88))
    {
      __int128 v10 = (void *)(a1 + 8);
      do
      {
        __int128 v11 = (void *)v9[5];
        if (v11 != v9 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_10182D748);
            }
            __int128 v12 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              __int128 v13 = (void *)(a1 + 8);
              int v14 = *((_DWORD *)v9 + 8);
              int v15 = *((_DWORD *)v11 + 7);
              *(_DWORD *)std::stringbuf::string_type buf = 136315650;
              uint64_t v34 = v13;
              __int16 v35 = 1024;
              LODWORD(v36[0]) = v14;
              WORD2(v36[0]) = 1024;
              *(_DWORD *)((char *)v36 + 6) = v15;
              _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10182D748);
              }
              BOOL v19 = (void *)(a1 + 8);
              int v20 = *((_DWORD *)v9 + 8);
              int v21 = *((_DWORD *)v11 + 7);
              int v29 = 136315650;
              __int128 v30 = v19;
              __int16 v31 = 1024;
              LODWORD(v32[0]) = v20;
              WORD2(v32[0]) = 1024;
              *(_DWORD *)((char *)v32 + 6) = v21;
              int v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                              (const char *)&v29,
                              24,
                              v28);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData >::listClients() [Notification_T = CLOdometerNotifier_Type::Notification, NotificationData_T = CLOdomete rNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v22);
            }

            signed __int32 v16 = (void *)v11[1];
            if (v16)
            {
              do
              {
                __int128 v17 = v16;
                signed __int32 v16 = (void *)*v16;
              }

              while (v16);
            }

            else
            {
              do
              {
                __int128 v17 = (void *)v11[2];
                BOOL v18 = *v17 == (void)v11;
                __int128 v11 = v17;
              }

              while (!v18);
            }

            __int128 v11 = v17;
          }

          while (v17 != v9 + 6);
        }

        unint64_t v23 = (void *)v9[1];
        if (v23)
        {
          do
          {
            int v24 = v23;
            unint64_t v23 = (void *)*v23;
          }

          while (v23);
        }

        else
        {
          do
          {
            int v24 = (void *)v9[2];
            BOOL v18 = *v24 == (void)v9;
            __int128 v9 = v24;
          }

          while (!v18);
        }

        __int128 v9 = v24;
      }

      while (v24 != (void *)(a1 + 88));
    }
  }

void sub_100280408(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100281990(a1);
  operator delete(v1);
}

id sub_10028041C(uint64_t a1, int a2, void *a3)
{
  id result = sub_100281144(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_100280468(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100280494(id a1)
{
  qword_101934638 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Odometer");
}

void sub_1002804C0(id a1)
{
  qword_1019345B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pressure");
}

void *sub_1002804F4()
{
  id result = operator new(0x10uLL);
  *id result = &off_10182D7B8;
  return result;
}

void sub_100280518(uint64_t a1, void *a2)
{
  *a2 = &off_10182D7B8;
}

double sub_100280530(uint64_t a1, double **a2)
{
  id v2 = *a2;
  double result = **a2;
  double v4 = 0.0;
  while (v2 != a2[1])
  {
    double v4 = v4 + v2[2];
    v2 += 3;
  }

  return result;
}

uint64_t sub_10028055C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100280598()
{
}

void *sub_1002805AC()
{
  double result = operator new(0x10uLL);
  *double result = &off_10182D848;
  return result;
}

void sub_1002805D0(uint64_t a1, void *a2)
{
  *a2 = &off_10182D848;
}

double sub_1002805E8(uint64_t a1, double **a2)
{
  id v2 = a2[1];
  double result = **a2;
  double v4 = 0.0;
  if (*a2 != v2)
  {
    uint64_t v5 = *a2;
    do
    {
      double v4 = v4 + v5[2];
      v5 += 3;
    }

    while (v5 != v2);
  }

  return result;
}

uint64_t sub_100280638(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100280674()
{
}

void *sub_100280688()
{
  double result = operator new(0x10uLL);
  *double result = &off_10182D8C8;
  return result;
}

void sub_1002806AC(uint64_t a1, void *a2)
{
  *a2 = &off_10182D8C8;
}

BOOL sub_1002806C4(uint64_t a1, uint64_t a2)
{
  return *(double *)(a2 + 16) >= 0.0;
}

uint64_t sub_1002806D4(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100280710()
{
}

void *sub_100280724()
{
  double result = operator new(0x10uLL);
  *double result = &off_10182D958;
  return result;
}

void sub_100280748(uint64_t a1, void *a2)
{
  *a2 = &off_10182D958;
}

BOOL sub_100280760(uint64_t a1, uint64_t a2)
{
  return *(double *)(a2 + 16) > 2.22044605e-16;
}

uint64_t sub_100280778(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1002807B4()
{
}

void *sub_1002807C0(void *a1, uint64_t a2)
{
  *a1 = a2;
  double v4 = operator new(0x20uLL);
  *double v4 = &off_10182DAB8;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  void v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100280808(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100280828(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

uint64_t sub_100280840(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *sub_100280880(void *a1, uint64_t a2)
{
  *a1 = a2;
  double v4 = operator new(0x20uLL);
  *double v4 = &off_10182DB30;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  void v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1002808C8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    uint64_t v3 = (void *)sub_1001B4FBC(v1);
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1002808E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    id v2 = (void *)sub_1001B4FBC(v1);
    operator delete(v2);
  }

uint64_t sub_100280908(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void sub_100280948(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_100280974(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_1002809A0(uint64_t a1, double **a2)
{
  uint64_t v3 = *a2;
  id v2 = a2[1];
  double v4 = (*a2)[1];
  double v5 = *(float *)(a1 + 136);
  if (v4 <= v5) {
    double v4 = *(float *)(a1 + 136);
  }
  int v6 = v3 + 3;
  if (v3 + 3 == v2)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    LODWORD(v7) = 0;
    double v8 = *v3;
    do
    {
      double v9 = *v6;
      double v10 = v6[1];
      v6 += 3;
      uint64_t v7 = (v7 + (int)((v9 - v8) / v4));
      if (v10 <= v5) {
        double v4 = *(float *)(a1 + 136);
      }
      else {
        double v4 = v10;
      }
      double v8 = v9;
    }

    while (v6 != v2);
  }

  if (v4 != 1.79769313e308)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182DB98);
    }
    __int128 v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning No expiration rule was added so the number of records will be unbounded.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182DB98);
      }
      v14[0] = 0;
      __int128 v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning No expiration rule was added so the number of records will be unbounded.",  v14,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLActivityRecorderDb<CLSignificantElevation>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLSigni ficantElevation, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v13);
    }
  }

  return v7;
}

CLCppContainer *sub_100280B9C(_OWORD *a1)
{
  id v2 = operator new(0xC0uLL);
  __int128 v3 = a1[9];
  v2[8] = a1[8];
  v2[9] = v3;
  __int128 v4 = a1[11];
  void v2[10] = a1[10];
  v2[11] = v4;
  __int128 v5 = a1[5];
  v2[4] = a1[4];
  v2[5] = v5;
  __int128 v6 = a1[7];
  v2[6] = a1[6];
  v2[7] = v6;
  __int128 v7 = a1[1];
  *id v2 = *a1;
  v2[1] = v7;
  __int128 v8 = a1[3];
  _DWORD v2[2] = a1[2];
  v2[3] = v8;
  double v10 = _NSConcreteStackBlock;
  uint64_t v11 = 3221225472LL;
  __int128 v12 = sub_100281134;
  __int128 v13 = &unk_10181D3D0;
  int v14 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_100280C44(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    __int128 v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      double v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          __int128 v12 = (uint64_t *)v4;
        }
        else {
          __int128 v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          double v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        uint64_t v50 = v9;
        id v13 = sub_100281144(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        int v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          int v15 = a1 + 11;
          signed __int32 v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            BOOL v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                int v22 = (uint64_t *)v17;
              }
              else {
                int v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                BOOL v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              __int16 v49 = v19;
              sub_100281018(a1, (uint64_t)&v49, (uint64_t)&v50, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              int v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  __int128 v32 = (uint64_t *)v27;
                }
                else {
                  __int128 v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  int v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              uint64_t v50 = v29;
              uint64_t v34 = v29[6];
              int v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                __int16 v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    uint64_t v39 = (uint64_t *)v36;
                  }
                  else {
                    uint64_t v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    __int16 v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      BOOL v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      BOOL v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      int v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  __int16 v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      int v14 = v43;
                      __int16 v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      int v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      __int16 v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              __int16 v49 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10182D748);
              }
              int v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                uint64_t v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)std::stringbuf::string_type buf = 136446466;
                int v56 = v25;
                __int16 v57 = 1026;
                int v58 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_10182D748);
                }
                int v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v51 = 136446466;
                id v52 = v45;
                __int16 v53 = 1026;
                int v54 = v46;
                LODWORD(v4std::ostream::~ostream(v2, v3 + 8) = 18;
                int v47 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                                &v51,
                                v48);
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLOdometerNotifier_Type::Notification, CLOdometerNotifier_Type::NotificationData>::inv okeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLOdometerNotifier_Type ::Notification, NotificationData_T = CLOdometerNotifier_Type::NotificationData, NotificationInfo_T = c har, RegistrationInfo_T = char]",  "%s\n",  v47);
              }
            }
          }

          while (v14 != v50 + 6);
        }
      }
    }
  }

_BYTE *sub_100281018(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    __int128 v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_100281144(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40LL);
    int v14 = (int *)(*(void *)a2 + 32LL);
    __int128 v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    uint64_t result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

void sub_1002810F4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182DBE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100281108(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182DBE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_100281134(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

id sub_100281144(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppEncodableDataContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_1002811BC(a1);
  }
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v4) & 1) != 0) {
    return sub_100281544(a1);
  }
  else {
    return 0LL;
  }
}

id sub_1002811BC(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return sub_1002818F0((uint64_t)&v8 + 7, a1);
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182DC28);
    }
    __int128 v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x80000001012E43C4LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182DC28);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(vstd::ostream::~ostream(v2, v3 + 8) = 32;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182DC28);
    }
    __int128 v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x80000001012E43C4LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182DC28);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(vstd::ostream::~ostream(v2, v3 + 8) = 32;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  __int128 v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLOdometerNotifier_Type::NotificationData, Callb ack = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:241:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_100281544(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182DC28);
    }
    __int128 v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012E43C4LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182DC28);
    }
    LODWORD(vstd::ostream::~ostream(v2, v3 + 8) = 134218498;
    HIDWORD(vstd::ostream::~ostream(v2, v3 + 8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182DC28);
    }
    __int128 v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012E43C4LL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182DC28);
    }
    LODWORD(vstd::ostream::~ostream(v2, v3 + 8) = 134218498;
    HIDWORD(vstd::ostream::~ostream(v2, v3 + 8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  __int128 v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLOdometerNotifier_Type::NotificationData, Callb ack = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:250:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_1002818F0(uint64_t a1, void *a2)
{
  if (![a2 cppObjectPtr]
    && objc_msgSend(objc_msgSend(a2, "compatibilityInfo"), "isEqual:", &off_1018D30C8))
  {
    if (objc_msgSend(objc_msgSend(a2, "serialized"), "length") != (id)192) {
      sub_101232590();
    }
    objc_msgSend(a2, "setCppObjectPtr:", objc_msgSend(objc_msgSend(a2, "serialized"), "bytes"));
  }

  return [a2 cppObjectPtr];
}

void sub_100281964(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

uint64_t sub_100281990(uint64_t a1)
{
  *(void *)a1 = off_10182DC58;
  id v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *id v2 = 0LL;
  *(void *)(a1 + 16) = 0LL;
  return a1;
}

CLCppContainer *sub_1002819F0(_OWORD *a1)
{
  id v2 = operator new(0xC0uLL);
  __int128 v3 = a1[9];
  v2[8] = a1[8];
  v2[9] = v3;
  __int128 v4 = a1[11];
  void v2[10] = a1[10];
  v2[11] = v4;
  __int128 v5 = a1[5];
  v2[4] = a1[4];
  v2[5] = v5;
  __int128 v6 = a1[7];
  v2[6] = a1[6];
  v2[7] = v6;
  __int128 v7 = a1[1];
  *id v2 = *a1;
  v2[1] = v7;
  __int128 v8 = a1[3];
  _DWORD v2[2] = a1[2];
  v2[3] = v8;
  id v10 = _NSConcreteStackBlock;
  uint64_t v11 = 3221225472LL;
  uint64_t v12 = sub_100281A98;
  __int16 v13 = &unk_10181D3D0;
  unint64_t v14 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_100281A98(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

BOOL sub_100281AA8()
{
  return os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT);
}

uint64_t sub_100281ABC()
{
  qword_101993E90 = (uint64_t)&off_10182D7B8;
  qword_101993EA8 = (uint64_t)&qword_101993E90;
  __cxa_atexit((void (*)(void *))sub_10027C560, &qword_101993E90, (void *)&_mh_execute_header);
  qword_101993EB0 = (uint64_t)&off_10182D848;
  qword_101993EC8 = (uint64_t)&qword_101993EB0;
  __cxa_atexit((void (*)(void *))sub_10027C560, &qword_101993EB0, (void *)&_mh_execute_header);
  qword_101993ED0 = (uint64_t)&off_10182D8C8;
  qword_101993EE8 = (uint64_t)&qword_101993ED0;
  __cxa_atexit((void (*)(void *))sub_10027C5AC, &qword_101993ED0, (void *)&_mh_execute_header);
  qword_101993EF0 = (uint64_t)&off_10182D958;
  qword_101993F08 = (uint64_t)&qword_101993EF0;
  return __cxa_atexit((void (*)(void *))sub_10027C5AC, &qword_101993EF0, (void *)&_mh_execute_header);
}

void *sub_100281F18(void *a1, uint64_t a2)
{
  __int128 v4 = operator new(0x208uLL);
  sub_100F8E1B8(v4, a2);
  sub_100282760(a1, (uint64_t)v4);
  __int128 v5 = operator new(0x160uLL);
  sub_100FB49F8(v5, a2);
  sub_100282820(a1 + 2, (uint64_t)v5);
  __int128 v6 = operator new(0x188uLL);
  sub_100AC01D8(v6, a2);
  sub_1002828E0(a1 + 4, (uint64_t)v6);
  return a1;
}

void sub_100281FA8(_Unwind_Exception *a1)
{
}

void sub_100282000(double **a1, uint64_t a2, double a3)
{
  __int128 v3 = *(double **)a2;
  *(void *)(a2 + std::ostream::~ostream(v2, v3 + 8) = *(void *)a2;
  __int128 v4 = *a1;
  __int128 v5 = a1[1];
  if (v5 != *a1)
  {
    double v7 = v4[2] - a3 + 0.0;
    double v8 = v7 * v4[5] / 3600.0 + 0.0;
    double v33 = v8;
    double v34 = v7;
    __int128 v9 = *((_OWORD *)v4 + 2);
    uint64_t v10 = *((void *)v4 + 10);
    __int128 v11 = *((_OWORD *)v4 + 4);
    __int128 v38 = *((_OWORD *)v4 + 3);
    __int128 v39 = v11;
    uint64_t v40 = v10;
    __int128 v37 = v9;
    __int128 v12 = *((_OWORD *)v4 + 1);
    __int128 v35 = *(_OWORD *)v4;
    __int128 v36 = v12;
    if (v7 >= 60.0)
    {
      unint64_t v14 = (void *)(a2 + 16);
      double v15 = *(double *)&v36;
      do
      {
        double v16 = v7 + -60.0;
        double v17 = v15 - (v7 + -60.0) + -60.0;
        double v18 = v8 * 3600.0 / v7;
        if ((unint64_t)v3 >= *v14)
        {
          BOOL v19 = *(double **)a2;
          uint64_t v20 = ((uint64_t)v3 - *(void *)a2) >> 4;
          unint64_t v21 = v20 + 1;
          uint64_t v22 = *v14 - (void)v19;
          if (v22 >> 3 > v21) {
            unint64_t v21 = v22 >> 3;
          }
          else {
            unint64_t v23 = v21;
          }
          if (v23)
          {
            int v24 = (char *)sub_100037038(a2 + 16, v23);
            BOOL v19 = *(double **)a2;
            __int128 v3 = *(double **)(a2 + 8);
          }

          else
          {
            int v24 = 0LL;
          }

          uint64_t v25 = (double *)&v24[16 * v20];
          *uint64_t v25 = v17;
          v25[1] = v18;
          int v26 = v25;
          if (v3 != v19)
          {
            do
            {
              *((_OWORD *)v26 - 1) = *((_OWORD *)v3 - 1);
              v26 -= 2;
              v3 -= 2;
            }

            while (v3 != v19);
            BOOL v19 = *(double **)a2;
          }

          __int128 v3 = v25 + 2;
          *(void *)a2 = v26;
          *(void *)(a2 + std::ostream::~ostream(v2, v3 + 8) = v25 + 2;
          *(void *)(a2 + 16) = &v24[16 * v23];
          if (v19) {
            operator delete(v19);
          }
        }

        else
        {
          *__int128 v3 = v17;
          v3[1] = v18;
          v3 += 2;
          double v8 = v33;
          double v7 = v34;
          double v16 = v34 + -60.0;
        }

        *(void *)(a2 + std::ostream::~ostream(v2, v3 + 8) = v3;
        double v8 = v8 - v8 * 60.0 / v7;
        double v33 = v8;
        double v34 = v16;
        double v7 = v16;
      }

      while (v16 >= 60.0);
      __int128 v4 = *a1;
      __int128 v5 = a1[1];
    }

    uint64_t v27 = v4 + 11;
    v32[0] = &v34;
    v32[1] = &v33;
    void v32[2] = &v35;
    void v32[3] = a2;
    while (v27 != v5)
    {
      __int128 v28 = *((_OWORD *)v27 + 1);
      v41[0] = *(_OWORD *)v27;
      v41[1] = v28;
      __int128 v29 = *((_OWORD *)v27 + 2);
      __int128 v30 = *((_OWORD *)v27 + 3);
      __int128 v31 = *((_OWORD *)v27 + 4);
      uint64_t v42 = *((void *)v27 + 10);
      v41[3] = v30;
      v41[4] = v31;
      v41[2] = v29;
      sub_100282274((uint64_t)v32, (uint64_t)v41);
      v27 += 11;
    }
  }

void sub_100282274(uint64_t a1, uint64_t a2)
{
  double v3 = *(double *)(a2 + 16);
  double v4 = *(double *)(*(void *)(a1 + 16) + 16LL);
  if (v3 >= v4)
  {
    double v7 = v3 - v4;
    double v8 = v7 + **(double **)a1;
    if (v8 >= 60.0)
    {
      double v9 = v8 + -60.0;
      uint64_t v10 = *(double **)(a1 + 8);
      double v11 = *v10 + (v7 - (v8 + -60.0)) * *(double *)(a2 + 40) / 3600.0;
      *uint64_t v10 = v11;
      uint64_t v12 = *(void *)(a1 + 24);
      double v13 = *(double *)(a2 + 16) - (v8 + -60.0) + -60.0;
      double v14 = v11 * 3600.0 / 60.0;
      double v15 = *(double **)(v12 + 8);
      unint64_t v16 = *(void *)(v12 + 16);
      if ((unint64_t)v15 >= v16)
      {
        double v18 = *(double **)v12;
        uint64_t v19 = ((uint64_t)v15 - *(void *)v12) >> 4;
        unint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 60) {
LABEL_49:
        }
          sub_100007008();
        uint64_t v21 = v16 - (void)v18;
        if (v21 >> 3 > v20) {
          unint64_t v20 = v21 >> 3;
        }
        else {
          unint64_t v22 = v20;
        }
        if (v22)
        {
          unint64_t v23 = (char *)sub_100037038(v12 + 16, v22);
          double v18 = *(double **)v12;
          double v15 = *(double **)(v12 + 8);
        }

        else
        {
          unint64_t v23 = 0LL;
        }

        int v24 = (double *)&v23[16 * v19];
        uint64_t v25 = &v23[16 * v22];
        *int v24 = v13;
        v24[1] = v14;
        double v17 = v24 + 2;
        if (v15 != v18)
        {
          do
          {
            *((_OWORD *)v24 - 1) = *((_OWORD *)v15 - 1);
            v24 -= 2;
            v15 -= 2;
          }

          while (v15 != v18);
          double v18 = *(double **)v12;
        }

        *(void *)uint64_t v12 = v24;
        *(void *)(v12 + std::ostream::~ostream(v2, v3 + 8) = v17;
        *(void *)(v12 + 16) = v25;
        if (v18) {
          operator delete(v18);
        }
      }

      else
      {
        *double v15 = v13;
        v15[1] = v14;
        double v17 = v15 + 2;
      }

      *(void *)(v12 + std::ostream::~ostream(v2, v3 + 8) = v17;
      int v26 = *(double **)a1;
      *int v26 = v9;
      uint64_t v27 = *(double **)(a1 + 8);
      *uint64_t v27 = v9 * *(double *)(a2 + 40) / 3600.0;
      for (i = *v26; i >= 60.0; *__int16 v43 = i)
      {
        uint64_t v29 = *(void *)(a1 + 24);
        double v30 = *(double *)(a2 + 16) - (i + -60.0) + -60.0;
        double v31 = *v27 * 3600.0 / i;
        __int128 v32 = *(double **)(v29 + 8);
        unint64_t v33 = *(void *)(v29 + 16);
        if ((unint64_t)v32 >= v33)
        {
          __int128 v35 = *(double **)v29;
          uint64_t v36 = ((uint64_t)v32 - *(void *)v29) >> 4;
          unint64_t v37 = v36 + 1;
          uint64_t v38 = v33 - (void)v35;
          if (v38 >> 3 > v37) {
            unint64_t v37 = v38 >> 3;
          }
          else {
            unint64_t v39 = v37;
          }
          if (v39)
          {
            uint64_t v40 = (char *)sub_100037038(v29 + 16, v39);
            __int128 v35 = *(double **)v29;
            __int128 v32 = *(double **)(v29 + 8);
          }

          else
          {
            uint64_t v40 = 0LL;
          }

          BOOL v41 = (double *)&v40[16 * v36];
          *BOOL v41 = v30;
          v41[1] = v31;
          uint64_t v42 = v41;
          if (v32 != v35)
          {
            do
            {
              *((_OWORD *)v42 - 1) = *((_OWORD *)v32 - 1);
              v42 -= 2;
              v32 -= 2;
            }

            while (v32 != v35);
            __int128 v35 = *(double **)v29;
          }

          double v34 = v41 + 2;
          *(void *)uint64_t v29 = v42;
          *(void *)(v29 + std::ostream::~ostream(v2, v3 + 8) = v41 + 2;
          *(void *)(v29 + 16) = &v40[16 * v39];
          if (v35) {
            operator delete(v35);
          }
        }

        else
        {
          *__int128 v32 = v30;
          v32[1] = v31;
          double v34 = v32 + 2;
        }

        *(void *)(v29 + std::ostream::~ostream(v2, v3 + 8) = v34;
        __int16 v43 = *(double **)a1;
        uint64_t v27 = *(double **)(a1 + 8);
        *uint64_t v27 = *v27 + *v27 * -60.0 / **(double **)a1;
        double i = *v43 + -60.0;
      }
    }

    else
    {
      **(double **)a1 = v8;
      **(double **)(a1 + std::ostream::~ostream(v2, v3 + 8) = **(double **)(a1 + 8) + v7 * *(double *)(a2 + 40) / 3600.0;
    }

    uint64_t v44 = *(void *)(a1 + 16);
    __int128 v45 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)uint64_t v44 = *(_OWORD *)a2;
    *(_OWORD *)(v44 + 16) = v45;
    __int128 v46 = *(_OWORD *)(a2 + 32);
    __int128 v47 = *(_OWORD *)(a2 + 48);
    __int128 v48 = *(_OWORD *)(a2 + 64);
    *(void *)(v44 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(a2 + 80);
    *(_OWORD *)(v44 + 4std::ostream::~ostream(v2, v3 + 8) = v47;
    *(_OWORD *)(v44 + 64) = v48;
    *(_OWORD *)(v44 + sub_10000AE14(v13 - 32) = v46;
  }

  else
  {
    if (qword_101934650 != -1) {
      dispatch_once(&qword_101934650, &stru_10182DCA0);
    }
    __int128 v5 = (os_log_s *)qword_101934658;
    if (os_log_type_enabled((os_log_t)qword_101934658, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "METMinutes,time rolled back", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934650 != -1) {
        dispatch_once(&qword_101934650, &stru_10182DCA0);
      }
      v51[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934658,  16LL,  "METMinutes,time rolled back",  v51,  2);
      uint64_t v50 = (uint8_t *)v49;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "auto CLMetMinuteEstimator::estimateMetMinutes(CLMotionTimeRange, std::vector<CLNatalieData> &, std::vector<CLMet Minute> &)::(anonymous class)::operator()(const CLNatalieData) const",  "%s\n",  v49);
      if (v50 != buf) {
        free(v50);
      }
    }

    *(void *)(*(void *)(a1 + 24) + 8LL) = **(void **)(a1 + 24);
  }

void sub_100282734(id a1)
{
  qword_101934658 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Health");
}

void *sub_100282760(void *a1, uint64_t a2)
{
  *a1 = a2;
  double v4 = operator new(0x20uLL);
  *double v4 = &off_10182DCD0;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  void v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1002827A8(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002827C8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

uint64_t sub_1002827E0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *sub_100282820(void *a1, uint64_t a2)
{
  *a1 = a2;
  double v4 = operator new(0x20uLL);
  *double v4 = &off_10182DD48;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  void v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100282868(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100282888(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

uint64_t sub_1002828A0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *sub_1002828E0(void *a1, uint64_t a2)
{
  *a1 = a2;
  double v4 = operator new(0x20uLL);
  *double v4 = &off_10182DDC0;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  void v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100282928(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100282948(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

uint64_t sub_100282960(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void sub_100282A44(id a1)
{
  qword_101993F48 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLDistributedSensingServiceSilo");
}

void sub_100282BA8(id a1)
{
  qword_101993F58 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLVO2MaxCloudKitManagerSilo");
}

void sub_100282C5C(id a1)
{
}

void sub_1002834D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

id sub_100283508(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return _[a4 onDataProtectionNotification:a2 data:a3];
}

id sub_100283518(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return _[a4 onFitnessTrackingNotification:a2 data:a3];
}

void sub_100283A08( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100284180( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  sub_10000AE14((uint64_t)va);
  sub_1001BA1BC((id *)va1);
  _Unwind_Resume(a1);
}

void sub_1002841C0(uint64_t a1, xpc_activity_t activity)
{
  if (xpc_activity_get_state(activity))
  {
    [*(id *)(a1 + 32) onSyncActivity:activity];
    if (xpc_activity_get_state(activity) == 2 && !xpc_activity_set_state(activity, 4LL))
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      double v4 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 136446466;
        uint64_t v25 = "com.apple.vo2max.CloudKitManager";
        __int16 v26 = 2050;
        xpc_activity_state_t state = xpc_activity_get_state(activity);
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "Failed to mark %{public}s activity as Continue. Current state is %{public}ld",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_10182DF18);
        }
        uint64_t v5 = qword_1019346E8;
        int v18 = 136446466;
        uint64_t v19 = "com.apple.vo2max.CloudKitManager";
        __int16 v20 = 2050;
        xpc_activity_state_t v21 = xpc_activity_get_state(activity);
        __int128 v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v5,  17LL,  "Failed to mark %{public}s activity as Continue. Current state is %{public}ld",  &v18,  22);
        sub_10029211C("Generic", 1LL, 0, 0LL, "-[CLVO2MaxCloudKitManager setUpSyncActivity]_block_invoke", "%s\n", v6);
      }
    }
  }

  else
  {
    xpc_object_t v7 = xpc_activity_copy_criteria(activity);
    if (!v7) {
      xpc_object_t v7 = xpc_dictionary_create(0LL, 0LL, 0LL);
    }
    int64_t int64 = xpc_dictionary_get_int64(v7, XPC_ACTIVITY_DELAY);
    if (int64 == *(void *)(a1 + 40))
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      double v9 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
      {
        xpc_activity_state_t v10 = *(void *)(a1 + 40);
        *(_DWORD *)std::stringbuf::string_type buf = 136446466;
        uint64_t v25 = "com.apple.vo2max.CloudKitManager";
        __int16 v26 = 2050;
        xpc_activity_state_t state = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "XPC_CHECK_IN: %{public}s activity already scheduled with a delay of %{public}lld seconds",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_10182DF18);
        }
        xpc_activity_state_t v11 = *(void *)(a1 + 40);
        int v18 = 136446466;
        uint64_t v19 = "com.apple.vo2max.CloudKitManager";
        __int16 v20 = 2050;
        xpc_activity_state_t v21 = v11;
        uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  0LL,  "XPC_CHECK_IN: %{public}s activity already scheduled with a delay of %{public}lld seconds",  &v18,  22);
        sub_10029211C("Generic", 1LL, 0, 2LL, "-[CLVO2MaxCloudKitManager setUpSyncActivity]_block_invoke", "%s\n", v12);
      }
    }

    else
    {
      xpc_activity_state_t v13 = int64;
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      uint64_t v14 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = *(void *)(a1 + 40);
        *(_DWORD *)std::stringbuf::string_type buf = 136446722;
        uint64_t v25 = "com.apple.vo2max.CloudKitManager";
        __int16 v26 = 2050;
        xpc_activity_state_t state = v13;
        __int16 v28 = 2050;
        uint64_t v29 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "XPC_CHECK_IN: %{public}s: Overwriting previous delay (%{public}lld) with a new delay of %{public}lld seconds",  buf,  0x20u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_10182DF18);
        }
        uint64_t v16 = *(void *)(a1 + 40);
        int v18 = 136446722;
        uint64_t v19 = "com.apple.vo2max.CloudKitManager";
        __int16 v20 = 2050;
        xpc_activity_state_t v21 = v13;
        __int16 v22 = 2050;
        uint64_t v23 = v16;
        double v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  0LL,  "XPC_CHECK_IN: %{public}s: Overwriting previous delay (%{public}lld) with a new delay of %{public}lld seconds",  &v18,  32);
        sub_10029211C("Generic", 1LL, 0, 2LL, "-[CLVO2MaxCloudKitManager setUpSyncActivity]_block_invoke", "%s\n", v17);
      }

      xpc_dictionary_set_int64(v7, XPC_ACTIVITY_DELAY, *(void *)(a1 + 40));
      xpc_dictionary_set_int64(v7, XPC_ACTIVITY_GRACE_PERIOD, XPC_ACTIVITY_INTERVAL_1_HOUR);
      xpc_dictionary_set_string(v7, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_UTILITY);
      xpc_dictionary_set_BOOL(v7, XPC_ACTIVITY_REQUIRES_CLASS_B, 1);
      xpc_dictionary_set_BOOL(v7, XPC_ACTIVITY_ALLOW_BATTERY, 1);
      xpc_activity_set_criteria(activity, v7);
    }

    xpc_release(v7);
  }

void sub_100284B80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100285738( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

id sub_1002857C0(uint64_t a1)
{
  return [*(id *)(a1 + 32) validateAccount];
}

void sub_100285828(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v6 = (dispatch_queue_s *)objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "universe"), "silo"), "queue");
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1002858AC;
  block[3] = &unk_10181A2D8;
  block[4] = a3;
  void block[5] = a2;
  block[6] = *(void *)(a1 + 32);
  dispatch_async(v6, block);
}

void sub_1002858AC(uint64_t a1)
{
  if (!*(void *)(a1 + 32))
  {
    if ([*(id *)(a1 + 40) accountStatus] == (id)1)
    {
      if ([*(id *)(a1 + 40) supportsDeviceToDeviceEncryption])
      {
        uint64_t v6 = *(void *)(a1 + 48);
        xpc_object_t v7 = *(void **)(v6 + 208);
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 3221225472LL;
        _DWORD v18[2] = sub_100285D48;
        void v18[3] = &unk_10182DE90;
        v18[4] = v6;
        [v7 fetchUserRecordIDWithCompletionHandler:v18];
        return;
      }

      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      xpc_activity_state_t v13 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_ERROR))
      {
        id v14 = [*(id *)(*(void *)(a1 + 48) + 208) containerIdentifier];
        *(_DWORD *)std::stringbuf::string_type buf = 138543362;
        id v22 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "iCloud account for container %{public}@ doesn't support device to device encryption",  buf,  0xCu);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_27;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      uint64_t v15 = qword_1019346E8;
      id v16 = [*(id *)(*(void *)(a1 + 48) + 208) containerIdentifier];
      int v19 = 138543362;
      id v20 = v16;
      uint64_t v12 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  16LL,  "iCloud account for container %{public}@ doesn't support device to device encryption",  &v19,  12);
    }

    else
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      double v8 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_ERROR))
      {
        id v9 = [*(id *)(a1 + 40) accountStatus];
        *(_DWORD *)std::stringbuf::string_type buf = 134349056;
        id v22 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "iCloud account is not available, status: %{public}ld",  buf,  0xCu);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_27;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      uint64_t v10 = qword_1019346E8;
      id v11 = [*(id *)(a1 + 40) accountStatus];
      int v19 = 134349056;
      id v20 = v11;
      uint64_t v12 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  16LL,  "iCloud account is not available, status: %{public}ld",  &v19,  12);
    }

    double v17 = (uint8_t *)v12;
    sub_10029211C("Generic", 1LL, 0, 0LL, "-[CLVO2MaxCloudKitManager validateAccount]_block_invoke", "%s\n", v12);
    if (v17 != buf) {
      free(v17);
    }
LABEL_27:
    [*(id *)(a1 + 48) stopSyncing:0];
    return;
  }

  if (qword_1019346E0 != -1) {
    dispatch_once(&qword_1019346E0, &stru_10182DF18);
  }
  uint64_t v2 = (os_log_s *)qword_1019346E8;
  if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_ERROR))
  {
    double v3 = *(void **)(a1 + 32);
    *(_DWORD *)std::stringbuf::string_type buf = 138543362;
    id v22 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "Error determining account status: %{public}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10182DF18);
    }
    double v4 = *(void **)(a1 + 32);
    int v19 = 138543362;
    id v20 = v4;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  16LL,  "Error determining account status: %{public}@",  &v19,  12);
    sub_10029211C("Generic", 1LL, 0, 0LL, "-[CLVO2MaxCloudKitManager validateAccount]_block_invoke", "%s\n", v5);
  }

void sub_100285D48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (dispatch_queue_s *)objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "universe"), "silo"), "queue");
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100285DCC;
  block[3] = &unk_10181A2D8;
  uint64_t v7 = *(void *)(a1 + 32);
  block[4] = a3;
  void block[5] = v7;
  block[6] = a2;
  dispatch_async(v6, block);
}

void sub_100285DCC(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10182DF18);
    }
    uint64_t v2 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = *(void *)(a1 + 32);
      *(_DWORD *)std::stringbuf::string_type buf = 138543362;
      uint64_t v19 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "Error getting user record: %{public}@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      uint64_t v4 = *(void *)(a1 + 32);
      LODWORD(v17) = 138543362;
      *(void *)((char *)&v17 + 4) = v4;
      uint64_t v5 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  16LL,  "Error getting user record: %{public}@",  &v17,  12,  v17);
LABEL_10:
      uint64_t v6 = (uint8_t *)v5;
      sub_10029211C("Generic", 1LL, 0, 0LL, "-[CLVO2MaxCloudKitManager validateAccount]_block_invoke", "%s\n", v5);
      if (v6 != buf) {
        free(v6);
      }
      return;
    }

    return;
  }

  id v7 = [*(id *)(a1 + 40) getUserRecordIDName];
  if (!v7) {
    goto LABEL_27;
  }
  if ((objc_msgSend(v7, "isEqual:", objc_msgSend(*(id *)(a1 + 48), "recordName")) & 1) == 0)
  {
    if ([*(id *)(a1 + 40) shouldKeepLocalDataOnAccountChange])
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      double v8 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "iCloud account has changed. Due to testing override, will not delete local VO2Max data but will still delete s ync engine metadata.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_10182DF18);
        }
        LOWORD(v17) = 0;
        id v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  0LL,  "iCloud account has changed. Due to testing override, will not delete local VO2Max data but will still delete sync engine metadata.",  &v17,  2);
        sub_10029211C("Generic", 1LL, 0, 2LL, "-[CLVO2MaxCloudKitManager validateAccount]_block_invoke", "%s\n", v14);
      }

      [*(id *)(a1 + 40) stopSyncing:1];
    }

    else
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      id v9 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "[CKManager] iCloud account has changed. Deleting sync engine metadata",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_10182DF18);
        }
        LOWORD(v17) = 0;
        uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  0LL,  "[CKManager] iCloud account has changed. Deleting sync engine metadata",  &v17,  2);
        sub_10029211C("Generic", 1LL, 0, 2LL, "-[CLVO2MaxCloudKitManager validateAccount]_block_invoke", "%s\n", v15);
      }

      [*(id *)(a1 + 40) stopSyncing:1];
      [*(id *)(a1 + 40) deleteLocalVO2MaxData];
    }

void sub_10028685C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (dispatch_queue_s *)objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "universe"), "silo"), "queue");
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1002868E0;
  block[3] = &unk_10181A2D8;
  uint64_t v7 = *(void *)(a1 + 32);
  block[4] = a3;
  void block[5] = v7;
  block[6] = a2;
  dispatch_async(v6, block);
}

void sub_1002868E0(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10182DF18);
    }
    uint64_t v2 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = *(void **)(a1 + 32);
      *(_DWORD *)std::stringbuf::string_type buf = 138543362;
      id v35 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "[CKManager] Error fetching record zones: %{public}@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      int v18 = *(void **)(a1 + 32);
      int v30 = 138543362;
      id v31 = v18;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  16LL,  "[CKManager] Error fetching record zones: %{public}@",  &v30,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CLVO2MaxCloudKitManager deleteCloudKitRecords]_block_invoke",  "%s\n",  v19);
    }

    uint64_t v4 = a1 + 40;
    int v5 = 3;
  }

  else
  {
    if (*(void *)(a1 + 48))
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      uint64_t v6 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
      {
        id v7 = [*(id *)(a1 + 48) count];
        uint64_t v8 = *(void *)(a1 + 48);
        *(_DWORD *)std::stringbuf::string_type buf = 134349314;
        id v35 = v7;
        __int16 v36 = 2112;
        uint64_t v37 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[CKManager] Deleting %{public}lu zones: %@",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_10182DF18);
        }
        uint64_t v20 = qword_1019346E8;
        id v21 = [*(id *)(a1 + 48) count];
        uint64_t v22 = *(void *)(a1 + 48);
        int v30 = 134349314;
        id v31 = v21;
        __int16 v32 = 2112;
        uint64_t v33 = v22;
        uint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  0LL,  "[CKManager] Deleting %{public}lu zones: %@",  &v30,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLVO2MaxCloudKitManager deleteCloudKitRecords]_block_invoke",  "%s\n",  v23);
      }

      id v9 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [*(id *)(a1 + 48) count]);
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      uint64_t v10 = *(void **)(a1 + 48);
      id v11 = [v10 countByEnumeratingWithState:&v25 objects:v29 count:16];
      if (v11)
      {
        id v12 = v11;
        uint64_t v13 = *(void *)v26;
        do
        {
          for (double i = 0LL; i != v12; double i = (char *)i + 1)
          {
            if (*(void *)v26 != v13) {
              objc_enumerationMutation(v10);
            }
            uint64_t v15 = -[CKSyncEnginePendingZoneDelete initWithZoneID:]( [CKSyncEnginePendingZoneDelete alloc],  "initWithZoneID:",  [*(id *)(*((void *)&v25 + 1) + 8 * (void)i) zoneID]);
            -[NSMutableArray addObject:](v9, "addObject:", v15);
          }

          id v12 = [v10 countByEnumeratingWithState:&v25 objects:v29 count:16];
        }

        while (v12);
      }

      uint64_t v16 = *(void *)(a1 + 40);
      uint64_t v4 = a1 + 40;
      objc_msgSend(objc_msgSend(*(id *)(v16 + 216), "state"), "addPendingDatabaseChanges:", v9);
    }

    else
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_10182DF18);
      }
      __int128 v17 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "[CKManager] No zones to delete", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_10182DF18);
        }
        LOWORD(v3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
        int v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  2LL,  "[CKManager] No zones to delete",  &v30,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLVO2MaxCloudKitManager deleteCloudKitRecords]_block_invoke",  "%s\n",  v24);
      }

      uint64_t v4 = a1 + 40;
    }

    int v5 = 4;
  }

  *(_DWORD *)(*(void *)v4 + 20sub_100272D04(v1, 0LL) = v5;
}

void sub_100286F0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1002871A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100287B00(id a1, NSError *a2)
{
  if (qword_1019346E0 != -1) {
    dispatch_once(&qword_1019346E0, &stru_10182DF18);
  }
  uint64_t v3 = (os_log_s *)qword_1019346E8;
  if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543362;
    uint64_t v8 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Sync engine fetch complete for output records: %{public}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10182DF18);
    }
    int v5 = 138543362;
    uint64_t v6 = a2;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  0LL,  "Sync engine fetch complete for output records: %{public}@",  &v5,  12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "-[CLVO2MaxCloudKitManager initializeSyncEngine]_block_invoke", "%s\n", v4);
  }

void sub_100287CA8(id a1, NSError *a2)
{
  if (qword_1019346E0 != -1) {
    dispatch_once(&qword_1019346E0, &stru_10182DF18);
  }
  uint64_t v3 = (os_log_s *)qword_1019346E8;
  if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543362;
    uint64_t v8 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Sync engine fetch complete for input records: %{public}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_10182DF18);
    }
    int v5 = 138543362;
    uint64_t v6 = a2;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  0LL,  "Sync engine fetch complete for input records: %{public}@",  &v5,  12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "-[CLVO2MaxCloudKitManager initializeSyncEngine]_block_invoke", "%s\n", v4);
  }

void sub_100288E5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100288EA0(uint64_t a1, uint64_t a2)
{
  return uuid_compare((const unsigned __int8 *)(a1 + 16), (const unsigned __int8 *)(a2 + 16)) >> 31;
}

BOOL sub_100288EC0(uint64_t a1, uint64_t a2)
{
  return uuid_compare((const unsigned __int8 *)(a1 + 16), (const unsigned __int8 *)(a2 + 16)) == 0;
}

void sub_1002899F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10028A8A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10028E84C(id a1)
{
  qword_1019346E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "VO2Max");
}

void *sub_10028E878@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x1C0uLL);
  uint64_t result = sub_10028E8D0(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10028E8BC(_Unwind_Exception *a1)
{
}

void *sub_10028E8D0(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10182DF48;
  sub_1006E87F0(a1 + 3, *a2);
  return a1;
}

void sub_10028E90C(_Unwind_Exception *a1)
{
}

void sub_10028E920(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182DF48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10028E934(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182DF48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10028E958(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void *sub_10028E968@<X0>(uint64_t *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x70uLL);
  uint64_t result = sub_10028E9C0(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10028E9AC(_Unwind_Exception *a1)
{
}

void *sub_10028E9C0(void *a1, uint64_t *a2)
{
  a1[2] = 0LL;
  *a1 = off_10182DF98;
  a1[1] = 0LL;
  sub_10028EA84((uint64_t)&v4, (uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_10028EA0C(_Unwind_Exception *a1)
{
}

void sub_10028EA20(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182DF98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10028EA34(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182DF98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10028EA58(uint64_t a1)
{
  uint64_t v1 = a1 + 24;
  sub_10028EB1C((void *)(a1 + 64));
  return sub_10000AE14(v1);
}

void sub_10028EA84(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  uint64_t v9 = *a3;
  uint64_t v10 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  sub_100D58318(a2, &v9);
  uint64_t v6 = v10;
  if (v10)
  {
    id v7 = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

void sub_10028EB08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10028EB1C(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 18LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 36LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    id v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void sub_10028EBB0(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_100FCCC40(a2 + 1320);
    sub_1009AA7B4(a2 + 984);
    sub_1009A22F8(a2 + 496);
    uint64_t v3 = (void *)sub_100CE83B4(a2);
    operator delete(v3);
  }

void sub_10028EBF4( __n128 *a1, __n128 *a2, unsigned int (**a3)(void, void), uint64_t a4, char a5)
{
LABEL_1:
  uint64_t v9 = a2 - 5;
  uint64_t v10 = a1;
LABEL_2:
  uint64_t v11 = 1 - a4;
  while (2)
  {
    a1 = v10;
    uint64_t v12 = v11;
    uint64_t v13 = (char *)a2 - (char *)v10;
    unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * (a2 - v10);
    switch(v14)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        uint64_t v40 = *a3;
        v58[0] = a2[-5];
        __n128 v41 = a2[-1];
        __n128 v43 = a2[-4];
        __n128 v42 = a2[-3];
        v58[3] = a2[-2];
        v58[4] = v41;
        v58[1] = v43;
        void v58[2] = v42;
        __n128 v45 = v10[1];
        __n128 v44 = v10[2];
        __n128 v46 = v10[4];
        v57[3] = v10[3];
        v57[4] = v46;
        v57[1] = v45;
        _OWORD v57[2] = v44;
        v57[0] = *v10;
        if (v40(v58, v57))
        {
          __n128 v59 = *v10;
          __n128 v47 = v10[1];
          __n128 v48 = v10[2];
          __n128 v49 = v10[4];
          __n128 v62 = v10[3];
          __n128 v63 = v49;
          __n128 v60 = v47;
          __n128 v61 = v48;
          __n128 v50 = a2[-1];
          __n128 v52 = a2[-4];
          __n128 v51 = a2[-3];
          void v10[3] = a2[-2];
          v10[4] = v50;
          v10[1] = v52;
          _DWORD v10[2] = v51;
          *uint64_t v10 = *v9;
          __n128 v53 = v62;
          a2[-3] = v61;
          a2[-2] = v53;
          a2[-1] = v63;
          __n128 v54 = v60;
          *uint64_t v9 = v59;
          a2[-4] = v54;
        }

        return;
      case 3uLL:
        sub_10028F2C0(v10, (__n128 *)v10[5].n128_u64, (__n128 *)a2[-5].n128_u64, a3);
        return;
      case 4uLL:
        sub_10028FE88((__int128 *)v10, (__int128 *)&v10[5], (__int128 *)&v10[10], (__int128 *)&a2[-5], a3);
        return;
      case 5uLL:
        sub_10029009C( (__int128 *)v10,  (__int128 *)&v10[5],  (__int128 *)&v10[10],  (__int128 *)&v10[15],  (__int128 *)&a2[-5],  a3);
        return;
      default:
        if (v13 <= 1919)
        {
          if ((a5 & 1) != 0) {
            sub_10028EFC4((uint64_t)v10, a2, (uint64_t (**)(void, void))a3);
          }
          else {
            sub_10028F158((uint64_t)v10, a2, (uint64_t (**)(void, void))a3);
          }
          return;
        }

        if (v12 != 1)
        {
          unint64_t v15 = v14 >> 1;
          uint64_t v16 = &v10[5 * (v14 >> 1)];
          if ((unint64_t)v13 < 0x2801)
          {
            sub_10028F2C0(v16, v10, (__n128 *)a2[-5].n128_u64, a3);
            if ((a5 & 1) != 0) {
              goto LABEL_11;
            }
          }

          else
          {
            sub_10028F2C0(v10, v16, (__n128 *)a2[-5].n128_u64, a3);
            uint64_t v17 = 5 * v15;
            int v18 = &v10[5 * v15 - 5];
            sub_10028F2C0((__n128 *)v10[5].n128_u64, v18, (__n128 *)a2[-10].n128_u64, a3);
            uint64_t v19 = v10 + 10;
            uint64_t v20 = &v10[v17 + 5];
            sub_10028F2C0(v19, v20, (__n128 *)a2[-15].n128_u64, a3);
            sub_10028F2C0(v18, v16, v20, a3);
            __n128 v59 = *a1;
            __n128 v21 = a1[1];
            __n128 v22 = a1[2];
            __n128 v23 = a1[4];
            __n128 v62 = a1[3];
            __n128 v63 = v23;
            __n128 v60 = v21;
            __n128 v61 = v22;
            __n128 v24 = v16[4];
            __n128 v26 = v16[1];
            __n128 v25 = v16[2];
            a1[3] = v16[3];
            a1[4] = v24;
            a1[1] = v26;
            a1[2] = v25;
            *a1 = *v16;
            __n128 v27 = v63;
            __n128 v29 = v60;
            __n128 v28 = v61;
            void v16[3] = v62;
            _DWORD v16[4] = v27;
            v16[1] = v29;
            void v16[2] = v28;
            *uint64_t v16 = v59;
            if ((a5 & 1) != 0) {
              goto LABEL_11;
            }
          }

          int v30 = *a3;
          v56[0] = a1[-5];
          __n128 v31 = a1[-1];
          __n128 v33 = a1[-4];
          __n128 v32 = a1[-3];
          v56[3] = a1[-2];
          v56[4] = v31;
          v56[1] = v33;
          v56[2] = v32;
          __n128 v35 = a1[1];
          __n128 v34 = a1[2];
          __n128 v36 = a1[4];
          v55[3] = a1[3];
          v55[4] = v36;
          v55[1] = v35;
          v55[2] = v34;
          v55[0] = *a1;
          if ((((uint64_t (*)(_OWORD *, _OWORD *))v30)(v56, v55) & 1) == 0)
          {
            uint64_t v10 = (__n128 *)sub_10028F5F4(a1, a2, (uint64_t (**)(void, void))a3);
            goto LABEL_16;
          }

uint64_t sub_10028EFC4(uint64_t result, _OWORD *a2, uint64_t (**a3)(void, void))
{
  if ((_OWORD *)result != a2)
  {
    unint64_t v4 = (_OWORD *)result;
    unint64_t v5 = (_OWORD *)(result + 80);
    if ((_OWORD *)(result + 80) != a2)
    {
      uint64_t v7 = 0LL;
      unint64_t v8 = (_OWORD *)result;
      do
      {
        uint64_t v9 = v8;
        unint64_t v8 = v5;
        uint64_t v10 = *a3;
        __int128 v11 = v8[3];
        void v36[2] = v8[2];
        v36[3] = v11;
        v36[4] = v8[4];
        __int128 v12 = v8[1];
        v36[0] = *v8;
        v36[1] = v12;
        __int128 v14 = v9[1];
        __int128 v13 = v9[2];
        __int128 v15 = v9[4];
        v35[3] = v9[3];
        v35[4] = v15;
        v35[1] = v14;
        v35[2] = v13;
        v35[0] = *v9;
        uint64_t result = v10(v36, v35);
        if ((_DWORD)result)
        {
          __int128 v16 = v8[3];
          __int128 v32 = v8[2];
          __int128 v33 = v16;
          __int128 v34 = v8[4];
          __int128 v17 = v8[1];
          __int128 v30 = *v8;
          __int128 v31 = v17;
          uint64_t v18 = v7;
          while (1)
          {
            uint64_t v19 = (_OWORD *)((char *)v4 + v18);
            __int128 v20 = *(_OWORD *)((char *)v4 + v18 + 48);
            v19[7] = *(_OWORD *)((char *)v4 + v18 + 32);
            v19[8] = v20;
            v19[9] = *(_OWORD *)((char *)v4 + v18 + 64);
            __int128 v21 = *(_OWORD *)((char *)v4 + v18 + 16);
            v19[5] = *(_OWORD *)((char *)v4 + v18);
            v19[6] = v21;
            if (!v18) {
              break;
            }
            __n128 v22 = *a3;
            v29[2] = v32;
            v29[3] = v33;
            v29[4] = v34;
            v29[0] = v30;
            v29[1] = v31;
            __int128 v23 = *(v19 - 2);
            _DWORD v28[2] = *(v19 - 3);
            v28[3] = v23;
            v28[4] = *(v19 - 1);
            __int128 v24 = *(v19 - 4);
            v28[0] = *(v19 - 5);
            v28[1] = v24;
            uint64_t result = v22(v29, v28);
            v18 -= 80LL;
            if ((result & 1) == 0)
            {
              __n128 v25 = (_OWORD *)((char *)v4 + v18 + 80);
              goto LABEL_10;
            }
          }

          __n128 v25 = v4;
LABEL_10:
          __int128 v26 = v33;
          uint64_t v25[2] = v32;
          void v25[3] = v26;
          v25[4] = v34;
          __int128 v27 = v31;
          *__n128 v25 = v30;
          v25[1] = v27;
        }

        unint64_t v5 = v8 + 5;
        v7 += 80LL;
      }

      while (v8 + 5 != a2);
    }
  }

  return result;
}

uint64_t sub_10028F158(uint64_t result, _OWORD *a2, uint64_t (**a3)(void, void))
{
  if ((_OWORD *)result != a2)
  {
    unint64_t v4 = (_OWORD *)result;
    for (double i = (_OWORD *)(result + 80); v4 + 5 != a2; double i = v4 + 5)
    {
      uint64_t v7 = v4;
      unint64_t v4 = i;
      unint64_t v8 = *a3;
      __int128 v9 = v4[3];
      void v36[2] = v4[2];
      v36[3] = v9;
      v36[4] = v4[4];
      __int128 v10 = v4[1];
      v36[0] = *v4;
      v36[1] = v10;
      __int128 v12 = v7[1];
      __int128 v11 = v7[2];
      __int128 v13 = v7[4];
      v35[3] = v7[3];
      v35[4] = v13;
      v35[1] = v12;
      v35[2] = v11;
      v35[0] = *v7;
      uint64_t result = v8(v36, v35);
      if ((_DWORD)result)
      {
        __int128 v14 = v4[3];
        __int128 v32 = v4[2];
        __int128 v33 = v14;
        __int128 v34 = v4[4];
        __int128 v15 = v4[1];
        __int128 v30 = *v4;
        __int128 v31 = v15;
        __int128 v16 = v4;
        do
        {
          __int128 v17 = v16 - 5;
          __int128 v18 = *(v16 - 4);
          __int128 v19 = *(v16 - 2);
          __int128 v20 = *(v16 - 1);
          void v16[2] = *(v16 - 3);
          void v16[3] = v19;
          _DWORD v16[4] = v20;
          __int128 v21 = *(v16 - 6);
          *__int128 v16 = *(v16 - 5);
          v16[1] = v18;
          __n128 v22 = *a3;
          v29[2] = v32;
          v29[3] = v33;
          v29[4] = v34;
          v29[0] = v30;
          v29[1] = v31;
          __int128 v23 = *(v16 - 10);
          __int128 v24 = *(v16 - 9);
          __int128 v25 = *(v16 - 8);
          v28[3] = *(v16 - 7);
          v28[4] = v21;
          v28[1] = v24;
          _DWORD v28[2] = v25;
          v28[0] = v23;
          uint64_t result = v22(v29, v28);
          __int128 v16 = v17;
        }

        while ((result & 1) != 0);
        __int128 v26 = v33;
        uint64_t v17[2] = v32;
        v17[3] = v26;
        v17[4] = v34;
        __int128 v27 = v31;
        _OWORD *v17 = v30;
        v17[1] = v27;
      }
    }
  }

  return result;
}

uint64_t sub_10028F2C0(_OWORD *a1, _OWORD *a2, _OWORD *a3, unsigned int (**a4)(void, void))
{
  unint64_t v8 = *a4;
  __int128 v9 = a2[3];
  v89[2] = a2[2];
  v89[3] = v9;
  v89[4] = a2[4];
  __int128 v10 = a2[1];
  v89[0] = *a2;
  v89[1] = v10;
  __int128 v11 = a1[3];
  v88[2] = a1[2];
  v88[3] = v11;
  v88[4] = a1[4];
  __int128 v12 = a1[1];
  v88[0] = *a1;
  v88[1] = v12;
  char v13 = v8(v89, v88);
  __int128 v14 = *a4;
  if ((v13 & 1) != 0)
  {
    __int128 v15 = a3[3];
    v83[2] = a3[2];
    v83[3] = v15;
    v83[4] = a3[4];
    __int128 v16 = a3[1];
    v83[0] = *a3;
    v83[1] = v16;
    __int128 v17 = a2[3];
    v82[2] = a2[2];
    v82[3] = v17;
    v82[4] = a2[4];
    __int128 v18 = a2[1];
    v82[0] = *a2;
    v82[1] = v18;
    if (v14(v83, v82))
    {
      __int128 v19 = a1[3];
      __int128 v92 = a1[2];
      __int128 v93 = v19;
      __int128 v94 = a1[4];
      __int128 v20 = a1[1];
      __int128 v90 = *a1;
      __int128 v91 = v20;
      *a1 = *a3;
      __int128 v21 = a3[4];
      __int128 v23 = a3[1];
      __int128 v22 = a3[2];
      a1[3] = a3[3];
      a1[4] = v21;
      a1[1] = v23;
      a1[2] = v22;
      __int128 v24 = v94;
      __int128 v25 = v92;
      a3[3] = v93;
      a3[4] = v24;
      a3[2] = v25;
      __int128 v26 = v90;
      __int128 v27 = v91;
      uint64_t result = 1LL;
LABEL_9:
      *a3 = v26;
      a3[1] = v27;
      return result;
    }

    __int128 v57 = a1[3];
    __int128 v92 = a1[2];
    __int128 v93 = v57;
    __int128 v94 = a1[4];
    __int128 v58 = a1[1];
    __int128 v90 = *a1;
    __int128 v91 = v58;
    *a1 = *a2;
    __int128 v59 = a2[4];
    __int128 v61 = a2[1];
    __int128 v60 = a2[2];
    a1[3] = a2[3];
    a1[4] = v59;
    a1[1] = v61;
    a1[2] = v60;
    __int128 v62 = v94;
    __int128 v63 = v92;
    a2[3] = v93;
    a2[4] = v62;
    __int128 v64 = v91;
    *a2 = v90;
    a2[1] = v64;
    a2[2] = v63;
    uint64_t v65 = *a4;
    __int128 v67 = *a3;
    __int128 v66 = a3[1];
    __int128 v68 = a3[4];
    v81[3] = a3[3];
    v81[4] = v68;
    __int128 v69 = a3[2];
    v81[1] = v66;
    v81[2] = v69;
    __int128 v70 = *a2;
    __int128 v71 = a2[1];
    __int128 v72 = a2[3];
    v80[4] = a2[4];
    v81[0] = v67;
    v80[2] = a2[2];
    v80[3] = v72;
    v80[0] = v70;
    v80[1] = v71;
    if (v65(v81, v80))
    {
      __int128 v73 = a2[3];
      __int128 v92 = a2[2];
      __int128 v93 = v73;
      __int128 v94 = a2[4];
      __int128 v74 = a2[1];
      __int128 v90 = *a2;
      __int128 v91 = v74;
      *a2 = *a3;
      __int128 v75 = a3[4];
      __int128 v77 = a3[1];
      __int128 v76 = a3[2];
      a2[3] = a3[3];
      a2[4] = v75;
      a2[1] = v77;
      a2[2] = v76;
      __int128 v78 = v94;
      __int128 v79 = v92;
      a3[3] = v93;
      a3[4] = v78;
      a3[2] = v79;
      __int128 v26 = v90;
      __int128 v27 = v91;
      uint64_t result = 2LL;
      goto LABEL_9;
    }
  }

  else
  {
    __int128 v29 = a3[3];
    v87[2] = a3[2];
    v87[3] = v29;
    v87[4] = a3[4];
    __int128 v30 = a3[1];
    v87[0] = *a3;
    v87[1] = v30;
    __int128 v31 = a2[3];
    v86[2] = a2[2];
    v86[3] = v31;
    v86[4] = a2[4];
    __int128 v32 = a2[1];
    v86[0] = *a2;
    v86[1] = v32;
    uint64_t result = ((uint64_t (*)(_OWORD *, _OWORD *))v14)(v87, v86);
    if (!(_DWORD)result) {
      return result;
    }
    __int128 v33 = a2[3];
    __int128 v92 = a2[2];
    __int128 v93 = v33;
    __int128 v94 = a2[4];
    __int128 v34 = a2[1];
    __int128 v90 = *a2;
    __int128 v91 = v34;
    *a2 = *a3;
    __int128 v35 = a3[4];
    __int128 v37 = a3[1];
    __int128 v36 = a3[2];
    a2[3] = a3[3];
    a2[4] = v35;
    a2[1] = v37;
    a2[2] = v36;
    __int128 v38 = v94;
    __int128 v39 = v92;
    a3[3] = v93;
    a3[4] = v38;
    __int128 v40 = v91;
    *a3 = v90;
    a3[1] = v40;
    a3[2] = v39;
    __n128 v41 = *a4;
    __int128 v43 = *a2;
    __int128 v42 = a2[1];
    __int128 v44 = a2[4];
    v85[3] = a2[3];
    v85[4] = v44;
    __int128 v45 = a2[2];
    v85[1] = v42;
    v85[2] = v45;
    __int128 v46 = *a1;
    __int128 v47 = a1[1];
    __int128 v48 = a1[3];
    v84[4] = a1[4];
    v85[0] = v43;
    v84[2] = a1[2];
    v84[3] = v48;
    v84[0] = v46;
    v84[1] = v47;
    if (v41(v85, v84))
    {
      __int128 v49 = a1[3];
      __int128 v92 = a1[2];
      __int128 v93 = v49;
      __int128 v94 = a1[4];
      __int128 v50 = a1[1];
      __int128 v90 = *a1;
      __int128 v91 = v50;
      *a1 = *a2;
      __int128 v51 = a2[4];
      __int128 v53 = a2[1];
      __int128 v52 = a2[2];
      a1[3] = a2[3];
      a1[4] = v51;
      a1[1] = v53;
      a1[2] = v52;
      __int128 v54 = v94;
      __int128 v55 = v92;
      a2[3] = v93;
      a2[4] = v54;
      __int128 v56 = v91;
      uint64_t result = 2LL;
      *a2 = v90;
      a2[1] = v56;
      a2[2] = v55;
      return result;
    }
  }

  return 1LL;
}

_OWORD *sub_10028F5F4(_OWORD *a1, _OWORD *a2, uint64_t (**a3)(void, void))
{
  unint64_t v4 = a2;
  __int128 v6 = a1[3];
  __int128 v69 = a1[2];
  __int128 v70 = v6;
  __int128 v71 = a1[4];
  __int128 v7 = a1[1];
  __int128 v67 = *a1;
  __int128 v68 = v7;
  unint64_t v8 = *a3;
  v66[2] = v69;
  v66[3] = v6;
  v66[4] = v71;
  v66[0] = v67;
  v66[1] = v7;
  __int128 v9 = *(a2 - 5);
  __int128 v10 = *(a2 - 4);
  __int128 v11 = *(a2 - 3);
  __int128 v12 = *(a2 - 1);
  v65[3] = *(a2 - 2);
  v65[4] = v12;
  v65[1] = v10;
  v65[2] = v11;
  v65[0] = v9;
  if ((v8(v66, v65) & 1) != 0)
  {
    char v13 = a1;
    do
    {
      __int128 v14 = v13 + 5;
      __int128 v15 = *a3;
      v64[2] = v69;
      v64[3] = v70;
      v64[4] = v71;
      v64[0] = v67;
      v64[1] = v68;
      __int128 v16 = v13[8];
      v63[2] = v13[7];
      v63[3] = v16;
      v63[4] = v13[9];
      __int128 v17 = v13[6];
      v63[0] = v13[5];
      v63[1] = v17;
      char v18 = v15(v64, v63);
      char v13 = v14;
    }

    while ((v18 & 1) == 0);
  }

  else
  {
    __int128 v19 = a1 + 5;
    do
    {
      __int128 v14 = v19;
      if (v19 >= v4) {
        break;
      }
      __int128 v20 = *a3;
      v62[2] = v69;
      v62[3] = v70;
      v62[4] = v71;
      v62[0] = v67;
      v62[1] = v68;
      __int128 v21 = v14[3];
      v61[2] = v14[2];
      v61[3] = v21;
      v61[4] = v14[4];
      __int128 v22 = v14[1];
      v61[0] = *v14;
      v61[1] = v22;
      int v23 = v20(v62, v61);
      __int128 v19 = v14 + 5;
    }

    while (!v23);
  }

  if (v14 >= v4)
  {
    __int128 v24 = v4;
  }

  else
  {
    do
    {
      __int128 v24 = v4 - 5;
      __int128 v25 = *a3;
      v60[2] = v69;
      v60[3] = v70;
      v60[4] = v71;
      v60[0] = v67;
      v60[1] = v68;
      __int128 v26 = *(v4 - 2);
      v59[2] = *(v4 - 3);
      v59[3] = v26;
      v59[4] = *(v4 - 1);
      __int128 v27 = *(v4 - 4);
      v59[0] = *(v4 - 5);
      v59[1] = v27;
      v4 -= 5;
    }

    while ((v25(v60, v59) & 1) != 0);
  }

  while (v14 < v24)
  {
    __int128 v72 = *v14;
    __int128 v28 = v14[1];
    __int128 v29 = v14[2];
    __int128 v30 = v14[4];
    __int128 v75 = v14[3];
    __int128 v76 = v30;
    __int128 v73 = v28;
    __int128 v74 = v29;
    __int128 v31 = v24[4];
    __int128 v33 = v24[1];
    __int128 v32 = v24[2];
    void v14[3] = v24[3];
    _DWORD v14[4] = v31;
    v14[1] = v33;
    _OWORD v14[2] = v32;
    _OWORD *v14 = *v24;
    __int128 v34 = v76;
    __int128 v36 = v73;
    __int128 v35 = v74;
    void v24[3] = v75;
    v24[4] = v34;
    v24[1] = v36;
    __n128 v24[2] = v35;
    *__int128 v24 = v72;
    do
    {
      void v58[2] = v69;
      v58[3] = v70;
      v58[4] = v71;
      v58[0] = v67;
      v58[1] = v68;
      __int128 v38 = v14[6];
      __int128 v37 = v14[7];
      __int128 v39 = v14[9];
      v57[3] = v14[8];
      v57[4] = v39;
      v57[1] = v38;
      _OWORD v57[2] = v37;
      __int128 v40 = v14[5];
      v14 += 5;
      __n128 v41 = (unsigned int (*)(void, void))*a3;
      v57[0] = v40;
    }

    while (!v41(v58, v57));
    do
    {
      v56[2] = v69;
      v56[3] = v70;
      v56[4] = v71;
      v56[0] = v67;
      v56[1] = v68;
      __int128 v43 = *(v24 - 4);
      __int128 v42 = *(v24 - 3);
      __int128 v44 = *(v24 - 1);
      v55[3] = *(v24 - 2);
      v55[4] = v44;
      v55[1] = v43;
      v55[2] = v42;
      __int128 v45 = *(v24 - 5);
      v24 -= 5;
      __int128 v46 = *a3;
      v55[0] = v45;
    }

    while ((v46(v56, v55) & 1) != 0);
  }

  __int128 v47 = v14 - 5;
  if (v14 - 5 != a1)
  {
    *a1 = *v47;
    __int128 v48 = *(v14 - 4);
    __int128 v49 = *(v14 - 3);
    __int128 v50 = *(v14 - 1);
    a1[3] = *(v14 - 2);
    a1[4] = v50;
    a1[1] = v48;
    a1[2] = v49;
  }

  *__int128 v47 = v67;
  __int128 v51 = v68;
  __int128 v52 = v69;
  __int128 v53 = v71;
  *(v14 - 2) = v70;
  *(v14 - 1) = v53;
  *(v14 - 4) = v51;
  *(v14 - 3) = v52;
  return v14;
}

__int128 *sub_10028F8D4(__int128 *a1, __int128 *a2, uint64_t (**a3)(void, void))
{
  uint64_t v6 = 0LL;
  __int128 v7 = a1[3];
  __int128 v60 = a1[2];
  __int128 v61 = v7;
  __int128 v62 = a1[4];
  __int128 v8 = a1[1];
  __int128 v58 = *a1;
  __int128 v59 = v8;
  do
  {
    __int128 v9 = *a3;
    __int128 v10 = a1[v6 + 8];
    _OWORD v57[2] = a1[v6 + 7];
    v57[3] = v10;
    v57[4] = a1[v6 + 9];
    __int128 v11 = a1[v6 + 6];
    v57[0] = a1[v6 + 5];
    v57[1] = v11;
    v56[2] = v60;
    v56[3] = v61;
    v56[4] = v62;
    v56[0] = v58;
    v56[1] = v59;
    v6 += 5LL;
  }

  while ((v9(v57, v56) & 1) != 0);
  __int128 v12 = &a1[v6];
  char v13 = &a1[v6 - 5];
  if (v6 == 5)
  {
    while (v12 < a2)
    {
      char v18 = *a3;
      __int128 v14 = a2 - 5;
      __int128 v19 = *(a2 - 2);
      v55[2] = *(a2 - 3);
      v55[3] = v19;
      v55[4] = *(a2 - 1);
      __int128 v20 = *(a2 - 4);
      v55[0] = *(a2 - 5);
      v55[1] = v20;
      v54[2] = v60;
      v54[3] = v61;
      v54[4] = v62;
      v54[0] = v58;
      v54[1] = v59;
      a2 -= 5;
      if ((v18(v55, v54) & 1) != 0) {
        goto LABEL_9;
      }
    }

    __int128 v14 = a2;
  }

  else
  {
    do
    {
      __int128 v14 = a2 - 5;
      __int128 v15 = (unsigned int (*)(void, void))*a3;
      __int128 v16 = *(a2 - 2);
      _OWORD v53[2] = *(a2 - 3);
      v53[3] = v16;
      v53[4] = *(a2 - 1);
      __int128 v17 = *(a2 - 4);
      v53[0] = *(a2 - 5);
      v53[1] = v17;
      v52[2] = v60;
      v52[3] = v61;
      v52[4] = v62;
      v52[0] = v58;
      v52[1] = v59;
      a2 -= 5;
    }

    while (!v15(v53, v52));
  }

BOOL sub_10028FB9C(__int128 *a1, __int128 *a2, unsigned int (**a3)(void, void))
{
  unint64_t v6 = 0xCCCCCCCCCCCCCCCDLL * (a2 - a1);
  BOOL result = 1LL;
  switch(v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      __int128 v8 = *a3;
      __int128 v9 = *(a2 - 2);
      v49[2] = *(a2 - 3);
      v49[3] = v9;
      v49[4] = *(a2 - 1);
      __int128 v10 = *(a2 - 4);
      v49[0] = *(a2 - 5);
      v49[1] = v10;
      __int128 v11 = a1[3];
      v48[2] = a1[2];
      v48[3] = v11;
      v48[4] = a1[4];
      __int128 v12 = a1[1];
      v48[0] = *a1;
      v48[1] = v12;
      if (!v8(v49, v48)) {
        return 1LL;
      }
      char v13 = a2 - 5;
      __int128 v14 = a1[3];
      __int128 v52 = a1[2];
      __int128 v53 = v14;
      __int128 v54 = a1[4];
      __int128 v15 = a1[1];
      __int128 v50 = *a1;
      __int128 v51 = v15;
      *a1 = *(a2 - 5);
      __int128 v16 = *(a2 - 1);
      __int128 v18 = *(a2 - 4);
      __int128 v17 = *(a2 - 3);
      a1[3] = *(a2 - 2);
      a1[4] = v16;
      a1[1] = v18;
      a1[2] = v17;
      __int128 v19 = v54;
      __int128 v20 = v52;
      void v13[3] = v53;
      v13[4] = v19;
      __int128 v21 = v51;
      BOOL result = 1LL;
      __int128 *v13 = v50;
      v13[1] = v21;
      _DWORD v13[2] = v20;
      return result;
    case 3uLL:
      sub_10028F2C0(a1, a1 + 5, a2 - 5, a3);
      return 1LL;
    case 4uLL:
      sub_10028FE88(a1, a1 + 5, a1 + 10, a2 - 5, a3);
      return 1LL;
    case 5uLL:
      sub_10029009C(a1, a1 + 5, a1 + 10, a1 + 15, a2 - 5, a3);
      return 1LL;
    default:
      __int128 v22 = a1 + 10;
      sub_10028F2C0(a1, a1 + 5, a1 + 10, a3);
      __int128 v23 = a1 + 15;
      if (a1 + 15 == a2) {
        return 1LL;
      }
      uint64_t v24 = 0LL;
      int v25 = 0;
      break;
  }

  while (1)
  {
    __int128 v26 = *a3;
    __int128 v27 = v23[3];
    v47[2] = v23[2];
    v47[3] = v27;
    v47[4] = v23[4];
    __int128 v28 = v23[1];
    v47[0] = *v23;
    v47[1] = v28;
    __int128 v30 = v22[1];
    __int128 v29 = v22[2];
    __int128 v31 = v22[4];
    v46[3] = v22[3];
    v46[4] = v31;
    v46[1] = v30;
    id v46[2] = v29;
    v46[0] = *v22;
    if (v26(v47, v46))
    {
      __int128 v32 = v23[3];
      __int128 v52 = v23[2];
      __int128 v53 = v32;
      __int128 v54 = v23[4];
      __int128 v33 = v23[1];
      __int128 v50 = *v23;
      __int128 v51 = v33;
      uint64_t v34 = v24;
      while (1)
      {
        __int128 v35 = (__int128 *)((char *)a1 + v34);
        __int128 v36 = *(__int128 *)((char *)a1 + v34 + 208);
        v35[17] = *(__int128 *)((char *)a1 + v34 + 192);
        v35[18] = v36;
        v35[19] = *(__int128 *)((char *)a1 + v34 + 224);
        __int128 v37 = *(__int128 *)((char *)a1 + v34 + 176);
        v35[15] = *(__int128 *)((char *)a1 + v34 + 160);
        v35[16] = v37;
        if (v34 == -160) {
          break;
        }
        __int128 v38 = *a3;
        v45[2] = v52;
        v45[3] = v53;
        v45[4] = v54;
        v45[0] = v50;
        v45[1] = v51;
        __int128 v39 = v35[8];
        v44[2] = v35[7];
        v44[3] = v39;
        v44[4] = v35[9];
        __int128 v40 = v35[6];
        v44[0] = v35[5];
        v44[1] = v40;
        v34 -= 80LL;
        if ((((uint64_t (*)(_OWORD *, _OWORD *))v38)(v45, v44) & 1) == 0)
        {
          __int128 v41 = (__int128 *)((char *)a1 + v34 + 240);
          goto LABEL_12;
        }
      }

      __int128 v41 = a1;
LABEL_12:
      __int128 v42 = v53;
      v41[2] = v52;
      v41[3] = v42;
      v41[4] = v54;
      __int128 v43 = v51;
      *__int128 v41 = v50;
      v41[1] = v43;
      if (++v25 == 8) {
        return v23 + 5 == a2;
      }
    }

    __int128 v22 = v23;
    v24 += 80LL;
    v23 += 5;
    if (v23 == a2) {
      return 1LL;
    }
  }

double sub_10028FE88( __int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4, unsigned int (**a5)(void, void))
{
  __int128 v10 = *a5;
  __int128 v11 = a4[3];
  v61[2] = a4[2];
  v61[3] = v11;
  v61[4] = a4[4];
  __int128 v12 = a4[1];
  v61[0] = *a4;
  v61[1] = v12;
  __int128 v13 = a3[3];
  v60[2] = a3[2];
  v60[3] = v13;
  v60[4] = a3[4];
  __int128 v14 = a3[1];
  v60[0] = *a3;
  v60[1] = v14;
  if (v10(v61, v60))
  {
    __int128 v16 = a3[3];
    __int128 v64 = a3[2];
    __int128 v65 = v16;
    __int128 v66 = a3[4];
    __int128 v17 = a3[1];
    __int128 v62 = *a3;
    __int128 v63 = v17;
    *a3 = *a4;
    __int128 v18 = a4[4];
    __int128 v20 = a4[1];
    __int128 v19 = a4[2];
    a3[3] = a4[3];
    a3[4] = v18;
    a3[1] = v20;
    a3[2] = v19;
    __int128 v21 = v66;
    __int128 v22 = v64;
    a4[3] = v65;
    a4[4] = v21;
    __int128 v23 = v63;
    *a4 = v62;
    a4[1] = v23;
    a4[2] = v22;
    uint64_t v24 = *a5;
    __int128 v26 = *a3;
    __int128 v25 = a3[1];
    __int128 v27 = a3[4];
    v59[3] = a3[3];
    v59[4] = v27;
    __int128 v28 = a3[2];
    v59[1] = v25;
    v59[2] = v28;
    __int128 v29 = *a2;
    __int128 v30 = a2[1];
    __int128 v31 = a2[3];
    v58[4] = a2[4];
    v59[0] = v26;
    void v58[2] = a2[2];
    v58[3] = v31;
    v58[0] = v29;
    v58[1] = v30;
    if (v24(v59, v58))
    {
      __int128 v32 = a2[3];
      __int128 v64 = a2[2];
      __int128 v65 = v32;
      __int128 v66 = a2[4];
      __int128 v33 = a2[1];
      __int128 v62 = *a2;
      __int128 v63 = v33;
      *a2 = *a3;
      __int128 v34 = a3[4];
      __int128 v36 = a3[1];
      __int128 v35 = a3[2];
      a2[3] = a3[3];
      a2[4] = v34;
      a2[1] = v36;
      a2[2] = v35;
      __int128 v37 = v66;
      __int128 v38 = v64;
      a3[3] = v65;
      a3[4] = v37;
      __int128 v39 = v63;
      *a3 = v62;
      a3[1] = v39;
      a3[2] = v38;
      __int128 v40 = *a5;
      __int128 v42 = *a2;
      __int128 v41 = a2[1];
      __int128 v43 = a2[4];
      v57[3] = a2[3];
      v57[4] = v43;
      __int128 v44 = a2[2];
      v57[1] = v41;
      _OWORD v57[2] = v44;
      __int128 v45 = *a1;
      __int128 v46 = a1[1];
      __int128 v47 = a1[3];
      v56[4] = a1[4];
      v57[0] = v42;
      v56[2] = a1[2];
      v56[3] = v47;
      v56[0] = v45;
      v56[1] = v46;
      if (v40(v57, v56))
      {
        __int128 v48 = a1[3];
        __int128 v64 = a1[2];
        __int128 v65 = v48;
        __int128 v66 = a1[4];
        __int128 v49 = a1[1];
        __int128 v62 = *a1;
        __int128 v63 = v49;
        *a1 = *a2;
        __int128 v50 = a2[4];
        __int128 v52 = a2[1];
        __int128 v51 = a2[2];
        a1[3] = a2[3];
        a1[4] = v50;
        a1[1] = v52;
        a1[2] = v51;
        __int128 v53 = v66;
        __int128 v54 = v64;
        a2[3] = v65;
        a2[4] = v53;
        double result = *(double *)&v62;
        __int128 v55 = v63;
        *a2 = v62;
        a2[1] = v55;
        a2[2] = v54;
      }
    }
  }

  return result;
}

double sub_10029009C( __int128 *a1, __int128 *a2, __int128 *a3, __int128 *a4, __int128 *a5, unsigned int (**a6)(void, void))
{
  __int128 v12 = *a6;
  __int128 v13 = a5[3];
  v81[2] = a5[2];
  v81[3] = v13;
  v81[4] = a5[4];
  __int128 v14 = a5[1];
  v81[0] = *a5;
  v81[1] = v14;
  __int128 v15 = a4[3];
  v80[2] = a4[2];
  v80[3] = v15;
  v80[4] = a4[4];
  __int128 v16 = a4[1];
  v80[0] = *a4;
  v80[1] = v16;
  if (v12(v81, v80))
  {
    __int128 v18 = a4[3];
    __int128 v84 = a4[2];
    __int128 v85 = v18;
    __int128 v86 = a4[4];
    __int128 v19 = a4[1];
    __int128 v82 = *a4;
    __int128 v83 = v19;
    *a4 = *a5;
    __int128 v20 = a5[4];
    __int128 v22 = a5[1];
    __int128 v21 = a5[2];
    a4[3] = a5[3];
    a4[4] = v20;
    a4[1] = v22;
    a4[2] = v21;
    __int128 v23 = v86;
    __int128 v24 = v84;
    a5[3] = v85;
    a5[4] = v23;
    __int128 v25 = v83;
    *a5 = v82;
    a5[1] = v25;
    a5[2] = v24;
    __int128 v26 = *a6;
    __int128 v28 = *a4;
    __int128 v27 = a4[1];
    __int128 v29 = a4[4];
    v79[3] = a4[3];
    v79[4] = v29;
    __int128 v30 = a4[2];
    v79[1] = v27;
    v79[2] = v30;
    __int128 v31 = *a3;
    __int128 v32 = a3[1];
    __int128 v33 = a3[3];
    v78[4] = a3[4];
    v79[0] = v28;
    void v78[2] = a3[2];
    v78[3] = v33;
    v78[0] = v31;
    v78[1] = v32;
    if (v26(v79, v78))
    {
      __int128 v34 = a3[3];
      __int128 v84 = a3[2];
      __int128 v85 = v34;
      __int128 v86 = a3[4];
      __int128 v35 = a3[1];
      __int128 v82 = *a3;
      __int128 v83 = v35;
      *a3 = *a4;
      __int128 v36 = a4[4];
      __int128 v38 = a4[1];
      __int128 v37 = a4[2];
      a3[3] = a4[3];
      a3[4] = v36;
      a3[1] = v38;
      a3[2] = v37;
      __int128 v39 = v86;
      __int128 v40 = v84;
      a4[3] = v85;
      a4[4] = v39;
      __int128 v41 = v83;
      *a4 = v82;
      a4[1] = v41;
      a4[2] = v40;
      __int128 v42 = *a6;
      __int128 v44 = *a3;
      __int128 v43 = a3[1];
      __int128 v45 = a3[4];
      v77[3] = a3[3];
      v77[4] = v45;
      __int128 v46 = a3[2];
      v77[1] = v43;
      v77[2] = v46;
      __int128 v47 = *a2;
      __int128 v48 = a2[1];
      __int128 v49 = a2[3];
      v76[4] = a2[4];
      v77[0] = v44;
      v76[2] = a2[2];
      v76[3] = v49;
      v76[0] = v47;
      v76[1] = v48;
      if (v42(v77, v76))
      {
        __int128 v50 = a2[3];
        __int128 v84 = a2[2];
        __int128 v85 = v50;
        __int128 v86 = a2[4];
        __int128 v51 = a2[1];
        __int128 v82 = *a2;
        __int128 v83 = v51;
        *a2 = *a3;
        __int128 v52 = a3[4];
        __int128 v54 = a3[1];
        __int128 v53 = a3[2];
        a2[3] = a3[3];
        a2[4] = v52;
        a2[1] = v54;
        a2[2] = v53;
        __int128 v55 = v86;
        __int128 v56 = v84;
        a3[3] = v85;
        a3[4] = v55;
        __int128 v57 = v83;
        *a3 = v82;
        a3[1] = v57;
        a3[2] = v56;
        __int128 v58 = *a6;
        __int128 v60 = *a2;
        __int128 v59 = a2[1];
        __int128 v61 = a2[4];
        v75[3] = a2[3];
        v75[4] = v61;
        __int128 v62 = a2[2];
        v75[1] = v59;
        v75[2] = v62;
        __int128 v63 = *a1;
        __int128 v64 = a1[1];
        __int128 v65 = a1[3];
        v74[4] = a1[4];
        v75[0] = v60;
        v74[2] = a1[2];
        v74[3] = v65;
        v74[0] = v63;
        v74[1] = v64;
        if (v58(v75, v74))
        {
          __int128 v66 = a1[3];
          __int128 v84 = a1[2];
          __int128 v85 = v66;
          __int128 v86 = a1[4];
          __int128 v67 = a1[1];
          __int128 v82 = *a1;
          __int128 v83 = v67;
          *a1 = *a2;
          __int128 v68 = a2[4];
          __int128 v70 = a2[1];
          __int128 v69 = a2[2];
          a1[3] = a2[3];
          a1[4] = v68;
          a1[1] = v70;
          a1[2] = v69;
          __int128 v71 = v86;
          __int128 v72 = v84;
          a2[3] = v85;
          a2[4] = v71;
          double result = *(double *)&v82;
          __int128 v73 = v83;
          *a2 = v82;
          a2[1] = v73;
          a2[2] = v72;
        }
      }
    }
  }

  return result;
}

__n128 *sub_100290344(uint64_t a1, __n128 *a2, __n128 *a3, unsigned int (**a4)(void, void))
{
  if ((__n128 *)a1 != a2)
  {
    uint64_t v8 = (uint64_t)a2 - a1;
    uint64_t v9 = ((uint64_t)a2 - a1) / 80;
    if ((uint64_t)a2 - a1 >= 81)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      __int128 v12 = (__n128 *)(a1 + 80 * v10);
      do
      {
        sub_1002905AC(a1, a4, v9, v12);
        v12 -= 5;
        --v11;
      }

      while (v11);
    }

    __int128 v13 = a2;
    if (a2 != a3)
    {
      __int128 v14 = a2;
      do
      {
        __int128 v15 = (unsigned int (*)(_OWORD *, _OWORD *))*a4;
        __n128 v16 = v14[3];
        v43[2] = v14[2];
        v43[3] = v16;
        v43[4] = v14[4];
        __n128 v17 = v14[1];
        v43[0] = *v14;
        v43[1] = v17;
        __int128 v18 = *(_OWORD *)(a1 + 48);
        _OWORD v42[2] = *(_OWORD *)(a1 + 32);
        v42[3] = v18;
        v42[4] = *(_OWORD *)(a1 + 64);
        __int128 v19 = *(_OWORD *)(a1 + 16);
        v42[0] = *(_OWORD *)a1;
        v42[1] = v19;
        if (v15(v43, v42))
        {
          __n128 v20 = v14[3];
          __n128 v46 = v14[2];
          __n128 v47 = v20;
          __n128 v48 = v14[4];
          __n128 v21 = v14[1];
          __n128 v44 = *v14;
          __n128 v45 = v21;
          __n128 *v14 = *(__n128 *)a1;
          __n128 v22 = *(__n128 *)(a1 + 64);
          __n128 v24 = *(__n128 *)(a1 + 16);
          __n128 v23 = *(__n128 *)(a1 + 32);
          void v14[3] = *(__n128 *)(a1 + 48);
          _DWORD v14[4] = v22;
          v14[1] = v24;
          _OWORD v14[2] = v23;
          __n128 v25 = v48;
          __n128 v26 = v46;
          *(__n128 *)(a1 + 4std::ostream::~ostream(v2, v3 + 8) = v47;
          *(__n128 *)(a1 + 64) = v25;
          __n128 v27 = v45;
          *(__n128 *)a1 = v44;
          *(__n128 *)(a1 + 16) = v27;
          *(__n128 *)(a1 + sub_10000AE14(v13 - 32) = v26;
          sub_1002905AC(a1, a4, v9, (__n128 *)a1);
        }

        v14 += 5;
      }

      while (v14 != a3);
      __int128 v13 = a3;
    }

    if (v8 >= 81)
    {
      int64_t v28 = v8 / 0x50uLL;
      __int128 v29 = a2 - 5;
      do
      {
        __n128 v30 = *(__n128 *)(a1 + 48);
        __n128 v46 = *(__n128 *)(a1 + 32);
        __n128 v47 = v30;
        __n128 v48 = *(__n128 *)(a1 + 64);
        __n128 v31 = *(__n128 *)(a1 + 16);
        __n128 v44 = *(__n128 *)a1;
        __n128 v45 = v31;
        __int128 v32 = (__n128 *)sub_10029080C((_OWORD *)a1, (unsigned int (**)(_OWORD *, _OWORD *))a4, v28);
        if (v29 == v32)
        {
          __n128 v38 = v47;
          void v32[2] = v46;
          void v32[3] = v38;
          void v32[4] = v48;
          __n128 v39 = v45;
          *__int128 v32 = v44;
          v32[1] = v39;
        }

        else
        {
          *__int128 v32 = *v29;
          __n128 v33 = v29[1];
          __n128 v34 = v29[2];
          __n128 v35 = v29[4];
          void v32[3] = v29[3];
          void v32[4] = v35;
          v32[1] = v33;
          void v32[2] = v34;
          __n128 v36 = v47;
          v29[2] = v46;
          v29[3] = v36;
          v29[4] = v48;
          __n128 v37 = v45;
          *__int128 v29 = v44;
          v29[1] = v37;
          sub_100290938(a1, (uint64_t)&v32[5], a4, 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)&v32[5] - a1) >> 4));
        }

        v29 -= 5;
      }

      while (v28-- > 2);
    }

    return v13;
  }

  return a3;
}

__n128 sub_1002905AC(uint64_t a1, unsigned int (**a2)(void, void), uint64_t a3, __n128 *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    unint64_t v5 = a4;
    int64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= (uint64_t)(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)a4 - a1) >> 4)))
    {
      int64_t v10 = (0x999999999999999ALL * (((uint64_t)a4 - a1) >> 4)) | 1;
      unint64_t v11 = (__n128 *)(a1 + 80 * v10);
      int64_t v12 = 0x999999999999999ALL * (((uint64_t)a4 - a1) >> 4) + 2;
      if (v12 < a3)
      {
        __n128 v13 = v11[3];
        _OWORD v57[2] = v11[2];
        v57[3] = v13;
        __n128 v14 = v11[5];
        v57[4] = v11[4];
        __n128 v15 = v11[1];
        v57[0] = *v11;
        v57[1] = v15;
        __n128 v16 = v11[6];
        __n128 v17 = v11[8];
        __n128 v18 = v11[9];
        v56[2] = v11[7];
        v56[3] = v17;
        v56[4] = v18;
        __int128 v19 = *a2;
        v56[0] = v14;
        v56[1] = v16;
        if (v19(v57, v56))
        {
          v11 += 5;
          int64_t v10 = v12;
        }
      }

      __n128 v20 = *a2;
      __n128 v21 = v11[3];
      v55[2] = v11[2];
      v55[3] = v21;
      v55[4] = v11[4];
      __n128 v22 = v11[1];
      v55[0] = *v11;
      v55[1] = v22;
      __n128 v23 = v5[3];
      v54[2] = v5[2];
      v54[3] = v23;
      v54[4] = v5[4];
      __n128 v24 = v5[1];
      v54[0] = *v5;
      v54[1] = v24;
      if ((((uint64_t (*)(_OWORD *, _OWORD *))v20)(v55, v54) & 1) == 0)
      {
        __n128 v26 = v5[3];
        __n128 v51 = v5[2];
        __n128 v52 = v26;
        __n128 v53 = v5[4];
        __n128 v27 = v5[1];
        __n128 v49 = *v5;
        __n128 v50 = v27;
        do
        {
          int64_t v28 = v11;
          *unint64_t v5 = *v11;
          __n128 v29 = v11[1];
          __n128 v30 = v11[2];
          __n128 v31 = v11[4];
          void v5[3] = v11[3];
          v5[4] = v31;
          v5[1] = v29;
          _DWORD v5[2] = v30;
          if (v7 < v10) {
            break;
          }
          uint64_t v32 = (2 * v10) | 1;
          unint64_t v11 = (__n128 *)(a1 + 80 * v32);
          if (2 * v10 + 2 < a3)
          {
            __n128 v33 = v11[3];
            v48[2] = v11[2];
            v48[3] = v33;
            __n128 v34 = v11[5];
            v48[4] = v11[4];
            __n128 v35 = v11[1];
            v48[0] = *v11;
            v48[1] = v35;
            __n128 v36 = v11[6];
            __n128 v37 = v11[8];
            __n128 v38 = v11[9];
            v47[2] = v11[7];
            v47[3] = v37;
            v47[4] = v38;
            __n128 v39 = *a2;
            v47[0] = v34;
            v47[1] = v36;
            if (v39(v48, v47))
            {
              v11 += 5;
              uint64_t v32 = 2 * v10 + 2;
            }
          }

          __int128 v40 = *a2;
          __n128 v41 = v11[3];
          id v46[2] = v11[2];
          v46[3] = v41;
          v46[4] = v11[4];
          __n128 v42 = v11[1];
          v46[0] = *v11;
          v46[1] = v42;
          v45[2] = v51;
          v45[3] = v52;
          v45[4] = v53;
          v45[0] = v49;
          v45[1] = v50;
          unint64_t v5 = v28;
          int64_t v10 = v32;
        }

        while (!v40(v46, v45));
        *int64_t v28 = v49;
        __n128 result = v50;
        __n128 v43 = v51;
        __n128 v44 = v53;
        v28[3] = v52;
        v28[4] = v44;
        v28[1] = result;
        _DWORD v28[2] = v43;
      }
    }
  }

  return result;
}

_OWORD *sub_10029080C(_OWORD *a1, unsigned int (**a2)(_OWORD *, _OWORD *), uint64_t a3)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = &a1[5 * v6 + 5];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3)
    {
      int64_t v12 = *a2;
      v24[0] = *v9;
      __int128 v13 = v9[4];
      __int128 v15 = v9[1];
      __int128 v14 = v9[2];
      void v24[3] = v9[3];
      v24[4] = v13;
      v24[1] = v15;
      __n128 v24[2] = v14;
      __int128 v17 = v9[6];
      __int128 v16 = v9[7];
      __int128 v18 = v9[9];
      v23[3] = v9[8];
      v23[4] = v18;
      v23[1] = v17;
      void v23[2] = v16;
      v23[0] = v9[5];
      if (v12(v24, v23))
      {
        v9 += 5;
        uint64_t v10 = v11;
      }
    }

    *a1 = *v9;
    __int128 v19 = v9[1];
    __int128 v20 = v9[2];
    __int128 v21 = v9[4];
    a1[3] = v9[3];
    a1[4] = v21;
    a1[1] = v19;
    a1[2] = v20;
    a1 = v9;
    uint64_t v6 = v10;
  }

  while (v10 <= v8);
  return v9;
}

__n128 sub_100290938(uint64_t a1, uint64_t a2, unsigned int (**a3)(void, void), uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v7 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v8 = *a3;
    uint64_t v9 = (_OWORD *)(a1 + 80 * v7);
    __int128 v10 = v9[3];
    v35[2] = v9[2];
    v35[3] = v10;
    v35[4] = v9[4];
    __int128 v11 = v9[1];
    v35[0] = *v9;
    v35[1] = v11;
    __int128 v12 = *(_OWORD *)(a2 - 32);
    v34[2] = *(_OWORD *)(a2 - 48);
    v34[3] = v12;
    v34[4] = *(_OWORD *)(a2 - 16);
    __int128 v13 = *(_OWORD *)(a2 - 64);
    v34[0] = *(_OWORD *)(a2 - 80);
    v34[1] = v13;
    if (v8(v35, v34))
    {
      __int128 v15 = (_OWORD *)(a2 - 80);
      __int128 v16 = *(_OWORD *)(a2 - 32);
      __int128 v31 = *(_OWORD *)(a2 - 48);
      __int128 v32 = v16;
      __int128 v33 = *(_OWORD *)(a2 - 16);
      __n128 v17 = *(__n128 *)(a2 - 64);
      __int128 v29 = *(_OWORD *)(a2 - 80);
      __n128 v30 = v17;
      do
      {
        __int128 v18 = v9;
        *__int128 v15 = *v9;
        __int128 v19 = v9[1];
        __int128 v20 = v9[2];
        __int128 v21 = v9[4];
        void v15[3] = v9[3];
        _DWORD v15[4] = v21;
        v15[1] = v19;
        id v15[2] = v20;
        if (!v7) {
          break;
        }
        __n128 v22 = *a3;
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v9 = (_OWORD *)(a1 + 80 * v7);
        __int128 v23 = v9[3];
        _DWORD v28[2] = v9[2];
        v28[3] = v23;
        v28[4] = v9[4];
        __int128 v24 = v9[1];
        v28[0] = *v9;
        v28[1] = v24;
        v27[2] = v31;
        v27[3] = v32;
        v27[4] = v33;
        v27[0] = v29;
        v27[1] = v30;
        char v25 = v22(v28, v27);
        __int128 v15 = v18;
      }

      while ((v25 & 1) != 0);
      __int128 v26 = v32;
      _DWORD v18[2] = v31;
      void v18[3] = v26;
      v18[4] = v33;
      __n128 result = v30;
      _OWORD *v18 = v29;
      v18[1] = result;
    }
  }

  return result;
}

__int128 *sub_100290AAC(__int128 *a1, __int128 *a2, unsigned int (**a3)(void, void))
{
  if (a1 != a2)
  {
    unint64_t v5 = a1 + 5;
    while (v5 != a2)
    {
      uint64_t v6 = *a3;
      v29[0] = *(v5 - 5);
      __int128 v7 = *(v5 - 1);
      __int128 v9 = *(v5 - 4);
      __int128 v8 = *(v5 - 3);
      v29[3] = *(v5 - 2);
      v29[4] = v7;
      v29[1] = v9;
      v29[2] = v8;
      __int128 v11 = v5[1];
      __int128 v10 = v5[2];
      __int128 v12 = v5[4];
      v28[3] = v5[3];
      v28[4] = v12;
      v28[1] = v11;
      _DWORD v28[2] = v10;
      __int128 v13 = *v5;
      v5 += 5;
      v28[0] = v13;
      if (v6(v29, v28))
      {
        __int128 v14 = v5 - 10;
        while (v5 != a2)
        {
          __int128 v15 = *a3;
          v27[0] = *v14;
          __int128 v16 = v14[4];
          __int128 v18 = v14[1];
          __int128 v17 = v14[2];
          v27[3] = v14[3];
          v27[4] = v16;
          v27[1] = v18;
          v27[2] = v17;
          __int128 v20 = v5[1];
          __int128 v19 = v5[2];
          __int128 v21 = v5[4];
          void v26[3] = v5[3];
          v26[4] = v21;
          v26[1] = v20;
          v26[2] = v19;
          v26[0] = *v5;
          if ((((uint64_t (*)(_OWORD *, _OWORD *))v15)(v27, v26) & 1) == 0)
          {
            void v14[5] = *v5;
            __int128 v22 = v5[1];
            __int128 v23 = v5[2];
            __int128 v24 = v5[4];
            _WORD v14[8] = v5[3];
            v14[9] = v24;
            v14[6] = v22;
            v14[7] = v23;
            v14 += 5;
          }

          v5 += 5;
        }

        return v14 + 5;
      }
    }
  }

  return a2;
}

void *sub_100290BF0(uint64_t a1)
{
  __n128 result = (void *)sub_100ACA534(a1, 0);
  *__n128 result = &off_10182DFE8;
  return result;
}

uint64_t *sub_100290C14(uint64_t a1)
{
  uint64_t v1 = (char *)dword_101347C98;
  while (!*(void *)(a1 + 16))
  {
LABEL_8:
    v1 += 4;
    if (v1 == "44CLStreamingAwareLocationProviderStateMachine") {
      return sub_100ACB610(a1, 0LL);
    }
  }

  int v2 = *(_DWORD *)v1;
  uint64_t v3 = *(uint64_t **)(a1 + 16);
  while (1)
  {
    int v4 = *((_DWORD *)v3 + 7);
    if (v2 >= v4) {
      break;
    }
LABEL_7:
    uint64_t v3 = (uint64_t *)*v3;
    if (!v3) {
      goto LABEL_8;
    }
  }

  if (v4 < v2)
  {
    ++v3;
    goto LABEL_7;
  }

  uint64_t v12 = 0LL;
  uint64_t v13 = 0LL;
  __asm { FMOV            V0.2D, #-1.0 }

  __int128 v11 = _Q0;
  return sub_100ACB794(a1, 0LL, (uint64_t)&v11);
}

uint64_t sub_100290CA8(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, void, uint64_t))(**(void **)(a1 + 32) + 8LL))( *(void *)(a1 + 32),  *a3,  a4);
}

void sub_100290CC4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100228DF0(a1);
  operator delete(v1);
}

uint64_t sub_100290CD8(double a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a3 + 48) + 48LL))(*(void *)(a3 + 48));
  if ((_DWORD)result)
  {
    uint64_t result = (*(uint64_t (**)(void, _BYTE *, double))(**(void **)(a3 + 48) + 24LL))( *(void *)(a3 + 48),  v6,  a1);
    if (v6[208]) {
      return sub_100253308(*(void *)(a3 + 56));
    }
  }

  return result;
}

uint64_t sub_100290D70(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(**(void **)(a2 + 56) + 48LL))(*(void *)(a2 + 56));
}

void sub_100290D80(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 912);
  uint64_t v5 = *(void *)(a1 + 928);
  uint64_t v28 = *(void *)(a1 + 944);
  uint64_t v29 = *(void *)(a1 + 920);
  uint64_t v6 = *(int *)(a1 + 972);
  int v7 = *(_DWORD *)(a1 + 976);
  float v8 = *(float *)(a1 + 984);
  float v9 = *(float *)(a1 + 988);
  float v10 = v8 * flt_1012E4728[v6];
  if (v8 >= 0.0833)
  {
    float v14 = (float)*(unsigned int *)(a1 + 1352);
    switch((int)v6)
    {
      case 2:
        double v15 = v14 * -1.44 + v10 * 2.06;
        double v16 = 7.77;
        break;
      case 3:
        double v15 = v14 * -0.62 + v10 * 5.5;
        double v16 = 4.44;
        break;
      case 4:
        double v15 = v14 * -1.44 + v10 * 2.06;
        double v16 = 8.77;
        break;
      default:
        double v15 = v14 * -0.61 + v10 * 2.0;
        double v16 = 6.59;
        break;
    }

    double v11 = v15 + v16;
    if (v9 >= 0.0)
    {
      if (v9 <= 20.0)
      {
        int v13 = 0;
        float v12 = 1.4;
      }

      else
      {
        int v13 = 0;
        if (v9 <= 80.0) {
          float v12 = (float)(v9 * -0.0033) + 1.466;
        }
        else {
          float v12 = 1.2;
        }
      }
    }

    else
    {
      int v13 = 0;
      float v12 = 1.3;
    }
  }

  else
  {
    double v11 = 2.0999999;
    if ((_DWORD)v6 == 6) {
      double v11 = 6.0;
    }
    float v12 = 1.0;
    int v13 = 3;
  }

  float v17 = v11;
  if (qword_1019344E0 != -1) {
    dispatch_once(&qword_1019344E0, &stru_10182E0E0);
  }
  float v18 = v12 * v17;
  __int128 v19 = (os_log_s *)qword_1019344E8;
  if (os_log_type_enabled((os_log_t)qword_1019344E8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v20 = *(void *)(a1 + 120);
    uint64_t v21 = *(void *)(a1 + 128);
    *(_DWORD *)std::stringbuf::string_type buf = 134221312;
    uint64_t v59 = v20;
    __int16 v60 = 2048;
    uint64_t v61 = v21;
    __int16 v62 = 1024;
    int v63 = v7;
    __int16 v64 = 1024;
    int v65 = v6;
    __int16 v66 = 2048;
    double v67 = v17;
    __int16 v68 = 2048;
    uint64_t v69 = v5;
    __int16 v70 = 2048;
    double v71 = v10;
    __int16 v72 = 1024;
    int v73 = v13;
    __int16 v74 = 2048;
    double v75 = v8;
    __int16 v76 = 2048;
    uint64_t v77 = v4;
    __int16 v78 = 2048;
    uint64_t v79 = v29;
    __int16 v80 = 2048;
    uint64_t v81 = v28;
    __int16 v82 = 2048;
    double v83 = v18;
    __int16 v84 = 2048;
    double v85 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "startTime,%f,endTime,%f,numberOfStrokes,%d,strokeType,%d,epochMets,%f,timestamp,%f,speed,%f,metSource,%d,strokeRat e,%f,entryStartTime,%f,entryEndTime,%f,distance,%f,scaledMets,%f,historicalTurnsPerSession,%f",  buf,  0x82u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344E0 != -1) {
      dispatch_once(&qword_1019344E0, &stru_10182E0E0);
    }
    uint64_t v24 = *(void *)(a1 + 120);
    uint64_t v25 = *(void *)(a1 + 128);
    int v30 = 134221312;
    uint64_t v31 = v24;
    __int16 v32 = 2048;
    uint64_t v33 = v25;
    __int16 v34 = 1024;
    int v35 = v7;
    __int16 v36 = 1024;
    int v37 = v6;
    __int16 v38 = 2048;
    double v39 = v17;
    __int16 v40 = 2048;
    uint64_t v41 = v5;
    __int16 v42 = 2048;
    double v43 = v10;
    __int16 v44 = 1024;
    int v45 = v13;
    __int16 v46 = 2048;
    double v47 = v8;
    __int16 v48 = 2048;
    uint64_t v49 = v4;
    __int16 v50 = 2048;
    uint64_t v51 = v29;
    __int16 v52 = 2048;
    uint64_t v53 = v28;
    __int16 v54 = 2048;
    double v55 = v18;
    __int16 v56 = 2048;
    double v57 = v9;
    LODWORD(v27) = 130;
    __int128 v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344E8,  2LL,  "startTime,%f,endTime,%f,numberOfStrokes,%d,strokeType,%d,epochMets,%f,timestamp,%f,speed,%f,metSourc e,%d,strokeRate,%f,entryStartTime,%f,entryEndTime,%f,distance,%f,scaledMets,%f,historicalTurnsPerSession,%f",  COERCE_DOUBLE(&v30),  v27,  v28,  v29);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLCalorieSwimmingModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v26);
  }

  if (v8 < 0.0833)
  {
    uint64_t v22 = sub_100F5A080();
    sub_100F5D168(v22);
  }

  uint64_t v23 = sub_100F5A080();
  sub_100F5CB34(v23, v6);
  *(_DWORD *)a2 = 0;
  *(float *)(a2 + 4) = v17;
  *(_DWORD *)(a2 + std::ostream::~ostream(v2, v3 + 8) = 0;
  *(float *)(a2 + 12) = v17;
  *(_DWORD *)(a2 + 16) = 0;
  *(float *)(a2 + 2sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v18;
  *(_DWORD *)(a2 + 24) = v13;
  *(_DWORD *)(a2 + 2std::ostream::~ostream(v2, v3 + 8) = 0;
  *(void *)(a2 + sub_10000AE14(v13 - 32) = 0xB00000003LL;
}

void sub_100291274(id a1)
{
  qword_1019344E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Swimming");
}

uint64_t sub_100291654(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    uint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        LODWORD(v6) = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      LODWORD(v6) = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      break;
    }
    switch((unsigned __int16)(v6 >> 3))
    {
      case 1u:
        char v12 = 0;
        unsigned int v13 = 0;
        uint64_t v14 = 0LL;
        *(_BYTE *)(a1 + 32) |= 2u;
        while (1)
        {
          unint64_t v15 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v15 == -1LL || v15 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v16 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v15);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v15 + 1;
          v14 |= (unint64_t)(v16 & 0x7F) << v12;
          if ((v16 & 0x80) == 0) {
            goto LABEL_56;
          }
          v12 += 7;
          BOOL v9 = v13++ >= 9;
          if (v9)
          {
            LODWORD(v14) = 0;
            goto LABEL_58;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_56:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v14) = 0;
        }
LABEL_58:
        uint64_t v36 = 16LL;
        goto LABEL_67;
      case 2u:
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v14 = 0LL;
        *(_BYTE *)(a1 + 32) |= 4u;
        while (2)
        {
          unint64_t v20 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v20 == -1LL || v20 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v21 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v20);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v20 + 1;
            v14 |= (unint64_t)(v21 & 0x7F) << v18;
            if (v21 < 0)
            {
              v18 += 7;
              BOOL v9 = v19++ >= 9;
              if (v9)
              {
                LODWORD(v14) = 0;
                goto LABEL_62;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v14) = 0;
        }
LABEL_62:
        uint64_t v36 = 20LL;
        goto LABEL_67;
      case 3u:
        char v22 = 0;
        unsigned int v23 = 0;
        uint64_t v14 = 0LL;
        *(_BYTE *)(a1 + 32) |= 8u;
        while (2)
        {
          unint64_t v24 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v24 == -1LL || v24 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v25 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v24);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v24 + 1;
            v14 |= (unint64_t)(v25 & 0x7F) << v22;
            if (v25 < 0)
            {
              v22 += 7;
              BOOL v9 = v23++ >= 9;
              if (v9)
              {
                LODWORD(v14) = 0;
                goto LABEL_66;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v14) = 0;
        }
LABEL_66:
        uint64_t v36 = 24LL;
LABEL_67:
        *(_DWORD *)(a1 + v36) = v14;
        continue;
      case 4u:
        char v26 = 0;
        unsigned int v27 = 0;
        uint64_t v28 = 0LL;
        *(_BYTE *)(a1 + 32) |= 0x10u;
        while (2)
        {
          unint64_t v29 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v29 == -1LL || v29 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v30 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v29);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v29 + 1;
            v28 |= (unint64_t)(v30 & 0x7F) << v26;
            if (v30 < 0)
            {
              v26 += 7;
              BOOL v9 = v27++ >= 9;
              if (v9)
              {
                uint64_t v28 = 0LL;
                goto LABEL_71;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v28 = 0LL;
        }
LABEL_71:
        *(_BYTE *)(a1 + 2std::ostream::~ostream(v2, v3 + 8) = v28 != 0;
        continue;
      case 5u:
        char v31 = 0;
        unsigned int v32 = 0;
        uint64_t v33 = 0LL;
        *(_BYTE *)(a1 + 32) |= 1u;
        break;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        continue;
    }

    while (1)
    {
      unint64_t v34 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v34 == -1LL || v34 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v35 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v34);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v34 + 1;
      v33 |= (unint64_t)(v35 & 0x7F) << v31;
      if ((v35 & 0x80) == 0) {
        goto LABEL_73;
      }
      v31 += 7;
      BOOL v9 = v32++ >= 9;
      if (v9)
      {
        uint64_t v33 = 0LL;
        goto LABEL_75;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_73:
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      uint64_t v33 = 0LL;
    }
LABEL_75:
    *(void *)(a1 + std::ostream::~ostream(v2, v3 + 8) = v33;
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

const char *sub_1002920B8(unsigned int a1)
{
  if (a1 > 5) {
    return "NONE";
  }
  else {
    return off_10182E100[a1];
  }
}

uint64_t sub_1002920DC()
{
  uint64_t v0 = sub_1007B3C30();
  return sub_1007B54BC(v0);
}

BOOL sub_1002920F0()
{
  uint64_t v0 = sub_1007B3C30();
  return sub_1007B6060(v0);
}

uint64_t sub_100292108()
{
  uint64_t v0 = sub_1007B3C30();
  return sub_1007B60AC(v0);
}

uint64_t sub_10029211C(const char *a1, uint64_t a2, int a3, uint64_t a4, const char *a5, char *a6, ...)
{
  uint64_t v12 = sub_1007B3C30();
  if (a3) {
    uint64_t result = sub_1007B4284(v12, a1, a2, a4, a5, a6, va);
  }
  else {
    uint64_t result = sub_1007B3EDC(v12, a1, a2, a4, a5, a6, va);
  }
  if (off_101993F80) {
    return off_101993F80(qword_101993F78, a1, a2, a4, a5, a6, va);
  }
  return result;
}

BOOL sub_1002921D0(int a1, int a2)
{
  uint64_t v4 = sub_1007B3C30();
  else {
    unsigned int v5 = off_10182E130[a1 - 116];
  }
  return sub_1007B71E8(v4, (uint64_t)v5, a2);
}

void sub_100292220(id a1)
{
  int v3 = 0;
  if (sub_1002F8DDC())
  {
    uint64_t v1 = sub_1002F8DDC();
    if (sub_1002A7CB0(v1, "gpsUtcLeapSeconds", &v3))
    {
      if (v3 >= 1)
      {
        int v2 = 18 - v3;
        if (v2 <= 19) {
          dword_101936DE0 = v3;
        }
      }
    }
  }

uint64_t sub_10029228C()
{
  if (!qword_101993F90)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    uint64_t v0 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "***no run loop available***", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      v3[0] = 0;
      int v2 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "***no run loop available***",  v3,  2);
      sub_10029211C("Generic", 1LL, 0, 0LL, "CFRunLoopRef CLCommonGetRunLoop()", "%s\n", v2);
    }
  }

  return qword_101993F90;
}

void sub_100292428(CFTypeRef cf)
{
  if (!qword_101993F90) {
    goto LABEL_16;
  }
  if ((CFTypeRef)qword_101993F90 == cf)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    uint64_t v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Setting CLCommon's runloop after it was already established",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      LOWORD(v12) = 0;
      double v10 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  0LL,  "#Warning Setting CLCommon's runloop after it was already established",  &v12,  2);
      unsigned int v5 = v11;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCommonSetRunLoop(CFRunLoopRef)", "%s\n", v10);
      goto LABEL_33;
    }
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    int v2 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "Changing CLCommon's runloop after it was already established",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      LOWORD(v12) = 0;
      double v3 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Changing CLCommon's runloop after it was already established",  &v12,  2);
      unsigned int v5 = v4;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLCommonSetRunLoop(CFRunLoopRef)", "%s\n", v3);
LABEL_33:
      if (v5 != buf) {
        free(v5);
      }
    }
  }

BOOL sub_100292840(double a1, double a2, double a3)
{
  return vabdd_f64(a1, a2) < a3;
}

BOOL sub_100292850(double a1, double a2, double a3, double a4, double a5)
{
  BOOL v5 = vabdd_f64(a1, a3) < a5;
  return vabdd_f64(a2, a4) < a5 && v5;
}

BOOL sub_10029286C(double a1, double a2)
{
  BOOL v2 = fabs(a1) < 0.00003;
  return fabs(a2) < 0.00003 && v2;
}

void sub_100292890(double a1)
{
}

void sub_1002928C4(double a1, double a2)
{
}

void sub_100292950(double a1)
{
}

void sub_1002929AC(double a1)
{
}

void (__cdecl ***sub_100292A34( void (__cdecl ***a1)(std::basic_stringstream<char> *__hidden this), const std::string *a2, int a3))(std::basic_stringstream<char> *__hidden this)
{
  BOOL v5 = a1 + 2;
  uint64_t v6 = (uint64_t)(a1 + 3);
  *a1 = v7;
  *(void *)((char *)*(v7 - 3) + (void)a1) = v8;
  a1[1] = 0LL;
  BOOL v9 = (std::ios_base *)((char *)*(*a1 - 3) + (void)a1);
  std::ios_base::init(v9, a1 + 3);
  v9[1].__vftable = 0LL;
  v9[1].__fmtflags_ = -1;
  a1[2] = v10;
  *(void *)((char *)*(v10 - 3) + (void)v5) = v11;
  *a1 = v12;
  sub_10023BE04(v6, a2, a3);
  return a1;
}

void sub_100292B2C(_Unwind_Exception *a1)
{
}

double sub_100292B54(double a1, double a2)
{
  double v2 = vabdd_f64(a1, a2);
  if (v2 > 180.0)
  {
    if (a1 >= 180.0) {
      a1 = 360.0 - a1;
    }
    if (a2 >= 180.0) {
      a2 = 360.0 - a2;
    }
    return a1 + a2;
  }

  return v2;
}

double sub_100292B94(double a1, double a2)
{
  double result = a1 + a2;
  double v3 = 360.0;
  if (result >= 360.0)
  {
    double v3 = -360.0;
    return result + v3;
  }

  if (result < 0.0) {
    return result + v3;
  }
  return result;
}

uint64_t sub_100292BC4(const char *a1)
{
  double v2 = getpwnam("mobile");
  if (v2)
  {
    uid_t pw_uid = v2->pw_uid;
    gid_t pw_gid = v2->pw_gid;
  }

  else
  {
    gid_t pw_gid = 501;
    uid_t pw_uid = 501;
  }

  return lchown(a1, pw_uid, pw_gid);
}

uint64_t sub_100292C04(_BYTE *a1, uid_t a2, gid_t a3)
{
  int v6 = *a1;
  if (!*a1) {
    return 1LL;
  }
  unint64_t v7 = 0LL;
  char v8 = a1 + 1;
  while (1)
  {
    v11[v7] = v6;
    if (v6 != 47 || !stat(v11, &v10)) {
      goto LABEL_7;
    }
    if (mkdir(v11, 0x1FFu)) {
      return 0LL;
    }
    lchown(v11, a2, a3);
    lchmod(v11, 0x1C0u);
LABEL_7:
    uint64_t result = 1LL;
    if (v7 <= 0x3FD)
    {
      int v6 = v8[v7++];
      if (v6) {
        continue;
      }
    }

    return result;
  }

uint64_t sub_100292CFC(const char *a1, uid_t a2, gid_t a3, mode_t a4)
{
  return lchmod(a1, a4);
}

BOOL sub_100292D28(const char *a1)
{
  return stat(a1, &v2) == 0;
}

BOOL sub_100292D50(const char *a1)
{
  return unlink(a1) == 0;
}

BOOL sub_100292D6C(const char *a1)
{
  return rmdir(a1) == 0;
}

BOOL sub_100292D88(const char *a1, const char *a2)
{
  return rename(a1, a2) == 0;
}

uint64_t sub_100292DA4(const char *a1, const char *a2)
{
  uint64_t v4 = malloc(0x400uLL);
  if (!v4) {
    goto LABEL_31;
  }
  BOOL v5 = fopen(a1, "rb");
  if (!v5)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    CFTypeRef v13 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      int v14 = *__error();
      *(_DWORD *)std::stringbuf::string_type buf = 136446466;
      char v30 = a1;
      __int16 v31 = 1026;
      int v32 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "cannot open source file: %{public}s, errno %{public}d",  buf,  0x12u);
    }

    uint64_t v11 = 0LL;
    if (!sub_1002921D0(115, 0)) {
      goto LABEL_39;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    uint64_t v15 = qword_101934A78;
    int v16 = *__error();
    *(_DWORD *)uint64_t v28 = 136446466;
    *(void *)&v28[4] = a1;
    *(_WORD *)&v28[12] = 1026;
    *(_DWORD *)&v28[14] = v16;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  17LL,  "cannot open source file: %{public}s, errno %{public}d",  v28,  18);
    char v18 = (uint8_t *)v17;
    sub_10029211C("Generic", 1LL, 0, 0LL, "int CLCommonCopyFile(const char *, const char *)", "%s\n", v17);
    if (v18 != buf) {
      free(v18);
    }
LABEL_31:
    uint64_t v11 = 0LL;
    goto LABEL_39;
  }

  int v6 = v5;
  unint64_t v7 = fopen(a2, "wb");
  if (!v7)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    unsigned int v19 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      int v20 = *__error();
      *(_DWORD *)std::stringbuf::string_type buf = 136446466;
      char v30 = a2;
      __int16 v31 = 1026;
      int v32 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_FAULT,  "cannot open target file: %{public}s, errno %{public}d",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      uint64_t v23 = qword_101934A78;
      int v24 = *__error();
      *(_DWORD *)uint64_t v28 = 136446466;
      *(void *)&v28[4] = a2;
      *(_WORD *)&v28[12] = 1026;
      *(_DWORD *)&v28[14] = v24;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v23,  17LL,  "cannot open target file: %{public}s, errno %{public}d",  v28,  18);
      char v26 = (uint8_t *)v25;
      sub_10029211C("Generic", 1LL, 0, 0LL, "int CLCommonCopyFile(const char *, const char *)", "%s\n", v25);
      if (v26 != buf) {
        free(v26);
      }
    }

    fclose(v6);
    goto LABEL_31;
  }

  char v8 = v7;
  while (1)
  {
    if (feof(v6))
    {
      uint64_t v11 = 1LL;
      goto LABEL_38;
    }

    size_t v9 = fread(v4, 1uLL, 0x400uLL, v6);
    if (v9 == -1LL) {
      break;
    }
    if (v9 != fwrite(v4, 1uLL, v9, v8))
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      stat v10 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 136446210;
        char v30 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "error writing target file: %{public}s",  buf,  0xCu);
      }

      uint64_t v11 = 0LL;
      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182E260);
        }
        *(_DWORD *)uint64_t v28 = 136446210;
        *(void *)&v28[4] = a2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "error writing target file: %{public}s",  v28,  12,  *(_OWORD *)v28);
LABEL_47:
        unsigned int v27 = (uint8_t *)v12;
        sub_10029211C("Generic", 1LL, 0, 0LL, "int CLCommonCopyFile(const char *, const char *)", "%s\n", v12);
        if (v27 != buf) {
          free(v27);
        }
        uint64_t v11 = 0LL;
        goto LABEL_38;
      }

      goto LABEL_38;
    }
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182E260);
  }
  char v21 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 136446210;
    char v30 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_FAULT,  "error reading source file: %{public}s",  buf,  0xCu);
  }

  uint64_t v11 = 0LL;
  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    *(_DWORD *)uint64_t v28 = 136446210;
    *(void *)&v28[4] = a1;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "error reading source file: %{public}s",  v28,  12,  *(_OWORD *)v28);
    goto LABEL_47;
  }

uint64_t sub_100293400(const char *a1, const char *a2)
{
  HIDWORD(v3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
  uint64_t v4 = malloc(0x400uLL);
  if (!v4) {
    goto LABEL_37;
  }
  BOOL v5 = fopen(a1, "rb");
  if (!v5)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    int v14 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      int v15 = *__error();
      *(_DWORD *)std::stringbuf::string_type buf = 136446466;
      uint64_t v33 = a1;
      __int16 v34 = 1026;
      int v35 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "cannot open source file: %{public}s, errno %{public}d",  buf,  0x12u);
    }

    uint64_t v11 = 0LL;
    if (!sub_1002921D0(115, 0)) {
      goto LABEL_38;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    uint64_t v16 = qword_101934A78;
    int v17 = *__error();
    *(_DWORD *)__int16 v31 = 136446466;
    *(void *)&_DWORD v31[4] = a1;
    *(_WORD *)&v31[12] = 1026;
    *(_DWORD *)&v31[14] = v17;
    LODWORD(v3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 18;
    char v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  17LL,  "cannot open source file: %{public}s, errno %{public}d",  v31,  v30);
    sub_10029211C("Generic", 1LL, 0LL, 0LL, "int CLCommonBzipFile(const char *, const char *)", "%s\n", v18);
LABEL_37:
    uint64_t v11 = 0LL;
    goto LABEL_38;
  }

  int v6 = v5;
  unint64_t v7 = fopen(a2, "wb");
  if (!v7)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    unsigned int v19 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      int v20 = *__error();
      *(_DWORD *)std::stringbuf::string_type buf = 136446466;
      uint64_t v33 = a1;
      __int16 v34 = 1026;
      int v35 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_FAULT,  "cannot open target file: %{public}s, errno %{public}d",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      uint64_t v26 = qword_101934A78;
      int v27 = *__error();
      *(_DWORD *)__int16 v31 = 136446466;
      *(void *)&_DWORD v31[4] = a1;
      *(_WORD *)&v31[12] = 1026;
      *(_DWORD *)&v31[14] = v27;
      LODWORD(v3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 18;
      uint64_t v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  17LL,  "cannot open target file: %{public}s, errno %{public}d",  v31,  v30);
      sub_10029211C("Generic", 1LL, 0LL, 0LL, "int CLCommonBzipFile(const char *, const char *)", "%s\n", v28);
    }

    fclose(v6);
    goto LABEL_37;
  }

  char v8 = v7;
  size_t v9 = BZ2_bzWriteOpen((int *)&v30 + 1, v7, 1, 0, 0);
  if (HIDWORD(v30))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    stat v10 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 136446466;
      uint64_t v33 = a2;
      __int16 v34 = 1026;
      int v35 = HIDWORD(v30);
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "cannot open compression stream: %{public}s, bzerror %{public}d",  buf,  0x12u);
    }

    uint64_t v11 = 0LL;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      *(_DWORD *)__int16 v31 = 136446466;
      *(void *)&_DWORD v31[4] = a2;
      *(_WORD *)&v31[12] = 1026;
      *(_DWORD *)&v31[14] = HIDWORD(v30);
      LODWORD(v3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 18;
      uint64_t v23 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "cannot open compression stream: %{public}s, bzerror %{public}d",  v31,  v30,  *(_OWORD *)v31,  *(void *)&v31[16]);
LABEL_58:
      char v25 = (uint8_t *)v23;
      sub_10029211C("Generic", 1LL, 0LL, 0LL, "int CLCommonBzipFile(const char *, const char *)", "%s\n", v23);
      if (v25 != buf) {
        free(v25);
      }
      uint64_t v11 = 0LL;
    }
  }

  else
  {
    while (1)
    {
      if (feof(v6))
      {
        uint64_t v11 = 1LL;
        goto LABEL_10;
      }

      size_t v13 = fread(v4, 1uLL, 0x400uLL, v6);
      if (v13 == -1LL) {
        break;
      }
      BZ2_bzWrite((int *)&v30 + 1, v9, v4, v13);
      if (HIDWORD(v30))
      {
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182E260);
        }
        int v24 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 136446466;
          uint64_t v33 = a2;
          __int16 v34 = 1026;
          int v35 = HIDWORD(v30);
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "error writing target file: %{public}s, bzerror: %{public}d",  buf,  0x12u);
        }

        uint64_t v11 = 0LL;
        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_10182E260);
          }
          *(_DWORD *)__int16 v31 = 136446466;
          *(void *)&_DWORD v31[4] = a2;
          *(_WORD *)&v31[12] = 1026;
          *(_DWORD *)&v31[14] = HIDWORD(v30);
          LODWORD(v3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 18;
          uint64_t v23 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "error writing target file: %{public}s, bzerror: %{public}d",  v31,  v30,  *(_OWORD *)v31,  *(void *)&v31[16]);
          goto LABEL_58;
        }

        goto LABEL_10;
      }
    }

    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    char v22 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 136446210;
      uint64_t v33 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_FAULT,  "error reading source file: %{public}s",  buf,  0xCu);
    }

    uint64_t v11 = 0LL;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      *(_DWORD *)__int16 v31 = 136446210;
      *(void *)&_DWORD v31[4] = a1;
      LODWORD(v3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 12;
      uint64_t v23 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "error reading source file: %{public}s",  v31,  v30,  *(_OWORD *)v31,  *(void *)&v31[16]);
      goto LABEL_58;
    }
  }

FILE *sub_100293D24(const char *a1)
{
  uint64_t result = fopen(a1, "rb");
  if (result)
  {
    stat v2 = result;
    fseek(result, 0LL, 2);
    uint64_t v3 = ftell(v2);
    fclose(v2);
    return (FILE *)v3;
  }

  return result;
}

BOOL sub_100293D74(char *a1, const char *a2)
{
  __int16 v50 = a1;
  sub_100222B94( v53,  (uint64_t)-[NSString UTF8String]( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"decompress:%@",  -[NSString lastPathComponent]( +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2),  "lastPathComponent")),  "UTF8String"),  0);
  uint64_t v51 = 0LL;
  off_t v52 = 0LL;
  uint64_t v3 = malloc(0x4000uLL);
  if (!v3)
  {
    BOOL v12 = 0LL;
    unsigned int v10 = 0;
    int v8 = 0;
    goto LABEL_56;
  }

  uint64_t v4 = v3;
  if (!sub_100294AAC(v50, (double *)&v51, 0LL, 0LL, &v52))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    char v21 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 136446210;
      __int16 v62 = v50;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_FAULT,  "CLCommonGzipDecompressFile, can't stat, %{public}s",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_37;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    int v54 = 136446210;
    double v55 = v50;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "CLCommonGzipDecompressFile, can't stat, %{public}s",  &v54,  12);
    uint64_t v23 = (uint8_t *)v22;
    sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLCommonGzipDecompressFile(const char *, const char *)", "%s\n", v22);
    goto LABEL_79;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182E260);
  }
  BOOL v5 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 136316162;
    __int16 v62 = v50;
    __int16 v63 = 2080;
    *(void *)__int16 v64 = a2;
    *(_WORD *)&v64[8] = 2048;
    *(void *)&_BYTE v64[10] = v52;
    *(_WORD *)&v64[18] = 2048;
    *(void *)&v64[20] = v51;
    *(_WORD *)&v64[28] = 1024;
    *(_DWORD *)int v65 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "CLCommonGzipDecompressFile, from, %s, to, %s, size, %llu, cTime, %.1lf, isOK, %d",  buf,  0x30u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    int v54 = 136316162;
    double v55 = v50;
    __int16 v56 = 2080;
    *(void *)double v57 = a2;
    *(_WORD *)&v57[8] = 2048;
    *(void *)&v57[10] = v52;
    *(_WORD *)&v57[18] = 2048;
    *(void *)&v57[20] = v51;
    *(_WORD *)&v57[28] = 1024;
    *(_DWORD *)__int128 v58 = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "CLCommonGzipDecompressFile, from, %s, to, %s, size, %llu, cTime, %.1lf, isOK, %d",  (const char *)&v54,  48,  v49,  *(double *)&v50,  v51);
    __int16 v40 = (uint8_t *)v39;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLCommonGzipDecompressFile(const char *, const char *)", "%s\n", v39);
    if (v40 != buf) {
      free(v40);
    }
  }

  int v6 = fopen(a2, "wb");
  if (v6)
  {
    unint64_t v7 = gzopen(v50, "rb");
    if (v7)
    {
      int v8 = 0;
      unsigned int v9 = 0;
      do
      {
        unsigned int v10 = v9;
        int v11 = gzeof(v7);
        BOOL v12 = v11 != 0;
        if (v11) {
          goto LABEL_53;
        }
        int v13 = gzread(v7, v4, 0x4000u);
        if (v13 <= 0)
        {
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_10182E260);
          }
          uint64_t v28 = (os_log_s *)qword_101934A78;
          if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
          {
            int v29 = *__error();
            *(_DWORD *)std::stringbuf::string_type buf = 136446722;
            __int16 v62 = v50;
            __int16 v63 = 1026;
            *(_DWORD *)__int16 v64 = v29;
            *(_WORD *)&v64[4] = 1026;
            *(_DWORD *)&v64[6] = v13;
            _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_FAULT,  "CLCommonGzipDecompressFile, error reading source file: %{public}s, errno, %{public}d, read, %{public}d",  buf,  0x18u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934A70 != -1) {
              dispatch_once(&qword_101934A70, &stru_10182E260);
            }
            uint64_t v30 = qword_101934A78;
            int v31 = *__error();
            int v54 = 136446722;
            double v55 = v50;
            __int16 v56 = 1026;
            *(_DWORD *)double v57 = v31;
            *(_WORD *)&v57[4] = 1026;
            *(_DWORD *)&v57[6] = v13;
            LODWORD(v4std::iostream::~basic_iostream(v2, v3 + 8) = 24;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v30,  17LL,  "CLCommonGzipDecompressFile, error reading source file: %{public}s, errno, %{public}d, read, %{public}d",  &v54,  v48);
            int v20 = (uint8_t *)v32;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLCommonGzipDecompressFile(const char *, const char *)",  "%s\n",  v32);
            if (v20 != buf) {
              goto LABEL_52;
            }
          }

          goto LABEL_53;
        }

        size_t v14 = fwrite(v4, 1uLL, v13, v6);
        v8 += v13;
        unsigned int v9 = v10 + v14;
      }

      while (v14 == v13);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      int v15 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        int v16 = *__error();
        *(_DWORD *)std::stringbuf::string_type buf = 136446722;
        __int16 v62 = (void *)a2;
        __int16 v63 = 1026;
        *(_DWORD *)__int16 v64 = v16;
        *(_WORD *)&v64[4] = 2050;
        *(void *)&v64[6] = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_FAULT,  "CLCommonGzipDecompressFile, can't write, %{public}s, errno, %{public}d, write, %{public}zu",  buf,  0x1Cu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182E260);
        }
        uint64_t v17 = qword_101934A78;
        int v18 = *__error();
        int v54 = 136446722;
        double v55 = (void *)a2;
        __int16 v56 = 1026;
        *(_DWORD *)double v57 = v18;
        *(_WORD *)&v57[4] = 2050;
        *(void *)&v57[6] = v14;
        LODWORD(v4std::iostream::~basic_iostream(v2, v3 + 8) = 28;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v17,  17LL,  "CLCommonGzipDecompressFile, can't write, %{public}s, errno, %{public}d, write, %{public}zu",  &v54,  v48);
        int v20 = (uint8_t *)v19;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLCommonGzipDecompressFile(const char *, const char *)",  "%s\n",  v19);
        if (v20 != buf) {
LABEL_52:
        }
          free(v20);
      }

void sub_100294A4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_100294AAC(const char *a1, double *a2, double *a3, double *a4, off_t *a5)
{
  int v10 = stat(a1, &v15);
  if (v10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    int v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 136315394;
      char v21 = a1;
      __int16 v22 = 1024;
      int v23 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning CLCommonGetFileTimestamps, failed to stat file, %s, ret, %d",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      int v16 = 136315394;
      uint64_t v17 = a1;
      __int16 v18 = 1024;
      int v19 = v10;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  0LL,  "#Warning CLCommonGetFileTimestamps, failed to stat file, %s, ret, %d",  (const char *)&v16,  18);
      int v13 = (uint8_t *)v12;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLCommonGetFileTimestamps(const char *, CFAbsoluteTime *, CFAbsoluteTime *, CFAbsoluteTime *, off_t *)",  "%s\n",  v12);
      if (v13 != buf) {
        free(v13);
      }
    }
  }

  else
  {
    if (a2) {
      *a2 = (double)(v15.st_ctimespec.tv_sec - (uint64_t)kCFAbsoluteTimeIntervalSince1970);
    }
    if (a3) {
      *a3 = (double)(v15.st_mtimespec.tv_sec - (uint64_t)kCFAbsoluteTimeIntervalSince1970);
    }
    if (a4) {
      *a4 = (double)(v15.st_atimespec.tv_sec - (uint64_t)kCFAbsoluteTimeIntervalSince1970);
    }
    if (a5) {
      *a5 = v15.st_size;
    }
  }

  return v10 == 0;
}

uint64_t sub_100294D20(const char *a1, const char *a2)
{
  uint64_t v4 = sub_100293400(a1, a2);
  sub_1001BA1BC(v6);
  return v4;
}

void sub_100294DAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100294DC0(const __CFString *a1, double *a2)
{
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    BOOL v5 = 0LL;
LABEL_3:
    if (strptime(CStringPtr, "%a, %d %b %Y %T %Z", &usedBufLen))
    {
      time_t v6 = mktime(&usedBufLen);
      if (v6 != -1)
      {
        *a2 = (double)v6 - kCFAbsoluteTimeIntervalSince1970;
        uint64_t v7 = 1LL;
        if (!v5) {
          return v7;
        }
        goto LABEL_13;
      }
    }

    goto LABEL_12;
  }

  v12.length = CFStringGetLength(a1);
  v12.location = 0LL;
  CFStringGetBytes(a1, v12, 0x8000100u, 0, 0, 0LL, 0LL, (CFIndex *)&usedBufLen.tm_sec);
  uint64_t v8 = *(void *)&usedBufLen.tm_sec;
  if (!*(void *)&usedBufLen.tm_sec)
  {
    BOOL v5 = 0LL;
    goto LABEL_12;
  }

  CFIndex v9 = ++*(void *)&usedBufLen.tm_sec;
  BOOL v5 = (char *)malloc(v8 + 1);
  if (v5 && CFStringGetCString(a1, v5, v9, 0x8000100u))
  {
    CStringPtr = v5;
    goto LABEL_3;
  }

uint64_t sub_100294EE0(const __CFDictionary *a1, double *a2, double *a3)
{
  uint64_t result = (uint64_t)CFDictionaryGetValue(a1, @"Date");
  if (result)
  {
    uint64_t result = sub_100294DC0((const __CFString *)result, a3);
    if ((_DWORD)result)
    {
      if (*a2 >= 0.0) {
        double v6 = *a2 * 0.5;
      }
      else {
        double v6 = 0.0;
      }
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      uint64_t v7 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        double v8 = *a3;
        double v9 = v6 + *a3;
        double v10 = *a2;
        *(_DWORD *)std::stringbuf::string_type buf = 134218752;
        double v27 = v8;
        __int16 v28 = 2048;
        double v29 = v9;
        __int16 v30 = 2048;
        double v31 = v10;
        __int16 v32 = 2048;
        double v33 = CFAbsoluteTimeGetCurrent() - v9;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "http date string is converted to timestamp %.3f and adjusted to %.3f by %.3fs RTT (%.3fs diff from systime)",  buf,  0x2Au);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182E260);
        }
        uint64_t v11 = qword_101934A78;
        double v12 = *a3;
        double v13 = v6 + *a3;
        double v14 = *a2;
        CFAbsoluteTime v15 = CFAbsoluteTimeGetCurrent() - v13;
        int v18 = 134218752;
        double v19 = v12;
        __int16 v20 = 2048;
        double v21 = v13;
        __int16 v22 = 2048;
        double v23 = v14;
        __int16 v24 = 2048;
        CFAbsoluteTime v25 = v15;
        LODWORD(v17) = 42;
        int v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v11,  2LL,  "http date string is converted to timestamp %.3f and adjusted to %.3f by %.3fs RTT (%.3fs diff from systime)",  COERCE_DOUBLE(&v18),  v17);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLCommonGetTimeFromHttpHeaderAndRtt(CFDictionaryRef, const CFTimeInterval *, CFAbsoluteTime *)",  "%s\n",  v16);
      }

      return 1LL;
    }
  }

  return result;
}

double sub_100295150(uint64_t *a1)
{
  return (double)a1[1] / 1000000000.0 + (double)*a1 - kCFAbsoluteTimeIntervalSince1970;
}

CFStringRef sub_100295180(CFDictionaryRef formatOptions, CFAbsoluteTime a2)
{
  if (formatOptions) {
    return CFDateFormatterCreateStringWithAbsoluteTime(kCFAllocatorDefault, formatOptions, a2);
  }
  else {
    return CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%.3f", *(void *)&a2);
  }
}

CFStringRef sub_1002951C8(CFAbsoluteTime a1)
{
  if (!qword_101993F98)
  {
    stat v2 = CFLocaleCreate(kCFAllocatorDefault, @"en_US");
    if (v2)
    {
      uint64_t v3 = v2;
      qword_101993F98 = (uint64_t)CFDateFormatterCreate( kCFAllocatorDefault,  v2,  kCFDateFormatterLongStyle,  kCFDateFormatterLongStyle);
      CFRelease(v3);
    }
  }

  return sub_100295180((CFDictionaryRef)qword_101993F98, a1);
}

double sub_10029524C(int *a1, _DWORD *a2, double a3)
{
  if (qword_101993F88 != -1) {
    dispatch_once(&qword_101993F88, &stru_10182E220);
  }
  double v6 = a3 + 662342400.0 + (double)dword_101936DE0;
  int v7 = (int)(v6 / 604800.0);
  *a1 = v7;
  double result = (v6 - (double)(604800 * v7)) * 1000.0;
  *a2 = (int)result;
  return result;
}

double sub_1002952F8()
{
  time_t v0 = qword_101993FA0;
  if (!qword_101993FA0)
  {
    memset(&v2, 0, sizeof(v2));
    if (!strptime("Nov 21 2024 21:18:46", "%b %d %Y %H:%M:%S", &v2)) {
      return 0.0;
    }
    time_t v0 = mktime(&v2);
    qword_101993FA0 = v0;
  }

  double result = (double)v0 - kCFAbsoluteTimeIntervalSince1970;
  if (v0 <= 0) {
    return 0.0;
  }
  return result;
}

double sub_100295384(uint64_t a1, uint64_t a2)
{
  if (*(double *)(a2 + 344) <= 0.0)
  {
    double Current = CFAbsoluteTimeGetCurrent();
    double v4 = *(double *)(a1 + 76);
  }

  else
  {
    double Current = sub_101171D4C();
    double v4 = *(double *)(a2 + 344);
  }

  return Current - v4;
}

void sub_1002953C8(double *a1, double *a2, double a3, double a4, double a5, double a6, double a7)
{
  unsigned __int8 v14 = atomic_load((unsigned __int8 *)&qword_101993FD0);
  if ((v14 & 1) == 0 && __cxa_guard_acquire(&qword_101993FD0))
  {
    sub_100D2D9A4((uint64_t)dbl_101993FA8);
    __cxa_guard_release(&qword_101993FD0);
  }

  sub_100D2E3F8(dbl_101993FA8, a1, a2, a3, a4, 0.0, a5, a6, a7);
}

void sub_100295478(_Unwind_Exception *a1)
{
}

double sub_100295490(double a1, double a2, double a3, double a4)
{
  double v4 = atan2(a1 - a3, a4 - a2);
  return fmod(v4 + 4.71238898, 6.28318531) * 57.2957795;
}

BOOL sub_1002954D0(double a1, double a2)
{
  BOOL v2 = a1 <= 90.0;
  if (a1 < -90.0) {
    BOOL v2 = 0;
  }
  if (a2 > 180.0) {
    BOOL v2 = 0;
  }
  return a2 >= -180.0 && v2;
}

BOOL sub_100295514(double a1)
{
  return a1 < 1000000.0 && a1 > -500.0;
}

double sub_100295538(double *a1, double *a2, double a3, double a4, double a5, double a6)
{
  double v8 = a4 * 0.0174532925;
  double v9 = a5 * 0.0174532925;
  double v10 = a6 / 6378137.0;
  __double2 v11 = __sincos_stret(a3 * 0.0174532925);
  __double2 v12 = __sincos_stret(v10);
  __double2 v13 = __sincos_stret(v9);
  double v14 = asin(v13.__cosval * (v11.__cosval * v12.__sinval) + v11.__sinval * v12.__cosval);
  double v15 = sin(v14);
  double v16 = atan2(v11.__cosval * (v13.__sinval * v12.__sinval), v12.__cosval - v11.__sinval * v15);
  *a1 = v14 / 0.0174532925;
  double result = (v8 + v16) / 0.0174532925;
  *a2 = result;
  return result;
}

void sub_100295604(double *a1, double *a2, double *a3, double *a4, double a5, double a6, double a7)
{
  if (a1 && a2 && a3)
  {
    if (a4)
    {
      sub_100295538(&v16, &v17, a5, a6, 0.0, a7);
      double v14 = vabdd_f64(v16, a5);
      sub_100295538(&v17, &v16, a5, a6, 90.0, a7);
      double v15 = vabdd_f64(v16, a6);
      *a1 = a5 - v14;
      *a3 = v14 + a5;
      *a2 = a6 - v15;
      *a4 = v15 + a6;
    }
  }

uint64_t sub_1002956CC(const __CFString *a1, const __CFString *a2, _BYTE *a3)
{
  if (a3) {
    *a3 = 0;
  }
  CFPropertyListRef v4 = CFPreferencesCopyValue(a1, a2, @"mobile", kCFPreferencesAnyHost);
  if (!v4) {
    return 0LL;
  }
  BOOL v5 = v4;
  CFTypeID v6 = CFGetTypeID(v4);
  if (v6 == CFBooleanGetTypeID())
  {
    if (a3) {
      *a3 = 1;
    }
    uint64_t v7 = CFEqual(v5, kCFBooleanTrue);
  }

  else if (v6 == CFNumberGetTypeID() && !CFNumberIsFloatType((CFNumberRef)v5))
  {
    if (a3) {
      *a3 = 1;
    }
    CFNumberGetValue((CFNumberRef)v5, kCFNumberIntType, &valuePtr);
    uint64_t v7 = valuePtr != 0;
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  CFRelease(v5);
  return v7;
}

uint64_t sub_1002957B8(uint64_t result)
{
  byte_1019A0E18 = result;
  return result;
}

void sub_1002957C4()
{
  int v0 = sub_1002956CC(@"LocationServicesEnabledIn8.0", @"com.apple.locationd", &v3);
  if (v3) {
    BOOL v1 = v0 == 0;
  }
  else {
    BOOL v1 = 1;
  }
  int v2 = !v1;
  dword_101936DE4 = v2;
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_101993FD8);
}

void sub_10029582C(_Unwind_Exception *a1)
{
}

uint64_t sub_100295844()
{
  if (qword_101993FE0 != -1) {
    dispatch_once(&qword_101993FE0, &stru_10182E240);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&unk_101993FD8);
  uint64_t v0 = dword_101936DE4;
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_101993FD8);
  return v0;
}

uint64_t sub_1002958AC()
{
  unsigned int v0 = sub_100295844();
  if (byte_1019A0E18) {
    unsigned int v1 = 1;
  }
  else {
    unsigned int v1 = v0;
  }
  if (v0 == 2) {
    return 2LL;
  }
  else {
    return v1;
  }
}

BOOL sub_1002958D8()
{
  int v0 = sub_1002956CC(@"AuthorizationPromptMapDisplayEnabled", @"com.apple.locationd", &v3);
  if (v3) {
    BOOL v1 = v0 == 0;
  }
  else {
    BOOL v1 = 0;
  }
  return !v1;
}

BOOL sub_100295918()
{
  unsigned __int8 v4 = 0;
  int v0 = sub_1002956CC(@"GpsNetworkCtrl", @"com.apple.locationd", &v4);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182E260);
  }
  BOOL v1 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 67109376;
    int v9 = v0;
    __int16 v10 = 1024;
    int v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "GPS_NETWORK: enabled %d found %d", buf, 0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    v5[0] = 67109376;
    v5[1] = v0;
    __int16 v6 = 1024;
    int v7 = v4;
    char v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "GPS_NETWORK: enabled %d found %d",  v5,  14);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLCommonIsGpsNetworkTestMode()", "%s\n", v3);
  }

  return v0 != 0;
}

BOOL sub_100295B04(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    if (a3)
    {
      double v5 = *(double *)(a1 + 88);
      double v6 = *(double *)(a2 + 88);
      BOOL v8 = v5 == -1.0 && v6 == -1.0 || vabdd_f64(v5 + *(double *)(a1 + 76), *(double *)(a2 + 76) + v6) < 2.22044605e-16;
    }

    else
    {
      BOOL v8 = *(double *)(a1 + 76) == *(double *)(a2 + 76);
    }

    if (*(double *)(a1 + 4) != *(double *)(a2 + 4)
      || *(double *)(a1 + 12) != *(double *)(a2 + 12)
      || *(double *)(a1 + 20) != *(double *)(a2 + 20)
      || *(double *)(a1 + 28) != *(double *)(a2 + 28)
      || *(double *)(a1 + 36) != *(double *)(a2 + 36)
      || *(double *)(a1 + 44) != *(double *)(a2 + 44)
      || *(double *)(a1 + 60) != *(double *)(a2 + 60))
    {
      return 0;
    }

    if (*(_DWORD *)(a1 + 96) != *(_DWORD *)(a2 + 96)) {
      BOOL v8 = 0;
    }
    if (!v8) {
      return 0;
    }
    if (*(_DWORD *)(a1 + 124) != *(_DWORD *)(a2 + 124) || *(_DWORD *)(a1 + 132) == *(_DWORD *)(a2 + 132)) {
      return *(_DWORD *)(a1 + 124) == *(_DWORD *)(a2 + 124);
    }
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    int v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v12 = *(void *)(a1 + 4);
      uint64_t v13 = *(void *)(a1 + 12);
      int v14 = *(_DWORD *)(a1 + 132);
      uint64_t v15 = *(void *)(a2 + 4);
      uint64_t v16 = *(void *)(a2 + 12);
      int v17 = *(_DWORD *)(a2 + 132);
      *(_DWORD *)std::stringbuf::string_type buf = 134219264;
      uint64_t v40 = v12;
      __int16 v41 = 2048;
      uint64_t v42 = v13;
      __int16 v43 = 1024;
      int v44 = v14;
      __int16 v45 = 2048;
      uint64_t v46 = v15;
      __int16 v47 = 2048;
      uint64_t v48 = v16;
      __int16 v49 = 1024;
      int v50 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "CLCommonCompareLocationEqualityClient compared two coordinates that were identical other than their reference fr ames: (%lf, %lf, %d) (%lf, %lf, %d)",  buf,  0x36u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      uint64_t v19 = *(void *)(a1 + 4);
      uint64_t v20 = *(void *)(a1 + 12);
      int v21 = *(_DWORD *)(a1 + 132);
      uint64_t v22 = *(void *)(a2 + 4);
      uint64_t v23 = *(void *)(a2 + 12);
      int v24 = *(_DWORD *)(a2 + 132);
      int v27 = 134219264;
      uint64_t v28 = v19;
      __int16 v29 = 2048;
      uint64_t v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      __int16 v33 = 2048;
      uint64_t v34 = v22;
      __int16 v35 = 2048;
      uint64_t v36 = v23;
      __int16 v37 = 1024;
      int v38 = v24;
      LODWORD(v26) = 54;
      CFAbsoluteTime v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "CLCommonCompareLocationEqualityClient compared two coordinates that were identical other than thei r reference frames: (%lf, %lf, %d) (%lf, %lf, %d)",  COERCE_DOUBLE(&v27),  v26);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "Boolean CLCommonCompareLocationEqualityClientWithTimeCheck(const CLClientLocation *, const CLClientLocation *, BOOL)",  "%s\n",  v25);
    }

    if (!*(_DWORD *)(a1 + 132)) {
      return 1;
    }
    return *(_DWORD *)(a2 + 132) == 0;
  }

  else
  {
    return (a1 | a2) == 0;
  }

double sub_100295E8C()
{
  size_t v14 = 4LL;
  if ((byte_101993FE8 & 1) == 0)
  {
    if (sysctlnametomib("kern.monotonicclock", dword_101993FEC, (size_t *)&dword_101936DE8))
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      int v0 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_FAULT,  "Error occurred, no mib to monotonic clock conversion",  buf,  2u);
      }

      double v1 = -1.0;
      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182E260);
        }
        LOWORD(v16[0]) = 0;
        int v2 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Error occurred, no mib to monotonic clock conversion",  v16,  2,  v14);
LABEL_21:
        uint64_t v12 = (uint8_t *)v2;
        sub_10029211C("Generic", 1LL, 0, 0LL, "double CLCommonGetKernelMonotonicClock()", "%s\n", v2);
        if (v12 != buf) {
          free(v12);
        }
        return v1;
      }

      return v1;
    }

    byte_101993FE8 = 1;
  }

  if (!sysctl(dword_101993FEC, dword_101936DE8, &v15, &v14, 0LL, 0LL))
  {
    LODWORD(v3) = v15;
    return (double)v3 + 0.5;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182E260);
  }
  unsigned __int8 v4 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    int v5 = *__error();
    double v6 = __error();
    int v7 = strerror(*v6);
    *(_DWORD *)std::stringbuf::string_type buf = 67240450;
    int v20 = v5;
    __int16 v21 = 2082;
    uint64_t v22 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Error occurred %{public}d %{public}s", buf, 0x12u);
  }

  double v1 = -1.0;
  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    uint64_t v8 = qword_101934A78;
    int v9 = *__error();
    __int16 v10 = __error();
    int v11 = strerror(*v10);
    v16[0] = 67240450;
    v16[1] = v9;
    __int16 v17 = 2082;
    int v18 = v11;
    int v2 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v8,  17LL,  "Error occurred %{public}d %{public}s",  v16,  18,  v14);
    goto LABEL_21;
  }

  return v1;
}

void sub_1002961E4(FILE *a1)
{
  uint32_t v2 = _dyld_image_count();
  uint64_t v3 = v2;
  __int16 v29 = (unint64_t *)calloc(v2, 0x38uLL);
  if (v2 && v29)
  {
    uint32_t v4 = 0;
    do
    {
      image_name = _dyld_get_image_name(v4);
      size_t v6 = (size_t)&image_name[strlen(image_name) + 1];
      do
      {
        int v7 = *(unsigned __int8 *)(v6 - 2);
        --v6;
      }

      while (v7 != 47);
      image_header = _dyld_get_image_header(v4);
      int v9 = image_header;
      __int16 v10 = *(const mach_header **)&image_header->cputype;
      uint32_t ncmds = image_header->ncmds;
      if (ncmds)
      {
        uint64_t v12 = 0LL;
        p_cputype = &image_header[1].cputype;
        do
        {
          if (*p_cputype == 1)
          {
          }

          else if (*p_cputype == 27)
          {
            v30[0] = *(_OWORD *)(p_cputype + 2);
          }

          p_cputype = (cpu_type_t *)((char *)p_cputype + p_cputype[1]);
          --ncmds;
        }

        while (ncmds);
      }

      else
      {
        uint64_t v12 = 0LL;
      }

      uint64_t v14 = 0LL;
      int v15 = v29;
      while (1)
      {
        unint64_t v17 = *v15;
        v15 += 7;
        unint64_t v16 = v17;
        if (v3 == ++v14)
        {
          uint64_t v14 = v3;
          int v19 = v3;
          goto LABEL_24;
        }
      }

      int v19 = v14;
LABEL_24:
      int v20 = (const mach_header **)&v29[7 * v14];
      memmove(v20 + 7, v20, 56LL * (v3 + ~v19));
      *int v20 = v9;
      v20[1] = v12;
      *((_OWORD *)v20 + 1) = v30[0];
      _OWORD v20[4] = (const mach_header *)image_name;
      v20[5] = (const mach_header *)v6;
      v20[6] = v10;
      ++v4;
    }

    while (v4 != (_DWORD)v3);
  }

  fwrite("Binary Images:\n", 0xFuLL, 1uLL, a1);
  if ((_DWORD)v3)
  {
    for (uint64_t i = 0LL; i != v3; ++i)
    {
      uint64_t v22 = (char *)&v29[7 * i];
      __int128 v23 = *((_OWORD *)v22 + 1);
      v30[0] = *(_OWORD *)v22;
      v30[1] = v23;
      __int128 v31 = *((_OWORD *)v22 + 2);
      uint64_t v32 = *((void *)v22 + 6);
      int v24 = "other";
      if ((_DWORD)v32 != 16777228)
      {
        CFAbsoluteTime v25 = "unknown";
        if (HIDWORD(v32) == 9) {
          CFAbsoluteTime v25 = "armv7";
        }
        int v24 = "armv6";
        if (HIDWORD(v32) != 6) {
          int v24 = v25;
        }
      }

      uint64_t v28 = v24;
      if (i) {
        uint64_t v26 = 32LL;
      }
      else {
        uint64_t v26 = 43LL;
      }
      fprintf( a1,  "%16p - %lld %c%s %s <",  *(const void **)&v30[0],  (void)((v30[0] + __PAIR128__(-1LL, 0LL)) >> 64),  v26,  *((const char **)&v31 + 1),  v28);
      for (uint64_t j = 16LL; j != 32; ++j)
        fprintf(a1, "%02X", *((unsigned __int8 *)v30 + j));
      fprintf(a1, "> %s\n", (const char *)v31);
    }
  }

  free(v29);
}

uint64_t sub_1002964C4(unint64_t a1)
{
  return byte_1012E4824[a1 >> 4]
       + byte_1012E4824[(a1 >> 8) & 0xF]
       + byte_1012E4824[(unsigned __int16)a1 >> 12]
       + byte_1012E4824[a1 & 0xF]
       + byte_1012E4824[(a1 >> 16) & 0xF]
       + byte_1012E4824[(a1 >> 20) & 0xF]
       + byte_1012E4824[(a1 >> 24) & 0xF]
       + byte_1012E4824[(unint64_t)a1 >> 28];
}

CFTypeRef sub_100296530(CFStringRef filePath, const __CFString *a2)
{
  if (!filePath) {
    return 0LL;
  }
  CFURLRef v3 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, filePath, kCFURLPOSIXPathStyle, 1u);
  if (!v3) {
    return 0LL;
  }
  CFURLRef v4 = v3;
  Unique = (__CFBundle *)_CFBundleCreateUnique(kCFAllocatorDefault, v3);
  if (Unique)
  {
    size_t v6 = Unique;
    CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(Unique, a2);
    CFTypeRef v8 = ValueForInfoDictionaryKey;
    if (ValueForInfoDictionaryKey) {
      CFRetain(ValueForInfoDictionaryKey);
    }
    CFRelease(v6);
  }

  else
  {
    CFTypeRef v8 = 0LL;
  }

  CFRelease(v4);
  return v8;
}

uint64_t sub_1002965D0()
{
  uint64_t v0 = sub_100CCE8AC();
  return sub_100CCE934(v0);
}

BOOL sub_1002965E4(__CFString *a1)
{
  if (sub_10029661C(a1)) {
    return 1LL;
  }
  uint64_t v3 = sub_100CCE8AC();
  return sub_100CCEA88(v3, a1);
}

BOOL sub_10029661C(void *a1)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_101994028);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_101994028))
  {
    sub_1010DDBC0(&v7, "/System/Library/LocationBundles/LocationPromptUI.bundle");
    sub_1010DDBC0(v8, "/System/Library/LocationBundles/LocationFenceSync.bundle");
    sub_1010DDBC0(v9, "/System/Library/LocationBundles/PLAMonitor.bundle");
    sub_100296844((uint64_t)&qword_101994010, &v7, 3uLL);
    for (uint64_t i = 0LL; i != -9; i -= 3LL)
    {
      if (SHIBYTE(v9[i + 2]) < 0) {
        operator delete((void *)v9[i]);
      }
    }

    __cxa_atexit((void (*)(void *))sub_1002968E0, &qword_101994010, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101994028);
  }

  uint64_t v3 = (unsigned __int8 *)qword_101994010;
  CFURLRef v4 = (unsigned __int8 *)qword_101994018;
  *(void *)&__int128 v7 = [a1 UTF8String];
  return sub_1002978A4(v3, v4, (const char **)&v7) != (unsigned __int8 *)qword_101994018;
}

void sub_100296780(_Unwind_Exception *a1)
{
  uint64_t v3 = 0LL;
  while (1)
  {
    v3 -= 24LL;
    if (v3 == -72)
    {
      __cxa_guard_abort(&qword_101994028);
      _Unwind_Resume(a1);
    }
  }

BOOL sub_1002967F4(const __CFString *a1)
{
  uint64_t v2 = sub_100CCE8AC();
  return sub_100CCEBB0(v2, a1);
}

BOOL sub_10029681C(const __CFString *a1)
{
  uint64_t v2 = sub_100CCE8AC();
  return sub_100CCEC64(v2, a1);
}

uint64_t sub_100296844(uint64_t a1, __int128 *a2, unint64_t a3)
{
  *(void *)(a1 + 16) = 0LL;
  uint64_t v4 = a1 + 16;
  *(void *)a1 = 0LL;
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  if (a3)
  {
    sub_100006E1C((void *)a1, a3);
    *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = sub_100036E0C(v4, a2, (__int128 *)((char *)a2 + 24 * a3), *(char **)(a1 + 8));
  }

  return a1;
}

void sub_1002968C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + std::iostream::~basic_iostream(v2, v3 + 8) = v10;
  sub_1000129D4(&a9);
  _Unwind_Resume(a1);
}

void **sub_1002968E0(void **a1)
{
  uint64_t v3 = a1;
  sub_1000129D4(&v3);
  return a1;
}

BOOL sub_100296914(const __CFString *a1)
{
  uint64_t v2 = sub_100CCE8AC();
  return sub_100CCED18(v2, a1);
}

BOOL sub_10029693C(const __CFString *a1)
{
  uint64_t v2 = sub_100CCE8AC();
  return sub_100CCEDCC(v2, a1);
}

void sub_100296964(const char *a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182E260);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 136315138;
    uint64_t v22 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "TILE: delete file, %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    v20.st_dev = 136315138;
    *(void *)&v20.st_mode = a1;
    __int128 v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: delete file, %s",  (const char *)&v20);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCommonDeleteFileIfExists(const char *)", "%s\n", v7);
  }

  memset(&v20, 0, sizeof(v20));
  int v3 = stat(a1, &v20);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182E260);
  }
  uint64_t v4 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 136316162;
    uint64_t v22 = a1;
    __int16 v23 = 1024;
    int v24 = v3;
    __int16 v25 = 2048;
    __darwin_time_t tv_sec = v20.st_mtimespec.tv_sec;
    __int16 v27 = 2048;
    __darwin_time_t v28 = v20.st_ctimespec.tv_sec;
    __int16 v29 = 2048;
    st_uint64_t size = v20.st_size;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "TILE: stat, %s, ret, %d, mtime, %lu, ctime, %lu, size, %lld",  buf,  0x30u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    int v10 = 136316162;
    int v11 = a1;
    __int16 v12 = 1024;
    int v13 = v3;
    __int16 v14 = 2048;
    __darwin_time_t v15 = v20.st_mtimespec.tv_sec;
    __int16 v16 = 2048;
    __darwin_time_t v17 = v20.st_ctimespec.tv_sec;
    __int16 v18 = 2048;
    off_t v19 = v20.st_size;
    CFTypeRef v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: stat, %s, ret, %d, mtime, %lu, ctime, %lu, size, %lld",  (const char *)&v10,  48);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCommonDeleteFileIfExists(const char *)", "%s\n", v8);
  }

  if (!v3)
  {
    int v5 = unlink(a1);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182E260);
    }
    size_t v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 136315394;
      uint64_t v22 = a1;
      __int16 v23 = 1024;
      int v24 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "TILE: unlink, %s, ret, %d", buf, 0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182E260);
      }
      int v10 = 136315394;
      int v11 = a1;
      __int16 v12 = 1024;
      int v13 = v5;
      uint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: unlink, %s, ret, %d",  (const char *)&v10,  18);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLCommonDeleteFileIfExists(const char *)", "%s\n", v9);
    }
  }

BOOL sub_100296E50(const char *a1, uint64_t a2)
{
  if (!a1)
  {
    if (qword_101934A40 != -1) {
      dispatch_once(&qword_101934A40, &stru_10182E280);
    }
    __int128 v7 = (os_log_s *)qword_101934A48;
    if (os_log_type_enabled((os_log_t)qword_101934A48, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "CLCommonSetFileProtectionClass,sFilename==nullptr",  buf,  2u);
    }

    BOOL v8 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (!v8) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A40 != -1) {
      dispatch_once(&qword_101934A40, &stru_10182E280);
    }
    *(_WORD *)int v24 = 0;
    uint64_t v10 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A48,  17LL,  "CLCommonSetFileProtectionClass,sFilename==nullptr",  v24,  2,  *(void *)v24);
LABEL_21:
    __int16 v16 = (uint8_t *)v10;
    sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLCommonSetFileProtectionClass(const char *, int)", "%s\n");
LABEL_22:
    if (v16 != buf) {
      free(v16);
    }
    return 0LL;
  }

  int v4 = open(a1, 2);
  if (v4 < 0)
  {
    if (qword_101934A40 != -1) {
      dispatch_once(&qword_101934A40, &stru_10182E280);
    }
    int v11 = (os_log_s *)qword_101934A48;
    if (os_log_type_enabled((os_log_t)qword_101934A48, OS_LOG_TYPE_ERROR))
    {
      int v12 = *__error();
      *(_DWORD *)std::stringbuf::string_type buf = 67240192;
      LODWORD(v34) = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "CLCommonSetFileProtectionClass,open,errno,%{public}d",  buf,  8u);
    }

    BOOL v13 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (!v13) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A40 != -1) {
      dispatch_once(&qword_101934A40, &stru_10182E280);
    }
    uint64_t v14 = qword_101934A48;
    int v15 = *__error();
    *(_DWORD *)int v24 = 67240192;
    *(_DWORD *)&v24[4] = v15;
    uint64_t v10 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  16LL,  "CLCommonSetFileProtectionClass,open,errno,%{public}d",  v24,  8,  *(void *)v24);
    goto LABEL_21;
  }

  int v5 = v4;
  int v6 = fcntl(v4, 63);
  if (v6 == (_DWORD)a2)
  {
    close(v5);
LABEL_34:
    if (qword_101934A40 != -1) {
      dispatch_once(&qword_101934A40, &stru_10182E280);
    }
    uint64_t v22 = (os_log_s *)qword_101934A48;
    if (os_log_type_enabled((os_log_t)qword_101934A48, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 136315906;
      uint64_t v34 = a1;
      __int16 v35 = 1026;
      int v36 = v6;
      __int16 v37 = 1026;
      int v38 = a2;
      __int16 v39 = 1026;
      int v40 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "CLCommonSetFileProtectionClass,%s,oldPc,%{public}d,newPc,%{public}d,ret,%{public}d",  buf,  0x1Eu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A40 != -1) {
        dispatch_once(&qword_101934A40, &stru_10182E280);
      }
      *(_DWORD *)int v24 = 136315906;
      *(void *)&v24[4] = a1;
      __int16 v25 = 1026;
      int v26 = v6;
      __int16 v27 = 1026;
      int v28 = a2;
      __int16 v29 = 1026;
      int v30 = 0;
      __int16 v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A48,  2LL,  "CLCommonSetFileProtectionClass,%s,oldPc,%{public}d,newPc,%{public}d,ret,%{public}d",  v24,  30);
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLCommonSetFileProtectionClass(const char *, int)", "%s\n", v23);
    }

    return 1LL;
  }

  int v17 = fcntl(v5, 64, a2);
  close(v5);
  if (!v17) {
    goto LABEL_34;
  }
  if (qword_101934A40 != -1) {
    dispatch_once(&qword_101934A40, &stru_10182E280);
  }
  __int16 v18 = (os_log_s *)qword_101934A48;
  if (os_log_type_enabled((os_log_t)qword_101934A48, OS_LOG_TYPE_INFO))
  {
    int v19 = *__error();
    *(_DWORD *)std::stringbuf::string_type buf = 136316162;
    uint64_t v34 = a1;
    __int16 v35 = 1026;
    int v36 = v6;
    __int16 v37 = 1026;
    int v38 = a2;
    __int16 v39 = 1026;
    int v40 = v17;
    __int16 v41 = 1026;
    int v42 = v19;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "#Warning,CLCommonSetFileProtectionClass,%s,oldPc,%{public}d,newPc,%{public}d,ret,%{public}d,errno,%{public}d",  buf,  0x24u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A40 != -1) {
      dispatch_once(&qword_101934A40, &stru_10182E280);
    }
    uint64_t v20 = qword_101934A48;
    int v21 = *__error();
    *(_DWORD *)int v24 = 136316162;
    *(void *)&v24[4] = a1;
    __int16 v25 = 1026;
    int v26 = v6;
    __int16 v27 = 1026;
    int v28 = a2;
    __int16 v29 = 1026;
    int v30 = v17;
    __int16 v31 = 1026;
    int v32 = v21;
    __int16 v16 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  1LL,  "#Warning,CLCommonSetFileProtectionClass,%s,oldPc,%{public}d,newPc,%{public}d,ret,%{public}d,errno,%{public}d",  v24,  36);
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLCommonSetFileProtectionClass(const char *, int)", "%s\n");
    goto LABEL_22;
  }

  return result;
}

BOOL sub_100297480(void *a1)
{
  return uuid_parse((const char *)[a1 UTF8String], uu) == 0;
}

double sub_1002974D8(int a1, int a2, int a3)
{
  if (a3 >= a1) {
    int v3 = a1;
  }
  else {
    int v3 = a3;
  }
  double v4 = pow((double)a2, (double)(v3 & ~(v3 >> 31)));
  return v4 + (double)rand() / 2147483650.0 * v4;
}

const char *sub_100297524(unsigned int a1)
{
  if (a1 > 8) {
    return "UNKNOWN";
  }
  else {
    return off_10182E2A0[a1];
  }
}

const char *sub_100297548(unsigned int a1)
{
  if (a1 > 4) {
    return "UNKNOWN";
  }
  else {
    return off_10182E2E8[a1];
  }
}

double sub_10029756C(double a1)
{
  if (a1 < 0.0) {
    return 180.0;
  }
  double v1 = 1.0;
  if (a1 <= 15.0)
  {
    double v1 = 4.0;
    if (a1 <= 10.0)
    {
      double v1 = 10.0;
      if (a1 <= 8.0)
      {
        double v1 = 15.0;
        if (a1 <= 5.0)
        {
          if (a1 <= 3.0)
          {
            double v1 = 25.0;
            if (a1 <= 2.5) {
              return dbl_1012E4840[a1 > 1.0];
            }
          }

          else
          {
            return 19.9;
          }
        }
      }
    }
  }

  return v1;
}

uint64_t sub_100297608(int a1, int a2, char a3, char a4, unsigned int a5, int a6, int a7)
{
  if (a7)
  {
    if ((a3 & 1) != 0 || (a4 & 1) != 0 || a5)
    {
      if (a2 | a1) {
        return 1LL;
      }
      else {
        return a5;
      }
    }

    else
    {
      return 0LL;
    }
  }

  else
  {
    if (a2 | a1) {
      a6 = 1;
    }
    return a6 | a5;
  }

uint64_t sub_100297644(int a1)
{
  return a1 ^ 1u;
}

uint64_t sub_10029764C(int a1, int a2, int a3, int a4, uint64_t a5, int a6, int a7)
{
  uint64_t v7 = 0LL;
  switch(a1)
  {
    case 0:
      uint64_t v7 = 64639LL;
      if (a6) {
        uint64_t v7 = 195711LL;
      }
      if (a7) {
        v7 |= 0x40000uLL;
      }
      break;
    case 1:
    case 8:
      BOOL v9 = (a4 != 3 || a2 != 1) && a2 <= 1;
      uint64_t v10 = 0x4000LL;
      if (!v9) {
        uint64_t v10 = 52351LL;
      }
      if (a7) {
        v10 |= 0x40000uLL;
      }
      uint64_t v7 = v10 | 0x1000;
      break;
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
      break;
    case 5:
      sub_101232700();
    default:
      uint64_t v7 = 0LL;
      break;
  }

  if (a3 == 2) {
    return v7 & 0x7AFF8;
  }
  else {
    return v7;
  }
}

uint64_t sub_100297738(void *a1, int a2, int a3)
{
  unsigned int v6 = objc_msgSend( objc_msgSend(a1, "objectForKeyedSubscript:", @"LocationRestricted"),  "BOOLValue");
  unsigned int v7 = objc_msgSend( objc_msgSend(a1, "objectForKey:", @"TemporaryAuthorization"),  "unsignedIntValue");
  unsigned int v8 = objc_msgSend( objc_msgSend(a1, "objectForKey:", @"CorrectiveCompensationEnabled"),  "unsignedIntValue");
  if ([a1 objectForKey:@"AuthorizationUpgradeAvailable"]) {
    unsigned int v9 = objc_msgSend( objc_msgSend(a1, "objectForKey:", @"AuthorizationUpgradeAvailable"),  "BOOLValue") ^ 1;
  }
  else {
    LOBYTE(v9) = 0;
  }
  uint64_t v10 = 3LL;
  if (a3) {
    uint64_t v10 = 0LL;
  }
  uint64_t v11 = v10 | (a2 == 2);
  if (v6) {
    v11 |= 4uLL;
  }
  BOOL v12 = v8 == 2 && (v7 & 2) == 0LL;
  uint64_t v13 = v11 | 0x40;
  if (!v12) {
    uint64_t v13 = v11;
  }
  else {
    uint64_t v14 = v13;
  }
  return v14 | (v7 << 8) & 0x800LL;
}

void sub_10029784C(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_100297878(id a1)
{
  qword_101934A48 = (uint64_t)os_log_create("com.apple.locationd.Utility", "Utility");
}

unsigned __int8 *sub_1002978A4(unsigned __int8 *a1, unsigned __int8 *a2, const char **a3)
{
  int v3 = a1;
  if (a1 != a2)
  {
    int v5 = *a3;
    size_t v6 = strlen(*a3);
    while (1)
    {
      if ((char)v3[23] < 0)
      {
        if (v6 == *((void *)v3 + 1))
        {
          if (v6 == -1LL) {
LABEL_14:
          }
            sub_1001040F8();
          unsigned int v7 = *(unsigned __int8 **)v3;
LABEL_10:
          if (!memcmp(v7, v5, v6)) {
            return v3;
          }
        }
      }

      else if (v6 == v3[23])
      {
        unsigned int v7 = v3;
        if (v6 == -1LL) {
          goto LABEL_14;
        }
        goto LABEL_10;
      }

      v3 += 24;
      if (v3 == a2) {
        return a2;
      }
    }
  }

  return v3;
}

void sub_100297954(unint64_t *a1, size_t a2)
{
  int v5 = (char *)a1[1];
  double v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }

    a1[1] = (unint64_t)v5;
  }

  else
  {
    unint64_t v6 = *a1;
    unsigned int v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0LL;
    }
    BOOL v12 = &v7[v11];
    uint64_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }

    else
    {
      uint64_t v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }

      while (v5 != (char *)v6);
      int v5 = (char *)*a1;
    }

    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5) {
      operator delete(v5);
    }
  }

double sub_100297A7C@<D0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(void *)(a2 + 24) = 3LL;
  *(_DWORD *)(a2 + sub_10000AE14(v13 - 32) = 3;
  float v3 = sub_100E02DAC(*(_DWORD *)(a1 + 152));
  *(float *)(a2 + 2sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v3;
  *(_DWORD *)(a2 + 24) = 3;
  *(float *)(a2 + 2std::iostream::~basic_iostream(v2, v3 + 8) = v3;
  *(void *)&double result = 3LL;
  *(void *)(a2 + sub_10000AE14(v13 - 32) = 3LL;
  return result;
}

void *sub_100297AC8(void *a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_10182E370;
  a1[9] = off_10182E420;
  sub_100B14CF0(a1 + 53, 0LL, 0LL);
  (*(void (**)(void *))(*a1 + 112LL))(a1);
  return a1;
}

void sub_100297B68( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100297B94(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0u;
  BOOL v12 = (void *)(a1 + 8);
  *(void *)a1 = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 8));
  *BOOL v12 = &off_10182BDA0;
  *(void *)a1 = off_10182E660;
  *(void *)(a1 + 72) = off_10182E708;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_10182E660;
  *(void *)(a1 + 72) = off_10182E708;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 20std::iostream::~basic_iostream(v2, v3 + 8) = 0u;
  *(_DWORD *)(a1 + 24sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
  sub_1010DDBC0((void *)(a1 + 248), "");
  sub_1010DDBC0((void *)(a1 + 272), "");
  sub_1010DDBC0((void *)(a1 + 296), "");
  sub_1010DDBC0((void *)(a1 + 320), "");
  *(_DWORD *)(a1 + 344) = 12000;
  *(void *)(a1 + 352) = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 360));
  *(void *)(a1 + 36sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = &off_10182BDA0;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v28 = a1 + 112;
  (*(void (**)(void))(v13 + 16))();
  __int16 v30 = 256;
  if (a3)
  {
    *(void *)(a1 + 2sub_10000AE14(v13 - 32) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v28 + 24LL))(v28);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a4;
    uint64_t v27 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  char v15 = (int *)(a1 + 344);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 344));
  int v17 = v33;
  if (v33)
  {
    p_shared_owners = (unint64_t *)&v33->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    *char v15 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10182E748);
  }
  uint64_t v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v15;
    *(_DWORD *)std::stringbuf::string_type buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182E748);
    }
    int v24 = *v15;
    v31[0] = 67109120;
    v31[1] = v24;
    __int16 v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v31);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<ConfigSummary>::CLActivityRecorderDb(const char *, BOOL, float, const std::string &, const CL SqliteDatabase::SqlitePropertyPersistence) [T = ConfigSummary, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v25);
  }

  int v22 = HIBYTE(v30);
  *(void *)(a1 + 2sub_10000AE14(v13 - 32) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v30)
    {
      pthread_mutex_unlock(v29);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_100297FA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[44] = off_10182BD58;
  sub_1001B9C98(v28);
  sub_100298410(v27);
  sub_10029C2DC(v26);
  sub_100D8A88C(a12);
  *int v24 = off_10182BD58;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_10029809C()
{
}

uint64_t sub_1002980A4(uint64_t a1)
{
  *(void *)(a1 + 72) = off_10182E708;
  uint64_t v2 = a1 + 72;
  *(void *)a1 = off_10182E660;
  *(void *)(a1 + 352) = off_10182BD58;
  sub_1001B9C98((void *)(a1 + 360));
  sub_10029C2DC((void *)(a1 + 176));
  sub_100D8A88C(v2);
  *(void *)a1 = off_10182BD58;
  sub_1001B9C98((void *)(a1 + 8));
  return a1;
}

uint64_t sub_100298168(uint64_t a1)
{
  return sub_1002980A4(a1 - 72);
}

void sub_100298170(uint64_t a1)
{
  double v1 = (void *)sub_1002980A4(a1);
  operator delete(v1);
}

void sub_100298184(uint64_t a1)
{
  double v1 = (void *)sub_1002980A4(a1 - 72);
  operator delete(v1);
}

void sub_10029819C(uint64_t a1, uint64_t *a2)
{
  if (sub_100D8A92C(a1 + 72))
  {
    uint64_t v5 = *a2;
    uint64_t v4 = a2[1];
    if (v4 != *a2)
    {
      do
      {
        v4 -= 120LL;
        sub_10029C410((uint64_t)(a2 + 2), v4);
      }

      while (v4 != v5);
    }

    a2[1] = v5;
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * from ActiveConfig", &v9);
    uint64_t v6 = v9;
    uint64_t v19 = v9;
    sub_1003C0454(*(void *)(a1 + 80));
    __int128 v9 = 0uLL;
    int v10 = 0;
    sub_1010DDBC0(&v11, "");
    sub_1010DDBC0(&v13, "");
    sub_1010DDBC0(&v15, "");
    sub_1010DDBC0(&__p, "");
    while (!sub_1002983B4(&v19, (uint64_t)&v9))
    {
      unint64_t v7 = a2[1];
      if (v7 >= a2[2])
      {
        uint64_t v8 = sub_10029C474(a2, &v9);
      }

      else
      {
        sub_10029C578(a2[1], &v9);
        uint64_t v8 = v7 + 120;
        a2[1] = v7 + 120;
      }

      a2[1] = v8;
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    if (v18 < 0) {
      operator delete(__p);
    }
    if (v16 < 0) {
      operator delete(v15);
    }
    if (v14 < 0) {
      operator delete(v13);
    }
    if (v12 < 0) {
      operator delete(v11);
    }
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

void sub_100298328( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002983B4(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  sub_1002986EC(a1, a2);
  return 0LL;
}

uint64_t sub_100298410(uint64_t a1)
{
  return a1;
}

uint64_t sub_100298470(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  v13[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v14 = 256;
  if ((sub_100D8A92C(v6) & 1) != 0)
  {
    sub_100B14CF8((uint64_t *)(a1 + 424), v13);
    if (v13[0])
    {
      sub_1002983B4(v13, a2);
      uint64_t v7 = 100LL;
    }

    else
    {
      if (qword_101934730 != -1) {
        dispatch_once(&qword_101934730, &stru_10182E4B0);
      }
      uint64_t v8 = (os_log_s *)qword_101934738;
      if (os_log_type_enabled((os_log_t)qword_101934738, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "ActiveConfigRecorderDb: failed to prepare queryForBestFit #InvalidPreparedSQLStatement",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934730 != -1) {
          dispatch_once(&qword_101934730, &stru_10182E4B0);
        }
        v12[0] = 0;
        unint64_t v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934738,  17LL,  "ActiveConfigRecorderDb: failed to prepare queryForBestFit #InvalidPreparedSQLStatement",  v12,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLActiveConfigRecorderDb::queryForBestFitConfig(ConfigSummary &) const",  "%s\n",  v11);
      }

      uint64_t v7 = 112LL;
    }

    uint64_t v9 = v13[0];
    v13[0] = 0LL;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    }
  }

  else
  {
    uint64_t v7 = 109LL;
  }

  (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
  return v7;
}

void sub_100298694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  if (a6) {
    (*(void (**)(uint64_t))(*(void *)a6 + 8LL))(a6);
  }
  sub_1011C52D0((uint64_t)va);
  _Unwind_Resume(a1);
}

std::string *sub_1002986E0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return sub_1002986EC(a2, a3);
}

std::string *sub_1002986EC(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)a2 = sqlite3_column_int(v4, 0);
  uint64_t v5 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + std::iostream::~basic_iostream(v2, v3 + 8) = sqlite3_column_double(v5, 1);
  uint64_t v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)(a2 + 16) = sqlite3_column_int(v6, 2);
  uint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  uint64_t v8 = sqlite3_column_text(v7, 3);
  std::string::assign((std::string *)(a2 + 24), (const std::string::value_type *)v8);
  uint64_t v9 = (sqlite3_stmt *)sub_100019240(*a1);
  int v10 = sqlite3_column_text(v9, 4);
  std::string::assign((std::string *)(a2 + 48), (const std::string::value_type *)v10);
  unint64_t v11 = (sqlite3_stmt *)sub_100019240(*a1);
  char v12 = sqlite3_column_text(v11, 5);
  std::string::assign((std::string *)(a2 + 72), (const std::string::value_type *)v12);
  uint64_t v13 = (sqlite3_stmt *)sub_100019240(*a1);
  __int16 v14 = sqlite3_column_text(v13, 6);
  return std::string::assign((std::string *)(a2 + 96), (const std::string::value_type *)v14);
}

uint64_t sub_1002987B8(uint64_t *a1)
{
  uint64_t result = sub_1003C1048(a1[10]);
  if ((_DWORD)result)
  {
    sub_100298898((uint64_t)a1);
    sub_1003B59A0( a1[10],  "ActiveConfig",  (const char **)&off_10182E4D0,  (const std::string::value_type **)&off_101936DF0,  0);
    sub_1003C0D54(a1[10], "CREATE UNIQUE INDEX IF NOT EXISTS ix_ActiveConfig_studyId ON ActiveConfig(studyId)", &v7);
    uint64_t v3 = v7;
    uint64_t v4 = a1[10];
    uint64_t v5 = (sqlite3_stmt *)sub_100019240(v7);
    sub_1003BB2BC(v4, v5);
    uint64_t result = sub_1003BF158(a1[10], "SELECT * FROM ActiveConfig ORDER BY priority DESC, startTime DESC LIMIT 1");
    a1[53] = result;
    a1[54] = v6;
    if (v3) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return result;
}

void sub_100298874(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100298898(uint64_t a1)
{
  uint64_t result = sub_1003B747C(*(void *)(a1 + 80), "ActiveConfig");
  if ((_DWORD)result)
  {
    uint64_t v3 = 0LL;
    int v4 = 0;
    uint64_t v8 = "startTime";
    do
    {
      int v38 = v8;
      int v39 = 5;
      __int16 v40 = 0;
      char v41 = 0;
      char v42 = 0;
      if ((sub_1003BC790(*(void *)(a1 + 80), "ActiveConfig", v8, (uint64_t)&v38) & 1) == 0)
      {
        sub_1003C0454(*(void *)(a1 + 80));
        sub_10000CE18((uint64_t)v34);
        uint64_t v9 = sub_10000CF44(&v35, (uint64_t)"ALTER TABLE ActiveConfig ADD COLUMN ", 36LL);
        size_t v10 = strlen(v8);
        unint64_t v11 = sub_10000CF44(v9, (uint64_t)v8, v10);
        char v12 = sub_10000CF44(v11, (uint64_t)" ", 1LL);
        uint64_t v13 = (const char *)sub_1003BCC40((int)(&off_10182E4D0)[v3 + 7]);
        size_t v14 = strlen(v13);
        char v15 = sub_10000CF44(v12, (uint64_t)v13, v14);
        sub_10000CF44(v15, (uint64_t)";", 1LL);
        uint64_t v16 = *(void *)(a1 + 80);
        std::stringbuf::str(&v31, &v36);
        if ((v31.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v17 = &v31;
        }
        else {
          int v17 = (std::stringbuf::string_type *)v31.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v16, (char *)v17, &v29);
        uint64_t v18 = v29.__r_.__value_.__r.__words[0];
        v29.__r_.__value_.__r.__words[0] = 0LL;
        uint64_t v19 = *(void *)(a1 + 80);
        uint64_t v20 = (sqlite3_stmt *)sub_100019240(v18);
        sub_1003BB2BC(v19, v20);
        sub_10000CE18((uint64_t)&v31);
        int v21 = sub_10000CF44(&v31.__r_.__value_.__l.__cap_, (uint64_t)"UPDATE ActiveConfig SET ", 24LL);
        size_t v22 = strlen(v8);
        __int16 v23 = sub_10000CF44(v21, (uint64_t)v8, v22);
        sub_10000CF44(v23, (uint64_t)" = 0;", 5LL);
        uint64_t v24 = *(void *)(a1 + 80);
        std::stringbuf::str(&v29, &v32);
        if ((v29.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int16 v25 = &v29;
        }
        else {
          __int16 v25 = (std::stringbuf::string_type *)v29.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v24, (char *)v25, &v30);
        uint64_t v26 = v30;
        uint64_t v30 = 0LL;
        uint64_t v27 = *(void *)(a1 + 80);
        uint64_t v28 = (sqlite3_stmt *)sub_100019240(v26);
        sub_1003BB2BC(v27, v28);
        sub_1003C05BC(*(void *)(a1 + 80));
        if (v26) {
          (*(void (**)(uint64_t))(*(void *)v26 + 8LL))(v26);
        }
        v31.__r_.__value_.__r.__words[0] = v5;
        *(std::string::size_type *)((char *)v31.__r_.__value_.__r.__words + *(void *)(v5 - 24)) = v7;
        v31.__r_.__value_.__l.__cap_ = v6;
        std::streambuf::~streambuf(&v32);
        std::ios::~ios(&v33);
        if (v18) {
          (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
        }
        v34[0] = v5;
        *(void *)((char *)v34 + *(void *)(v5 - 24)) = v7;
        std::string::size_type v35 = v6;
        std::streambuf::~streambuf(&v36);
        std::ios::~ios(&v37);
        int v4 = 1;
      }

      uint64_t v8 = (&off_10182E4D0)[v3 + 12];
      v3 += 6LL;
    }

    while (v3 != 36);
    uint64_t result = sub_100298EFC( a1,  "ActiveConfig",  (const char **)&off_10182E4D0,  (const std::string::value_type **)&off_101936DF0);
  }

  return result;
}

void sub_100298C3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a21);
  if (v59) {
    (*(void (**)(uint64_t))(*(void *)v59 + 8LL))(v59);
  }
  sub_1011F8850((uint64_t)&a59);
  _Unwind_Resume(a1);
}

uint64_t sub_100298CD4(uint64_t a1)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM ActiveConfig", &v8);
    uint64_t v3 = v8;
    uint64_t v4 = *(void *)(a1 + 80);
    std::string::size_type v5 = (sqlite3_stmt *)sub_100019240(v8);
    sub_1003BB2BC(v4, v5);
    uint64_t v6 = *(void *)(a1 + 80);
    else {
      uint64_t v7 = *(void *)(v6 + 88);
    }
    uint64_t result = sub_1003C1EC0(v6, v7);
    if (v3) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return result;
}

void sub_100298D68(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100298D88(uint64_t a1)
{
  return sub_100298CD4(a1 - 72);
}

uint64_t sub_100298D90(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54( *(void *)(a1 + 80),  "REPLACE INTO ActiveConfig (startTime, priority, configId, bundleIdentifier, studyId, parameterDictionary) VALUES(?, ?, ?, ?, ?, ?)",  &v21);
    uint64_t v5 = v21;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v21);
    uint64_t result = sub_1003B7480(v6, 1, *(double *)(a2 + 8));
    if ((_DWORD)result)
    {
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v5);
      uint64_t result = sub_1003C28BC(v7, 2, *(_DWORD *)(a2 + 16));
      if ((_DWORD)result)
      {
        uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
        uint64_t v9 = *(char *)(a2 + 47) >= 0 ? (char *)(a2 + 24) : *(char **)(a2 + 24);
        uint64_t result = sub_1003BC1F0(v8, 3, v9);
        if ((_DWORD)result)
        {
          size_t v10 = (sqlite3_stmt *)sub_100019240(v5);
          unint64_t v11 = *(char *)(a2 + 71) >= 0 ? (char *)(a2 + 48) : *(char **)(a2 + 48);
          uint64_t result = sub_1003BC1F0(v10, 4, v11);
          if ((_DWORD)result)
          {
            char v12 = (sqlite3_stmt *)sub_100019240(v5);
            uint64_t v13 = *(char *)(a2 + 95) >= 0 ? (char *)(a2 + 72) : *(char **)(a2 + 72);
            uint64_t result = sub_1003BC1F0(v12, 5, v13);
            if ((_DWORD)result)
            {
              size_t v14 = (sqlite3_stmt *)sub_100019240(v5);
              int v17 = *(char **)(a2 + 96);
              uint64_t v16 = (char *)(a2 + 96);
              char v15 = v17;
              if (v16[23] >= 0) {
                uint64_t v18 = v16;
              }
              else {
                uint64_t v18 = v15;
              }
              uint64_t result = sub_1003BC1F0(v14, 6, v18);
              if ((_DWORD)result)
              {
                uint64_t v19 = *(void *)(a1 + 80);
                uint64_t v20 = (sqlite3_stmt *)sub_100019240(v5);
                uint64_t result = sub_1003BB2BC(v19, v20);
              }
            }
          }
        }
      }
    }

    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100298EDC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100298EFC(uint64_t a1, char *a2, const char **a3, const std::string::value_type **a4)
{
  if (!sub_1003B79FC(*(void *)(a1 + 80), a2))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182E748);
    }
    uint64_t v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s needs autoincrement migration",  (uint8_t *)buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182E748);
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      __int16 v131 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s needs autoincrement migration",  &__p,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<ConfigSummary>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = ConfigSummary, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  (const char *)v131);
      if (v131 != buf) {
        free(v131);
      }
    }

    memset(&__p, 0, sizeof(__p));
    sub_1010DDBC0(buf, a2);
    uint64_t v9 = std::string::append(buf, "AutoIncr");
    __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t cap = v9->__r_.__value_.__l.__cap_;
    *(_OWORD *)BOOL v140 = v10;
    v9->__r_.__value_.__l.__size_ = 0LL;
    v9->__r_.__value_.__l.__cap_ = 0LL;
    v9->__r_.__value_.__r.__words[0] = 0LL;
    sub_1010DDBC0(buf, a2);
    unint64_t v11 = std::string::append(buf, "Index");
    __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    int64_t v139 = v11->__r_.__value_.__l.__cap_;
    *(_OWORD *)uint64_t v138 = v12;
    v11->__r_.__value_.__l.__size_ = 0LL;
    v11->__r_.__value_.__l.__cap_ = 0LL;
    v11->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003C0454(*(void *)(a1 + 80));
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    size_t v14 = buf;
    sub_1000392EC((uint64_t)buf, size + 21);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      size_t v14 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (size)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t p_p = &__p;
      }
      else {
        uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v14, p_p, size);
    }

    strcpy((char *)v14 + size, "DROP TABLE IF EXISTS ");
    if (cap >= 0) {
      uint64_t v16 = v140;
    }
    else {
      uint64_t v16 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v17 = HIBYTE(cap);
    }
    else {
      std::string::size_type v17 = (std::string::size_type)v140[1];
    }
    uint64_t v18 = std::string::append(buf, (const std::string::value_type *)v16, v17);
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v20 = v18->__r_.__value_.__s.__size_;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v19;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v20;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v20 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v19 = __p.__r_.__value_.__r.__words[0];
    }

    if (v20 >= 0) {
      uint64_t v21 = &__p;
    }
    else {
      uint64_t v21 = (std::string *)v19;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v21, buf);
    size_t v22 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v23 = sqlite3_step(v22);
    std::string::size_type v24 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v24) {
      (*(void (**)(std::string::size_type))(*(void *)v24 + 8LL))(v24);
    }
    if (v23 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v25 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v25 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v26 = &v145;
    sub_1000392EC((uint64_t)&v145, v25 + 13);
    if ((v145.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v26 = (std::string *)v145.__r_.__value_.__r.__words[0];
    }
    if (v25)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v27 = &__p;
      }
      else {
        uint64_t v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v26, v27, v25);
    }

    strcpy((char *)v26 + v25, "CREATE TABLE ");
    if (cap >= 0) {
      uint64_t v28 = v140;
    }
    else {
      uint64_t v28 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v29 = HIBYTE(cap);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)v140[1];
    }
    uint64_t v30 = std::string::append(&v145, (const std::string::value_type *)v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v137.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    std::stringbuf v32 = std::string::append(&v137, " (");
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003BE030(a3, 1, 1, (uint64_t)&v136);
    if ((v136.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v34 = &v136;
    }
    else {
      uint64_t v34 = (std::string *)v136.__r_.__value_.__r.__words[0];
    }
    if ((v136.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v35 = v136.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v35 = v136.__r_.__value_.__l.__size_;
    }
    std::stringbuf v36 = std::string::append(&v146, (const std::string::value_type *)v34, v35);
    __int128 v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v36->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0LL;
    v36->__r_.__value_.__l.__cap_ = 0LL;
    v36->__r_.__value_.__r.__words[0] = 0LL;
    int v38 = std::string::append(buf, ")");
    std::string::size_type v39 = v38->__r_.__value_.__r.__words[0];
    v143.__r_.__value_.__r.__words[0] = v38->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v143.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v40 = v38->__r_.__value_.__s.__size_;
    v38->__r_.__value_.__l.__size_ = 0LL;
    v38->__r_.__value_.__l.__cap_ = 0LL;
    v38->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v39;
    __p.__r_.__value_.__l.__size_ = v143.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v143.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v40;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      char v41 = &__p;
    }
    else {
      char v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v41, buf);
    char v42 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v43 = sqlite3_step(v42);
    std::string::size_type v44 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v44) {
      (*(void (**)(std::string::size_type))(*(void *)v44 + 8LL))(v44);
    }
    if (v43 != 101) {
      goto LABEL_234;
    }
    sub_1003BE030(a3, 0, 0, (uint64_t)buf);
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v45 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v45 = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v46 = &v142;
    sub_1000392EC((uint64_t)&v142, v45 + 12);
    if ((v142.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v46 = (std::string *)v142.__r_.__value_.__r.__words[0];
    }
    if (v45)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v47 = &__p;
      }
      else {
        __int16 v47 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v46, v47, v45);
    }

    strcpy((char *)v46 + v45, "INSERT INTO ");
    if (cap >= 0) {
      uint64_t v48 = v140;
    }
    else {
      uint64_t v48 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v49 = HIBYTE(cap);
    }
    else {
      std::string::size_type v49 = (std::string::size_type)v140[1];
    }
    int v50 = std::string::append(&v142, (const std::string::value_type *)v48, v49);
    __int128 v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v135.__r_.__value_.__l.__cap_ = v50->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v135.__r_.__value_.__l.__data_ = v51;
    v50->__r_.__value_.__l.__size_ = 0LL;
    v50->__r_.__value_.__l.__cap_ = 0LL;
    v50->__r_.__value_.__r.__words[0] = 0LL;
    off_t v52 = std::string::append(&v135, " (");
    __int128 v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v143.__r_.__value_.__l.__cap_ = v52->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v143.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0LL;
    v52->__r_.__value_.__l.__cap_ = 0LL;
    v52->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v54 = buf;
    }
    else {
      int v54 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v55 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v55 = buf[0].__r_.__value_.__l.__size_;
    }
    __int16 v56 = std::string::append(&v143, (const std::string::value_type *)v54, v55);
    __int128 v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    v136.__r_.__value_.__l.__cap_ = v56->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v136.__r_.__value_.__l.__data_ = v57;
    v56->__r_.__value_.__l.__size_ = 0LL;
    v56->__r_.__value_.__l.__cap_ = 0LL;
    v56->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v58 = std::string::append(&v136, ") SELECT ");
    __int128 v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v145.__r_.__value_.__l.__cap_ = v58->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v145.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0LL;
    v58->__r_.__value_.__l.__cap_ = 0LL;
    v58->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v60 = buf;
    }
    else {
      double v60 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v61 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v61 = buf[0].__r_.__value_.__l.__size_;
    }
    __int16 v62 = std::string::append(&v145, (const std::string::value_type *)v60, v61);
    __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v137.__r_.__value_.__l.__cap_ = v62->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0LL;
    v62->__r_.__value_.__l.__cap_ = 0LL;
    v62->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v64 = std::string::append(&v137, " FROM ");
    __int128 v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v64->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0LL;
    v64->__r_.__value_.__l.__cap_ = 0LL;
    v64->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v66 = std::string::append(&v146, a2);
    std::string::size_type v67 = v66->__r_.__value_.__r.__words[0];
    v144[0] = v66->__r_.__value_.__l.__size_;
    *(void *)((char *)v144 + 7) = *(std::string::size_type *)((char *)&v66->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v68 = v66->__r_.__value_.__s.__size_;
    v66->__r_.__value_.__l.__size_ = 0LL;
    v66->__r_.__value_.__l.__cap_ = 0LL;
    v66->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v67;
    __p.__r_.__value_.__l.__size_ = v144[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v144 + 7);
    __p.__r_.__value_.__s.__size_ = v68;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v69 = &__p;
    }
    else {
      uint64_t v69 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v69, &v146);
    __int16 v70 = (sqlite3_stmt *)sub_100019240((uint64_t)v146.__r_.__value_.__l.__data_);
    int v71 = sqlite3_step(v70);
    std::string::size_type v72 = v146.__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = 0LL;
    if (v72) {
      (*(void (**)(std::string::size_type))(*(void *)v72 + 8LL))(v72);
    }
    if (v71 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v73 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v73 = __p.__r_.__value_.__l.__size_;
    }
    __int16 v74 = buf;
    sub_1000392EC((uint64_t)buf, v73 + 11);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int16 v74 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (v73)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        double v75 = &__p;
      }
      else {
        double v75 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v74, v75, v73);
    }

    strcpy((char *)v74 + v73, "DROP TABLE ");
    __int16 v76 = std::string::append(buf, a2);
    std::string::size_type v77 = v76->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v76->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v76->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v78 = v76->__r_.__value_.__s.__size_;
    v76->__r_.__value_.__l.__size_ = 0LL;
    v76->__r_.__value_.__l.__cap_ = 0LL;
    v76->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v77;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v78;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v78 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v77 = __p.__r_.__value_.__r.__words[0];
    }

    if (v78 >= 0) {
      uint64_t v79 = &__p;
    }
    else {
      uint64_t v79 = (std::string *)v77;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v79, buf);
    __int16 v80 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v81 = sqlite3_step(v80);
    std::string::size_type v82 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v82) {
      (*(void (**)(std::string::size_type))(*(void *)v82 + 8LL))(v82);
    }
    if (v81 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v83 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v83 = __p.__r_.__value_.__l.__size_;
    }
    __int16 v84 = &v137;
    sub_1000392EC((uint64_t)&v137, v83 + 12);
    if ((v137.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int16 v84 = (std::string *)v137.__r_.__value_.__r.__words[0];
    }
    if (v83)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        double v85 = &__p;
      }
      else {
        double v85 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v84, v85, v83);
    }

    strcpy((char *)v84 + v83, "ALTER TABLE ");
    if (cap >= 0) {
      __int128 v86 = v140;
    }
    else {
      __int128 v86 = (void **)v140[0];
    }
    if (cap >= 0) {
      std::string::size_type v87 = HIBYTE(cap);
    }
    else {
      std::string::size_type v87 = (std::string::size_type)v140[1];
    }
    uint64_t v88 = std::string::append(&v137, (const std::string::value_type *)v86, v87);
    __int128 v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v88->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v89;
    v88->__r_.__value_.__l.__size_ = 0LL;
    v88->__r_.__value_.__l.__cap_ = 0LL;
    v88->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v90 = std::string::append(&v146, " RENAME TO ");
    __int128 v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v90->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v91;
    v90->__r_.__value_.__l.__size_ = 0LL;
    v90->__r_.__value_.__l.__cap_ = 0LL;
    v90->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v92 = std::string::append(buf, a2);
    std::string::size_type v93 = v92->__r_.__value_.__r.__words[0];
    v145.__r_.__value_.__r.__words[0] = v92->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v94 = v92->__r_.__value_.__s.__size_;
    v92->__r_.__value_.__l.__size_ = 0LL;
    v92->__r_.__value_.__l.__cap_ = 0LL;
    v92->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v93;
    __p.__r_.__value_.__l.__size_ = v145.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v94;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v95 = &__p;
    }
    else {
      uint64_t v95 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v95, buf);
    uint64_t v96 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v97 = sqlite3_step(v96);
    std::string::size_type v98 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v98) {
      (*(void (**)(std::string::size_type))(*(void *)v98 + 8LL))(v98);
    }
    if (v97 != 101) {
      goto LABEL_234;
    }
    sub_1003BAFA4(a4, buf);
    std::string::size_type v99 = buf[0].__r_.__value_.__s.__size_;
    unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v99 = buf[0].__r_.__value_.__l.__size_;
    }
    if (v99)
    {
      std::string::assign(&__p, "");
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size_t v101 = __p.__r_.__value_.__s.__size_;
      }
      else {
        size_t v101 = __p.__r_.__value_.__l.__size_;
      }
      int v102 = &v135;
      sub_1000392EC((uint64_t)&v135, v101 + 13);
      if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v102 = (std::string *)v135.__r_.__value_.__r.__words[0];
      }
      if (v101)
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          uint64_t v103 = &__p;
        }
        else {
          uint64_t v103 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        memmove(v102, v103, v101);
      }

      strcpy((char *)v102 + v101, "CREATE INDEX ");
      if (v139 >= 0) {
        int v104 = v138;
      }
      else {
        int v104 = (void **)v138[0];
      }
      if (v139 >= 0) {
        std::string::size_type v105 = HIBYTE(v139);
      }
      else {
        std::string::size_type v105 = (std::string::size_type)v138[1];
      }
      int v106 = std::string::append(&v135, (const std::string::value_type *)v104, v105);
      __int128 v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
      v143.__r_.__value_.__l.__cap_ = v106->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v143.__r_.__value_.__l.__data_ = v107;
      v106->__r_.__value_.__l.__size_ = 0LL;
      v106->__r_.__value_.__l.__cap_ = 0LL;
      v106->__r_.__value_.__r.__words[0] = 0LL;
      std::stringbuf::string_type v108 = std::string::append(&v143, " ON ");
      __int128 v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
      v136.__r_.__value_.__l.__cap_ = v108->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v136.__r_.__value_.__l.__data_ = v109;
      v108->__r_.__value_.__l.__size_ = 0LL;
      v108->__r_.__value_.__l.__cap_ = 0LL;
      v108->__r_.__value_.__r.__words[0] = 0LL;
      __int16 v110 = std::string::append(&v136, a2);
      __int128 v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
      v145.__r_.__value_.__l.__cap_ = v110->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v145.__r_.__value_.__l.__data_ = v111;
      v110->__r_.__value_.__l.__size_ = 0LL;
      v110->__r_.__value_.__l.__cap_ = 0LL;
      v110->__r_.__value_.__r.__words[0] = 0LL;
      __int16 v112 = std::string::append(&v145, " (");
      __int128 v113 = *(_OWORD *)&v112->__r_.__value_.__l.__data_;
      v137.__r_.__value_.__l.__cap_ = v112->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v137.__r_.__value_.__l.__data_ = v113;
      v112->__r_.__value_.__l.__size_ = 0LL;
      v112->__r_.__value_.__l.__cap_ = 0LL;
      v112->__r_.__value_.__r.__words[0] = 0LL;
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int16 v114 = buf;
      }
      else {
        __int16 v114 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
      }
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v115 = buf[0].__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v115 = buf[0].__r_.__value_.__l.__size_;
      }
      __int16 v116 = std::string::append(&v137, (const std::string::value_type *)v114, v115);
      __int128 v117 = *(_OWORD *)&v116->__r_.__value_.__l.__data_;
      v146.__r_.__value_.__l.__cap_ = v116->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v117;
      v116->__r_.__value_.__l.__size_ = 0LL;
      v116->__r_.__value_.__l.__cap_ = 0LL;
      v116->__r_.__value_.__r.__words[0] = 0LL;
      __int16 v118 = std::string::append(&v146, ")");
      std::string::size_type v119 = v118->__r_.__value_.__r.__words[0];
      v142.__r_.__value_.__r.__words[0] = v118->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)v142.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v118->__r_.__value_.__r.__words[1] + 7);
      unsigned __int8 v120 = v118->__r_.__value_.__s.__size_;
      v118->__r_.__value_.__l.__size_ = 0LL;
      v118->__r_.__value_.__l.__cap_ = 0LL;
      v118->__r_.__value_.__r.__words[0] = 0LL;
      __p.__r_.__value_.__r.__words[0] = v119;
      __p.__r_.__value_.__l.__size_ = v142.__r_.__value_.__r.__words[0];
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v142.__r_.__value_.__r.__words + 7);
      __p.__r_.__value_.__s.__size_ = v120;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        BOOL v121 = &__p;
      }
      else {
        BOOL v121 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(*(void *)(a1 + 80), (char *)v121, &v146);
      __int16 v122 = (sqlite3_stmt *)sub_100019240((uint64_t)v146.__r_.__value_.__l.__data_);
      int v123 = sqlite3_step(v122);
      std::string::size_type v124 = v146.__r_.__value_.__r.__words[0];
      v146.__r_.__value_.__r.__words[0] = 0LL;
      if (v124) {
        (*(void (**)(std::string::size_type))(*(void *)v124 + 8LL))(v124);
      }
      unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    }

    else
    {
      int v123 = 101;
    }

    if ((v100 & 0x80) != 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
    if (v123 == 101)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182E748);
      }
      BOOL v125 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s autoincrement migration succeeded",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182E748);
        }
        LODWORD(v146.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v134) = 12;
        __int16 v133 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s autoincrement migration succeeded",  &v146,  v134);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<ConfigSummary>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInf o *, const char **) [T = ConfigSummary, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  (const char *)v133);
        if (v133 != buf) {
          free(v133);
        }
      }

      sub_1003C05BC(*(void *)(a1 + 80));
      char v126 = 0;
    }

    else
    {
LABEL_234:
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182E748);
      }
      int v127 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_FAULT,  "%{public}s autoincrement migration failed",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182E748);
        }
        LODWORD(v146.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v134) = 12;
        uint64_t v132 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "%{public}s autoincrement migration failed",  &v146,  v134);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLActivityRecorderDb<ConfigSummary>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInf o *, const char **) [T = ConfigSummary, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  (const char *)v132);
        if (v132 != buf) {
          free(v132);
        }
      }

      sub_1003C0E18(*(void *)(a1 + 80));
      char v126 = 1;
    }

    if (SHIBYTE(v139) < 0) {
      operator delete(v138[0]);
    }
    if (SHIBYTE(cap) < 0) {
      operator delete(v140[0]);
    }
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v126 & 1) != 0) {
        goto LABEL_246;
      }
    }

    else if ((v126 & 1) != 0)
    {
      goto LABEL_246;
    }

    return 1LL;
  }

void sub_10029A094( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10029A3B4(void *a1, uint64_t *a2, double a3, double a4)
{
  __int128 v10 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v35);
  if ((SHIBYTE(v36) & 0x80000000) == 0)
  {
    if (HIBYTE(v36)) {
      goto LABEL_3;
    }
LABEL_27:
    sub_1012328CC(v10);
    goto LABEL_28;
  }

  uint64_t v4 = (std::stringbuf *)v35[1];
  operator delete(v35[0]);
  if (!v4) {
    goto LABEL_27;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v35);
  unint64_t v11 = sub_10000CF44(&v36, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t p_p = &__p;
  }
  else {
    uint64_t p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  size_t v14 = sub_10000CF44(v11, (uint64_t)p_p, size);
  sub_10000CF44(v14, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  uint64_t v15 = a1[10];
  uint64_t v4 = &v37;
  std::stringbuf::str(&__p, &v37);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v16 = &__p;
  }
  else {
    uint64_t v16 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v15, (char *)v16, &v33);
  uint64_t v5 = v33;
  uint64_t v33 = 0LL;
  uint64_t v34 = v5;
  std::string::size_type v17 = (sqlite3_stmt *)sub_100019240(v5);
  if (sub_1003B7480(v17, 1, a3))
  {
    uint64_t v18 = (sqlite3_stmt *)sub_100019240(v5);
    if (sub_1003B7480(v18, 2, a4))
    {
      memset(&__p, 0, 20);
      sub_1010DDBC0(&v25, "");
      sub_1010DDBC0(&v27, "");
      sub_1010DDBC0(&v29, "");
      sub_1010DDBC0(&v31, "");
      while (1)
      {
        uint64_t v19 = sub_1001BA11C((uint64_t)a1, &v34, (uint64_t)&__p);
        if ((_DWORD)v19) {
          break;
        }
        unint64_t v20 = a2[1];
        if (v20 >= a2[2])
        {
          uint64_t v21 = sub_10029C474(a2, (__int128 *)&__p);
        }

        else
        {
          sub_10029C578(a2[1], (__int128 *)&__p);
          uint64_t v21 = v20 + 120;
          a2[1] = v20 + 120;
        }

        a2[1] = v21;
      }

      if (v32 < 0) {
        operator delete(v31);
      }
      if (v30 < 0) {
        operator delete(v29);
      }
      if (v28 < 0) {
        operator delete(v27);
      }
      if (v26 < 0) {
        operator delete(v25);
      }
      uint64_t v5 = v34;
      goto LABEL_38;
    }
  }

void sub_10029A69C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, char a38)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (v38) {
    (*(void (**)(uint64_t))(*(void *)v38 + 8LL))(v38);
  }
  sub_1011F8850((uint64_t)&a38);
  _Unwind_Resume(a1);
}

uint64_t sub_10029A760(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v43 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182E748);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)std::stringbuf::string_type buf = 68289282;
      *(_DWORD *)__int16 v47 = 0;
      *(_WORD *)&v47[4] = 2082;
      *(void *)&v47[6] = "";
      __int16 v48 = 2082;
      std::string::size_type v49 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182E748);
      }
      uint64_t v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)std::stringbuf::string_type buf = 134349056;
        *(void *)__int16 v47 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182E748);
        }
        uint64_t v39 = *(void *)(a1 + 216);
        int v44 = 134349056;
        uint64_t v45 = v39;
        unsigned __int8 v40 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v44,  12);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<ConfigSummary>::setDatabaseAccessible() [T = ConfigSummary, DataProtectionPo licy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v40);
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_70;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182E748);
    }
    __int128 v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)std::stringbuf::string_type buf = 68289539;
      *(_DWORD *)__int16 v47 = 0;
      *(_WORD *)&v47[4] = 2082;
      *(void *)&v47[6] = "";
      __int16 v48 = 2082;
      std::string::size_type v49 = v11;
      __int16 v50 = 2049;
      uint64_t v51 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    unint64_t v13 = *(void *)(a1 + 208);
    uint64_t v14 = *(void *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 192);
    uint64_t v16 = (void *)(v14 + 8 * (v13 / 0x22));
    unsigned int v42 = v9;
    if (v15 == v14) {
      unint64_t v17 = 0LL;
    }
    else {
      unint64_t v17 = *v16 + 120 * (v13 % 0x22);
    }
    while (1)
    {
      if (v15 == v14)
      {
        unint64_t v23 = 0LL;
      }

      else
      {
        unint64_t v22 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        unint64_t v23 = *(void *)(v14 + 8 * (v22 / 0x22)) + 120 * (v22 % 0x22);
      }

      if (v17 == v23) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10182E768);
      }
      std::string::size_type v24 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10182E768);
        }
        LOWORD(v44) = 0;
        LODWORD(v41) = 2;
        char v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v44,  v41);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<ConfigSummary>::setDatabaseAccessible() [T = ConfigSummary, DataProtectionPo licy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v26);
      }

      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v17, 1LL);
      v17 += 120LL;
      if (v17 - *v16 == 4080)
      {
        unint64_t v25 = v16[1];
        ++v16;
        unint64_t v17 = v25;
      }

      uint64_t v14 = *(void *)(a1 + 184);
      uint64_t v15 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    uint64_t v9 = v42;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182E748);
    }
    uint64_t v18 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      uint64_t v19 = (void *)(a1 + 88);
      *(_DWORD *)std::stringbuf::string_type buf = 68289282;
      *(_DWORD *)__int16 v47 = 0;
      *(_WORD *)&v47[4] = 2082;
      *(void *)&v47[6] = "";
      __int16 v48 = 2082;
      std::string::size_type v49 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182E748);
      }
    }

    unint64_t v20 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      uint64_t v21 = (void *)(a1 + 88);
      *(_DWORD *)std::stringbuf::string_type buf = 68289282;
      *(_DWORD *)__int16 v47 = 0;
      *(_WORD *)&v47[4] = 2082;
      *(void *)&v47[6] = "";
      __int16 v48 = 2082;
      std::string::size_type v49 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 12std::iostream::~basic_iostream(v2, v3 + 8) = 1;
  }

  uint64_t v27 = *(void ***)(a1 + 184);
  char v28 = *(void ***)(a1 + 192);
  if (v28 == v27)
  {
    char v28 = *(void ***)(a1 + 184);
  }

  else
  {
    unint64_t v29 = *(void *)(a1 + 208);
    char v30 = &v27[v29 / 0x22];
    uint64_t v31 = (uint64_t)*v30 + 120 * (v29 % 0x22);
    unint64_t v32 = (unint64_t)v27[(*(void *)(a1 + 216) + v29) / 0x22] + 120 * ((*(void *)(a1 + 216) + v29) % 0x22);
    if (v31 != v32)
    {
      do
      {
        sub_10029C410(a1 + 216, v31);
        v31 += 120LL;
        if (v31 - (void)*v30 == 4080)
        {
          uint64_t v33 = (uint64_t)v30[1];
          ++v30;
          uint64_t v31 = v33;
        }
      }

      while (v31 != v32);
      uint64_t v27 = *(void ***)(a1 + 184);
      char v28 = *(void ***)(a1 + 192);
    }
  }

  *(void *)(a1 + 216) = 0LL;
  unint64_t v34 = (char *)v28 - (char *)v27;
  if (v34 >= 0x11)
  {
    do
    {
      operator delete(*v27);
      uint64_t v35 = *(void *)(a1 + 192);
      uint64_t v27 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v27;
      unint64_t v34 = v35 - (void)v27;
    }

    while (v34 > 0x10);
  }

  if (v34 >> 3 == 1)
  {
    uint64_t v36 = 17LL;
  }

  else
  {
    if (v34 >> 3 != 2) {
      goto LABEL_68;
    }
    uint64_t v36 = 34LL;
  }

  *(void *)(a1 + 20std::iostream::~basic_iostream(v2, v3 + 8) = v36;
LABEL_68:
  std::stringbuf v37 = *(void **)(a1 + 144);
  if (v37)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_10029AF1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

std::string *sub_10029AF50(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5 = *a3;
  *(_DWORD *)(a2 + 16) = *((_DWORD *)a3 + 4);
  *(_OWORD *)a2 = v5;
  std::string::operator=((std::string *)(a2 + 24), (const std::string *)a3 + 1);
  std::string::operator=((std::string *)(a2 + 48), (const std::string *)a3 + 2);
  std::string::operator=((std::string *)(a2 + 72), (const std::string *)a3 + 3);
  return std::string::operator=((std::string *)(a2 + 96), (const std::string *)a3 + 4);
}

id *sub_10029AFAC(uint64_t *a1, __int128 *a2, char a3)
{
  v39[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v39[1] = 0LL;
  if (*((double *)a1 + 29) <= 0.0
    || !(*(unsigned int (**)(uint64_t *, uint64_t *, __int128 *))(*a1 + 136))(a1, a1 + 28, a2))
  {
    if ((a3 & 1) == 0) {
      sub_1003C0454(a1[10]);
    }
    uint64_t v28 = 0LL;
    double v29 = 0.0;
    int v30 = 0;
    sub_1010DDBC0(&v31, "");
    sub_1010DDBC0(&v33, "");
    sub_1010DDBC0(&v35, "");
    sub_1010DDBC0(&__p, "");
    int v6 = (*(uint64_t (**)(uint64_t *, uint64_t *))(*a1 + 104))(a1, &v28);
    if (v6 != 1)
    {
      if (v6)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182E748);
        }
        uint64_t v14 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)std::stringbuf::string_type buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10182E748);
          }
          LOWORD(v4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
          uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v40,  2);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<ConfigSummary>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = ConfigSumma ry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v15);
        }

void sub_10029B7A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, id a36)
{
}

uint64_t sub_10029B82C(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    __int128 v20 = (_Unwind_Exception *)sub_101232A38(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  uint64_t v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t p_p = &__p;
    }
    else {
      uint64_t p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 8)))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_10029BA8C(void *a1, double a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_101232BA4(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t p_p = &__p;
    }
    else {
      uint64_t p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    double v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_10029BCC4(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_101232D10(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  __int128 v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t p_p = &__p;
  }
  else {
    uint64_t p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  double v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

uint64_t sub_10029BEEC(uint64_t a1)
{
  return sub_10029A760(a1 - 72);
}

void sub_10029BEF4(id a1)
{
  qword_101934738 = (uint64_t)os_log_create("com.apple.locationd.Motion", "ContextConfiguration");
}

uint64_t sub_10029BF20(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v33);
  if ((SHIBYTE(v34) & 0x80000000) == 0)
  {
    if (HIBYTE(v34)) {
      goto LABEL_3;
    }
LABEL_40:
    uint64_t v20 = (_Unwind_Exception *)sub_101232E7C(v4);
    sub_100298410((uint64_t)&__p);
    uint64_t v21 = v32;
    uint64_t v32 = 0LL;
    if (v21) {
      (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
    }
    sub_1011F8850((uint64_t)v33);
    _Unwind_Resume(v20);
  }

  uint64_t v19 = v33[1];
  operator delete(v33[0]);
  if (!v19) {
    goto LABEL_40;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    uint64_t v7 = *a2;
    uint64_t v6 = a2[1];
    if (v6 != *a2)
    {
      do
      {
        v6 -= 120LL;
        sub_10029C410((uint64_t)(a2 + 2), v6);
      }

      while (v6 != v7);
    }

    a2[1] = v7;
    sub_10000CE18((uint64_t)v33);
    double v8 = sub_10000CF44(&v34, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, uint64_t *))(*a1 + 64))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t p_p = &__p;
    }
    else {
      uint64_t p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v11 = sub_10000CF44(v8, (uint64_t)p_p, size);
    sub_10000CF44(v11, (uint64_t)" ORDER BY id ASC", 16LL);
    uint64_t v12 = a1[10];
    std::stringbuf::str(&__p, &v35);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v13 = &__p;
    }
    else {
      uint64_t v13 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v12, (char *)v13, &v31);
    uint64_t v14 = v31;
    uint64_t v31 = 0LL;
    uint64_t v32 = v14;
    sub_1003C0454(a1[10]);
    memset(&__p, 0, 20);
    sub_1010DDBC0(&v23, "");
    sub_1010DDBC0(&v25, "");
    sub_1010DDBC0(&v27, "");
    sub_1010DDBC0(&v29, "");
    while (!sub_1001BA11C((uint64_t)a1, &v32, (uint64_t)&__p))
    {
      unint64_t v15 = a2[1];
      if (v15 >= a2[2])
      {
        uint64_t v16 = sub_10029C474(a2, (__int128 *)&__p);
      }

      else
      {
        sub_10029C578(a2[1], (__int128 *)&__p);
        uint64_t v16 = v15 + 120;
        a2[1] = v15 + 120;
      }

      a2[1] = v16;
    }

    sub_1003C05BC(a1[10]);
    if (v30 < 0) {
      operator delete(v29);
    }
    if (v28 < 0) {
      operator delete(v27);
    }
    if (v26 < 0) {
      operator delete(v25);
    }
    if (v24 < 0) {
      operator delete(v23);
    }
    uint64_t v17 = v32;
    uint64_t v32 = 0LL;
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
    }
    *(void **)((char *)v33
    uint64_t v34 = v18;
    std::streambuf::~streambuf(&v35);
    return std::ios::~ios(&v36);
  }

  return result;
}

void sub_10029C2B0(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_10029C2DC(void *a1)
{
  uint64_t v2 = a1 + 5;
  uint64_t v3 = (void **)a1[1];
  uint64_t v4 = (void **)a1[2];
  if (v4 == v3)
  {
    uint64_t v4 = (void **)a1[1];
  }

  else
  {
    unint64_t v5 = a1[4];
    uint64_t v6 = &v3[v5 / 0x22];
    uint64_t v7 = (uint64_t)*v6 + 120 * (v5 % 0x22);
    unint64_t v8 = (unint64_t)v3[(a1[5] + v5) / 0x22] + 120 * ((a1[5] + v5) % 0x22);
    if (v7 != v8)
    {
      do
      {
        sub_10029C410((uint64_t)v2, v7);
        v7 += 120LL;
        if (v7 - (void)*v6 == 4080)
        {
          uint64_t v9 = (uint64_t)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }

      while (v7 != v8);
      uint64_t v3 = (void **)a1[1];
      uint64_t v4 = (void **)a1[2];
    }
  }

  *uint64_t v2 = 0LL;
  unint64_t v10 = (char *)v4 - (char *)v3;
  if ((unint64_t)((char *)v4 - (char *)v3) >= 0x11)
  {
    do
    {
      operator delete(*v3);
      uint64_t v4 = (void **)a1[2];
      uint64_t v3 = (void **)(a1[1] + 8LL);
      a1[1] = v3;
      unint64_t v10 = (char *)v4 - (char *)v3;
    }

    while ((unint64_t)((char *)v4 - (char *)v3) > 0x10);
  }

  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 17LL;
  }

  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 34LL;
  }

  a1[4] = v12;
LABEL_16:
  while (v3 != v4)
  {
    uint64_t v13 = *v3++;
    operator delete(v13);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void sub_10029C410(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_10029C474(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x222222222222222LL) {
    sub_100007008();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x111111111111111LL) {
    unint64_t v9 = 0x222222222222222LL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)sub_1000BAE04(v7, v9);
  }
  else {
    unint64_t v10 = 0LL;
  }
  uint64_t v13 = v10;
  uint64_t v14 = &v10[120 * v4];
  uint64_t v16 = &v10[120 * v9];
  sub_10029C578((uint64_t)v14, a2);
  unint64_t v15 = v14 + 120;
  sub_10029C6C4(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10029C8B0(&v13);
  return v11;
}

void sub_10029C564(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10029C578(uint64_t a1, __int128 *a2)
{
  __int128 v4 = *a2;
  *(_DWORD *)(a1 + 16) = *((_DWORD *)a2 + 4);
  *(_OWORD *)a1 = v4;
  if (*((char *)a2 + 47) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 24), *((void **)a2 + 3), *((void *)a2 + 4));
  }

  else
  {
    __int128 v5 = *(__int128 *)((char *)a2 + 24);
    *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *((void *)a2 + 5);
    *(_OWORD *)(a1 + 24) = v5;
  }

  if (*((char *)a2 + 71) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 48), *((void **)a2 + 6), *((void *)a2 + 7));
  }

  else
  {
    __int128 v6 = a2[3];
    *(void *)(a1 + 64) = *((void *)a2 + 8);
    *(_OWORD *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = v6;
  }

  if (*((char *)a2 + 95) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 72), *((void **)a2 + 9), *((void *)a2 + 10));
  }

  else
  {
    __int128 v7 = *(__int128 *)((char *)a2 + 72);
    *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)a2 + 11);
    *(_OWORD *)(a1 + 72) = v7;
  }

  unint64_t v8 = (_BYTE *)(a1 + 96);
  if (*((char *)a2 + 119) < 0)
  {
    sub_1010DD48C(v8, *((void **)a2 + 12), *((void *)a2 + 13));
  }

  else
  {
    __int128 v9 = a2[6];
    *(void *)(a1 + 112) = *((void *)a2 + 14);
    *(_OWORD *)unint64_t v8 = v9;
  }

  return a1;
}

void sub_10029C678(_Unwind_Exception *exception_object)
{
  if (v1[95] < 0) {
    operator delete(*v4);
  }
  if (v1[71] < 0) {
    operator delete(*v3);
  }
  if (v1[47] < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10029C6C4(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10029C738((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10029C738(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v19 = a6;
  *((void *)&v19 + 1) = a7;
  __int128 v18 = v19;
  v16[0] = a1;
  v16[1] = &v18;
  _DWORD v16[2] = &v19;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      __int128 v10 = *(_OWORD *)(a3 - 120);
      *(_DWORD *)(v9 - 104) = *(_DWORD *)(a3 - 104);
      *(_OWORD *)(v9 - 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v10;
      __int128 v11 = *(_OWORD *)(a3 - 96);
      *(void *)(v9 - 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(a3 - 80);
      *(_OWORD *)(v9 - 96) = v11;
      *(void *)(a3 - 8std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
      *(void *)(a3 - 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
      *(void *)(a3 - 96) = 0LL;
      __int128 v12 = *(_OWORD *)(a3 - 72);
      *(void *)(v9 - 56) = *(void *)(a3 - 56);
      *(_OWORD *)(v9 - 72) = v12;
      *(void *)(a3 - 64) = 0LL;
      *(void *)(a3 - 56) = 0LL;
      *(void *)(a3 - 72) = 0LL;
      __int128 v13 = *(_OWORD *)(a3 - 48);
      *(void *)(v9 - sub_10000AE14(v13 - 32) = *(void *)(a3 - 32);
      *(_OWORD *)(v9 - 4std::iostream::~basic_iostream(v2, v3 + 8) = v13;
      *(void *)(a3 - 4std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
      *(void *)(a3 - 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
      *(void *)(a3 - sub_10000AE14(v13 - 32) = 0LL;
      __int128 v14 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - std::iostream::~basic_iostream(v2, v3 + 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v14;
      v9 -= 120LL;
      *(void *)(a3 - 24) = 0LL;
      *(void *)(a3 - 16) = 0LL;
      *(void *)(a3 - std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
      v7 -= 120LL;
      a3 -= 120LL;
    }

    while (a3 != a5);
    *((void *)&v19 + 1) = v9;
  }

  char v17 = 1;
  sub_10029C82C((uint64_t)v16);
  return a6;
}

uint64_t sub_10029C82C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_10029C860((uint64_t *)a1);
  }
  return a1;
}

void sub_10029C860(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_10029C410(v3, v1);
      v1 += 120LL;
    }

    while (v1 != v2);
  }

void **sub_10029C8B0(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_10029C8E0(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 120;
    sub_10029C410(v4, i - 120);
  }

void sub_10029C924(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

uint64_t sub_10029CABC(void *a1, void *a2, _DWORD *a3)
{
  uint64_t v6 = a1[2];
  uint64_t v7 = a1[1];
  if (v6 == v7) {
    uint64_t v8 = 0LL;
  }
  else {
    uint64_t v8 = 32 * (v6 - v7) - 1;
  }
  uint64_t v9 = a1[4];
  uint64_t v10 = a1[5];
  unint64_t v11 = v10 + v9;
  if (v8 == v10 + v9)
  {
    sub_10029CB80(a1);
    uint64_t v9 = a1[4];
    uint64_t v10 = a1[5];
    uint64_t v7 = a1[1];
    unint64_t v11 = v9 + v10;
  }

  uint64_t v12 = *(void *)(v7 + ((v11 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v11;
  *(void *)uint64_t v12 = *a2;
  *(_DWORD *)(v12 + std::iostream::~basic_iostream(v2, v3 + 8) = *a3;
  uint64_t v13 = v10 + 1;
  a1[5] = v13;
  unint64_t v14 = v9 + v13;
  unint64_t v15 = (void *)(v7 + 8 * (v14 >> 8));
  if ((_BYTE)v14) {
    uint64_t v16 = *v15 + 16LL * v14;
  }
  else {
    uint64_t v16 = *(v15 - 1) + 4096LL;
  }
  return v16 - 16;
}

void sub_10029CB80(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    uint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      std::stringbuf v35 = &v34[8 * (v33 >> 2)];
      std::stringbuf v37 = &v34[8 * v36];
      char v38 = (uint64_t *)a1[1];
      uint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_10029CE48( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

_BYTE *sub_10029CE94(_BYTE *__dst, unsigned __int8 *a2, size_t a3)
{
  else {
    *__uuid_t dst = -1;
  }
  return __dst;
}

void *sub_10029CEFC(void *a1)
{
  *a1 = off_10182E798;
  a1[1] = 0LL;
  a1[2] = 0LL;
  a1[3] = 0LL;
  uint64_t v2 = sub_1006E27E8();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_10029CFA0;
  void v4[3] = &unk_10181D3D0;
  void v4[4] = a1;
  sub_1006E28B8(v2, (uint64_t)v4);
  return a1;
}

void sub_10029CF80(_Unwind_Exception *a1)
{
}

void sub_10029CFA0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (uint64_t *)sub_10071542C();
  uint64_t v14 = 0x140000FF0CLL;
  char v15 = 0;
  sub_10121B774(v2, (uint64_t)&v14, (uint64_t *)&v16);
  sub_10005F550(v1 + 8, &v16);
  BOOL v3 = (std::__shared_weak_count *)*((void *)&v16 + 1);
  if (*((void *)&v16 + 1))
  {
    unsigned int v4 = (unint64_t *)(*((void *)&v16 + 1) + 8LL);
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  sub_100719D78(*(uint64_t **)(v1 + 8), (uint64_t)nullsub_145, v1);
  sub_100719ECC(*(void *)(v1 + 8), (uint64_t)sub_10029D12C, v1);
  sub_100719E00(*(void *)(v1 + 8), (uint64_t)sub_10029D12C, v1);
  sub_10071A408(*(void *)(v1 + 8), (uint64_t)sub_10029D12C, v1);
  uint64_t v6 = operator new(0x20uLL);
  uint64_t v7 = (uint64_t)v6;
  uint64_t v8 = *(void *)(v1 + 16);
  *(void *)&__int128 v16 = *(void *)(v1 + 8);
  *((void *)&v16 + 1) = v8;
  if (v8)
  {
    uint64_t v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  sub_100E2E64C(v6, &v16);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)&v16 + 1);
  if (*((void *)&v16 + 1))
  {
    uint64_t v12 = (unint64_t *)(*((void *)&v16 + 1) + 8LL);
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  sub_10029D2EC((uint64_t *)(v1 + 24), v7);
  sub_100E2EA00(*(uint64_t **)(v1 + 24));
}

void sub_10029D100(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10029D12C(void *a1)
{
  uint64_t v2 = (uint64_t *)a1[3];
  sub_100E2E678(v2);
  sub_100E2EA00(v2);
  return (*(uint64_t (**)(void *))(*a1 + 16LL))(a1);
}

void *sub_10029D168(void *a1)
{
  *a1 = off_10182E798;
  uint64_t v2 = (uint64_t)(a1 + 1);
  sub_10029D2EC(a1 + 3, 0LL);
  sub_10000AE14(v2);
  return a1;
}

void *sub_10029D1AC(void *a1)
{
  *a1 = off_10182E798;
  uint64_t v2 = (uint64_t)(a1 + 1);
  sub_10029D2EC(a1 + 3, 0LL);
  sub_10000AE14(v2);
  return a1;
}

void sub_10029D1F0(uint64_t *a1)
{
  *a1 = (uint64_t)off_10182E798;
  uint64_t v2 = (uint64_t)(a1 + 1);
  sub_10029D2EC(a1 + 3, 0LL);
  sub_10000AE14(v2);
  operator delete(a1);
}

unint64_t sub_10029D234()
{
  return ((unint64_t)sub_1004F97F4() >> 8) & 1;
}

BOOL sub_10029D24C(uint64_t a1, uint64_t a2, char *a3)
{
  if ((sub_1004F97F4() & 0x100) == 0) {
    sub_101232FE8();
  }
  int v8 = 0;
  uint64_t v7 = 4LL;
  return sub_100E2F5E4(*(void *)(a1 + 24), a2, a3, (uint64_t)&v8, (uint64_t)&v7) == 0;
}

void sub_10029D2C0(id a1)
{
  qword_1019344A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Eclipse");
}

void sub_10029D2EC(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    unsigned int v4 = (void *)sub_100E2E9FC();
    operator delete(v4);
  }

void *sub_10029D318@<X0>(int *a1@<X1>, int *a2@<X2>, char *a3@<X3>, uint64_t *a4@<X4>, void *a5@<X8>)
{
  unint64_t v10 = operator new(0xC0uLL);
  uint64_t result = sub_10121F314(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  return result;
}

void sub_10029D37C(_Unwind_Exception *a1)
{
}

uint64_t sub_10029D390(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

id sub_10029D8A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = -[CKRecordID initWithRecordName:zoneID:]( [CKRecordID alloc],  "initWithRecordName:zoneID:",  a2,  [*(id *)(a1 + 32) zoneIDForZoneName:*(void *)(a1 + 40)]);
  unsigned int v4 = objc_alloc(&OBJC_CLASS___CKSyncEnginePendingRecordZoneChange);
  unint64_t v5 =  -[CKSyncEnginePendingRecordZoneChange initWithRecordID:type:]( v4,  "initWithRecordID:type:",  v3,  CKSyncEnginePendingRecordZoneChangeTypeSave);

  return [*(id *)(a1 + 48) addObject:v5];
}

BOOL sub_10029DF68(void *a1, uint64_t a2)
{
  unsigned int v4 = a1 + 14;
  (*(void (**)(void *))(a1[14] + 16LL))(a1 + 14);
  LODWORD(a2) = (*(uint64_t (**)(void *, uint64_t))(*a1 + 104LL))(a1, a2);
  (*(void (**)(void *))(*v4 + 24LL))(v4);
  return (_DWORD)a2 == 0;
}

void sub_10029DFEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10029EEDC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CKRecord *sub_10029F65C(uint64_t a1, void *a2)
{
  return sub_100BE66C0(*(void *)(*(void *)(a1 + 32) + 24LL), a2);
}

void sub_1002A04D8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 24LL);
  if (v2) {
    sub_100BE6FBC(v2, a2);
  }
}

void sub_1002A0774(id a1, CKRecordZone *a2, unint64_t a3, BOOL *a4)
{
  if (qword_1019347B0 != -1) {
    dispatch_once(&qword_1019347B0, &stru_10182E9D0);
  }
  unint64_t v5 = (os_log_s *)qword_1019347B8;
  if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543362;
    uint64_t v11 = -[CKRecordZoneID zoneName](-[CKRecordZone zoneID](a2, "zoneID"), "zoneName");
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "[CloudKit] Successfully saved zone %{public}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182E9D0);
    }
    uint64_t v6 = qword_1019347B8;
    int v8 = 138543362;
    uint64_t v9 = -[CKRecordZoneID zoneName](-[CKRecordZone zoneID](a2, "zoneID"), "zoneName");
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v6,  0LL,  "[CloudKit] Successfully saved zone %{public}@",  &v8,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CMHealthColdStorageCloudKitManager handleSentDatabaseChanges:]_block_invoke",  "%s\n",  v7);
  }

id sub_1002A0938(uint64_t a1, void *a2)
{
  if (qword_1019347B0 != -1) {
    dispatch_once(&qword_1019347B0, &stru_10182E9D0);
  }
  unsigned int v4 = (os_log_s *)qword_1019347B8;
  if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543362;
    id v11 = [a2 zoneName];
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "[CloudKit] Successfully deleted zone ID %{public}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182E9D0);
    }
    uint64_t v6 = qword_1019347B8;
    int v8 = 138543362;
    id v9 = [a2 zoneName];
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v6,  0LL,  "[CloudKit] Successfully deleted zone ID %{public}@",  &v8,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CMHealthColdStorageCloudKitManager handleSentDatabaseChanges:]_block_invoke",  "%s\n",  v7);
  }

  return [*(id *)(a1 + 32) handleZoneDeleted:a2];
}

id sub_1002A0B04(uint64_t a1, void *a2)
{
  if (qword_1019347B0 != -1) {
    dispatch_once(&qword_1019347B0, &stru_10182E9D0);
  }
  unsigned int v4 = (os_log_s *)qword_1019347B8;
  if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543618;
    id v13 = objc_msgSend(objc_msgSend(objc_msgSend(a2, "recordZone"), "zoneID"), "zoneName");
    __int16 v14 = 2114;
    id v15 = [a2 error];
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "[CloudKit] Failed to save zone changes %{public}@. Error: %{public}@",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182E9D0);
    }
    uint64_t v6 = qword_1019347B8;
    int v8 = 138543618;
    id v9 = objc_msgSend(objc_msgSend(objc_msgSend(a2, "recordZone"), "zoneID"), "zoneName");
    __int16 v10 = 2114;
    id v11 = [a2 error];
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v6,  16LL,  "[CloudKit] Failed to save zone changes %{public}@. Error: %{public}@",  &v8,  22);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CMHealthColdStorageCloudKitManager handleSentDatabaseChanges:]_block_invoke",  "%s\n",  v7);
  }

  id result = objc_msgSend(objc_msgSend(a2, "error"), "code");
  if (result == (id)112) {
    return objc_msgSend(*(id *)(a1 + 32), "deleteZone:", objc_msgSend(objc_msgSend(a2, "recordZone"), "zoneID"));
  }
  return result;
}

void sub_1002A0D3C(id a1, CKRecordZoneID *a2, NSError *a3, BOOL *a4)
{
  if (qword_1019347B0 != -1) {
    dispatch_once(&qword_1019347B0, &stru_10182E9D0);
  }
  uint64_t v6 = (os_log_s *)qword_1019347B8;
  if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543618;
    __int16 v14 = -[CKRecordZoneID zoneName](a2, "zoneName");
    __int16 v15 = 2114;
    __int128 v16 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "[CloudKit] Failed to delete zone %{public}@. Error: %{public}@",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182E9D0);
    }
    uint64_t v7 = qword_1019347B8;
    int v9 = 138543618;
    __int16 v10 = -[CKRecordZoneID zoneName](a2, "zoneName");
    __int16 v11 = 2114;
    uint64_t v12 = a3;
    int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  17LL,  "[CloudKit] Failed to delete zone %{public}@. Error: %{public}@",  &v9,  22);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CMHealthColdStorageCloudKitManager handleSentDatabaseChanges:]_block_invoke",  "%s\n",  v8);
  }

void sub_1002A11B8(uint64_t a1, void *a2)
{
  if (qword_1019347B0 != -1) {
    dispatch_once(&qword_1019347B0, &stru_10182E9D0);
  }
  unsigned int v4 = (os_log_s *)qword_1019347B8;
  if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543362;
    id v14 = [a2 recordID];
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "[CloudKit] Successfully saved records %{public}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182E9D0);
    }
    uint64_t v7 = qword_1019347B8;
    int v11 = 138543362;
    id v12 = [a2 recordID];
    int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  2LL,  "[CloudKit] Successfully saved records %{public}@",  &v11,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CMHealthColdStorageCloudKitManager handleSentRecordZoneChanges:]_block_invoke",  "%s\n",  v8);
  }

  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 24LL);
  if (v5
    && (sub_100BE6D38( v5,  [a2 recordID],  +[CMHealthColdStorageUtils getSystemFieldsFromCKRecord:]( CMHealthColdStorageUtils,  "getSystemFieldsFromCKRecord:",  a2)) & 1) == 0)
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182E9D0);
    }
    uint64_t v6 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "[CloudKit] SentRecordChanges: Failed to update local system fields for saved record",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182E9D0);
      }
      LOWORD(v11) = 0;
      LODWORD(v1sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 2;
      int v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[CloudKit] SentRecordChanges: Failed to update local system fields for saved record",  &v11,  v10);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CMHealthColdStorageCloudKitManager handleSentRecordZoneChanges:]_block_invoke",  "%s\n",  v9);
    }
  }

void sub_1002A14E4(uint64_t a1, void *a2)
{
  if (qword_1019347B0 != -1) {
    dispatch_once(&qword_1019347B0, &stru_10182E9D0);
  }
  unsigned int v4 = (os_log_s *)qword_1019347B8;
  if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543362;
    id v13 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "[CloudKit] Successfully deleted records %{public}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182E9D0);
    }
    int v10 = 138543362;
    int v11 = a2;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  2LL,  "[CloudKit] Successfully deleted records %{public}@",  &v10,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CMHealthColdStorageCloudKitManager handleSentRecordZoneChanges:]_block_invoke",  "%s\n",  v7);
  }

  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 24LL);
  if (v5 && (sub_100BE6D38(v5, a2, 0LL) & 1) == 0)
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182E9D0);
    }
    uint64_t v6 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "[CloudKit] SentRecordChanges: Failed to update local system fields for failed record",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182E9D0);
      }
      LOWORD(v1sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
      LODWORD(v9) = 2;
      int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[CloudKit] SentRecordChanges: Failed to update local system fields for failed record",  &v10,  v9);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CMHealthColdStorageCloudKitManager handleSentRecordZoneChanges:]_block_invoke",  "%s\n",  v8);
    }
  }

void sub_1002A17DC(uint64_t a1, void *a2)
{
  if (qword_1019347B0 != -1) {
    dispatch_once(&qword_1019347B0, &stru_10182E9D0);
  }
  unsigned int v4 = (os_log_s *)qword_1019347B8;
  if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543618;
    id v15 = objc_msgSend(objc_msgSend(a2, "record"), "recordID");
    __int16 v16 = 2114;
    id v17 = [a2 error];
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "[CloudKit] Failed to save record changes %{public}@. Error: %{public}@",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182E9D0);
    }
    uint64_t v6 = qword_1019347B8;
    int v10 = 138543618;
    id v11 = objc_msgSend(objc_msgSend(a2, "record"), "recordID");
    __int16 v12 = 2114;
    id v13 = [a2 error];
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v6,  16LL,  "[CloudKit] Failed to save record changes %{public}@. Error: %{public}@",  &v10,  22);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CMHealthColdStorageCloudKitManager handleSentRecordZoneChanges:]_block_invoke",  "%s\n",  v7);
  }

  sub_100BE7118(*(void *)(*(void *)(a1 + 32) + 24), (uint64_t)[a2 error]);
  if (CKErrorIsCode([a2 error], 14))
  {
    objc_msgSend( *(id *)(a1 + 32),  "handleServerRecordChanged:",  objc_msgSend( objc_msgSend(objc_msgSend(a2, "error"), "userInfo"),  "objectForKeyedSubscript:",  CKRecordChangedErrorServerRecordKey));
  }

  else if (CKErrorIsCode([a2 error], 11))
  {
    objc_msgSend(*(id *)(a1 + 32), "handleUnknownItem:", objc_msgSend(a2, "record"));
  }

  else if (CKErrorIsCode([a2 error], 26))
  {
    objc_msgSend(*(id *)(a1 + 32), "handleZoneNotFound:", objc_msgSend(a2, "record"));
  }

  else if (CKErrorIsCode([a2 error], 112))
  {
    objc_msgSend( *(id *)(a1 + 32),  "deleteZone:",  objc_msgSend(objc_msgSend(objc_msgSend(a2, "record"), "recordID"), "zoneID"));
  }

  else
  {
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182E9D0);
    }
    uint64_t v5 = (os_log_s *)qword_1019347B8;
    if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "[CloudKit] Unhandled error, ignoring failed record",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347B0 != -1) {
        dispatch_once(&qword_1019347B0, &stru_10182E9D0);
      }
      LOWORD(v1sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
      LODWORD(v9) = 2;
      int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  2LL,  "[CloudKit] Unhandled error, ignoring failed record",  &v10,  v9);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CMHealthColdStorageCloudKitManager handleSentRecordZoneChanges:]_block_invoke",  "%s\n",  v8);
    }
  }

void sub_1002A1BFC(id a1, CKRecordID *a2, NSError *a3, BOOL *a4)
{
  if (qword_1019347B0 != -1) {
    dispatch_once(&qword_1019347B0, &stru_10182E9D0);
  }
  uint64_t v6 = (os_log_s *)qword_1019347B8;
  if (os_log_type_enabled((os_log_t)qword_1019347B8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 138543618;
    id v13 = a2;
    __int16 v14 = 2114;
    id v15 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "[CloudKit] Failed to delete record %{public}@. Error: %{public}@",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347B0 != -1) {
      dispatch_once(&qword_1019347B0, &stru_10182E9D0);
    }
    int v8 = 138543618;
    uint64_t v9 = a2;
    __int16 v10 = 2114;
    id v11 = a3;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347B8,  16LL,  "[CloudKit] Failed to delete record %{public}@. Error: %{public}@",  &v8,  22);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "-[CMHealthColdStorageCloudKitManager handleSentRecordZoneChanges:]_block_invoke",  "%s\n",  v7);
  }

void sub_1002A2E78(id a1)
{
  qword_1019347B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "HealthColdStorage");
}

void *sub_1002A2EA4@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  unsigned int v4 = operator new(0x190uLL);
  id result = sub_1002A2EFC(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1002A2EE8(_Unwind_Exception *a1)
{
}

void *sub_1002A2EFC(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10182EA00;
  sub_100AC64D8(a1 + 3, *a2);
  return a1;
}

void sub_1002A2F38(_Unwind_Exception *a1)
{
}

void sub_1002A2F4C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182EA00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002A2F60(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182EA00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1002A2F84(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void sub_1002A3DFC(id a1)
{
  qword_1019349B8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

double sub_1002A3E28(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  double result = -1.0;
  *(_OWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = xmmword_1012E0070;
  *(_OWORD *)(a1 + 24) = xmmword_1012E0070;
  *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0xBFF0000000000000LL;
  *(_OWORD *)(a1 + 64) = xmmword_1012E0070;
  *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 96) = 0;
  *(_BYTE *)(a1 + 10sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
  *(void *)(a1 + 112) = 0LL;
  *(void *)(a1 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  return result;
}

BOOL sub_1002A3E68(uint64_t a1)
{
  return *(double *)(a1 + 8) > 0.0;
}

void sub_1002A3E78(uint64_t a1)
{
  if (*(double *)(a1 + 8) <= 0.0)
  {
    *(CFAbsoluteTime *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = CFAbsoluteTimeGetCurrent();
    if (*(double *)(a1 + 88) > 0.0)
    {
      int v2 = *(_DWORD *)(a1 + 96);
      char v3 = *(_BYTE *)(a1 + 100);
      double Current = CFAbsoluteTimeGetCurrent();
      double v5 = Current;
      unint64_t v6 = *(void *)(a1 + 120);
      unint64_t v7 = *(void *)(a1 + 112);
      if (v7 >= v6)
      {
        uint64_t v9 = *(void *)(a1 + 104);
        uint64_t v10 = (uint64_t)(v7 - v9) >> 4;
        unint64_t v11 = v10 + 1;
        uint64_t v12 = v6 - v9;
        if (v12 >> 3 > v11) {
          unint64_t v11 = v12 >> 3;
        }
        else {
          unint64_t v13 = v11;
        }
        if (v13) {
          __int16 v14 = (char *)sub_100037038(a1 + 120, v13);
        }
        else {
          __int16 v14 = 0LL;
        }
        id v15 = &v14[16 * v10];
        __int16 v16 = &v14[16 * v13];
        *(double *)id v15 = v5;
        *((_DWORD *)v15 + 2) = v2;
        v15[12] = v3;
        int v8 = v15 + 16;
        uint64_t v18 = *(void *)(a1 + 104);
        uint64_t v17 = *(void *)(a1 + 112);
        if (v17 != v18)
        {
          do
          {
            uint64_t v19 = *(void *)(v17 - 16);
            v17 -= 16LL;
            uint64_t v20 = *(void *)(v17 + 5);
            *((void *)v15 - 2) = v19;
            v15 -= 16;
            *(void *)(v15 + 5) = v20;
          }

          while (v17 != v18);
          uint64_t v17 = *(void *)(a1 + 104);
        }

        *(void *)(a1 + 104) = v15;
        *(void *)(a1 + 112) = v8;
        *(void *)(a1 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v16;
        if (v17) {
          operator delete((void *)v17);
        }
      }

      else
      {
        *(double *)unint64_t v7 = Current;
        *(_DWORD *)(v7 + std::iostream::~basic_iostream(v2, v3 + 8) = v2;
        int v8 = (char *)(v7 + 16);
        *(_BYTE *)(v7 + 12) = v3;
      }

      *(void *)(a1 + 112) = v8;
    }

    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10182EAC0);
    }
    uint64_t v21 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "HARVEST NAVIGATION SESSION: start navigation session",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10182EAC0);
      }
      v24[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  1LL,  "HARVEST NAVIGATION SESSION: start navigation session",  v24,  2);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNavigationSession::start()", "%s\n", v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

void sub_1002A4114(uint64_t a1)
{
  if (*(double *)(a1 + 8) >= 0.0 && *(double *)(a1 + 24) <= 0.0 && *(double *)(a1 + 40) <= 0.0)
  {
    *(CFAbsoluteTime *)(a1 + 16) = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 8);
    *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0xBFF0000000000000LL;
    if (*(double *)(a1 + 88) > 0.0)
    {
      int v2 = *(_DWORD *)(a1 + 96);
      char v3 = *(_BYTE *)(a1 + 100);
      double Current = CFAbsoluteTimeGetCurrent();
      double v5 = Current;
      unint64_t v6 = *(void *)(a1 + 120);
      unint64_t v7 = *(void *)(a1 + 112);
      if (v7 >= v6)
      {
        uint64_t v9 = *(void *)(a1 + 104);
        uint64_t v10 = (uint64_t)(v7 - v9) >> 4;
        unint64_t v11 = v10 + 1;
        uint64_t v12 = v6 - v9;
        if (v12 >> 3 > v11) {
          unint64_t v11 = v12 >> 3;
        }
        else {
          unint64_t v13 = v11;
        }
        if (v13) {
          __int16 v14 = (char *)sub_100037038(a1 + 120, v13);
        }
        else {
          __int16 v14 = 0LL;
        }
        id v15 = &v14[16 * v10];
        __int16 v16 = &v14[16 * v13];
        *(double *)id v15 = v5;
        *((_DWORD *)v15 + 2) = v2;
        v15[12] = v3;
        int v8 = v15 + 16;
        uint64_t v18 = *(void *)(a1 + 104);
        uint64_t v17 = *(void *)(a1 + 112);
        if (v17 != v18)
        {
          do
          {
            uint64_t v19 = *(void *)(v17 - 16);
            v17 -= 16LL;
            uint64_t v20 = *(void *)(v17 + 5);
            *((void *)v15 - 2) = v19;
            v15 -= 16;
            *(void *)(v15 + 5) = v20;
          }

          while (v17 != v18);
          uint64_t v17 = *(void *)(a1 + 104);
        }

        *(void *)(a1 + 104) = v15;
        *(void *)(a1 + 112) = v8;
        *(void *)(a1 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v16;
        if (v17) {
          operator delete((void *)v17);
        }
      }

      else
      {
        *(double *)unint64_t v7 = Current;
        *(_DWORD *)(v7 + std::iostream::~basic_iostream(v2, v3 + 8) = v2;
        int v8 = (char *)(v7 + 16);
        *(_BYTE *)(v7 + 12) = v3;
      }

      *(void *)(a1 + 112) = v8;
    }

    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10182EAC0);
    }
    uint64_t v21 = (os_log_s *)qword_1019349B8;
    if (!os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEFAULT))
    {
LABEL_35:
      if (!sub_1002921D0(115, 2))
      {
LABEL_36:
        *(_OWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = xmmword_1012E0070;
        *(_OWORD *)(a1 + 24) = xmmword_1012E0070;
        *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
        *(void *)(a1 + 56) = 0LL;
        *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0xBFF0000000000000LL;
        *(_OWORD *)(a1 + 64) = xmmword_1012E0070;
        *(_BYTE *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
        *(void *)(a1 + 112) = *(void *)(a1 + 104);
        return;
      }

      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10182EAC0);
      }
      uint64_t v37 = qword_1019349B8;
      (*(void (**)(void **__return_ptr))(**(void **)a1 + 16LL))(v56);
      if (v57 >= 0.0) {
        char v38 = v56;
      }
      else {
        char v38 = (void **)v56[0];
      }
      uint64_t v39 = *(void *)(a1 + 16);
      uint64_t v40 = *(void *)(a1 + 32);
      uint64_t v42 = *(void *)(a1 + 48);
      uint64_t v41 = *(void *)(a1 + 56);
      uint64_t v43 = *(void *)(a1 + 72);
      int v44 = *(unsigned __int8 *)(a1 + 80);
      uint64_t v45 = *(void *)(a1 + 104);
      uint64_t v46 = *(void *)(a1 + 112);
      double v47 = -1.0;
      unint64_t v48 = v46 - v45;
      uint64_t v49 = (v46 - v45) >> 4;
      if (v46 == v45)
      {
        int v51 = -1;
        double v50 = -1.0;
      }

      else
      {
        double v50 = *(float *)(v45 + 8);
        int v51 = *(unsigned __int8 *)(v45 + 12);
        if (v48 >= 0x11)
        {
          double v47 = *(float *)(v46 - 8);
          int v52 = *(unsigned __int8 *)(v46 - 4);
LABEL_48:
          *(_DWORD *)std::stringbuf::string_type __p = 136317954;
          *(void *)&__p[4] = v38;
          __int16 v59 = 2048;
          uint64_t v60 = v39;
          __int16 v61 = 2048;
          uint64_t v62 = v40;
          __int16 v63 = 2048;
          uint64_t v64 = v42;
          __int16 v65 = 2048;
          uint64_t v66 = v41;
          __int16 v67 = 2048;
          uint64_t v68 = v43;
          __int16 v69 = 1024;
          int v70 = v44;
          __int16 v71 = 2048;
          uint64_t v72 = v49;
          __int16 v73 = 2048;
          double v74 = v50;
          __int16 v75 = 1024;
          int v76 = v51;
          __int16 v77 = 2048;
          double v78 = v47;
          __int16 v79 = 1024;
          int v80 = v52;
          LODWORD(v54) = 110;
          __int128 v53 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v37,  0LL,  "HARVEST NAVIGATION SESSION: stop navigation session, identifier, %s, duration, %.3f, automtive ActivityDuration, %.3f, isVehicleConnectedDuration, %.3f, gpsDuration, %.3f, proactiveGpsDurat ion, %.3f, mapsUsed, %d, batteryStates, %lu, beggining, level, %f, charging, %d, end, level, %f, charging, %d",  __p,  v54,  v55,  *(double *)v56,  *(double *)&v56[1],  v57);
          if (SHIBYTE(v57) < 0) {
            operator delete(v56[0]);
          }
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNavigationSession::stop()", "%s\n", v53);
          goto LABEL_36;
        }
      }

      int v52 = -1;
      goto LABEL_48;
    }

    (*(void (**)(_BYTE *__return_ptr))(**(void **)a1 + 16LL))(__p);
    if (v61 >= 0) {
      unint64_t v22 = __p;
    }
    else {
      unint64_t v22 = *(_BYTE **)__p;
    }
    uint64_t v23 = *(void *)(a1 + 16);
    uint64_t v24 = *(void *)(a1 + 32);
    uint64_t v26 = *(void *)(a1 + 48);
    uint64_t v25 = *(void *)(a1 + 56);
    uint64_t v27 = *(void *)(a1 + 72);
    int v28 = *(unsigned __int8 *)(a1 + 80);
    uint64_t v29 = *(void *)(a1 + 104);
    uint64_t v30 = *(void *)(a1 + 112);
    double v31 = -1.0;
    unint64_t v32 = v30 - v29;
    uint64_t v33 = (v30 - v29) >> 4;
    if (v30 == v29)
    {
      int v35 = -1;
      double v34 = -1.0;
    }

    else
    {
      double v34 = *(float *)(v29 + 8);
      int v35 = *(unsigned __int8 *)(v29 + 12);
      if (v32 >= 0x11)
      {
        double v31 = *(float *)(v30 - 8);
        int v36 = *(unsigned __int8 *)(v30 - 4);
        goto LABEL_33;
      }
    }

    int v36 = -1;
LABEL_33:
    *(_DWORD *)std::stringbuf::string_type buf = 136317954;
    std::string::size_type v82 = v22;
    __int16 v83 = 2048;
    uint64_t v84 = v23;
    __int16 v85 = 2048;
    uint64_t v86 = v24;
    __int16 v87 = 2048;
    uint64_t v88 = v26;
    __int16 v89 = 2048;
    uint64_t v90 = v25;
    __int16 v91 = 2048;
    uint64_t v92 = v27;
    __int16 v93 = 1024;
    int v94 = v28;
    __int16 v95 = 2048;
    uint64_t v96 = v33;
    __int16 v97 = 2048;
    double v98 = v34;
    __int16 v99 = 1024;
    int v100 = v35;
    __int16 v101 = 2048;
    double v102 = v31;
    __int16 v103 = 1024;
    int v104 = v36;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "HARVEST NAVIGATION SESSION: stop navigation session, identifier, %s, duration, %.3f, automtiveActivityDuration, %. 3f, isVehicleConnectedDuration, %.3f, gpsDuration, %.3f, proactiveGpsDuration, %.3f, mapsUsed, %d, batteryStates, %lu, beggining, level, %f, charging, %d, end, level, %f, charging, %d",  buf,  0x6Eu);
    if (SHIBYTE(v61) < 0) {
      operator delete(*(void **)__p);
    }
    goto LABEL_35;
  }

void sub_1002A460C(uint64_t a1)
{
  if (*(double *)(a1 + 24) <= 0.0)
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10182EAC0);
    }
    int v2 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "HARVEST NAVIGATION SESSION: start automotive activity",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10182EAC0);
      }
      v5[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  1LL,  "HARVEST NAVIGATION SESSION: start automotive activity",  v5,  2);
      unsigned int v4 = (uint8_t *)v3;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNavigationSession::startAutomotiveActivity()", "%s\n", v3);
      if (v4 != buf) {
        free(v4);
      }
    }

    *(CFAbsoluteTime *)(a1 + 24) = CFAbsoluteTimeGetCurrent();
    sub_1002A3E78(a1);
  }

void sub_1002A47B8(uint64_t a1)
{
  if (*(double *)(a1 + 24) >= 0.0)
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10182EAC0);
    }
    int v2 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "HARVEST NAVIGATION SESSION: stop automotive activity",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10182EAC0);
      }
      v4[0] = 0;
      char v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  1LL,  "HARVEST NAVIGATION SESSION: stop automotive activity",  v4,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNavigationSession::stopAutomotiveActivity()", "%s\n", v3);
    }

    *(double *)(a1 + sub_10000AE14(v13 - 32) = *(double *)(a1 + 32) + CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 24);
    *(void *)(a1 + 24) = 0xBFF0000000000000LL;
    sub_1002A4114(a1);
  }

void sub_1002A4978(uint64_t a1)
{
  if (*(double *)(a1 + 40) <= 0.0)
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10182EAC0);
    }
    int v2 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "HARVEST NAVIGATION SESSION: start vehicle connected",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10182EAC0);
      }
      v5[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  1LL,  "HARVEST NAVIGATION SESSION: start vehicle connected",  v5,  2);
      unsigned int v4 = (uint8_t *)v3;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNavigationSession::startVehicleConnected()", "%s\n", v3);
      if (v4 != buf) {
        free(v4);
      }
    }

    *(CFAbsoluteTime *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = CFAbsoluteTimeGetCurrent();
    sub_1002A3E78(a1);
  }

void sub_1002A4B24(uint64_t a1)
{
  if (*(double *)(a1 + 40) >= 0.0)
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_10182EAC0);
    }
    int v2 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "HARVEST NAVIGATION SESSION: stop vehicle connected",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_10182EAC0);
      }
      v4[0] = 0;
      char v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349B8,  1LL,  "HARVEST NAVIGATION SESSION: stop vehicle connected",  v4,  2);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNavigationSession::stopVehicleConnected()", "%s\n", v3);
    }

    *(double *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = *(double *)(a1 + 48) + CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 40);
    *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0xBFF0000000000000LL;
    sub_1002A4114(a1);
  }

double sub_1002A4CE4(uint64_t a1, double result)
{
  if (*(double *)(a1 + 8) > 0.0)
  {
    double result = *(double *)(a1 + 56) + result;
    *(double *)(a1 + 56) = result;
  }

  return result;
}

void sub_1002A4D00(uint64_t a1)
{
}

double sub_1002A4D3C(double *a1)
{
  double result = a1[1];
  if (result > 0.0)
  {
    double result = a1[8];
    if (result >= 0.0)
    {
      double result = a1[9] + CFAbsoluteTimeGetCurrent() - a1[8];
      a1[9] = result;
      a1[8] = -1.0;
    }
  }

  return result;
}

uint64_t sub_1002A4D8C(uint64_t result)
{
  *(_BYTE *)(result + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
  return result;
}

void sub_1002A4D98(uint64_t a1, int a2, float a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  *(double *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = Current;
  unint64_t v7 = (_OWORD *)(a1 + 88);
  *(float *)(a1 + 96) = a3;
  *(_BYTE *)(a1 + 10sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = a2;
  if (*(double *)(a1 + 8) > 0.0)
  {
    int v8 = *(double **)(a1 + 104);
    uint64_t v9 = *(double **)(a1 + 112);
    uint64_t v10 = (char *)v9 - (char *)v8;
    if (v9 == v8 || *((unsigned __int8 *)v9 - 4) != a2 || Current - *(v9 - 2) >= 300.0)
    {
      unint64_t v11 = *(void *)(a1 + 120);
      if ((unint64_t)v9 >= v11)
      {
        uint64_t v13 = v10 >> 4;
        unint64_t v14 = (v10 >> 4) + 1;
        if (v14 >> 60) {
          sub_100007008();
        }
        uint64_t v15 = v11 - (void)v8;
        if (v15 >> 3 > v14) {
          unint64_t v14 = v15 >> 3;
        }
        else {
          unint64_t v16 = v14;
        }
        if (v16) {
          uint64_t v17 = (char *)sub_100037038(a1 + 120, v16);
        }
        else {
          uint64_t v17 = 0LL;
        }
        uint64_t v18 = &v17[16 * v13];
        uint64_t v19 = &v17[16 * v16];
        *(_OWORD *)uint64_t v18 = *v7;
        uint64_t v12 = v18 + 16;
        uint64_t v21 = *(void *)(a1 + 104);
        uint64_t v20 = *(void *)(a1 + 112);
        if (v20 != v21)
        {
          do
          {
            uint64_t v22 = *(void *)(v20 - 16);
            v20 -= 16LL;
            uint64_t v23 = *(void *)(v20 + 5);
            *((void *)v18 - 2) = v22;
            v18 -= 16;
            *(void *)(v18 + 5) = v23;
          }

          while (v20 != v21);
          uint64_t v20 = *(void *)(a1 + 104);
        }

        *(void *)(a1 + 104) = v18;
        *(void *)(a1 + 112) = v12;
        *(void *)(a1 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v19;
        if (v20) {
          operator delete((void *)v20);
        }
      }

      else
      {
        *(_OWORD *)uint64_t v9 = *v7;
        uint64_t v12 = v9 + 2;
      }

      *(void *)(a1 + 112) = v12;
    }
  }

void sub_1002A4ED8(id a1)
{
  qword_1019349B8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

BOOL sub_1002A4F04(const char *a1, int a2, uint64_t a3)
{
  unint64_t v6 = xmlBufferCreate();
  if (!v6) {
    return 0LL;
  }
  unint64_t v7 = v6;
  int v8 = xmlNewTextWriterMemory(v6, 0);
  if (v8)
  {
    uint64_t v9 = v8;
    int v10 = xmlTextWriterWriteBase64(v8, a1, 0, a2);
    BOOL v11 = v10 != -1;
    if (v10 != -1)
    {
      xmlTextWriterFlush(v9);
      uint64_t v12 = (xmlChar *)xmlBufferContent(v7);
      int v13 = xmlBufferLength(v7);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      unint64_t v14 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::stringbuf::string_type buf = 134218498;
        *(void *)&uint8_t buf[4] = v12;
        *(_WORD *)&_BYTE buf[12] = 1024;
        *(_DWORD *)&buf[14] = v13;
        *(_WORD *)&_BYTE buf[18] = 2080;
        *(void *)&buf[20] = v12;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "processed %p %d to (%s)", buf, 0x1Cu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        int v17 = 134218498;
        uint64_t v18 = v12;
        __int16 v19 = 1024;
        int v20 = v13;
        __int16 v21 = 2080;
        uint64_t v22 = v12;
        unint64_t v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "processed %p %d to (%s)",  &v17,  28);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLNameValuePair::encodeBase64(const void *, unsigned long, std::string &)",  "%s\n",  v16);
        if (v16 != buf) {
          free(v16);
        }
      }

      sub_100104050(buf, v12, v13);
      *(_OWORD *)a3 = *(_OWORD *)buf;
      *(void *)(a3 + 16) = *(void *)&buf[16];
    }

    xmlFreeTextWriter(v9);
  }

  else
  {
    BOOL v11 = 0LL;
  }

  xmlBufferFree(v7);
  return v11;
}

void *sub_1002A51A4(void *a1)
{
  *a1 = off_10182EAF0;
  a1[1] = 0LL;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  a1[1] = Mutable;
  if (!Mutable)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    char v3 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "could not create new mutable dictionary",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      v6[0] = 0;
      double v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not create new mutable dictionary",  v6,  2);
      sub_10029211C("Generic", 1LL, 0, 0LL, "CLNameValuePair::CLNameValuePair()", "%s\n", v5);
    }
  }

  return a1;
}

void *sub_1002A5374(void *a1, CFDictionaryRef theDict)
{
  *a1 = off_10182EAF0;
  a1[1] = 0LL;
  if (theDict) {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, theDict);
  }
  else {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }
  a1[1] = MutableCopy;
  if (!MutableCopy)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    unsigned int v4 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "could not create new mutable dictionary",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      v7[0] = 0;
      unint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not create new mutable dictionary",  v7,  2);
      sub_10029211C("Generic", 1LL, 0, 0LL, "CLNameValuePair::CLNameValuePair(CFDictionaryRef)", "%s\n", v6);
    }
  }

  return a1;
}

void *sub_1002A5554(void *a1)
{
  *a1 = off_10182EAF0;
  int v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_1002A5594(void *a1)
{
  uint64_t v1 = sub_1002A5554(a1);
  operator delete(v1);
}

void *sub_1002A55A8(void *a1, uint64_t a2)
{
  *a1 = off_10182EAF0;
  CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, *(CFDictionaryRef *)(a2 + 8));
  a1[1] = MutableCopy;
  if (!MutableCopy)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    unsigned int v4 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "could not create new mutable dictionary",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      v7[0] = 0;
      unint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not create new mutable dictionary",  v7,  2);
      sub_10029211C("Generic", 1LL, 0, 0LL, "CLNameValuePair::CLNameValuePair(const CLNameValuePair &)", "%s\n", v6);
    }
  }

  return a1;
}

uint64_t sub_1002A576C(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unsigned int v4 = *(const void **)(a1 + 8);
    if (v4) {
      CFRelease(v4);
    }
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, *(CFDictionaryRef *)(a2 + 8));
    *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = MutableCopy;
    if (!MutableCopy)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      unint64_t v6 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create new mutable dictionary",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        v9[0] = 0;
        int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not create new mutable dictionary",  v9,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLNameValuePair &CLNameValuePair::operator=(const CLNameValuePair &)",  "%s\n",  v8);
      }
    }
  }

  return a1;
}

CFStringRef sub_1002A5938()
{
  return @"Memory";
}

uint64_t sub_1002A5948(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 928LL))(a3, a1, a2);
}

uint64_t sub_1002A5964(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a3 + 896LL))(a3, a1, a2);
}

uint64_t sub_1002A5980(void *context, uint64_t a2, int a3)
{
  unsigned int v4 = *(const __CFDictionary **)(a2 + 8);
  if (a3) {
    double v5 = (void (__cdecl *)(const void *, const void *, void *))sub_1002A5964;
  }
  else {
    double v5 = (void (__cdecl *)(const void *, const void *, void *))sub_1002A5948;
  }
  CFDictionaryApplyFunction(v4, v5, context);
  return (*(uint64_t (**)(void *))(*(void *)context + 848LL))(context);
}

uint64_t sub_1002A59CC(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

BOOL sub_1002A59D4(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = +[NSURL fileURLWithPath:isDirectory:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2),  0LL);
  id v20 = 0LL;
  if (+[NSData instancesRespondToSelector:]( &OBJC_CLASS___NSData,  "instancesRespondToSelector:",  "dataWithContentsOfURL:options:error:")) {
    double v5 = +[NSData dataWithContentsOfURL:options:error:]( &OBJC_CLASS___NSData,  "dataWithContentsOfURL:options:error:",  v4,  0LL,  &v20);
  }
  else {
    double v5 = +[NSData dataWithContentsOfURL:](&OBJC_CLASS___NSData, "dataWithContentsOfURL:", v4);
  }
  if (!v5)
  {
    if (!v20) {
      return 0LL;
    }
    (*(void (**)(uint64_t, void))(*(void *)a1 + 872LL))(a1, 0LL);
    if (objc_msgSend(objc_msgSend(v20, "domain"), "isEqual:", NSCocoaErrorDomain)
      && [v20 code] == (id)260)
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_10182EEC8);
      }
      unint64_t v7 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
      {
        id v8 = objc_msgSend(objc_msgSend(v20, "description"), "UTF8String");
        *(_DWORD *)std::stringbuf::string_type buf = 68289538;
        int v22 = 0;
        __int16 v23 = 2082;
        uint64_t v24 = "";
        __int16 v25 = 2082;
        uint64_t v26 = a2;
        __int16 v27 = 2082;
        id v28 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:file does not exist... clearing, file:%{public, location:escape_only}s, error :%{public, location:escape_only}s}",  buf,  0x26u);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_10182EEC8);
        }
      }

      uint64_t v9 = qword_101934988;
      BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
      if (!result) {
        return result;
      }
      id v10 = objc_msgSend(objc_msgSend(v20, "description"), "UTF8String");
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v22 = 0;
      __int16 v23 = 2082;
      uint64_t v24 = "";
      __int16 v25 = 2082;
      uint64_t v26 = a2;
      __int16 v27 = 2082;
      id v28 = v10;
      BOOL v11 = "file does not exist... clearing";
      uint64_t v12 = "{msg%{public}.0s:file does not exist... clearing, file:%{public, location:escape_only}s, error"
            ":%{public, location:escape_only}s}";
    }

    else
    {
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_10182EEC8);
      }
      int v17 = (os_log_s *)qword_101934988;
      if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
      {
        id v18 = objc_msgSend(objc_msgSend(v20, "description"), "UTF8String");
        *(_DWORD *)std::stringbuf::string_type buf = 68289538;
        int v22 = 0;
        __int16 v23 = 2082;
        uint64_t v24 = "";
        __int16 v25 = 2082;
        uint64_t v26 = a2;
        __int16 v27 = 2082;
        id v28 = v18;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Warning Error reading file, file:%{public, location:escape_only}s, error:%{p ublic, location:escape_only}s}",  buf,  0x26u);
        if (qword_101934980 != -1) {
          dispatch_once(&qword_101934980, &stru_10182EEC8);
        }
      }

      uint64_t v9 = qword_101934988;
      BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
      if (!result) {
        return result;
      }
      id v19 = objc_msgSend(objc_msgSend(v20, "description"), "UTF8String");
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v22 = 0;
      __int16 v23 = 2082;
      uint64_t v24 = "";
      __int16 v25 = 2082;
      uint64_t v26 = a2;
      __int16 v27 = 2082;
      id v28 = v19;
      BOOL v11 = "#Warning Error reading file";
      uint64_t v12 = "{msg%{public}.0s:#Warning Error reading file, file:%{public, location:escape_only}s, error:%"
            "{public, location:escape_only}s}";
    }

    uint64_t v15 = (os_log_s *)v9;
    uint32_t v16 = 38;
    goto LABEL_32;
  }

  if (qword_101934980 != -1) {
    dispatch_once(&qword_101934980, &stru_10182EEC8);
  }
  int v13 = (os_log_s *)qword_101934988;
  if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 68289282;
    int v22 = 0;
    __int16 v23 = 2082;
    uint64_t v24 = "";
    __int16 v25 = 2082;
    uint64_t v26 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:could not deserialize property list, file:%{public, location:escape_only}s}",  buf,  0x1Cu);
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_10182EEC8);
    }
  }

  uint64_t v14 = qword_101934988;
  BOOL result = os_signpost_enabled((os_log_t)qword_101934988);
  if (result)
  {
    *(_DWORD *)std::stringbuf::string_type buf = 68289282;
    int v22 = 0;
    __int16 v23 = 2082;
    uint64_t v24 = "";
    __int16 v25 = 2082;
    uint64_t v26 = a2;
    BOOL v11 = "could not deserialize property list";
    uint64_t v12 = "{msg%{public}.0s:could not deserialize property list, file:%{public, location:escape_only}s}";
    uint64_t v15 = (os_log_s *)v14;
    uint32_t v16 = 28;
LABEL_32:
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v11,  v12,  buf,  v16);
    return 0LL;
  }

  return result;
}

uint64_t sub_1002A5EAC(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 872LL))(a1);
}

id sub_1002A5EB8(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  unint64_t v7 = objc_autoreleasePoolPush();
  id v8 = +[NSURL fileURLWithPath:isDirectory:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2),  0LL);
  if (v8)
  {
    uint64_t v9 = 536870913LL;
    if (a4) {
      uint64_t v9 = 1LL;
    }
    if (a4 == 1) {
      uint64_t v10 = 1073741825LL;
    }
    else {
      uint64_t v10 = v9;
    }
    id v20 = 0LL;
    id v11 = [a3 writeToURL:v8 options:v10 error:&v20];
    if ((v11 & 1) == 0)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v12 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_ERROR))
      {
        id v13 = objc_msgSend(objc_msgSend(v20, "description"), "UTF8String");
        *(_DWORD *)std::stringbuf::string_type buf = 136446466;
        uint64_t v26 = a2;
        __int16 v27 = 2082;
        id v28 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "Could not write data to disk %{public}s, %{public}s",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        uint64_t v14 = qword_101934A78;
        id v15 = objc_msgSend(objc_msgSend(v20, "description"), "UTF8String");
        int v21 = 136446466;
        uint64_t v22 = a2;
        __int16 v23 = 2082;
        id v24 = v15;
        uint32_t v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  16LL,  "Could not write data to disk %{public}s, %{public}s",  &v21,  22);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLNameValuePair::writeDataToFile(const char *, CFDataRef, CLNVPDataProtection) const",  "%s\n",  v16);
      }
    }
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    int v17 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 136446210;
      uint64_t v26 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "Could not create NSURL for file: %{public}s",  buf,  0xCu);
    }

    id v11 = 0LL;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      int v21 = 136446210;
      uint64_t v22 = a2;
      id v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Could not create NSURL for file: %{public}s",  &v21,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLNameValuePair::writeDataToFile(const char *, CFDataRef, CLNVPDataProtection) const",  "%s\n",  v19);
      id v11 = 0LL;
    }
  }

  objc_autoreleasePoolPop(v7);
  return v11;
}

id sub_1002A6270(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0LL;
  uint64_t v3 = (*(uint64_t (**)(uint64_t, CFTypeRef *))(*(void *)a1 + 768LL))(a1, &cf);
  if ((_DWORD)v3)
  {
    id v4 = sub_1002A5EB8(v3, a2, (void *)cf, 2);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    double v5 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 136446210;
      uint64_t v13 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "Could not serialize data for file %{public}s",  buf,  0xCu);
    }

    id v4 = 0LL;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      int v10 = 136446210;
      uint64_t v11 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Could not serialize data for file %{public}s",  &v10,  12);
      id v8 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 0LL, "virtual BOOL CLNameValuePair::saveToFile(const char *) const", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
      id v4 = 0LL;
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  return v4;
}

id sub_1002A6460(uint64_t a1, uint64_t a2, int a3)
{
  CFTypeRef cf = 0LL;
  sub_100222B94(v12, (uint64_t)"CLNameValuePair.SaveToBinaryFile", 0);
  unint64_t v6 = objc_autoreleasePoolPush();
  uint64_t v7 = (*(uint64_t (**)(uint64_t, CFTypeRef *))(*(void *)a1 + 776LL))(a1, &cf);
  if ((_DWORD)v7)
  {
    id v8 = sub_1002A5EB8(v7, a2, (void *)cf, a3);
  }

  else
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_10182EEC8);
    }
    uint64_t v9 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289282;
      int v15 = 0;
      __int16 v16 = 2082;
      int v17 = "";
      __int16 v18 = 2082;
      uint64_t v19 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Could not serialize data, file:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_10182EEC8);
      }
    }

    int v10 = (os_log_s *)qword_101934988;
    if (os_signpost_enabled((os_log_t)qword_101934988))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289282;
      int v15 = 0;
      __int16 v16 = 2082;
      int v17 = "";
      __int16 v18 = 2082;
      uint64_t v19 = a2;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Could not serialize data",  "{msg%{public}.0s:Could not serialize data, file:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    id v8 = 0LL;
  }

  if (cf) {
    CFRelease(cf);
  }
  objc_autoreleasePoolPop(v6);
  sub_1001BA1BC(v12);
  return v8;
}

void sub_1002A6660( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_1002A667C(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  (*(void (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 880LL))(a1, v5, a3);
  CFRelease(v5);
}

uint64_t sub_1002A66DC(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 880LL))(a1);
}

uint64_t sub_1002A66E8(CFMutableDictionaryRef *a1)
{
  return (*((uint64_t (**)(CFMutableDictionaryRef *))*a1 + 106))(a1);
}

void sub_1002A6718(uint64_t a1, const __CFString *a2, unsigned int a3)
{
  if ((a3 & 0x80000000) != 0)
  {
    (*(void (**)(uint64_t, const __CFString *))(*(void *)a1 + 888LL))(a1, a2);
    return;
  }

  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFArrayGetTypeID())
  {
    if (!a3)
    {
      (*(void (**)(uint64_t, const __CFString *))(*(void *)a1 + 888LL))(a1, a2);
      goto LABEL_40;
    }

    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    uint64_t v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, (std::string *)__p);
      int v8 = SBYTE3(v34);
      uint64_t v9 = *(_BYTE **)__p;
      CFTypeID v10 = CFGetTypeID(cf);
      uint64_t v11 = __p;
      *(_DWORD *)std::stringbuf::string_type buf = 136446722;
      if (v8 < 0) {
        uint64_t v11 = v9;
      }
      int v36 = v11;
      __int16 v37 = 1026;
      unsigned int v38 = a3;
      __int16 v39 = 2050;
      CFTypeID v40 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "key %{public}s does not have element %{public}d in non-array type %{public}lu",  buf,  0x1Cu);
      if (SBYTE3(v34) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_40;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    uint64_t v12 = qword_101934A78;
    sub_1002A6C50(a2, &v28);
    int size = (char)v28.__r_.__value_.__s.__size_;
    std::string::size_type v14 = v28.__r_.__value_.__r.__words[0];
    CFTypeID v15 = CFGetTypeID(cf);
    __int16 v16 = &v28;
    *(_DWORD *)std::stringbuf::string_type __p = 136446722;
    if (size < 0) {
      __int16 v16 = (std::string *)v14;
    }
    *(void *)&__p[4] = v16;
    __int16 v31 = 1026;
    unsigned int v32 = a3;
    __int16 v33 = 2050;
    CFTypeID v34 = v15;
    int v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v12,  17LL,  "key %{public}s does not have element %{public}d in non-array type %{public}lu",  __p,  28);
LABEL_37:
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNameValuePair::clearInternal(const CFStringRef, int)",  "%s\n",  v17);
    goto LABEL_40;
  }

  if (CFArrayGetCount((CFArrayRef)cf) <= a3)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    __int16 v18 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, (std::string *)__p);
      int v19 = SBYTE3(v34);
      id v20 = *(_BYTE **)__p;
      CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
      uint64_t v22 = __p;
      *(_DWORD *)std::stringbuf::string_type buf = 136446722;
      if (v19 < 0) {
        uint64_t v22 = v20;
      }
      int v36 = v22;
      __int16 v37 = 1026;
      unsigned int v38 = a3;
      __int16 v39 = 2050;
      CFTypeID v40 = Count;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "key %{public}s does not have element %{public}d in array of size %{public}ld",  buf,  0x1Cu);
      if (SBYTE3(v34) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_40;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    uint64_t v23 = qword_101934A78;
    sub_1002A6C50(a2, &v28);
    int v24 = (char)v28.__r_.__value_.__s.__size_;
    std::string::size_type v25 = v28.__r_.__value_.__r.__words[0];
    CFIndex v26 = CFArrayGetCount((CFArrayRef)cf);
    __int16 v27 = &v28;
    *(_DWORD *)std::stringbuf::string_type __p = 136446722;
    if (v24 < 0) {
      __int16 v27 = (std::string *)v25;
    }
    *(void *)&__p[4] = v27;
    __int16 v31 = 1026;
    unsigned int v32 = a3;
    __int16 v33 = 2050;
    CFTypeID v34 = v26;
    int v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v23,  17LL,  "key %{public}s does not have element %{public}d in array of size %{public}ld",  __p,  28);
    goto LABEL_37;
  }

  CFArrayRemoveValueAtIndex((CFMutableArrayRef)cf, a3);
  (*(void (**)(uint64_t))(*(void *)a1 + 848LL))(a1);
LABEL_40:
  CFRelease(cf);
}

void sub_1002A6C10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002A6C50@<W0>(const __CFString *a1@<X0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0LL;
  a2->__r_.__value_.__l.__size_ = 0LL;
  a2->__r_.__value_.__l.__cap_ = 0LL;
  BOOL result = sub_1002AA05C(a1, a2);
  if (!result)
  {
    if ((char)a2->__r_.__value_.__s.__size_ < 0)
    {
      *a2->__r_.__value_.__l.__data_ = 0;
      a2->__r_.__value_.__l.__size_ = 0LL;
    }

    else
    {
      a2->__r_.__value_.__s.__data_[0] = 0;
      a2->__r_.__value_.__s.__size_ = 0;
    }
  }

  return result;
}

void sub_1002A6CA0(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1002A6CBC(CFMutableDictionaryRef *a1, const void *a2)
{
  return (*((uint64_t (**)(CFMutableDictionaryRef *))*a1 + 106))(a1);
}

uint64_t sub_1002A6CEC(uint64_t a1, uint64_t *a2)
{
  unint64_t Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 8));
  uint64_t v5 = Count;
  if (Count >> 61) {
    size_t v6 = -1LL;
  }
  else {
    size_t v6 = 8 * Count;
  }
  uint64_t v7 = (const void **)operator new[](v6);
  int v8 = (const void **)operator new[](v6);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 8), v7, v8);
  sub_100012A14(a2);
  if (v5 >= 1)
  {
    uint64_t v9 = (const __CFString **)v7;
    do
    {
      sub_1002A6C50(*v9, &__p);
      unint64_t v10 = a2[1];
      if (v10 >= a2[2])
      {
        uint64_t v12 = sub_10112142C(a2, (__int128 *)&__p);
      }

      else
      {
        if ((char)__p.__r_.__value_.__s.__size_ < 0)
        {
          sub_1010DD48C((_BYTE *)a2[1], __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
        }

        else
        {
          __int128 v11 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
          *(void *)(v10 + 16) = __p.__r_.__value_.__l.__cap_;
          *(_OWORD *)unint64_t v10 = v11;
        }

        uint64_t v12 = v10 + 24;
        a2[1] = v10 + 24;
      }

      a2[1] = v12;
      ++v9;
      --v5;
    }

    while (v5);
  }

  operator delete[](v7);
  operator delete[](v8);
  return 1LL;
}

void sub_1002A6E08( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  *(void *)(v15 + std::iostream::~basic_iostream(v2, v3 + 8) = v16;
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002A6E30(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, NSString *))(*(void *)a1 + 920LL))( a1,  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
}

uint64_t sub_1002A6E6C(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 920LL))(a1);
}

uint64_t sub_1002A6E78(uint64_t a1, const char *a2, CFTypeRef *a3, uint64_t a4)
{
  CFStringRef v7 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  *a3 = 0LL;
  uint64_t v8 = (*(uint64_t (**)(uint64_t, CFStringRef, CFTypeRef *, uint64_t))(*(void *)a1 + 904LL))(a1, v7, a3, a4);
  if ((_DWORD)v8 && *a3) {
    CFAutorelease(*a3);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v8;
}

CFStringRef sub_1002A6F04(char *cStr)
{
  return CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
}

uint64_t sub_1002A6F20(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  *a3 = 0LL;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 904LL))(a1);
  if ((_DWORD)v4 && *a3) {
    CFAutorelease(*a3);
  }
  return v4;
}

uint64_t sub_1002A6F64(uint64_t a1, const char *a2, BOOL *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  uint64_t v6 = sub_1002A6FD4(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_1002A6FD4(uint64_t a1, uint64_t a2, BOOL *a3)
{
  uint64_t v6 = sub_1002A9230(cf, a3);
  if ((v6 & 1) == 0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    CFStringRef v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      uint64_t v19 = v8;
      __int16 v20 = 2112;
      uint64_t v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = a2;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &v14,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, BOOL &, int) const",  "%s\n",  v12);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_1002A7208(uint64_t a1, const char *a2, _WORD *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  uint64_t v6 = sub_1002A7278(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_1002A7278(uint64_t a1, uint64_t a2, _WORD *a3)
{
  uint64_t v6 = sub_1002A96F8(cf, buf);
  if ((_DWORD)v6)
  {
    *a3 = *(_WORD *)buf;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    CFStringRef v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      uint64_t v19 = v8;
      __int16 v20 = 2112;
      uint64_t v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = a2;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &v14,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, uint16_t &, int) const",  "%s\n",  v12);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_1002A74B8(uint64_t a1, const char *a2, _WORD *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  uint64_t v6 = sub_1002A7528(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_1002A7528(uint64_t a1, uint64_t a2, _WORD *a3)
{
  uint64_t v6 = sub_1002A92D0(cf, a3);
  if ((v6 & 1) == 0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    CFStringRef v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      uint64_t v19 = v8;
      __int16 v20 = 2112;
      uint64_t v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = a2;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &v14,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, short &, int) const",  "%s\n",  v12);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_1002A775C(uint64_t a1, const char *a2, _DWORD *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  uint64_t v6 = sub_1002A77CC(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_1002A77CC(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v6 = sub_1002A9500(cf, buf);
  if ((_DWORD)v6)
  {
    *a3 = *(_DWORD *)buf;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    CFStringRef v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      *(void *)&uint8_t buf[4] = v8;
      __int16 v19 = 2112;
      uint64_t v20 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = a2;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &v14,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, uint32_t &, int) const",  "%s\n",  v12);
      if (v12 != buf) {
        free(v12);
      }
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_1002A7A0C(uint64_t a1, const char *a2, void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  uint64_t v6 = sub_1002A7A7C(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_1002A7A7C(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = sub_1002A9500(cf, a3);
  if ((v6 & 1) == 0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    CFStringRef v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      uint64_t v19 = v8;
      __int16 v20 = 2112;
      uint64_t v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = a2;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &v14,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, int64_t &, int) const",  "%s\n",  v12);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_1002A7CB0(uint64_t a1, const char *a2, _DWORD *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  uint64_t v6 = sub_1002A7D20(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_1002A7D20(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v6 = sub_1002A96F8(cf, a3);
  if ((v6 & 1) == 0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    CFStringRef v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      uint64_t v19 = v8;
      __int16 v20 = 2112;
      uint64_t v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = a2;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &v14,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, int &, int) const",  "%s\n",  v12);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_1002A7F54(uint64_t a1, const char *a2, void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  uint64_t v6 = sub_1002A7FC4(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_1002A7FC4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = sub_1002A98F0(cf, a3);
  if ((v6 & 1) == 0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    CFStringRef v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      uint64_t v19 = v8;
      __int16 v20 = 2112;
      uint64_t v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = a2;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &v14,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, long &, int) const",  "%s\n",  v12);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_1002A81F8(uint64_t a1, const char *a2, float *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  uint64_t v6 = sub_1002A832C(a1, (uint64_t)v5, &v9);
  if ((_DWORD)v6)
  {
    float v7 = v9;
    *a3 = v7;
  }

  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

float sub_1002A827C(uint64_t a1, uint64_t a2, float *a3)
{
  if (sub_1002A832C(a1, a2, &v5))
  {
    float result = v5;
    *a3 = result;
  }

  return result;
}

uint64_t sub_1002A82BC(uint64_t a1, const char *a2, void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  uint64_t v6 = sub_1002A832C(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_1002A832C(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = sub_1002A9AE8(cf, a3);
  if ((v6 & 1) == 0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    float v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      uint64_t v19 = v8;
      __int16 v20 = 2112;
      uint64_t v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = a2;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &v14,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, double &, int) const",  "%s\n",  v12);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

BOOL sub_1002A8560(uint64_t a1, const char *a2, std::string *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002A85D0(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002A85D0(uint64_t a1, uint64_t a2, std::string *a3)
{
  BOOL v6 = sub_1002AA05C((const __CFString *)cf, a3);
  if (!v6)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    float v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      uint64_t v19 = v8;
      __int16 v20 = 2112;
      uint64_t v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = a2;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &v14,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, std::string &, int) const",  "%s\n",  v12);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_1002A8804(uint64_t a1, const char *a2, CFTypeRef *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  uint64_t v6 = sub_1002A8874(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

uint64_t sub_1002A8874(uint64_t a1, const __CFString *a2, CFTypeRef *a3)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, const __CFString *, CFTypeRef *))(*(void *)a1 + 904LL))(a1, a2, &cf);
  if ((_DWORD)result)
  {
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == CFStringGetTypeID())
    {
      CFTypeRef v8 = cf;
      *a3 = cf;
      CFAutorelease(v8);
      return 1LL;
    }

    else
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      double v9 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        sub_1002A6C50(a2, &__p);
        uint64_t v10 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
        CFTypeID v11 = CFGetTypeID(cf);
        CFTypeID TypeID = CFStringGetTypeID();
        *(_DWORD *)std::stringbuf::string_type buf = 136446722;
        uint64_t v29 = (uint64_t)v10;
        __int16 v30 = 2050;
        CFTypeID v31 = v11;
        __int16 v32 = 2050;
        CFTypeID v33 = TypeID;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "type IDs do not match for key %{public}s - %{public}lu vs %{public}lu",  buf,  0x20u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        uint64_t v15 = qword_101934A78;
        sub_1002A6C50(a2, &v24);
        if ((v24.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int16 v16 = &v24;
        }
        else {
          __int16 v16 = (std::string *)v24.__r_.__value_.__r.__words[0];
        }
        CFTypeID v17 = CFGetTypeID(cf);
        CFTypeID v18 = CFStringGetTypeID();
        LODWORD(__p.__r_.__value_.__l.__data_) = 136446722;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v16;
        WORD2(__p.__r_.__value_.__r.__words[1]) = 2050;
        *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v17;
        HIWORD(__p.__r_.__value_.__r.__words[2]) = 2050;
        CFTypeID v27 = v18;
        uint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  17LL,  "type IDs do not match for key %{public}s - %{public}lu vs %{public}lu",  &__p,  32);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, CFStringRef &, int) const",  "%s\n",  v19);
      }

      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v13 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
        *(_DWORD *)std::stringbuf::string_type buf = 138412546;
        uint64_t v29 = v14;
        __int16 v30 = 2112;
        CFTypeID v31 = (CFTypeID)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        uint64_t v20 = qword_101934A78;
        std::string::size_type v21 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
        LODWORD(__p.__r_.__value_.__l.__data_) = 138412546;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v21;
        WORD2(__p.__r_.__value_.__r.__words[1]) = 2112;
        *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a2;
        LODWORD(v23) = 22;
        uint64_t v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &__p,  v23);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, CFStringRef &, int) const",  "%s\n",  v22);
      }

      CFRelease(cf);
      return 0LL;
    }
  }

  return result;
}

void sub_1002A8C9C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002A8CD4(uint64_t a1, const char *a2, const UInt8 **a3, _DWORD *a4, uint64_t a5)
{
  CFStringRef v9 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v10 = sub_1002A8D50(a1, (uint64_t)v9, a3, a4, a5);
  CFRelease(v9);
  return v10;
}

BOOL sub_1002A8D50(uint64_t a1, uint64_t a2, const UInt8 **a3, _DWORD *a4, uint64_t a5)
{
  if (!(*(unsigned int (**)(uint64_t, uint64_t, CFTypeRef *, uint64_t))(*(void *)a1 + 904LL))( a1,  a2,  &cf,  a5)) {
    return 0LL;
  }
  BOOL v9 = sub_1002AABD8(cf, a3, a4);
  if (!v9)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v10 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      uint64_t v22 = v11;
      __int16 v23 = 2112;
      uint64_t v24 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v13 = qword_101934A78;
      uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      int v17 = 138412546;
      uint64_t v18 = v14;
      __int16 v19 = 2112;
      uint64_t v20 = a2;
      uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &v17,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, const char *&, unsigned int &, int) const",  "%s\n",  v15);
    }
  }

  CFRelease(cf);
  return v9;
}

BOOL sub_1002A8F8C(uint64_t a1, const char *a2, void *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002A8FFC(a1, (uint64_t)v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002A8FFC(uint64_t a1, uint64_t a2, void *a3)
{
  BOOL v6 = sub_1002A9E3C(cf, a3);
  if (!v6)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    CFTypeID v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      *(_DWORD *)std::stringbuf::string_type buf = 138412546;
      uint64_t v19 = v8;
      __int16 v20 = 2112;
      uint64_t v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Unsupported type at %@:%@ (domain:key)",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 840LL))(a1);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = a2;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "Unsupported type at %@:%@ (domain:key)",  &v14,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, CLNameValuePair &, int) const",  "%s\n",  v12);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t sub_1002A9230(const void *a1, BOOL *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFBooleanGetTypeID() && v4 != CFNumberGetTypeID()) {
    return 0LL;
  }
  *a2 = CFBooleanGetValue((CFBooleanRef)a1) != 0;
  return 1LL;
}

uint64_t sub_1002A9298(const void *a1, _WORD *a2)
{
  uint64_t result = sub_1002A96F8(a1, &v4);
  if ((_DWORD)result) {
    *a2 = v4;
  }
  return result;
}

uint64_t sub_1002A92D0(const void *a1, _WORD *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFNumberGetTypeID())
  {
    CFTypeID v9 = CFGetTypeID(a1);
    if (v9 != CFBooleanGetTypeID()) {
      return 0LL;
    }
    uint64_t result = sub_1002A9230(a1, (BOOL *)buf);
    if (!(_DWORD)result) {
      return result;
    }
    *a2 = buf[0];
    return 1LL;
  }

  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt16Type, a2)) {
    return 1LL;
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182EEA8);
  }
  CFStringRef v5 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "could not get value", buf, 2u);
  }

  BOOL v6 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    v10[0] = 0;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not get value",  v10,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, short &)",  "%s\n",  v8);
    return 0LL;
  }

  return result;
}

uint64_t sub_1002A94C8(const void *a1, _DWORD *a2)
{
  uint64_t result = sub_1002A9500(a1, &v4);
  if ((_DWORD)result) {
    *a2 = v4;
  }
  return result;
}

uint64_t sub_1002A9500(const void *a1, void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFNumberGetTypeID())
  {
    CFTypeID v9 = CFGetTypeID(a1);
    if (v9 != CFBooleanGetTypeID()) {
      return 0LL;
    }
    uint64_t result = sub_1002A9230(a1, (BOOL *)buf);
    if (!(_DWORD)result) {
      return result;
    }
    *a2 = buf[0];
    return 1LL;
  }

  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt64Type, a2)) {
    return 1LL;
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182EEA8);
  }
  CFStringRef v5 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "could not get value", buf, 2u);
  }

  BOOL v6 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    v10[0] = 0;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not get value",  v10,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, int64_t &)",  "%s\n",  v8);
    return 0LL;
  }

  return result;
}

uint64_t sub_1002A96F8(const void *a1, _DWORD *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFNumberGetTypeID())
  {
    CFTypeID v9 = CFGetTypeID(a1);
    if (v9 != CFBooleanGetTypeID()) {
      return 0LL;
    }
    uint64_t result = sub_1002A9230(a1, (BOOL *)buf);
    if (!(_DWORD)result) {
      return result;
    }
    *a2 = buf[0];
    return 1LL;
  }

  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, a2)) {
    return 1LL;
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182EEA8);
  }
  CFStringRef v5 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "could not get value", buf, 2u);
  }

  BOOL v6 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    v10[0] = 0;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not get value",  v10,  2);
    sub_10029211C("Generic", 1LL, 0, 0LL, "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, int &)", "%s\n", v8);
    return 0LL;
  }

  return result;
}

uint64_t sub_1002A98F0(const void *a1, void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFNumberGetTypeID())
  {
    CFTypeID v9 = CFGetTypeID(a1);
    if (v9 != CFBooleanGetTypeID()) {
      return 0LL;
    }
    uint64_t result = sub_1002A9230(a1, (BOOL *)buf);
    if (!(_DWORD)result) {
      return result;
    }
    *a2 = buf[0];
    return 1LL;
  }

  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberLongType, a2)) {
    return 1LL;
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182EEA8);
  }
  CFStringRef v5 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "could not get value", buf, 2u);
  }

  BOOL v6 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v6)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    v10[0] = 0;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not get value",  v10,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, long &)",  "%s\n",  v8);
    return 0LL;
  }

  return result;
}

uint64_t sub_1002A9AE8(const void *a1, void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFNumberGetTypeID())
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134349312;
      CFTypeID v17 = CFGetTypeID(a1);
      __int16 v18 = 2050;
      CFTypeID TypeID = CFNumberGetTypeID();
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "type IDs do not match - %{public}lu vs %{public}lu",  buf,  0x16u);
    }

    BOOL v7 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (!v7) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    uint64_t v8 = qword_101934A78;
    int v12 = 134349312;
    CFTypeID v13 = CFGetTypeID(a1);
    __int16 v14 = 2050;
    CFTypeID v15 = CFNumberGetTypeID();
    CFTypeID v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v8,  17LL,  "type IDs do not match - %{public}lu vs %{public}lu",  &v12,  22);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, double &)",  "%s\n",  v9);
LABEL_12:
    free(v9);
    return 0LL;
  }

  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberFloat64Type, a2)) {
    return 1LL;
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182EEA8);
  }
  uint64_t v10 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "could not get value", buf, 2u);
  }

  BOOL v11 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v11)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    LOWORD(v12) = 0;
    CFTypeID v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not get value",  &v12,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, double &)",  "%s\n",  v9);
    goto LABEL_12;
  }

  return result;
}

BOOL sub_1002A9E3C(const void *a1, void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (v4 == TypeID)
  {
    sub_1002AFBC8(a2, (CFDictionaryRef)a1);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134349312;
      CFTypeID v15 = CFGetTypeID(a1);
      __int16 v16 = 2050;
      CFTypeID v17 = CFDictionaryGetTypeID();
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "type IDs do not match - %{public}lu vs %{public}lu",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v8 = qword_101934A78;
      int v10 = 134349312;
      CFTypeID v11 = CFGetTypeID(a1);
      __int16 v12 = 2050;
      CFTypeID v13 = CFDictionaryGetTypeID();
      CFTypeID v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v8,  17LL,  "type IDs do not match - %{public}lu vs %{public}lu",  &v10,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, CLNameValuePair &)",  "%s\n",  v9);
    }
  }

  return v4 == TypeID;
}

BOOL sub_1002AA05C(const __CFString *cf, std::string *a2)
{
  if (!cf) {
    goto LABEL_8;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFStringGetTypeID())
  {
    CStringPtr = CFStringGetCStringPtr(cf, 0x8000100u);
    if (CStringPtr)
    {
      std::string::assign(a2, CStringPtr);
      return 1LL;
    }

    else
    {
      *(void *)tm usedBufLen = 0LL;
      v28.length = CFStringGetLength(cf);
      v28.location = 0LL;
      CFStringGetBytes(cf, v28, 0x8000100u, 0, 0, 0LL, 0LL, (CFIndex *)usedBufLen);
      uint64_t v14 = *(void *)usedBufLen + 1LL;
      *(void *)tm usedBufLen = v14;
      CFTypeID v15 = (char *)operator new[](v14);
      int CString = CFStringGetCString(cf, v15, v14, 0x8000100u);
      BOOL v6 = CString != 0;
      if (CString)
      {
        std::string::assign(a2, v15);
      }

      else
      {
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        uint64_t v19 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)std::stringbuf::string_type buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "could not convert to C string", buf, 2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_10182EEA8);
          }
          v24[0] = 0;
          __int16 v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not convert to C string",  v24,  2);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, std::string &)",  "%s\n",  v23);
        }
      }

      operator delete[](v15);
    }

    return v6;
  }

  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 != CFDataGetTypeID())
  {
LABEL_8:
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    __int16 v12 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      if (cf) {
        CFTypeID v13 = CFGetTypeID(cf);
      }
      else {
        CFTypeID v13 = -1LL;
      }
      *(_DWORD *)std::stringbuf::string_type buf = 134349056;
      CFTypeID v27 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "#Warning type IDs do not match - %{public}lu",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v20 = qword_101934A78;
      if (cf) {
        CFTypeID v21 = CFGetTypeID(cf);
      }
      else {
        CFTypeID v21 = -1LL;
      }
      *(_DWORD *)tm usedBufLen = 134349056;
      *(void *)&usedBufLen[4] = v21;
      uint64_t v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  0LL,  "#Warning type IDs do not match - %{public}lu",  usedBufLen,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, std::string &)",  "%s\n",  v22);
    }

    std::string::assign(a2, "");
    return 0LL;
  }

  BytePtr = (const char *)CFDataGetBytePtr((CFDataRef)cf);
  int Length = CFDataGetLength((CFDataRef)cf);
  int v10 = Length;
  if (BytePtr) {
    return sub_1002A4F04(BytePtr, Length, (uint64_t)a2);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182EEA8);
  }
  CFTypeID v17 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 67240192;
    LODWORD(v27) = v10;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "can't convert %{public}u data bytes", buf, 8u);
  }

  BOOL v6 = 0LL;
  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    *(_DWORD *)tm usedBufLen = 67240192;
    *(_DWORD *)&usedBufLen[4] = v10;
    __int16 v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "can't convert %{public}u data bytes",  usedBufLen,  8);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, std::string &)",  "%s\n",  v18);
    return 0LL;
  }

  return v6;
}

BOOL sub_1002AA610(uint64_t a1, const __CFString *a2, CFTypeRef *a3)
{
  CFTypeID v5 = CFGetTypeID(cf);
  BOOL v6 = v5 == CFArrayGetTypeID();
  BOOL v7 = v6;
  if (v6)
  {
    *a3 = cf;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    uint64_t v8 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, &__p);
      CFTypeID v9 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
      CFTypeID v10 = CFGetTypeID(cf);
      CFTypeID TypeID = CFArrayGetTypeID();
      *(_DWORD *)std::stringbuf::string_type buf = 136446722;
      __int16 v23 = v9;
      __int16 v24 = 2050;
      CFTypeID v25 = v10;
      __int16 v26 = 2050;
      CFTypeID v27 = TypeID;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "type IDs do not match for key %{public}s - %{public}lu vs %{public}lu",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v13 = qword_101934A78;
      uint64_t v14 = &v18;
      sub_1002A6C50(a2, &v18);
      if ((v18.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v14 = (std::string *)v18.__r_.__value_.__r.__words[0];
      }
      CFTypeID v15 = CFGetTypeID(cf);
      CFTypeID v16 = CFArrayGetTypeID();
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446722;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2050;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v15;
      HIWORD(__p.__r_.__value_.__r.__words[2]) = 2050;
      CFTypeID v21 = v16;
      CFTypeID v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  17LL,  "type IDs do not match for key %{public}s - %{public}lu vs %{public}lu",  &__p,  32);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, CFArrayRef &) const",  "%s\n",  v17);
    }
  }

  CFAutorelease(cf);
  return v7;
}

void sub_1002AA8BC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002AA8F4(uint64_t a1, const __CFString *a2, CFTypeRef *a3)
{
  CFTypeID v5 = CFGetTypeID(cf);
  BOOL v6 = v5 == CFDataGetTypeID();
  BOOL v7 = v6;
  if (v6)
  {
    *a3 = cf;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    uint64_t v8 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, &__p);
      CFTypeID v9 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
      CFTypeID v10 = CFGetTypeID(cf);
      CFTypeID TypeID = CFDataGetTypeID();
      *(_DWORD *)std::stringbuf::string_type buf = 136446722;
      __int16 v24 = v9;
      __int16 v25 = 2050;
      CFTypeID v26 = v10;
      __int16 v27 = 2050;
      CFTypeID v28 = TypeID;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "type IDs do not match for key %{public}s - %{public}lu vs %{public}lu",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v13 = qword_101934A78;
      uint64_t v14 = &v19;
      sub_1002A6C50(a2, &v19);
      if ((v19.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v14 = (std::string *)v19.__r_.__value_.__r.__words[0];
      }
      CFTypeID v15 = CFGetTypeID(cf);
      CFTypeID v16 = CFDataGetTypeID();
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446722;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v14;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2050;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v15;
      HIWORD(__p.__r_.__value_.__r.__words[2]) = 2050;
      CFTypeID v22 = v16;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  17LL,  "type IDs do not match for key %{public}s - %{public}lu vs %{public}lu",  &__p,  32);
      std::string v18 = v17;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::get(CFStringRef, CFDataRef &, int) const",  "%s\n",  v18);
    }
  }

  CFAutorelease(cf);
  return v7;
}

void sub_1002AABA0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002AABD8(const void *a1, const UInt8 **a2, _DWORD *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  CFTypeID TypeID = CFDataGetTypeID();
  if (v6 == TypeID)
  {
    *a2 = CFDataGetBytePtr((CFDataRef)a1);
    *a3 = CFDataGetLength((CFDataRef)a1);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    uint64_t v8 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134349312;
      CFTypeID v17 = CFGetTypeID(a1);
      __int16 v18 = 2050;
      CFTypeID v19 = CFDataGetTypeID();
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "type IDs do not match - %{public}lu vs %{public}lu",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      int v12 = 134349312;
      CFTypeID v13 = CFGetTypeID(a1);
      __int16 v14 = 2050;
      CFTypeID v15 = CFDataGetTypeID();
      CFTypeID v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "type IDs do not match - %{public}lu vs %{public}lu",  &v12,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, const char *&, unsigned int &)",  "%s\n",  v11);
    }
  }

  return v6 == TypeID;
}

uint64_t sub_1002AAE08(uint64_t a1, const __CFString *a2, uint64_t *a3, int a4)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, const __CFString *, CFTypeRef *))(*(void *)a1 + 912LL))(a1, a2, &cf);
  if ((_DWORD)result)
  {
    *a3 = 0LL;
    CFTypeID v8 = CFGetTypeID(cf);
    if (v8 == CFArrayGetTypeID())
    {
      CFIndex v9 = a4 & ~(a4 >> 31);
      if (CFArrayGetCount((CFArrayRef)cf) > v9)
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, v9);
LABEL_34:
        *a3 = (uint64_t)ValueAtIndex;
        CFRetain(ValueAtIndex);
        CFRelease(cf);
        return 1LL;
      }

      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      __int16 v18 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        sub_1002A6C50(a2, (std::string *)__p);
        int v19 = SBYTE3(v32);
        uint64_t v20 = *(_BYTE **)__p;
        CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
        CFTypeID v22 = __p;
        *(_DWORD *)std::stringbuf::string_type buf = 136446722;
        if (v19 < 0) {
          CFTypeID v22 = v20;
        }
        *(void *)CFTypeID v34 = v22;
        *(_WORD *)&v34[8] = 1026;
        *(_DWORD *)&_BYTE v34[10] = v9;
        __int16 v35 = 2050;
        int v36 = (_BYTE *)Count;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "specified index is out of range for key %{public}s (%{public}d of %{public}ld)",  buf,  0x1Cu);
        if (SBYTE3(v32) < 0) {
          operator delete(*(void **)__p);
        }
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_31;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v23 = qword_101934A78;
      sub_1002A6C50(a2, &v28);
      int size = (char)v28.__r_.__value_.__s.__size_;
      std::string::size_type v25 = v28.__r_.__value_.__r.__words[0];
      CFIndex v26 = CFArrayGetCount((CFArrayRef)cf);
      __int16 v27 = &v28;
      *(_DWORD *)std::string __p = 136446722;
      if (size < 0) {
        __int16 v27 = (std::string *)v25;
      }
      *(void *)&__p[4] = v27;
      *(_WORD *)&_BYTE __p[12] = 1026;
      *(_DWORD *)&__p[14] = v9;
      __int16 v31 = 2050;
      CFIndex v32 = v26;
      CFTypeID v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v23,  17LL,  "specified index is out of range for key %{public}s (%{public}d of %{public}ld)",  __p,  28);
    }

    else
    {
      if (a4 < 1)
      {
        ValueAtIndex = cf;
        goto LABEL_34;
      }

      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      CFTypeID v11 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        CFTypeID v12 = CFGetTypeID(cf);
        sub_1002A6C50(a2, (std::string *)__p);
        CFTypeID v13 = (v32 & 0x80000000LL) == 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)std::stringbuf::string_type buf = 67240706;
        *(_DWORD *)CFTypeID v34 = a4;
        *(_WORD *)&v34[4] = 2050;
        *(void *)&v34[6] = v12;
        __int16 v35 = 2082;
        int v36 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "specified index %{public}d not applicable to type %{public}lu for key %{public}s",  buf,  0x1Cu);
        if (SBYTE3(v32) < 0) {
          operator delete(*(void **)__p);
        }
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_31;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v14 = qword_101934A78;
      CFTypeID v15 = CFGetTypeID(cf);
      sub_1002A6C50(a2, &v28);
      if ((v28.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        CFTypeID v16 = &v28;
      }
      else {
        CFTypeID v16 = (std::string *)v28.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string __p = 67240706;
      *(_DWORD *)&__p[4] = a4;
      *(_WORD *)&__p[8] = 2050;
      *(void *)&__p[10] = v15;
      __int16 v31 = 2082;
      CFIndex v32 = (CFIndex)v16;
      CFTypeID v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  17LL,  "specified index %{public}d not applicable to type %{public}lu for key %{public}s",  __p,  28);
    }

    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::copyInternal(CFStringRef, CFTypeRef &, int) const",  "%s\n",  v17);
LABEL_31:
    CFRelease(cf);
    uint64_t result = *a3;
    if (*a3)
    {
      CFRelease((CFTypeRef)result);
      return 0LL;
    }
  }

  return result;
}

void sub_1002AB2D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002AB310(uint64_t a1, const void *a2, void *a3)
{
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 8), a2);
  CFTypeID v5 = Value;
  *a3 = Value;
  if (Value) {
    CFRetain(Value);
  }
  return v5 != 0LL;
}

BOOL sub_1002AB350(uint64_t a1, const void *a2)
{
  return CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 8), a2) != 0;
}

uint64_t sub_1002AB370(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  (*(void (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 896LL))(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return 1LL;
}

uint64_t sub_1002AB3DC(uint64_t a1)
{
  return 1LL;
}

BOOL sub_1002AB3FC(uint64_t a1, const char *a2, _BYTE *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AB464(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AB464(uint64_t a1, const __CFString *a2, _BYTE *a3)
{
  CFStringRef v5 = (CFTypeRef *)&kCFBooleanTrue;
  if (!*a3) {
    CFStringRef v5 = (CFTypeRef *)&kCFBooleanFalse;
  }
  CFTypeRef v6 = *v5;
  CFRetain(*v5);
  if (v6)
  {
    (*(void (**)(uint64_t, const __CFString *, CFTypeRef))(*(void *)a1 + 896LL))(a1, a2, v6);
    CFRelease(v6);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      CFTypeID v8 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v14 = 136446210;
      CFTypeID v15 = p_buf;
      CFTypeID v12 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v10,  17LL,  "could not create cf type for key %{public}s",  &v14,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::set(CFStringRef, const BOOL &)",  "%s\n",  (const char *)v12);
      if (v12 != __p) {
        free(v12);
      }
    }
  }

  return v6 != 0LL;
}

BOOL sub_1002AB6D8(uint64_t a1, const char *a2, unsigned __int16 *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AB740(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AB740(uint64_t a1, const __CFString *a2, unsigned __int16 *a3)
{
  LODWORD(valuePtr[0].__r_.__value_.__l.__data_) = *a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, valuePtr);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, valuePtr);
      BOOL v7 = (valuePtr[0].__r_.__value_.__s.__size_ & 0x80u) == 0
         ? valuePtr
         : (std::string *)valuePtr[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(valuePtr, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  valuePtr,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::set(CFStringRef, const uint16_t &)",  "%s\n",  (const char *)v11);
      if (v11 != valuePtr) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002AB9B0(uint64_t a1, const char *a2, const void *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002ABA18(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002ABA18(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::set(CFStringRef, const short &)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002ABC7C(uint64_t a1, const char *a2, unsigned int *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002ABCE4(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002ABCE4(uint64_t a1, const __CFString *a2, unsigned int *a3)
{
  valuePtr[0].__r_.__value_.__r.__words[0] = *a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, valuePtr);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, valuePtr);
      BOOL v7 = (valuePtr[0].__r_.__value_.__s.__size_ & 0x80u) == 0
         ? valuePtr
         : (std::string *)valuePtr[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(valuePtr, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  valuePtr,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::set(CFStringRef, const uint32_t &)",  "%s\n",  (const char *)v11);
      if (v11 != valuePtr) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002ABF54(uint64_t a1, const char *a2, const void *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002ABFBC(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002ABFBC(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::set(CFStringRef, const int64_t &)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002AC220(uint64_t a1, const char *a2, const void *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AC288(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AC288(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::set(CFStringRef, const int &)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002AC4EC(uint64_t a1, const char *a2, const void *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AC554(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AC554(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::set(CFStringRef, const long &)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002AC7B8(uint64_t a1, const char *a2, const void *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AC820(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AC820(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat64Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 896LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::set(CFStringRef, const double &)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002ACA84(uint64_t a1, const char *a2, char *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002ACAEC(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002ACAEC(uint64_t a1, const __CFString *a2, char *cStr)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFStringRef))(*(void *)a1 + 896LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::set(CFStringRef, const char *)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002ACD58(uint64_t a1, const char *a2, char *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  if (a3[23] >= 0) {
    BOOL v6 = a3;
  }
  else {
    BOOL v6 = *(char **)a3;
  }
  BOOL v7 = sub_1002ACAEC(a1, v5, v6);
  if (v5) {
    CFRelease(v5);
  }
  return v7;
}

BOOL sub_1002ACDCC(uint64_t a1, const __CFString *a2, char *a3)
{
  if (a3[23] < 0) {
    a3 = *(char **)a3;
  }
  return sub_1002ACAEC(a1, a2, a3);
}

uint64_t sub_1002ACDE0(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  (*(void (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 896LL))(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return 1LL;
}

uint64_t sub_1002ACE4C(uint64_t a1)
{
  return 1LL;
}

BOOL sub_1002ACE6C(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002ACED4(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002ACED4(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, *(CFDictionaryRef *)(a3 + 8));
  if (Copy)
  {
    (*(void (**)(uint64_t, const __CFString *, CFDictionaryRef))(*(void *)a1 + 896LL))(a1, a2, Copy);
    CFRelease(Copy);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::set(CFStringRef, const CLNameValuePair &)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return Copy != 0LL;
}

CFTypeRef sub_1002AD138(_BYTE *a1)
{
  uint64_t v1 = (CFTypeRef *)&kCFBooleanTrue;
  if (!*a1) {
    uint64_t v1 = (CFTypeRef *)&kCFBooleanFalse;
  }
  CFTypeRef v2 = *v1;
  CFRetain(*v1);
  return v2;
}

CFNumberRef sub_1002AD17C(unsigned __int16 *a1)
{
  int valuePtr = *a1;
  return CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
}

CFNumberRef sub_1002AD1B4(void *valuePtr)
{
  return CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, valuePtr);
}

CFNumberRef sub_1002AD1CC(void *valuePtr)
{
  return CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, valuePtr);
}

CFNumberRef sub_1002AD1E4(void *valuePtr)
{
  return CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat64Type, valuePtr);
}

uint64_t sub_1002AD1FC(CFMutableDictionaryRef *a1, const void *a2, const void *a3)
{
  return (*((uint64_t (**)(CFMutableDictionaryRef *))*a1 + 106))(a1);
}

uint64_t sub_1002AD22C(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  (*(void (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 928LL))(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return 1LL;
}

uint64_t sub_1002AD298(uint64_t a1)
{
  return 1LL;
}

BOOL sub_1002AD2B8(uint64_t a1, const char *a2, _BYTE *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AD320(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AD320(uint64_t a1, const __CFString *a2, _BYTE *a3)
{
  CFStringRef v5 = (CFTypeRef *)&kCFBooleanTrue;
  if (!*a3) {
    CFStringRef v5 = (CFTypeRef *)&kCFBooleanFalse;
  }
  CFTypeRef v6 = *v5;
  CFRetain(*v5);
  if (v6)
  {
    (*(void (**)(uint64_t, const __CFString *, CFTypeRef))(*(void *)a1 + 928LL))(a1, a2, v6);
    CFRelease(v6);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      CFTypeID v8 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v10 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v14 = 136446210;
      CFTypeID v15 = p_buf;
      CFTypeID v12 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v10,  17LL,  "could not create cf type for key %{public}s",  &v14,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::insert(CFStringRef, const BOOL &)",  "%s\n",  (const char *)v12);
      if (v12 != __p) {
        free(v12);
      }
    }
  }

  return v6 != 0LL;
}

BOOL sub_1002AD594(uint64_t a1, const char *a2, unsigned __int16 *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AD5FC(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AD5FC(uint64_t a1, const __CFString *a2, unsigned __int16 *a3)
{
  LODWORD(valuePtr[0].__r_.__value_.__l.__data_) = *a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, valuePtr);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, valuePtr);
      BOOL v7 = (valuePtr[0].__r_.__value_.__s.__size_ & 0x80u) == 0
         ? valuePtr
         : (std::string *)valuePtr[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(valuePtr, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  valuePtr,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::insert(CFStringRef, const uint16_t &)",  "%s\n",  (const char *)v11);
      if (v11 != valuePtr) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002AD86C(uint64_t a1, const char *a2, const void *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AD8D4(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AD8D4(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt16Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::insert(CFStringRef, const short &)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002ADB38(uint64_t a1, const char *a2, unsigned int *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002ADBA0(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002ADBA0(uint64_t a1, const __CFString *a2, unsigned int *a3)
{
  valuePtr[0].__r_.__value_.__r.__words[0] = *a3;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, valuePtr);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, valuePtr);
      BOOL v7 = (valuePtr[0].__r_.__value_.__s.__size_ & 0x80u) == 0
         ? valuePtr
         : (std::string *)valuePtr[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(valuePtr, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  valuePtr,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::insert(CFStringRef, const uint32_t &)",  "%s\n",  (const char *)v11);
      if (v11 != valuePtr) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002ADE10(uint64_t a1, const char *a2, const void *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002ADE78(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002ADE78(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::insert(CFStringRef, const int64_t &)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002AE0DC(uint64_t a1, const char *a2, const void *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AE144(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AE144(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v14 = 136446210;
      CFTypeID v15 = p_buf;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v14,  12);
      CFTypeID v12 = v11;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::insert(CFStringRef, const int &)",  "%s\n",  (const char *)v12);
      if (v12 != __p) {
        free(v12);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002AE3A8(uint64_t a1, const char *a2, const void *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AE410(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AE410(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::insert(CFStringRef, const long &)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002AE674(uint64_t a1, const char *a2, const void *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AE6DC(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AE6DC(uint64_t a1, const __CFString *a2, const void *a3)
{
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat64Type, a3);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFNumberRef))(*(void *)a1 + 928LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v14 = 136446210;
      CFTypeID v15 = p_buf;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v14,  12);
      CFTypeID v12 = v11;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::insert(CFStringRef, const double &)",  "%s\n",  (const char *)v12);
      if (v12 != __p) {
        free(v12);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002AE940(uint64_t a1, const char *a2, char *a3)
{
  CFNumberRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AE9A8(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AE9A8(uint64_t a1, const __CFString *a2, char *cStr)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
  if (v5)
  {
    (*(void (**)(uint64_t, const __CFString *, CFStringRef))(*(void *)a1 + 928LL))(a1, a2, v5);
    CFRelease(v5);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::insert(CFStringRef, const char *)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return v5 != 0LL;
}

BOOL sub_1002AEC14(uint64_t a1, const char *a2, char *a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  if (a3[23] >= 0) {
    BOOL v6 = a3;
  }
  else {
    BOOL v6 = *(char **)a3;
  }
  BOOL v7 = sub_1002AE9A8(a1, v5, v6);
  if (v5) {
    CFRelease(v5);
  }
  return v7;
}

BOOL sub_1002AEC88(uint64_t a1, const __CFString *a2, char *a3)
{
  if (a3[23] < 0) {
    a3 = *(char **)a3;
  }
  return sub_1002AE9A8(a1, a2, a3);
}

uint64_t sub_1002AEC9C(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  (*(void (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 928LL))(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return 1LL;
}

uint64_t sub_1002AED08(uint64_t a1)
{
  return 1LL;
}

BOOL sub_1002AED28(uint64_t a1, const char *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  BOOL v6 = sub_1002AED90(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

BOOL sub_1002AED90(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, *(CFDictionaryRef *)(a3 + 8));
  if (Copy)
  {
    (*(void (**)(uint64_t, const __CFString *, CFDictionaryRef))(*(void *)a1 + 928LL))(a1, a2, Copy);
    CFRelease(Copy);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    BOOL v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(a2, __p);
      BOOL v7 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(buf.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "could not create cf type for key %{public}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = qword_101934A78;
      sub_1002A6C50(a2, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
      int v13 = 136446210;
      int v14 = p_buf;
      CFTypeID v11 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  17LL,  "could not create cf type for key %{public}s",  &v13,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::insert(CFStringRef, const CLNameValuePair &)",  "%s\n",  (const char *)v11);
      if (v11 != __p) {
        free(v11);
      }
    }
  }

  return Copy != 0LL;
}

uint64_t sub_1002AEFF4(uint64_t a1, uint64_t a2, const void *a3)
{
  if ((*(unsigned int (**)(uint64_t, uint64_t, CFTypeRef *))(*(void *)a1 + 912LL))(a1, a2, &arg))
  {
    CFAutorelease(arg);
    CFTypeID v6 = CFGetTypeID(arg);
    if (v6 == CFArrayGetTypeID())
    {
      CFMutableDictionaryRef Mutable = (void *)arg;
    }

    else
    {
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      CFAutorelease(Mutable);
      CFArrayAppendValue((CFMutableArrayRef)Mutable, arg);
    }

    CFTypeID v8 = CFGetTypeID(a3);
    if (v8 == CFArrayGetTypeID())
    {
      v11.length = CFArrayGetCount((CFArrayRef)a3);
      v11.location = 0LL;
      CFArrayAppendArray((CFMutableArrayRef)Mutable, (CFArrayRef)a3, v11);
    }

    else
    {
      CFArrayAppendValue((CFMutableArrayRef)Mutable, a3);
    }
  }

  else
  {
    CFMutableDictionaryRef Mutable = (void *)a3;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)a1 + 896LL))(a1, a2, Mutable);
}

uint64_t sub_1002AF100(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 856LL))(a1);
}

CFIndex sub_1002AF10C(uint64_t a1)
{
  return CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 8));
}

uint64_t sub_1002AF124(uint64_t a1, const char *a2)
{
  CFStringRef v3 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, CFStringRef))(*(void *)a1 + 864LL))(a1, v3);
  CFRelease(v3);
  return v4;
}

uint64_t sub_1002AF180(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 864LL))(a1);
}

uint64_t sub_1002AF18C(uint64_t a1, uint64_t a2)
{
  CFTypeID v2 = CFGetTypeID(cf);
  if (v2 == CFArrayGetTypeID()) {
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
  }
  else {
    CFIndex Count = 1LL;
  }
  CFRelease(cf);
  return Count;
}

BOOL sub_1002AF200(uint64_t a1)
{
  return (*(int (**)(uint64_t))(*(void *)a1 + 856LL))(a1) < 1;
}

BOOL sub_1002AF224(uint64_t a1, const char *a2)
{
  CFStringRef v3 = CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  LODWORD(a1) = (*(uint64_t (**)(uint64_t, CFStringRef))(*(void *)a1 + 864LL))(a1, v3);
  CFRelease(v3);
  return (int)a1 < 1;
}

BOOL sub_1002AF284(uint64_t a1)
{
  return (*(int (**)(uint64_t))(*(void *)a1 + 864LL))(a1) < 1;
}

BOOL sub_1002AF2A8(uint64_t a1, CFDataRef *a2)
{
  CFDataRef Data = CFPropertyListCreateData( kCFAllocatorDefault,  *(CFPropertyListRef *)(a1 + 8),  kCFPropertyListXMLFormat_v1_0,  0LL,  0LL);
  *a2 = Data;
  return Data != 0LL;
}

uint64_t sub_1002AF2F4(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = CFWriteStreamCreateWithAllocatedBuffers(kCFAllocatorDefault, kCFAllocatorDefault);
  CFErrorRef error = 0LL;
  if (v4)
  {
    CFStringRef v5 = v4;
    if (!CFWriteStreamOpen(v4))
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v9 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "could not open write stream",  (uint8_t *)buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_35;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      LOWORD(v20.__r_.__value_.__l.__data_) = 0;
      uint64_t v10 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not open write stream",  &v20,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::serializeBinary(CFDataRef *) const",  "%s\n",  (const char *)v10);
      if (v10 == buf) {
        goto LABEL_35;
      }
LABEL_51:
      free(v10);
LABEL_35:
      uint64_t v7 = 0LL;
LABEL_36:
      CFRelease(v5);
      if (error) {
        CFRelease(error);
      }
      return v7;
    }

    CFIndex v6 = CFPropertyListWrite(*(CFPropertyListRef *)(a1 + 8), v5, kCFPropertyListBinaryFormat_v1_0, 0LL, &error);
    if (!error && v6)
    {
      *a2 = CFWriteStreamCopyProperty(v5, kCFStreamPropertyDataWritten);
      CFWriteStreamClose(v5);
      uint64_t v7 = 1LL;
      goto LABEL_36;
    }

    if (error)
    {
      CFIndex Code = CFErrorGetCode(error);
      if (error)
      {
        Domain = CFErrorGetDomain(error);
        goto LABEL_26;
      }
    }

    else
    {
      CFIndex Code = 0LL;
    }

    Domain = @"unknown error";
LABEL_26:
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    int v13 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      sub_1002A6C50(Domain, buf);
      int v14 = (buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? buf : (std::string *)buf[0].__r_.__value_.__r.__words[0];
      LODWORD(v20.__r_.__value_.__l.__data_) = 134349314;
      *(std::string::size_type *)((char *)v20.__r_.__value_.__r.__words + 4) = Code;
      WORD2(v20.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&v20.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v14;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "could not write data, error code, %{public}ld, error domain, %{public}s",  (uint8_t *)&v20,  0x16u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_35;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    uint64_t v17 = qword_101934A78;
    sub_1002A6C50(Domain, &v20);
    if ((v20.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int16 v18 = &v20;
    }
    else {
      __int16 v18 = (std::string *)v20.__r_.__value_.__r.__words[0];
    }
    int v21 = 134349314;
    CFIndex v22 = Code;
    __int16 v23 = 2082;
    __int16 v24 = v18;
    uint64_t v10 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v17,  17LL,  "could not write data, error code, %{public}ld, error domain, %{public}s",  &v21,  22);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::serializeBinary(CFDataRef *) const",  "%s\n",  (const char *)v10);
    if (v10 == buf) {
      goto LABEL_35;
    }
    goto LABEL_51;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182EEA8);
  }
  CFTypeID v8 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "could not create write stream",  (uint8_t *)buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    LOWORD(v20.__r_.__value_.__l.__data_) = 0;
    CFTypeID v16 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "could not create write stream",  &v20,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::serializeBinary(CFDataRef *) const",  "%s\n",  (const char *)v16);
    if (v16 != buf) {
      free(v16);
    }
  }

  return 0LL;
}

BOOL sub_1002AF848(void *a1, const __CFData *a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  CFErrorRef error = 0LL;
  CFPropertyListRef v5 = CFPropertyListCreateWithData(kCFAllocatorDefault, a2, 1uLL, 0LL, &error);
  if (v5)
  {
    CFIndex v6 = (const void *)a1[1];
    if (v6) {
      CFRelease(v6);
    }
    a1[1] = v5;
    (*(void (**)(void *))(*a1 + 848LL))(a1);
    goto LABEL_21;
  }

  if (!error)
  {
    CFIndex Code = 0LL;
    goto LABEL_9;
  }

  CFIndex Code = CFErrorGetCode(error);
  if (!error)
  {
LABEL_9:
    Domain = @"unknown error";
    goto LABEL_10;
  }

  Domain = CFErrorGetDomain(error);
LABEL_10:
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182EEA8);
  }
  uint64_t v9 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
  {
    if (Domain)
    {
      sub_1002A6C50(Domain, __p);
      if ((__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v10 = __p;
      }
      else {
        uint64_t v10 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 134349314;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = Code;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v10;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "could not create intermediate property list - %{public}ld (%{public}s)",  (uint8_t *)&buf,  0x16u);
    }

    else
    {
      LODWORD(buf.__r_.__value_.__l.__data_) = 134349314;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = Code;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)"unknown error";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "could not create intermediate property list - %{public}ld (%{public}s)",  (uint8_t *)&buf,  0x16u);
    }
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    uint64_t v12 = qword_101934A78;
    if (Domain)
    {
      sub_1002A6C50(Domain, &buf);
      if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_std::string buf = &buf;
      }
      else {
        p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
      }
    }

    else
    {
      p_std::string buf = (std::string *)"unknown error";
    }

    int v17 = 134349314;
    CFIndex v18 = Code;
    __int16 v19 = 2082;
    std::string v20 = p_buf;
    int v14 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v12,  17LL,  "could not create intermediate property list - %{public}ld (%{public}s)",  &v17,  22);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNameValuePair::deserialize(const CFDataRef)",  "%s\n",  (const char *)v14);
    if (v14 != __p) {
      free(v14);
    }
  }

void sub_1002AFB8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1002AFBC8(void *a1, CFDictionaryRef theDict)
{
  if (theDict)
  {
    uint64_t v4 = (const void *)a1[1];
    if (v4) {
      CFRelease(v4);
    }
    a1[1] = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, theDict);
    uint64_t v5 = 106LL;
  }

  else
  {
    uint64_t v5 = 109LL;
  }

  return (*(uint64_t (**)(void *))(*a1 + 8 * v5))(a1);
}

void sub_1002AFC2C(uint64_t a1)
{
  __p[0] = 0LL;
  __p[1] = 0LL;
  uint64_t v6 = 0LL;
  (*(void (**)(uint64_t, void **))(*(void *)a1 + 800LL))(a1, __p);
  if (qword_101934A80 != -1) {
    dispatch_once(&qword_101934A80, &stru_10182EEE8);
  }
  uint64_t v1 = (os_log_s *)qword_101934A88;
  if (os_log_type_enabled((os_log_t)qword_101934A88, OS_LOG_TYPE_DEBUG))
  {
    CFTypeID v2 = __p;
    if (v6 < 0) {
      CFTypeID v2 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v10 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "%s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A80 != -1) {
      dispatch_once(&qword_101934A80, &stru_10182EEE8);
    }
    CFStringRef v3 = __p;
    if (v6 < 0) {
      CFStringRef v3 = (void **)__p[0];
    }
    int v7 = 136315138;
    CFTypeID v8 = v3;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A88,  2LL,  "%s",  (const char *)&v7);
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLNameValuePair::print() const", "%s\n", v4);
  }

  if (SHIBYTE(v6) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002AFE18( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AFE38(uint64_t a1, std::string *this)
{
  uint64_t v4 = *(const __CFDictionary **)(a1 + 8);
  if (v4 && CFDictionaryGetCount(v4))
  {
    memset(&context, 0, sizeof(context));
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 8), (CFDictionaryApplierFunction)sub_1002AFEE0, &context);
    std::string::operator=(this, &context);
  }

  else
  {
    std::string::assign(this, "<empty>\n");
  }

void sub_1002AFEC4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002AFEE0(const __CFString *a1, const __CFString *a2, std::string *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    memset(&__p, 0, sizeof(__p));
    sub_1002AA05C(a1, &__p);
    CFTypeID v7 = CFGetTypeID(a2);
    if (v7 == CFDictionaryGetTypeID())
    {
      int size = (char)__p.__r_.__value_.__s.__size_;
      std::string::size_type v9 = __p.__r_.__value_.__r.__words[0];
      CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a2);
      uint64_t p_p = &__p;
      if (size < 0) {
        uint64_t p_p = (std::string *)v9;
      }
      snprintf(__str, 0x100uLL, "%s = <dictionary (%ld entries)>:\n", (const char *)p_p, Count);
      std::string::append(a3, __str);
      CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)sub_1002AFEE0, a3);
    }

    else
    {
      CFTypeID v14 = CFGetTypeID(a2);
      if (v14 == CFArrayGetTypeID())
      {
        v15.length = CFArrayGetCount((CFArrayRef)a2);
        CFTypeID v16 = &__p;
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          CFTypeID v16 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        context.__r_.__value_.__r.__words[0] = (std::string::size_type)v16;
        LODWORD(context.__r_.__value_.__r.__words[1]) = 0;
        context.__r_.__value_.__l.__cap_ = (std::string::size_type)a3;
        v15.location = 0LL;
        CFArrayApplyFunction((CFArrayRef)a2, v15, (CFArrayApplierFunction)sub_1002B1D2C, &context);
      }

      else
      {
        CFTypeID v17 = CFGetTypeID(a2);
        if (v17 == CFStringGetTypeID())
        {
          memset(&context, 0, sizeof(context));
          if (sub_1002AA05C(a2, &context))
          {
            CFIndex v18 = &__p;
            if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              CFIndex v18 = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            p_std::string context = &context;
            if ((context.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              p_std::string context = (std::string *)context.__r_.__value_.__r.__words[0];
            }
            snprintf(__str, 0x100uLL, "%s = %s\n", (const char *)v18, (const char *)p_context);
          }

          std::string::append(a3, __str);
        }

        else
        {
          CFTypeID v20 = CFGetTypeID(a2);
          if (v20 == CFNumberGetTypeID())
          {
            if (sub_1002A9AE8(a2, &context))
            {
              int v21 = &__p;
              if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                int v21 = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              snprintf( __str,  0x100uLL,  "%s = %0.6f\n",  (const char *)v21,  *(double *)&context.__r_.__value_.__l.__data_);
            }

            std::string::append(a3, __str);
          }

          else
          {
            CFTypeID v22 = CFGetTypeID(a2);
            if (v22 == CFBooleanGetTypeID())
            {
              CFBooleanGetValue((CFBooleanRef)a2);
              snprintf(__str, 0x100uLL, "%s = %d\n");
            }

            else
            {
              CFGetTypeID(a2);
              snprintf(__str, 0x100uLL, "%s = <unhandled value type %lu>\n");
            }

            std::string::append(a3, __str);
          }
        }
      }
    }
  }

  else
  {
    CFTypeID v12 = CFGetTypeID(a1);
    CFTypeID TypeID = CFStringGetTypeID();
    snprintf(__str, 0x100uLL, "type ID does not match - %lu vs %lu\n", v12, TypeID);
    std::string::append(a3, __str);
  }

void sub_1002B0204( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B024C(uint64_t a1, void *context)
{
  CFStringRef v3 = *(const __CFDictionary **)(a1 + 8);
  if (v3)
  {
    CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)sub_1002B0438, context);
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    uint64_t v4 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 136315138;
      std::string::size_type v9 = context;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "dictionary, %s, NULL", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      int v6 = 136315138;
      CFTypeID v7 = context;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "dictionary, %s, NULL",  (const char *)&v6);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNameValuePair::printCSV(const char *)", "%s\n", v5);
    }
  }

void sub_1002B0438(const __CFString *a1, const __CFString *a2, char *a3)
{
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID()) {
    goto LABEL_28;
  }
  sub_1002AA05C(a1, &v79);
  CFTypeID v7 = CFGetTypeID(a2);
  if (v7 == CFDictionaryGetTypeID())
  {
    sub_1010DDBC0(&v78, a3);
    sub_1010DDBC0(&__p, "->");
    if ((v77 & 0x80u) == 0) {
      uint64_t p_p = (const std::string::value_type *)&__p;
    }
    else {
      uint64_t p_p = (const std::string::value_type *)__p;
    }
    if ((v77 & 0x80u) == 0) {
      std::string::size_type v9 = v77;
    }
    else {
      std::string::size_type v9 = v76;
    }
    uint64_t v10 = std::string::append(&v78, p_p, v9);
    __int128 v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v80.__r_.__value_.__l.__cap_ = v10->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0LL;
    v10->__r_.__value_.__l.__cap_ = 0LL;
    v10->__r_.__value_.__r.__words[0] = 0LL;
    if ((v79.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      CFTypeID v12 = &v79;
    }
    else {
      CFTypeID v12 = (std::string *)v79.__r_.__value_.__r.__words[0];
    }
    if ((v79.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = v79.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = v79.__r_.__value_.__l.__size_;
    }
    CFTypeID v14 = std::string::append(&v80, (const std::string::value_type *)v12, size);
    __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    *(void *)&uint8_t buf[16] = v14->__r_.__value_.__l.__cap_;
    *(_OWORD *)std::string buf = v15;
    v14->__r_.__value_.__l.__size_ = 0LL;
    v14->__r_.__value_.__l.__cap_ = 0LL;
    v14->__r_.__value_.__r.__words[0] = 0LL;
    if (buf[23] >= 0) {
      CFTypeID v16 = buf;
    }
    else {
      CFTypeID v16 = *(_BYTE **)buf;
    }
    CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)sub_1002B0438, v16);
    int v17 = buf[23];
LABEL_25:
    if ((v17 & 0x80000000) == 0) {
      goto LABEL_28;
    }
    CFIndex v18 = *(void **)buf;
    goto LABEL_27;
  }

  CFTypeID v19 = CFGetTypeID(a2);
  if (v19 == CFArrayGetTypeID())
  {
    sub_1010DDBC0(&v78, a3);
    sub_1010DDBC0(&__p, "->");
    if ((v77 & 0x80u) == 0) {
      CFTypeID v20 = (const std::string::value_type *)&__p;
    }
    else {
      CFTypeID v20 = (const std::string::value_type *)__p;
    }
    if ((v77 & 0x80u) == 0) {
      std::string::size_type v21 = v77;
    }
    else {
      std::string::size_type v21 = v76;
    }
    CFTypeID v22 = std::string::append(&v78, v20, v21);
    __int128 v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v80.__r_.__value_.__l.__cap_ = v22->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0LL;
    v22->__r_.__value_.__l.__cap_ = 0LL;
    v22->__r_.__value_.__r.__words[0] = 0LL;
    if ((v79.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int16 v24 = &v79;
    }
    else {
      __int16 v24 = (std::string *)v79.__r_.__value_.__r.__words[0];
    }
    if ((v79.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v25 = v79.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v25 = v79.__r_.__value_.__l.__size_;
    }
    CFIndex v26 = std::string::append(&v80, (const std::string::value_type *)v24, v25);
    __int128 v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
    *(void *)&uint8_t buf[16] = v26->__r_.__value_.__l.__cap_;
    *(_OWORD *)std::string buf = v27;
    v26->__r_.__value_.__l.__size_ = 0LL;
    v26->__r_.__value_.__l.__cap_ = 0LL;
    v26->__r_.__value_.__r.__words[0] = 0LL;
    for (CFIndex i = 0LL; ; ++i)
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
      int v17 = buf[23];
      if (i >= Count) {
        break;
      }
      if (buf[23] >= 0) {
        __int16 v30 = buf;
      }
      else {
        __int16 v30 = *(_BYTE **)buf;
      }
      CFStringRef v31 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s.%ld", v30, i);
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, i);
      sub_1002B0438(v31, ValueAtIndex, a3);
      if (v31) {
        CFRelease(v31);
      }
    }

    goto LABEL_25;
  }

  CFTypeID v33 = CFGetTypeID(a2);
  if (v33 != CFStringGetTypeID())
  {
    CFTypeID v37 = CFGetTypeID(a2);
    if (v37 == CFNumberGetTypeID())
    {
      if (CFNumberIsFloatType((CFNumberRef)a2))
      {
        v78.__r_.__value_.__r.__words[0] = 0LL;
        sub_1002A9AE8(a2, &v78);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        unsigned int v38 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          __int16 v39 = &v79;
          if ((v79.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            __int16 v39 = (std::string *)v79.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string buf = 136315650;
          *(void *)&uint8_t buf[4] = a3;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = v39;
          *(_WORD *)&_BYTE buf[22] = 2048;
          v83[0] = v78.__r_.__value_.__r.__words[0];
          _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEBUG,  "dictionary, %s, key, %s, value, %.8lf",  buf,  0x20u);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_28;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        CFTypeID v40 = &v79;
        if ((v79.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          CFTypeID v40 = (std::string *)v79.__r_.__value_.__r.__words[0];
        }
        LODWORD(v80.__r_.__value_.__l.__data_) = 136315650;
        *(std::string::size_type *)((char *)v80.__r_.__value_.__r.__words + 4) = (std::string::size_type)a3;
        WORD2(v80.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v80.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v40;
        HIWORD(v80.__r_.__value_.__r.__words[2]) = 2048;
        v81[0] = v78.__r_.__value_.__r.__words[0];
        uint64_t v41 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "dictionary, %s, key, %s, value, %.8lf",  (const char *)&v80,  32,  *(double *)&v74);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void _printCSV_logKeyValue(const void *, const void *, void *)",  "%s\n",  v41);
      }

      else
      {
        LODWORD(v78.__r_.__value_.__l.__data_) = 0;
        sub_1002A96F8(a2, &v78);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        uint64_t v64 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          __int16 v65 = &v79;
          if ((v79.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            __int16 v65 = (std::string *)v79.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string buf = 136315906;
          *(void *)&uint8_t buf[4] = a3;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = v65;
          *(_WORD *)&_BYTE buf[22] = 1024;
          LODWORD(v83[0]) = v78.__r_.__value_.__l.__data_;
          WORD2(v83[0]) = 1024;
          *(_DWORD *)((char *)v83 + 6) = v78.__r_.__value_.__l.__data_;
          _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEBUG,  "dictionary, %s, key, %s, value, %d, 0x%08x",  buf,  0x22u);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_28;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        uint64_t v66 = &v79;
        if ((v79.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v66 = (std::string *)v79.__r_.__value_.__r.__words[0];
        }
        LODWORD(v80.__r_.__value_.__l.__data_) = 136315906;
        *(std::string::size_type *)((char *)v80.__r_.__value_.__r.__words + 4) = (std::string::size_type)a3;
        WORD2(v80.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v80.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v66;
        HIWORD(v80.__r_.__value_.__r.__words[2]) = 1024;
        LODWORD(v81[0]) = v78.__r_.__value_.__l.__data_;
        WORD2(v81[0]) = 1024;
        *(_DWORD *)((char *)v81 + 6) = v78.__r_.__value_.__l.__data_;
        LODWORD(v73) = 34;
        uint64_t v41 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "dictionary, %s, key, %s, value, %d, 0x%08x",  (const char *)&v80,  v73,  (_DWORD)v74,  (_DWORD)__p);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void _printCSV_logKeyValue(const void *, const void *, void *)",  "%s\n",  v41);
      }
    }

    else
    {
      CFTypeID v42 = CFGetTypeID(a2);
      if (v42 == CFBooleanGetTypeID())
      {
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        uint64_t v43 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          int v44 = (char)v79.__r_.__value_.__s.__size_;
          std::string::size_type v45 = v79.__r_.__value_.__r.__words[0];
          int Value = CFBooleanGetValue((CFBooleanRef)a2);
          double v47 = &v79;
          *(_DWORD *)std::string buf = 136315650;
          if (v44 < 0) {
            double v47 = (std::string *)v45;
          }
          *(void *)&uint8_t buf[4] = a3;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = v47;
          *(_WORD *)&_BYTE buf[22] = 1024;
          LODWORD(v83[0]) = Value;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEBUG,  "dictionary, %s, key, %s, value, %d, [CFBoolean]",  buf,  0x1Cu);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_28;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10182EEA8);
        }
        uint64_t v48 = qword_101934A78;
        int v49 = (char)v79.__r_.__value_.__s.__size_;
        std::string::size_type v50 = v79.__r_.__value_.__r.__words[0];
        int v51 = CFBooleanGetValue((CFBooleanRef)a2);
        int v52 = &v79;
        LODWORD(v80.__r_.__value_.__l.__data_) = 136315650;
        if (v49 < 0) {
          int v52 = (std::string *)v50;
        }
        *(std::string::size_type *)((char *)v80.__r_.__value_.__r.__words + 4) = (std::string::size_type)a3;
        WORD2(v80.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&v80.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v52;
        HIWORD(v80.__r_.__value_.__r.__words[2]) = 1024;
        LODWORD(v81[0]) = v51;
        LODWORD(v73) = 28;
        uint64_t v41 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v48,  2LL,  "dictionary, %s, key, %s, value, %d, [CFBoolean]",  (const char *)&v80,  v73,  (_DWORD)v74);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void _printCSV_logKeyValue(const void *, const void *, void *)",  "%s\n",  v41);
      }

      else
      {
        CFTypeID v53 = CFGetTypeID(a2);
        if (v53 == CFDateGetTypeID())
        {
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_10182EEA8);
          }
          double v54 = (os_log_s *)qword_101934A78;
          if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
          {
            int v55 = (char)v79.__r_.__value_.__s.__size_;
            std::string::size_type v56 = v79.__r_.__value_.__r.__words[0];
            double AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)a2);
            __int128 v58 = &v79;
            *(_DWORD *)std::string buf = 136315650;
            if (v55 < 0) {
              __int128 v58 = (std::string *)v56;
            }
            *(void *)&uint8_t buf[4] = a3;
            *(_WORD *)&_BYTE buf[12] = 2080;
            *(void *)&buf[14] = v58;
            *(_WORD *)&_BYTE buf[22] = 2048;
            *(double *)__int16 v83 = AbsoluteTime;
            _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_DEBUG,  "dictionary, %s, key, %s, value, %.2lf, [CFDate]",  buf,  0x20u);
          }

          if (!sub_1002921D0(115, 2)) {
            goto LABEL_28;
          }
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_10182EEA8);
          }
          uint64_t v59 = qword_101934A78;
          int v60 = (char)v79.__r_.__value_.__s.__size_;
          std::string::size_type v61 = v79.__r_.__value_.__r.__words[0];
          double v62 = CFDateGetAbsoluteTime((CFDateRef)a2);
          __int16 v63 = &v79;
          LODWORD(v80.__r_.__value_.__l.__data_) = 136315650;
          if (v60 < 0) {
            __int16 v63 = (std::string *)v61;
          }
          *(std::string::size_type *)((char *)v80.__r_.__value_.__r.__words + 4) = (std::string::size_type)a3;
          WORD2(v80.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&v80.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v63;
          HIWORD(v80.__r_.__value_.__r.__words[2]) = 2048;
          *(double *)int v81 = v62;
          uint64_t v41 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v59,  2LL,  "dictionary, %s, key, %s, value, %.2lf, [CFDate]",  (const char *)&v80,  32,  *(double *)&v74);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void _printCSV_logKeyValue(const void *, const void *, void *)",  "%s\n",  v41);
        }

        else
        {
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_10182EEA8);
          }
          __int16 v67 = (os_log_s *)qword_101934A78;
          if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v68 = &v79;
            if ((v79.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              uint64_t v68 = (std::string *)v79.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = a3;
            *(_WORD *)&_BYTE buf[12] = 2080;
            *(void *)&buf[14] = v68;
            _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEBUG,  "dictionary, %s, key, %s, un-printable value",  buf,  0x16u);
          }

          if (!sub_1002921D0(115, 2)) {
            goto LABEL_28;
          }
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_10182EEA8);
          }
          __int16 v69 = &v79;
          if ((v79.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            __int16 v69 = (std::string *)v79.__r_.__value_.__r.__words[0];
          }
          LODWORD(v80.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)v80.__r_.__value_.__r.__words + 4) = (std::string::size_type)a3;
          WORD2(v80.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&v80.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v69;
          uint64_t v41 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "dictionary, %s, key, %s, un-printable value",  (const char *)&v80,  22);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void _printCSV_logKeyValue(const void *, const void *, void *)",  "%s\n",  v41);
        }
      }
    }

    if (v41 != buf) {
      free(v41);
    }
    goto LABEL_28;
  }

  memset(&v78, 0, sizeof(v78));
  sub_1002AA05C(a2, &v78);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182EEA8);
  }
  CFTypeID v34 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    __int16 v35 = &v79;
    if ((v79.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int16 v35 = (std::string *)v79.__r_.__value_.__r.__words[0];
    }
    int v36 = &v78;
    if ((v78.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      int v36 = (std::string *)v78.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = a3;
    *(_WORD *)&_BYTE buf[12] = 2080;
    *(void *)&buf[14] = v35;
    *(_WORD *)&_BYTE buf[22] = 2080;
    v83[0] = v36;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEBUG, "dictionary, %s, key, %s, value, %s", buf, 0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    int v70 = &v79;
    if ((v79.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      int v70 = (std::string *)v79.__r_.__value_.__r.__words[0];
    }
    __int16 v71 = &v78;
    if ((v78.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int16 v71 = (std::string *)v78.__r_.__value_.__r.__words[0];
    }
    LODWORD(v80.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)v80.__r_.__value_.__r.__words + 4) = (std::string::size_type)a3;
    WORD2(v80.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v80.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v70;
    HIWORD(v80.__r_.__value_.__r.__words[2]) = 2080;
    v81[0] = v71;
    uint64_t v72 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "dictionary, %s, key, %s, value, %s",  (const char *)&v80,  32,  v74);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void _printCSV_logKeyValue(const void *, const void *, void *)", "%s\n", v72);
    if (v72 != buf) {
      free(v72);
    }
  }

  if ((char)v78.__r_.__value_.__s.__size_ < 0)
  {
    CFIndex v18 = (void *)v78.__r_.__value_.__r.__words[0];
LABEL_27:
    operator delete(v18);
  }

void sub_1002B11D4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *__p, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, void *a39, uint64_t a40, int a41, __int16 a42, char a43, char a44)
{
  if (a29 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B12A0(const __CFString *a1, const __CFString *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    memset(&v54, 0, sizeof(v54));
    sub_1002AA05C(a1, &v54);
    CFTypeID v5 = CFGetTypeID(a2);
    if (v5 == CFDictionaryGetTypeID())
    {
      if (qword_101934A80 != -1) {
        dispatch_once(&qword_101934A80, &stru_10182EEE8);
      }
      CFTypeID v6 = (os_log_s *)qword_101934A88;
      if (os_log_type_enabled((os_log_t)qword_101934A88, OS_LOG_TYPE_DEBUG))
      {
        int size = (char)v54.__r_.__value_.__s.__size_;
        std::string::size_type v8 = v54.__r_.__value_.__r.__words[0];
        CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a2);
        uint64_t v10 = &v54;
        if (size < 0) {
          uint64_t v10 = (std::string *)v8;
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v10;
        __int16 v60 = 2048;
        v61[0] = Count;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "\t%s = <dictionary (%ld entries)>:",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A80 != -1) {
          dispatch_once(&qword_101934A80, &stru_10182EEE8);
        }
        uint64_t v39 = qword_101934A88;
        int v40 = (char)v54.__r_.__value_.__s.__size_;
        std::string::size_type v41 = v54.__r_.__value_.__r.__words[0];
        CFIndex v42 = CFDictionaryGetCount((CFDictionaryRef)a2);
        uint64_t v43 = &v54;
        if (v40 < 0) {
          uint64_t v43 = (std::string *)v41;
        }
        LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v43;
        WORD2(__p.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v42;
        int v44 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v39,  2LL,  "\t%s = <dictionary (%ld entries)>:",  (const char *)&__p,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLNameValuePair::printKeyValue(const void *, const void *, void *)",  "%s\n",  v44);
        if (v44 != buf) {
          free(v44);
        }
      }

      CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)sub_1002B12A0, 0LL);
      goto LABEL_63;
    }

    CFTypeID v11 = CFGetTypeID(a2);
    if (v11 == CFArrayGetTypeID())
    {
      v12.length = CFArrayGetCount((CFArrayRef)a2);
      int v13 = &v54;
      if ((v54.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v13 = (std::string *)v54.__r_.__value_.__r.__words[0];
      }
      *(void *)std::string buf = v13;
      *(_DWORD *)&uint8_t buf[8] = 0;
      *(void *)((char *)v61 + 2) = 0LL;
      v12.location = 0LL;
      CFArrayApplyFunction((CFArrayRef)a2, v12, (CFArrayApplierFunction)sub_1002B1CB8, buf);
      goto LABEL_63;
    }

    CFTypeID v14 = CFGetTypeID(a2);
    if (v14 == CFStringGetTypeID())
    {
      memset(&__p, 0, sizeof(__p));
      if (sub_1002AA05C(a2, &__p))
      {
        if (qword_101934A80 != -1) {
          dispatch_once(&qword_101934A80, &stru_10182EEE8);
        }
        __int128 v15 = (os_log_s *)qword_101934A88;
        if (os_log_type_enabled((os_log_t)qword_101934A88, OS_LOG_TYPE_DEBUG))
        {
          CFTypeID v16 = &v54;
          if ((v54.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            CFTypeID v16 = (std::string *)v54.__r_.__value_.__r.__words[0];
          }
          uint64_t p_p = &__p;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            uint64_t p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v16;
          __int16 v60 = 2080;
          v61[0] = p_p;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "\t%s = %s", buf, 0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A80 != -1) {
            dispatch_once(&qword_101934A80, &stru_10182EEE8);
          }
          std::string::size_type v45 = &v54;
          if ((v54.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            std::string::size_type v45 = (std::string *)v54.__r_.__value_.__r.__words[0];
          }
          uint64_t v46 = &__p;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            uint64_t v46 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)int v55 = 136315394;
          *(void *)&v55[4] = v45;
          __int16 v56 = 2080;
          double v57 = v46;
          double v47 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A88,  2LL,  "\t%s = %s",  v55,  22);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLNameValuePair::printKeyValue(const void *, const void *, void *)",  "%s\n",  v47);
          if (v47 != buf) {
            free(v47);
          }
        }
      }

      goto LABEL_63;
    }

    CFTypeID v18 = CFGetTypeID(a2);
    if (v18 == CFNumberGetTypeID())
    {
      if (qword_101934A80 != -1) {
        dispatch_once(&qword_101934A80, &stru_10182EEE8);
      }
      CFTypeID v19 = (os_log_s *)qword_101934A88;
      if (os_log_type_enabled((os_log_t)qword_101934A88, OS_LOG_TYPE_DEBUG))
      {
        CFTypeID v20 = &v54;
        if ((v54.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          CFTypeID v20 = (std::string *)v54.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string buf = 136315394;
        *(void *)&uint8_t buf[4] = v20;
        __int16 v60 = 2048;
        v61[0] = *(void *)v55;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "\t%s = %0.6f", buf, 0x16u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_63;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934A80 != -1) {
        dispatch_once(&qword_101934A80, &stru_10182EEE8);
      }
      std::string::size_type v21 = &v54;
      if ((v54.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        std::string::size_type v21 = (std::string *)v54.__r_.__value_.__r.__words[0];
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2048;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = *(void *)v55;
      LODWORD(v53) = 22;
      CFTypeID v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A88,  2LL,  "\t%s = %0.6f",  (const char *)&__p,  v53);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLNameValuePair::printKeyValue(const void *, const void *, void *)",  "%s\n",  v22);
      if (v22 == buf) {
        goto LABEL_63;
      }
    }

    else
    {
      CFTypeID v23 = CFGetTypeID(a2);
      if (v23 == CFBooleanGetTypeID())
      {
        if (qword_101934A80 != -1) {
          dispatch_once(&qword_101934A80, &stru_10182EEE8);
        }
        __int16 v24 = (os_log_s *)qword_101934A88;
        if (os_log_type_enabled((os_log_t)qword_101934A88, OS_LOG_TYPE_DEBUG))
        {
          int v25 = (char)v54.__r_.__value_.__s.__size_;
          std::string::size_type v26 = v54.__r_.__value_.__r.__words[0];
          int Value = CFBooleanGetValue((CFBooleanRef)a2);
          std::string v28 = &v54;
          if (v25 < 0) {
            std::string v28 = (std::string *)v26;
          }
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v28;
          __int16 v60 = 1024;
          LODWORD(v61[0]) = Value;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "\t%s = %d", buf, 0x12u);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_63;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934A80 != -1) {
          dispatch_once(&qword_101934A80, &stru_10182EEE8);
        }
        uint64_t v29 = qword_101934A88;
        int v30 = (char)v54.__r_.__value_.__s.__size_;
        std::string::size_type v31 = v54.__r_.__value_.__r.__words[0];
        int v32 = CFBooleanGetValue((CFBooleanRef)a2);
        CFTypeID v33 = &v54;
        if (v30 < 0) {
          CFTypeID v33 = (std::string *)v31;
        }
        LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v33;
        WORD2(__p.__r_.__value_.__r.__words[1]) = 1024;
        *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v32;
        CFTypeID v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v29,  2LL,  "\t%s = %d",  (const char *)&__p,  18);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLNameValuePair::printKeyValue(const void *, const void *, void *)",  "%s\n",  v22);
      }

      else
      {
        if (qword_101934A80 != -1) {
          dispatch_once(&qword_101934A80, &stru_10182EEE8);
        }
        CFTypeID v34 = (os_log_s *)qword_101934A88;
        if (os_log_type_enabled((os_log_t)qword_101934A88, OS_LOG_TYPE_DEBUG))
        {
          int v35 = (char)v54.__r_.__value_.__s.__size_;
          std::string::size_type v36 = v54.__r_.__value_.__r.__words[0];
          CFTypeID v37 = CFGetTypeID(a2);
          unsigned int v38 = &v54;
          if (v35 < 0) {
            unsigned int v38 = (std::string *)v36;
          }
          *(_DWORD *)std::string buf = 136315394;
          *(void *)&uint8_t buf[4] = v38;
          __int16 v60 = 2048;
          v61[0] = v37;
          _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEBUG,  "\t%s = <unhandled value type %lu>",  buf,  0x16u);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_63;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934A80 != -1) {
          dispatch_once(&qword_101934A80, &stru_10182EEE8);
        }
        uint64_t v48 = qword_101934A88;
        int v49 = (char)v54.__r_.__value_.__s.__size_;
        std::string::size_type v50 = v54.__r_.__value_.__r.__words[0];
        CFTypeID v51 = CFGetTypeID(a2);
        int v52 = &v54;
        if (v49 < 0) {
          int v52 = (std::string *)v50;
        }
        LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v52;
        WORD2(__p.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v51;
        CFTypeID v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v48,  2LL,  "\t%s = <unhandled value type %lu>",  (const char *)&__p,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLNameValuePair::printKeyValue(const void *, const void *, void *)",  "%s\n",  v22);
      }

      if (v22 == buf)
      {
LABEL_63:
        return;
      }
    }

    free(v22);
    goto LABEL_63;
  }

void sub_1002B1C4C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B1CB8(uint64_t a1, uint64_t a2)
{
  CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s[%d]", *(void *)a2, *(unsigned int *)(a2 + 8));
  sub_1002B12A0(v4, a1);
  ++*(_DWORD *)(a2 + 8);
  CFRelease(v4);
}

void sub_1002B1D2C(uint64_t a1, uint64_t a2)
{
  CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s[%d]", *(void *)a2, *(unsigned int *)(a2 + 8));
  sub_1002AFEE0(v4, a1, *(void *)(a2 + 16));
  ++*(_DWORD *)(a2 + 8);
  CFRelease(v4);
}

BOOL sub_1002B1DA4(const void *a1, void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  CFTypeID TypeID = CFStringGetTypeID();
  if (v4 == TypeID)
  {
    *a2 = a1;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182EEA8);
    }
    CFTypeID v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134349312;
      CFTypeID v16 = CFGetTypeID(a1);
      __int16 v17 = 2050;
      CFTypeID v18 = CFStringGetTypeID();
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "type IDs do not match - %{public}lu vs %{public}lu",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182EEA8);
      }
      uint64_t v8 = qword_101934A78;
      int v11 = 134349312;
      CFTypeID v12 = CFGetTypeID(a1);
      __int16 v13 = 2050;
      CFTypeID v14 = CFStringGetTypeID();
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v8,  17LL,  "type IDs do not match - %{public}lu vs %{public}lu",  &v11,  22);
      uint64_t v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "static BOOL CLNameValuePair::fromCfType(const CFTypeRef, CFStringRef &)",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }
  }

  return v4 == TypeID;
}

void sub_1002B1FBC(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_1002B1FE8(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void sub_1002B2014(id a1)
{
  qword_101934A88 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Direct_deprecated");
}

void sub_1002B20E4(id a1)
{
  qword_101994050 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLCompanionRelativeElevationServiceSilo");
}

void sub_1002B2488(_Unwind_Exception *a1)
{
}

void sub_1002B24A4(void **a1, unint64_t a2)
{
  CFTypeID v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0x8E38E38E38E38E39LL * ((v4 - (_BYTE *)*a1) >> 4) < a2)
  {
    if (a2 >= 0x1C71C71C71C71C8LL) {
      sub_100007008();
    }
    uint64_t v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 144;
    CFTypeID v6 = (char *)sub_1002B4F00(v3, a2);
    CFTypeID v7 = &v6[144 * v5];
    std::string::size_type v9 = &v6[144 * v8];
    int v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    CFTypeID v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 9) = *((_OWORD *)v10 - 9);
        __int128 v13 = *((_OWORD *)v10 - 8);
        __int128 v14 = *((_OWORD *)v10 - 7);
        __int128 v15 = *((_OWORD *)v10 - 5);
        *((_OWORD *)v12 - 6) = *((_OWORD *)v10 - 6);
        *((_OWORD *)v12 - 5) = v15;
        *((_OWORD *)v12 - std::iostream::~basic_iostream(v2, v3 + 8) = v13;
        *((_OWORD *)v12 - 7) = v14;
        __int128 v16 = *((_OWORD *)v10 - 4);
        __int128 v17 = *((_OWORD *)v10 - 3);
        __int128 v18 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v18;
        *((_OWORD *)v12 - 4) = v16;
        *((_OWORD *)v12 - 3) = v17;
        v12 -= 144;
        v10 -= 144;
      }

      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

NSTimer *sub_1002B25A8(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 32) + 216LL) = +[NSTimer scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:]( &OBJC_CLASS___NSTimer,  "scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:",  *(void *)(a1 + 32),  "rotateCAHourly",  0LL,  1LL,  3600.0);
  uint64_t result = +[NSTimer scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:]( &OBJC_CLASS___NSTimer,  "scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:",  *(void *)(a1 + 32),  "rotateCADaily",  0LL,  1LL,  86400.0);
  *(void *)(*(void *)(a1 + 32) + 224LL) = result;
  return result;
}

void sub_1002B29FC(_Unwind_Exception *a1)
{
}

id sub_1002B2A10(uint64_t a1, unsigned int *a2, _OWORD *a3, void *a4)
{
  uint64_t v4 = *a2;
  __int128 v5 = a3[9];
  _WORD v12[8] = a3[8];
  v12[9] = v5;
  __int128 v6 = a3[11];
  v12[10] = a3[10];
  v12[11] = v6;
  __int128 v7 = a3[5];
  v12[4] = a3[4];
  void v12[5] = v7;
  __int128 v8 = a3[7];
  void v12[6] = a3[6];
  v12[7] = v8;
  __int128 v9 = a3[1];
  v12[0] = *a3;
  v12[1] = v9;
  __int128 v10 = a3[3];
  id v12[2] = a3[2];
  void v12[3] = v10;
  return [a4 onCompanionNotification:v4 data:v12];
}

id sub_1002B2A6C(uint64_t a1, unsigned int *a2, _OWORD *a3, void *a4)
{
  uint64_t v4 = *a2;
  __int128 v5 = a3[7];
  v11[6] = a3[6];
  v11[7] = v5;
  __int128 v6 = a3[9];
  _WORD v11[8] = a3[8];
  v11[9] = v6;
  __int128 v7 = a3[3];
  _DWORD v11[2] = a3[2];
  void v11[3] = v7;
  __int128 v8 = a3[5];
  v11[4] = a3[4];
  v11[5] = v8;
  __int128 v9 = a3[1];
  v11[0] = *a3;
  v11[1] = v9;
  return [a4 onMotionActivityNotification:v4 data:v11];
}

id sub_1002B2AEC(uint64_t a1, void *a2)
{
  return _[a2 onKFFilteredPressure:a1];
}

void sub_1002B31C0(_Unwind_Exception *a1)
{
}

double sub_1002B31E0(uint64_t a1, double result)
{
  if ((*(_DWORD *)a1)++)
  {
    double v4 = *(double *)(a1 + 8);
    double v3 = *(double *)(a1 + 16);
    double v5 = *(double *)(a1 + 24) * v4;
    double v6 = *(double *)(a1 + 32) * (v4 * v4);
    double v7 = v5 + 1.0;
    if (v3 == result)
    {
      double v8 = *(double *)(a1 + 16);
    }

    else
    {
      double v8 = (result + v5 * v3) / (v5 + 1.0);
      *(double *)(a1 + 16) = v8;
    }

    double v9 = ((result - v8) * (result - v8) + v5 * (*(double *)(a1 + 40) + (v3 - v8) * (v3 - v8))) / v7;
    uint64_t result = v6 + 1.0;
    *(double *)(a1 + 24) = v7;
    *(double *)(a1 + sub_10000AE14(v13 - 32) = v6 + 1.0;
    *(double *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v9;
  }

  else
  {
    *(double *)(a1 + 16) = result;
  }

  return result;
}

uint64_t sub_1002B3F08(void *a1, _OWORD *a2)
{
  unint64_t v2 = a1[5];
  if (v2)
  {
    double v3 = (_OWORD *)(*a1 + 144 * ((a1[3] + a1[4]) % v2));
    __int128 v4 = a2[4];
    __int128 v6 = a2[1];
    __int128 v5 = a2[2];
    v3[3] = a2[3];
    void v3[4] = v4;
    v3[1] = v6;
    _DWORD v3[2] = v5;
    __int128 v7 = a2[8];
    __int128 v9 = a2[5];
    __int128 v8 = a2[6];
    v3[7] = a2[7];
    _WORD v3[8] = v7;
    v3[5] = v9;
    void v3[6] = v8;
    *double v3 = *a2;
    unint64_t v10 = a1[4];
    if (v10 == a1[5])
    {
      unint64_t v2 = 0LL;
      a1[3] = (a1[3] + 1LL) % v10;
    }

    else
    {
      a1[4] = v10 + 1;
      return 1LL;
    }
  }

  return v2;
}

NSDictionary *sub_1002B4354(uint64_t a1)
{
  v3[0] = @"btRssi";
  v4[0] = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(*(void *)(a1 + 32) + 128LL));
  v3[1] = @"btRssiAge";
  v4[1] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 40));
  _DWORD v3[2] = @"companionPressure";
  _DWORD v4[2] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", **(double **)(a1 + 32));
  v3[3] = @"companionPressureAge";
  void v4[3] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 48));
  void v3[4] = @"companionPressureVariance";
  void v4[4] = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(*(void *)(a1 + 32) + 16LL));
  v3[5] = @"inProximity";
  void v4[5] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 64LL));
  void v3[6] = @"motionState";
  void v4[6] = +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(*(void *)(a1 + 32) + 48LL));
  v3[7] = @"proximityAge";
  v4[7] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 56));
  _WORD v3[8] = @"relativePressureBiasEstimate";
  _WORD v4[8] = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(*(void *)(a1 + 32) + 104LL));
  v3[9] = @"relativePressureBiasMeasurement";
  v4[9] = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(*(void *)(a1 + 32) + 96LL));
  v3[10] = @"tableIndex";
  v4[10] = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 80));
  v3[11] = @"timeSinceLastCalibration";
  v4[11] = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(*(void *)(a1 + 32) + 136LL));
  _BYTE v3[12] = @"watchMotionStateAge";
  v4[12] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 64));
  v3[13] = @"watchPressure";
  v4[13] = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(*(void *)(a1 + 32) + 24LL));
  v3[14] = @"watchPressureAge";
  v4[14] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 72));
  v3[15] = @"watchPressureVariance";
  v4[15] = +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(*(void *)(a1 + 32) + 40LL));
  return +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v4,  v3,  16LL);
}

void sub_1002B4C4C(id a1)
{
  qword_1019346D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Transport");
}

void sub_1002B4C78(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_1002B4CA4(uint64_t a1, unint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + sub_10000AE14(v13 - 32) = 0LL;
  *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = a2;
  sub_1002B4CF0(a1, a2);
  return a1;
}

void sub_1002B4CD4(_Unwind_Exception *exception_object)
{
  double v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::iostream::~basic_iostream(v2, v3 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1002B4CF0(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0x8E38E38E38E38E39LL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    sub_1002B4D34((void **)a1, v4);
  }

  else if (!v3)
  {
    *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = *(void *)a1 + 144 * a2;
  }

void sub_1002B4D34(void **a1, unint64_t a2)
{
  __int128 v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  __int128 v5 = v6;
  __int128 v7 = *(char **)(v4 - 8);
  if (0x8E38E38E38E38E39LL * ((v6 - v7) >> 4) >= a2)
  {
    if (a2)
    {
      size_t v13 = 144 * ((144 * a2 - 144) / 0x90) + 144;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }

    a1[1] = v7;
  }

  else
  {
    unint64_t v8 = 0x8E38E38E38E38E39LL * ((v7 - (_BYTE *)*a1) >> 4);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x1C71C71C71C71C7LL) {
      sub_100007008();
    }
    unint64_t v10 = 0x8E38E38E38E38E39LL * ((v5 - (_BYTE *)*a1) >> 4);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0xE38E38E38E38E3LL) {
      unint64_t v11 = 0x1C71C71C71C71C7LL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      CFTypeID v12 = (char *)sub_1002B4F00(v4, v11);
    }
    else {
      CFTypeID v12 = 0LL;
    }
    __int128 v14 = &v12[144 * v8];
    __int128 v15 = &v12[144 * v11];
    size_t v16 = 144 * ((144 * a2 - 144) / 0x90) + 144;
    bzero(v14, v16);
    __int128 v17 = &v14[v16];
    CFTypeID v19 = (char *)*a1;
    __int128 v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 9) = *((_OWORD *)v18 - 9);
        __int128 v20 = *((_OWORD *)v18 - 8);
        __int128 v21 = *((_OWORD *)v18 - 7);
        __int128 v22 = *((_OWORD *)v18 - 5);
        *((_OWORD *)v14 - 6) = *((_OWORD *)v18 - 6);
        *((_OWORD *)v14 - 5) = v22;
        *((_OWORD *)v14 - std::iostream::~basic_iostream(v2, v3 + 8) = v20;
        *((_OWORD *)v14 - 7) = v21;
        __int128 v23 = *((_OWORD *)v18 - 4);
        __int128 v24 = *((_OWORD *)v18 - 3);
        __int128 v25 = *((_OWORD *)v18 - 1);
        *((_OWORD *)v14 - 2) = *((_OWORD *)v18 - 2);
        *((_OWORD *)v14 - 1) = v25;
        *((_OWORD *)v14 - 4) = v23;
        *((_OWORD *)v14 - 3) = v24;
        v14 -= 144;
        v18 -= 144;
      }

      while (v18 != v19);
      __int128 v18 = (char *)*a1;
    }

    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18) {
      operator delete(v18);
    }
  }

void *sub_1002B4F00(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1C71C71C71C71C8LL) {
    sub_1000070D4();
  }
  return operator new(144 * a2);
}

void *sub_1002B4F48(void *a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  *a1 = off_1018A2210;
  id v9 = a5;
  *a1 = off_10182EF98;
  a1[1] = v9;
  a1[2] = a3;
  a1[3] = a4;
  id v10 = a2;
  a1[5] = 0LL;
  a1[4] = v10;
  a1[6] = 0LL;
  v14[0] = 0LL;
  v14[1] = v14;
  _OWORD v14[2] = 0x2020000000LL;
  char v15 = 0;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3221225472LL;
  aBlock[2] = sub_1002B507C;
  aBlock[3] = &unk_10182EFC8;
  aBlock[4] = v14;
  a1[5] = _Block_copy(aBlock);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  id v12[2] = sub_1002B5090;
  void v12[3] = &unk_10182EFF0;
  v12[4] = v14;
  a1[6] = _Block_copy(v12);
  _Block_object_dispose(v14, 8);
  return a1;
}

void sub_1002B5054(_Unwind_Exception *a1)
{
}

uint64_t sub_1002B507C(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  return result;
}

BOOL sub_1002B5090(uint64_t a1)
{
  return *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) == 0;
}

void sub_1002B50AC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002B5390(a1);
  operator delete(v1);
}

id sub_1002B50C0(void *a1, int a2, void *__src, unint64_t a4)
{
  LODWORD(__dst) = 2139095039;
  *((void *)&__dst + 1) = 0x7FEFFFFFFFFFFFFFLL;
  *(int32x2_t *)&__int128 v23 = vdup_n_s32(0x7F7FFFFFu);
  DWORD2(v23) = 2139095039;
  unsigned __int128 v24 = __PAIR128__(v23, 0x7FEFFFFFFFFFFFFFLL);
  if (a4 >= 0x30) {
    size_t v8 = 48LL;
  }
  else {
    size_t v8 = a4;
  }
  memcpy(&__dst, __src, v8);
  if (a4 >= 0x31)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182EF68);
    }
    id v9 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 136315906;
      unint64_t v34 = 0x80000001012E4E17LL & 0x7FFFFFFFFFFFFFFFLL;
      __int16 v35 = 2048;
      uint64_t v36 = 48LL;
      __int16 v37 = 2048;
      unint64_t v38 = a4;
      __int16 v39 = 1024;
      int v40 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "SIZE MISMATCH: %s=%lu vs sz=%zu notification=%d",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182EF68);
      }
      int v25 = 136315906;
      unint64_t v26 = 0x80000001012E4E17LL & 0x7FFFFFFFFFFFFFFFLL;
      __int16 v27 = 2048;
      uint64_t v28 = 48LL;
      __int16 v29 = 2048;
      unint64_t v30 = a4;
      __int16 v31 = 1024;
      int v32 = a2;
      char v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "SIZE MISMATCH: %s=%lu vs sz=%zu notification=%d",  (const char *)&v25,  38,  v16,  LODWORD(v17[0]));
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMotionNotifier::SiloDispatcher<CLBarometerCalibration_Types::CMKFFilteredPressureSample>::dispatc hData(int, const void *, size_t) [T = CLBarometerCalibration_Types::CMKFFilteredPressureSample]",  "%s\n",  v15);
    }
  }

  uint64_t v11 = a1[2];
  uint64_t v10 = a1[3];
  uint64_t v12 = a1[6];
  size_t v13 = (void *)a1[4];
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472LL;
  uint64_t v17[2] = sub_1002B53E8;
  v17[3] = &unk_10182F040;
  v17[4] = v12;
  v17[5] = v11;
  __int128 v18 = __dst;
  __int128 v19 = v23;
  unsigned __int128 v20 = v24;
  uint64_t v21 = v10;
  return [v13 async:v17];
}

uint64_t sub_1002B5390(uint64_t a1)
{
  *(void *)a1 = off_10182EF98;
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  _Block_release(*(const void **)(a1 + 40));
  _Block_release(*(const void **)(a1 + 48));

  return sub_1011C07F8(a1);
}

uint64_t sub_1002B53E8(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if ((_DWORD)result) {
    return (*(uint64_t (**)(uint64_t, void))(a1 + 40))(a1 + 48, *(void *)(a1 + 96));
  }
  return result;
}

unsigned __int8 *sub_1002B542C()
{
  unsigned __int8 v1 = 1;
  sub_1012049AC((unsigned __int8 *)&unk_101994030, "PressureFindingLogCa", &v1, 0);
  uint64_t v2 = 0x405E000000000000LL;
  return sub_101204164(byte_101994038, "PressureFindingPressureValidDuration", &v2, 0);
}

void *sub_1002B5518(void *a1, uint64_t a2)
{
  *a1 = off_10182F070;
  a1[1] = a2;
  a1[2] = 0LL;
  a1[3] = 0LL;
  a1[4] =  -[CLHarvestAccessoryLocationProviderAdapter initWithMonitorGpsExternal:]( objc_alloc(&OBJC_CLASS___CLHarvestAccessoryLocationProviderAdapter),  "initWithMonitorGpsExternal:",  a1);
  return a1;
}

void sub_1002B5574(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void *)(v2 + 24);
  *(void *)(v2 + 24) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_1012331B4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002B55A4(uint64_t a1)
{
  *(void *)a1 = off_10182F070;

  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return a1;
}

void sub_1002B5610(uint64_t a1)
{
  unsigned __int8 v1 = (void *)sub_1002B55A4(a1);
  operator delete(v1);
}

uint64_t sub_1002B5624(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

id sub_1002B5644(uint64_t a1, uint64_t a2)
{
  return [*(id *)(*(void *)(a1 + 16) + 16) register:*(void *)(*(void *)(a1 + 16) + 8) forNotification:a2 registrationInfo:0];
}

id sub_1002B5658(uint64_t a1, uint64_t a2)
{
  return [*(id *)(*(void *)(a1 + 16) + 16) unregister:*(void *)(*(void *)(a1 + 16) + 8) forNotification:a2];
}

id sub_1002B5668(uint64_t a1, uint64_t a2)
{
  return [*(id *)(*(void *)(a1 + 24) + 16) register:*(void *)(*(void *)(a1 + 24) + 8) forNotification:a2 registrationInfo:0];
}

id sub_1002B567C(uint64_t a1, uint64_t a2)
{
  return [*(id *)(*(void *)(a1 + 24) + 16) register:*(void *)(*(void *)(a1 + 24) + 8) forNotification:a2 registrationInfo:0];
}

void sub_1002B5690()
{
}

uint64_t sub_1002B56C0()
{
  uint64_t v2 = v7;
  uint64_t v7 = 0LL;
  uint64_t v3 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = v2;
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    uint64_t v4 = v7;
    uint64_t v7 = 0LL;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
  }

  sub_1004DA2D8((uint64_t)sub_1002B594C, v1, *(void **)(v1 + 8), &v7);
  uint64_t v5 = v7;
  uint64_t v7 = 0LL;
  uint64_t result = *(void *)(v1 + 24);
  *(void *)(v1 + 24) = v5;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 8LL))(result);
    uint64_t result = v7;
    uint64_t v7 = 0LL;
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  *(void *)(v1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v0;
  return result;
}

void sub_1002B575C(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182F0E0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    size_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLMonitorGpsExternal::onGpsNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182F0E0);
    }
    id v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      char v15 = "";
      __int16 v16 = 2082;
      __int128 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLMonitorGpsExternal::onGpsNotification, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  (*(void (**)(void, uint64_t, void, uint64_t))(**(void **)(a4 + 40) + 32LL))( *(void *)(a4 + 40),  a1,  *a2,  a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1002B592C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B594C(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182F0E0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    size_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLMonitorGpsExternal::onAccessoryNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182F0E0);
    }
    id v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      char v15 = "";
      __int16 v16 = 2082;
      __int128 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLMonitorGpsExternal::onAccessoryNotification, event:%{public, location:escape_only }s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  (*(void (**)(void, uint64_t, void, uint64_t))(**(void **)(a4 + 40) + 32LL))( *(void *)(a4 + 40),  a1,  *a2,  a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1002B5B1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

id sub_1002B5B3C(uint64_t a1, void *a2)
{
  return sub_1006B85C4(*(void *)(a1 + 40), a2);
}

void sub_1002B5B44(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_1002B5B70()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936068);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936068))
    {
      qword_101936050 = 0LL;
      *(void *)algn_101936058 = 0LL;
      qword_101936060 = 0LL;
      __cxa_atexit((void (*)(void *))sub_1001BA3E4, &qword_101936050, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936068);
    }
  }

void sub_1002B5BD4()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936118);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936118))
    {
      std::__shared_mutex_base::__shared_mutex_base(&stru_101936070);
      __cxa_atexit((void (*)(void *))sub_1001BA414, &stru_101936070, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936118);
    }
  }

void sub_1002B5C48(_Unwind_Exception *a1)
{
}

uint64_t sub_1002B5C60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = off_10182F110;
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + sub_10000AE14(v13 - 32) = a2;
  *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = off_10182F180;
  uint64_t v7 = operator new(0x20uLL);
  v7[1] = 0LL;
  _DWORD v7[2] = 0LL;
  void *v7 = off_10182F1B8;
  *((_DWORD *)v7 + 6) = 31337;
  *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = v7 + 3;
  *(void *)(a1 + 56) = v7;
  *(void *)(a1 + 64) = a3;
  *(void *)(a1 + 72) = a4;
  *(_WORD *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  return a1;
}

uint64_t sub_1002B5CF0(uint64_t a1)
{
  *(void *)a1 = off_10182F110;
  sub_1002B6FB0(a1);
  [*(id *)(a1 + 8) invalidateAndCancel];

  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  uint64_t v2 = *(void *)(a1 + 88);
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  sub_1002B729C((void *)(a1 + 40));
  return a1;
}

void sub_1002B5D60(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002B5CF0(a1);
  operator delete(v1);
}

BOOL sub_1002B5D74(uint64_t a1, uint64_t a2, NSMutableURLRequest *a3, double *a4)
{
  if (!*(void *)(a1 + 8))
  {
    id v8 = [*(id *)(a1 + 32) operationQueue];
    id v9 = +[NSURLSessionConfiguration defaultSessionConfiguration]( &OBJC_CLASS___NSURLSessionConfiguration,  "defaultSessionConfiguration");
    if (qword_101994070 != -1) {
      dispatch_once(&qword_101994070, &stru_10182F1F8);
    }
    uint64_t v10 = +[NSURLSession sessionWithConfiguration:delegate:delegateQueue:]( &OBJC_CLASS___NSURLSession,  "sessionWithConfiguration:delegate:delegateQueue:",  v9,  qword_101994078,  v8);
    *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = v10;
    char v11 = v10;
  }

  if (*a4 <= 0.0)
  {
    if (qword_101934A30 != -1) {
      dispatch_once(&qword_101934A30, &stru_10182F218);
    }
    unint64_t v30 = (os_log_s *)qword_101934A38;
    if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_FAULT))
    {
      double v31 = *a4;
      *(_DWORD *)std::string buf = 68289282;
      int v54 = 0;
      __int16 v55 = 2082;
      __int16 v56 = "";
      __int16 v57 = 2050;
      double v58 = v31;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Ignoring new #filedownload request with invalid timeout, Timeout_s:%{public}.09f}",  buf,  0x1Cu);
      if (qword_101934A30 != -1) {
        dispatch_once(&qword_101934A30, &stru_10182F218);
      }
    }

    uint64_t v32 = qword_101934A38;
    if (!os_signpost_enabled((os_log_t)qword_101934A38)) {
      return 0LL;
    }
    double v33 = *a4;
    *(_DWORD *)std::string buf = 68289282;
    int v54 = 0;
    __int16 v55 = 2082;
    __int16 v56 = "";
    __int16 v57 = 2050;
    double v58 = v33;
    unint64_t v34 = "Ignoring new #filedownload request with invalid timeout";
    __int16 v35 = "{msg%{public}.0s:Ignoring new #filedownload request with invalid timeout, Timeout_s:%{public}.09f}";
LABEL_55:
    unint64_t v38 = (os_log_s *)v32;
    uint32_t v39 = 28;
    goto LABEL_56;
  }

  uint64_t v12 = +[NSURL URLWithString:]( &OBJC_CLASS___NSURL,  "URLWithString:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2, *a4));
  if (!v12)
  {
    if (qword_101934A30 != -1) {
      dispatch_once(&qword_101934A30, &stru_10182F218);
    }
    uint64_t v36 = (os_log_s *)qword_101934A38;
    if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 68289283;
      int v54 = 0;
      __int16 v55 = 2082;
      __int16 v56 = "";
      __int16 v57 = 2081;
      double v58 = *(double *)&a2;
      _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Ignoring new #filedownload request with invalid src string, URLString:%{private, lo cation:escape_only}s}",  buf,  0x1Cu);
      if (qword_101934A30 != -1) {
        dispatch_once(&qword_101934A30, &stru_10182F218);
      }
    }

    uint64_t v32 = qword_101934A38;
    if (!os_signpost_enabled((os_log_t)qword_101934A38)) {
      return 0LL;
    }
    *(_DWORD *)std::string buf = 68289283;
    int v54 = 0;
    __int16 v55 = 2082;
    __int16 v56 = "";
    __int16 v57 = 2081;
    double v58 = *(double *)&a2;
    unint64_t v34 = "Ignoring new #filedownload request with invalid src string";
    __int16 v35 = "{msg%{public}.0s:Ignoring new #filedownload request with invalid src string, URLString:%{private, "
          "location:escape_only}s}";
    goto LABEL_55;
  }

  int v13 = v12;
  __int16 v14 = +[NSMutableURLRequest requestWithURL:](&OBJC_CLASS___NSMutableURLRequest, "requestWithURL:", v12);
  if (!v14)
  {
    if (qword_101934A30 != -1) {
      dispatch_once(&qword_101934A30, &stru_10182F218);
    }
    __int16 v37 = (os_log_s *)qword_101934A38;
    if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 68289283;
      int v54 = 0;
      __int16 v55 = 2082;
      __int16 v56 = "";
      __int16 v57 = 2113;
      double v58 = *(double *)&v13;
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Ignoring new #filedownload request with invalid src url, URL:%{private, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_101934A30 != -1) {
        dispatch_once(&qword_101934A30, &stru_10182F218);
      }
    }

    uint64_t v32 = qword_101934A38;
    if (!os_signpost_enabled((os_log_t)qword_101934A38)) {
      return 0LL;
    }
    *(_DWORD *)std::string buf = 68289283;
    int v54 = 0;
    __int16 v55 = 2082;
    __int16 v56 = "";
    __int16 v57 = 2113;
    double v58 = *(double *)&v13;
    unint64_t v34 = "Ignoring new #filedownload request with invalid src url";
    __int16 v35 = "{msg%{public}.0s:Ignoring new #filedownload request with invalid src url, URL:%{private, location:escape_only}@}";
    goto LABEL_55;
  }

  char v15 = v14;
  -[NSMutableURLRequest setTimeoutInterval:](v14, "setTimeoutInterval:", *a4);
  -[NSMutableURLRequest setAllowsCellularAccess:](v15, "setAllowsCellularAccess:", *(unsigned __int8 *)(a1 + 80));
  if (*(void *)(a1 + 16))
  {
    if (qword_101934A30 != -1) {
      dispatch_once(&qword_101934A30, &stru_10182F218);
    }
    __int16 v16 = (os_log_s *)qword_101934A38;
    if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_FAULT))
    {
      double v17 = COERCE_DOUBLE([*(id *)(a1 + 16) originalRequest]);
      *(_DWORD *)std::string buf = 68289539;
      int v54 = 0;
      __int16 v55 = 2082;
      __int16 v56 = "";
      __int16 v57 = 2113;
      double v58 = v17;
      __int16 v59 = 2113;
      __int16 v60 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Dropping uncancelled #filedownload to service new request, OriginalRequest:%{privat e, location:escape_only}@, NewRequest:%{private, location:escape_only}@}",  buf,  0x26u);
      if (qword_101934A30 != -1) {
        dispatch_once(&qword_101934A30, &stru_10182F218);
      }
    }

    __int16 v18 = (os_log_s *)qword_101934A38;
    if (os_signpost_enabled((os_log_t)qword_101934A38))
    {
      double v19 = COERCE_DOUBLE([*(id *)(a1 + 16) originalRequest]);
      *(_DWORD *)std::string buf = 68289539;
      int v54 = 0;
      __int16 v55 = 2082;
      __int16 v56 = "";
      __int16 v57 = 2113;
      double v58 = v19;
      __int16 v59 = 2113;
      __int16 v60 = v15;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Dropping uncancelled #filedownload to service new request",  "{msg%{public}.0s:Dropping uncancelled #filedownload to service new request, OriginalRequest:%{privat e, location:escape_only}@, NewRequest:%{private, location:escape_only}@}",  buf,  0x26u);
    }

    sub_1002B6880(a1);
  }

  *(void *)(a1 + 96) = 0LL;
  unsigned __int128 v20 =  +[NSURL fileURLWithPath:isDirectory:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:isDirectory:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a3),  0LL);
  *(void *)(a1 + 24) = v20;
  if (!v20)
  {
    if (qword_101934A30 != -1) {
      dispatch_once(&qword_101934A30, &stru_10182F218);
    }
    std::string::size_type v41 = (os_log_s *)qword_101934A38;
    if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 68289539;
      int v54 = 0;
      __int16 v55 = 2082;
      __int16 v56 = "";
      __int16 v57 = 2113;
      double v58 = *(double *)&v15;
      __int16 v59 = 2081;
      __int16 v60 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Ignoring new #filedownload request with invalid dst string, NewRequest:%{private, l ocation:escape_only}@, LocalFileString:%{private, location:escape_only}s}",  buf,  0x26u);
      if (qword_101934A30 != -1) {
        dispatch_once(&qword_101934A30, &stru_10182F218);
      }
    }

    uint64_t v42 = qword_101934A38;
    if (!os_signpost_enabled((os_log_t)qword_101934A38)) {
      return 0LL;
    }
    *(_DWORD *)std::string buf = 68289539;
    int v54 = 0;
    __int16 v55 = 2082;
    __int16 v56 = "";
    __int16 v57 = 2113;
    double v58 = *(double *)&v15;
    __int16 v59 = 2081;
    __int16 v60 = a3;
    unint64_t v34 = "Ignoring new #filedownload request with invalid dst string";
    __int16 v35 = "{msg%{public}.0s:Ignoring new #filedownload request with invalid dst string, NewRequest:%{private,"
          " location:escape_only}@, LocalFileString:%{private, location:escape_only}s}";
    unint64_t v38 = (os_log_s *)v42;
    uint32_t v39 = 38;
LABEL_56:
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v38,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v34,  v35,  buf,  v39);
    return 0LL;
  }

  sub_1002B68E8(a1 + 40, &v51);
  v49[0] = _NSConcreteStackBlock;
  v49[1] = 3321888768LL;
  v49[2] = sub_1002B696C;
  v49[3] = &unk_10182F130;
  v49[4] = a1;
  _OWORD v49[5] = v51;
  std::string::size_type v50 = v52;
  if (v52)
  {
    p_shared_weak_owners = &v52->__shared_weak_owners_;
    do
      unint64_t v22 = __ldxr((unint64_t *)p_shared_weak_owners);
    while (__stxr(v22 + 1, (unint64_t *)p_shared_weak_owners));
  }

  id v23 = [*(id *)(a1 + 8) downloadTaskWithRequest:v15 completionHandler:v49];
  *(void *)(a1 + 16) = v23;
  BOOL v24 = v23 != 0LL;
  if (v23)
  {
    if (qword_101934A30 != -1) {
      dispatch_once(&qword_101934A30, &stru_10182F218);
    }
    int v25 = (os_log_s *)qword_101934A38;
    if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v26 = *(NSMutableURLRequest **)(a1 + 24);
      *(_DWORD *)std::string buf = 68289539;
      int v54 = 0;
      __int16 v55 = 2082;
      __int16 v56 = "";
      __int16 v57 = 2113;
      double v58 = *(double *)&v15;
      __int16 v59 = 2113;
      __int16 v60 = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Created task for #filedownload request, NewRequest:%{private, location:escape_only} @, LocalFile:%{private, location:escape_only}@}",  buf,  0x26u);
    }

    if (*(_BYTE *)(a1 + 81))
    {
      double v27 = *a4;
      uint64_t v28 = operator new(0x30uLL);
      sub_100AD558C((uint64_t)v28, (uint64_t)"CLHttpRequest", a1, v27 * 3.0);
      uint64_t v29 = *(void *)(a1 + 88);
      *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = v28;
      if (v29)
      {
        (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
        uint64_t v28 = *(void **)(a1 + 88);
      }

      sub_1010DDBC0(__p, "download");
      sub_100AD5668((uint64_t)v28, (uint64_t *)__p);
      if (v48 < 0) {
        operator delete(__p[0]);
      }
    }

    if (!*(void *)(a1 + 104)) {
      *(void *)(a1 + 104) = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CLDownloadOSTransaction");
    }
    [*(id *)(a1 + 16) resume];
  }

  else
  {
    if (qword_101934A30 != -1) {
      dispatch_once(&qword_101934A30, &stru_10182F218);
    }
    uint64_t v43 = (os_log_s *)qword_101934A38;
    if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_FAULT))
    {
      int v44 = *(NSMutableURLRequest **)(a1 + 24);
      *(_DWORD *)std::string buf = 68289539;
      int v54 = 0;
      __int16 v55 = 2082;
      __int16 v56 = "";
      __int16 v57 = 2113;
      double v58 = *(double *)&v15;
      __int16 v59 = 2113;
      __int16 v60 = v44;
      _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Could not create task for #filedownload request, NewRequest:%{private, location:esc ape_only}@, LocalFile:%{private, location:escape_only}@}",  buf,  0x26u);
      if (qword_101934A30 != -1) {
        dispatch_once(&qword_101934A30, &stru_10182F218);
      }
    }

    std::string::size_type v45 = (os_log_s *)qword_101934A38;
    if (os_signpost_enabled((os_log_t)qword_101934A38))
    {
      uint64_t v46 = *(NSMutableURLRequest **)(a1 + 24);
      *(_DWORD *)std::string buf = 68289539;
      int v54 = 0;
      __int16 v55 = 2082;
      __int16 v56 = "";
      __int16 v57 = 2113;
      double v58 = *(double *)&v15;
      __int16 v59 = 2113;
      __int16 v60 = v46;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v45,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Could not create task for #filedownload request",  "{msg%{public}.0s:Could not create task for #filedownload request, NewRequest:%{private, location:esc ape_only}@, LocalFile:%{private, location:escape_only}@}",  buf,  0x26u);
    }
  }

  if (v50) {
    std::__shared_weak_count::__release_weak(v50);
  }
  if (v52) {
    std::__shared_weak_count::__release_weak(v52);
  }
  return v24;
}

void sub_1002B682C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, std::__shared_weak_count *a21, uint64_t a22, std::__shared_weak_count *a23)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21) {
    std::__shared_weak_count::__release_weak(a21);
  }
  if (a23) {
    std::__shared_weak_count::__release_weak(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002B6880(uint64_t a1)
{
  *(void *)(a1 + 24) = 0LL;
  [*(id *)(a1 + 16) cancel];

  *(void *)(a1 + 16) = 0LL;
  uint64_t v2 = *(void *)(a1 + 88);
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }

  *(void *)(a1 + 104) = 0LL;
}

void sub_1002B68E8(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
    *a2 = v2;
    a2[1] = v3;
    p_shared_weak_owners = (unint64_t *)&v3->__shared_weak_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_weak_owners);
    while (__stxr(v7 + 1, p_shared_weak_owners));
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  else
  {
    *a2 = v2;
    a2[1] = 0LL;
  }

void sub_1002B696C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (*(void *)(v4 + 8) != -1LL) {
      sub_1002B698C(v5, a2, a3, a4);
    }
  }

void sub_1002B698C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v30 = a4;
  if (a4)
  {
    if (qword_101934A30 != -1) {
      dispatch_once(&qword_101934A30, &stru_10182F218);
    }
    unint64_t v7 = (os_log_s *)qword_101934A38;
    if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *(void *)(a1 + 24);
      *(_DWORD *)std::string buf = 68289795;
      int v32 = 0;
      __int16 v33 = 2082;
      unint64_t v34 = "";
      __int16 v35 = 2113;
      uint64_t v36 = a3;
      __int16 v37 = 2113;
      uint64_t v38 = v8;
      __int16 v39 = 2113;
      id v40 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Error on #filedownload task completion, Response:%{private, location:escape_only}@, LocalFile:%{private, location:escape_only}@, Error:%{private, location:escape_only}@}",  buf,  0x30u);
      if (qword_101934A30 != -1) {
        dispatch_once(&qword_101934A30, &stru_10182F218);
      }
    }

    id v9 = (os_log_s *)qword_101934A38;
    if (os_signpost_enabled((os_log_t)qword_101934A38))
    {
      uint64_t v10 = *(void *)(a1 + 24);
      *(_DWORD *)std::string buf = 68289795;
      int v32 = 0;
      __int16 v33 = 2082;
      unint64_t v34 = "";
      __int16 v35 = 2113;
      uint64_t v36 = a3;
      __int16 v37 = 2113;
      uint64_t v38 = v10;
      __int16 v39 = 2113;
      id v40 = a4;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Error on #filedownload task completion",  "{msg%{public}.0s:Error on #filedownload task completion, Response:%{private, location:escape_only}@, LocalFile:%{private, location:escape_only}@, Error:%{private, location:escape_only}@}",  buf,  0x30u);
    }

    *(void *)(a1 + 96) = [a4 code];
  }

  else
  {
    uint64_t v13 = sub_1002B7140(a3);
    *(void *)(a1 + 96) = v13;
    if (v13)
    {
      if (qword_101934A30 != -1) {
        dispatch_once(&qword_101934A30, &stru_10182F218);
      }
      __int16 v14 = (os_log_s *)qword_101934A38;
      if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_ERROR))
      {
        uint64_t v15 = *(void *)(a1 + 24);
        uint64_t v16 = *(void *)(a1 + 96);
        *(_DWORD *)std::string buf = 68289795;
        int v32 = 0;
        __int16 v33 = 2082;
        unint64_t v34 = "";
        __int16 v35 = 2113;
        uint64_t v36 = a3;
        __int16 v37 = 2113;
        uint64_t v38 = v15;
        __int16 v39 = 1025;
        LODWORD(v4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Protocol error on #filedownload task completion, Response:%{private, location:esc ape_only}@, LocalFile:%{private, location:escape_only}@, ResultCode:%{private}d}",  buf,  0x2Cu);
        if (qword_101934A30 != -1) {
          dispatch_once(&qword_101934A30, &stru_10182F218);
        }
      }

      double v17 = (os_log_s *)qword_101934A38;
      if (os_signpost_enabled((os_log_t)qword_101934A38))
      {
        uint64_t v18 = *(void *)(a1 + 24);
        uint64_t v19 = *(void *)(a1 + 96);
        *(_DWORD *)std::string buf = 68289795;
        int v32 = 0;
        __int16 v33 = 2082;
        unint64_t v34 = "";
        __int16 v35 = 2113;
        uint64_t v36 = a3;
        __int16 v37 = 2113;
        uint64_t v38 = v18;
        __int16 v39 = 1025;
        LODWORD(v4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v19;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v17,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Protocol error on #filedownload task completion",  "{msg%{public}.0s:Protocol error on #filedownload task completion, Response:%{private, location:esc ape_only}@, LocalFile:%{private, location:escape_only}@, ResultCode:%{private}d}",  buf,  0x2Cu);
      }
    }

    else
    {
      if (qword_101934A30 != -1) {
        dispatch_once(&qword_101934A30, &stru_10182F218);
      }
      unsigned __int128 v20 = (os_log_s *)qword_101934A38;
      if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = *(void *)(a1 + 24);
        *(_DWORD *)std::string buf = 68289539;
        int v32 = 0;
        __int16 v33 = 2082;
        unint64_t v34 = "";
        __int16 v35 = 2113;
        uint64_t v36 = a3;
        __int16 v37 = 2113;
        uint64_t v38 = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#filedownload task completed successfully, Response:%{private, location:escape_on ly}@, LocalFile:%{private, location:escape_only}@}",  buf,  0x26u);
      }

      if (!-[NSFileManager replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager", 0LL),  "replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:",  *(void *)(a1 + 24),  a2,  0LL,  1LL,  &v29,  &v30)
        || (id v22 = [*(id *)(a1 + 24) absoluteString],
            (objc_msgSend(v22, "isEqual:", objc_msgSend(v29, "absoluteString")) & 1) == 0))
      {
        if (qword_101934A30 != -1) {
          dispatch_once(&qword_101934A30, &stru_10182F218);
        }
        id v23 = (os_log_s *)qword_101934A38;
        if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_ERROR))
        {
          uint64_t v24 = *(void *)(a1 + 24);
          *(_DWORD *)std::string buf = 68290307;
          int v32 = 0;
          __int16 v33 = 2082;
          unint64_t v34 = "";
          __int16 v35 = 2113;
          uint64_t v36 = a3;
          __int16 v37 = 2113;
          uint64_t v38 = v24;
          __int16 v39 = 2113;
          id v40 = v29;
          __int16 v41 = 2113;
          uint64_t v42 = a2;
          __int16 v43 = 2113;
          id v44 = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Error writing file to disk for completed #filedownload task, Response:%{private , location:escape_only}@, LocalFile:%{private, location:escape_only}@, LostAndFile:%{private, locati on:escape_only}@, TempFile:%{private, location:escape_only}@, Error:%{private, location:escape_only}@}",  buf,  0x44u);
          if (qword_101934A30 != -1) {
            dispatch_once(&qword_101934A30, &stru_10182F218);
          }
        }

        int v25 = (os_log_s *)qword_101934A38;
        if (os_signpost_enabled((os_log_t)qword_101934A38))
        {
          uint64_t v26 = *(void *)(a1 + 24);
          *(_DWORD *)std::string buf = 68290307;
          int v32 = 0;
          __int16 v33 = 2082;
          unint64_t v34 = "";
          __int16 v35 = 2113;
          uint64_t v36 = a3;
          __int16 v37 = 2113;
          uint64_t v38 = v26;
          __int16 v39 = 2113;
          id v40 = v29;
          __int16 v41 = 2113;
          uint64_t v42 = a2;
          __int16 v43 = 2113;
          id v44 = v30;
          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v25,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Error writing file to disk for completed #filedownload task",  "{msg%{public}.0s:Error writing file to disk for completed #filedownload task, Response:%{private , location:escape_only}@, LocalFile:%{private, location:escape_only}@, LostAndFile:%{private, locati on:escape_only}@, TempFile:%{private, location:escape_only}@, Error:%{private, location:escape_only}@}",  buf,  0x44u);
        }

        id v27 = [v30 code];
        uint64_t v28 = 512LL;
        if (v27) {
          uint64_t v28 = (uint64_t)v27;
        }
        *(void *)(a1 + 96) = v28;
      }
    }
  }

  char v11 = *(void (**)(uint64_t, BOOL, void))(a1 + 64);
  if (v11) {
    v11(a1, *(void *)(a1 + 96) == 0LL, *(void *)(a1 + 72));
  }
  sub_1002B6880(a1);
}

uint64_t sub_1002B6F7C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(a2 + 40);
  *(void *)(result + 4std::iostream::~basic_iostream(v2, v3 + 8) = v2;
  if (v2)
  {
    uint64_t v3 = (unint64_t *)(v2 + 16);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

void sub_1002B6FA0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void sub_1002B6FB0(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    if (qword_101934A30 != -1) {
      dispatch_once(&qword_101934A30, &stru_10182F218);
    }
    uint64_t v2 = (os_log_s *)qword_101934A38;
    if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_INFO))
    {
      id v3 = [*(id *)(a1 + 16) originalRequest];
      v4[0] = 68289283;
      v4[1] = 0;
      __int16 v5 = 2082;
      __int128 v6 = "";
      __int16 v7 = 2113;
      id v8 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Cancelling task for #filedownload request, OriginalRequest:%{private, location:escape_only}@}",  (uint8_t *)v4,  0x1Cu);
    }
  }

  sub_1002B6880(a1);
}

void sub_1002B70AC(uint64_t a1)
{
  uint64_t v2 = operator new(0x20uLL);
  _DWORD v2[2] = 0LL;
  *uint64_t v2 = off_10182F1B8;
  v2[1] = 0LL;
  *((void *)&v6 + 1) = v2;
  *((_DWORD *)v2 + 6) = 31337;
  *(void *)&__int128 v6 = v2 + 3;
  sub_10005F550(a1 + 8, &v6);
  id v3 = (std::__shared_weak_count *)*((void *)&v6 + 1);
  if (*((void *)&v6 + 1))
  {
    unint64_t v4 = (unint64_t *)(*((void *)&v6 + 1) + 8LL);
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

uint64_t sub_1002B7140(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___NSHTTPURLResponse);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) == 0) {
    return 0LL;
  }
  id v3 = [a1 statusCode];
  switch((unint64_t)v3)
  {
    case 0x191uLL:
    case 0x197uLL:
      uint64_t result = -1013LL;
      break;
    case 0x192uLL:
    case 0x195uLL:
    case 0x196uLL:
      goto LABEL_7;
    case 0x193uLL:
      uint64_t result = -1102LL;
      break;
    case 0x194uLL:
      uint64_t result = -1100LL;
      break;
    default:
      if (v3 == (id)200) {
        return 0LL;
      }
LABEL_7:
      uint64_t result = -1LL;
      break;
  }

  return result;
}

void sub_1002B7248(void *a1)
{
  uint64_t v1 = sub_1002B729C(a1);
  operator delete(v1);
}

void sub_1002B725C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182F1B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002B7270(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182F1B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void *sub_1002B729C(void *a1)
{
  *a1 = off_10182F180;
  sub_1002B70AC((uint64_t)a1);
  sub_10000AE14((uint64_t)(a1 + 1));
  return a1;
}

void sub_1002B72DC(id a1)
{
  qword_101994078 = objc_alloc_init(&OBJC_CLASS___CLFileDownloadTaskDelegate);
}

void sub_1002B7300(id a1)
{
  qword_101934A38 = (uint64_t)os_log_create("com.apple.locationd.Utility", "Network");
}

void sub_1002B732C(uint64_t a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4)
{
  if (*(_BYTE *)(a2 + 32)) {
    int v7 = 1;
  }
  else {
    int v7 = sub_100E575B0();
  }
  sub_1002F0B04(&__p);
  CFStringRef v8 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsPowerLogEnabled", 0x8000100u, kCFAllocatorNull);
  int v9 = sub_1002A6FD4(__p, (uint64_t)v8, (BOOL *)&v25);
  CFRelease(v8);
  int v10 = v25.__r_.__value_.__s.__data_[0];
  char v11 = (std::__shared_weak_count *)*((void *)&__p + 1);
  if (*((void *)&__p + 1))
  {
    uint64_t v12 = (unint64_t *)(*((void *)&__p + 1) + 8LL);
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  int v14 = v9 ^ 1;
  if (v10) {
    int v14 = 1;
  }
  if ((v7 & v14 & 1) != 0)
  {
    std::operator+<char>(&__p, "MiLo", a3);
    if (v30 >= 0) {
      uint64_t p_p = &__p;
    }
    else {
      uint64_t p_p = (__int128 *)__p;
    }
    sub_100E57638((uint64_t)a4, (uint64_t)p_p);
    if (v30 < 0) {
      operator delete((void *)__p);
    }
    sub_1002A5370(v26);
    sub_1002AFBC8(v26, a4);
    if (*(_BYTE *)(a2 + 32))
    {
      uint64_t v16 = *(void *)(a2 + 24);
      if (!v16) {
        sub_100008BDC();
      }
      (*(void (**)(uint64_t, void *))(*(void *)v16 + 48LL))(v16, v26);
    }

    memset(&v25, 0, sizeof(v25));
    sub_1002AFE38((uint64_t)v26, &v25);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10182F238);
    }
    double v17 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v18 = &v25;
      if ((v25.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v18 = (std::string *)v25.__r_.__value_.__r.__words[0];
      }
      LODWORD(__p) = 136380675;
      *(void *)((char *)&__p + 4) = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "Wrote microlocation metrics to power log: %{private}s",  (uint8_t *)&__p,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10182F238);
      }
      id v23 = &v25;
      if ((v25.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        id v23 = (std::string *)v25.__r_.__value_.__r.__words[0];
      }
      int v27 = 136380675;
      uint64_t v28 = v23;
      uint64_t v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Wrote microlocation metrics to power log: %{private}s",  &v27,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationPowerLog::logMetrics(std::optional<ObserverPowerLogFunction>, std::string, NSDictionary *) const",  "%s\n",  v24);
    }

    uint64_t v19 = (__int128 *)v26;
LABEL_38:
    sub_1002A5590(v19);
    return;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10182F238);
  }
  unsigned __int128 v20 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(__p) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "PowerLog is not enabled so not writing microlocation metrics",  (uint8_t *)&__p,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10182F238);
    }
    LOWORD(v25.__r_.__value_.__l.__data_) = 0;
    id v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "PowerLog is not enabled so not writing microlocation metrics",  &v25,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationPowerLog::logMetrics(std::optional<ObserverPowerLogFunction>, std::string, NSDictionary *) const",  "%s\n",  v22);
  }

  if (*(_BYTE *)(a2 + 32))
  {
    sub_1002A5370(&__p);
    uint64_t v21 = *(void *)(a2 + 24);
    if (!v21) {
      sub_100008BDC();
    }
    (*(void (**)(uint64_t, __int128 *))(*(void *)v21 + 48LL))(v21, &__p);
    uint64_t v19 = &__p;
    goto LABEL_38;
  }

void sub_1002B77D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_1002A5590(&a18);
  _Unwind_Resume(a1);
}

void sub_1002B7844(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1002B7870(uint64_t a1, uint64_t a2)
{
  *id v3 = off_10182F268;
  _WORD v3[8] = a2;
}

uint64_t sub_1002B78AC(uint64_t a1, double a2)
{
  double v3 = a2;
  uint64_t result = *(void *)(a1 + 64);
  if (result) {
    return (*(uint64_t (**)(uint64_t, double *))(*(void *)result + 16LL))(result, &v3);
  }
  return result;
}

BOOL sub_1002B78E0(uint64_t a1, uint64_t a2)
{
  return *(double *)(a2 + 16) + *(double *)(a2 + 24) > 75.0 || sub_100DE96EC(a2);
}

void *sub_1002B7908(void *a1)
{
  *a1 = off_10182F2C0;
  sub_100210A00(a1 + 2);
  return a1;
}

void sub_1002B793C(void *a1)
{
  *a1 = off_10182F2C0;
  sub_100210A00(a1 + 2);
  operator delete(a1);
}

void sub_1002B7AF4(id a1)
{
  qword_1019345D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Fall");
}

uint64_t sub_1002B7B20(uint64_t a1)
{
  uint64_t v2 = sub_1005CACB8(a1, &off_10182F300);
  sub_1005CACB8(v2 + 64, &off_10182F300);
  sub_1005CACB8(a1 + 128, &off_10182F300);
  sub_1005CACB8(a1 + 192, &off_10182F300);
  sub_1005CACB8(a1 + 256, &off_10182F300);
  *(_BYTE *)(a1 + 32sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
  *(void *)(a1 + 336) = 0x25A00000000LL;
  *(_DWORD *)(a1 + 3sub_10000AE14(v13 - 32) = 1031798784;
  *(_BYTE *)(a1 + 2752) = 1;
  *(void *)(a1 + 276std::iostream::~basic_iostream(v2, v3 + 8) = 0x25A00000000LL;
  *(_DWORD *)(a1 + 2764) = 1031798784;
  *(_BYTE *)(a1 + 5184) = 1;
  *(void *)(a1 + 520sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0x25A00000000LL;
  *(_BYTE *)(a1 + 7616) = 1;
  *(_DWORD *)(a1 + 5196) = 1031798784;
  *(void *)(a1 + 76sub_10000AE14(v13 - 32) = 0x25A00000000LL;
  *(_DWORD *)(a1 + 762std::iostream::~basic_iostream(v2, v3 + 8) = 1031798784;
  *(_OWORD *)(a1 + 1004std::iostream::~basic_iostream(v2, v3 + 8) = 0u;
  return a1;
}

uint64_t sub_1002B7BD4(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)(a1 + 10048) < 0x40uLL) {
    return 0LL;
  }
  float v10 = *(float *)(a4 + 16);
  BOOL v11 = *(float *)(a4 + 24) > 30.0 && v10 == 0.0;
  float v12 = v10 * 60.0;
  if (v11) {
    float v13 = 46.154;
  }
  else {
    float v13 = v12;
  }
  float v14 = (float)(480.0 / v13) / 0.04;
  if (v13 <= 20.0) {
    float v14 = 600.0;
  }
  int v15 = (int)fmaxf(v14, 320.0);
  *(void *)int v32 = 0x25A00000000LL;
  sub_1002B8084((unsigned __int16 *)a1, a3, v32);
  unint64_t v28 = 0LL;
  sub_1002B84E0(a1, v15, v32, (uint64_t)v31, (uint64_t)v30, &v28, v13);
  unint64_t v26 = 0LL;
  unint64_t v27 = 0LL;
  if (v28 < 2)
  {
    int v20 = 0;
    float v18 = 0.0;
    float v19 = 0.0;
  }

  else
  {
    float v18 = sub_1002B8648(v13, v17, v31, v30, v28, &v27, &v26);
    int v25 = 0;
    float v19 = sub_1002B87B4(a1, v27, v26, v32, (float *)&v25);
    int v20 = v25;
  }

  *(void *)id v29 = 0x14000000000LL;
  sub_1002B8828(v17, v32, v29);
  int v22 = v21;
  float v24 = sub_1002B8904(v23, v29);
  *(_DWORD *)(a5 + 2sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v20;
  *(float *)(a5 + 24) = v19;
  *(float *)(a5 + 12) = v24;
  *(float *)(a5 + 16) = v18;
  *(_DWORD *)(a5 + std::iostream::~basic_iostream(v2, v3 + 8) = v22;
  *(void *)a5 = *(void *)(a2 + 48);
  *(void *)(a1 + 1004std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  return 1LL;
}

void sub_1002B7DC8(uint64_t a1, float *a2, int *a3)
{
  float v6 = sub_100833470(a2);
  float v7 = a2[4];
  sub_1008335D0(a2, v43);
  float v8 = sub_100DEA49C((uint64_t)v43);
  float v10 = v9;
  int v11 = *a3;
  LODWORD(a3) = a3[1];
  sub_1008335D0(a2, v42);
  sub_1002B89B4((uint64_t)v42, (uint64_t)v43);
  float v12 = sub_1002B8A2C((uint64_t)v43, a2 + 4);
  float v14 = v13;
  float v15 = v7 + v6;
  if (v11 != (_DWORD)a3) {
    float v15 = -(float)(v7 + v6);
  }
  sub_1005CACBC((unsigned __int16 *)a1, v15);
  int v17 = v16;
  sub_1005CACBC((unsigned __int16 *)(a1 + 64), v12);
  int v19 = v18;
  sub_1005CACBC((unsigned __int16 *)(a1 + 128), v14);
  int v21 = v20;
  sub_1005CACBC((unsigned __int16 *)(a1 + 192), v8);
  float v23 = v22;
  sub_1005CACBC((unsigned __int16 *)(a1 + 256), v10);
  if (*(void *)(a1 + 10056) >= 4uLL)
  {
    uint64_t v25 = *(unsigned __int16 *)(a1 + 338);
    unint64_t v26 = *(unsigned int *)(a1 + 340);
    uint64_t v27 = *(unsigned __int16 *)(a1 + 336);
    if (v27 + v25 >= v26) {
      uint64_t v28 = *(unsigned int *)(a1 + 340);
    }
    else {
      uint64_t v28 = 0LL;
    }
    *(_DWORD *)(a1 + 336 + 4 * (v27 + v25 - v28) + std::iostream::~basic_iostream(v2, v3 + 8) = v17;
    if (v26 <= v25)
    {
      if (v27 + 1 < v26) {
        LOWORD(v26) = 0;
      }
      *(_WORD *)(a1 + 336) = v27 + 1 - v26;
    }

    else
    {
      *(_WORD *)(a1 + 33std::iostream::~basic_iostream(v2, v3 + 8) = v25 + 1;
    }

    *(_BYTE *)(a1 + 32sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
    uint64_t v29 = *(unsigned __int16 *)(a1 + 2770);
    unint64_t v30 = *(unsigned int *)(a1 + 2772);
    uint64_t v31 = *(unsigned __int16 *)(a1 + 2768);
    if (v31 + v29 >= v30) {
      uint64_t v32 = *(unsigned int *)(a1 + 2772);
    }
    else {
      uint64_t v32 = 0LL;
    }
    *(_DWORD *)(a1 + 2768 + 4 * (v31 + v29 - v32) + std::iostream::~basic_iostream(v2, v3 + 8) = v19;
    if (v30 <= v29)
    {
      if (v31 + 1 < v30) {
        LOWORD(v3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
      }
      *(_WORD *)(a1 + 276std::iostream::~basic_iostream(v2, v3 + 8) = v31 + 1 - v30;
    }

    else
    {
      *(_WORD *)(a1 + 277sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v29 + 1;
    }

    *(_BYTE *)(a1 + 2752) = 1;
    uint64_t v33 = *(unsigned __int16 *)(a1 + 5202);
    unint64_t v34 = *(unsigned int *)(a1 + 5204);
    uint64_t v35 = *(unsigned __int16 *)(a1 + 5200);
    if (v35 + v33 >= v34) {
      uint64_t v36 = *(unsigned int *)(a1 + 5204);
    }
    else {
      uint64_t v36 = 0LL;
    }
    *(_DWORD *)(a1 + 5200 + 4 * (v35 + v33 - v36) + std::iostream::~basic_iostream(v2, v3 + 8) = v21;
    if (v34 <= v33)
    {
      if (v35 + 1 < v34) {
        LOWORD(v34) = 0;
      }
      *(_WORD *)(a1 + 520sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v35 + 1 - v34;
    }

    else
    {
      *(_WORD *)(a1 + 5202) = v33 + 1;
    }

    *(_BYTE *)(a1 + 5184) = 1;
    float v37 = atan2f(v24, v23);
    uint64_t v38 = *(unsigned __int16 *)(a1 + 7634);
    unint64_t v39 = *(unsigned int *)(a1 + 7636);
    uint64_t v40 = *(unsigned __int16 *)(a1 + 7632);
    if (v40 + v38 >= v39) {
      uint64_t v41 = *(unsigned int *)(a1 + 7636);
    }
    else {
      uint64_t v41 = 0LL;
    }
    *(float *)(a1 + 7632 + 4 * (v40 + v38 - v41) + std::iostream::~basic_iostream(v2, v3 + 8) = v37;
    if (v39 <= v38)
    {
      if (v40 + 1 < v39) {
        LOWORD(v39) = 0;
      }
      *(_WORD *)(a1 + 76sub_10000AE14(v13 - 32) = v40 + 1 - v39;
    }

    else
    {
      *(_WORD *)(a1 + 7634) = v38 + 1;
    }

    *(_BYTE *)(a1 + 7616) = 1;
    ++*(void *)(a1 + 10048);
    *(void *)(a1 + 10056) = 0LL;
  }

void sub_1002B8084(unsigned __int16 *a1, _DWORD *a2, unsigned __int16 *a3)
{
  float v6 = sub_1002B8CC8((uint64_t)a1, a2);
  *(void *)std::string::size_type v50 = 0x25A00000000LL;
  int v49 = 1031798784;
  *(void *)double v47 = 0x25A00000000LL;
  unsigned int v7 = a1[1385];
  if (a1[2601] < v7) {
    unsigned int v7 = a1[2601];
  }
  if (v7)
  {
    __float2 v8 = __sincosf_stret(v6);
    unint64_t v9 = 0LL;
    unsigned __int16 v10 = 0;
    unsigned __int16 v11 = 0;
    unsigned __int16 v12 = 0;
    unsigned __int16 v13 = 0;
    do
    {
      float v14 = *(float *)sub_100208A44(a1 + 1384, v9);
      float v15 = (float)(v8.__sinval * *(float *)sub_100208A44(a1 + 2600, v9)) + (float)(v8.__cosval * v14);
      unint64_t v16 = v12 + (unint64_t)v11;
      if (v16 >= 0x25A) {
        uint64_t v17 = -602LL;
      }
      else {
        uint64_t v17 = 0LL;
      }
      *(float *)&v50[2 * v17 + 4 + 2 * v16] = v15;
      if (v11 > 0x259u)
      {
        if (v12 >= 0x259u) {
          __int16 v18 = -602;
        }
        else {
          __int16 v18 = 0;
        }
        v12 += v18 + 1;
      }

      else
      {
        ++v11;
      }

      float v19 = *(float *)sub_100208A44(a1 + 1384, v9);
      float v20 = (float)(v8.__cosval * *(float *)sub_100208A44(a1 + 2600, v9)) + (float)((float)-v8.__sinval * v19);
      unint64_t v21 = v13 + (unint64_t)v10;
      if (v21 >= 0x25A) {
        uint64_t v22 = -602LL;
      }
      else {
        uint64_t v22 = 0LL;
      }
      *(float *)&v47[2 * v22 + 4 + 2 * v21] = v20;
      if (v10 > 0x259u)
      {
        if (v13 >= 0x259u) {
          __int16 v23 = -602;
        }
        else {
          __int16 v23 = 0;
        }
        v13 += v23 + 1;
      }

      else
      {
        ++v10;
      }

      ++v9;
      else {
        unint64_t v24 = a1[2601];
      }
    }

    while (v9 < v24);
    v50[1] = v11;
    v47[1] = v10;
  }

  else
  {
    unsigned __int16 v10 = 0;
    unsigned __int16 v11 = 0;
    unsigned __int16 v13 = 0;
    unsigned __int16 v12 = 0;
  }

  v50[0] = v12;
  char v48 = 1;
  v47[0] = v13;
  if (a2[1] == 1) {
    float v25 = 1.0;
  }
  else {
    float v25 = -1.0;
  }
  int v26 = v11;
  if (*a2 == 1)
  {
    if (v26)
    {
      unint64_t v27 = 0LL;
      do
      {
        float v28 = *(float *)sub_100208A44(v50, v27);
        float v29 = *(float *)sub_100208A44(v47, v27);
        float v30 = *(float *)sub_100208A44(v47, v27);
        float v31 = sqrt(v28 * v28 + v29 * v29) * (float)((float)(v25 * v30) / fabsf(*(float *)sub_100208A44(v47, v27)));
        uint64_t v32 = a3[1];
        unint64_t v33 = *((unsigned int *)a3 + 1);
        uint64_t v34 = *a3;
        if (v34 + v32 >= v33) {
          uint64_t v35 = *((unsigned int *)a3 + 1);
        }
        else {
          uint64_t v35 = 0LL;
        }
        *(float *)&a3[2 * (v34 + v32 - v35) + 4] = v31;
        if (v33 <= v32)
        {
          if (v34 + 1 < v33) {
            LOWORD(v33) = 0;
          }
          *a3 = v34 + 1 - v33;
        }

        else
        {
          a3[1] = v32 + 1;
        }

        ++v27;
        else {
          unint64_t v36 = v47[1];
        }
      }

      while (v27 < v36);
    }
  }

  else if (v26)
  {
    unint64_t v37 = 0LL;
    do
    {
      float v38 = *(float *)sub_100208A44(v50, v37);
      float v39 = *(float *)sub_100208A44(v47, v37);
      float v40 = *(float *)sub_100208A44(v50, v37);
      float v41 = sqrt(v38 * v38 + v39 * v39) * (float)((float)(v25 * v40) / fabsf(*(float *)sub_100208A44(v50, v37)));
      uint64_t v42 = a3[1];
      unint64_t v43 = *((unsigned int *)a3 + 1);
      uint64_t v44 = *a3;
      if (v44 + v42 >= v43) {
        uint64_t v45 = *((unsigned int *)a3 + 1);
      }
      else {
        uint64_t v45 = 0LL;
      }
      *(float *)&a3[2 * (v44 + v42 - v45) + 4] = v41;
      if (v43 <= v42)
      {
        if (v44 + 1 < v43) {
          LOWORD(v43) = 0;
        }
        *a3 = v44 + 1 - v43;
      }

      else
      {
        a3[1] = v42 + 1;
      }

      ++v37;
      else {
        unint64_t v46 = v47[1];
      }
    }

    while (v37 < v46);
  }

void sub_1002B84E0(uint64_t a1, int a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, void *a6, float a7)
{
  if (a7 >= 46.0)
  {
    float v11 = 0.28571;
  }

  else if (a7 <= 12.0)
  {
    float v11 = 1.4286;
  }

  else
  {
    float v11 = (float)(60.0 / a7) / 3.5;
  }

  unint64_t v17 = 0LL;
  unint64_t v18 = 0LL;
  unint64_t v12 = sub_1002B8F08(a1, a2, (uint64_t)v20, (uint64_t)v19, &v18, &v17, v11);
  unint64_t v13 = v18;
  sub_1002B9098(0.08, v12, (uint64_t)v20, v18, a3, 1);
  unint64_t v14 = v17;
  sub_1002B9098(0.08, v15, (uint64_t)v19, v17, a3, 0);
  sub_1002B91A8( (float)((float)(v11 * 3.5) * 0.7) / 5.0,  (float)((float)(v11 * 3.5) * 0.75) * 0.5,  v16,  v20,  (uint64_t)v19,  v13,  v14,  a4,  a5,  a6);
}

float sub_1002B8648(float a1, uint64_t a2, int *a3, int *a4, unint64_t a5, void *a6, void *a7)
{
  float v7 = 0.0;
  if (a5 < 2) {
    return v7;
  }
  char v8 = 0;
  uint64_t v9 = 30LL;
  if (a5 < 0x1E) {
    uint64_t v9 = a5;
  }
  int v12 = *a3;
  unsigned __int16 v10 = a3 + 1;
  int v11 = v12;
  int v15 = *a4;
  unint64_t v13 = a4 + 1;
  int v14 = v15;
  uint64_t v16 = v9 - 1;
  float v17 = 3.4028e38;
  float v18 = 3.4028e38;
  float v19 = 3.4028e38;
  do
  {
    int v20 = v14;
    int v21 = *v13++;
    int v14 = v21;
    float v22 = (double)(v21 - v20) * 0.04;
    float v23 = 60.0 / v22;
    if (a1 >= 46.154) {
      BOOL v24 = v23 > 34.615;
    }
    else {
      BOOL v24 = fabsf((float)(v23 - a1) / a1) < 0.25;
    }
    int v26 = *v10++;
    int v25 = v26;
    float v27 = (double)(v26 - v11) * 0.04;
    float v28 = vabds_f32(v27, v22);
    if (v28 >= v19) {
      BOOL v24 = 0;
    }
    float v29 = v28;
    if (v24) {
      goto LABEL_11;
    }
    if ((v8 & 1) != 0)
    {
      char v8 = 1;
    }

    else
    {
      if (v28 < v18)
      {
        float v29 = v19;
LABEL_11:
        *a6 = v11;
        *a7 = v25;
        float v19 = v29;
        char v8 = v24;
        float v17 = v22;
        goto LABEL_18;
      }

      char v8 = 0;
    }

    float v28 = v18;
LABEL_18:
    int v11 = v25;
    float v18 = v28;
    --v16;
  }

  while (v16);
  float v30 = 60.0 / v17;
  float v7 = 0.0;
  if (a1 >= 0.0) {
    return a1;
  }
  return v7;
}

float sub_1002B87B4(uint64_t a1, unint64_t a2, unint64_t a3, unsigned __int16 *a4, float *a5)
{
  unint64_t v12 = 0LL;
  sub_1002B97E4(a1, a2, a3, a4, &v12);
  *(_DWORD *)a5 = v8;
  sub_1002B9AA4(v9, a2, a4, v12);
  float result = *a5 / v10;
  if (result > 5.0) {
    float result = 5.0;
  }
  if (result < 0.0) {
    return 0.0;
  }
  return result;
}

void sub_1002B8828(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unint64_t v3 = a2[1];
  unint64_t v4 = v3 - 320;
  if (v3 >= 0x140)
  {
    unint64_t v7 = 0LL;
    float v8 = -3.4028e38;
    float v9 = 3.4028e38;
    do
    {
      float v10 = (float *)sub_100208A44(a2, v4 + v7);
      if (v8 < *v10) {
        float v8 = *v10;
      }
      int v11 = (float *)sub_100208A44(a2, v4 + v7);
      if (*v11 < v9) {
        float v9 = *v11;
      }
      int v12 = *(_DWORD *)sub_100208A44(a2, v4 + v7);
      *(_DWORD *)sub_100208A44(a3, v7++) = v12;
    }

    while (v7 != 320);
  }

float sub_1002B8904(uint64_t a1, unsigned __int16 *a2)
{
  float v3 = sub_1009AF760(25, 0x80uLL, 0.1);
  LODWORD(a2) = sub_1009AF58C(v3);
  float v4 = sub_1009AF760(25, 0x80uLL, 10.0);
  int v5 = sub_1009AF58C(v4);
  return sqrtf(fabsf(sub_1009AF7AC((int)a2, v5, (uint64_t)v8)));
}

float *sub_1002B89B4(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0LL; i != 3; ++i)
  {
    for (unint64_t j = 0LL; j != 3; ++j)
    {
      float v6 = sub_1002B9B68(a1, i, j);
      float result = (float *)sub_1002B9EC4(a2, j, i);
      *float result = v6;
    }
  }

  return result;
}

float sub_1002B8A2C(uint64_t a1, float *a2)
{
  for (unint64_t i = 0LL; i != 3; ++i)
  {
    float v5 = sub_1002B9B68(a1, i, 0LL) * *a2;
    *(float *)sub_1002BA24C((uint64_t)&v11, i) = v5;
    for (unint64_t j = 1LL; j != 3; ++j)
    {
      float v7 = sub_1002B9B68(a1, i, j);
      float v8 = sub_1002B8AF0((uint64_t)a2, j);
      float v9 = (float *)sub_1002BA24C((uint64_t)&v11, i);
      *float v9 = *v9 + (float)(v7 * v8);
    }
  }

  return v11;
}

float sub_1002B8AF0(uint64_t a1, unint64_t a2)
{
  if (a2 >= 3)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182F318);
    }
    float v5 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218240;
      unint64_t v12 = a2;
      __int16 v13 = 2048;
      uint64_t v14 = 3LL;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMVector.h, line 271 ,invalid index %zu >= %zu.",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182F318);
      }
      int v7 = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 3LL;
      float v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMVecto r.h, line 271,invalid index %zu >= %zu.",  (size_t)&v7,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "T CMVector<float, 3>::operator[](const size_t) const [T = float, N = 3]",  "%s\n",  v6);
    }
  }

  return *(float *)(a1 + 4 * a2);
}

float sub_1002B8CC8(uint64_t a1, _DWORD *a2)
{
  else {
    int v4 = *(unsigned __int16 *)(a1 + 7634);
  }
  uint64_t v5 = (v4 - 320);
  if (v5 >= *(unsigned __int16 *)(a1 + 7634))
  {
    int v7 = 0;
    int v6 = 0;
  }

  else
  {
    int v6 = 0;
    int v7 = 0;
    unint64_t v8 = (v4 - 320);
    do
    {
      if (*(float *)sub_100208A44((unsigned __int16 *)(a1 + 7632), v8) >= 1.57079633)
      {
        ++v6;
      }

      else if (*(float *)sub_100208A44((unsigned __int16 *)(a1 + 7632), v8) <= -1.57079633)
      {
        ++v7;
      }

      ++v8;
    }

    while (v8 < *(unsigned __int16 *)(a1 + 7634));
  }

  uint64_t v9 = 0LL;
  if (v7 <= 0 || v6 <= 0) {
    float v11 = 0.0;
  }
  else {
    float v11 = 6.2832;
  }
  unint64_t v12 = (unsigned __int16 *)(a1 + 7632);
  do
  {
    double v13 = *(float *)sub_100208A44(v12, v5 + v9);
    uint64_t v14 = (float *)sub_100208A44(v12, v5 + v9);
    if (v13 <= -1.57079633) {
      float v15 = v11;
    }
    else {
      float v15 = -0.0;
    }
    __src[v9++] = *v14 + v15;
  }

  while (v9 != 320);
  memcpy(__dst, __src, sizeof(__dst));
  sub_100749128((char *)__dst, 4uLL, 0x140uLL, (uint64_t (*)(char *, char *))sub_1002B8EF4);
  float v16 = dbl_1012E4F40[*a2 == 1] + __dst[159];
  double v17 = v16;
  if (v16 > 3.14159265)
  {
    double v18 = -6.28318531;
LABEL_29:
    float v16 = v17 + v18;
    return v16 + 0.0;
  }

  if (v17 < -3.14159265)
  {
    double v18 = 6.28318531;
    goto LABEL_29;
  }

  return v16 + 0.0;
}

BOOL sub_1002B8EF4(float *a1, float *a2)
{
  return *a1 > *a2;
}

unint64_t sub_1002B8F08( uint64_t a1, int a2, uint64_t a3, uint64_t a4, unint64_t *a5, unint64_t *a6, float a7)
{
  int v29 = 30;
  int v30 = 30;
  unint64_t result = sub_1002B9280(a1, a2, &v30, &v29, (uint64_t)v32, (uint64_t)v31);
  uint64_t v15 = a1 + 320;
  int v16 = (*(unsigned __int16 *)(a1 + 338) - a2) & ~((*(unsigned __int16 *)(a1 + 338) - a2) >> 31);
  if (v30 >= 1)
  {
    if (v30 >= 30) {
      uint64_t v17 = 30LL;
    }
    else {
      uint64_t v17 = v30;
    }
    uint64_t v18 = v17 - 1;
    float v19 = (float *)v32;
    do
    {
      float v20 = *v19++;
      unint64_t v21 = sub_1002B9450(-1.0, v20, result, v16, 2, v15, (uint64_t)v33);
      unint64_t result = sub_1002B968C(a7, -1.0, v21, a3, v15, v33, v21);
      *a5 = result;
    }

    while (result <= 5 && v18-- != 0);
  }

  if (v29 >= 1)
  {
    if (v29 >= 30) {
      uint64_t v23 = 30LL;
    }
    else {
      uint64_t v23 = v29;
    }
    uint64_t v24 = v23 - 1;
    int v25 = (float *)v31;
    do
    {
      float v26 = *v25++;
      unint64_t v27 = sub_1002B9450(1.0, v26, result, v16, 2, v15, (uint64_t)v33);
      unint64_t result = sub_1002B968C(a7, 1.0, v27, a4, v15, v33, v27);
      *a6 = result;
    }

    while (result <= 5 && v24-- != 0);
  }

  return result;
}

void sub_1002B9098(float a1, uint64_t a2, uint64_t a3, unint64_t a4, unsigned __int16 *a5, int a6)
{
  if (a6) {
    float v6 = -1.0;
  }
  else {
    float v6 = 1.0;
  }
  if (a4 >= 0x1E) {
    uint64_t v7 = 30LL;
  }
  else {
    uint64_t v7 = a4;
  }
  if (v7)
  {
    uint64_t v10 = 0LL;
    unsigned int v11 = vcvtmd_s64_f64(a1 / 0.04);
    do
    {
      unint64_t v12 = *(unsigned int *)(a3 + 4 * v10);
      if ((int)v12 >= 1 && v12 < a5[1])
      {
        uint64_t v14 = (float *)sub_100208A44(a5, v12);
        int v15 = *(_DWORD *)(a3 + 4 * v10);
        unint64_t v16 = (v15 - v11) & ~((int)(v15 - v11) >> 31);
        int v17 = v11 + 1 + v15;
        uint64_t v18 = v17 >= a5[1] ? a5[1] : v17;
        if ((int)v16 < (int)v18)
        {
          float v19 = v6 * *v14;
          do
          {
            if ((float)(v6 * *(float *)sub_100208A44(a5, v16)) > v19)
            {
              float v19 = v6 * *(float *)sub_100208A44(a5, v16);
              *(_DWORD *)(a3 + 4 * v1sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v16;
            }

            ++v16;
          }

          while (v18 != v16);
        }
      }

      ++v10;
    }

    while (v10 != v7);
  }

void sub_1002B91A8( float a1, float a2, uint64_t a3, _DWORD *a4, uint64_t a5, unint64_t a6, unint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  if (a6 && a7)
  {
    uint64_t v10 = 0LL;
    unint64_t v11 = 0LL;
    signed int v12 = vcvtmd_s64_f64(a1 / 0.04);
    signed int v13 = vcvtmd_s64_f64(a2 / 0.04);
    uint64_t v14 = a7 - 1;
    if (a7 - 1 >= 0x1D) {
      uint64_t v14 = 29LL;
    }
    unint64_t v15 = 30LL;
    if (a6 >= 0x1E) {
      unint64_t v16 = 30LL;
    }
    else {
      unint64_t v16 = a6;
    }
    int v17 = *a4 - v13;
    if (a7 < 0x1E) {
      unint64_t v15 = a7;
    }
    uint64_t v18 = -1LL;
    do
    {
      int v19 = a4[v10];
      if (*(_DWORD *)(a5 + 4 * v14) <= v19) {
        break;
      }
      if (v19 - v17 >= v13)
      {
        uint64_t v20 = v18;
        while (1)
        {
          uint64_t v21 = v20 + 1;
          if (v20 + 1 >= v15) {
            break;
          }
          signed int v22 = *(_DWORD *)(a5 + 4 * v20++ + 4) - v19;
          if (v22 >= v12)
          {
            *(_DWORD *)(a8 + 4 * v11) = v19;
            *(_DWORD *)(a9 + 4 * v11) = *(_DWORD *)(a5 + 4 * v21);
            int v17 = *(_DWORD *)(a5 + 4 * v21);
            *a10 = ++v11;
            uint64_t v18 = v21;
            break;
          }
        }
      }

      if (++v10 >= v16) {
        break;
      }
    }

    while (v11 < 0x1E);
  }

uint64_t sub_1002B9280(uint64_t result, int a2, int *a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  unsigned int v10 = *(unsigned __int16 *)(result + 338);
  unint64_t v11 = (v10 - a2) & ~((int)(v10 - a2) >> 31);
  if (v11 >= v10)
  {
    float v15 = 3.4028e38;
    float v17 = -3.4028e38;
  }

  else
  {
    uint64_t v12 = result;
    signed int v13 = (unsigned __int16 *)(result + 336);
    float v14 = -3.4028e38;
    float v15 = 3.4028e38;
    do
    {
      unint64_t v16 = (float *)sub_100208A44(v13, v11);
      if (v14 < *v16) {
        float v14 = *v16;
      }
      unint64_t result = sub_100208A44(v13, v11);
      ++v11;
    }

    while (v11 < *(unsigned __int16 *)(v12 + 338));
    float v17 = v14 + -1.0;
  }

  float v18 = -1.0 - v15;
  if (v18 < 0.9) {
    float v18 = 0.9;
  }
  if (v17 < 0.5) {
    float v17 = 0.5;
  }
  if (v17 < 0.9) {
    float v17 = 0.9;
  }
  int v19 = vcvtpd_s64_f64((v18 + 0.7) / 0.1);
  if (v19 >= 30) {
    int v19 = 30;
  }
  *a3 = v19;
  int v20 = vcvtpd_s64_f64((v17 + 0.1) / 0.1);
  if (v20 >= 30) {
    LODWORD(v21) = 30;
  }
  else {
    LODWORD(v21) = v20;
  }
  *a4 = v21;
  uint64_t v22 = *a3;
  if ((int)v22 >= 1)
  {
    for (uint64_t i = 0LL; i != v22; ++i)
    {
      float v24 = v18;
      if (i) {
        float v24 = *(float *)(a5 + 4LL * (i - 1)) + -0.1;
      }
      *(float *)(a5 + 4 * i) = v24;
    }
  }

  if (v20 >= 1)
  {
    uint64_t v25 = 0LL;
    else {
      uint64_t v21 = v21;
    }
    do
    {
      float v26 = v17;
      if (v25) {
        float v26 = *(float *)(a6 + 4LL * (v25 - 1)) + -0.1;
      }
      *(float *)(a6 + 4 * v25++) = v26;
    }

    while (v21 != v25);
  }

  return result;
}

unint64_t sub_1002B9450(float a1, float a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  unint64_t v10 = 0LL;
  if (a5 >= 0) {
    int v11 = a5;
  }
  else {
    int v11 = a5 + 1;
  }
  double v12 = (double)(v11 >> 1);
  if (v12 < 1.0) {
    double v12 = 1.0;
  }
  int v13 = (int)v12;
  int v14 = a4 & ~(a4 >> 31);
  else {
    int v15 = (int)v12;
  }
  int v16 = v15 + 1;
  float v17 = (unsigned __int16 *)(a6 + 16);
  int v34 = 2 * v13;
  int v35 = v15;
  int v36 = (int)v12;
  do
  {
    signed int v18 = *(unsigned __int16 *)(a6 + 18);
    if (v14 >= v18 - v16) {
      break;
    }
    unint64_t v19 = v14 & ~(v14 >> 31);
    if (v19 < v18)
    {
      while ((float)(*(float *)sub_100208A44(v17, v19) * a1) <= a2)
      {
      }

      signed int v18 = v19;
    }

uint64_t sub_1002B968C(float a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, int a7)
{
  if (a7 < 1) {
    return 0LL;
  }
  uint64_t v11 = 0LL;
  int v12 = 0;
  uint64_t v13 = 0LL;
  unsigned int v14 = vcvtmd_s64_f64(a1 / 0.04);
  if (a7 >= 30) {
    uint64_t v15 = 30LL;
  }
  else {
    uint64_t v15 = a7;
  }
  int v16 = (unsigned __int16 *)(a5 + 16);
  do
  {
    unint64_t v17 = a6[v11];
    if ((int)v17 > v12 && (int)v17 >= 1 && v17 < *(unsigned __int16 *)(a5 + 18))
    {
      float v20 = *(float *)sub_100208A44(v16, v17) * a2;
      *(_DWORD *)(a4 + 4 * v13) = a6[v11];
      unint64_t v21 = a6;
      uint64_t v22 = v15;
      do
      {
        unint64_t v23 = *v21;
        int v24 = a6[v11];
        if ((int)v23 >= (int)((v24 - v14) & ~((int)(v24 - v14) >> 31)))
        {
          int v25 = v24 + v14;
          if ((int)v23 <= v25 && (float)(*(float *)sub_100208A44(v16, v23) * a2) > v20)
          {
            float v20 = *(float *)sub_100208A44(v16, *v21) * a2;
            *(_DWORD *)(a4 + 4 * v13) = *v21;
          }
        }

        ++v21;
        --v22;
      }

      while (v22);
      int v12 = a6[v11] + v14;
      ++v13;
    }

    ++v11;
  }

  while (v11 != v15);
  return v13;
}

void sub_1002B97E4(uint64_t a1, unint64_t a2, unint64_t a3, unsigned __int16 *a4, void *a5)
{
  unint64_t v5 = a4[1] - 1LL;
  if (v5 >= a3) {
    unint64_t v5 = a3;
  }
  unint64_t v6 = v5 - a2;
  if (v5 > a2)
  {
    unint64_t v10 = v6 + 1;
    uint64_t v11 = 4 * (v6 + 1);
    __chkstk_darwin(a1);
    unsigned int v14 = (char *)&v46 - v13;
    if ((v15 & 1) == 0)
    {
      uint64_t v16 = 0LL;
      do
      {
        if (v16)
        {
          double v17 = *(float *)&v14[4 * v16 - 4];
          int v12 = (float *)sub_100208A44(a4, a2 + v16);
          double v18 = v17 + *v12 * 0.04 * 9.81000042;
        }

        else
        {
          double v18 = 0.0;
        }

        float v19 = v18;
        *(float *)&v14[4 * v16++] = v19;
      }

      while (v10 != v16);
      __chkstk_darwin(v12);
      double v23 = __chkstk_darwin(v20);
      unint64_t v26 = (char *)&v46 - v25;
      if (v6 != -1LL)
      {
        uint64_t v27 = 0LL;
        float v28 = (float)(*(float *)&v23 - v24) / (float)v6;
        do
        {
          if (v27) {
            float v29 = v28 + *(float *)(v22 + 4 * v27 - 4);
          }
          else {
            float v29 = 0.0;
          }
          *(float *)(v22 + 4 * v27) = v29;
          *(float *)&v26[4 * v27] = *(float *)&v14[4 * v27] - v29;
          ++v27;
        }

        while (v10 != v27);
        __chkstk_darwin(v21);
        uint64_t v32 = (char *)&v46 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v33 = 0LL;
        do
        {
          if (v33) {
            double v34 = *(float *)&v32[4 * v33 - 4] + *(float *)(v31 + 4 * v33) * 0.04;
          }
          else {
            double v34 = 0.0;
          }
          float v35 = v34;
          *(float *)&v32[4 * v33++] = v35;
        }

        while (v10 != v33);
        double v37 = __chkstk_darwin(v30);
        float v38 = (char *)&v46 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v39 = 0LL;
        float v42 = 0.0;
        float v43 = (float)(v40 - v41) / *(float *)&v37;
        do
        {
          float v44 = 0.0;
          if (v39) {
            float v44 = v43 + *(float *)&v38[4 * v39 - 4];
          }
          *(float *)&v38[4 * v39] = v44;
          float v45 = vabds_f32(*(float *)(v36 + 4 * v39), v44);
          if (v42 < v45)
          {
            *a5 = v39;
            float v42 = v45;
          }

          ++v39;
        }

        while (v10 != v39);
      }
    }
  }

void sub_1002B9AA4(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unint64_t a4)
{
  unint64_t v4 = a3[1] - a2;
  if (v4 >= a4) {
    unint64_t v4 = a4;
  }
  if (v4)
  {
    unint64_t v8 = 0LL;
    float v9 = 0.0;
    do
    {
      if (fabsf(*(float *)sub_100208A44(a3, a2 + v8)) < 0.8)
      {
        float v10 = v9 + 0.04;
        float v9 = v10;
      }

      ++v8;
      unint64_t v11 = a3[1] - a2;
      if (v11 >= a4) {
        unint64_t v11 = a4;
      }
    }

    while (v8 < v11);
  }

float sub_1002B9B68(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a2 >= 3)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182F318);
    }
    uint64_t v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218240;
      unint64_t v17 = a2;
      __int16 v18 = 2048;
      uint64_t v19 = 3LL;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMMatrix.h, line 7 0,invalid row %zu > %zu.",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182F318);
      }
      int v12 = 134218240;
      unint64_t v13 = a2;
      __int16 v14 = 2048;
      uint64_t v15 = 3LL;
      unint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMMat rix.h, line 70,invalid row %zu > %zu.",  (size_t)&v12,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "T CMMatrix<float, 3>::operator()(size_t, size_t) const [T = float, M = 3, N = 3]",  "%s\n",  v8);
    }
  }

  if (a3 >= 3)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182F318);
    }
    float v9 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218240;
      unint64_t v17 = a3;
      __int16 v18 = 2048;
      uint64_t v19 = 3LL;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMMatrix.h, line 7 1,invalid col %zu > %zu.",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182F318);
      }
      int v12 = 134218240;
      unint64_t v13 = a3;
      __int16 v14 = 2048;
      uint64_t v15 = 3LL;
      LODWORD(v11) = 22;
      float v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMMa trix.h, line 71,invalid col %zu > %zu.",  (size_t)&v12,  v11);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "T CMMatrix<float, 3>::operator()(size_t, size_t) const [T = float, M = 3, N = 3]",  "%s\n",  v10);
    }
  }

  return *(float *)(a1 + 4 * (3 * a3 + a2));
}

uint64_t sub_1002B9EC4(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a2 >= 3)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182F318);
    }
    uint64_t v7 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218240;
      unint64_t v17 = a2;
      __int16 v18 = 2048;
      uint64_t v19 = 3LL;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMMatrix.h, line 7 7,invalid row %zu > %zu.",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182F318);
      }
      int v12 = 134218240;
      unint64_t v13 = a2;
      __int16 v14 = 2048;
      uint64_t v15 = 3LL;
      unint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: row < M, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMMat rix.h, line 77,invalid row %zu > %zu.",  (size_t)&v12,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "T &CMMatrix<float, 3>::operator()(size_t, size_t) [T = float, M = 3, N = 3]",  "%s\n",  v8);
    }
  }

  if (a3 >= 3)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182F318);
    }
    float v9 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218240;
      unint64_t v17 = a3;
      __int16 v18 = 2048;
      uint64_t v19 = 3LL;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMMatrix.h, line 7 8,invalid col %zu > %zu.",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182F318);
      }
      int v12 = 134218240;
      unint64_t v13 = a3;
      __int16 v14 = 2048;
      uint64_t v15 = 3LL;
      LODWORD(v11) = 22;
      float v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: col < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMMa trix.h, line 78,invalid col %zu > %zu.",  (size_t)&v12,  v11);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "T &CMMatrix<float, 3>::operator()(size_t, size_t) [T = float, M = 3, N = 3]",  "%s\n",  v10);
    }
  }

  return a1 + 4 * (3 * a3 + a2);
}

void sub_1002BA220(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_1002BA24C(uint64_t a1, unint64_t a2)
{
  if (a2 >= 3)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182F318);
    }
    unint64_t v5 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218240;
      unint64_t v12 = a2;
      __int16 v13 = 2048;
      uint64_t v14 = 3LL;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMVector.h, line 277 ,invalid index %zu >= %zu.",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182F318);
      }
      int v7 = 134218240;
      unint64_t v8 = a2;
      __int16 v9 = 2048;
      uint64_t v10 = 3LL;
      unint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: i < N, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/Math/CMVecto r.h, line 277,invalid index %zu >= %zu.",  (size_t)&v7,  22);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "T &CMVector<float, 3>::operator[](const size_t) [T = float, N = 3]",  "%s\n",  v6);
    }
  }

  return a1 + 4 * a2;
}

void sub_1002BA4C8(id a1)
{
  qword_101994098 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLSedentaryTimerNotifierSilo");
}

uint64_t sub_1002BA57C(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1002BB764;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_1019940B8 != -1) {
    dispatch_once(&qword_1019940B8, block);
  }
  return qword_1019A0E20;
}

void sub_1002BA8EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002BA910(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(_BYTE *)(a1 + 120))
  {
    if (*(_BYTE *)(a1 + 176))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182F5F0);
      }
      unint64_t v5 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
      {
        else {
          double v6 = *(double *)a2;
        }
        int v7 = *(unsigned __int8 *)(a1 + 176);
        *(_DWORD *)std::string buf = 136446466;
        double v55 = v6;
        __int16 v56 = 1026;
        *(_DWORD *)__int16 v57 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "SedentaryAlarm,Error starting,client,%{public}s,armed,%{public}d",  buf,  0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182F5F0);
        }
        else {
          double v32 = *(double *)a2;
        }
        int v33 = *(unsigned __int8 *)(a1 + 176);
        int v46 = 136446466;
        double v47 = v32;
        __int16 v48 = 1026;
        *(_DWORD *)int v49 = v33;
        double v34 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "SedentaryAlarm,Error starting,client,%{public}s,armed,%{public}d",  &v46,  18);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLSedentaryTimerNotifier::startTimer(const std::string &, NSDictionary *)",  "%s\n",  v34);
      }

      return 108LL;
    }

    else
    {
      objc_msgSend(objc_msgSend(a3, "objectForKeyedSubscript:", CMSedentaryTimerStartTimeKey), "doubleValue");
      double v14 = v13;
      uint64_t v15 = -[NSDate initWithTimeIntervalSinceReferenceDate:]( objc_alloc(&OBJC_CLASS___NSDate),  "initWithTimeIntervalSinceReferenceDate:",  v13);
      uint64_t v16 = -[NSCalendar components:fromDate:]( +[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"),  "components:fromDate:",  192LL,  v15);
      NSInteger v17 = -[NSDateComponents minute](v16, "minute");
      NSInteger v18 = -[NSDateComponents second](v16, "second");
      if (v17 | v18)
      {
        NSInteger v19 = v18;
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182F5F0);
        }
        uint64_t v20 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 134218496;
          double v55 = v14;
          __int16 v56 = 2048;
          *(void *)__int16 v57 = v17;
          *(_WORD *)&v57[8] = 2048;
          NSInteger v58 = v19;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "SedentaryAlarm,startDate sent that doesn't align with the wall hour,%f,minuteOffset,%ld,secondOffset,%ld",  buf,  0x20u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10182F5F0);
          }
          int v46 = 134218496;
          double v47 = v14;
          __int16 v48 = 2048;
          *(void *)int v49 = v17;
          *(_WORD *)&v49[8] = 2048;
          NSInteger v50 = v19;
          float v40 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "SedentaryAlarm,startDate sent that doesn't align with the wall hour,%f,minuteOffset,%ld,secondOffset,%ld",  COERCE_DOUBLE(&v46),  32,  v41);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLSedentaryTimerNotifier::startTimer(const std::string &, NSDictionary *)",  "%s\n",  v40);
        }
      }

      -[NSDate timeIntervalSinceReferenceDate]( +[NSDate date](&OBJC_CLASS___NSDate, "date"),  "timeIntervalSinceReferenceDate");
      int v22 = (int)(v14 - v21);
      WORD1(v41) = v22;
      objc_msgSend(objc_msgSend(a3, "objectForKeyedSubscript:", CMSedentaryTimerPeriodIntervalKey), "doubleValue");
      unsigned int v24 = (int)v23;
      WORD2(v41) = (int)v23;
      objc_msgSend(objc_msgSend(a3, "objectForKeyedSubscript:", CMSedentaryTimerReminderIntervalKey), "doubleValue");
      unsigned int v26 = (int)v25;
      HIWORD(v41) = (int)v25;
      unsigned int v27 = objc_msgSend( objc_msgSend(a3, "objectForKeyedSubscript:", CMSedentaryTimerAutoRescheduleKey),  "BOOLValue");
      LOBYTE(v42) = v27;
      HIWORD(v42) = *(_DWORD *)(a1 + 268);
      __int16 v43 = *(_DWORD *)(a1 + 280);
      char v44 = *(_DWORD *)(a1 + 292);
      char v45 = *(_DWORD *)(a1 + 304);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182F5F0);
      }
      float v28 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        else {
          double v29 = *(double *)a2;
        }
        *(_DWORD *)std::string buf = 136316418;
        double v55 = v29;
        __int16 v56 = 1024;
        *(_DWORD *)__int16 v57 = v22;
        *(_WORD *)&v57[4] = 1024;
        *(_DWORD *)&v57[6] = v24;
        LOWORD(v5std::iostream::~basic_iostream(v2, v3 + 8) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v26;
        HIWORD(v5std::iostream::~basic_iostream(v2, v3 + 8) = 1024;
        unsigned int v59 = v27;
        __int16 v60 = 2048;
        double v61 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "SedentaryAlarm,START,client,%s,offset,%d,period,%d,reminder,%d,autoReschedule,%d,startDate,%f",  buf,  0x2Eu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182F5F0);
        }
        else {
          double v38 = *(double *)a2;
        }
        int v46 = 136316418;
        double v47 = v38;
        __int16 v48 = 1024;
        *(_DWORD *)int v49 = v22;
        *(_WORD *)&v49[4] = 1024;
        *(_DWORD *)&void v49[6] = v24;
        LOWORD(v5sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1024;
        *(_DWORD *)((char *)&v50 + 2) = v26;
        HIWORD(v5sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1024;
        unsigned int v51 = v27;
        __int16 v52 = 2048;
        double v53 = v14;
        uint64_t v39 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "SedentaryAlarm,START,client,%s,offset,%d,period,%d,reminder,%d,autoReschedule,%d,startDate,%f",  (const char *)&v46,  46,  v41,  v42);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLSedentaryTimerNotifier::startTimer(const std::string &, NSDictionary *)",  "%s\n",  v39);
      }

      if (v22 >= 0) {
        LOWORD(v3sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v22;
      }
      else {
        int v30 = -v22;
      }
      uint64_t result = 107LL;
      if (v24 && v26 < v24 && v24 > (unsigned __int16)v30)
      {
        uint64_t v31 = sub_1008FA854(0);
        (*(void (**)(uint64_t, char *))(*(void *)(v31 + 64) + 24LL))(v31 + 64, (char *)&v41 + 2);
        *(_BYTE *)(a1 + 176) = 1;
        return 100LL;
      }
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182F5F0);
    }
    __int16 v9 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
    {
      else {
        double v10 = *(double *)a2;
      }
      int v11 = *(unsigned __int8 *)(a1 + 120);
      *(_DWORD *)std::string buf = 136446466;
      double v55 = v10;
      __int16 v56 = 1026;
      *(_DWORD *)__int16 v57 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "SedentaryAlarm,Error starting,client,%{public}s,fitness tracking,%{public}d",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182F5F0);
      }
      else {
        double v35 = *(double *)a2;
      }
      int v36 = *(unsigned __int8 *)(a1 + 120);
      int v46 = 136446466;
      double v47 = v35;
      __int16 v48 = 1026;
      *(_DWORD *)int v49 = v36;
      double v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "SedentaryAlarm,Error starting,client,%{public}s,fitness tracking,%{public}d",  &v46,  18);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLSedentaryTimerNotifier::startTimer(const std::string &, NSDictionary *)",  "%s\n",  v37);
    }

    return 109LL;
  }

  return result;
}

void sub_1002BB324( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002BB348(uint64_t a1)
{
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10182F5F0);
  }
  uint64_t v2 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SedentaryAlarm,STOP", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182F5F0);
    }
    v6[0] = 0;
    unint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "SedentaryAlarm,STOP",  v6,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLSedentaryTimerNotifier::stopTimer(const std::string &)",  "%s\n",  v5);
  }

  uint64_t v3 = sub_1008FA854(0);
  (*(void (**)(uint64_t))(*(void *)(v3 + 64) + 32LL))(v3 + 64);
  *(_BYTE *)(a1 + 176) = 0;
  return 100LL;
}

void sub_1002BB728(id a1)
{
  if (sub_1004F7000() && sub_1008FA690())
  {
    sub_1004F2598();
  }

uint64_t sub_1002BB764(uint64_t a1)
{
  uint64_t v2 = operator new(0x180uLL);
  uint64_t result = sub_1002BB7B0((uint64_t)v2, *(void **)(a1 + 32));
  qword_1019A0E20 = (uint64_t)v2;
  return result;
}

void sub_1002BB79C(_Unwind_Exception *a1)
{
}

uint64_t sub_1002BB7B0(uint64_t a1, void *a2)
{
  uint64_t v3 = sub_1002BBCFC(a1, "CLSedentaryTimerNotifier", a2);
  *(void *)(v3 + 112) = off_10182F478;
  uint64_t v4 = v3 + 112;
  *(void *)uint64_t v3 = off_10182F388;
  *(_BYTE *)(v3 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0;
  *(void *)(v3 + 121) = 0x10000000000000LL;
  *(void *)(v3 + 129) = 0LL;
  *(_DWORD *)(v3 + 137) = 0;
  *(_OWORD *)(v3 + 144) = 0u;
  uint64_t v5 = v3 + 144;
  *(_OWORD *)(v3 + 16sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0u;
  *(_BYTE *)(v3 + 176) = 0;
  double v6 = operator new(0x200uLL);
  sub_100F64574(v6, 0LL);
  sub_1002C00A8((void *)(a1 + 184), (uint64_t)v6);
  int v7 = *(std::__shared_weak_count **)(a1 + 192);
  uint64_t v33 = *(void *)(a1 + 184);
  double v34 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  sub_1001B4E14(a1 + 200, &v33);
  double v10 = v34;
  if (v34)
  {
    int v11 = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  *(CFAbsoluteTime *)(a1 + 24std::iostream::~basic_iostream(v2, v3 + 8) = CFAbsoluteTimeGetCurrent();
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 28std::iostream::~basic_iostream(v2, v3 + 8) = 0u;
  *(void *)(a1 + 304) = 0LL;
  LODWORD(v35[0]) = 90;
  sub_10023AE2C((unsigned __int8 *)(a1 + 264), "SedentaryTimerActiveWindow", v35, 0);
  LODWORD(v35[0]) = 60;
  sub_10023AE2C((unsigned __int8 *)(a1 + 276), "SedentaryTimerActiveThreshold", v35, 0);
  LODWORD(v35[0]) = 50;
  sub_10023AE2C((unsigned __int8 *)(a1 + 288), "SedentaryTimerStepCountThreshold", v35, 0);
  LODWORD(v35[0]) = 20;
  sub_10023AE2C((unsigned __int8 *)(a1 + 300), "SedentaryTimerPushCountThreshold", v35, 0);
  *(_OWORD *)(a1 + 312) = xmmword_1012E4F78;
  *(_OWORD *)(a1 + 32std::iostream::~basic_iostream(v2, v3 + 8) = unk_1012E4F88;
  *(_OWORD *)(a1 + 344) = xmmword_1012E4F98;
  *(_OWORD *)(a1 + 356) = *(__int128 *)((char *)&xmmword_1012E4F98 + 12);
  *(_DWORD *)(a1 + 372) = 1;
  double v13 = (void **)(a1 + 376);
  *(void *)(a1 + 376) = 0LL;
  sub_10060B0A4((uint64_t)sub_1002BBD98, a1, *(void **)(a1 + 32), v35);
  uint64_t v14 = v35[0];
  v35[0] = 0LL;
  uint64_t v15 = *(void *)v5;
  *(void *)uint64_t v5 = v14;
  if (v15)
  {
    (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    uint64_t v16 = v35[0];
    v35[0] = 0LL;
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
    }
  }

  [*(id *)(*(void *)v5 + 16) register:*(void *)(*(void *)v5 + 8) forNotification:0 registrationInfo:0];
  [*(id *)(*(void *)v5 + 16) register:*(void *)(*(void *)v5 + 8) forNotification:4 registrationInfo:0];
  sub_100DAA9F8((uint64_t)sub_1002BBF70, a1, *(void **)(a1 + 32), v35);
  uint64_t v17 = v35[0];
  v35[0] = 0LL;
  uint64_t v18 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = v17;
  if (v18)
  {
    (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    uint64_t v19 = v35[0];
    v35[0] = 0LL;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
    }
  }

  [*(id *)(*(void *)(a1 + 152) + 16) register:*(void *)(*(void *)(a1 + 152) + 8) forNotification:1 registrationInfo:0];
  sub_100E18F18((uint64_t)sub_1002BC150, a1, *(void **)(a1 + 32), v35);
  uint64_t v20 = v35[0];
  v35[0] = 0LL;
  uint64_t v21 = *(void *)(a1 + 160);
  *(void *)(a1 + 16sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v20;
  if (v21)
  {
    (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
    uint64_t v22 = v35[0];
    v35[0] = 0LL;
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
    }
  }

  [*(id *)(*(void *)(a1 + 160) + 16) register:*(void *)(*(void *)(a1 + 160) + 8) forNotification:2 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 160) + 16) register:*(void *)(*(void *)(a1 + 160) + 8) forNotification:5 registrationInfo:0];
  double v23 = operator new(0x130uLL);
  sub_10025854C((uint64_t)v23, (__int128 *)(a1 + 312), v4);
  unsigned int v24 = *v13;
  unsigned __int16 *v13 = v23;
  if (v24) {
    sub_1002C0ED8(a1 + 376, v24);
  }
  uint64_t v25 = sub_1008FA854(0);
  v32[0] = _NSConcreteStackBlock;
  v32[1] = 3221225472LL;
  void v32[2] = sub_1002BC328;
  void v32[3] = &unk_10182F4B8;
  void v32[4] = a1;
  (*(void (**)(uint64_t, void *))(*(void *)(v25 + 64) + 16LL))(v25 + 64, v32);
  *(_BYTE *)(a1 + 24sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 1;
  sub_1002BC930((void **)(a1 + 200), 604800.0);
  sub_1002BCBE4(a1);
  uint64_t v26 = *(void *)(a1 + 184);
  unsigned int v27 = *(void **)(a1 + 40);
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 3221225472LL;
  v35[2] = sub_1002BD47C;
  v35[3] = &unk_10182F4F8;
  v35[4] = a1;
  sub_100F645BC(v26, v27, v35);
  float v28 = +[NSNotificationCenter defaultCenter](&OBJC_CLASS___NSNotificationCenter, "defaultCenter");
  id v29 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "silo"), "operationQueue");
  v31[0] = _NSConcreteStackBlock;
  v31[1] = 3221225472LL;
  v31[2] = sub_1002BCD30;
  void v31[3] = &unk_10182F4D8;
  _DWORD v31[4] = a1;
  *(void *)(a1 + 16std::iostream::~basic_iostream(v2, v3 + 8) = -[NSNotificationCenter addObserverForName:object:queue:usingBlock:]( v28,  "addObserverForName:object:queue:usingBlock:",  NSSystemTimeZoneDidChangeNotification,  0LL,  v29,  v31);
  return a1;
}

void sub_1002BBC18( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  unsigned int v27 = (void *)*v23;
  *double v23 = 0LL;
  if (v27) {
    sub_1002C0ED8((uint64_t)v23, v27);
  }
  sub_1001B4FBC(v22);
  sub_10000AE14(v21);
  uint64_t v28 = *(void *)(v20 + 160);
  *(void *)(v20 + 16sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
  }
  uint64_t v29 = *(void *)(v20 + 152);
  *(void *)(v20 + 152) = 0LL;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
  }
  uint64_t v30 = *v25;
  *uint64_t v25 = 0LL;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
  }
  sub_1002BCD40(v20);
  _Unwind_Resume(a1);
}

uint64_t sub_1002BBCFC(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_10182F620;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + sub_10000AE14(v13 - 32) = a3;
  *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = [a3 silo];
  *(void *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 10std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  return a1;
}

void sub_1002BBD7C(_Unwind_Exception *exception_object)
{
}

void sub_1002BBD98(uint64_t a1, _DWORD *a2, _BYTE *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182F5D0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    unint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLSedentaryTimerNotifier::onFitnessTrackingNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182F5D0);
    }
    unint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLSedentaryTimerNotifier::onFitnessTrackingNotification, event:%{public, location:e scape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_1002BD978(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1002BBF50( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002BBF70(uint64_t a1, _DWORD *a2, __int128 *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182F5D0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v7 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLSedentaryTimerNotifier::onMotionStateObserverNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182F5D0);
    }
    unint64_t v8 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLSedentaryTimerNotifier::onMotionStateObserverNotification, event:%{public, locati on:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  if (*a2 == 1)
  {
    __int128 v9 = *a3;
    *(_DWORD *)(a4 + 137) = *((_DWORD *)a3 + 4);
    *(_OWORD *)(a4 + 121) = v9;
  }

  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1002BC134( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002BC150(uint64_t a1, _DWORD *a2, __int128 *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182F5D0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    unint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLSedentaryTimerNotifier::onNatalimetryNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182F5D0);
    }
    __int128 v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::string buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLSedentaryTimerNotifier::onNatalimetryNotification, event:%{public, location:escap e_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_1002BDE6C(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_1002BC308( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

id sub_1002BC328(uint64_t a1, int a2, char a3, double a4, double a5)
{
  uint64_t v5 = *(void *)(a1 + 32);
  double v6 = *(void **)(v5 + 40);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  void v8[2] = sub_1002BC38C;
  void v8[3] = &unk_10182F498;
  _DWORD v8[4] = v5;
  *(double *)&void v8[5] = a4;
  *(double *)&v8[6] = a5;
  int v9 = a2;
  char v10 = a3;
  return [v6 async:v8];
}

void sub_1002BC38C(uint64_t a1)
{
}

void sub_1002BC3A4(uint64_t a1, int a2, char a3, double a4, double a5)
{
  if (a2 <= 4)
  {
    if (*(_BYTE *)(a1 + 120))
    {
      int v7 = a2;
      double Current = CFAbsoluteTimeGetCurrent();
      if (v7 == 3 || !v7)
      {
        double v11 = *(double *)(a1 + 121);
        BOOL v12 = Current > v11 && Current - v11 < 320.0;
        if (v12 && *(int *)(a1 + 133) >= 1)
        {
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10182F5F0);
          }
          int v13 = (os_log_s *)qword_1019344B8;
          if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
          {
            CFAbsoluteTime v14 = CFAbsoluteTimeGetCurrent();
            double v15 = *(double *)(a1 + 121);
            *(_DWORD *)std::string buf = 134218240;
            *(CFAbsoluteTime *)&uint8_t buf[4] = v14;
            __int16 v37 = 2048;
            double v38 = v15;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "SedentaryAlarm,InVehicleReminder,now,%.3f,motionStateTime,%.3f",  buf,  0x16u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344B0 != -1) {
              dispatch_once(&qword_1019344B0, &stru_10182F5F0);
            }
            uint64_t v23 = qword_1019344B8;
            CFAbsoluteTime v24 = CFAbsoluteTimeGetCurrent();
            uint64_t v25 = *(void *)(a1 + 121);
            *(_DWORD *)double v35 = 134218240;
            *(CFAbsoluteTime *)&v35[4] = v24;
            *(_WORD *)&v35[12] = 2048;
            *(void *)&v35[14] = v25;
            LODWORD(v27) = 22;
            uint64_t v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v23,  0LL,  "SedentaryAlarm,InVehicleReminder,now,%.3f,motionStateTime,%.3f",  COERCE_DOUBLE(v35),  v27);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSedentaryTimerNotifier::onSedentaryAlarm(const CFAbsoluteTime, const CFAbsoluteTime, const CLSedent aryAlarmType, const BOOL)",  "%s\n",  v26);
            if (v26 != buf) {
              free(v26);
            }
          }

          int v7 = 4;
        }
      }

      *(double *)double v35 = a4;
      *(double *)&v35[8] = a5;
      *(_DWORD *)&v35[16] = v7;
      v35[20] = a3;
      *(void *)&v35[24] = 0LL;
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182F5F0);
      }
      __int16 v16 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134349568;
        *(double *)&uint8_t buf[4] = a4;
        __int16 v37 = 2050;
        double v38 = a5;
        __int16 v39 = 1026;
        int v40 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "StandPlus,aop alarm,startTime,%{public}f,firedTime,%{public}f,type,%{public}d",  buf,  0x1Cu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182F5F0);
        }
        int v29 = 134349568;
        double v30 = a4;
        __int16 v31 = 2050;
        double v32 = a5;
        __int16 v33 = 1026;
        int v34 = v7;
        LODWORD(v27) = 28;
        uint64_t v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "StandPlus,aop alarm,startTime,%{public}f,firedTime,%{public}f,type,%{public}d",  &v29,  *(void *)&v27);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSedentaryTimerNotifier::onSedentaryAlarm(const CFAbsoluteTime, const CFAbsoluteTime, const CLSedentaryA larmType, const BOOL)",  "%s\n",  v22);
        if (v22 != buf) {
          free(v22);
        }
      }

      uint64_t v17 = *(void *)(a1 + 376);
      if (v17)
      {
        sub_1002597E4(v17, (uint64_t)v35);
      }

      else
      {
        v28[0] = *(_OWORD *)v35;
        v28[1] = *(_OWORD *)&v35[16];
        (*(void (**)(uint64_t, _OWORD *))(*(void *)a1 + 216LL))(a1, v28);
      }
    }

    else
    {
      sub_1010DDBC0(buf, "com.apple.locationd");
      sub_1002BB348(a1);
      if (SHIBYTE(v39) < 0) {
        operator delete(*(void **)buf);
      }
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182F5F0);
      }
      __int16 v18 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        int v19 = *(unsigned __int8 *)(a1 + 120);
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "SedentaryAlarm,STOP,fitness tracking,%d",  buf,  8u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182F5F0);
        }
        int v20 = *(unsigned __int8 *)(a1 + 120);
        *(_DWORD *)double v35 = 67109120;
        *(_DWORD *)&v35[4] = v20;
        uint64_t v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "SedentaryAlarm,STOP,fitness tracking,%d",  v35);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSedentaryTimerNotifier::onSedentaryAlarm(const CFAbsoluteTime, const CFAbsoluteTime, const CLSedentaryA larmType, const BOOL)",  "%s\n",  v21);
        if (v21 != buf) {
          free(v21);
        }
      }
    }
  }

void sub_1002BC90C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002BC930(void **a1, double a2)
{
  if (a2 >= 0.0)
  {
    unint64_t v8 = a1[2];
    uint64_t v6 = (uint64_t)(a1 + 2);
    int v7 = v8;
    unint64_t v9 = *(void *)(v6 - 8);
    if (v9 >= (unint64_t)v8)
    {
      unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - (void)*a1) >> 3);
      unint64_t v12 = v11 + 1;
      if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100007008();
      }
      unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (_BYTE *)*a1) >> 3);
      if (2 * v13 > v12) {
        unint64_t v12 = 2 * v13;
      }
      if (v13 >= 0x555555555555555LL) {
        unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14) {
        double v15 = (char *)sub_10000701C(v6, v14);
      }
      else {
        double v15 = 0LL;
      }
      __int16 v16 = &v15[24 * v11];
      uint64_t v17 = &v15[24 * v14];
      *(double *)__int16 v16 = a2;
      *((void *)v16 + 1) = 0x7FEFFFFFFFFFFFFFLL;
      v16[16] = 0;
      char v10 = v16 + 24;
      int v19 = (char *)*a1;
      __int16 v18 = (char *)a1[1];
      if (v18 != *a1)
      {
        do
        {
          __int128 v20 = *(_OWORD *)(v18 - 24);
          *(v16 - std::iostream::~basic_iostream(v2, v3 + 8) = *(v18 - 8);
          *(_OWORD *)(v16 - 24) = v20;
          v16 -= 24;
          v18 -= 24;
        }

        while (v18 != v19);
        __int16 v18 = (char *)*a1;
      }

      *a1 = v16;
      a1[1] = v10;
      a1[2] = v17;
      if (v18) {
        operator delete(v18);
      }
    }

    else
    {
      *(double *)unint64_t v9 = a2;
      *(void *)(v9 + std::iostream::~basic_iostream(v2, v3 + 8) = 0x7FEFFFFFFFFFFFFFLL;
      *(_BYTE *)(v9 + 16) = 0;
      char v10 = (char *)(v9 + 24);
    }

    a1[1] = v10;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182F768);
    }
    uint64_t v3 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134349056;
      double v24 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Programmer error, this expiration rule with time %{public}fis not valid.",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182F768);
      }
      int v21 = 134349056;
      double v22 = a2;
      uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Programmer error, this expiration rule with time %{public}fis not valid.",  &v21,  12);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLActivityAggregator<CLSedentaryAlarmData>::setExpirationRule(CFTimeInterval) [T = CLSedentaryAlarmData, Da taProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v4);
    }
  }

void sub_1002BCBE4(uint64_t a1)
{
  int v13 = 86400;
  uint64_t v2 = sub_1006E27E8();
  sub_100413284(v2, &v11);
  int v3 = sub_1002A7CB0(v11, "SedentaryTimerAggregateInterval", &v13);
  uint64_t v4 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  if (v3) {
    uint64_t v7 = 1000000000LL * v13;
  }
  else {
    uint64_t v7 = 86400000000000LL;
  }
  unint64_t v8 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0,  0,  (dispatch_queue_t)[*(id *)(a1 + 40) queue]);
  *(void *)(a1 + 256) = v8;
  dispatch_source_set_timer(v8, 0LL, v7, 0xDF8475800uLL);
  unint64_t v9 = *(dispatch_source_s **)(a1 + 256);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = sub_1002BCEFC;
  void v10[3] = &unk_10181D3D0;
  v10[4] = a1;
  dispatch_source_set_event_handler(v9, v10);
  dispatch_resume(*(dispatch_object_t *)(a1 + 256));
}

void sub_1002BCD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

id sub_1002BCD30(uint64_t a1, uint64_t a2)
{
  return _[*(id *)(*(void *)(a1 + 32) + 32) timeZoneDidChange:a2];
}

uint64_t sub_1002BCD40(uint64_t a1)
{
  *(void *)a1 = off_10182F620;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

uint64_t sub_1002BCDB4(uint64_t a1)
{
  *(void *)a1 = off_10182F388;
  *(void *)(a1 + 112) = off_10182F478;
  if (*(void *)(a1 + 168))
  {
    -[NSNotificationCenter removeObserver:]( +[NSNotificationCenter defaultCenter](&OBJC_CLASS___NSNotificationCenter, "defaultCenter"),  "removeObserver:",  *(void *)(a1 + 168));
    *(void *)(a1 + 16std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  }

  *(_BYTE *)(a1 + 10std::iostream::~basic_iostream(v2, v3 + 8) = 1;
  uint64_t v2 = *(void **)(a1 + 376);
  *(void *)(a1 + 376) = 0LL;
  if (v2) {
    sub_1002C0ED8(a1 + 376, v2);
  }
  sub_1001B4FBC(a1 + 200);
  sub_10000AE14(a1 + 184);
  uint64_t v3 = *(void *)(a1 + 160);
  *(void *)(a1 + 16sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return sub_1002BCD40(a1);
}

uint64_t sub_1002BCE84(uint64_t a1)
{
  return sub_1002BCDB4(a1 - 112);
}

void sub_1002BCE8C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002BCDB4(a1);
  operator delete(v1);
}

void sub_1002BCEA0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002BCDB4(a1 - 112);
  operator delete(v1);
}

void *sub_1002BCEB8(void *result)
{
  uint64_t v1 = result;
  if (result[21])
  {
    uint64_t result = -[NSNotificationCenter removeObserver:]( +[NSNotificationCenter defaultCenter](&OBJC_CLASS___NSNotificationCenter, "defaultCenter"),  "removeObserver:",  result[21]);
    v1[21] = 0LL;
  }

  *((_BYTE *)v1 + 10std::iostream::~basic_iostream(v2, v3 + 8) = 1;
  return result;
}

uint64_t sub_1002BCEFC(uint64_t a1)
{
  return sub_1002BCF08(*(void *)(a1 + 32) + 200LL);
}

uint64_t sub_1002BCF08(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 40)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182F768);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v3 = sub_101171D38();
    int v4 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::string buf = 134218240;
    *(double *)__int16 v33 = v3;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Aggregating records start %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182F768);
    }
    uint64_t v16 = qword_101934A78;
    double v17 = sub_101171D38();
    int v18 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)double v30 = v17;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v18;
    int v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  2LL,  "Aggregating records start %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLSedentaryAlarmData>::aggregateRecords() [T = CLSedentaryAlarmData, DataProtectionPolic y = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v19);
  }

  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10182F768);
  }
  unint64_t v6 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v7 = sub_101171D38();
    int v8 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)std::string buf = 134218240;
    *(double *)__int16 v33 = v7;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Aggregating records stop %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182F768);
    }
    uint64_t v20 = qword_101934A78;
    double v21 = sub_101171D38();
    int v22 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v29 = 134218240;
    *(double *)double v30 = v21;
    *(_WORD *)&v30[8] = 1024;
    int v31 = v22;
    uint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  2LL,  "Aggregating records stop %f, count ~%d",  COERCE_DOUBLE(&v29),  18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLSedentaryAlarmData>::aggregateRecords() [T = CLSedentaryAlarmData, DataProtectionPolic y = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v23);
  }

  uint64_t v9 = *(void *)(a1 + 24);
  double v10 = (double)*(int *)(v9 + 132);
  if ((double)(int)sub_1002C0194(v9, (double **)a1) * 1.2 < v10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10182F768);
    }
    uint64_t v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 24);
      int v13 = *(_DWORD *)(v12 + 132);
      int v14 = sub_1002C0194(v12, (double **)a1);
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)__int16 v33 = v13;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10182F768);
      }
      uint64_t v24 = qword_101934A78;
      uint64_t v25 = *(void *)(a1 + 24);
      int v26 = *(_DWORD *)(v25 + 132);
      int v27 = sub_1002C0194(v25, (double **)a1);
      int v29 = 67109376;
      *(_DWORD *)double v30 = v26;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = v27;
      uint64_t v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v24,  0LL,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records es timated to be needed %d",  &v29,  14);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLSedentaryAlarmData>::aggregateRecords() [T = CLSedentaryAlarmData, DataProtectionPol icy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v28);
    }
  }

  return v5;
}

void sub_1002BD47C(uint64_t a1, double *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(void **)(v3 + 40);
  v8[1] = 3221225472LL;
  __int128 v5 = *((_OWORD *)a2 + 1);
  __int128 v9 = *(_OWORD *)a2;
  v8[0] = _NSConcreteStackBlock;
  void v8[2] = sub_1002BD5B0;
  void v8[3] = &unk_10182D1B8;
  _DWORD v8[4] = v3;
  __int128 v10 = v5;
  [v4 async:v8];
  unint64_t v6 = objc_autoreleasePoolPush();
  double v7 = objc_alloc_init(&OBJC_CLASS___ALActivityLog);
  -[ALActivityLog setTimestamp:](v7, "setTimestamp:", *a2);
  -[ALActivityLog setSedentaryAlarmData:]( v7,  "setSedentaryAlarmData:",  objc_alloc_init(&OBJC_CLASS___ALCLSedentaryAlarmData));
  -[ALCLSedentaryAlarmData setFiredTime:]( -[ALActivityLog sedentaryAlarmData](v7, "sedentaryAlarmData"),  "setFiredTime:",  a2[1]);
  -[ALCLSedentaryAlarmData setType:]( -[ALActivityLog sedentaryAlarmData](v7, "sedentaryAlarmData"),  "setType:",  *((unsigned int *)a2 + 4));
  -[ALCLSedentaryAlarmData setDidWake:]( -[ALActivityLog sedentaryAlarmData](v7, "sedentaryAlarmData"),  "setDidWake:",  *((unsigned __int8 *)a2 + 20));
  -[ALCLSedentaryAlarmData setRegularEntry:]( -[ALActivityLog sedentaryAlarmData](v7, "sedentaryAlarmData"),  "setRegularEntry:",  1LL);
  objc_msgSend( -[CLServiceVendor proxyForService:]( +[CLServiceVendor sharedInstance](CLServiceVendor, "sharedInstance"),  "proxyForService:",  @"CLActivityLogger"),  "logData:",  v7);
  objc_autoreleasePoolPop(v6);
}

void sub_1002BD5B0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  __int128 v2 = *(_OWORD *)(a1 + 56);
  v3[0] = *(_OWORD *)(a1 + 40);
  v3[1] = v2;
  sub_1002BD5E4(v1, (uint64_t)v3);
}

void sub_1002BD5E4(void *a1, uint64_t a2)
{
  LODWORD(__p) = 0;
  if (sub_100247620((uint64_t)a1, (int *)&__p, 1LL))
  {
    __int128 __p = 0LL;
    uint64_t v16 = 0LL;
    double v17 = 0LL;
    int v4 = sub_10000835C((uint64_t)&v17, 1uLL);
    __int128 v5 = (char *)__p;
    unint64_t v6 = v16;
    int v8 = &v4[2 * v7];
    __int128 v9 = *(_OWORD *)(a2 + 16);
    *int v4 = *(_OWORD *)a2;
    v4[1] = v9;
    __int128 v10 = (char *)(v4 + 2);
    if (v6 != v5)
    {
      uint64_t v11 = v4;
      do
      {
        __int128 v12 = *((_OWORD *)v6 - 1);
        int v4 = v11 - 2;
        *(v11 - 2) = *((_OWORD *)v6 - 2);
        *(v11 - 1) = v12;
        v6 -= 32;
        v11 -= 2;
      }

      while (v6 != v5);
    }

    __int128 __p = v4;
    uint64_t v16 = v10;
    double v17 = v8;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v16 = v10;
    int v14 = 0;
    (*(void (**)(void *, int *, void **, void, uint64_t, void))(*a1 + 152LL))( a1,  &v14,  &__p,  0LL,  0xFFFFFFFFLL,  0LL);
    a1[31] = *(void *)(a2 + 8);
    if (__p)
    {
      uint64_t v16 = (char *)__p;
      operator delete(__p);
    }
  }

  else if (*(_BYTE *)(a2 + 20))
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterPostNotification(DarwinNotifyCenter, @"com.apple.locationd.sedentarytimer", 0LL, 0LL, 0);
  }

void sub_1002BD700( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002BD720(uint64_t a1)
{
  uint64_t v7 = 0LL;
  int v8 = 0LL;
  uint64_t v9 = 0LL;
  if (sub_100F64A7C(*(void *)(a1 + 184), (void **)&v7, *(double *)(a1 + 248)) == 100)
  {
    __int128 v2 = v7;
    if (v7 == v8) {
      goto LABEL_6;
    }
    __int128 __p = 0LL;
    __int128 v5 = 0LL;
    uint64_t v6 = 0LL;
    sub_1002C0E60(&__p, v7, (uint64_t)v8, (v8 - v7) >> 5);
    int v3 = 0;
    (*(void (**)(uint64_t, int *, void **, void, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v3,  &__p,  0LL,  0xFFFFFFFFLL,  0LL);
    *(void *)(a1 + 24std::iostream::~basic_iostream(v2, v3 + 8) = *((void *)v8 - 3);
    if (__p)
    {
      __int128 v5 = __p;
      operator delete(__p);
    }
  }

  __int128 v2 = v7;
LABEL_6:
  if (v2)
  {
    int v8 = v2;
    operator delete(v2);
  }

void sub_1002BD7E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1002BD818@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

uint64_t sub_1002BD890(uint64_t a1, _DWORD *a2)
{
  if (*a2 == 1) {
    return 0LL;
  }
  if (!*a2) {
    sub_1002BD720(a1);
  }
  return 1LL;
}

uint64_t sub_1002BD8C0(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1002BD94C;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_1019940C8 != -1) {
    dispatch_once(&qword_1019940C8, block);
  }
  if (byte_1019940C0) {
    return 1LL;
  }
  sub_1004F2598();
  return sub_1001B9A1C();
}

id sub_1002BD94C(uint64_t a1)
{
  id result = objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "isServiceEnabled:",  @"CLSedentaryTimerNotifier");
  byte_1019940C0 = (char)result;
  return result;
}

void sub_1002BD978(uint64_t a1, uint64_t a2, _DWORD *a3, _BYTE *a4)
{
  if (*a3 != 4)
  {
    if (!*a3) {
      *(_BYTE *)(a1 + 12sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *a4 & a4[1];
    }
    return;
  }

  int v5 = *(_DWORD *)a4;
  if (*(_DWORD *)a4 == *(_DWORD *)(a1 + 372)) {
    return;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10182F5F0);
  }
  uint64_t v6 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(_DWORD *)(a1 + 372);
    *(_DWORD *)std::string buf = 67240448;
    int v24 = v7;
    __int16 v25 = 1026;
    int v26 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Activity mode from %{public}d to %{public}d",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182F5F0);
    }
    int v15 = *(_DWORD *)(a1 + 372);
    v20[0] = 67240448;
    v20[1] = v15;
    __int16 v21 = 1026;
    int v22 = v5;
    uint64_t v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "Activity mode from %{public}d to %{public}d",  v20,  14);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSedentaryTimerNotifier::onFitnessTrackingNotification(int, const CLFitnessTrackingNotifier_Type::Notificati on &, const CLFitnessTrackingNotifier_Type::NotificationData &)",  "%s\n",  v16);
  }

  *(_DWORD *)(a1 + 372) = v5;
  if (v5 == 1)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182F5F0);
    }
    int v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "StandPlus, running stand minute estimator",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182F5F0);
      }
      LOWORD(v20[0]) = 0;
      LODWORD(v19) = 2;
      double v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "StandPlus, running stand minute estimator",  v20,  v19);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSedentaryTimerNotifier::onFitnessTrackingNotification(int, const CLFitnessTrackingNotifier_Type::Notifica tion &, const CLFitnessTrackingNotifier_Type::NotificationData &)",  "%s\n",  v17);
    }

    [*(id *)(*(void *)(a1 + 160) + 16) register:*(void *)(*(void *)(a1 + 160) + 8) forNotification:5 registrationInfo:0];
    uint64_t v9 = (void **)(a1 + 376);
    __int128 v10 = *(void **)(a1 + 376);
    *(void *)(a1 + 376) = 0LL;
    if (v10) {
      sub_1002C0ED8(a1 + 376, v10);
    }
    uint64_t v11 = operator new(0x130uLL);
    sub_10025854C((uint64_t)v11, (__int128 *)(a1 + 312), a1 + 112);
    __int128 v12 = *v9;
    *uint64_t v9 = v11;
    if (v12)
    {
      uint64_t v13 = a1 + 376;
LABEL_27:
      sub_1002C0ED8(v13, v12);
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182F5F0);
    }
    int v14 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "StandPlus, stopping stand minute estimator",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182F5F0);
      }
      LOWORD(v20[0]) = 0;
      LODWORD(v19) = 2;
      int v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "StandPlus, stopping stand minute estimator",  v20,  v19);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSedentaryTimerNotifier::onFitnessTrackingNotification(int, const CLFitnessTrackingNotifier_Type::Notifica tion &, const CLFitnessTrackingNotifier_Type::NotificationData &)",  "%s\n",  v18);
    }

    [*(id *)(*(void *)(a1 + 160) + 16) unregister:*(void *)(*(void *)(a1 + 160) + 8) forNotification:5];
    __int128 v12 = *(void **)(a1 + 376);
    *(void *)(a1 + 376) = 0LL;
    if (v12)
    {
      uint64_t v13 = a1 + 376;
      goto LABEL_27;
    }
  }

void sub_1002BDE50(_Unwind_Exception *a1)
{
}

void sub_1002BDE6C(uint64_t a1, uint64_t a2, _DWORD *a3, __int128 *a4)
{
  if (*a3 == 5)
  {
    uint64_t v8 = *(void *)(a1 + 376);
    if (v8) {
      sub_10025868C(v8, a4);
    }
  }

  else if (*a3 == 2)
  {
    __int128 v4 = *a4;
    __int128 v5 = a4[1];
    __int128 v6 = a4[2];
    *(_OWORD *)(a1 + 356) = *(__int128 *)((char *)a4 + 44);
    *(_OWORD *)(a1 + 32std::iostream::~basic_iostream(v2, v3 + 8) = v5;
    *(_OWORD *)(a1 + 344) = v6;
    *(_OWORD *)(a1 + 312) = v4;
    uint64_t v7 = *(void *)(a1 + 376);
    if (v7) {
      sub_1002597DC(v7, (uint64_t)a4);
    }
  }

void sub_1002BDEC8(uint64_t a1, uint64_t a2)
{
  __int128 __p = 0LL;
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  sub_100F64A7C(*(void *)(a1 + 184), &__p, *(double *)a2);
  __int128 v4 = (double *)__p;
  if (__p == v23)
  {
    int v6 = 0;
    int v5 = 0;
  }

  else
  {
    int v5 = 0;
    int v6 = 0;
    do
    {
      int v7 = *((_DWORD *)v4 + 4);
      if (v7 == *(_DWORD *)(a2 + 16)) {
        ++v5;
      }
      if (v7 == 2) {
        ++v6;
      }
      v4 += 4;
    }

    while (v4 != v23);
  }

  if (v5 | v6)
  {
    double v8 = *(v23 - 3);
    if (v8 > *(double *)(a2 + 8))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182F5F0);
      }
      uint64_t v9 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = *(void *)(a2 + 8);
        *(_DWORD *)std::string buf = 134349312;
        double v36 = v8;
        __int16 v37 = 2050;
        uint64_t v38 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "StandPlus,warning,time went backward,alreadyLogged,%{public}f,new,%{public}f",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182F5F0);
        }
        uint64_t v19 = *(void *)(a2 + 8);
        int v25 = 134349312;
        double v26 = v8;
        __int16 v27 = 2050;
        uint64_t v28 = v19;
        uint64_t v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "StandPlus,warning,time went backward,alreadyLogged,%{public}f,new,%{public}f",  &v25,  22);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLSedentaryTimerNotifier::onStoreSedentaryAlarm(CLSedentaryAlarmData)",  "%s\n",  v20);
      }
    }

    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182F5F0);
    }
    uint64_t v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
    {
      double v12 = *(double *)a2;
      uint64_t v13 = *(void *)(a2 + 8);
      int v14 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)std::string buf = 134350080;
      double v36 = v12;
      __int16 v37 = 2050;
      uint64_t v38 = v13;
      __int16 v39 = 1026;
      int v40 = v14;
      __int16 v41 = 1026;
      int v42 = v5;
      __int16 v43 = 1026;
      int v44 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "StandPlus,warning,attempting to log bad alarm,startTime,%{public}f,firedTime,%{public}f,type,%{public}d,count,%{ public}d,countReset,%{public}d",  buf,  0x28u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182F5F0);
      }
      double v15 = *(double *)a2;
      uint64_t v16 = *(void *)(a2 + 8);
      int v17 = *(_DWORD *)(a2 + 16);
      int v25 = 134350080;
      double v26 = v15;
      __int16 v27 = 2050;
      uint64_t v28 = v16;
      __int16 v29 = 1026;
      int v30 = v17;
      __int16 v31 = 1026;
      int v32 = v5;
      __int16 v33 = 1026;
      int v34 = v6;
      LODWORD(v21) = 40;
      int v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "StandPlus,warning,attempting to log bad alarm,startTime,%{public}f,firedTime,%{public}f,type,%{pub lic}d,count,%{public}d,countReset,%{public}d",  &v25,  v21);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLSedentaryTimerNotifier::onStoreSedentaryAlarm(CLSedentaryAlarmData)",  "%s\n",  v18);
    }
  }

  else
  {
    sub_1002BE300(a1 + 200, (double *)a2);
  }

  if (__p)
  {
    uint64_t v23 = (double *)__p;
    operator delete(__p);
  }

void sub_1002BE2D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002BE300(uint64_t a1, double *a2)
{
  uint64_t result = sub_1002C0F28(*(void *)(a1 + 24), a2);
  if (!*(_BYTE *)(a1 + 41))
  {
    uint64_t result = sub_100D8A92C(*(void *)(a1 + 24) + 72LL);
    if ((_DWORD)result)
    {
      *(_BYTE *)(a1 + 41) = 1;
      return sub_1002BCF08(a1);
    }
  }

  return result;
}

void sub_1002BE354(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1002BE35C(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = &off_10182F828;
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + sub_10000AE14(v13 - 32) = a6;
  else {
    double v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

void sub_1002BE430(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  double v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLSedentaryTimerNotifier");
  sub_1002BE35C((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  void *v8 = &off_10182F528;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1002BE4CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

void sub_1002BE4F8(uint64_t a1, uint64_t a2)
{
  HIDWORD(v14) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)std::string buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v14 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182F5D0);
      }
      char v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v11 = (void *)(a1 + 8);
        *(_DWORD *)std::string buf = 136446466;
        uint64_t v20 = v11;
        __int16 v21 = 1026;
        int v22 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_10182F5D0);
        }
        double v12 = (void *)(a1 + 8);
        int v15 = 136446466;
        uint64_t v16 = v12;
        __int16 v17 = 1026;
        int v18 = a2;
        LODWORD(v14) = 18;
        id v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                        &v15,
                        v14);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::Notificati onData>::removeClient(int) [Notification_T = CLSedentaryTimerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
      }
    }
  }

uint64_t sub_1002BE76C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_101937100);
}

BOOL sub_1002BE780(uint64_t a1, int a2, int *a3, char *a4)
{
  int v40 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      uint64_t v39 = v10;
      int v16 = *a3;
      uint64_t v19 = *(void *)(v10 + 48);
      uint64_t v18 = v10 + 48;
      uint64_t v17 = v19;
      if (!v19) {
        goto LABEL_31;
      }
      uint64_t v20 = v18;
      do
      {
        int v21 = *(_DWORD *)(v17 + 28);
        BOOL v22 = v21 < v16;
        if (v21 >= v16) {
          uint64_t v23 = (uint64_t *)v17;
        }
        else {
          uint64_t v23 = (uint64_t *)(v17 + 8);
        }
        if (!v22) {
          uint64_t v20 = v17;
        }
        uint64_t v17 = *v23;
      }

      while (*v23);
      if (v20 == v18 || v16 < *(_DWORD *)(v20 + 28)) {
LABEL_31:
      }
        uint64_t v20 = v18;
      uint64_t v24 = *(void *)(a1 + 64);
      if (!v24) {
        goto LABEL_42;
      }
      uint64_t v25 = a1 + 64;
      do
      {
        int v26 = *(_DWORD *)(v24 + 32);
        BOOL v27 = v26 < v16;
        if (v26 >= v16) {
          uint64_t v28 = (uint64_t *)v24;
        }
        else {
          uint64_t v28 = (uint64_t *)(v24 + 8);
        }
        if (!v27) {
          uint64_t v25 = v24;
        }
        uint64_t v24 = *v28;
      }

      while (*v28);
      if (v25 != a1 + 64 && v16 >= *(_DWORD *)(v25 + 32))
      {
        *(void *)__int16 v41 = v25;
        uint64_t v33 = *(void *)(v25 + 56);
        char v34 = *a4;
        *(void *)std::string buf = &v40;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v25 + 40), &v40, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + sub_10000AE14(v13 - 32) = v34;
        memset(buf, 0, 24);
        if (v20 == v18)
        {
          if ((*(unsigned int (**)(uint64_t, int *, uint8_t *))(*(void *)a1 + 128LL))(a1, a3, buf))
          {
            double v35 = sub_1002C1878((uint64_t)buf);
            sub_1002C080C((_BYTE *)a1, (uint64_t)&v39, (uint64_t)v41, v35);
          }

          if (*(void *)buf)
          {
            *(void *)&uint8_t buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
        }

        if (v33) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        *(void *)__int16 v41 = a1 + 64;
        char v29 = byte_101937101;
        HIDWORD(v3std::iostream::~basic_iostream(v2, v3 + 8) = v16;
        *(void *)std::string buf = (char *)&v38 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v38 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 8sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v29;
        HIDWORD(v3std::iostream::~basic_iostream(v2, v3 + 8) = *a3;
        *(void *)std::string buf = (char *)&v38 + 4;
        int v30 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v38 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v30 + 8);
        char v31 = *a4;
        HIDWORD(v3std::iostream::~basic_iostream(v2, v3 + 8) = *a3;
        *(void *)std::string buf = (char *)&v38 + 4;
        int v32 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v38 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)std::string buf = &v40;
        *((_BYTE *)sub_1004EF3D4(v32 + 5, &v40, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + sub_10000AE14(v13 - 32) = v31;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v20 == v18)
      {
        *(_DWORD *)std::string buf = *a3;
        sub_10004A8FC((uint64_t **)(v39 + 40), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_10182F5D0);
  }
  uint64_t v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    int v15 = (void *)(a1 + 8);
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL result = sub_1002921D0(115, 0);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182F5D0);
    }
    double v36 = (void *)(a1 + 8);
    *(_DWORD *)__int16 v41 = 136446466;
    *(void *)&v41[4] = v36;
    __int16 v42 = 1026;
    int v43 = a2;
    LODWORD(v3std::iostream::~basic_iostream(v2, v3 + 8) = 18;
    __int16 v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                    v41,
                    v38);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::NotificationDa ta>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLSedentar yTimerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData, Notificat ionInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v37);
    return 0LL;
  }

  return result;
}

void sub_1002BEBF8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1002BEC20(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        int v21 = (uint64_t *)v15;
      }
      else {
        int v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182F5D0);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)std::string buf = 136446466;
      char v29 = v11;
      __int16 v30 = 1026;
      int v31 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182F5D0);
      }
      BOOL v22 = (void *)(a1 + 8);
      int v24 = 136446466;
      uint64_t v25 = v22;
      __int16 v26 = 1026;
      int v27 = a2;
      uint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
                      &v24,
                      18);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::Notification Data>::clientRegistered(int, const Notification_T &) [Notification_T = CLSedentaryTimerNotifier_Type::Notificati on, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      return 0LL;
    }
  }

  return result;
}

BOOL sub_1002BEEA0(char *a1, int a2, int *a3)
{
  HIDWORD(v33) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        id v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            id v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            BOOL v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                uint64_t v25 = (uint64_t *)v20;
              }
              else {
                uint64_t v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                BOOL v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v33 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10182F5D0);
              }
              __int16 v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v27 = a1 + 8;
                if (a1[31] < 0) {
                  int v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v43 >= 0) {
                  uint64_t v28 = __p;
                }
                else {
                  uint64_t v28 = (void **)__p[0];
                }
                *(_DWORD *)std::string buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v35 = 2082;
                double v36 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v43 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_10182F5D0);
                }
                char v29 = a1 + 8;
                if (a1[31] < 0) {
                  char v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v37 >= 0) {
                  int v31 = buf;
                }
                else {
                  int v31 = *(_BYTE **)buf;
                }
                int v38 = 136446466;
                uint64_t v39 = v29;
                __int16 v40 = 2082;
                __int16 v41 = v31;
                LODWORD(v33) = 22;
                int v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                                &v38,
                                v33);
                if (v37 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::No tificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLSedentaryT imerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v32);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_1002BF228(uint64_t a1, int *a2, char *a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }

  while (*v10);
  if (v7 == v3) {
    return 0LL;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0LL;
  }
  uint64_t v11 = *(void *)(v7 + 64);
  if (!v11) {
    return 0LL;
  }
  return 1LL;
}

uint64_t sub_1002BF2AC(uint64_t a1, int *a2, uint64_t a3)
{
  int v10 = *a2;
  BOOL v12 = &v10;
  uint64_t v5 = sub_10023347C((uint64_t **)(a1 + 56), &v10, (uint64_t)&unk_1012CF090, &v12);
  sub_10005F550((uint64_t)(v5 + 8), &v11);
  int v6 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1))
  {
    uint64_t v7 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return 1LL;
}

void sub_1002BF358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1002BF36C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int128 __p = 0LL;
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  (*(void (**)(uint64_t, uint64_t, void **, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  &__p,  a3,  a4,  0LL);
  if (__p)
  {
    uint64_t v5 = __p;
    operator delete(__p);
  }

void sub_1002BF3C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1002BF3DC(uint64_t a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    int v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182F5D0);
    }
    __int128 v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      BOOL v12 = (void *)(a1 + 8);
      id v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)std::string buf = 68289794;
      *(_DWORD *)__int16 v65 = 0;
      *(_WORD *)&v65[4] = 2082;
      *(void *)&_BYTE v65[6] = "";
      *(_WORD *)&v65[14] = 2082;
      *(void *)&v65[16] = "activity";
      __int16 v66 = 2082;
      __int16 v67 = v12;
      __int16 v68 = 2050;
      __int16 v69 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    uint64_t v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      uint64_t v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)int v70 = &v70[8];
      memset(&v70[8], 0, 24);
      __int16 v71 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v70);
      int v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v69;
      if (v69)
      {
        p_shared_owners = (unint64_t *)&v69->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&v65[4], *(void **)&v65[12]);
      BOOL v24 = v71;
      if (v71)
      {
        uint64_t v25 = (unint64_t *)&v71->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v70, *(void **)&v70[8]);
    }

    if (a4)
    {
      sub_1002C08E8(a3, buf);
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      int v27 = *(std::__shared_weak_count **)&v65[4];
      if (*(void *)&v65[4])
      {
        uint64_t v28 = (unint64_t *)(*(void *)&v65[4] + 8LL);
        do
          unint64_t v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    uint64_t v30 = sub_1002C0390(a3);
    if (a5 == -1)
    {
      sub_1002C0438((void *)a1, (int *)a2, v30);
    }

    else
    {
      uint64_t v31 = a1 + 88;
      uint64_t v32 = *(void *)(a1 + 88);
      if (!v32) {
        goto LABEL_48;
      }
      uint64_t v33 = a1 + 88;
      do
      {
        int v34 = *(_DWORD *)(v32 + 32);
        BOOL v35 = v34 < a5;
        if (v34 >= a5) {
          double v36 = (uint64_t *)v32;
        }
        else {
          double v36 = (uint64_t *)(v32 + 8);
        }
        if (!v35) {
          uint64_t v33 = v32;
        }
        uint64_t v32 = *v36;
      }

      while (*v36);
      if (v33 == v31 || *(_DWORD *)(v33 + 32) > a5) {
LABEL_48:
      }
        uint64_t v33 = a1 + 88;
      uint64_t v62 = v33;
      unint64_t v37 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v38 = *a2;
      uint64_t v39 = (__n128 *)(a1 + 64);
      do
      {
        int v40 = *(_DWORD *)(v37 + 32);
        BOOL v41 = v40 < v38;
        if (v40 >= v38) {
          __int16 v42 = (unint64_t *)v37;
        }
        else {
          __int16 v42 = (unint64_t *)(v37 + 8);
        }
        if (!v41) {
          uint64_t v39 = (__n128 *)v37;
        }
        unint64_t v37 = *v42;
      }

      while (*v42);
      if (v39 == v15 || v38 < (signed __int32)v39[2].n128_u32[0])
      {
LABEL_59:
        double v61 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_10182F5D0);
        }
        char v43 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          int v44 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v70, a1, a2);
          if (v70[23] >= 0) {
            char v45 = v70;
          }
          else {
            char v45 = *(_BYTE **)v70;
          }
          *(_DWORD *)std::string buf = 136315650;
          *(void *)__int16 v65 = v44;
          *(_WORD *)&v65[8] = 1024;
          *(_DWORD *)&v65[10] = a5;
          *(_WORD *)&v65[14] = 2080;
          *(void *)&v65[16] = v45;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v70[23] & 0x80000000) != 0) {
            operator delete(*(void **)v70);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_10182F5D0);
          }
          int v46 = (void *)(a1 + 8);
          uint64_t v47 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v60 >= 0) {
            __int16 v48 = __p;
          }
          else {
            __int16 v48 = (void **)__p[0];
          }
          *(_DWORD *)int v70 = 136315650;
          *(void *)&v70[4] = v46;
          *(_WORD *)&v70[12] = 1024;
          *(_DWORD *)&v70[14] = a5;
          *(_WORD *)&v70[18] = 2080;
          *(void *)&v70[20] = v48;
          int v49 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v47,  2LL,  "%s; client %d has deregistered, not notifying %s",
                          v70,
                          28,
                          v58);
          if (v60 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::Notifica tionData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Notif ication_T = CLSedentaryTimerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type: :NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v49);
        }

        goto LABEL_83;
      }

      double v61 = v39;
      if (v33 == v31) {
        goto LABEL_60;
      }
      uint64_t v52 = v39[3].n128_i64[0];
      NSInteger v50 = v39 + 3;
      unsigned int v51 = (__n128 *)v52;
      if (!v52) {
        goto LABEL_60;
      }
      int v53 = *(_DWORD *)(v33 + 32);
      int v54 = v50;
      do
      {
        int v55 = v51[1].n128_i32[3];
        BOOL v56 = v55 < v53;
        if (v55 >= v53) {
          __int16 v57 = v51;
        }
        else {
          __int16 v57 = (__n128 *)&v51->n128_i8[8];
        }
        if (!v56) {
          int v54 = v51;
        }
        unsigned int v51 = (__n128 *)v57->n128_u64[0];
      }

      while (v57->n128_u64[0]);
      sub_1002C080C((_BYTE *)a1, (uint64_t)&v62, (uint64_t)&v61, v30);
    }

void sub_1002BF9F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_1002BFA44(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182F5D0);
    }
    __int128 v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)std::string buf = 136315138;
      int v34 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182F5D0);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v29 = 136315138;
      uint64_t v30 = v4;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
                     (const char *)&v29);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::Notification Data>::listClients() [Notification_T = CLSedentaryTimerNotifier_Type::Notification, NotificationData_T = CLSeden taryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_10182F5D0);
    }
    uint64_t v6 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = (void *)(a1 + 8);
      uint64_t v8 = *(void *)(a1 + 96);
      *(_DWORD *)std::string buf = 136315394;
      int v34 = v7;
      __int16 v35 = 2048;
      v36[0] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_10182F5D0);
      }
      uint64_t v25 = (void *)(a1 + 8);
      uint64_t v26 = *(void *)(a1 + 96);
      int v29 = 136315394;
      uint64_t v30 = v25;
      __int16 v31 = 2048;
      v32[0] = v26;
      int v27 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
                      (const char *)&v29,
                      22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::Notification Data>::listClients() [Notification_T = CLSedentaryTimerNotifier_Type::Notification, NotificationData_T = CLSeden taryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v27);
    }

    BOOL v9 = *(void **)(a1 + 80);
    if (v9 != (void *)(a1 + 88))
    {
      int v10 = (void *)(a1 + 8);
      do
      {
        __int128 v11 = (void *)v9[5];
        if (v11 != v9 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_10182F5D0);
            }
            BOOL v12 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              id v13 = (void *)(a1 + 8);
              int v14 = *((_DWORD *)v9 + 8);
              int v15 = *((_DWORD *)v11 + 7);
              *(_DWORD *)std::string buf = 136315650;
              int v34 = v13;
              __int16 v35 = 1024;
              LODWORD(v36[0]) = v14;
              WORD2(v36[0]) = 1024;
              *(_DWORD *)((char *)v36 + 6) = v15;
              _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10182F5D0);
              }
              BOOL v19 = (void *)(a1 + 8);
              int v20 = *((_DWORD *)v9 + 8);
              int v21 = *((_DWORD *)v11 + 7);
              int v29 = 136315650;
              uint64_t v30 = v19;
              __int16 v31 = 1024;
              LODWORD(v32[0]) = v20;
              WORD2(v32[0]) = 1024;
              *(_DWORD *)((char *)v32 + 6) = v21;
              BOOL v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                              (const char *)&v29,
                              24,
                              v28);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::Noti ficationData>::listClients() [Notification_T = CLSedentaryTimerNotifier_Type::Notification, Notification Data_T = CLSedentaryTimerNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v22);
            }

            signed __int32 v16 = (void *)v11[1];
            if (v16)
            {
              do
              {
                int v17 = v16;
                signed __int32 v16 = (void *)*v16;
              }

              while (v16);
            }

            else
            {
              do
              {
                int v17 = (void *)v11[2];
                BOOL v18 = *v17 == (void)v11;
                __int128 v11 = v17;
              }

              while (!v18);
            }

            __int128 v11 = v17;
          }

          while (v17 != v9 + 6);
        }

        unint64_t v23 = (void *)v9[1];
        if (v23)
        {
          do
          {
            BOOL v24 = v23;
            unint64_t v23 = (void *)*v23;
          }

          while (v23);
        }

        else
        {
          do
          {
            BOOL v24 = (void *)v9[2];
            BOOL v18 = *v24 == (void)v9;
            BOOL v9 = v24;
          }

          while (!v18);
        }

        BOOL v9 = v24;
      }

      while (v24 != (void *)(a1 + 88));
    }
  }

void sub_1002BFFF0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1002C1818(a1);
  operator delete(v1);
}

id sub_1002C0004(uint64_t a1, int a2, void *a3)
{
  id result = sub_1002C0A3C(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_1002C0050(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_1002C007C(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void *sub_1002C00A8(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &off_10182F700;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  void v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1002C00F0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C0110(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

uint64_t sub_1002C0128(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void sub_1002C0168(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_1002C0194(uint64_t a1, double **a2)
{
  uint64_t v3 = *a2;
  __int128 v2 = a2[1];
  double v4 = (*a2)[1];
  double v5 = *(float *)(a1 + 136);
  if (v4 <= v5) {
    double v4 = *(float *)(a1 + 136);
  }
  int v6 = v3 + 3;
  if (v3 + 3 == v2)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    LODWORD(v7) = 0;
    double v8 = *v3;
    do
    {
      double v9 = *v6;
      double v10 = v6[1];
      v6 += 3;
      uint64_t v7 = (v7 + (int)((v9 - v8) / v4));
      if (v10 <= v5) {
        double v4 = *(float *)(a1 + 136);
      }
      else {
        double v4 = v10;
      }
      double v8 = v9;
    }

    while (v6 != v2);
  }

  if (v4 != 1.79769313e308)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182F5F0);
    }
    __int128 v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning No expiration rule was added so the number of records will be unbounded.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182F5F0);
      }
      v14[0] = 0;
      id v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning No expiration rule was added so the number of records will be unbounded.",  v14,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLActivityRecorderDb<CLSedentaryAlarmData>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLSedenta ryAlarmData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v13);
    }
  }

  return v7;
}

CLCppContainer *sub_1002C0390(uint64_t a1)
{
  __int128 v2 = operator new(0x18uLL);
  v2[1] = 0LL;
  _DWORD v2[2] = 0LL;
  *__int128 v2 = 0LL;
  sub_1002C0E60(v2, *(const void **)a1, *(void *)(a1 + 8), (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_1002C09FC;
  void v4[3] = &unk_10181D3D0;
  void v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  0LL,  24LL);
}

void sub_1002C0424(_Unwind_Exception *a1)
{
}

void sub_1002C0438(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    double v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      double v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          BOOL v12 = (uint64_t *)v4;
        }
        else {
          BOOL v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          double v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        NSInteger v50 = v9;
        id v13 = sub_1002C0A3C(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        int v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          int v15 = a1 + 11;
          signed __int32 v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            BOOL v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                BOOL v22 = (uint64_t *)v17;
              }
              else {
                BOOL v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                BOOL v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              int v49 = v19;
              sub_1002C080C(a1, (uint64_t)&v49, (uint64_t)&v50, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              int v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  uint64_t v32 = (uint64_t *)v27;
                }
                else {
                  uint64_t v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  int v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              NSInteger v50 = v29;
              uint64_t v34 = v29[6];
              int v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                __int16 v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    uint64_t v39 = (uint64_t *)v36;
                  }
                  else {
                    uint64_t v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    __int16 v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      __int16 v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      __int16 v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      int v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  char v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      int v14 = v43;
                      char v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      int v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      __int16 v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              int v49 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_10182F5D0);
              }
              BOOL v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                uint64_t v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)std::string buf = 136446466;
                BOOL v56 = v25;
                __int16 v57 = 1026;
                int v58 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_10182F5D0);
                }
                char v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v51 = 136446466;
                uint64_t v52 = v45;
                __int16 v53 = 1026;
                int v54 = v46;
                LODWORD(v4std::iostream::~basic_iostream(v2, v3 + 8) = 18;
                uint64_t v47 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                                &v51,
                                v48);
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLSedentaryTimerNotifier_Type::Notification, CLSedentaryTimerNotifier_Type::Notificati onData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLSedentary TimerNotifier_Type::Notification, NotificationData_T = CLSedentaryTimerNotifier_Type::NotificationData , NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
              }
            }
          }

          while (v14 != v50 + 6);
        }
      }
    }
  }

_BYTE *sub_1002C080C(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    uint64_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_1002C0A3C(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40LL);
    int v14 = (int *)(*(void *)a2 + 32LL);
    BOOL v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    uint64_t result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

uint64_t sub_1002C08E8@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x30uLL);
  uint64_t result = sub_1002C0940((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_1002C092C(_Unwind_Exception *a1)
{
}

uint64_t sub_1002C0940(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0u;
  *(void *)a1 = off_10182F798;
  *(_OWORD *)(a1 + sub_10000AE14(v13 - 32) = 0u;
  *(void *)(a1 + 24) = 0LL;
  sub_1002C0E60( (void *)(a1 + 24),  *(const void **)a2,  *(void *)(a2 + 8),  (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 5);
  return a1;
}

void sub_1002C0994(_Unwind_Exception *a1)
{
}

void sub_1002C09A8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10182F798;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1002C09BC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10182F798;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_1002C09E0(uint64_t a1)
{
  __int128 v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + sub_10000AE14(v13 - 32) = v2;
    operator delete(v2);
  }

void sub_1002C09FC(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 32);
  if (v1)
  {
    __int128 v2 = *v1;
    if (*v1)
    {
      v1[1] = v2;
      operator delete(v2);
    }

    operator delete(v1);
  }

id sub_1002C0A3C(void *a1)
{
  uint64_t v2 = objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_1002C0A88(a1);
  }
  else {
    return 0LL;
  }
}

id sub_1002C0A88(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182F7D8);
    }
    uint64_t v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012E524CLL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182F7D8);
    }
    LODWORD(vstd::iostream::~basic_iostream(v2, v3 + 8) = 134218498;
    HIDWORD(vstd::iostream::~basic_iostream(v2, v3 + 8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182F7D8);
    }
    int v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001012E524CLL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10182F7D8);
    }
    LODWORD(vstd::iostream::~basic_iostream(v2, v3 + 8) = 134218498;
    HIDWORD(vstd::iostream::~basic_iostream(v2, v3 + 8) = (_DWORD)v2;
    uint64_t v4 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly becaus e the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  uint64_t v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLSedentaryTimerNotifier_Type::NotificationData, Callback = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:228:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

void sub_1002C0E34(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

void *sub_1002C0E60(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    uint64_t result = sub_10004B974(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1002C0EBC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::iostream::~basic_iostream(v2, v3 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1002C0ED8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100210A00(a2 + 26);
    sub_1001B9D48(a2 + 20);
    sub_100231C10(a2 + 14);
    uint64_t v3 = (void *)a2[1];
    if (v3)
    {
      a2[2] = v3;
      operator delete(v3);
    }

    operator delete(a2);
  }

uint64_t sub_1002C0F28(uint64_t a1, double *a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  *(void *)&v21[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v22 = 256;
  v21[0] = *a2;
  if (sub_100D8AB44(v6, v21))
  {
    if (sub_100D8A92C(v6))
    {
      (*(void (**)(uint64_t, double *, void))(*(void *)a1 + 80LL))(a1, a2, 0LL);
    }

    else if (!*(_BYTE *)(a1 + 128))
    {
      uint64_t v12 = (void *)(a1 + 176);
      unint64_t v13 = *(void *)(a1 + 216);
      if (v13 > *(int *)(a1 + 256))
      {
        ++*(void *)(a1 + 208);
        *(void *)(a1 + 216) = v13 - 1;
        sub_1000ECDBC(a1 + 176, 1);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10182F5F0);
        }
        unint64_t v14 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "Maximum number of entries exceeded, throwing out oldest entry.",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10182F5F0);
          }
          v20[0] = 0;
          int v18 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Maximum number of entries exceeded, throwing out oldest entry.",  v20,  2);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityRecorderDb<CLSedentaryAlarmData>::addSuspectRecord(const T &) [T = CLSedentaryAlarmData, Data ProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v18);
        }
      }

      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10182F7F8);
      }
      int v15 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Buffer was added to since db was inaccesible.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10182F7F8);
        }
        v20[0] = 0;
        LODWORD(v19) = 2;
        uint64_t v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Buffer was added to since db was inaccesible.",  v20,  v19);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityRecorderDb<CLSedentaryAlarmData>::addSuspectRecord(const T &) [T = CLSedentaryAlarmData, DataPr otectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v17);
      }

      __n128 v7 = sub_1002C144C(v12, (uint64_t)a2);
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182F5F0);
    }
    size_t v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
    {
      id v9 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289538;
      int v24 = 0;
      __int16 v25 = 2082;
      int v26 = "";
      __int16 v27 = 1026;
      int v28 = (int)v21[0];
      __int16 v29 = 2082;
      int v30 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CL database error, record contains invalid time, invalid time:%{public}d, name: %{public, location:escape_only}s}",  buf,  0x22u);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182F5F0);
      }
    }

    id v10 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      __int16 v11 = (void *)(a1 + 88);
      *(_DWORD *)std::string buf = 68289538;
      int v24 = 0;
      __int16 v25 = 2082;
      int v26 = "";
      __int16 v27 = 1026;
      int v28 = (int)v21[0];
      __int16 v29 = 2082;
      int v30 = v11;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CL database error, record contains invalid time",  "{msg%{public}.0s:CL database error, record contains invalid time, invalid time:%{public}d, name: %{public, location:escape_only}s}",  buf,  0x22u);
    }
  }

  return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v5 + 24LL))(v5, v7);
}

void sub_1002C1420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

__n128 sub_1002C144C(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1002C1504(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  size_t v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v7 & 0x7F));
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  _OWORD *v8 = *(_OWORD *)a2;
  v8[1] = v10;
  ++a1[5];
  return result;
}

void sub_1002C14D8(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

void sub_1002C1504(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    size_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    id v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)size_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      BOOL v38 = (uint64_t *)a1[1];
      size_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        size_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        BOOL v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)BOOL v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1002C17CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002C1818(uint64_t a1)
{
  *(void *)a1 = &off_10182F828;
  unint64_t v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *unint64_t v2 = 0LL;
  *(void *)(a1 + 16) = 0LL;
  return a1;
}

CLCppContainer *sub_1002C1878(uint64_t a1)
{
  unint64_t v2 = operator new(0x18uLL);
  v2[1] = 0LL;
  _DWORD v2[2] = 0LL;
  *unint64_t v2 = 0LL;
  sub_1002C0E60(v2, *(const void **)a1, *(void *)(a1 + 8), (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 5);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  _DWORD v4[2] = sub_1002C1920;
  void v4[3] = &unk_10181D3D0;
  void v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  0LL,  24LL);
}

void sub_1002C190C(_Unwind_Exception *a1)
{
}

void sub_1002C1920(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 32);
  if (v1)
  {
    unint64_t v2 = *v1;
    if (*v1)
    {
      v1[1] = v2;
      operator delete(v2);
    }

    operator delete(v1);
  }

char *sub_1002C1960(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  id v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 5)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      void *v7 = 0LL;
      v7[1] = 0LL;
      _DWORD v7[2] = 0LL;
    }

    if (a4 >> 59) {
      sub_100007008();
    }
    uint64_t v10 = v8 >> 4;
    if (v8 >> 4 <= a4) {
      uint64_t v10 = a4;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = sub_10004B974(v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    id v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  uint64_t v12 = (void **)(result + 8);
  BOOL v14 = (_BYTE *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 5;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[32 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    id v9 = (char *)*v12;
  }

  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v18, v19, v17);
  }

uint64_t sub_1002C1A68()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_101994080, (void *)&_mh_execute_header);
}

void sub_1002C2E90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_1002C2EAC(const char *a1, float *a2)
{
  int v4 = sub_1002A81F8(v11, a1, a2);
  int v5 = v4;
  uint64_t v6 = *(std::__shared_weak_count **)v12;
  if (!*(void *)v12) {
    goto LABEL_5;
  }
  unint64_t v7 = (unint64_t *)(*(void *)v12 + 8LL);
  do
    unint64_t v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (!v5) {
      return;
    }
  }

  else
  {
LABEL_5:
    if (!v4) {
      return;
    }
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10182F840);
  }
  id v9 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_INFO))
  {
    int v10 = (int)*a2;
    uint64_t v11 = 68289538LL;
    *(_WORD *)uint64_t v12 = 2082;
    *(void *)&id v12[2] = "";
    __int16 v13 = 2082;
    BOOL v14 = a1;
    __int16 v15 = 1026;
    int v16 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Overriding behavior feature, key:%{public, location:escape_only}s, value:%{public}d}",  (uint8_t *)&v11,  0x22u);
  }

void sub_1002C3010( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1002C302C(const char *a1, int *a2)
{
  int v4 = sub_1002A7CB0(v11, a1, a2);
  int v5 = v4;
  uint64_t v6 = *(std::__shared_weak_count **)v12;
  if (!*(void *)v12) {
    goto LABEL_5;
  }
  unint64_t v7 = (unint64_t *)(*(void *)v12 + 8LL);
  do
    unint64_t v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (!v5) {
      return;
    }
  }

  else
  {
LABEL_5:
    if (!v4) {
      return;
    }
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10182F840);
  }
  id v9 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_INFO))
  {
    int v10 = *a2;
    uint64_t v11 = 68289538LL;
    *(_WORD *)uint64_t v12 = 2082;
    *(void *)&id v12[2] = "";
    __int16 v13 = 2082;
    BOOL v14 = a1;
    __int16 v15 = 1026;
    int v16 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Overriding behavior feature, key:%{public, location:escape_only}s, value:%{public}d}",  (uint8_t *)&v11,  0x22u);
  }

void sub_1002C318C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1002C31A8(const char *a1, uint64_t *a2)
{
  int v4 = sub_1002A7F54(v11, a1, a2);
  int v5 = v4;
  uint64_t v6 = *(std::__shared_weak_count **)v12;
  if (!*(void *)v12) {
    goto LABEL_5;
  }
  unint64_t v7 = (unint64_t *)(*(void *)v12 + 8LL);
  do
    unint64_t v8 = __ldaxr(v7);
  while (__stlxr(v8 - 1, v7));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (!v5) {
      return;
    }
  }

  else
  {
LABEL_5:
    if (!v4) {
      return;
    }
  }

  if (qword_1019345D0 != -1) {
    dispatch_once(&qword_1019345D0, &stru_10182F840);
  }
  id v9 = (os_log_s *)qword_1019345D8;
  if (os_log_type_enabled((os_log_t)qword_1019345D8, OS_LOG_TYPE_INFO))
  {
    uint64_t v10 = *a2;
    uint64_t v11 = 68289538LL;
    *(_WORD *)uint64_t v12 = 2082;
    *(void *)&id v12[2] = "";
    __int16 v13 = 2082;
    BOOL v14 = a1;
    __int16 v15 = 1026;
    int v16 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Overriding behavior feature, key:%{public, location:escape_only}s, value:%{public}d}",  (uint8_t *)&v11,  0x22u);
  }

void sub_1002C3308( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

__n128 sub_1002C3734(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + sub_10000AE14(v13 - 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v2;
  *(_OWORD *)(a1 + 52) = *(_OWORD *)(a2 + 52);
  __n128 result = *(__n128 *)(a2 + 68);
  *(__n128 *)(a1 + 6std::iostream::~basic_iostream(v2, v3 + 8) = result;
  *(_DWORD *)(a1 + 84) = *(_DWORD *)(a2 + 84);
  *(_WORD *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *(_WORD *)(a2 + 88);
  *(_BYTE *)(a1 + 9sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(_BYTE *)(a2 + 90);
  return result;
}

void sub_1002C37A8(id a1)
{
  qword_1019345D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Fall");
}

double sub_1002C37D4(uint64_t a1)
{
  *(_OWORD *)a1 = xmmword_1012E52C0;
  *(_OWORD *)(a1 + 16) = xmmword_1012E52E0;
  *(void *)(a1 + sub_10000AE14(v13 - 32) = 0x4100000041A00000LL;
  *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0xA00000018LL;
  *(_OWORD *)(a1 + 4std::iostream::~basic_iostream(v2, v3 + 8) = xmmword_1012E52F0;
  *(_DWORD *)(a1 + 64) = 1110704128;
  *(void *)&double result = 0x200000008LL;
  *(_OWORD *)(a1 + 6std::iostream::~basic_iostream(v2, v3 + 8) = xmmword_1012E5300;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 87) = 0;
  return result;
}

unint64_t sub_1002C3828(_WORD *a1, float a2)
{
  BOOL v3 = 0LL;
  uint64_t v4 = 0LL;
  __int128 __p = 0LL;
  BOOL v44 = 0LL;
  uint64_t v45 = 0LL;
  LOWORD(a2) = a1[2];
  *(float *)&unsigned int v5 = (float)LODWORD(a2);
  float v6 = *(float *)&v5 * 0.0039062;
  LOWORD(v5) = a1[3];
  *(float *)&unsigned int v7 = (float)v5;
  float v8 = *(float *)&v7 * 0.0039062;
  LOWORD(v7) = a1[1];
  float v9 = (float)v7 * 0.0039062;
  do
  {
    int v10 = (unsigned __int16)a1[v4 + 10];
    float v11 = 60.0;
    if (v10 != 0x8000 && v6 <= 60.0)
    {
      float v11 = (float)(__int16)v10 * 0.015625;
      float v13 = v11 + (float)(v9 * 1000.0);
      if (v3 >= v45)
      {
        BOOL v14 = (float *)__p;
        uint64_t v15 = ((char *)v3 - (_BYTE *)__p) >> 3;
        unint64_t v16 = v15 + 1;
        uint64_t v17 = (char *)v45 - (_BYTE *)__p;
        else {
          unint64_t v18 = v16;
        }
        if (v18)
        {
          uint64_t v19 = (char *)sub_1000071BC((uint64_t)&v45, v18);
          BOOL v14 = (float *)__p;
          BOOL v3 = v44;
        }

        else
        {
          uint64_t v19 = 0LL;
        }

        int64_t v20 = (float *)&v19[8 * v15];
        *int64_t v20 = v6;
        v20[1] = v13;
        uint64_t v21 = v20;
        if (v3 != v14)
        {
          do
          {
            uint64_t v22 = *((void *)v3 - 1);
            v3 -= 2;
            *((void *)v21 - 1) = v22;
            v21 -= 2;
          }

          while (v3 != v14);
          BOOL v14 = (float *)__p;
        }

        BOOL v3 = v20 + 2;
        __int128 __p = v21;
        BOOL v44 = v20 + 2;
        uint64_t v45 = (float *)&v19[8 * v18];
        if (v14) {
          operator delete(v14);
        }
      }

      else
      {
        *BOOL v3 = v6;
        v3[1] = v13;
        v3 += 2;
      }

      BOOL v44 = v3;
    }

    ++v4;
    float v6 = v8 + v6;
  }

  while (v4 != 100);
  uint64_t v23 = (float *)__p;
  if (__p == v3)
  {
    float v38 = 0.0;
    if (!v3) {
      return ((unint64_t)LODWORD(v38) << 32) | 0xE;
    }
    goto LABEL_56;
  }

  uint64_t v40 = 0LL;
  BOOL v41 = 0LL;
  uint64_t v42 = 0LL;
  if (__p == v3 - 2)
  {
    float v38 = 0.0;
    goto LABEL_55;
  }

  uint64_t v24 = 0LL;
  do
  {
    unint64_t v25 = v23;
    v23 += 2;
    uint64_t v26 = v44;
    if (v23 != v44)
    {
      __int16 v27 = v24;
      uint64_t v28 = v23;
      do
      {
        float v11 = v28[1] - v25[1];
        float v29 = v11 / (float)(*v28 - *v25);
        if (v27 >= v42)
        {
          __int128 v30 = v40;
          uint64_t v31 = v27 - v40;
          unint64_t v32 = v31 + 1;
          uint64_t v33 = (char *)v42 - (char *)v40;
          else {
            unint64_t v34 = v32;
          }
          if (v34)
          {
            __int16 v35 = (char *)sub_10000956C((uint64_t)&v42, v34);
            __int128 v30 = v40;
            __int16 v27 = v41;
          }

          else
          {
            __int16 v35 = 0LL;
          }

          uint64_t v36 = (float *)&v35[4 * v31];
          *uint64_t v36 = v29;
          uint64_t v24 = v36 + 1;
          while (v27 != v30)
          {
            float v37 = *--v27;
            float v11 = v37;
            *--uint64_t v36 = v37;
          }

          uint64_t v40 = v36;
          uint64_t v42 = (float *)&v35[4 * v34];
          if (v30) {
            operator delete(v30);
          }
        }

        else
        {
          *__int16 v27 = v29;
          uint64_t v24 = v27 + 1;
        }

        BOOL v41 = v24;
        v28 += 2;
        __int16 v27 = v24;
      }

      while (v28 != v26);
    }
  }

  while (v23 != v3 - 2);
  if (v40 == v24)
  {
    float v38 = 0.0;
    if (!v24) {
      goto LABEL_55;
    }
    goto LABEL_54;
  }

  float v38 = sub_1002C3BB8(v40, v24, v11);
  uint64_t v24 = v40;
  if (v40) {
LABEL_54:
  }
    operator delete(v24);
LABEL_55:
  BOOL v3 = (float *)__p;
  if (__p)
  {
LABEL_56:
    BOOL v44 = v3;
    operator delete(v3);
  }

  return ((unint64_t)LODWORD(v38) << 32) | 0xE;
}

void sub_1002C3B78( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

float sub_1002C3BB8(float *a1, float *a2, float a3)
{
  uint64_t v3 = (char *)a2 - (char *)a1;
  uint64_t v4 = a1;
  unint64_t v5 = (unint64_t)(v3 >> 2) >> 1;
  float v6 = &a1[v5];
  if (v6 != a2) {
    sub_1002C3C90(a1, &a1[v5], a2, a3);
  }
  if (((v3 >> 2) & 0x8000000000000001LL) == 1) {
    return *v6;
  }
  if ((unint64_t)v3 >= 8 && v5 != 1)
  {
    float v8 = v4 + 1;
    float v9 = *v4;
    uint64_t v10 = 4 * v5 - 4;
    float v11 = v4 + 1;
    do
    {
      float v12 = *v11++;
      float v13 = v12;
      if (v9 < v12)
      {
        float v9 = v13;
        uint64_t v4 = v8;
      }

      float v8 = v11;
      v10 -= 4LL;
    }

    while (v10);
  }

  return *v4 + (float)((float)(*v6 - *v4) * 0.5);
}

float sub_1002C3C90(float *a1, float *a2, float *a3, float result)
{
  if (a3 != a2)
  {
    uint64_t v4 = a3;
    do
    {
      unint64_t v7 = v4 - a1;
      if (v7 < 2) {
        break;
      }
      if (v7 == 3)
      {
        sub_1002C3F18(a1, a1 + 1, v4 - 1);
        return result;
      }

      if (v7 == 2)
      {
        double result = *(v4 - 1);
        float v30 = *a1;
        if (result < *a1)
        {
          *a1 = result;
          *(v4 - 1) = v30;
        }

        return result;
      }

      float v8 = &a1[v7 >> 1];
      float v9 = v4 - 1;
      int v10 = sub_1002C3F18(a1, v8, v4 - 1);
      double result = *a1;
      if (*a1 >= *v8)
      {
        float v11 = v4 - 1;
        while (--v11 != a1)
        {
          if (*v11 < *v8)
          {
            *a1 = *v11;
            *float v11 = result;
            ++v10;
            goto LABEL_13;
          }
        }

        uint64_t v21 = a1 + 1;
        if (result >= *v9)
        {
          while (v21 != v9)
          {
            float v22 = *v21;
            if (result < *v21)
            {
              *v21++ = *v9;
              *float v9 = v22;
              goto LABEL_45;
            }

            ++v21;
          }

          return result;
        }

uint64_t sub_1002C3F18(float *a1, float *a2, float *a3)
{
  float v3 = *a2;
  float v4 = *a1;
  float v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1LL;
    }

    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4) {
      return 1LL;
    }
    *a2 = *a3;
    *a3 = v4;
    return 2LL;
  }

  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    float v6 = *a1;
    if (*a2 >= *a1) {
      return 1LL;
    }
    *a1 = *a2;
    *a2 = v6;
    return 2LL;
  }

  return 0LL;
}

float sub_1002C3FA0(float *a1, float *a2, float result)
{
  while (a1 != a2 - 1)
  {
    float v3 = a1++;
    if (v3 != a2 && a1 != a2)
    {
      double result = *v3;
      float v4 = a1;
      float v5 = v3;
      float v6 = a1;
      do
      {
        float v7 = *v6++;
        float v8 = v7;
        if (v7 < result)
        {
          double result = v8;
          float v5 = v4;
        }

        float v4 = v6;
      }

      while (v6 != a2);
      if (v5 != v3)
      {
        double result = *v3;
        *float v3 = *v5;
        *float v5 = result;
      }
    }
  }

  return result;
}

void sub_1002C4014(uint64_t a1@<X8>)
{
  *(_BYTE *)a1 = 0;
  __asm { FMOV            V0.2D, #10.0 }

  *(_OWORD *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = _Q0;
  *(_OWORD *)(a1 + 24) = xmmword_1012E5470;
  *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0x4024000000000000LL;
  buf[0] = 0;
  sub_1012049AC(&v30, "EnableMultiSportSimulation", buf, 0);
  int v6 = v31;
  *(_BYTE *)a1 = v31;
  if (v6)
  {
    *(void *)std::string buf = 0LL;
    sub_101204164(v28, "MultiSportSimulatedPauseTime", buf, 0);
    if (v28[0])
    {
      double v7 = v29;
      _NF = v29 < 10.0;
      if (v29 < 10.0) {
        double v7 = 10.0;
      }
      *(double *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = v7;
      if (_NF)
      {
        if (qword_101934680 != -1) {
          dispatch_once(&qword_101934680, &stru_10182F8A0);
        }
        float v9 = (os_log_s *)qword_101934688;
        if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 134218240;
          *(double *)&uint8_t buf[4] = v29;
          __int16 v45 = 2048;
          uint64_t v46 = 0x4024000000000000LL;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "MultiSportSim, failed to set pause time %f, min time is %f",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934680 != -1) {
            dispatch_once(&qword_101934680, &stru_10182F8A0);
          }
          int v42 = 134218240;
          *(double *)char v43 = v29;
          *(_WORD *)&v43[8] = 2048;
          *(void *)&v43[10] = 0x4024000000000000LL;
          LODWORD(v27) = 22;
          float v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  16LL,  "MultiSportSim, failed to set pause time %f, min time is %f",  COERCE_DOUBLE(&v42),  v27);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "static CLWorkoutSeriesModelSimulator::SimulationInfo CLWorkoutSeriesModelSimulator::SimulationInfo::fromDefaultsWrites()",  "%s\n",  v22);
          if (v22 != buf) {
            free(v22);
          }
        }
      }
    }

    *(void *)std::string buf = 0LL;
    sub_101204164((unsigned __int8 *)&v42, "MultiSportSimulatedTransitionTime", buf, 0);
    if ((_BYTE)v42)
    {
      double v10 = v29;
      BOOL v11 = v29 < 10.0;
      if (v29 < 10.0) {
        double v10 = 10.0;
      }
      *(double *)(a1 + 16) = v10;
      if (v11)
      {
        if (qword_101934680 != -1) {
          dispatch_once(&qword_101934680, &stru_10182F8A0);
        }
        float v12 = (os_log_s *)qword_101934688;
        if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 134218240;
          *(void *)&uint8_t buf[4] = *(void *)&v43[4];
          __int16 v45 = 2048;
          uint64_t v46 = 0x4024000000000000LL;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "MultiSportSim, failed to set transition time %f, min time is %f",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934680 != -1) {
            dispatch_once(&qword_101934680, &stru_10182F8A0);
          }
          int v40 = 134218240;
          *(void *)BOOL v41 = *(void *)&v43[4];
          *(_WORD *)&v41[8] = 2048;
          *(void *)&v41[10] = 0x4024000000000000LL;
          LODWORD(v27) = 22;
          uint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  16LL,  "MultiSportSim, failed to set transition time %f, min time is %f",  COERCE_DOUBLE(&v40),  v27);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "static CLWorkoutSeriesModelSimulator::SimulationInfo CLWorkoutSeriesModelSimulator::SimulationInfo::fromDefaultsWrites()",  "%s\n",  v23);
          if (v23 != buf) {
            free(v23);
          }
        }
      }
    }

    *(void *)std::string buf = 0LL;
    sub_101204164((unsigned __int8 *)&v40, "MultiSportSimulatedLegTime", buf, 0);
    if ((_BYTE)v40)
    {
      double v13 = *(double *)&v41[4];
      BOOL v14 = *(double *)&v41[4] < 10.0;
      *(double *)(a1 + 24) = v13;
      if (v14)
      {
        if (qword_101934680 != -1) {
          dispatch_once(&qword_101934680, &stru_10182F8A0);
        }
        float v15 = (os_log_s *)qword_101934688;
        if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 134218240;
          *(void *)&uint8_t buf[4] = *(void *)&v41[4];
          __int16 v45 = 2048;
          uint64_t v46 = 0x4024000000000000LL;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "MultiSportSim, failed to set leg time %f, min time is %f",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934680 != -1) {
            dispatch_once(&qword_101934680, &stru_10182F8A0);
          }
          int v38 = 134218240;
          *(void *)uint64_t v39 = *(void *)&v41[4];
          *(_WORD *)&v39[8] = 2048;
          *(void *)&v39[10] = 0x4024000000000000LL;
          LODWORD(v27) = 22;
          float v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  16LL,  "MultiSportSim, failed to set leg time %f, min time is %f",  COERCE_DOUBLE(&v38),  v27);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "static CLWorkoutSeriesModelSimulator::SimulationInfo CLWorkoutSeriesModelSimulator::SimulationInfo::fromDefaultsWrites()",  "%s\n",  v24);
          if (v24 != buf) {
            free(v24);
          }
        }
      }
    }

    *(void *)std::string buf = 0LL;
    sub_101204164((unsigned __int8 *)&v38, "MultiSportSimulatedSwimmingPrewarm", buf, 0);
    if ((_BYTE)v38)
    {
      double v16 = *(double *)&v39[4];
      BOOL v17 = *(double *)&v39[4] <= 0.0;
      if (!v17) {
        double v16 = 15.0;
      }
      *(double *)(a1 + sub_10000AE14(v13 - 32) = v16;
      if (!v17)
      {
        if (qword_101934680 != -1) {
          dispatch_once(&qword_101934680, &stru_10182F8A0);
        }
        float v18 = (os_log_s *)qword_101934688;
        if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 134218240;
          *(void *)&uint8_t buf[4] = *(void *)&v39[4];
          __int16 v45 = 2048;
          uint64_t v46 = 0x4024000000000000LL;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "MultiSportSim, failed to swim prewarm time %f, value must be <= 0 (disable prewarm) or > %f",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934680 != -1) {
            dispatch_once(&qword_101934680, &stru_10182F8A0);
          }
          int v36 = 134218240;
          *(void *)float v37 = *(void *)&v39[4];
          *(_WORD *)&v37[8] = 2048;
          *(void *)&v37[10] = 0x4024000000000000LL;
          LODWORD(v27) = 22;
          float v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  16LL,  "MultiSportSim, failed to swim prewarm time %f, value must be <= 0 (disable prewarm) or > %f",  COERCE_DOUBLE(&v36),  v27);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "static CLWorkoutSeriesModelSimulator::SimulationInfo CLWorkoutSeriesModelSimulator::SimulationInfo::fromDefaultsWrites()",  "%s\n",  v25);
          if (v25 != buf) {
            free(v25);
          }
        }
      }
    }

    *(void *)std::string buf = 0LL;
    sub_101204164((unsigned __int8 *)&v36, "MultiSportSimulatedOutdoorCyclingPrewarm", buf, 0);
    if ((_BYTE)v36)
    {
      double v19 = *(double *)&v37[4];
      BOOL v20 = *(double *)&v37[4] <= 0.0;
      if (!v20) {
        double v19 = 10.0;
      }
      *(double *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v19;
      if (!v20)
      {
        if (qword_101934680 != -1) {
          dispatch_once(&qword_101934680, &stru_10182F8A0);
        }
        uint64_t v21 = (os_log_s *)qword_101934688;
        if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 134218240;
          *(void *)&uint8_t buf[4] = *(void *)&v37[4];
          __int16 v45 = 2048;
          uint64_t v46 = 0x4024000000000000LL;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "MultiSportSim, failed to swim prewarm time %f, value must be <= 0 (disable prewarm) or > %f",  buf,  0x16u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934680 != -1) {
            dispatch_once(&qword_101934680, &stru_10182F8A0);
          }
          int v32 = 134218240;
          uint64_t v33 = *(void *)&v37[4];
          __int16 v34 = 2048;
          uint64_t v35 = 0x4024000000000000LL;
          LODWORD(v27) = 22;
          float v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  16LL,  "MultiSportSim, failed to swim prewarm time %f, value must be <= 0 (disable prewarm) or > %f",  COERCE_DOUBLE(&v32),  v27);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "static CLWorkoutSeriesModelSimulator::SimulationInfo CLWorkoutSeriesModelSimulator::SimulationInfo::fromDefaultsWrites()",  "%s\n",  v26);
          if (v26 != buf) {
            free(v26);
          }
        }
      }
    }
  }

uint64_t sub_1002C4944(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, double a7)
{
  uint64_t v10 = sub_100AD6F0C(a1, a2, a3, a4, a5);
  *(void *)uint64_t v10 = off_10182F870;
  *(double *)(v10 + 496) = a7;
  *(_OWORD *)(v10 + 504) = 0u;
  *(_OWORD *)(v10 + 52sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = 0u;
  *(_OWORD *)(v10 + 536) = 0u;
  sub_1002C49C4(v10, a6);
  return a1;
}

void sub_1002C49A8(_Unwind_Exception *a1)
{
}

void sub_1002C49C4(uint64_t a1, uint64_t a2)
{
  float v4 = *(void ***)(a1 + 512);
  uint64_t v5 = *(void *)(a1 + 520);
  *(void *)(a1 + 544) = 0LL;
  unint64_t v6 = v5 - (void)v4;
  if (v6 >= 0x11)
  {
    do
    {
      operator delete(*v4);
      float v4 = (void **)(*(void *)(a1 + 512) + 8LL);
      *(void *)(a1 + 512) = v4;
      unint64_t v6 = *(void *)(a1 + 520) - (void)v4;
    }

    while (v6 > 0x10);
  }

  if (v6 >> 3 == 1)
  {
    uint64_t v7 = 85LL;
  }

  else
  {
    if (v6 >> 3 != 2) {
      goto LABEL_8;
    }
    uint64_t v7 = 170LL;
  }

  *(void *)(a1 + 536) = v7;
LABEL_8:
  double v8 = *(double *)(a1 + 496);
  HIBYTE(v39) = 1;
  uint64_t v9 = *(void *)(a1 + 56);
  if (*(void *)(a1 + 64) == v9
    || (unint64_t v10 = *(void *)(a1 + 80),
        unint64_t v11 = *(void *)(v9 + 8 * (v10 / 0x18)) + 168 * (v10 % 0x18),
        unint64_t v12 = *(void *)(v9 + 8 * ((*(void *)(a1 + 88) + v10) / 0x18)) + 168 * ((*(void *)(a1 + 88) + v10) % 0x18),
        v11 == v12))
  {
LABEL_24:
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_10182F8A0);
    }
    double v19 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = *(void *)(a2 + 8);
      uint64_t v21 = *(void *)(a2 + 16);
      uint64_t v22 = *(void *)(a2 + 24);
      uint64_t v23 = *(void *)(a2 + 32);
      uint64_t v24 = *(void *)(a2 + 40);
      *(_DWORD *)std::string buf = 134219008;
      *(void *)&uint8_t buf[4] = v20;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(void *)&buf[14] = v21;
      *(_WORD *)&_BYTE buf[22] = 2048;
      uint64_t v51 = v22;
      __int16 v52 = 2048;
      uint64_t v53 = v23;
      __int16 v54 = 2048;
      uint64_t v55 = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "MultiSportSimParams,pauseTime,%f,transistionTime,%f,legTime,%f,swimPrewarmTime,%f,outdoorCyclingPrewarmTime,%f",  buf,  0x34u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_10182F8A0);
      }
      uint64_t v31 = *(void *)(a2 + 8);
      uint64_t v32 = *(void *)(a2 + 16);
      uint64_t v33 = *(void *)(a2 + 24);
      uint64_t v34 = *(void *)(a2 + 32);
      uint64_t v35 = *(void *)(a2 + 40);
      int v40 = 134219008;
      uint64_t v41 = v31;
      __int16 v42 = 2048;
      uint64_t v43 = v32;
      __int16 v44 = 2048;
      uint64_t v45 = v33;
      __int16 v46 = 2048;
      uint64_t v47 = v34;
      __int16 v48 = 2048;
      uint64_t v49 = v35;
      LODWORD(v39) = 52;
      int v36 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "MultiSportSimParams,pauseTime,%f,transistionTime,%f,legTime,%f,swimPrewarmTime,%f,outdoorCyclingPrewarmTime,%f",  COERCE_DOUBLE(&v40),  v39);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutSeriesModelSimulator::buildTestSequence(const SimulationInfo &)",  "%s\n",  v36);
      if (v36 != buf) {
        free(v36);
      }
    }

    return;
  }

  double v13 = v8 + 5.0;
  BOOL v14 = (void *)(v9 + 8 * (v10 / 0x18));
  while (1)
  {
    uint64_t v15 = *(void *)(v11 + 48);
    if (v15 > 16) {
      break;
    }
    switch(v15)
    {
      case 2LL:
        goto LABEL_17;
      case 4LL:
        double v16 = operator new(0x10uLL);
        *(void *)&uint8_t buf[8] = v16 + 2;
        *(void *)&uint8_t buf[16] = v16 + 2;
        *double v16 = 19LL;
        v16[1] = 0x500000004LL;
        *(void *)std::string buf = v16;
        double v17 = sub_1002C5094( a1,  *(void *)(v11 + 48),  (double *)a2,  (uint64_t **)buf,  (_BYTE *)&v39 + 7,  v13,  *(double *)(a2 + 40));
        break;
      case 5LL:
        double v16 = operator new(0x20uLL);
        *(void *)&uint8_t buf[8] = v16 + 4;
        *(void *)&uint8_t buf[16] = v16 + 4;
        *(_OWORD *)double v16 = xmmword_1012E54F8;
        *((_OWORD *)v16 + 1) = unk_1012E5508;
        *(void *)std::string buf = v16;
        double v17 = sub_1002C5094(a1, *(void *)(v11 + 48), (double *)a2, (uint64_t **)buf, (_BYTE *)&v39 + 7, v13, 0.0);
        break;
      default:
        goto LABEL_30;
    }

void sub_1002C5008(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1002C5030(uint64_t a1)
{
  *(void *)a1 = off_10186E3E8;
  float v3 = (void **)(a1 + 112);
  sub_1002C5E9C(&v3);
  sub_1002C5F18((void *)(a1 + 48));
  return a1;
}

double sub_1002C5094( uint64_t a1, unint64_t a2, double *a3, uint64_t **a4, _BYTE *a5, double a6, double a7)
{
  double v14 = a6;
  __int128 __p = 0LL;
  double v102 = 0LL;
  std::string::size_type v105 = 0LL;
  if (a7 > 0.0)
  {
    double v17 = a6 + a7;
    double v18 = a3[3];
    double v9 = v14 + a7 + v18 * 0.5 + a3[1];
    double v99 = v9 + a7;
    double v100 = v14 + a7 + v18 * 0.5;
    double v98 = v9 + a7 + v18 * 0.5;
    double v97 = v98 + a3[2];
    if (*a5) {
      goto LABEL_5;
    }
    uint64_t v22 = (__n128 *)sub_10000701C((uint64_t)&v105, 1uLL);
    unint64_t v20 = (unint64_t)&v22->n128_u64[3 * v23];
    v22->n128_f64[0] = v14;
    v22->n128_u64[1] = a2;
    v22[1].n128_u64[0] = 0x200000000LL;
    uint64_t v21 = (__n128 *)((char *)v22 + 24);
    __int128 __p = v22;
    std::string::size_type v105 = (char *)v20;
    double v102 = (__n128 *)((char *)v22 + 24);
    if ((unint64_t)&v22[1].n128_u64[1] < v20)
    {
      v22[1].n128_f64[1] = v17;
      v22[2].n128_u64[0] = a2;
      v22[2].n128_u64[1] = 2LL;
      double v19 = v22 + 3;
      goto LABEL_25;
    }

    double v14 = v14 + a7;
  }

  else
  {
    double v16 = a3[3];
    double v99 = v14 + v16 * 0.5 + a3[1];
    double v100 = v14 + v16 * 0.5;
    double v98 = v99 + v16 * 0.5;
    double v97 = v98 + a3[2];
    if (*a5)
    {
      double v17 = v14;
LABEL_5:
      double v19 = 0LL;
      unint64_t v20 = 0LL;
      *a5 = 0;
      goto LABEL_27;
    }

    uint64_t v21 = 0LL;
    unint64_t v20 = 0LL;
  }

  uint64_t v24 = __p;
  unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * (((char *)v21 - (char *)__p) >> 3);
  unint64_t v26 = v25 + 1;
  if (v25 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_100007008();
  }
  unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - (void)__p) >> 3);
  if (2 * v27 > v26) {
    unint64_t v26 = 2 * v27;
  }
  if (v27 >= 0x555555555555555LL) {
    unint64_t v28 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v28 = v26;
  }
  if (v28)
  {
    unint64_t v29 = (char *)sub_10000701C((uint64_t)&v105, v28);
    uint64_t v24 = __p;
    uint64_t v21 = v102;
  }

  else
  {
    unint64_t v29 = 0LL;
  }

  uint64_t v30 = (__n128 *)&v29[24 * v25];
  unint64_t v20 = (unint64_t)&v29[24 * v28];
  v30->n128_f64[0] = v14;
  v30->n128_u64[1] = a2;
  v30[1].n128_u64[0] = 2LL;
  double v19 = (__n128 *)((char *)v30 + 24);
  if (v21 != v24)
  {
    do
    {
      __n128 v31 = *(__n128 *)((char *)v21 - 24);
      v30[-1].n128_u64[1] = v21[-1].n128_u64[1];
      *(__n128 *)((char *)v30 - 24) = v31;
      uint64_t v30 = (__n128 *)((char *)v30 - 24);
      uint64_t v21 = (__n128 *)((char *)v21 - 24);
    }

    while (v21 != v24);
    uint64_t v24 = __p;
  }

  __int128 __p = v30;
  std::string::size_type v105 = (char *)v20;
  if (v24)
  {
    operator delete(v24);
    unint64_t v20 = (unint64_t)v105;
  }

  double v17 = v14;
LABEL_25:
  double v102 = v19;
  *a5 = 0;
  if ((unint64_t)v19 < v20)
  {
    v19->n128_f64[0] = v100;
    v19->n128_u64[1] = a2;
    v19[1].n128_u64[0] = 1LL;
    uint64_t v32 = &v19[1].n128_f64[1];
    goto LABEL_41;
  }

void sub_1002C5B20( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_1002C5B64(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 170 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1002C6C5C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  double v8 = (__n128 *)(*(void *)(v5 + 8 * (v7 / 0xAA)) + 24 * (v7 % 0xAA));
  __n128 result = *a2;
  v8[1].n128_u64[0] = a2[1].n128_u64[0];
  __n128 *v8 = result;
  ++a1[5];
  return result;
}

uint64_t sub_1002C5C10@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void **a3@<X8>)
{
  uint64_t v4 = (void *)result;
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v30 = (uint64_t)(a3 + 2);
  uint64_t v6 = result + 504;
  unint64_t v7 = (int64x2_t *)(result + 536);
  while (v4[68])
  {
    unint64_t v8 = v4[67];
    uint64_t v9 = *(void *)(v4[64] + 8 * (v8 / 0xAA));
    unint64_t v10 = v8 % 0xAA;
    double v11 = *(double *)(v9 + 24 * v10);
    double v12 = v11 + -5.0;
    uint64_t v13 = v9 + 24 * v10;
    int v15 = *(_DWORD *)(v13 + 16);
    int v14 = *(_DWORD *)(v13 + 20);
    uint64_t v16 = *(void *)(v13 + 8);
    double v18 = (double *)a3[1];
    double v17 = (double *)a3[2];
    if (v18 >= v17)
    {
      unint64_t v20 = (double *)*a3;
      uint64_t v21 = ((char *)v18 - (_BYTE *)*a3) >> 5;
      unint64_t v22 = v21 + 1;
      uint64_t v23 = (char *)v17 - (char *)v20;
      if (v23 >> 4 > v22) {
        unint64_t v22 = v23 >> 4;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24)
      {
        unint64_t v25 = (char *)sub_10000835C(v30, v24);
        unint64_t v20 = (double *)*a3;
        double v18 = (double *)a3[1];
      }

      else
      {
        unint64_t v25 = 0LL;
      }

      unint64_t v26 = (double *)&v25[32 * v21];
      *unint64_t v26 = v11;
      v26[1] = v12;
      *((_DWORD *)v26 + 4) = v15;
      *((_DWORD *)v26 + 5) = v14;
      *((void *)v26 + 3) = v16;
      if (v18 == v20)
      {
        unint64_t v29 = &v25[32 * v21];
      }

      else
      {
        unint64_t v27 = &v25[32 * v21];
        do
        {
          __int128 v28 = *((_OWORD *)v18 - 1);
          unint64_t v29 = v27 - 32;
          *((_OWORD *)v27 - 2) = *((_OWORD *)v18 - 2);
          *((_OWORD *)v27 - 1) = v28;
          v18 -= 4;
          v27 -= 32;
        }

        while (v18 != v20);
      }

      double v19 = v26 + 4;
      *a3 = v29;
      a3[1] = v26 + 4;
      a3[2] = &v25[32 * v24];
      if (v20) {
        operator delete(v20);
      }
    }

    else
    {
      double *v18 = v11;
      v18[1] = v12;
      *((_DWORD *)v18 + 4) = v15;
      *((_DWORD *)v18 + 5) = v14;
      double v19 = v18 + 4;
      *((void *)v18 + 3) = v16;
    }

    a3[1] = v19;
    int64x2_t *v7 = vaddq_s64(*v7, (int64x2_t)xmmword_1012CE4D0);
    __n128 result = sub_100211164(v6, 1);
  }

  return result;
}

void sub_1002C5DE4(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::iostream::~basic_iostream(v2, v3 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C5E04(void *a1)
{
  *a1 = off_10182F870;
  sub_100210A00(a1 + 63);
  return sub_1002C5030((uint64_t)a1);
}

void sub_1002C5E38(void *a1)
{
  *a1 = off_10182F870;
  sub_100210A00(a1 + 63);
  uint64_t v2 = (void *)sub_1002C5030((uint64_t)a1);
  operator delete(v2);
}

void sub_1002C5E70(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

void sub_1002C5E9C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0LL;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 32LL))(v6);
        }
      }

      while (v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_1002C5F18(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  float v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      float v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 12LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 24LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void sub_1002C5FAC(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
LABEL_1:
  unint64_t v8 = a1;
  while (2)
  {
    a1 = v8;
    uint64_t v9 = a2 - v8;
    uint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v8) >> 3);
    switch(v10)
    {
      case 0LL:
      case 1LL:
        return;
      case 2LL:
        double v39 = *(double *)(a2 - 24);
        unint64_t v38 = a2 - 24;
        if (v39 < *(double *)v8)
        {
          uint64_t v108 = *(void *)(v8 + 16);
          __int128 v99 = *(_OWORD *)v8;
          __int128 v40 = *(_OWORD *)v38;
          *(void *)(v8 + 16) = *(void *)(v38 + 16);
          *(_OWORD *)unint64_t v8 = v40;
          *(void *)(v38 + 16) = v108;
          *(_OWORD *)unint64_t v38 = v99;
        }

        return;
      case 3LL:
        sub_1002C6828((__int128 *)v8, (__int128 *)(v8 + 24), (__int128 *)(a2 - 24));
        return;
      case 4LL:
        sub_1002C6B90(v8, v8 + 24, v8 + 48, (unint64_t *)(a2 - 24));
        return;
      case 5LL:
        uint64_t v41 = (__int128 *)(v8 + 24);
        __int16 v42 = (__int128 *)(v8 + 48);
        unint64_t v43 = (__int128 *)(v8 + 72);
        sub_1002C6B90(v8, v8 + 24, v8 + 48, (unint64_t *)(v8 + 72));
        double v45 = *(double *)(a2 - 24);
        unint64_t v44 = a2 - 24;
        if (v45 < *(double *)(v8 + 72))
        {
          __int128 v46 = *v43;
          uint64_t v47 = *(void *)(v8 + 88);
          uint64_t v48 = *(void *)(v44 + 16);
          *unint64_t v43 = *(_OWORD *)v44;
          *(void *)(v8 + 8std::iostream::~basic_iostream(v2, v3 + 8) = v48;
          *(void *)(v44 + 16) = v47;
          *(_OWORD *)unint64_t v44 = v46;
          if (*(double *)v43 < *(double *)v42)
          {
            uint64_t v49 = *(void *)(v8 + 64);
            __int128 v50 = *v42;
            *__int16 v42 = *v43;
            *(void *)(v8 + 64) = *(void *)(v8 + 88);
            *unint64_t v43 = v50;
            *(void *)(v8 + 8std::iostream::~basic_iostream(v2, v3 + 8) = v49;
            if (*(double *)v42 < *(double *)v41)
            {
              uint64_t v51 = *(void *)(v8 + 40);
              __int128 v52 = *v41;
              *uint64_t v41 = *v42;
              *(void *)(v8 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(v8 + 64);
              *__int16 v42 = v52;
              *(void *)(v8 + 64) = v51;
              if (*(double *)(v8 + 24) < *(double *)v8)
              {
                uint64_t v109 = *(void *)(v8 + 16);
                __int128 v100 = *(_OWORD *)v8;
                *(_OWORD *)unint64_t v8 = *v41;
                *(void *)(v8 + 16) = *(void *)(v8 + 40);
                *uint64_t v41 = v100;
                *(void *)(v8 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v109;
              }
            }
          }
        }

        return;
      default:
        if (v9 <= 575)
        {
          unint64_t v53 = v8 + 24;
          BOOL v55 = v8 == a2 || v53 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v55)
            {
              uint64_t v56 = 0LL;
              unint64_t v57 = v8;
              do
              {
                unint64_t v58 = v53;
                double v59 = *(double *)(v57 + 24);
                if (v59 < *(double *)v57)
                {
                  __int128 v101 = *(_OWORD *)(v57 + 32);
                  uint64_t v60 = v56;
                  while (1)
                  {
                    uint64_t v61 = v8 + v60;
                    *(_OWORD *)(v61 + 24) = *(_OWORD *)(v8 + v60);
                    *(void *)(v61 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(v8 + v60 + 16);
                    if (!v60) {
                      break;
                    }
                    v60 -= 24LL;
                    if (v59 >= *(double *)(v61 - 24))
                    {
                      uint64_t v62 = v8 + v60 + 24;
                      goto LABEL_75;
                    }
                  }

                  uint64_t v62 = v8;
LABEL_75:
                  *(double *)uint64_t v62 = v59;
                  *(_OWORD *)(v62 + std::iostream::~basic_iostream(v2, v3 + 8) = v101;
                }

                unint64_t v53 = v58 + 24;
                v56 += 24LL;
                unint64_t v57 = v58;
              }

              while (v58 + 24 != a2);
            }
          }

          else if (!v55)
          {
            do
            {
              uint64_t v89 = v53;
              double v90 = *(double *)(a1 + 24);
              if (v90 < *(double *)a1)
              {
                __int128 v104 = *(_OWORD *)(a1 + 32);
                unint64_t v91 = v53;
                do
                {
                  *(_OWORD *)unint64_t v91 = *(_OWORD *)(v91 - 24);
                  *(void *)(v91 + 16) = *(void *)(v91 - 8);
                  double v92 = *(double *)(v91 - 48);
                  v91 -= 24LL;
                }

                while (v90 < v92);
                *(double *)unint64_t v91 = v90;
                *(_OWORD *)(v91 + std::iostream::~basic_iostream(v2, v3 + 8) = v104;
              }

              v53 += 24LL;
              a1 = v89;
            }

            while (v89 + 24 != a2);
          }

          return;
        }

        if (!a3)
        {
          if (v8 != a2)
          {
            int64_t v63 = (unint64_t)(v10 - 2) >> 1;
            int64_t v64 = v63;
            do
            {
              int64_t v65 = v64;
              if (v63 >= v64)
              {
                uint64_t v66 = (2 * v64) | 1;
                unint64_t v67 = v8 + 24 * v66;
                if (2 * v65 + 2 < v10 && *(double *)v67 < *(double *)(v67 + 24))
                {
                  v67 += 24LL;
                  uint64_t v66 = 2 * v65 + 2;
                }

                unint64_t v68 = v8 + 24 * v65;
                double v69 = *(double *)v68;
                if (*(double *)v67 >= *(double *)v68)
                {
                  __int128 v102 = *(_OWORD *)(v68 + 8);
                  do
                  {
                    unint64_t v70 = v68;
                    unint64_t v68 = v67;
                    __int128 v71 = *(_OWORD *)v67;
                    *(void *)(v70 + 16) = *(void *)(v67 + 16);
                    *(_OWORD *)unint64_t v70 = v71;
                    if (v63 < v66) {
                      break;
                    }
                    uint64_t v72 = 2 * v66;
                    uint64_t v66 = (2 * v66) | 1;
                    unint64_t v67 = v8 + 24 * v66;
                    uint64_t v73 = v72 + 2;
                    if (v73 < v10 && *(double *)v67 < *(double *)(v67 + 24))
                    {
                      v67 += 24LL;
                      uint64_t v66 = v73;
                    }
                  }

                  while (*(double *)v67 >= v69);
                  *(double *)unint64_t v68 = v69;
                  *(_OWORD *)(v68 + std::iostream::~basic_iostream(v2, v3 + 8) = v102;
                }
              }

              int64_t v64 = v65 - 1;
            }

            while (v65);
            int64_t v74 = v9 / 0x18uLL;
            do
            {
              uint64_t v75 = 0LL;
              uint64_t v110 = *(void *)(v8 + 16);
              __int128 v103 = *(_OWORD *)v8;
              unint64_t v76 = v8;
              do
              {
                unint64_t v77 = v76;
                v76 += 24 * v75 + 24;
                uint64_t v78 = 2 * v75;
                uint64_t v75 = (2 * v75) | 1;
                int64_t v79 = v78 + 2;
                if (v79 < v74 && *(double *)v76 < *(double *)(v76 + 24))
                {
                  v76 += 24LL;
                  uint64_t v75 = v79;
                }

                __int128 v80 = *(_OWORD *)v76;
                *(void *)(v77 + 16) = *(void *)(v76 + 16);
                *(_OWORD *)unint64_t v77 = v80;
              }

              while (v75 <= (uint64_t)((unint64_t)(v74 - 2) >> 1));
              a2 -= 24LL;
              if (v76 == a2)
              {
                *(void *)(v76 + 16) = v110;
                *(_OWORD *)unint64_t v76 = v103;
              }

              else
              {
                __int128 v81 = *(_OWORD *)a2;
                *(void *)(v76 + 16) = *(void *)(a2 + 16);
                *(_OWORD *)unint64_t v76 = v81;
                *(void *)(a2 + 16) = v110;
                *(_OWORD *)a2 = v103;
                uint64_t v82 = v76 - v8 + 24;
                if (v82 >= 25)
                {
                  unint64_t v83 = (v82 / 0x18uLL - 2) >> 1;
                  unint64_t v84 = v8 + 24 * v83;
                  double v85 = *(double *)v76;
                  if (*(double *)v84 < *(double *)v76)
                  {
                    __int128 v95 = *(_OWORD *)(v76 + 8);
                    do
                    {
                      unint64_t v86 = v76;
                      unint64_t v76 = v84;
                      __int128 v87 = *(_OWORD *)v84;
                      *(void *)(v86 + 16) = *(void *)(v84 + 16);
                      *(_OWORD *)unint64_t v86 = v87;
                      if (!v83) {
                        break;
                      }
                      unint64_t v83 = (v83 - 1) >> 1;
                      unint64_t v84 = v8 + 24 * v83;
                    }

                    while (*(double *)v84 < v85);
                    *(double *)unint64_t v76 = v85;
                    *(_OWORD *)(v76 + std::iostream::~basic_iostream(v2, v3 + 8) = v95;
                  }
                }
              }
            }

            while (v74-- > 2);
          }

          return;
        }

        unint64_t v11 = (unint64_t)v10 >> 1;
        unint64_t v12 = v8 + 24 * ((unint64_t)v10 >> 1);
        if ((unint64_t)v9 < 0xC01)
        {
          sub_1002C6828((__int128 *)(a1 + 24 * v11), (__int128 *)a1, (__int128 *)(a2 - 24));
        }

        else
        {
          sub_1002C6828((__int128 *)a1, (__int128 *)(a1 + 24 * v11), (__int128 *)(a2 - 24));
          uint64_t v13 = 3 * v11;
          int v14 = (__int128 *)(a1 + 24 * v11 - 24);
          sub_1002C6828((__int128 *)(a1 + 24), v14, (__int128 *)(a2 - 48));
          int v15 = (__int128 *)(a1 + 24 + 8 * v13);
          sub_1002C6828((__int128 *)(a1 + 48), v15, (__int128 *)(a2 - 72));
          sub_1002C6828(v14, (__int128 *)v12, v15);
          uint64_t v105 = *(void *)(a1 + 16);
          __int128 v96 = *(_OWORD *)a1;
          uint64_t v16 = *(void *)(v12 + 16);
          *(_OWORD *)a1 = *(_OWORD *)v12;
          *(void *)(a1 + 16) = v16;
          *(void *)(v12 + 16) = v105;
          *(_OWORD *)unint64_t v12 = v96;
        }

        --a3;
        double v17 = *(double *)a1;
        if ((a4 & 1) == 0 && *(double *)(a1 - 24) >= v17)
        {
          __int128 v94 = *(_OWORD *)(a1 + 8);
          if (v17 >= *(double *)(a2 - 24))
          {
            unint64_t v31 = a1 + 24;
            do
            {
              unint64_t v8 = v31;
              if (v31 >= a2) {
                break;
              }
              v31 += 24LL;
            }

            while (v17 >= *(double *)v8);
          }

          else
          {
            unint64_t v8 = a1;
            do
            {
              double v30 = *(double *)(v8 + 24);
              v8 += 24LL;
            }

            while (v17 >= v30);
          }

          unint64_t v32 = a2;
          if (v8 < a2)
          {
            unint64_t v32 = a2;
            do
            {
              double v33 = *(double *)(v32 - 24);
              v32 -= 24LL;
            }

            while (v17 < v33);
          }

          while (v8 < v32)
          {
            uint64_t v107 = *(void *)(v8 + 16);
            __int128 v98 = *(_OWORD *)v8;
            __int128 v34 = *(_OWORD *)v32;
            *(void *)(v8 + 16) = *(void *)(v32 + 16);
            *(_OWORD *)unint64_t v8 = v34;
            *(void *)(v32 + 16) = v107;
            *(_OWORD *)unint64_t v32 = v98;
            do
            {
              double v35 = *(double *)(v8 + 24);
              v8 += 24LL;
            }

            while (v17 >= v35);
            do
            {
              double v36 = *(double *)(v32 - 24);
              v32 -= 24LL;
            }

            while (v17 < v36);
          }

          if (v8 - 24 != a1)
          {
            __int128 v37 = *(_OWORD *)(v8 - 24);
            *(void *)(a1 + 16) = *(void *)(v8 - 8);
            *(_OWORD *)a1 = v37;
          }

          a4 = 0;
          *(double *)(v8 - 24) = v17;
          *(_OWORD *)(v8 - 16) = v94;
          continue;
        }

        uint64_t v18 = 0LL;
        __int128 v93 = *(_OWORD *)(a1 + 8);
        do
        {
          double v19 = *(double *)(a1 + v18 + 24);
          v18 += 24LL;
        }

        while (v19 < v17);
        unint64_t v20 = a1 + v18;
        unint64_t v21 = a2;
        if (v18 == 24)
        {
          unint64_t v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            double v23 = *(double *)(v21 - 24);
            v21 -= 24LL;
          }

          while (v23 >= v17);
        }

        else
        {
          do
          {
            double v22 = *(double *)(v21 - 24);
            v21 -= 24LL;
          }

          while (v22 >= v17);
        }

        unint64_t v8 = a1 + v18;
        if (v20 < v21)
        {
          unint64_t v24 = v21;
          do
          {
            uint64_t v106 = *(void *)(v8 + 16);
            __int128 v97 = *(_OWORD *)v8;
            __int128 v25 = *(_OWORD *)v24;
            *(void *)(v8 + 16) = *(void *)(v24 + 16);
            *(_OWORD *)unint64_t v8 = v25;
            *(void *)(v24 + 16) = v106;
            *(_OWORD *)unint64_t v24 = v97;
            do
            {
              double v26 = *(double *)(v8 + 24);
              v8 += 24LL;
            }

            while (v26 < v17);
            do
            {
              double v27 = *(double *)(v24 - 24);
              v24 -= 24LL;
            }

            while (v27 >= v17);
          }

          while (v8 < v24);
        }

        if (v8 - 24 != a1)
        {
          __int128 v28 = *(_OWORD *)(v8 - 24);
          *(void *)(a1 + 16) = *(void *)(v8 - 8);
          *(_OWORD *)a1 = v28;
        }

        *(double *)(v8 - 24) = v17;
        *(_OWORD *)(v8 - 16) = v93;
        if (v20 < v21)
        {
LABEL_29:
          sub_1002C5FAC(a1, v8 - 24, a3, a4 & 1);
          a4 = 0;
          continue;
        }

        BOOL v29 = sub_1002C6918(a1, v8 - 24);
        if (!sub_1002C6918(v8, a2))
        {
          if (v29) {
            continue;
          }
          goto LABEL_29;
        }

        a2 = v8 - 24;
        if (!v29) {
          goto LABEL_1;
        }
        return;
    }
  }

__int128 *sub_1002C6828(__int128 *result, __int128 *a2, __int128 *a3)
{
  double v3 = *(double *)a2;
  double v4 = *(double *)a3;
  if (*(double *)a2 >= *(double *)result)
  {
    if (v4 < v3)
    {
      uint64_t v8 = *((void *)a2 + 2);
      __int128 v9 = *a2;
      uint64_t v10 = *((void *)a3 + 2);
      *a2 = *a3;
      *((void *)a2 + 2) = v10;
      *a3 = v9;
      *((void *)a3 + 2) = v8;
      if (*(double *)a2 < *(double *)result)
      {
        uint64_t v11 = *((void *)result + 2);
        __int128 v12 = *result;
        uint64_t v13 = *((void *)a2 + 2);
        *__n128 result = *a2;
        *((void *)result + 2) = v13;
        *a2 = v12;
        *((void *)a2 + 2) = v11;
      }
    }
  }

  else
  {
    if (v4 >= v3)
    {
      uint64_t v14 = *((void *)result + 2);
      __int128 v15 = *result;
      uint64_t v16 = *((void *)a2 + 2);
      *__n128 result = *a2;
      *((void *)result + 2) = v16;
      *a2 = v15;
      *((void *)a2 + 2) = v14;
      uint64_t v5 = *((void *)a2 + 2);
      __int128 v6 = *a2;
      uint64_t v17 = *((void *)a3 + 2);
      *a2 = *a3;
      *((void *)a2 + 2) = v17;
    }

    else
    {
      uint64_t v5 = *((void *)result + 2);
      __int128 v6 = *result;
      uint64_t v7 = *((void *)a3 + 2);
      *__n128 result = *a3;
      *((void *)result + 2) = v7;
    }

    *a3 = v6;
    *((void *)a3 + 2) = v5;
  }

  return result;
}

BOOL sub_1002C6918(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      __int128 v6 = (__int128 *)(a2 - 24);
      if (*(double *)(a2 - 24) < *(double *)a1)
      {
        uint64_t v7 = *(void *)(a1 + 16);
        __int128 v8 = *(_OWORD *)a1;
        uint64_t v9 = *(void *)(a2 - 8);
        *(_OWORD *)a1 = *v6;
        *(void *)(a1 + 16) = v9;
        *__int128 v6 = v8;
        *(void *)(a2 - std::iostream::~basic_iostream(v2, v3 + 8) = v7;
      }

      return result;
    case 3uLL:
      sub_1002C6828((__int128 *)a1, (__int128 *)(a1 + 24), (__int128 *)(a2 - 24));
      return 1LL;
    case 4uLL:
      sub_1002C6B90(a1, a1 + 24, a1 + 48, (unint64_t *)(a2 - 24));
      return 1LL;
    case 5uLL:
      uint64_t v18 = (__int128 *)(a1 + 24);
      double v19 = (__int128 *)(a1 + 48);
      unint64_t v20 = (__int128 *)(a1 + 72);
      sub_1002C6B90(a1, a1 + 24, a1 + 48, (unint64_t *)(a1 + 72));
      double v22 = *(double *)(a2 - 24);
      uint64_t v21 = a2 - 24;
      if (v22 < *(double *)(a1 + 72))
      {
        uint64_t v23 = *(void *)(a1 + 88);
        __int128 v24 = *v20;
        uint64_t v25 = *(void *)(v21 + 16);
        *unint64_t v20 = *(_OWORD *)v21;
        *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = v25;
        *(_OWORD *)uint64_t v21 = v24;
        *(void *)(v21 + 16) = v23;
        if (*(double *)v20 < *(double *)v19)
        {
          uint64_t v26 = *(void *)(a1 + 64);
          __int128 v27 = *v19;
          *double v19 = *v20;
          *(void *)(a1 + 64) = *(void *)(a1 + 88);
          *unint64_t v20 = v27;
          *(void *)(a1 + 8std::iostream::~basic_iostream(v2, v3 + 8) = v26;
          if (*(double *)v19 < *(double *)v18)
          {
            uint64_t v28 = *(void *)(a1 + 40);
            __int128 v29 = *v18;
            __int128 *v18 = *v19;
            *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = *(void *)(a1 + 64);
            *double v19 = v29;
            *(void *)(a1 + 64) = v28;
            if (*(double *)(a1 + 24) < *(double *)a1)
            {
              uint64_t v30 = *(void *)(a1 + 16);
              __int128 v31 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v18;
              *(void *)(a1 + 16) = *(void *)(a1 + 40);
              __int128 *v18 = v31;
              *(void *)(a1 + 4sub_10023AE2C(v1, "HealthColdStorageVacuumPageLimitKey", &dword_1012E2B48, 0) = v30;
            }
          }
        }
      }

      return 1LL;
    default:
      uint64_t v10 = (double *)(a1 + 48);
      sub_1002C6828((__int128 *)a1, (__int128 *)(a1 + 24), (__int128 *)(a1 + 48));
      uint64_t v11 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1LL;
      }
      uint64_t v12 = 0LL;
      int v13 = 0;
      break;
  }

  while (1)
  {
    double v14 = *(double *)v11;
    if (*(double *)v11 < *v10)
    {
      __int128 v32 = *(_OWORD *)(v11 + 8);
      uint64_t v15 = v12;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        *(_OWORD *)(v16 + 72) = *(_OWORD *)(a1 + v15 + 48);
        *(void *)(v16 + 8std::iostream::~basic_iostream(v2, v3 + 8) = *(void *)(a1 + v15 + 64);
        if (v15 == -48) {
          break;
        }
        v15 -= 24LL;
        if (v14 >= *(double *)(v16 + 24))
        {
          uint64_t v17 = a1 + v15 + 72;
          goto LABEL_13;
        }
      }

      uint64_t v17 = a1;
LABEL_13:
      *(double *)uint64_t v17 = v14;
      *(_OWORD *)(v17 + std::iostream::~basic_iostream(v2, v3 + 8) = v32;
      if (++v13 == 8) {
        return v11 + 24 == a2;
      }
    }

    uint64_t v10 = (double *)v11;
    v12 += 24LL;
    v11 += 24LL;
    if (v11 == a2) {
      return 1LL;
    }
  }

__n128 sub_1002C6B90(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  result.n128_u64[0] = *a4;
  if (*(double *)a4 < *(double *)a3)
  {
    unint64_t v9 = *(void *)(a3 + 16);
    __n128 result = *(__n128 *)a3;
    unint64_t v10 = a4[2];
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(void *)(a3 + 16) = v10;
    *(__n128 *)a4 = result;
    a4[2] = v9;
    result.n128_u64[0] = *(void *)a3;
    if (*(double *)a3 < *(double *)a2)
    {
      uint64_t v11 = *(void *)(a2 + 16);
      __n128 result = *(__n128 *)a2;
      uint64_t v12 = *(void *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(void *)(a2 + 16) = v12;
      *(__n128 *)a3 = result;
      *(void *)(a3 + 16) = v11;
      result.n128_u64[0] = *(void *)a2;
      if (*(double *)a2 < *(double *)a1)
      {
        uint64_t v13 = *(void *)(a1 + 16);
        __n128 result = *(__n128 *)a1;
        uint64_t v14 = *(void *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = v14;
        *(__n128 *)a2 = result;
        *(void *)(a2 + 16) = v13;
      }
    }
  }

  return result;
}

void sub_1002C6C5C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0xAA;
  unint64_t v4 = v2 - 170;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    __int128 v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    __int128 v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)__int128 v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int128 v34 = (char *)sub_1000071BC(v5, v33);
      double v35 = &v34[8 * (v33 >> 2)];
      __int128 v37 = &v34[8 * v36];
      unint64_t v38 = (uint64_t *)a1[1];
      __int128 v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        __int128 v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1002C6F24( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1002C6F70(uint64_t a1, double *a2)
{
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)&qword_1019940E8);
  if ((v4 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019940E8))
    {
      LODWORD(v7[0]) = 8;
      sub_1002C72A8(qword_1019940D0, v7, 1uLL);
      __cxa_atexit((void (*)(void *))sub_1002C7328, qword_1019940D0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019940E8);
    }
  }

  __int16 v8 = 0;
  *(_OWORD *)uint64_t v7 = xmmword_1012E1E90;
  memset(&v7[2], 0, 135);
  __int128 v9 = xmmword_1012E1E90;
  uint64_t v10 = 0LL;
  int v11 = 0;
  uint64_t v12 = 0LL;
  v13[0] = 0LL;
  *(void *)((char *)v13 + 5) = 0LL;
  *(void *)((char *)&v13[1] + 6) = 0LL;
  char v14 = 0;
  memset(&v13[3], 0, 24);
  __int128 v15 = xmmword_1012E1E90;
  uint64_t v16 = 0LL;
  int v17 = 0;
  unint64_t v18 = 0xFFEFFFFFFFFFFFFFLL;
  int v29 = 0;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  int v24 = 0;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  memset(v28, 0, sizeof(v28));
  uint64_t v30 = 0LL;
  uint64_t v31 = 0LL;
  unint64_t v32 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v33 = 0LL;
  int v34 = 0;
  uint64_t v40 = 0LL;
  __int16 v41 = 0;
  int v46 = 0;
  int v39 = 0;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v43 = 0u;
  __int128 v42 = 0u;
  char v44 = 0;
  memset(v45, 0, sizeof(v45));
  unint64_t v47 = 0xFFEFFFFFFFFFFFFFLL;
  __int128 v66 = 0u;
  __int128 v65 = 0u;
  __int128 v64 = 0u;
  __int128 v63 = 0u;
  __int128 v62 = 0u;
  __int128 v61 = 0u;
  __int128 v60 = 0u;
  __int128 v59 = 0u;
  __int128 v58 = 0u;
  __int128 v57 = 0u;
  __int128 v56 = 0u;
  __int128 v55 = 0u;
  __int128 v54 = 0u;
  __int128 v53 = 0u;
  __int128 v52 = 0u;
  __int128 v51 = 0u;
  __int128 v50 = 0u;
  __int128 v49 = 0u;
  __int128 v48 = 0u;
  uint64_t v67 = 0LL;
  unint64_t v68 = 0xFFEFFFFFFFFFFFFFLL;
  __int128 v69 = 0u;
  __int128 v70 = 0u;
  __int128 v71 = 0u;
  __int128 v72 = 0u;
  unint64_t v73 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v74 = 0LL;
  int v75 = 0;
  uint64_t v76 = 0LL;
  char v77 = 0;
  unint64_t v78 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v80 = 0LL;
  uint64_t v79 = 0LL;
  uint64_t v81 = 0x80000000800000LL;
  uint64_t v83 = 0LL;
  uint64_t v82 = 0LL;
  __int128 v84 = xmmword_1012E1EA0;
  uint64_t v85 = 0x80000000800000LL;
  __int128 v86 = 0u;
  __int128 v87 = 0u;
  uint64_t v88 = 0LL;
  unint64_t v89 = 0xFFEFFFFFFFFFFFFFLL;
  __int128 v90 = 0u;
  __int128 v91 = 0u;
  __int128 v92 = 0u;
  __int128 v93 = 0u;
  __int128 v94 = 0u;
  __int128 v95 = 0u;
  int v96 = 0;
  unint64_t v97 = 0xFFEFFFFFFFFFFFFFLL;
  __int16 v98 = 0;
  int v99 = 0;
  unint64_t v100 = 0xFFEFFFFFFFFFFFFFLL;
  uint64_t v101 = 7LL;
  unint64_t v102 = 0xFFEFFFFFFFFFFFFFLL;
  char v103 = 0;
  uint64_t v105 = 0LL;
  uint64_t v104 = 0LL;
  uint64_t v106 = 0LL;
  if (*(double *)&v53 > 0.0)
  {
    unint64_t v5 = *(void *)(a1 + 8) + 1LL;
    *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = v5;
    if (v5 >= 0x24)
    {
      *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
      return 2LL;
    }

    return 0LL;
  }

  uint64_t result = 0LL;
  *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  return result;
}

void sub_1002C7288(_Unwind_Exception *a1)
{
}

void *sub_1002C72A8(void *a1, const void *a2, unint64_t a3)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a3)
  {
    sub_10001B7A4(a1, a3);
    __int128 v6 = (char *)a1[1];
    memmove(v6, a2, 4 * a3);
    a1[1] = &v6[4 * a3];
  }

  return a1;
}

void sub_1002C730C(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::iostream::~basic_iostream(v2, v3 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1002C7328(uint64_t a1)
{
  unint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + std::iostream::~basic_iostream(v2, v3 + 8) = v2;
    operator delete(v2);
  }

  return a1;
}

double sub_1002C7358(uint64_t a1, void *a2)
{
  uint64_t v2 = sub_100DA9558(a1, a2);
  *(void *)uint64_t v2 = off_10182F918;
  *(_BYTE *)(v2 + 20std::iostream::~basic_iostream(v2, v3 + 8) = 0;
  double result = 0.0;
  *(_OWORD *)(v2 + 216) = 0u;
  *(_OWORD *)(v2 + 2sub_10000AE14(v13 - 32) = 0u;
  *(void *)(v2 + 24std::iostream::~basic_iostream(v2, v3 + 8) = 0LL;
  return result;
}

uint64_t sub_1002C738C(id *a1)
{
  *a1 = off_10182F918;
  sub_1002C73C0(a1);
  return sub_100DAA148((uint64_t)a1);
}

void sub_1002C73C0(id *a1)
{
  a1[28] = 0LL;
  [a1[29] invalidate];

  a1[29] = 0LL;
  [a1[30] invalidate];

  a1[30] = 0LL;
  [a1[31] invalidate];

  a1[31] = 0LL;
}

void sub_1002C7430(id *a1)
{
  uint64_t v1 = (void *)sub_1002C738C(a1);
  operator delete(v1);
}

void sub_1002C7444(uint64_t a1, void *a2)
{
  if (a2 && [a2 length])
  {
    [a2 getBytes:buf length:40];
    if (!*(_DWORD *)buf)
    {
      __int128 v6 = v10;
      __int128 v7 = v11;
      int v8 = v12;
      uuid_copy((unsigned __int8 *)&v7 + 4, (const unsigned __int8 *)&v11 + 4);
      if (*((void *)&v6 + 1))
      {
        if (*(void *)(a1 + 117) != *((void *)&v6 + 1)) {
          sub_100DAA21C(a1, &v6);
        }
        sub_1002C7810(a1);
      }

      else
      {
        sub_1002C7668(a1);
      }
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10182FA40);
    }
    unsigned __int8 v4 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "MotionStateObserver, Invalid data received.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10182FA40);
      }
      LOWORD(v6) = 0;
      unint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "MotionStateObserver, Invalid data received.",  &v6,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLMotionStateObserverCompanion::receiveMotionStateUpdate(NSData *)",  "%s\n",  v5);
    }
  }