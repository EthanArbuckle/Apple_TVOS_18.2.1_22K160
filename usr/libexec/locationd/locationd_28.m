void sub_100E02728( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  uint64_t v30;
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  sub_1011C52D0(v30 - 80);
  _Unwind_Resume(a1);
}

uint64_t sub_100E0277C(uint64_t a1, std::string::value_type *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  else {
    size_t v5 = *(void *)(a1 + 48);
  }
  v6 = &v42;
  sub_1000392EC((uint64_t)&v42, v5 + 1);
  if ((v42.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    v6 = (std::string *)v42.__r_.__value_.__r.__words[0];
  }
  if (v5)
  {
    v9 = *(char **)(a1 + 40);
    v8 = (char *)(a1 + 40);
    v7 = v9;
    if (v8[23] >= 0) {
      v10 = v8;
    }
    else {
      v10 = v7;
    }
    memmove(v6, v10, v5);
  }

  *(_WORD *)((char *)&v6->__r_.__value_.__l.__data_ + v5) = 47;
  v11 = std::string::append(&v42, a2);
  __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  int64_t cap = v11->__r_.__value_.__l.__cap_;
  __int128 v43 = v12;
  v11->__r_.__value_.__l.__size_ = 0LL;
  v11->__r_.__value_.__l.__cap_ = 0LL;
  v11->__r_.__value_.__r.__words[0] = 0LL;
  sub_100E65BA8((uint64_t)&v40);
  v13 = std::string::append(&v40, "/");
  __int128 v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__l.__cap_ = v13->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0LL;
  v13->__r_.__value_.__l.__cap_ = 0LL;
  v13->__r_.__value_.__r.__words[0] = 0LL;
  v15 = std::string::append(&v41, a2);
  __int128 v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__l.__cap_ = v15->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0LL;
  v15->__r_.__value_.__l.__cap_ = 0LL;
  v15->__r_.__value_.__r.__words[0] = 0LL;
  sub_1010DDBC0(&v41, a2);
  else {
    std::string __dst = *(std::string *)(v4 + 88);
  }
  v17 = std::string::append(&__dst, "_");
  __int128 v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v40.__r_.__value_.__l.__cap_ = v17->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0LL;
  v17->__r_.__value_.__l.__cap_ = 0LL;
  v17->__r_.__value_.__r.__words[0] = 0LL;
  if (sub_100E6641C(v4, &v41.__r_.__value_.__l.__data_, (char *)&v40))
  {
    sub_1010DDBC0(v37, a2);
    else {
      std::string v34 = *(std::string *)(v4 + 112);
    }
    v20 = std::string::append(&v34, ".bz2");
    __int128 v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    std::string::size_type v36 = v20->__r_.__value_.__l.__cap_;
    *(_OWORD *)v35 = v21;
    v20->__r_.__value_.__l.__size_ = 0LL;
    v20->__r_.__value_.__l.__cap_ = 0LL;
    v20->__r_.__value_.__r.__words[0] = 0LL;
    if ((sub_100E664F0(v4, v37, (char *)v35) & 1) != 0)
    {
      int v19 = 1;
    }

    else
    {
      sub_1010DDBC0(__p, a2);
      int v19 = sub_100E664F0(v4, __p, (char *)(v4 + 112));
      if (v33 < 0) {
        operator delete(__p[0]);
      }
    }

    if (SHIBYTE(v36) < 0) {
      operator delete(v35[0]);
    }
    if (v38 < 0) {
      operator delete(v37[0]);
    }
  }

  else
  {
    int v19 = 0;
  }

  if ((char)v41.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(v41.__r_.__value_.__l.__data_);
    if (!v19) {
      goto LABEL_56;
    }
  }

  else if (!v19)
  {
    goto LABEL_56;
  }

  if (cap >= 0) {
    v22 = (const char *)&v43;
  }
  else {
    v22 = (const char *)v43;
  }
  if ((v42.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    v23 = &v42;
  }
  else {
    v23 = (std::string *)v42.__r_.__value_.__r.__words[0];
  }
  if (!sub_100292D88(v22, (const char *)v23))
  {
    int v24 = SHIBYTE(cap);
    v25 = (const char *)v43;
    int size = (char)v42.__r_.__value_.__s.__size_;
    std::string::size_type v27 = v42.__r_.__value_.__r.__words[0];
    v28 = __error();
    v29 = &v42;
    if (size < 0) {
      v29 = (std::string *)v27;
    }
    if (v24 >= 0) {
      v30 = (const char *)&v43;
    }
    else {
      v30 = v25;
    }
    syslog(5, "%s,%s,Failed to move file %s to %s (%d)\n", "NOTICE", "CLLog", v30, (const char *)v29, *v28);
  }

void sub_100E02B08( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, void *__p, uint64_t a34, int a35, __int16 a36, char a37, char a38, void *a39, uint64_t a40, int a41, __int16 a42, char a43, char a44, uint64_t a45, void *a46, uint64_t a47, int a48, __int16 a49, char a50,char a51)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a51 < 0) {
    operator delete(a46);
  }
  if (a44 < 0) {
    operator delete(a39);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E02C14()
{
}

void sub_100E02C1C()
{
}

void sub_100E02C30(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

void sub_100E02C5C(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

__n128 sub_100E02C88(uint64_t a1, uint64_t a2)
{
  __int128 v2 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v2;
  __int128 v3 = *(_OWORD *)(a2 + 32);
  __int128 v4 = *(_OWORD *)(a2 + 48);
  __int128 v5 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v5;
  *(_OWORD *)(a1 + 32) = v3;
  *(_OWORD *)(a1 + 48) = v4;
  __n128 result = *(__n128 *)(a2 + 96);
  __int128 v7 = *(_OWORD *)(a2 + 112);
  __int128 v8 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 140) = *(_OWORD *)(a2 + 140);
  *(_OWORD *)(a1 + 112) = v7;
  *(_OWORD *)(a1 + 128) = v8;
  *(__n128 *)(a1 + 96) = result;
  return result;
}

uint64_t sub_100E02CBC(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100869780(a1);
  if ((_DWORD)result)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 96);
    BOOL v6 = v5 > 0xB;
    int v7 = (1 << v5) & 0xC02;
    BOOL v8 = v6 || v7 == 0;
    if (v8 || *(double *)(a1 + 20) > 30.0)
    {
      return 0LL;
    }

    else
    {
      uint64_t result = sub_100869780(a2);
      if ((_DWORD)result) {
        return vabdd_f64(*(double *)(a1 + 76), *(double *)(a2 + 76)) <= 1.25;
      }
    }
  }

  return result;
}

uint64_t sub_100E02D40(uint64_t a1, uint64_t a2)
{
  return sub_100D2EC74(*(double *)(a2 + 4), *(double *)(a2 + 12), *(double *)(a1 + 4), *(double *)(a1 + 12));
}

__n128 sub_100E02D54@<Q0>(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  __int128 v2 = *(_OWORD *)(a1 + 112);
  a2[6] = *(_OWORD *)(a1 + 96);
  a2[7] = v2;
  a2[8] = *(_OWORD *)(a1 + 128);
  *(_OWORD *)((char *)a2 + 140) = *(_OWORD *)(a1 + 140);
  __int128 v3 = *(_OWORD *)(a1 + 48);
  a2[2] = *(_OWORD *)(a1 + 32);
  a2[3] = v3;
  __int128 v4 = *(_OWORD *)(a1 + 80);
  a2[4] = *(_OWORD *)(a1 + 64);
  a2[5] = v4;
  __n128 result = *(__n128 *)a1;
  __int128 v6 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v6;
  return result;
}

uint64_t sub_100E02D88()
{
  else {
    return 2LL;
  }
}

float sub_100E02DAC(int a1)
{
  if (a1 > 2104)
  {
    if (a1 > 12149)
    {
      switch(a1)
      {
        case 17150:
          return 5.97;
        case 15110:
          return 6.95;
        case 12150:
          return 9.33;
      }
    }

    else
    {
      switch(a1)
      {
        case 2105:
          return 3.71;
        case 2150:
          return 4.6;
        case 3015:
          return 5.87;
      }
    }
  }

  else if (a1 > 2023)
  {
    switch(a1)
    {
      case 2024:
        return 5.13;
      case 2071:
        return 5.91;
      case 2101:
        return 6.07;
    }
  }

  else
  {
    switch(a1)
    {
      case 2010:
        return 6.35;
      case 2020:
        return 7.55;
      case 2022:
        return 5.38;
    }
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884878);
  }
  __int128 v3 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 67109120;
    int v8 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Unexpected activity type passed to lookup model, %d",  buf,  8u);
  }

  BOOL v4 = sub_1002921D0(115, 0);
  float result = 4.4021;
  if (v4)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884878);
    }
    v6[0] = 67109120;
    v6[1] = a1;
    unsigned int v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "Unexpected activity type passed to lookup model, %d",  v6);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "float CLCalorieUtils::lookupMetsForActivity(const CLMotionActivity::Type)",  "%s\n",  v5);
    return 4.4021;
  }

  return result;
}

void sub_100E0307C(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

void *sub_100E030A8(void *a1, void *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1018848A8;
  a1[3] = a2;
  return a1;
}

void sub_100E030F0(_Unwind_Exception *a1)
{
  void *v1 = &off_1018633E8;
  sub_10000AE14(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100E03118(uint64_t a1)
{
  *(void *)a1 = off_1018848A8;

  *(void *)a1 = &off_1018633E8;
  sub_10000AE14(a1 + 8);
  return a1;
}

void sub_100E0316C(uint64_t a1)
{
  v1 = (void *)sub_100E03118(a1);
  operator delete(v1);
}

uint64_t sub_100E03180(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = [*(id *)(a1 + 24) length];
  __int128 v6 = [[PBDataReader alloc] initWithData:a2];
  if (*(void *)&v6[OBJC_IVAR___PBDataReader__pos] < *(void *)&v6[OBJC_IVAR___PBDataReader__length]
    && !v6[OBJC_IVAR___PBDataReader__error])
  {
    char v9 = 0;
    unsigned int v10 = 0;
    unint64_t v11 = 0LL;
    while (1)
    {
      uint64_t v12 = *(void *)&v6[OBJC_IVAR___PBDataReader__pos];
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)&v6[OBJC_IVAR___PBDataReader__length]) {
        break;
      }
      char v21 = *(_BYTE *)(*(void *)&v6[OBJC_IVAR___PBDataReader__bytes] + v12);
      *(void *)&v6[OBJC_IVAR___PBDataReader__pos] = v13;
      v11 |= (unint64_t)(v21 & 0x7F) << v9;
      if ((v21 & 0x80) == 0) {
        goto LABEL_9;
      }
      v9 += 7;
      if (v10++ >= 9)
      {
        unint64_t v16 = 0LL;
        uint64_t v14 = OBJC_IVAR___PBDataReader__error;
        int v15 = v6[OBJC_IVAR___PBDataReader__error];
LABEL_12:
        if (v15) {
          BOOL v17 = 1;
        }
        else {
          BOOL v17 = (v16 & 7) == 4;
        }
        if (v17) {
          return 0LL;
        }
        uint64_t v7 = (unsigned __int16)(v16 >> 3);
        if ((_DWORD)v7 != 1) {
          return v7;
        }
        unint64_t v19 = *(void *)&v6[OBJC_IVAR___PBDataReader__pos];
        if (v19 > 0xFFFFFFFFFFFFFFF7LL || v19 + 8 > *(void *)&v6[OBJC_IVAR___PBDataReader__length])
        {
          v6[v14] = 1;
          uint64_t v20 = 0LL;
          if (!a3) {
            goto LABEL_25;
          }
LABEL_24:
          *a3 = v20;
          goto LABEL_25;
        }

        uint64_t v20 = *(void *)(*(void *)&v6[OBJC_IVAR___PBDataReader__bytes] + v19);
        *(void *)&v6[OBJC_IVAR___PBDataReader__pos] = v19 + 8;
        if (a3) {
          goto LABEL_24;
        }
LABEL_25:
        if (*(void *)&v6[OBJC_IVAR___PBDataReader__pos] >= *(void *)&v6[OBJC_IVAR___PBDataReader__length]) {
          return 1LL;
        }
        char v9 = 0;
        unsigned int v10 = 0;
        unint64_t v11 = 0LL;
        if (v6[OBJC_IVAR___PBDataReader__error]) {
          return 1LL;
        }
      }
    }

    v6[OBJC_IVAR___PBDataReader__error] = 1;
LABEL_9:
    uint64_t v14 = OBJC_IVAR___PBDataReader__error;
    int v15 = v6[OBJC_IVAR___PBDataReader__error];
    if (v6[OBJC_IVAR___PBDataReader__error]) {
      unint64_t v16 = 0LL;
    }
    else {
      unint64_t v16 = v11;
    }
    goto LABEL_12;
  }

  return 0LL;
}

uint64_t sub_100E03360(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = sub_100E03180(a1, a2, 0LL);
  uint64_t v4 = sub_100E03540(a1, v3);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_1018848D8);
  }
  id v5 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67109376;
    int v13 = v4;
    __int16 v14 = 1024;
    unsigned int v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "tagEnabled returns %d for tag %d", buf, 0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018848D8);
    }
    v9[0] = 67109376;
    v9[1] = v4;
    __int16 v10 = 1024;
    unsigned int v11 = v3;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "tagEnabled returns %d for tag %d",  v9,  14);
    int v8 = (uint8_t *)v7;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual BOOL CLActivityLoggerMsgPolicy::shouldILog(NSData *)", "%s\n", v7);
    if (v8 != buf) {
      free(v8);
    }
  }

  return v4;
}

uint64_t sub_100E03540(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = (unsigned __int8 *)[*(id *)(a1 + 24) bytes];
  id v5 = [*(id *)(a1 + 24) length];
  if (a2 == 1) {
    return 1LL;
  }
  return (v4[(unint64_t)a2 >> 3] >> (~(_BYTE)a2 & 7)) & 1;
}

void sub_100E035B8(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_100E035E4(uint64_t a1)
{
  uint64_t v11 = a1 + 54460;
  uint64_t v10 = a1 + 53412;
  uint64_t v2 = a1 + 52352;
  uint64_t v3 = a1 + 51300;
  uint64_t v4 = a1 + 50252;
  uint64_t v5 = a1 + 49192;
  uint64_t v6 = a1 + 48140;
  uint64_t v7 = a1 + 47092;
  uint64_t v8 = a1 + 46032;
  *(_OWORD *)(a1 + 688) = xmmword_10135F1A0;
  *(void *)(a1 + 3776) = 0x10000000000LL;
  *(void *)(a1 + 6856) = 0x10000000000LL;
  *(void *)(a1 + 9936) = 0x10000000000LL;
  *(void *)(a1 + 13016) = 0x10000000000LL;
  *(void *)(a1 + 16096) = 0x10000000000LL;
  *(void *)(a1 + 19176) = 0x8000000000LL;
  sub_1005CACB8(a1 + 19696, &off_1018848F8);
  sub_1005CACB8(a1 + 19760, &off_1018848F8);
  sub_1005CACB8(a1 + 19824, &off_1018848F8);
  sub_1005CACB8(a1 + 19888, &off_101884910);
  sub_1005CACB8(a1 + 19952, &off_101884910);
  sub_1005CACB8(a1 + 20016, &off_101884910);
  sub_1005CACB8(a1 + 20080, &off_1018848F8);
  sub_1005CACB8(a1 + 20144, &off_1018848F8);
  sub_1005CACB8(a1 + 20208, &off_1018848F8);
  sub_1005CACB8(a1 + 20272, &off_1018848F8);
  sub_1005CACB8(a1 + 20336, &off_1018848F8);
  sub_1005CACB8(a1 + 20400, &off_1018848F8);
  sub_1005CACB8(a1 + 20464, &off_1018848F8);
  sub_1005CACB8(a1 + 20528, &off_1018848F8);
  sub_1005CACB8(a1 + 20592, &off_1018848F8);
  sub_1005CACB8(a1 + 20656, &off_1018848F8);
  sub_1005CACB8(a1 + 20720, &off_1018848F8);
  sub_1005CACB8(a1 + 20784, &off_1018848F8);
  sub_1005CACB8(a1 + 20848, &off_1018848F8);
  sub_1005CACB8(a1 + 20912, &off_1018848F8);
  sub_1005CACB8(a1 + 20976, &off_1018848F8);
  sub_1005CACB8(a1 + 21040, &off_101884928);
  sub_1005CACB8(a1 + 21104, &off_101884928);
  sub_1005CACB8(a1 + 21168, &off_101884928);
  sub_1005CACB8(a1 + 21232, &off_101884940);
  sub_1005CACB8(a1 + 21296, &off_101884940);
  sub_1005CACB8(a1 + 21360, &off_101884940);
  *(void *)(a1 + 21424) = 0x20000000000LL;
  *(void *)(a1 + 27576) = 0x20000000000LL;
  *(void *)(a1 + 33728) = 0x20000000000LL;
  *(void *)(a1 + 39880) = 0x20000000000LL;
  *(void *)uint64_t v8 = 0LL;
  *(_DWORD *)(v8 + 8) = 100;
  *(_BYTE *)(v8 + 12) = 1;
  *(void *)(v8 + 28) = 0x10000000000LL;
  *(_DWORD *)(v8 + 24) = 1031798784;
  *(_BYTE *)uint64_t v7 = 1;
  *(void *)(v7 + 16) = 0x10000000000LL;
  *(_DWORD *)(v7 + 12) = 1031798784;
  *(_BYTE *)uint64_t v6 = 1;
  *(void *)(v6 + 16) = 0x10000000000LL;
  *(_DWORD *)(v6 + 12) = 1031798784;
  *(void *)uint64_t v5 = 0LL;
  *(_DWORD *)(v5 + 8) = 50;
  *(_BYTE *)(v5 + 12) = 1;
  *(void *)(v5 + 28) = 0x10000000000LL;
  *(_DWORD *)(v5 + 24) = 1031798784;
  *(_BYTE *)uint64_t v4 = 1;
  *(void *)(v4 + 16) = 0x10000000000LL;
  *(_DWORD *)(v4 + 12) = 1031798784;
  *(_BYTE *)uint64_t v3 = 1;
  *(void *)(v3 + 16) = 0x10000000000LL;
  *(_DWORD *)(v3 + 12) = 1031798784;
  *(void *)uint64_t v2 = 0LL;
  *(_DWORD *)(v2 + 8) = 25;
  *(_BYTE *)(v2 + 12) = 1;
  *(void *)(v2 + 28) = 0x10000000000LL;
  *(_DWORD *)(v2 + 24) = 1031798784;
  *(_BYTE *)uint64_t v10 = 1;
  *(void *)(v10 + 16) = 0x10000000000LL;
  *(_DWORD *)(v10 + 12) = 1031798784;
  *(_BYTE *)uint64_t v11 = 1;
  *(void *)(v11 + 16) = 0x10000000000LL;
  *(_DWORD *)(v11 + 12) = 1031798784;
  nullsub_10(a1 + 61656);
  *(_DWORD *)(a1 + 696) = 0;
  *(_DWORD *)(a1 + 3776) = 0;
  *(_DWORD *)(a1 + 6856) = 0;
  *(_DWORD *)(a1 + 9936) = 0;
  *(_DWORD *)(a1 + 13016) = 0;
  *(_DWORD *)(a1 + 16096) = 0;
  *(_DWORD *)(a1 + 21424) = 0;
  *(_DWORD *)(a1 + 27576) = 0;
  *(void *)(a1 + 688) = 0LL;
  *(_DWORD *)(a1 + 33728) = 0;
  *(_DWORD *)(a1 + 39880) = 0;
  sub_100E03A04(a1);
  return a1;
}

float sub_100E03998(uint64_t a1, float *a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  float v9 = v8;
  sub_1005CACBC(a4, a2[1]);
  sub_1005CACBC(a5, a2[2]);
  return v9;
}

uint64_t sub_100E03A04(uint64_t a1)
{
  uint64_t v2 = a1 + 21040;
  uint64_t v3 = 3LL;
  do
  {
    sub_1005CACAC(v2);
    uint64_t result = sub_1005CACAC(v2 + 192);
    v2 += 64LL;
    --v3;
  }

  while (v3);
  return result;
}

uint64_t sub_100E03B44( uint64_t a1, float32x2_t *a2, float *a3, float32x2_t *a4, float *a5, float *a6, float *a7)
{
  float v14 = a2[1].f32[0] + a4[1].f32[0];
  float32x2_t v62 = vadd_f32(*a2, *a4);
  float v63 = v14;
  uint64_t v15 = sub_100CB0908(a1 + 46032, &v62);
  v61[0] = sub_100E03998( v15,  (float *)a2,  (unsigned __int16 *)(a1 + 19696),  (unsigned __int16 *)(a1 + 19760),  (unsigned __int16 *)(a1 + 19824));
  v61[1] = v16;
  v61[2] = v17;
  v60[0] = sub_100E03998( v18,  a3,  (unsigned __int16 *)(a1 + 20272),  (unsigned __int16 *)(a1 + 20336),  (unsigned __int16 *)(a1 + 20400));
  v60[1] = v19;
  v60[2] = v20;
  v59[0] = sub_100E03998( v21,  (float *)a4,  (unsigned __int16 *)(a1 + 20080),  (unsigned __int16 *)(a1 + 20144),  (unsigned __int16 *)(a1 + 20208));
  v59[1] = v22;
  v59[2] = v23;
  v58[0] = sub_100E03998( v24,  a5,  (unsigned __int16 *)(a1 + 20464),  (unsigned __int16 *)(a1 + 20528),  (unsigned __int16 *)(a1 + 20592));
  v58[1] = v25;
  v58[2] = v26;
  v57[0] = sub_100E03998( v27,  a6,  (unsigned __int16 *)(a1 + 20656),  (unsigned __int16 *)(a1 + 20720),  (unsigned __int16 *)(a1 + 20784));
  v57[1] = v28;
  v57[2] = v29;
  v56[0] = sub_100E03998( v30,  a7,  (unsigned __int16 *)(a1 + 20848),  (unsigned __int16 *)(a1 + 20912),  (unsigned __int16 *)(a1 + 20976));
  v56[1] = v31;
  v56[2] = v32;
  v55[0] = sub_100E03998( v33,  (float *)&v62,  (unsigned __int16 *)(a1 + 19888),  (unsigned __int16 *)(a1 + 19952),  (unsigned __int16 *)(a1 + 20016));
  v55[1] = v34;
  v55[2] = v35;
  int v36 = *(_DWORD *)(a1 + 688) + 1;
  *(_DWORD *)(a1 + 688) = v36;
  if ((v36 & 1) != 0) {
    return 0LL;
  }
  v37 = (unsigned __int16 *)(a1 + 16098);
  sub_10040B364((unsigned __int16 *)(a1 + 696), (uint64_t)v61);
  sub_10040B364((unsigned __int16 *)(a1 + 3776), (uint64_t)v60);
  sub_10040B364((unsigned __int16 *)(a1 + 6856), (uint64_t)v59);
  sub_10040B364((unsigned __int16 *)(a1 + 9936), (uint64_t)v58);
  sub_10040B364((unsigned __int16 *)(a1 + 13016), (uint64_t)v57);
  sub_10040B364((unsigned __int16 *)(a1 + 16096), (uint64_t)v56);
  sub_100CB0908(a1 + 49192, v55);
  ++*(_DWORD *)(a1 + 692);
  if ((*(_BYTE *)(a1 + 688) & 3) == 0) {
    sub_100CB0908(a1 + 52352, v55);
  }
  unint64_t v38 = *v37;
  if (*(_DWORD *)(a1 + 16100) != (_DWORD)v38) {
    goto LABEL_27;
  }
  v39 = (_WORD *)(a1 + 19176);
  unint64_t v40 = v38 >> 1;
  if ((v38 >> 1) >= v38)
  {
    float v49 = -INFINITY;
    goto LABEL_19;
  }

  float v41 = 0.0;
  float v42 = 3.4028e38;
  float v43 = -3.4028e38;
  float v44 = 0.0;
  do
  {
    float v45 = v44;
    v46 = (float *)sub_10040B624((unsigned __int16 *)(a1 + 16096), v40);
    float v44 = atan2f(v46[1], *v46) * 57.296;
    float v47 = v44 - v45;
    if ((float)(v44 - v45) <= 180.0)
    {
      if (v47 >= -180.0) {
        goto LABEL_12;
      }
      float v48 = 360.0;
    }

    else
    {
      float v48 = -360.0;
    }

    float v47 = v47 + v48;
LABEL_12:
    float v41 = v41 + v47;
    if (v42 > v41) {
      float v42 = v41;
    }
    if (v43 < v41) {
      float v43 = v41;
    }
    ++v40;
  }

  while (v40 < *v37);
  float v49 = v43 - v42;
LABEL_19:
  uint64_t v50 = *(unsigned __int16 *)(a1 + 19178);
  unint64_t v51 = *(unsigned int *)(a1 + 19180);
  uint64_t v52 = (unsigned __int16)*v39;
  if (v52 + v50 >= v51) {
    uint64_t v53 = *(unsigned int *)(a1 + 19180);
  }
  else {
    uint64_t v53 = 0LL;
  }
  *(float *)(a1 + 4 * (v52 + v50 - v53) + 19184) = v49;
  if (v51 <= v50)
  {
    if (v52 + 1 < v51) {
      LOWORD(v51) = 0;
    }
    _WORD *v39 = v52 + 1 - v51;
  }

  else
  {
    *(_WORD *)(a1 + 19178) = v50 + 1;
  }

float sub_100E03F3C(uint64_t a1)
{
  uint64_t v2 = (unsigned __int16 *)(a1 + 19176);
  sub_100E040C0(a1);
  sub_100E05D64(a1);
  sub_100E06644(a1, v3);
  sub_100E06924(a1);
  sub_100AC4E30(a1 + 57048, a1 + 57560, a1 + 58072, a1 + 55512, a1 + 56024, a1 + 56536, (float *)v17);
  __int128 v4 = v17[1];
  *(_OWORD *)(a1 + 84) = v17[0];
  *(_OWORD *)(a1 + 100) = v4;
  *(_DWORD *)(a1 + 116) = v18;
  *(void *)&__int128 v5 = v19;
  *((void *)&v5 + 1) = *(void *)v21;
  *(_OWORD *)(a1 + 120) = v5;
  *(void *)&__int128 v5 = v20;
  *((void *)&v5 + 1) = *(void *)&v21[12];
  *(_DWORD *)(a1 + 136) = *(_DWORD *)&v21[8];
  *(_OWORD *)(a1 + 140) = v5;
  *(_OWORD *)(a1 + 156) = v22;
  *(_DWORD *)(a1 + 172) = v23;
  sub_100E07598(a1);
  uint64_t v6 = v2[1];
  unint64_t v7 = *v2 + v6 - 1;
  unint64_t v8 = *((unsigned int *)v2 + 1);
  if (v7 < v8) {
    unint64_t v8 = 0LL;
  }
  *(_DWORD *)(a1 + 680) = *(_DWORD *)&v2[2 * (v7 - v8) + 4];
  if (!v6) {
    goto LABEL_8;
  }
  float v9 = 0.0;
  unint64_t v10 = -1LL;
  float v11 = 0.0;
  do
  {
    unint64_t v12 = v10++;
    int v13 = (float *)sub_100208A44(v2, v10);
    float v14 = *v13 - v11;
    float v11 = v11 + (float)(v14 / (float)(v12 + 2));
    float v9 = v9 + (float)(v14 * (float)(*v13 - v11));
  }

  while (v12 + 2 < v2[1]);
  if (v10) {
    float v15 = v9 / (float)v10;
  }
  else {
LABEL_8:
  }
    float v15 = 0.0;
  float result = sqrtf(v15);
  *(float *)(a1 + 684) = result;
  return result;
}

void sub_100E040C0(uint64_t a1)
{
  unint64_t v1 = 0LL;
  unint64_t v2 = 0LL;
  unint64_t v3 = 0LL;
  unint64_t v4 = 0LL;
  unint64_t v5 = 0LL;
  unint64_t v6 = 0LL;
  unint64_t v7 = 0LL;
  unint64_t v8 = 0LL;
  unint64_t v9 = 0LL;
  unint64_t v10 = 0LL;
  unint64_t v11 = 0LL;
  unint64_t v12 = 0LL;
  unint64_t v13 = 0LL;
  unsigned __int16 v346 = 0;
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  int v18 = 0;
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  v272 = (float32x4_t *)(a1 + 55512);
  *(void *)v405 = 0x10000000000LL;
  *(void *)v404 = 0x10000000000LL;
  *(void *)v403 = 0x10000000000LL;
  *(void *)v402 = 0x10000000000LL;
  *(void *)v401 = 0x10000000000LL;
  *(void *)v400 = 0x10000000000LL;
  *(void *)v399 = 0x10000000000LL;
  *(void *)v398 = 0x10000000000LL;
  *(void *)v397 = 0x10000000000LL;
  *(void *)v396 = 0x10000000000LL;
  *(void *)v395 = 0x10000000000LL;
  *(void *)v394 = 0x10000000000LL;
  v281 = (unsigned __int16 *)(a1 + 6856);
  v271 = (float *)(a1 + 412);
  v285 = (unsigned __int16 *)(a1 + 696);
  v283 = (unsigned __int16 *)(a1 + 3776);
  do
  {
    unint64_t v287 = v3;
    uint64_t v289 = v24;
    uint64_t v291 = v23;
    uint64_t v294 = v22;
    uint64_t v298 = v21;
    uint64_t v302 = v20;
    uint64_t v306 = v19;
    uint64_t v312 = v17;
    uint64_t v315 = v16;
    uint64_t v317 = v15;
    unint64_t v321 = v4;
    uint64_t v25 = v14;
    unint64_t v325 = v5;
    unint64_t v331 = v6;
    unint64_t v334 = v7;
    unint64_t v337 = v8;
    unint64_t v340 = v10;
    unint64_t v26 = v11;
    unint64_t v343 = v9;
    unint64_t v27 = v2;
    unint64_t v28 = v1;
    unint64_t v29 = v12;
    unint64_t v30 = v13;
    int v31 = (float *)sub_10040B624(v285, v13);
    int v32 = (float *)sub_10040B624(v281, v30);
    unint64_t v328 = v30;
    uint64_t v33 = (_DWORD *)sub_10040B624(v283, v30);
    unint64_t v12 = v29;
    float v34 = v31[1];
    float v35 = v31[2];
    float v36 = v32[1];
    float v37 = v32[2];
    unint64_t v38 = v29 + v346;
    if (v38 >= 0x100) {
      uint64_t v39 = -256LL;
    }
    else {
      uint64_t v39 = 0LL;
    }
    *(float *)&v405[2 * v39 + 4 + 2 * v38] = *v31 + *v32;
    if (v29 > 0xFF)
    {
      if (v346 >= 0xFFu) {
        __int16 v40 = -256;
      }
      else {
        __int16 v40 = 0;
      }
      v346 += v40 + 1;
      v405[0] = v346;
    }

    else
    {
      unint64_t v12 = v29 + 1;
      v405[1] = v29 + 1;
    }

    unint64_t v11 = v26;
    uint64_t v14 = v25;
    float v41 = v34 + v36;
    unint64_t v42 = v26 + (unsigned __int16)v25;
    if (v42 >= 0x100) {
      uint64_t v43 = -256LL;
    }
    else {
      uint64_t v43 = 0LL;
    }
    *(float *)&v404[2 * v43 + 4 + 2 * v42] = v41;
    BOOL v44 = v26 > 0xFF;
    unint64_t v1 = v28;
    unint64_t v2 = v27;
    unint64_t v3 = v287;
    unint64_t v4 = v321;
    unint64_t v5 = v325;
    unint64_t v6 = v331;
    unint64_t v7 = v334;
    unint64_t v8 = v337;
    unint64_t v10 = v340;
    unint64_t v9 = v343;
    uint64_t v17 = v312;
    uint64_t v16 = v315;
    uint64_t v19 = v306;
    uint64_t v20 = v302;
    if (v44)
    {
      else {
        int v45 = 0;
      }
      int v46 = v14 + v45;
      uint64_t v14 = (v46 + 1);
      v404[0] = v46 + 1;
    }

    else
    {
      v404[1] = ++v11;
    }

    uint64_t v15 = v317;
    uint64_t v23 = v291;
    uint64_t v22 = v294;
    float v47 = v35 + v37;
    unint64_t v48 = v340 + (unsigned __int16)v317;
    if (v48 >= 0x100) {
      uint64_t v49 = -256LL;
    }
    else {
      uint64_t v49 = 0LL;
    }
    *(float *)&v403[2 * v49 + 4 + 2 * v48] = v47;
    if (v340 > 0xFF)
    {
      else {
        int v50 = 0;
      }
      int v51 = v317 + v50;
      uint64_t v15 = (v51 + 1);
      v403[0] = v51 + 1;
    }

    else
    {
      unint64_t v10 = v340 + 1;
      v403[1] = v340 + 1;
    }

    unint64_t v52 = v343 + (unsigned __int16)v315;
    if (v52 >= 0x100) {
      uint64_t v53 = -256LL;
    }
    else {
      uint64_t v53 = 0LL;
    }
    *(_DWORD *)&v402[2 * v53 + 4 + 2 * v52] = *v33;
    if (v343 > 0xFF)
    {
      else {
        int v54 = 0;
      }
      int v55 = v315 + v54;
      uint64_t v16 = (v55 + 1);
      v402[0] = v55 + 1;
    }

    else
    {
      unint64_t v9 = v343 + 1;
      v402[1] = v343 + 1;
    }

    unint64_t v56 = v337 + (unsigned __int16)v312;
    if (v56 >= 0x100) {
      uint64_t v57 = -256LL;
    }
    else {
      uint64_t v57 = 0LL;
    }
    *(_DWORD *)&v401[2 * v57 + 4 + 2 * v56] = v33[1];
    if (v337 > 0xFF)
    {
      else {
        int v58 = 0;
      }
      int v59 = v312 + v58;
      uint64_t v17 = (v59 + 1);
      v401[0] = v59 + 1;
    }

    else
    {
      unint64_t v8 = v337 + 1;
      v401[1] = v337 + 1;
    }

    unint64_t v60 = v334 + (unsigned __int16)v18;
    if (v60 >= 0x100) {
      uint64_t v61 = -256LL;
    }
    else {
      uint64_t v61 = 0LL;
    }
    *(_DWORD *)&v400[2 * v61 + 4 + 2 * v60] = v33[2];
    if (v334 > 0xFF)
    {
      else {
        int v62 = 0;
      }
      int v63 = v18 + v62;
      int v18 = v63 + 1;
      v400[0] = v63 + 1;
    }

    else
    {
      unint64_t v7 = v334 + 1;
      v400[1] = v334 + 1;
    }

    unint64_t v64 = v331 + (unsigned __int16)v306;
    if (v64 >= 0x100) {
      uint64_t v65 = -256LL;
    }
    else {
      uint64_t v65 = 0LL;
    }
    *(float *)&v399[2 * v65 + 4 + 2 * v64] = *v31;
    if (v331 > 0xFF)
    {
      else {
        int v66 = 0;
      }
      int v67 = v306 + v66;
      uint64_t v19 = (v67 + 1);
      v399[0] = v67 + 1;
    }

    else
    {
      unint64_t v6 = v331 + 1;
      v399[1] = v331 + 1;
    }

    unint64_t v68 = v325 + (unsigned __int16)v302;
    if (v68 >= 0x100) {
      uint64_t v69 = -256LL;
    }
    else {
      uint64_t v69 = 0LL;
    }
    *(float *)&v398[2 * v69 + 4 + 2 * v68] = v31[1];
    if (v325 > 0xFF)
    {
      else {
        int v70 = 0;
      }
      int v71 = v302 + v70;
      uint64_t v20 = (v71 + 1);
      v398[0] = v71 + 1;
    }

    else
    {
      unint64_t v5 = v325 + 1;
      v398[1] = v325 + 1;
    }

    int v72 = *((_DWORD *)v31 + 2);
    uint64_t v21 = v298;
    unint64_t v73 = v321 + (unsigned __int16)v298;
    if (v73 >= 0x100) {
      uint64_t v74 = -256LL;
    }
    else {
      uint64_t v74 = 0LL;
    }
    *(_DWORD *)&v397[2 * v74 + 4 + 2 * v73] = v72;
    if (v321 > 0xFF)
    {
      else {
        int v75 = 0;
      }
      int v76 = v298 + v75;
      uint64_t v21 = (v76 + 1);
      v397[0] = v76 + 1;
    }

    else
    {
      unint64_t v4 = v321 + 1;
      v397[1] = v321 + 1;
    }

    unint64_t v77 = v287 + (unsigned __int16)v294;
    if (v77 >= 0x100) {
      uint64_t v78 = -256LL;
    }
    else {
      uint64_t v78 = 0LL;
    }
    *(float *)&v396[2 * v78 + 4 + 2 * v77] = *v32;
    if (v287 > 0xFF)
    {
      else {
        int v79 = 0;
      }
      int v80 = v294 + v79;
      uint64_t v22 = (v80 + 1);
      v396[0] = v80 + 1;
    }

    else
    {
      unint64_t v3 = v287 + 1;
      v396[1] = v287 + 1;
    }

    unint64_t v81 = v2 + (unsigned __int16)v291;
    if (v81 >= 0x100) {
      uint64_t v82 = -256LL;
    }
    else {
      uint64_t v82 = 0LL;
    }
    *(float *)&v395[2 * v82 + 4 + 2 * v81] = v32[1];
    if (v2 > 0xFF)
    {
      else {
        int v83 = 0;
      }
      int v84 = v291 + v83;
      uint64_t v23 = (v84 + 1);
      v395[0] = v84 + 1;
    }

    else
    {
      v395[1] = ++v2;
    }

    int v85 = *((_DWORD *)v32 + 2);
    uint64_t v24 = v289;
    unint64_t v86 = v1 + (unsigned __int16)v289;
    if (v86 >= 0x100) {
      uint64_t v87 = -256LL;
    }
    else {
      uint64_t v87 = 0LL;
    }
    *(_DWORD *)&v394[2 * v87 + 4 + 2 * v86] = v85;
    if (v1 > 0xFF)
    {
      else {
        int v88 = 0;
      }
      int v89 = v289 + v88;
      uint64_t v24 = (v89 + 1);
      v394[0] = v89 + 1;
    }

    else
    {
      v394[1] = ++v1;
    }

    unint64_t v13 = v328 + 1;
  }

  while (v328 != 255);
  *(void *)v393 = 0x10000000000LL;
  *(void *)v392 = 0x10000000000LL;
  *(void *)v391 = 0x10000000000LL;
  *(void *)v390 = 0x10000000000LL;
  *(void *)v389 = 0x10000000000LL;
  *(void *)v388 = 0x10000000000LL;
  *(void *)v387 = 0x10000000000LL;
  *(void *)v386 = 0x10000000000LL;
  *(void *)v385 = 0x10000000000LL;
  sub_100E0790C(v396, v393);
  sub_100E0790C(v395, v392);
  sub_100E0790C(v394, v391);
  sub_100E0790C(v399, v390);
  sub_100E0790C(v398, v389);
  sub_100E0790C(v397, v388);
  sub_100E0790C(v402, v387);
  sub_100E0790C(v401, v386);
  sub_100E0790C(v400, v385);
  v368[1] = 0LL;
  v368[0] = 0LL;
  int v369 = 0;
  uint64_t v371 = 0LL;
  uint64_t v370 = 0LL;
  int v372 = 0;
  uint64_t v373 = 0LL;
  uint64_t v367 = 0LL;
  *((void *)&v90 + 1) = 0LL;
  memset(v366, 0, 44);
  uint64_t v365 = 0LL;
  memset(v364, 0, 44);
  uint64_t v363 = 0LL;
  memset(v362, 0, 44);
  v360 = 0LL;
  __p = 0LL;
  v361 = 0LL;
  v357 = 0LL;
  v356 = 0LL;
  v358 = 0LL;
  v354 = 0LL;
  v353 = 0LL;
  v355 = 0LL;
  v351 = 0LL;
  v350 = 0LL;
  v352 = 0LL;
  uint64_t v91 = *(unsigned __int16 *)(a1 + 698);
  if (*(_WORD *)(a1 + 698))
  {
    unint64_t v92 = 0LL;
    *(void *)&__int128 v90 = 0x8000007F7FFFFFLL;
    __int128 v322 = v90;
    float v318 = 0.0;
    float v316 = 0.0;
    float v290 = 0.0;
    float v93 = 0.0;
    float v94 = 3.4028e38;
    float v303 = 0.0;
    float v95 = 1.1755e-38;
    float v96 = 0.0;
    float v299 = 0.0;
    float v97 = 0.0;
    float v295 = 0.0;
    float v98 = 0.0;
    float v332 = 3.4028e38;
    float v292 = 0.0;
    float v99 = 0.0;
    float v335 = 3.4028e38;
    float v329 = 3.4028e38;
    float v326 = 1.1755e-38;
    float v307 = 1.1755e-38;
    float v338 = 1.1755e-38;
    float v341 = 3.4028e38;
    float v347 = 1.1755e-38;
    float v344 = 3.4028e38;
    float v100 = 0.0;
    float v308 = 0.0;
    do
    {
      unint64_t v101 = v92;
      v102 = (float *)sub_10040B624(v285, v92);
      float v313 = v93;
      v103 = (float *)sub_10040B624(v283, v92);
      uint64_t v104 = sub_10040B624(v281, v92);
      v105 = (float *)v104;
      float v106 = *(float *)(v104 + 8);
      if (v94 > v106) {
        float v94 = *(float *)(v104 + 8);
      }
      if (v95 < v106) {
        float v95 = *(float *)(v104 + 8);
      }
      float v107 = *v103;
      sub_1005B19F8((uint64_t)v366, fabsf(*v102), fabsf(v103[1]));
      sub_1005B19F8((uint64_t)v364, *v102, v102[1]);
      sub_1005B19F8((uint64_t)v362, *v102, v103[2]);
      uint64_t v108 = 0LL;
      float v308 = v308 + (float)(v107 * v107);
      ++v92;
      float v109 = 0.0;
      do
      {
        float v109 = v109 + (float)(v103[v108] * v103[v108]);
        ++v108;
      }

      while (v108 != 3);
      sub_100DAD990((float *)v368, fabsf(*v102), fabsf(v103[1]), sqrtf(v109));
      float v110 = v103[2];
      float v111 = v344;
      if (v344 > v110) {
        float v111 = v103[2];
      }
      float v344 = v111;
      float v112 = v347;
      if (v347 < v110) {
        float v112 = v103[2];
      }
      float v347 = v112;
      float v113 = v105[2];
      float v114 = v341;
      if (v341 > v113) {
        float v114 = v105[2];
      }
      float v341 = v114;
      float v115 = v338;
      if (v338 < v113) {
        float v115 = v105[2];
      }
      float v338 = v115;
      float v116 = v105[1];
      float v117 = fabsf(*v105);
      float v118 = v307;
      if (v307 < v117) {
        float v118 = v117;
      }
      float v307 = v118;
      float v119 = v329;
      if (v329 > v116) {
        float v119 = v105[1];
      }
      float v329 = v119;
      float v120 = v326;
      if (v326 < v116) {
        float v120 = v105[1];
      }
      float v326 = v120;
      int v121 = *((_DWORD *)v102 + 1);
      float v122 = v335;
      if (v335 > *v102) {
        float v122 = *v102;
      }
      float v335 = v122;
      int8x8_t v288 = *(int8x8_t *)v103;
      float v123 = v332;
      if (v332 > *v105) {
        float v123 = *v105;
      }
      float v332 = v123;
      v124 = v360;
      if (v360 >= v361)
      {
        v126 = (char *)__p;
        uint64_t v127 = (v360 - (_BYTE *)__p) >> 2;
        unint64_t v128 = v127 + 1;
        uint64_t v129 = v361 - (_BYTE *)__p;
        if ((v361 - (_BYTE *)__p) >> 1 > v128) {
          unint64_t v128 = v129 >> 1;
        }
        else {
          unint64_t v130 = v128;
        }
        if (v130)
        {
          v131 = (char *)sub_10000956C((uint64_t)&v361, v130);
          v124 = v360;
          v126 = (char *)__p;
        }

        else
        {
          v131 = 0LL;
        }

        v132 = &v131[4 * v127];
        *(_DWORD *)v132 = v121;
        v125 = v132 + 4;
        while (v124 != v126)
        {
          int v133 = *((_DWORD *)v124 - 1);
          v124 -= 4;
          *((_DWORD *)v132 - 1) = v133;
          v132 -= 4;
        }

        __p = v132;
        v360 = v125;
        v361 = &v131[4 * v130];
        if (v126) {
          operator delete(v126);
        }
      }

      else
      {
        *(_DWORD *)v360 = v121;
        v125 = v124 + 4;
      }

      v360 = v125;
      int v134 = *((_DWORD *)v103 + 2);
      v135 = v357;
      if (v357 >= v358)
      {
        v137 = (char *)v356;
        uint64_t v138 = (v357 - (_BYTE *)v356) >> 2;
        unint64_t v139 = v138 + 1;
        uint64_t v140 = v358 - (_BYTE *)v356;
        if ((v358 - (_BYTE *)v356) >> 1 > v139) {
          unint64_t v139 = v140 >> 1;
        }
        else {
          unint64_t v141 = v139;
        }
        if (v141)
        {
          v142 = (char *)sub_10000956C((uint64_t)&v358, v141);
          v135 = v357;
          v137 = (char *)v356;
        }

        else
        {
          v142 = 0LL;
        }

        v143 = &v142[4 * v138];
        *(_DWORD *)v143 = v134;
        v136 = v143 + 4;
        while (v135 != v137)
        {
          int v144 = *((_DWORD *)v135 - 1);
          v135 -= 4;
          *((_DWORD *)v143 - 1) = v144;
          v143 -= 4;
        }

        v356 = v143;
        v357 = v136;
        v358 = &v142[4 * v141];
        if (v137) {
          operator delete(v137);
        }
      }

      else
      {
        *(_DWORD *)v357 = v134;
        v136 = v135 + 4;
      }

      v357 = v136;
      int v145 = *((_DWORD *)v105 + 2);
      v146 = v354;
      if (v354 >= v355)
      {
        v148 = (char *)v353;
        uint64_t v149 = (v354 - (_BYTE *)v353) >> 2;
        unint64_t v150 = v149 + 1;
        uint64_t v151 = v355 - (_BYTE *)v353;
        if ((v355 - (_BYTE *)v353) >> 1 > v150) {
          unint64_t v150 = v151 >> 1;
        }
        else {
          unint64_t v152 = v150;
        }
        if (v152)
        {
          v153 = (char *)sub_10000956C((uint64_t)&v355, v152);
          v146 = v354;
          v148 = (char *)v353;
        }

        else
        {
          v153 = 0LL;
        }

        v154 = &v153[4 * v149];
        *(_DWORD *)v154 = v145;
        v147 = v154 + 4;
        while (v146 != v148)
        {
          int v155 = *((_DWORD *)v146 - 1);
          v146 -= 4;
          *((_DWORD *)v154 - 1) = v155;
          v154 -= 4;
        }

        v353 = v154;
        v354 = v147;
        v355 = &v153[4 * v152];
        if (v148) {
          operator delete(v148);
        }
      }

      else
      {
        *(_DWORD *)v354 = v145;
        v147 = v146 + 4;
      }

      v354 = v147;
      v156 = (_DWORD *)sub_100208A44(v387, v101);
      v157 = v156;
      v158 = v351;
      if (v351 >= v352)
      {
        v161 = (char *)v350;
        uint64_t v162 = (v351 - (_BYTE *)v350) >> 2;
        unint64_t v163 = v162 + 1;
        uint64_t v164 = v352 - (_BYTE *)v350;
        if ((v352 - (_BYTE *)v350) >> 1 > v163) {
          unint64_t v163 = v164 >> 1;
        }
        else {
          unint64_t v165 = v163;
        }
        if (v165)
        {
          v166 = (char *)sub_10000956C((uint64_t)&v352, v165);
          v158 = v351;
          v161 = (char *)v350;
        }

        else
        {
          v166 = 0LL;
        }

        v167 = &v166[4 * v162];
        *(_DWORD *)v167 = *v157;
        v159 = v167 + 4;
        if (v158 == v161)
        {
          float v160 = v313;
        }

        else
        {
          float v160 = v313;
          do
          {
            int v168 = *((_DWORD *)v158 - 1);
            v158 -= 4;
            *((_DWORD *)v167 - 1) = v168;
            v167 -= 4;
          }

          while (v158 != v161);
        }

        v350 = v167;
        v351 = v159;
        v352 = &v166[4 * v165];
        if (v161) {
          operator delete(v161);
        }
      }

      else
      {
        *(_DWORD *)v351 = *v156;
        v159 = v158 + 4;
        float v160 = v313;
      }

      *((void *)&v169 + 1) = *((void *)&v322 + 1);
      *(int8x8_t *)&__int128 v169 = vbsl_s8( (int8x8_t)vcgt_f32( (float32x2_t)__PAIR64__(v288.u32[1], v322),  (float32x2_t)__PAIR64__(DWORD1(v322), v288.u32[0])),  v288,  *(int8x8_t *)&v322);
      __int128 v322 = v169;
      float v100 = v100 + *(float *)v288.i32;
      v351 = v159;
      float v170 = v103[2];
      float v171 = v170 - v99;
      float v99 = v99 + (float)((float)(v170 - v99) / (float)v92);
      float v292 = v292 + (float)(v171 * (float)(v170 - v99));
      float v318 = v318 + (float)((float)(v170 * v170) + (float)((float)(*v103 * *v103) + (float)(v103[1] * v103[1])));
      float v172 = *v105 * *v105;
      float v173 = v105[2] * v105[2];
      float v316 = v316 + (float)((float)(v172 + (float)(v105[1] * v105[1])) + v173);
      float v290 = v290 + v173;
      float v93 = v160 + v172;
      float v174 = v102[1];
      float v175 = *v102 - v98;
      float v98 = v98 + (float)(v175 / (float)v92);
      float v295 = v295 + (float)(v175 * (float)(*v102 - v98));
      float v176 = v174 - v97;
      float v97 = v97 + (float)((float)(v174 - v97) / (float)v92);
      float v299 = v299 + (float)(v176 * (float)(v174 - v97));
      float v177 = v102[2];
      float v178 = v177 - v96;
      float v96 = v96 + (float)((float)(v177 - v96) / (float)v92);
      float v303 = v303 + (float)(v178 * (float)(v177 - v96));
    }

    while (v92 != v91);
  }

  else
  {
    *(void *)&__int128 v322 = 0x8000007F7FFFFFLL;
    float v308 = 0.0;
    float v95 = 1.1755e-38;
    float v94 = 3.4028e38;
    float v100 = 0.0;
    float v341 = 3.4028e38;
    float v338 = 1.1755e-38;
    float v307 = 1.1755e-38;
    float v292 = 0.0;
    float v295 = 0.0;
    float v326 = 1.1755e-38;
    float v329 = 3.4028e38;
    float v335 = 3.4028e38;
    float v332 = 3.4028e38;
    float v299 = 0.0;
    float v303 = 0.0;
    float v344 = 3.4028e38;
    float v347 = 1.1755e-38;
    float v93 = 0.0;
    float v290 = 0.0;
    float v316 = 0.0;
    float v318 = 0.0;
  }

  v179 = v272;
  *(float *)a1 = sub_100DADA18((uint64_t)v368);
  *(float *)(a1 + 4) = sub_1005B1C24((uint64_t)v366);
  if ((_DWORD)v91)
  {
    *(float *)(a1 + 20) = sqrtf(v308 / (float)v91);
    *(float *)(a1 + 8) = v95 - v94;
    *(void *)(a1 + 12) = v322;
    float v180 = v100 / (float)v91;
  }

  else
  {
    *(_DWORD *)(a1 + 20) = 0;
    *(float *)(a1 + 8) = v95 - v94;
    *(void *)(a1 + 12) = v322;
    float v180 = 0.0;
  }

  *(float *)(a1 + 24) = v180;
  sub_100E079E4((float **)&__p, 0);
  *(_DWORD *)(a1 + 328) = v181;
  *(float *)(a1 + 348) = v347 - v344;
  float v182 = sub_10079239C((uint64_t)&v350, 50);
  *(float *)(a1 + 176) = (float)(int)sub_100E07A70(v387, v182);
  *(float *)(a1 + 352) = v338 - v341;
  *(float *)(a1 + 356) = v335;
  sub_100E07B08((uint64_t)v400);
  *(_DWORD *)(a1 + 228) = v183;
  sub_100E07B08((uint64_t)v393);
  *(_DWORD *)(a1 + 188) = v184;
  sub_100E07BDC((uint64_t)v399);
  *(_DWORD *)(a1 + 252) = v185;
  *(float *)(a1 + 180) = (float)(int)sub_100E07A70(v386, 0.0);
  *(float *)(a1 + 248) = sub_10079239C((uint64_t)&v356, 10);
  *(float *)(a1 + 244) = sub_10079239C((uint64_t)&v353, 90);
  float v186 = sub_10079239C((uint64_t)&v356, 90);
  *(float *)(a1 + 236) = v347 - v344;
  *(float *)(a1 + 240) = v186;
  *(float *)(a1 + 232) = v326 - v329;
  float v187 = 0.0;
  *(float *)(a1 + 256) = sqrtf(v187);
  *(float *)(a1 + 332) = v332;
  *(float *)(a1 + 336) = sub_10079239C((uint64_t)&v353, 50);
  *(float *)(a1 + 340) = v318;
  *(float *)(a1 + 392) = sub_1005B1C24((uint64_t)v364);
  *(float *)(a1 + 396) = sub_1005B1C24((uint64_t)v362);
  if (v91 < 2)
  {
    float v188 = 0.0;
    float v189 = 1.1755e-38;
LABEL_218:
    if (v189 == v188) {
      float v192 = 1.0;
    }
    else {
      float v192 = 2.0;
    }
    goto LABEL_221;
  }

  float v190 = v295 / (float)v91;
  float v191 = fmaxf(v190, 1.1755e-38);
  float v188 = v299 / (float)v91;
  if (v191 < v188) {
    float v191 = v299 / (float)v91;
  }
  float v189 = v303 / (float)v91;
  if (v191 >= v189) {
    float v189 = v191;
  }
  float v192 = 0.0;
  if (v189 != v190) {
    goto LABEL_218;
  }
LABEL_221:
  *(float *)(a1 + 372) = v192;
  sub_100FBFFE8(v349);
  sub_100FBFFEC((uint64_t)v349, v272, v405);
  sub_100FBFFEC((uint64_t)v349, (_DWORD *)(a1 + 56024), v404);
  sub_100FBFFEC((uint64_t)v349, (_DWORD *)(a1 + 56536), v403);
  v193 = v272 + 96;
  sub_100FBFFEC((uint64_t)v349, (float32x4_t *)v272[96].i32, v402);
  uint64_t v348 = a1 + 57560;
  sub_100FBFFEC((uint64_t)v349, (_DWORD *)(a1 + 57560), v401);
  uint64_t v194 = a1 + 58072;
  sub_100FBFFEC((uint64_t)v349, (_DWORD *)(a1 + 58072), v400);
  uint64_t v195 = (uint64_t)&v272[192];
  sub_100FBFFEC((uint64_t)v349, (float32x4_t *)v272[192].i32, v399);
  uint64_t v196 = a1 + 59096;
  sub_100FBFFEC((uint64_t)v349, (_DWORD *)(a1 + 59096), v398);
  uint64_t v345 = a1 + 59608;
  sub_100FBFFEC((uint64_t)v349, (_DWORD *)(a1 + 59608), v397);
  uint64_t v197 = (uint64_t)&v272[288];
  sub_100FBFFEC((uint64_t)v349, (float32x4_t *)v272[288].i32, v396);
  sub_100FBFFEC((uint64_t)v349, (_DWORD *)(a1 + 60632), v395);
  sub_100FBFFEC((uint64_t)v349, (_DWORD *)(a1 + 61144), v394);
  sub_100FBFFEC((uint64_t)v349, v384, v393);
  sub_100FBFFEC((uint64_t)v349, v383, v392);
  sub_100FBFFEC((uint64_t)v349, v382, v391);
  sub_100FBFFEC((uint64_t)v349, v381, v390);
  sub_100FBFFEC((uint64_t)v349, v380, v389);
  sub_100FBFFEC((uint64_t)v349, v379, v388);
  sub_100FBFFEC((uint64_t)v349, v378, v387);
  sub_100FBFFEC((uint64_t)v349, v377, v386);
  sub_100FBFFEC((uint64_t)v349, v376, v385);
  for (uint64_t i = 0LL; i != 128; i += 4LL)
  {
    *(float32x4_t *)&v375[i + 128] = vsqrtq_f32( vaddq_f32( vaddq_f32(vmulq_f32(*v179, *v179), vmulq_f32(v179[32], v179[32])),  vmulq_f32(v179[64], v179[64])));
    ++v179;
  }

  uint64_t v199 = 0LL;
  v200 = v272 + 192;
  do
  {
    *(float32x4_t *)&v375[v199] = vsqrtq_f32( vaddq_f32( vaddq_f32(vmulq_f32(*v200, *v200), vmulq_f32(v200[32], v200[32])),  vmulq_f32(v200[64], v200[64])));
    ++v200;
    v199 += 4LL;
  }

  while (v199 != 128);
  uint64_t v201 = 0LL;
  v202 = v272 + 288;
  do
  {
    *(float32x4_t *)&v374[v201 + 128] = vsqrtq_f32( vaddq_f32( vaddq_f32(vmulq_f32(*v202, *v202), vmulq_f32(v202[32], v202[32])),  vmulq_f32(v202[64], v202[64])));
    ++v202;
    v201 += 4LL;
  }

  while (v201 != 128);
  for (uint64_t j = 0LL; j != 128; j += 4LL)
  {
    *(float32x4_t *)&v374[j] = vsqrtq_f32( vaddq_f32( vaddq_f32(vmulq_f32(*v193, *v193), vmulq_f32(v193[32], v193[32])),  vmulq_f32(v193[64], v193[64])));
    ++v193;
  }

  uint64_t v204 = 0LL;
  float v205 = 0.0;
  int v206 = -1;
  float v207 = 0.0;
  do
  {
    float v208 = v375[v204 + 128];
    float v207 = v207 + v208;
    if (v208 > v205)
    {
      float v205 = v375[v204 + 128];
      int v206 = v204;
    }

    ++v204;
  }

  while (v204 != 128);
  float v336 = v207;
  uint64_t v209 = 0LL;
  float v210 = 0.0;
  int v211 = -1;
  do
  {
    if (*(float *)(v195 + 4 * v209) > v210)
    {
      float v210 = *(float *)(v195 + 4 * v209);
      int v211 = v209;
    }

    ++v209;
  }

  while (v209 != 128);
  float v286 = v210;
  unsigned int v293 = v91;
  uint64_t v212 = 0LL;
  float v213 = 0.0;
  int v214 = -1;
  do
  {
    if (*(float *)(v196 + 4 * v212) > v213)
    {
      float v213 = *(float *)(v196 + 4 * v212);
      int v214 = v212;
    }

    ++v212;
  }

  while (v212 != 128);
  uint64_t v342 = a1 + 59096;
  float v314 = v93;
  uint64_t v215 = 0LL;
  float v216 = 0.0;
  int v217 = -1;
  do
  {
    if (*(float *)(v345 + 4 * v215) > v216)
    {
      float v216 = *(float *)(v345 + 4 * v215);
      int v217 = v215;
    }

    ++v215;
  }

  while (v215 != 128);
  uint64_t v218 = 0LL;
  float v219 = 0.0;
  int v220 = -1;
  do
  {
    if (*(float *)&v384[v218] > v219)
    {
      float v219 = *(float *)&v384[v218];
      int v220 = v218;
    }

    ++v218;
  }

  while (v218 != 128);
  uint64_t v221 = 0LL;
  float v222 = 0.0;
  do
  {
    ++v221;
  }

  while (v221 != 128);
  uint64_t v223 = 0LL;
  float v224 = 0.0;
  do
  {
    ++v223;
  }

  while (v223 != 128);
  uint64_t v225 = 0LL;
  float v226 = 0.0;
  do
  {
    ++v225;
  }

  while (v225 != 128);
  uint64_t v227 = 0LL;
  float v228 = 0.0;
  do
  {
    ++v227;
  }

  while (v227 != 128);
  uint64_t v229 = 0LL;
  float v230 = 0.0;
  do
  {
    ++v229;
  }

  while (v229 != 128);
  uint64_t v231 = 0LL;
  float v232 = 0.0;
  do
  {
    ++v231;
  }

  while (v231 != 128);
  int v333 = sub_100E07D9C((uint64_t)v380, 2.0, 0.25);
  unint64_t v233 = sub_100E07D9C((uint64_t)v377, 6.0, 2.0);
  unint64_t v323 = sub_100E07D9C((uint64_t)v376, 6.0, 1.0);
  uint64_t v234 = 0LL;
  float v235 = 0.0;
  int v236 = -1;
  do
  {
    if (v374[v234 + 128] > v235)
    {
      float v235 = v374[v234 + 128];
      int v236 = v234;
    }

    ++v234;
  }

  while (v234 != 128);
  unint64_t v330 = HIDWORD(v233);
  unint64_t v327 = sub_100E07D9C(v194, 2.0, 0.25);
  unint64_t v309 = sub_100E07D9C(v197, 2.0, 0.25);
  unint64_t v319 = sub_100E07D9C(a1 + 60632, 2.0, 0.5);
  uint64_t v237 = 0LL;
  float v238 = 0.0;
  int v239 = -1;
  do
  {
    if (*(float *)(v197 + 4 * v237) > v238)
    {
      float v238 = *(float *)(v197 + 4 * v237);
      int v239 = v237;
    }

    ++v237;
  }

  while (v237 != 128);
  unint64_t v339 = HIDWORD(v309);
  unint64_t v324 = HIDWORD(v323);
  int v284 = sub_100E07D9C(v195, 2.0, 0.25);
  unint64_t v304 = sub_100E07D9C(v342, 4.0, 1.0);
  unint64_t v282 = sub_100E07D9C(v342, 6.0, 1.0);
  unint64_t v300 = sub_100E07D9C(v195, 6.0, 1.0);
  unint64_t v310 = sub_100E07D9C(v348, 2.0, 0.25);
  unint64_t v296 = sub_100E07D9C(v348, 6.0, 2.0);
  unint64_t v280 = sub_100E07D9C(v194, 6.0, 2.0);
  uint64_t v240 = 0LL;
  float v241 = 0.0;
  int v242 = -1;
  do
  {
    if (*(float *)(v194 + 4 * v240) > v241)
    {
      float v241 = *(float *)(v194 + 4 * v240);
      int v242 = v240;
    }

    ++v240;
  }

  while (v240 != 128);
  uint64_t v243 = 0LL;
  unint64_t v297 = HIDWORD(v296);
  unint64_t v301 = HIDWORD(v300);
  float v244 = 0.0;
  unint64_t v305 = HIDWORD(v304);
  int v245 = -1;
  unint64_t v320 = HIDWORD(v319);
  do
  {
    if (v375[v243] > v244)
    {
      float v244 = v375[v243];
      int v245 = v243;
    }

    ++v243;
  }

  while (v243 != 128);
  unint64_t v311 = HIDWORD(v310);
  unint64_t v277 = sub_100E07D9C((uint64_t)v375, 4.0, 2.0);
  int v279 = sub_100E07D9C((uint64_t)v375, 4.0, 1.0);
  int v278 = sub_100E07D9C((uint64_t)v375, 6.0, 1.0);
  unint64_t v276 = sub_100E07D9C((uint64_t)v374, 2.0, 0.25);
  unint64_t v275 = sub_100E07D9C((uint64_t)v374, 2.0, 0.5);
  unint64_t v274 = sub_100E07D9C((uint64_t)v374, 6.0, 2.0);
  uint64_t v246 = 0LL;
  float v247 = 0.0;
  int v248 = -1;
  do
  {
    if (*(float *)(v348 + 4 * v246) > v247)
    {
      float v247 = *(float *)(v348 + 4 * v246);
      int v248 = v246;
    }

    ++v246;
  }

  while (v246 != 128);
  float v249 = *(float *)&dword_10199EB88 * (float)v206;
  *(float *)(a1 + 28) = v205;
  *(float *)(a1 + 32) = v249;
  *(float *)(a1 + 36) = v336 * 0.0078125;
  *(float *)(a1 + 184) = v219;
  if (v222 <= v224) {
    float v250 = v224;
  }
  else {
    float v250 = v222;
  }
  if (v250 <= v226) {
    float v250 = v226;
  }
  *(float *)(a1 + 192) = v250;
  *(_DWORD *)(a1 + 196) = v333;
  *(float *)(a1 + 200) = (float)(int)v330;
  *(float *)(a1 + 204) = (float)(int)v324;
  *(float *)(a1 + 208) = (float)v236;
  *(float *)(a1 + 216) = (float)SHIDWORD(v327);
  *(float *)(a1 + 220) = (float)(int)v339;
  float v251 = sub_1009AF760(50, 0x80uLL, 0.4);
  float v252 = sub_1009AF760(50, 0x80uLL, 4.3);
  int v253 = (int)v251;
  int v254 = (int)v252;
  float v255 = 0.0;
  float v256 = 0.0;
  if ((int)v251 < v254)
  {
    uint64_t v257 = v254 - (uint64_t)v253;
    v258 = (float *)(a1 + 4LL * v253 + 60120);
    do
    {
      float v256 = (float)((float)(v256 + *v258) + v258[128]) + v258[256];
      ++v258;
      --v257;
    }

    while (v257);
  }

  *(float *)(a1 + 212) = v256;
  *(float *)(a1 + 224) = (float)(int)v320;
  *(float *)(a1 + 260) = (float)v211;
  *(float *)(a1 + 264) = v286;
  *(_DWORD *)(a1 + 268) = v284;
  *(float *)(a1 + 272) = (float)(int)v305;
  *(float *)(a1 + 276) = (float)SHIDWORD(v282);
  *(float *)(a1 + 280) = (float)(int)v311;
  *(float *)(a1 + 284) = (float)v242;
  *(float *)(a1 + 288) = (float)v245;
  *(float *)(a1 + 292) = (float)SHIDWORD(v277);
  *(_DWORD *)(a1 + 296) = v279;
  *(float *)(a1 + 304) = (float)SHIDWORD(v276);
  *(float *)(a1 + 308) = (float)SHIDWORD(v275);
  *(_DWORD *)(a1 + 300) = v278;
  *(float *)(a1 + 312) = (float)v248;
  *(float *)(a1 + 316) = (float)v220;
  *(float *)(a1 + 320) = (float)(v222 + v224) + v226;
  *(float *)(a1 + 324) = (float)(v228 + v230) + v232;
  *(float *)(a1 + 344) = (float)(int)v301;
  float v259 = (float)v214;
  *(float *)(a1 + 360) = (float)v214;
  *(float *)(a1 + 364) = (float)(int)v297;
  *(float *)(a1 + 368) = (float)SHIDWORD(v280);
  *(float *)(a1 + 384) = (float)SHIDWORD(v274);
  *(float *)(a1 + 388) = (float)v239;
  float v260 = (float)(v374[0] + 0.0) + v374[1];
  uint64_t v261 = 2LL;
  *(float *)(a1 + 400) = v260;
  do
    float v255 = v255 + v374[v261++];
  while (v261 != 15);
  *(float *)(a1 + 404) = v255;
  float v262 = 0.0;
  for (uint64_t k = 46LL; k != 128; ++k)
    float v262 = v262 + v374[k];
  float v264 = fabsf(v262);
  float v265 = v260 / v262;
  if (v264 <= 0.0000011921) {
    float v265 = -1.0;
  }
  *(float *)(a1 + 408) = v265;
  float v266 = *(float *)(a1 + 372);
  if (v266 != 1.0) {
    float v259 = (float)v217;
  }
  uint64_t v267 = a1 + 59608;
  if (v266 == 1.0) {
    uint64_t v267 = a1 + 59096;
  }
  BOOL v268 = v266 == 0.0;
  if (v266 == 0.0) {
    float v269 = (float)v211;
  }
  else {
    float v269 = v259;
  }
  if (v268) {
    uint64_t v270 = (uint64_t)&v272[192];
  }
  else {
    uint64_t v270 = v267;
  }
  *(float *)(a1 + 376) = v269;
  *(float *)(a1 + 380) = (float)(int)(sub_100E07D9C(v270, 4.0, 2.0) >> 32);
  *(void *)v271 = 0LL;
  if (fabsf(v316) > 0.0000011921) {
    float *v271 = v290 / v316;
  }
  if (v293 && fabsf(v314) > 0.0000011921) {
    *(float *)(a1 + 416) = v307 / sqrtf(v314 / (float)v293);
  }
  if (v350)
  {
    v351 = (char *)v350;
    operator delete(v350);
  }

  if (v353)
  {
    v354 = (char *)v353;
    operator delete(v353);
  }

  if (v356)
  {
    v357 = (char *)v356;
    operator delete(v356);
  }

  if (__p)
  {
    v360 = (char *)__p;
    operator delete(__p);
  }

void sub_100E05CDC(_Unwind_Exception *a1)
{
  unint64_t v2 = (void *)STACK[0x9E0];
  if (STACK[0x9E0])
  {
    STACK[0x9E8] = (unint64_t)v2;
    operator delete(v2);
  }

  unint64_t v3 = (void *)STACK[0x9F8];
  if (STACK[0x9F8])
  {
    STACK[0xA00] = (unint64_t)v3;
    operator delete(v3);
  }

  unint64_t v4 = (void *)STACK[0xA10];
  if (STACK[0xA10])
  {
    STACK[0xA18] = (unint64_t)v4;
    operator delete(v4);
  }

  unint64_t v5 = (void *)STACK[0xA28];
  if (STACK[0xA28])
  {
    STACK[0xA30] = (unint64_t)v5;
    operator delete(v5);
  }

  _Unwind_Resume(a1);
}

void sub_100E05D64(uint64_t a1)
{
  unint64_t v1 = 0LL;
  int v79 = (_WORD *)(a1 + 13018);
  v109[0] = 0x10000000000LL;
  v108[0] = 0x10000000000LL;
  v107[0] = 0x10000000000LL;
  do
  {
    unint64_t v2 = (_DWORD *)sub_10040B624((unsigned __int16 *)(a1 + 696), v1);
    unsigned int v3 = WORD1(v109[0]);
    unint64_t v4 = HIDWORD(v109[0]);
    uint64_t v5 = LOWORD(v109[0]);
    else {
      uint64_t v6 = 0LL;
    }
    *((_DWORD *)&v109[1] + LOWORD(v109[0]) + (unint64_t)WORD1(v109[0]) - v6) = *v2;
    if (v4 <= v3)
    {
      if (v5 + 1 < v4) {
        LOWORD(v4) = 0;
      }
      LOWORD(v109[0]) = v5 + 1 - v4;
    }

    else
    {
      WORD1(v109[0]) = v3 + 1;
    }

    unsigned int v7 = WORD1(v108[0]);
    unint64_t v8 = HIDWORD(v108[0]);
    uint64_t v9 = LOWORD(v108[0]);
    else {
      uint64_t v10 = 0LL;
    }
    *((_DWORD *)&v108[1] + LOWORD(v108[0]) + (unint64_t)WORD1(v108[0]) - v10) = v2[1];
    if (v8 <= v7)
    {
      if (v9 + 1 < v8) {
        LOWORD(v8) = 0;
      }
      LOWORD(v108[0]) = v9 + 1 - v8;
    }

    else
    {
      WORD1(v108[0]) = v7 + 1;
    }

    unsigned int v11 = WORD1(v107[0]);
    unint64_t v12 = HIDWORD(v107[0]);
    uint64_t v13 = LOWORD(v107[0]);
    else {
      uint64_t v14 = 0LL;
    }
    *((_DWORD *)&v107[1] + LOWORD(v107[0]) + (unint64_t)WORD1(v107[0]) - v14) = v2[2];
    if (v12 <= v11)
    {
      if (v13 + 1 < v12) {
        LOWORD(v12) = 0;
      }
      LOWORD(v107[0]) = v13 + 1 - v12;
    }

    else
    {
      WORD1(v107[0]) = v11 + 1;
    }

    ++v1;
  }

  while (v1 != 256);
  sub_100E07CA8(v106, (uint64_t)v93, (unsigned __int16 *)v109, 1);
  sub_100E07CA8(v105, (uint64_t)v93, (unsigned __int16 *)v108, 1);
  sub_100E07CA8(v104, (uint64_t)v93, (unsigned __int16 *)v107, 1);
  for (uint64_t i = 0LL; i != 128; i += 4LL)
    *(float32x4_t *)&v103[i * 4] = vaddq_f32( vaddq_f32(*(float32x4_t *)&v106[i], *(float32x4_t *)&v105[i]),  *(float32x4_t *)&v104[i]);
  if (!*(_WORD *)(a1 + 16098))
  {
    float v37 = (float *)a1;
    *(void *)(a1 + 40) = 0xFF7FFFFFBF800000LL;
    float v38 = 0.0;
    float v39 = NAN;
    goto LABEL_57;
  }

  unint64_t v16 = 0LL;
  int v17 = 0;
  float v18 = 0.0;
  float v19 = 3.4028e38;
  float v20 = 1.1755e-38;
  float v78 = 3.4028e38;
  float v21 = 0.0;
  float v75 = 0.0;
  float v76 = 0.0;
  float v77 = 1.1755e-38;
  float v22 = 0.0;
  do
  {
    uint64_t v23 = sub_10040B624((unsigned __int16 *)(a1 + 16096), v16);
    float v24 = *(float *)v23;
    float v25 = *(float *)(v23 + 4);
    float v26 = asinf(*(float *)(v23 + 8)) * 57.296;
    float v27 = v26 - v21;
    if ((float)(v26 - v21) <= 180.0)
    {
      if (v27 >= -180.0) {
        goto LABEL_36;
      }
      float v28 = 360.0;
    }

    else
    {
      float v28 = -360.0;
    }

    float v27 = v27 + v28;
LABEL_36:
    float v18 = v18 + v27;
    if (v19 > v18) {
      float v19 = v18;
    }
    if (v20 < v18) {
      float v20 = v18;
    }
    if (fabsf(v26) < 60.0)
    {
      float v29 = atan2f(v25, v24) * 57.296;
      float v30 = v29 - v75;
      if ((float)(v29 - v75) > 180.0)
      {
        float v31 = -360.0;
        goto LABEL_45;
      }

      if (v30 < -180.0)
      {
        float v31 = 360.0;
LABEL_45:
        float v30 = v30 + v31;
      }

      float v32 = v76 + v30;
      else {
        float v33 = v76 + v30;
      }
      float v34 = v77;
      float v75 = v29;
      float v76 = v32;
      if (v77 < v32) {
        float v34 = v32;
      }
      float v77 = v34;
      float v78 = v33;
      ++v17;
    }

    float v22 = v22 + v26;
    ++v16;
    unint64_t v35 = *(unsigned __int16 *)(a1 + 16098);
    float v21 = v26;
  }

  while (v16 < v35);
  float v36 = v77 - v78;
  if (v17 <= 0) {
    float v36 = -1.0;
  }
  float v37 = (float *)a1;
  *(float *)(a1 + 40) = v36;
  *(float *)(a1 + 44) = v20 - v19;
  float v38 = v22 / (float)v16;
  float v39 = (float)v17 / (float)v35;
LABEL_57:
  v37[12] = v38;
  v37[13] = 1.0 - v39;
  sub_100E07E08(&v89, &v91, v37 + 14, (uint64_t)v106);
  sub_100E07E08(&v92, &v91, &v90, (uint64_t)v105);
  sub_100E07E08(&v92, &v91, &v90, (uint64_t)v104);
  *(float *)&double v40 = sub_100E07E08(&v88, &v91, &v90, (uint64_t)v103);
  sub_100E07ECC((unsigned __int16 *)(a1 + 9936), v40);
  float v45 = v44;
  *(void *)v102 = 0x10000000000LL;
  *(void *)unint64_t v101 = 0x10000000000LL;
  *(void *)float v100 = 0x10000000000LL;
  *(void *)float v99 = 0x10000000000LL;
  if (*v79)
  {
    float v46 = v41;
    float v47 = v42;
    float v48 = v43;
    int v49 = 0;
    unint64_t v50 = 0LL;
    int v51 = 0;
    unint64_t v52 = 0LL;
    unint64_t v53 = 0LL;
    int v54 = (unsigned __int16 *)(a1 + 13016);
    do
    {
      int v55 = (float *)sub_10040B624(v54, v53);
      unint64_t v56 = v52 + (unsigned __int16)v51;
      if (v56 >= 0x100) {
        uint64_t v57 = -256LL;
      }
      else {
        uint64_t v57 = 0LL;
      }
      if (v52 > 0xFF)
      {
        else {
          int v58 = 0;
        }
        int v59 = v51 + v58;
        int v51 = v59 + 1;
        v102[0] = v59 + 1;
      }

      else
      {
        v102[1] = ++v52;
      }

      unint64_t v60 = (float *)sub_10040B624(v54, v53);
      unint64_t v61 = v50 + (unsigned __int16)v49;
      if (v61 >= 0x100) {
        uint64_t v62 = -256LL;
      }
      else {
        uint64_t v62 = 0LL;
      }
      if (v50 > 0xFF)
      {
        else {
          int v63 = 0;
        }
        int v64 = v49 + v63;
        int v49 = v64 + 1;
        v101[0] = v64 + 1;
      }

      else
      {
        v101[1] = ++v50;
      }

      uint64_t v65 = sub_10040B624(v54, v53);
      sub_1005CAE5C(v100, (_DWORD *)(v65 + 8));
      uint64_t v66 = sub_10040B624((unsigned __int16 *)(a1 + 9936), v53);
      sub_1005CAE5C(v99, (_DWORD *)(v66 + 8));
      ++v53;
    }

    while (v53 < (unsigned __int16)*v79);
  }

  sub_100E07CA8(v98, (uint64_t)v93, v102, 1);
  sub_100E07CA8(v97, (uint64_t)v93, v101, 1);
  sub_100E07CA8(v96, (uint64_t)v93, v100, 1);
  sub_100E07CA8(v95, (uint64_t)v93, v99, 1);
  sub_100E07E08(&v92, &v91, &v90, (uint64_t)v98);
  float v87 = 0.0;
  uint64_t v86 = 0LL;
  sub_100E07E08(&v87, (float *)&v86 + 1, (float *)&v86, (uint64_t)v97);
  uint64_t v85 = 0LL;
  int v84 = 0;
  sub_100E07E08((float *)&v85 + 1, (float *)&v85, (float *)&v84, (uint64_t)v98);
  float v83 = 0.0;
  uint64_t v82 = 0LL;
  sub_100E07E08(&v83, (float *)&v82 + 1, (float *)&v82, (uint64_t)v96);
  sub_100E07E08(&v92, &v91, &v90, (uint64_t)v96);
  float v81 = 0.0;
  sub_100E07E08(&v81, &v91, &v90, (uint64_t)v95);
  for (uint64_t j = 0LL; j != 128; j += 4LL)
    *(float32x4_t *)&v94[j * 4] = vaddq_f32( vaddq_f32(*(float32x4_t *)&v98[j], *(float32x4_t *)&v97[j]),  *(float32x4_t *)&v96[j]);
  float v80 = 0.0;
  sub_100E07E08(&v80, &v91, &v90, (uint64_t)v94);
  *(void *)(a1 + 468) = 0LL;
  *(void *)(a1 + 500) = 0LL;
  *(_DWORD *)(a1 + 508) = 0;
  *(void *)(a1 + 60) = 0LL;
  *(void *)(a1 + 76) = 0LL;
  *(void *)(a1 + 68) = 0LL;
  float v68 = v80;
  float v70 = *((float *)&v86 + 1);
  float v69 = v87;
  if (fabsf(v80) > 0.0000011921)
  {
    *(float *)(a1 + 60) = v88 / v80;
    *(float *)(a1 + 72) = v70 / v68;
    *(float *)(a1 + 468) = *((float *)&v82 + 1) / v68;
    *(float *)(a1 + 472) = *(float *)&v85 / v68;
    *(float *)(a1 + 504) = v69 / v68;
    *(float *)(a1 + 508) = v83 / v68;
    *(float *)(a1 + 500) = *((float *)&v85 + 1) / v68;
  }

  *(float *)(a1 + 452) = v68;
  if (fabsf(v69) > 0.0000011921)
  {
    *(float *)(a1 + 64) = v89 / v69;
    *(float *)(a1 + 68) = v70 / v69;
  }

  *(float *)(a1 + 456) = v69;
  *(float *)(a1 + 460) = v70;
  int v72 = HIDWORD(v85);
  float v71 = *(float *)&v86;
  *(_DWORD *)(a1 + 464) = v86;
  *(_DWORD *)(a1 + 476) = v72;
  *(_DWORD *)(a1 + 480) = v85;
  *(_DWORD *)(a1 + 484) = v84;
  *(float *)(a1 + 488) = v83;
  *(_DWORD *)(a1 + 492) = HIDWORD(v82);
  float v73 = *(float *)(a1 + 56);
  *(_DWORD *)(a1 + 496) = v82;
  if (fabsf(v73) > 0.0000011921) {
    *(float *)(a1 + 76) = v71 / v73;
  }
  if (fabsf(v88) > 0.0000011921) {
    *(float *)(a1 + 80) = v81 / v88;
  }
}

uint64_t sub_100E06644(uint64_t a1, double a2)
{
  unint64_t v2 = (unsigned __int16 *)(a1 + 39880);
  sub_100E07ECC((unsigned __int16 *)(a1 + 39880), a2);
  float v4 = v3;
  float v6 = v5;
  float v8 = v7;
  float v10 = v9;
  v46[0] = 0x20000000000LL;
  v45[0] = 0x20000000000LL;
  v44[0] = 0x20000000000LL;
  sub_1005CACB8(v43, &off_101884958);
  sub_1005CACB8(v42, &off_101884958);
  sub_1005CACB8(v41, &off_101884958);
  int v11 = 0;
  unint64_t v12 = 0LL;
  int v13 = 0;
  unint64_t v14 = 0LL;
  int v15 = 0;
  unint64_t v16 = 0LL;
  for (unint64_t i = 0LL; i != 512; ++i)
  {
    float v18 = (float *)sub_10040B624(v2, i);
    sub_1005CACBC(v43, (float)((float)(v18[2] * 0.0) + (float)(v6 * v18[1])) + (float)(v4 * *v18));
    unint64_t v20 = v16 + (unsigned __int16)v15;
    if (v20 >= 0x200) {
      uint64_t v21 = 0x7FFFFFFFFFFFFF00LL;
    }
    else {
      uint64_t v21 = 0LL;
    }
    *((_DWORD *)&v46[v21 + 1] + v20) = v19;
    if (v16 > 0x1FF)
    {
      else {
        int v22 = 0;
      }
      int v23 = v15 + v22;
      int v15 = v23 + 1;
      LOWORD(v46[0]) = v23 + 1;
    }

    else
    {
      WORD1(v46[0]) = ++v16;
    }

    float v24 = (float *)sub_10040B624(v2, i);
    sub_1005CACBC(v42, (float)((float)(v24[2] * 0.0) + (float)(v10 * v24[1])) + (float)(v8 * *v24));
    unint64_t v26 = v14 + (unsigned __int16)v13;
    if (v26 >= 0x200) {
      uint64_t v27 = 0x7FFFFFFFFFFFFF00LL;
    }
    else {
      uint64_t v27 = 0LL;
    }
    *((_DWORD *)&v45[v27 + 1] + v26) = v25;
    if (v14 > 0x1FF)
    {
      else {
        int v28 = 0;
      }
      int v29 = v13 + v28;
      int v13 = v29 + 1;
      LOWORD(v45[0]) = v29 + 1;
    }

    else
    {
      WORD1(v45[0]) = ++v14;
    }

    uint64_t v30 = sub_10040B624(v2, i);
    sub_1005CACBC(v41, *(float *)(v30 + 8));
    unint64_t v32 = v12 + (unsigned __int16)v11;
    if (v32 >= 0x200) {
      uint64_t v33 = 0x7FFFFFFFFFFFFF00LL;
    }
    else {
      uint64_t v33 = 0LL;
    }
    *((_DWORD *)&v44[v33 + 1] + v32) = v31;
    if (v12 > 0x1FF)
    {
      else {
        int v34 = 0;
      }
      int v35 = v11 + v34;
      int v11 = v35 + 1;
      LOWORD(v44[0]) = v35 + 1;
    }

    else
    {
      WORD1(v44[0]) = ++v12;
    }
  }

  sub_100E08020((uint64_t)v46, 0LL, 0.0);
  *(_DWORD *)(a1 + 420) = v36;
  sub_100E08020((uint64_t)v45, 0LL, 0.0);
  *(_DWORD *)(a1 + 424) = v37;
  uint64_t result = sub_100E08020((uint64_t)v44, 0LL, 0.0);
  *(_DWORD *)(a1 + 428) = v39;
  return result;
}

void sub_100E06924(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(8uLL);
  *(void *)unint64_t v2 = a1 + 21424;
  v171[0] = v2 + 8;
  __p = v2;
  float v170 = v2 + 8;
  float v4 = (char *)sub_1000071BC((uint64_t)v171, 2uLL);
  *((void *)v4 + 1) = a1 + 27576;
  float v5 = v4 + 8;
  float v6 = &v4[8 * v3];
  float v7 = v4 + 16;
  float v8 = (char *)__p;
  float v9 = v170;
  if (v170 != __p)
  {
    do
    {
      uint64_t v10 = *((void *)v9 - 1);
      v9 -= 8;
      *((void *)v5 - 1) = v10;
      v5 -= 8;
    }

    while (v9 != v8);
    float v8 = (char *)__p;
  }

  __p = v5;
  float v170 = v4 + 16;
  v171[0] = &v4[8 * v3];
  if (v8)
  {
    operator delete(v8);
    float v6 = (char *)v171[0];
  }

  uint64_t v11 = a1 + 33728;
  float v170 = v4 + 16;
  if (v7 >= v6)
  {
    uint64_t v13 = (v7 - (_BYTE *)__p) >> 3;
    uint64_t v14 = v6 - (_BYTE *)__p;
    uint64_t v15 = v14 >> 2;
    else {
      unint64_t v16 = v15;
    }
    if (v16) {
      int v17 = (char *)sub_1000071BC((uint64_t)v171, v16);
    }
    else {
      int v17 = 0LL;
    }
    float v18 = &v17[8 * v13];
    int v19 = &v17[8 * v16];
    *(void *)float v18 = v11;
    unint64_t v12 = v18 + 8;
    unint64_t v20 = v170;
    uint64_t v21 = (char *)__p;
    if (v170 != __p)
    {
      do
      {
        uint64_t v22 = *((void *)v20 - 1);
        v20 -= 8;
        *((void *)v18 - 1) = v22;
        v18 -= 8;
      }

      while (v20 != v21);
      unint64_t v20 = (char *)__p;
    }

    __p = v18;
    float v170 = v12;
    v171[0] = v19;
    if (v20) {
      operator delete(v20);
    }
  }

  else
  {
    *((void *)v4 + 2) = v11;
    unint64_t v12 = v4 + 24;
  }

  uint64_t v143 = a1;
  float v170 = v12;
  bzero(v164, 0x800uLL);
  if (v12 == __p)
  {
    float v34 = 0.0;
  }

  else
  {
    unint64_t v23 = 0LL;
    unint64_t v12 = (char *)__p;
    do
    {
      unint64_t v24 = 0LL;
      int v25 = *(unsigned __int16 **)&v12[8 * v23];
      do
      {
        unint64_t v26 = 0LL;
        double v27 = 0.0;
        do
        {
          uint64_t v28 = sub_10040B624(v25, v26);
          float v29 = sub_1002B8AF0(v28, v24);
          *((float *)v173 + v26) = v29;
          double v27 = v27 + v29;
          ++v26;
        }

        while (v26 != 512);
        uint64_t v30 = 0LL;
        double v31 = v27 * 0.001953125;
        *(float *)&double v31 = v27 * 0.001953125;
        float32x4_t v32 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v31, 0);
        do
        {
          *(float32x4_t *)&v173[v30] = vsubq_f32(*(float32x4_t *)&v173[v30], v32);
          v30 += 2LL;
        }

        while (v30 != 256);
        sub_100DEA424((uint64_t)v173, (float *)v172, 512LL, 1);
        for (unint64_t i = 0LL; i != 2048; i += 16LL)
          *(float32x4_t *)&v164[i / 2] = vaddq_f32(*(float32x4_t *)&v172[i / 8], *(float32x4_t *)&v164[i / 2]);
        ++v24;
      }

      while (v24 != 3);
      ++v23;
      unint64_t v12 = (char *)__p;
    }

    while (v23 < (v170 - (_BYTE *)__p) >> 3);
    float v34 = v165;
  }

  uint64_t v35 = 0LL;
  unint64_t v36 = 0LL;
  float v37 = 1.1755e-38;
  do
  {
    float v38 = v34;
    int v39 = (float *)&v164[2 * v35];
    float v34 = v39[25];
    if (v34 > v38 && v34 >= v39[26] && v34 > v37)
    {
      unint64_t v36 = v35 + 25;
      float v37 = v39[25];
    }

    ++v35;
  }

  while (v35 != 486);
  float v40 = v37 / 9.0;
  if (v12)
  {
    float v170 = v12;
    operator delete(v12);
  }

  __asm { FMOV            V0.2S, #-1.0 }

  *(void *)(v143 + 432) = _D0;
  *(_DWORD *)(v143 + 440) = -1082130432;
  *(float *)(v143 + 444) = v40;
  *(float *)(v143 + 448) = (float)v36 / 100.0;
  if (v36 && v40 > 0.1)
  {
    float v46 = (unsigned __int16 *)(v143 + 39880);
    unint64_t v47 = *(unsigned __int16 *)(v143 + 39882);
    float v160 = 0LL;
    v161 = 0LL;
    uint64_t v162 = 0LL;
    v157 = 0LL;
    v158 = 0LL;
    v159 = 0LL;
    v154 = 0LL;
    int v155 = 0LL;
    v156 = 0LL;
    unint64_t v48 = v47 / v36 * v36;
    if (v48)
    {
      unint64_t v49 = 0LL;
      float v50 = 0.0;
      float v51 = 0.0;
      float v52 = 0.0;
      do
      {
        float v53 = *(float *)sub_10040B624(v46, v49);
        float v54 = *(float *)(sub_10040B624(v46, v49) + 4);
        uint64_t v55 = sub_10040B624(v46, v49);
        float v52 = v52 + v53;
        ++v49;
        float v51 = v51 + v54;
        float v50 = v50 + *(float *)(v55 + 8);
      }

      while (v48 != v49);
    }

    else
    {
      float v52 = 0.0;
      float v51 = 0.0;
      float v50 = 0.0;
    }

    if (v36 <= v47)
    {
      uint64_t v56 = 0LL;
      float v57 = v51 / (float)v48;
      float v58 = (float)(v36 - 1);
      float v59 = 0.01 * v58;
      if (v48) {
        float v60 = v52 / (float)v48;
      }
      else {
        float v60 = 0.0;
      }
      if (v48) {
        float v61 = v57;
      }
      else {
        float v61 = 0.0;
      }
      if (v48) {
        float v62 = v50 / (float)v48;
      }
      else {
        float v62 = 0.0;
      }
      if (v47 / v36 <= 1) {
        uint64_t v63 = 1LL;
      }
      else {
        uint64_t v63 = v47 / v36;
      }
      float v147 = v60;
      float v148 = 0.01 * v58;
      float v145 = v62;
      float v146 = v61;
      uint64_t v144 = v63;
      do
      {
        *(void *)uint64_t v164 = 0x20000000000LL;
        v173[0] = 0x20000000000LL;
        v172[0] = 0x20000000000LL;
        __p = (void *)0x20000000000LL;
        unint64_t v64 = v36 * v56++;
        if (v64 >= v36 * v56)
        {
          unsigned __int16 v70 = 0;
          unsigned __int16 v69 = 0;
          unsigned __int16 v68 = 0;
        }

        else
        {
          uint64_t v153 = v56;
          unint64_t v65 = 0LL;
          unint64_t v66 = 0LL;
          unint64_t v67 = 0LL;
          unsigned __int16 v68 = 0;
          unsigned __int16 v69 = 0;
          unsigned __int16 v70 = 0;
          unint64_t v71 = v36;
          do
          {
            float v72 = *(float *)sub_10040B624(v46, v64) - v60;
            unint64_t v73 = v67 + v68;
            uint64_t v74 = 0x7FFFFFFFFFFFFF00LL;
            if (v73 < 0x200) {
              uint64_t v74 = 0LL;
            }
            *((float *)&v173[v74 + 1] + v73) = v72;
            if (v67 > 0x1FF)
            {
              if (v68 >= 0x1FFu) {
                __int16 v75 = -512;
              }
              else {
                __int16 v75 = 0;
              }
              v68 += v75 + 1;
            }

            else
            {
              ++v67;
            }

            float v76 = *(float *)(sub_10040B624(v46, v64) + 4) - v61;
            unint64_t v77 = v66 + v69;
            uint64_t v78 = 0x7FFFFFFFFFFFFF00LL;
            if (v77 < 0x200) {
              uint64_t v78 = 0LL;
            }
            *((float *)&v172[v78 + 1] + v77) = v76;
            if (v66 > 0x1FF)
            {
              if (v69 >= 0x1FFu) {
                __int16 v79 = -512;
              }
              else {
                __int16 v79 = 0;
              }
              v69 += v79 + 1;
            }

            else
            {
              ++v66;
            }

            float v80 = *(float *)(sub_10040B624(v46, v64) + 8) - v62;
            unint64_t v81 = v65 + v70;
            uint64_t v82 = 0x7FFFFFFFFFFFFF00LL;
            if (v81 < 0x200) {
              uint64_t v82 = 0LL;
            }
            *((float *)&v171[v82 - 1] + v81) = v80;
            if (v65 > 0x1FF)
            {
              if (v70 >= 0x1FFu) {
                __int16 v83 = -512;
              }
              else {
                __int16 v83 = 0;
              }
              v70 += v83 + 1;
            }

            else
            {
              ++v65;
            }

            ++v64;
            --v71;
          }

          while (v71);
          WORD1(v173[0]) = v67;
          WORD1(v172[0]) = v66;
          WORD1(__p) = v65;
          uint64_t v56 = v153;
          uint64_t v63 = v144;
        }

        LOWORD(v173[0]) = v68;
        LOWORD(v172[0]) = v69;
        LOWORD(__p) = v70;
        v168[0] = 0x20000000000LL;
        v167[0] = 0x20000000000LL;
        v166[0] = 0x20000000000LL;
        sub_100E08020((uint64_t)v173, (unsigned __int16 *)v168, 0.0);
        unint64_t v84 = LOWORD(v168[0]) + (unint64_t)WORD1(v168[0]) - 1;
        uint64_t v85 = HIDWORD(v168[0]);
        if (v84 < HIDWORD(v168[0])) {
          uint64_t v85 = 0LL;
        }
        sub_100E08020((uint64_t)v173, (unsigned __int16 *)v168, (float)-*((float *)&v168[1] + v84 - v85) / v59);
        sub_100E08020((uint64_t)v172, (unsigned __int16 *)v167, 0.0);
        unint64_t v86 = LOWORD(v167[0]) + (unint64_t)WORD1(v167[0]) - 1;
        uint64_t v87 = HIDWORD(v167[0]);
        if (v86 < HIDWORD(v167[0])) {
          uint64_t v87 = 0LL;
        }
        sub_100E08020((uint64_t)v172, (unsigned __int16 *)v167, (float)-*((float *)&v167[1] + v86 - v87) / v59);
        sub_100E08020((uint64_t)&__p, (unsigned __int16 *)v166, 0.0);
        unint64_t v88 = LOWORD(v166[0]) + (unint64_t)WORD1(v166[0]) - 1;
        uint64_t v89 = HIDWORD(v166[0]);
        if (v88 < HIDWORD(v166[0])) {
          uint64_t v89 = 0LL;
        }
        sub_100E08020((uint64_t)&__p, 0LL, (float)-*((float *)&v166[1] + v88 - v89) / v59);
        int v91 = v90;
        float v92 = v155;
        if (v155 >= v156)
        {
          float v94 = (char *)v154;
          uint64_t v95 = (v155 - (_BYTE *)v154) >> 2;
          unint64_t v96 = v95 + 1;
          uint64_t v97 = v156 - (_BYTE *)v154;
          if ((v156 - (_BYTE *)v154) >> 1 > v96) {
            unint64_t v96 = v97 >> 1;
          }
          else {
            unint64_t v98 = v96;
          }
          if (v98)
          {
            float v99 = (char *)sub_10000956C((uint64_t)&v156, v98);
            float v94 = (char *)v154;
            float v92 = v155;
          }

          else
          {
            float v99 = 0LL;
          }

          float v100 = &v99[4 * v95];
          *(_DWORD *)float v100 = v91;
          float v93 = v100 + 4;
          while (v92 != v94)
          {
            int v101 = *((_DWORD *)v92 - 1);
            v92 -= 4;
            *((_DWORD *)v100 - 1) = v101;
            v100 -= 4;
          }

          v154 = v100;
          int v155 = v93;
          v156 = &v99[4 * v98];
          if (v94) {
            operator delete(v94);
          }
        }

        else
        {
          *(_DWORD *)int v155 = v90;
          float v93 = v92 + 4;
        }

        unint64_t v102 = 0LL;
        int v155 = v93;
        do
        {
          int v103 = *(_DWORD *)sub_100208A44((unsigned __int16 *)v168, v102);
          int v104 = *(_DWORD *)sub_100208A44((unsigned __int16 *)v167, v102);
          v163[0] = v103;
          v163[1] = v104;
          v163[2] = 0;
          sub_10040B364(v164, (uint64_t)v163);
          ++v102;
        }

        while (v36 != v102);
        double v105 = 0.0;
        float v106 = 0.0;
        float v107 = 3.4028e38;
        float v108 = 0.0;
        do
        {
          double v149 = v105;
          float v150 = v106;
          float v151 = v107;
          __float2 v109 = __sincosf_stret(v108);
          unint64_t v110 = 0LL;
          float v152 = -v109.__sinval;
          float v111 = 3.4028e38;
          float v112 = 1.1755e-38;
          float v113 = 1.1755e-38;
          float v114 = 3.4028e38;
          do
          {
            float v115 = (float *)sub_10040B624(v164, v110);
            float v117 = *v115;
            float v116 = v115[1];
            float v118 = v115[2];
            float v119 = (float *)sub_10040B624(v164, v110);
            float v120 = (float)((float)(v118 * 0.0) + (float)(v152 * v116)) + (float)(v109.__cosval * v117);
            if (v112 < v120) {
              float v112 = (float)((float)(v118 * 0.0) + (float)(v152 * v116)) + (float)(v109.__cosval * v117);
            }
            if (v111 > v120) {
              float v111 = (float)((float)(v118 * 0.0) + (float)(v152 * v116)) + (float)(v109.__cosval * v117);
            }
            float v121 = (float)(v119[2] * 0.0) + (float)(v109.__cosval * v119[1]);
            float v122 = v121 + (float)(v109.__sinval * *v119);
            if (v114 > v122) {
              float v114 = v121 + (float)(v109.__sinval * *v119);
            }
            if (v113 < v122) {
              float v113 = v121 + (float)(v109.__sinval * *v119);
            }
            ++v110;
          }

          while (v36 != v110);
          float v106 = v150;
          float v107 = v151;
          if ((float)(v113 - v114) < v151)
          {
            float v106 = v112 - v111;
            float v107 = v113 - v114;
          }

          float v108 = v149 + 0.0523598776;
          double v105 = v108;
        }

        while (v108 < 3.14159265);
        float v123 = v161;
        if (v161 >= (float *)v162)
        {
          v125 = (float *)v160;
          uint64_t v126 = ((char *)v161 - (_BYTE *)v160) >> 2;
          unint64_t v127 = v126 + 1;
          float v60 = v147;
          float v59 = v148;
          float v62 = v145;
          float v61 = v146;
          uint64_t v128 = v162 - (_BYTE *)v160;
          if ((v162 - (_BYTE *)v160) >> 1 > v127) {
            unint64_t v127 = v128 >> 1;
          }
          else {
            unint64_t v129 = v127;
          }
          if (v129)
          {
            unint64_t v130 = (char *)sub_10000956C((uint64_t)&v162, v129);
            v125 = (float *)v160;
            float v123 = v161;
          }

          else
          {
            unint64_t v130 = 0LL;
          }

          v131 = (float *)&v130[4 * v126];
          float *v131 = v106;
          v124 = v131 + 1;
          while (v123 != v125)
          {
            int v132 = *((_DWORD *)v123-- - 1);
            *((_DWORD *)v131-- - 1) = v132;
          }

          float v160 = v131;
          v161 = v124;
          uint64_t v162 = &v130[4 * v129];
          if (v125) {
            operator delete(v125);
          }
        }

        else
        {
          float *v161 = v106;
          v124 = v123 + 1;
          float v60 = v147;
          float v59 = v148;
          float v62 = v145;
          float v61 = v146;
        }

        v161 = v124;
        int v133 = v158;
        if (v158 >= v159)
        {
          v135 = (float *)v157;
          uint64_t v136 = ((char *)v158 - (_BYTE *)v157) >> 2;
          unint64_t v137 = v136 + 1;
          if ((unint64_t)(v136 + 1) >> 62) {
LABEL_171:
          }
            sub_100007008();
          uint64_t v138 = (char *)v159 - (_BYTE *)v157;
          else {
            unint64_t v139 = v137;
          }
          if (v139)
          {
            uint64_t v140 = (char *)sub_10000956C((uint64_t)&v159, v139);
            v135 = (float *)v157;
            int v133 = v158;
          }

          else
          {
            uint64_t v140 = 0LL;
          }

          unint64_t v141 = (float *)&v140[4 * v136];
          *unint64_t v141 = v107;
          int v134 = v141 + 1;
          while (v133 != v135)
          {
            int v142 = *((_DWORD *)v133-- - 1);
            *((_DWORD *)v141-- - 1) = v142;
          }

          v157 = v141;
          v158 = v134;
          v159 = (float *)&v140[4 * v139];
          if (v135) {
            operator delete(v135);
          }
        }

        else
        {
          float *v158 = v107;
          int v134 = v133 + 1;
        }

        v158 = v134;
      }

      while (v56 != v63);
    }

    *(float *)(v143 + 432) = sub_100E08190((uint64_t)&v160);
    *(float *)(v143 + 436) = sub_100E08190((uint64_t)&v157);
    *(float *)(v143 + 440) = sub_100E08190((uint64_t)&v154);
    if (v154)
    {
      int v155 = (char *)v154;
      operator delete(v154);
    }

    if (v157)
    {
      v158 = (float *)v157;
      operator delete(v157);
    }

    if (v160)
    {
      v161 = (float *)v160;
      operator delete(v160);
    }
  }

void sub_100E07514(_Unwind_Exception *a1)
{
  unint64_t v2 = (void *)STACK[0x3118];
  if (STACK[0x3118])
  {
    STACK[0x3120] = (unint64_t)v2;
    operator delete(v2);
  }

  _Unwind_Resume(a1);
}

void sub_100E07598(uint64_t a1)
{
  uint64_t v2 = a1 + 48140;
  uint64_t v3 = a1 + 47092;
  uint64_t v4 = a1 + 46044;
  uint64_t v5 = a1 + 564;
  uint64_t v6 = a1 + 46032;
  sub_100D53FC4(a1 + 46032, 1, (uint64_t)v33);
  sub_100D54620((unsigned __int16 *)(a1 + 49192), &v25, (uint64_t)v24, (uint64_t)&v21);
  sub_100FBFFE8(v20);
  sub_100FBFFEC((uint64_t)v20, v39, (unsigned __int16 *)(a1 + 46060));
  sub_100FBFFEC((uint64_t)v20, v38, (unsigned __int16 *)(a1 + 47108));
  sub_100FBFFEC((uint64_t)v20, v37, (unsigned __int16 *)(a1 + 48156));
  float v7 = sub_1009AF9AC(1, 11, (uint64_t)v39, (uint64_t)v38, (uint64_t)v37);
  float v8 = sub_1009AF9AC(49, 127, (uint64_t)v39, (uint64_t)v38, (uint64_t)v37);
  *(void *)(a1 + 512) = v25;
  int v9 = HIDWORD(v25);
  *(float *)(a1 + 520) = (float)SDWORD2(v25);
  *(_DWORD *)(a1 + 524) = v9;
  int v10 = v27;
  *(float *)(a1 + 528) = (float)v26;
  int v11 = v29;
  *(_DWORD *)(a1 + 532) = v31;
  *(_DWORD *)(a1 + 536) = v10;
  *(_DWORD *)(a1 + 540) = v32;
  *(_OWORD *)(a1 + 544) = v28;
  *(_DWORD *)(a1 + 560) = v11;
  *(void *)&__int128 v12 = v30;
  *((void *)&v12 + 1) = v24[0];
  *(_OWORD *)uint64_t v5 = v12;
  *(_DWORD *)(a1 + 580) = v24[1];
  *(void *)&__int128 v12 = *(void *)((char *)&v24[1] + 4);
  int v13 = v21;
  *((void *)&v12 + 1) = v21;
  *(_OWORD *)(v5 + 20) = v12;
  *(_DWORD *)(a1 + 600) = v22;
  *(void *)&__int128 v12 = v23;
  *((void *)&v12 + 1) = v33[0];
  *(_OWORD *)(v5 + 40) = v12;
  *(void *)(v5 + 56) = v33[1];
  int v14 = v35;
  *(_DWORD *)(a1 + 628) = v34;
  *(float *)(a1 + 632) = v7;
  *(float *)(a1 + 636) = v8;
  *(_DWORD *)(a1 + 640) = v13;
  *(_DWORD *)(a1 + 644) = v36;
  *(_DWORD *)(a1 + 648) = v11;
  *(_DWORD *)(a1 + 652) = v14;
  *(float *)(a1 + 656) = sub_100E07810(a1);
  if (*(_BYTE *)v4) {
    sub_100208C68(v4);
  }
  float v15 = *(float *)(v4 + 4);
  if (*(_BYTE *)v3) {
    sub_100208C68(v3);
  }
  float v16 = *(float *)(v3 + 4);
  if (*(_BYTE *)v2) {
    sub_100208C68(v2);
  }
  *(float *)(a1 + 660) = -atan2f(v15, sqrtf((float)(v16 * v16) + (float)(*(float *)(v2 + 4) * *(float *)(v2 + 4))));
  *(float *)(a1 + 664) = sub_100E44C40(v6);
  *(_DWORD *)(a1 + 668) = v17;
  *(_DWORD *)(a1 + 672) = v18;
  *(_DWORD *)(a1 + 676) = v19;
}

float sub_100E07810(uint64_t a1)
{
  unint64_t v1 = (unsigned __int16 *)(a1 + 52352);
  uint64_t v2 = a1 + 21040;
  float v3 = 0.0;
  for (unint64_t i = 192LL; i != 256; ++i)
  {
    unint64_t v5 = 0LL;
    uint64_t v6 = v2;
    do
    {
      v16[0] = sub_100D54F1C(v1, i);
      v16[1] = v7;
      v16[2] = v8;
      int v9 = (float *)sub_1002BA24C((uint64_t)v16, v5);
      sub_1005CACBC((unsigned __int16 *)v6, *v9);
      sub_1005CACBC((unsigned __int16 *)(v6 + 192), v10);
      int v11 = *(_DWORD *)(v6 + 200);
      *(_DWORD *)sub_1002BA24C((uint64_t)v17, v5++) = v11;
      v6 += 64LL;
    }

    while (v5 != 3);
    uint64_t v12 = 0LL;
    float v13 = 0.0;
    do
    {
      float v13 = v13 + (float)(*(float *)&v17[v12] * *(float *)&v17[v12]);
      v12 += 4LL;
    }

    while (v12 != 12);
    float v14 = sqrtf(v13);
    float v3 = v3 + (float)(v14 * v14);
  }

  return v3;
}

unsigned __int16 *sub_100E0790C(unsigned __int16 *a1, unsigned __int16 *a2)
{
  *(_DWORD *)a2 = 0;
  uint64_t v4 = a2 + 4;
  for (unint64_t i = 1LL; i != 256; unint64_t i = v7 + 2)
  {
    float v6 = *(float *)sub_100208A44(a1, i);
    unint64_t v7 = i - 1;
    float v8 = v6 - *(float *)sub_100208A44(a1, v7);
    uint64_t v9 = a2[1];
    unint64_t v10 = *((unsigned int *)a2 + 1);
    uint64_t v11 = *a2;
    if (v11 + v9 >= v10) {
      uint64_t v12 = *((unsigned int *)a2 + 1);
    }
    else {
      uint64_t v12 = 0LL;
    }
    *(float *)&v4[2 * (v11 + v9 - v12)] = v8;
    if (v10 <= v9)
    {
      if (++v11 >= v10) {
        __int16 v13 = v10;
      }
      else {
        __int16 v13 = 0;
      }
      LOWORD(v11) = v11 - v13;
      *a2 = v11;
    }

    else
    {
      LOWORD(v9) = v9 + 1;
      a2[1] = v9;
    }
  }

  unint64_t v14 = (unsigned __int16)v11 + (unint64_t)(unsigned __int16)v9 - 1;
  if (v14 < v10) {
    unint64_t v10 = 0LL;
  }
  return sub_1005CAE5C(a2, &v4[2 * (v14 - v10)]);
}

void sub_100E079E4(float **a1, int a2)
{
  uint64_t v2 = *a1;
  float v3 = a1[1];
  if (v3 != *a1)
  {
    if (a2)
    {
      float v4 = 0.0;
      unint64_t v5 = *a1;
      do
      {
        float v6 = *v5++;
        float v4 = v4 + v6;
      }

      while (v5 != v3);
      float v7 = v4 / (float)(unint64_t)(v3 - *a1);
    }

    else
    {
      float v7 = sub_100825C70((uint64_t)a1);
      uint64_t v2 = *a1;
      float v3 = a1[1];
    }

    float v9 = 0.0;
    while (v2 != v3)
    {
      float v10 = *v2++;
      float v9 = v9 + vabds_f32(v7, v10);
    }
  }

uint64_t sub_100E07A70(unsigned __int16 *a1, float a2)
{
  if (a1[1] < 2u) {
    return 0LL;
  }
  LODWORD(v4) = 0;
  unint64_t v5 = 1LL;
  do
  {
    BOOL v6 = *(float *)sub_100208A44(a1, v5 - 1) <= a2;
    uint64_t v4 = v4 + (v6 ^ (*(float *)sub_100208A44(a1, v5++) <= a2));
  }

  while (v5 < a1[1]);
  return v4;
}

uint64_t sub_100E07B08(uint64_t result)
{
  uint64_t v1 = *(unsigned __int16 *)(result + 2);
  if (*(_WORD *)(result + 2))
  {
    uint64_t v2 = (unsigned __int16 *)result;
    unint64_t v3 = 0LL;
    float v4 = 0.0;
    do
      float v4 = v4 + *(float *)sub_100208A44(v2, v3++);
    while (v1 != v3);
    unint64_t v5 = 0LL;
    float v6 = v4 / (float)v1;
    float v7 = 0.0;
    float v8 = 0.0;
    do
    {
      uint64_t result = sub_100208A44(v2, v5);
      float v9 = (float)(*(float *)result - v6) * (float)(*(float *)result - v6);
      float v7 = v7 + v9;
      float v8 = v8 + (float)(v9 * v9);
      ++v5;
    }

    while (v1 != v5);
  }

  return result;
}

uint64_t sub_100E07BDC(uint64_t result)
{
  uint64_t v1 = *(unsigned __int16 *)(result + 2);
  if (*(_WORD *)(result + 2))
  {
    uint64_t v2 = (unsigned __int16 *)result;
    unint64_t v3 = 0LL;
    float v4 = 0.0;
    do
      float v4 = v4 + *(float *)sub_100208A44(v2, v3++);
    while (v1 != v3);
    unint64_t v5 = 0LL;
    float v6 = v4 / (float)v1;
    float v7 = 0.0;
    float v8 = 0.0;
    do
    {
      uint64_t result = sub_100208A44(v2, v5);
      float v9 = *(float *)result - v6;
      float v7 = v7 + (float)(v9 * v9);
      float v8 = v8 + (float)((float)(v9 * v9) * v9);
      ++v5;
    }

    while (v1 != v5);
  }

  return result;
}

void sub_100E07CA8(_DWORD *a1, uint64_t a2, unsigned __int16 *a3, int a4)
{
  if (a4)
  {
    sub_100DEA424((uint64_t)(a3 + 4), v8, 256LL, 0);
    uint64_t v6 = 0LL;
    *(void *)float v7 = 0x10000000000LL;
    do
      sub_1005CAE5C(v7, &v8[v6++]);
    while (v6 != 256);
    sub_100FBFFEC(a2, a1, v7);
  }

  else
  {
    sub_100FBFFEC(a2, a1, a3);
  }

unint64_t sub_100E07D9C(uint64_t a1, float a2, float a3)
{
  uint64_t v3 = 0LL;
  float v4 = 0.0;
  float v5 = 0.0;
  int v6 = -1;
  do
  {
    float v7 = *(float *)(a1 + 4 * v3);
    float v5 = v5 + v7;
    if (v7 > v4)
    {
      float v4 = *(float *)(a1 + 4 * v3);
      int v6 = v3;
    }

    ++v3;
  }

  while (v3 != 128);
  float v8 = v5 * 0.0078125;
  float v9 = v4 / v8;
  BOOL v10 = v8 == 0.0;
  float v11 = 0.0;
  if (!v10) {
    float v11 = v9;
  }
  BOOL v12 = v4 <= a3 || v11 <= a2;
  unint64_t v13 = LODWORD(v4) | ((unint64_t)(int)(float)v6 << 32);
  if (v12) {
    return 0xFFFFFFFF00000000LL;
  }
  else {
    return v13;
  }
}

float sub_100E07E08(float *a1, float *a2, float *a3, uint64_t a4)
{
  *a1 = 0.0;
  *a2 = 0.0;
  float v8 = sub_1009AF760(50, 0x80uLL, 0.25);
  unsigned int v9 = sub_1009AF58C(v8);
  float v10 = sub_1009AF760(50, 0x80uLL, 10.0);
  unsigned int v11 = sub_1009AF58C(v10);
  if (v9 < v11)
  {
    unint64_t v12 = (int)v9;
    do
    {
      float v13 = *(float *)(a4 + 4 * v12);
      *a1 = v13 + *a1;
      if (v13 > *a2)
      {
        *a3 = (float)v12;
        *a2 = v13;
      }

      ++v12;
    }

    while (v12 < (int)v11);
  }

  float result = *(float *)&dword_10199EB88 * *a3;
  *a3 = result;
  return result;
}

float *sub_100E07ECC(unsigned __int16 *a1, double a2)
{
  uint64_t v3 = a1[1];
  if (a1[1])
  {
    unint64_t v4 = 0LL;
    float32x2_t v5 = 0LL;
    do
    {
      a2 = *(double *)sub_10040B624(a1, v4);
      float32x2_t v5 = vadd_f32(v5, *(float32x2_t *)&a2);
      ++v4;
    }

    while (v3 != v4);
  }

  else
  {
    float32x2_t v5 = 0LL;
  }

  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  if ((_DWORD)v3)
  {
    unint64_t v6 = 0LL;
    *(float *)&a2 = (float)v3;
    float32x2_t v7 = vdiv_f32(v5, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a2, 0));
    do
    {
      float32x2_t v20 = vsub_f32(*(float32x2_t *)sub_10040B624(a1, v6), v7);
      unint64_t v8 = 0LL;
      LODWORD(v17) = sub_100E08238((uint64_t)&v20);
      HIDWORD(v17) = v9;
      int v18 = v10;
      int v19 = v11;
      do
      {
        *((float *)&v21 + v8) = sub_1004EB0EC((uint64_t)&v17, v8) + *((float *)&v21 + v8);
        ++v8;
      }

      while (v8 != 4);
      ++v6;
    }

    while (v6 != v3);
    float v13 = *((float *)&v21 + 1);
    float v12 = *(float *)&v21;
    float v15 = *((float *)&v22 + 1);
    float v14 = *(float *)&v22;
  }

  else
  {
    float v15 = 0.0;
    float v14 = 0.0;
    float v13 = 0.0;
    float v12 = 0.0;
  }

  return sub_100E08338(&v17, v12, v13, v14, v15);
}

uint64_t sub_100E08020(uint64_t result, unsigned __int16 *a2, float a3)
{
  unint64_t v4 = (unsigned __int16 *)result;
  if (a2)
  {
    *(_DWORD *)a2 = 0;
    int v5 = *((_DWORD *)a2 + 1);
    *((_DWORD *)a2 + 2) = 0;
    if (v5) {
      a2[1] = 1;
    }
    else {
      *a2 = 1;
    }
  }

  if (*(unsigned __int16 *)(result + 2) >= 2u)
  {
    float v6 = 0.0;
    float v7 = 1.1755e-38;
    float v8 = 3.4028e38;
    unint64_t v9 = 1LL;
    do
    {
      float v10 = a3;
      float v11 = *(float *)sub_100208A44(v4, v9 - 1);
      float result = sub_100208A44(v4, v9);
      a3 = v10 + (float)((float)((float)(0.01 * 9.81) * 0.5) * (float)(v11 + *(float *)result));
      float v6 = v6 + (float)((float)(0.01 * 0.5) * (float)(v10 + a3));
      if (v8 > v6) {
        float v8 = v6;
      }
      if (v7 < v6) {
        float v7 = v6;
      }
      if (a2)
      {
        uint64_t v12 = a2[1];
        unint64_t v13 = *((unsigned int *)a2 + 1);
        uint64_t v14 = *a2;
        if (v14 + v12 >= v13) {
          uint64_t v15 = *((unsigned int *)a2 + 1);
        }
        else {
          uint64_t v15 = 0LL;
        }
        *(float *)&a2[2 * (v14 + v12 - v15) + 4] = v6;
        if (v13 <= v12)
        {
          if (v14 + 1 < v13) {
            LOWORD(v13) = 0;
          }
          *a2 = v14 + 1 - v13;
        }

        else
        {
          a2[1] = v12 + 1;
        }
      }

      ++v9;
    }

    while (v9 < v4[1]);
  }

  return result;
}

float sub_100E08190(uint64_t a1)
{
  unint64_t v4 = 0LL;
  int v5 = 0LL;
  uint64_t v6 = 0LL;
  sub_10001B72C(&v4, *(const void **)a1, *(void *)(a1 + 8), (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2);
  std::__sort<std::__less<float,float> &,float *>(v4, v5, &v7);
  unint64_t v1 = (unint64_t)(v5 - v4) >> 1;
  if ((((_DWORD)v5 - (_DWORD)v4) & 4) != 0) {
    float v2 = v4[v1];
  }
  else {
    float v2 = (float)(v4[v1 - 1] + v4[v1]) * 0.5;
  }
  int v5 = v4;
  operator delete(v4);
  return v2;
}

void sub_100E0821C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

float sub_100E08238(uint64_t a1)
{
  float v2 = sub_1004EA360(a1, 0LL);
  float v3 = v2 * sub_1004EA360(a1, 0LL);
  *(float *)sub_1004E2E2C((uint64_t)&v11, 0LL, 0LL) = v3;
  float v4 = sub_1004EA360(a1, 0LL);
  float v5 = v4 * sub_1004EA360(a1, 1uLL);
  *(float *)sub_1004E2E2C((uint64_t)&v11, 0LL, 1uLL) = v5;
  float v6 = sub_1004EA360(a1, 1uLL);
  float v7 = v6 * sub_1004EA360(a1, 0LL);
  *(float *)sub_1004E2E2C((uint64_t)&v11, 1uLL, 0LL) = v7;
  float v8 = sub_1004EA360(a1, 1uLL);
  float v9 = v8 * sub_1004EA360(a1, 1uLL);
  *(float *)sub_1004E2E2C((uint64_t)&v11, 1uLL, 1uLL) = v9;
  return v11;
}

float *sub_100E08338(void *a1, float a2, float a3, float a4, float a5)
{
  unint64_t v6 = 0LL;
  *(float *)float v40 = a2;
  *(float *)&v40[1] = a3;
  float v41 = a4;
  float v42 = a5;
  char v7 = 1;
  *a1 = 0LL;
  a1[1] = 0LL;
  do
  {
    char v8 = v7;
    *(_DWORD *)sub_1004E2E2C((uint64_t)a1, v6, v6) = 1065353216;
    int v9 = *(_DWORD *)sub_1004E2E2C((uint64_t)v40, v6, v6);
    *(_DWORD *)sub_1004E2C54((uint64_t)&v43, v6) = v9;
    int v10 = *(_DWORD *)sub_1004E2E2C((uint64_t)v40, v6, v6);
    *(_DWORD *)sub_1004E2C54((uint64_t)&v39, v6) = v10;
    float result = (float *)sub_1004E2C54((uint64_t)&v38, v6);
    char v7 = 0;
    *float result = 0.0;
    unint64_t v6 = 1LL;
  }

  while ((v8 & 1) != 0);
  unint64_t v12 = 0LL;
  float v13 = 0.0;
  do
  {
    float v14 = -v41;
    if (v41 >= 0.0) {
      float v14 = v41;
    }
    if (v12 < 3) {
      float v13 = (float)((float)(v14 + 0.0) * 0.2) * 0.25;
    }
    float v15 = v14 * 100.0;
    if (v12 < 4) {
      goto LABEL_38;
    }
    float v16 = v43.f32[0];
    float v17 = v15 + v43.f32[0];
    if (v43.f32[0] < 0.0) {
      float v16 = -v43.f32[0];
    }
    if (v17 != v16) {
      goto LABEL_38;
    }
    float v18 = v43.f32[1];
    float v19 = v15 + v43.f32[1];
    if (v43.f32[1] < 0.0) {
      float v18 = -v43.f32[1];
    }
    if (v19 == v18)
    {
      float v41 = 0.0;
    }

    else
    {
LABEL_38:
      if (v14 > v13)
      {
        unint64_t v20 = 0LL;
        float v21 = v43.f32[1] - v43.f32[0];
        float v22 = v15 + (float)(v43.f32[1] - v43.f32[0]);
        if (v22 < 0.0) {
          float v22 = -v22;
        }
        float v23 = -v21;
        if (v21 >= 0.0) {
          float v23 = v43.f32[1] - v43.f32[0];
        }
        float v24 = (float)(v21 * 0.5) / v41;
        float v25 = -v24;
        BOOL v26 = v24 < 0.0;
        if (v24 >= 0.0) {
          float v25 = (float)(v21 * 0.5) / v41;
        }
        float v27 = 1.0 / (float)(v25 + sqrtf((float)(v24 * v24) + 1.0));
        if (v26) {
          float v27 = -v27;
        }
        float v28 = v41 / v21;
        if (v22 == v23) {
          float v29 = v28;
        }
        else {
          float v29 = v27;
        }
        float v30 = 1.0 / sqrtf((float)(v29 * v29) + 1.0);
        float v31 = v29 * v30;
        float v32 = (float)(v29 * v30) / (float)(v30 + 1.0);
        v38.f32[0] = v38.f32[0] - (float)(v41 * v29);
        v38.f32[1] = (float)(v41 * v29) + v38.f32[1];
        v43.f32[0] = v43.f32[0] - (float)(v41 * v29);
        v43.f32[1] = v43.f32[1] + (float)(v41 * v29);
        float v41 = 0.0;
        float v33 = -(float)(v29 * v30);
        char v34 = 1;
        do
        {
          char v35 = v34;
          float v36 = *(float *)sub_1004E2E2C((uint64_t)a1, v20, 0LL);
          float v37 = *(float *)sub_1004E2E2C((uint64_t)a1, v20, 1uLL);
          *(float *)sub_1004E2E2C((uint64_t)a1, v20, 0LL) = v36 + (float)(v33 * (float)(v37 + (float)(v36 * v32)));
          float result = (float *)sub_1004E2E2C((uint64_t)a1, v20, 1uLL);
          char v34 = 0;
          *float result = v37 + (float)(v31 * (float)(v36 - (float)(v37 * v32)));
          unint64_t v20 = 1LL;
        }

        while ((v35 & 1) != 0);
      }
    }

    ++v12;
    float32x2_t v39 = vadd_f32(v38, v39);
    float32x2_t v43 = v39;
    float32x2_t v38 = 0LL;
    float v13 = 0.0;
  }

  while (v12 != 10);
  return result;
}

void sub_100E08620()
{
  dword_10199EB88 = sub_1009AF790(50, 0x80uLL);
}

uint64_t sub_100E08644(uint64_t a1, void *a2)
{
  *sub_100C079E8(a1, a2) = &off_101884980;
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101884A68);
  }
  float v3 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "PAUSE: Autopause not suppored on this platform, constructing CLAutopauseProviderDummy",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101884A68);
    }
    v7[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "PAUSE: Autopause not suppored on this platform, constructing CLAutopauseProviderDummy",  v7,  2);
    unint64_t v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLAutopauseProviderDummy::CLAutopauseProviderDummy(id<CLIntersiloUniverse>)",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  return a1;
}

void sub_100E087E8(_Unwind_Exception *a1)
{
}

void sub_100E08808(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100C07AB0(a1);
  operator delete(v1);
}

uint64_t sub_100E0881C(uint64_t a1, uint64_t a2)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101884A68);
  }
  float v4 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 160LL))(__p, a1, a2);
    float v5 = v16 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "PAUSE: Client registered for %s", buf, 0xCu);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101884A68);
    }
    uint64_t v7 = qword_101934A78;
    (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 160LL))(buf, a1, a2);
    if (v12 >= 0) {
      char v8 = buf;
    }
    else {
      char v8 = *(_BYTE **)buf;
    }
    int v13 = 136315138;
    float v14 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v7,  2LL,  "PAUSE: Client registered for %s",  (const char *)&v13);
    int v10 = v9;
    if (v12 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLAutopauseProviderDummy::registerForNotificationInternal(const CLAutopauseProvider_Type::Notification &)",  "%s\n",  v10);
  }

  return 1LL;
}

uint64_t sub_100E08A54(uint64_t a1, uint64_t a2)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101884A68);
  }
  float v4 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 160LL))(__p, a1, a2);
    float v5 = v16 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "PAUSE: Client unregistered for %s", buf, 0xCu);
    if (v16 < 0) {
      operator delete(__p[0]);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101884A68);
    }
    uint64_t v7 = qword_101934A78;
    (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 160LL))(buf, a1, a2);
    if (v12 >= 0) {
      char v8 = buf;
    }
    else {
      char v8 = *(_BYTE **)buf;
    }
    int v13 = 136315138;
    float v14 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v7,  2LL,  "PAUSE: Client unregistered for %s",  (const char *)&v13);
    int v10 = v9;
    if (v12 < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLAutopauseProviderDummy::unregisterForNotificationInternal(const CLAutopauseProvider_Type::Notification &)",  "%s\n",  v10);
  }

  return 1LL;
}

void sub_100E08C8C(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_100E08CB8()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_10135F284;
      v1[3] = unk_10135F294;
      v1[4] = xmmword_10135F2A4;
      v1[0] = xmmword_10135F264;
      v1[1] = unk_10135F274;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_100E08D8C(_Unwind_Exception *a1)
{
}

uint64_t sub_100E08DA4(uint64_t result)
{
  uint64_t v1 = 0LL;
  *(_OWORD *)float result = xmmword_10135F330;
  *(_OWORD *)(result + 16) = unk_10135F340;
  *(_OWORD *)(result + 32) = xmmword_10135F350;
  *(_OWORD *)(result + 48) = xmmword_10135F300;
  *(_OWORD *)(result + 64) = unk_10135F310;
  *(_OWORD *)(result + 80) = xmmword_10135F320;
  __asm { FMOV            V4.2D, #1.0 }

  *(_OWORD *)(result + 96) = xmmword_10135F2E0;
  *(_OWORD *)(result + 112) = _Q4;
  uint64_t v7 = result + 128;
  *(_OWORD *)(result + 128) = xmmword_10135F330;
  *(_OWORD *)(result + 144) = unk_10135F340;
  *(_OWORD *)(result + 192) = xmmword_10135F370;
  *(_OWORD *)(result + 208) = unk_10135F380;
  *(_OWORD *)(result + 160) = xmmword_10135F350;
  *(_OWORD *)(result + 176) = xmmword_10135F360;
  *(_OWORD *)(result + 224) = xmmword_10135F2F0;
  *(_OWORD *)(result + 240) = _Q4;
  *(_DWORD *)(result + 288) = 0;
  *(void *)(result + 256) = result + 128;
  *(void *)(result + 264) = 0LL;
  *(void *)(result + 272) = 0LL;
  *(void *)(result + 280) = 0LL;
  *(void *)(result + 296) = result + 128;
  *(void *)(result + 304) = 0LL;
  *(_DWORD *)(result + 328) = 0;
  *(void *)(result + 312) = 0LL;
  *(void *)(result + 320) = 0LL;
  *(void *)(result + 336) = result + 128;
  *(void *)(result + 344) = 0LL;
  *(_DWORD *)(result + 368) = 0;
  *(void *)(result + 352) = 0LL;
  *(void *)(result + 360) = 0LL;
  do
  {
    uint64_t v8 = result + v1;
    *(void *)(v8 + 376) = off_10183B0F0;
    int v9 = (_OWORD *)(result + v1 + 392);
    _OWORD *v9 = 0uLL;
    v9[1] = 0uLL;
    _DWORD v9[2] = 0uLL;
    *(void *)(v8 + 448) = 0LL;
    *(void *)(v8 + 456) = 0LL;
    *(void *)(v8 + 440) = result + v1 + 448;
    v1 += 88LL;
    *(_DWORD *)(v8 + 384) = 0;
  }

  while (v1 != 264);
  uint64_t v10 = 0LL;
  *(void *)(result + 640) = result;
  *(void *)(result + 648) = 0LL;
  *(void *)(result + 664) = 0LL;
  *(void *)(result + 656) = 0LL;
  *(_DWORD *)(result + 672) = 0;
  *(void *)(result + 680) = result;
  *(void *)(result + 688) = 0LL;
  *(void *)(result + 704) = 0LL;
  *(void *)(result + 696) = 0LL;
  *(_DWORD *)(result + 712) = 0;
  *(void *)(result + 720) = result;
  *(void *)(result + 728) = 0LL;
  *(void *)(result + 744) = 0LL;
  *(void *)(result + 736) = 0LL;
  *(_DWORD *)(result + 752) = 0;
  *(void *)(result + 760) = v7;
  *(void *)(result + 776) = 0LL;
  *(void *)(result + 768) = 0LL;
  *(_DWORD *)(result + 792) = 0;
  *(void *)(result + 784) = 0LL;
  *(void *)(result + 800) = v7;
  *(void *)(result + 816) = 0LL;
  *(void *)(result + 808) = 0LL;
  *(_DWORD *)(result + 832) = 0;
  *(void *)(result + 824) = 0LL;
  *(void *)(result + 840) = result;
  *(void *)(result + 856) = 0LL;
  *(void *)(result + 848) = 0LL;
  *(_DWORD *)(result + 872) = 0;
  *(void *)(result + 864) = 0LL;
  *(void *)(result + 880) = result;
  *(void *)(result + 896) = 0LL;
  *(void *)(result + 888) = 0LL;
  *(_DWORD *)(result + 912) = 0;
  *(void *)(result + 904) = 0LL;
  do
  {
    uint64_t v11 = result + v10;
    *(void *)(v11 + 920) = off_10183B0F0;
    char v12 = (_OWORD *)(result + v10 + 936);
    *char v12 = 0uLL;
    v12[1] = 0uLL;
    v12[2] = 0uLL;
    *(_OWORD *)(v11 + 992) = 0uLL;
    *(void *)(v11 + 984) = result + v10 + 992;
    v10 += 88LL;
    *(_DWORD *)(v11 + 928) = 0;
  }

  while (v10 != 176);
  uint64_t v13 = 0LL;
  *(void *)(result + 1096) = v7;
  *(void *)(result + 1136) = v7;
  *(void *)(result + 1104) = 0LL;
  *(void *)(result + 1120) = 0LL;
  *(void *)(result + 1112) = 0LL;
  *(_DWORD *)(result + 1128) = 0;
  *(void *)(result + 1144) = 0LL;
  *(void *)(result + 1160) = 0LL;
  *(void *)(result + 1152) = 0LL;
  *(_DWORD *)(result + 1168) = 0;
  *(void *)(result + 1176) = result;
  *(void *)(result + 1184) = 0LL;
  *(void *)(result + 1200) = 0LL;
  *(void *)(result + 1192) = 0LL;
  *(_DWORD *)(result + 1208) = 0;
  *(void *)(result + 1216) = result;
  *(void *)(result + 1232) = 0LL;
  *(void *)(result + 1224) = 0LL;
  *(_DWORD *)(result + 1248) = 0;
  *(void *)(result + 1240) = 0LL;
  do
  {
    uint64_t v14 = result + v13;
    *(void *)(v14 + 1256) = off_10183B0F0;
    float v15 = (_OWORD *)(result + v13 + 1272);
    _OWORD *v15 = 0uLL;
    v15[1] = 0uLL;
    v15[2] = 0uLL;
    *(_OWORD *)(v14 + 1328) = 0uLL;
    *(void *)(v14 + 1320) = result + v13 + 1328;
    v13 += 88LL;
    *(_DWORD *)(v14 + 1264) = 0;
  }

  while (v13 != 176);
  *(void *)(result + 1432) = 0LL;
  *(void *)(result + 1440) = 0x80000000800000LL;
  *(_DWORD *)(result + 1448) = -8388609;
  *(_BYTE *)(result + 1452) = 1;
  *(void *)(result + 1472) = 0LL;
  *(void *)(result + 1464) = 0LL;
  *(void *)(result + 1480) = 0xA00000000LL;
  *(void *)(result + 1528) = 0x500000000LL;
  *(void *)(result + 1596) = 0x500000000LL;
  *(void *)(result + 1644) = 0x500000000LL;
  *(void *)(result + 1692) = 0LL;
  *(_DWORD *)(result + 1700) = 0;
  *(_BYTE *)(result + 1704) = 1;
  *(void *)(result + 1716) = 0LL;
  *(void *)(result + 1724) = 0LL;
  *(void *)(result + 1732) = 0xA00000000LL;
  *(void *)(result + 1780) = 0LL;
  *(_DWORD *)(result + 1788) = 0;
  *(_BYTE *)(result + 1792) = 1;
  *(void *)(result + 1820) = 0xA00000000LL;
  uint64_t v16 = 928LL;
  *(void *)(result + 1804) = 0LL;
  *(void *)(result + 1812) = 0LL;
  do
  {
    *(_DWORD *)(result + v16) = 10;
    v16 += 88LL;
  }

  while (v16 != 1104);
  for (uint64_t i = 1264LL; i != 1440; i += 88LL)
    *(_DWORD *)(result + i) = 10;
  for (uint64_t j = 384LL; j != 648; j += 88LL)
    *(_DWORD *)(result + j) = 10;
  return result;
}

uint64_t sub_100E090A8(uint64_t a1, float *a2, uint64_t a3)
{
  uint64_t result = sub_100E0934C(a1, a2, (uint64_t)v35, &v37, &v36);
  if ((_DWORD)result)
  {
    uint64_t result = sub_100E097B0(a1, (float *)&v37, (float *)&v36, v35);
    if ((_DWORD)result)
    {
      uint64_t v6 = a1 + 1740;
      uint64_t v7 = *(unsigned __int16 *)(a1 + 1732);
      unint64_t v8 = *(unsigned __int16 *)(a1 + 1734);
      unint64_t v9 = v7 + v8 - 1;
      unint64_t v10 = *(unsigned int *)(a1 + 1736);
      if (v9 < v10) {
        unint64_t v10 = 0LL;
      }
      float v11 = *(float *)(v6 + 4 * (v9 - v10));
      float v12 = *(float *)(v6 + 4 * v7);
      uint64_t v13 = a1 + 1828;
      uint64_t v14 = *(unsigned __int16 *)(a1 + 1820);
      uint64_t v15 = *(unsigned __int16 *)(a1 + 1822);
      unint64_t v16 = v14 + v15 - 1;
      unint64_t v17 = *(unsigned int *)(a1 + 1824);
      if (v16 < v17) {
        unint64_t v17 = 0LL;
      }
      float v18 = *(float *)(v13 + 4 * (v16 - v17));
      float v19 = *(float *)(v13 + 4 * v14);
      float v20 = 0.0;
      float v21 = 0.0;
      if (v8 >= 2)
      {
        unint64_t v22 = 1LL;
        do
        {
          float v23 = *(float *)sub_100208A44((unsigned __int16 *)(a1 + 1732), v22);
          float v21 = v21 + vabds_f32(v23, *(float *)sub_100208A44((unsigned __int16 *)(a1 + 1732), v22++ - 1));
        }

        while (v22 < *(unsigned __int16 *)(a1 + 1734));
        LODWORD(v15) = *(unsigned __int16 *)(a1 + 1822);
      }

      if (v15 >= 2)
      {
        float v20 = 0.0;
        unint64_t v24 = 1LL;
        do
        {
          float v25 = *(float *)sub_100208A44((unsigned __int16 *)(a1 + 1820), v24);
          float v20 = v20 + vabds_f32(v25, *(float *)sub_100208A44((unsigned __int16 *)(a1 + 1820), v24++ - 1));
        }

        while (v24 < *(unsigned __int16 *)(a1 + 1822));
      }

      float v26 = vabds_f32(v11, v12);
      if (*(_BYTE *)(a1 + 1704)) {
        sub_100E09D68(a1 + 1704);
      }
      float v27 = *(float *)(a1 + 1712);
      float v28 = 0.0;
      if (v27 < 0.0) {
        float v27 = 0.0;
      }
      *(float *)(a3 + 8) = sqrtf(v27);
      float v29 = vabds_f32(v18, v19);
      *(float *)(a3 + 16) = v26;
      *(float *)(a3 + 20) = v21;
      *(_DWORD *)(a3 + 12) = *(_DWORD *)sub_100208A44((unsigned __int16 *)(a1 + 1732), 5uLL);
      uint64_t v30 = a1 + 1596 + 8LL * *(unsigned __int16 *)(a1 + 1596);
      *(_DWORD *)(a3 + 24) = *(_DWORD *)(v30 + 8);
      *(_DWORD *)(a3 + 28) = *(_DWORD *)(v30 + 12);
      if (*(_BYTE *)(a1 + 1792)) {
        sub_100E09D68(a1 + 1792);
      }
      float v31 = *(float *)(a1 + 1800);
      if (v31 < 0.0) {
        float v31 = 0.0;
      }
      *(float *)(a3 + 32) = sqrtf(v31);
      *(float *)(a3 + 40) = v29;
      *(float *)(a3 + 44) = v20;
      *(_DWORD *)(a3 + 36) = *(_DWORD *)sub_100208A44((unsigned __int16 *)(a1 + 1820), 5uLL);
      uint64_t v32 = a1 + 1644 + 8LL * *(unsigned __int16 *)(a1 + 1644);
      *(_DWORD *)(a3 + 48) = *(_DWORD *)(v32 + 8);
      *(_DWORD *)(a3 + 52) = *(_DWORD *)(v32 + 12);
      unint64_t v33 = 0LL;
      *(CFAbsoluteTime *)a3 = CFAbsoluteTimeGetCurrent() + -10.0;
      do
        float v28 = v28 + *(float *)sub_100208A44((unsigned __int16 *)(a1 + 1480), v33++);
      while (v33 != 10);
      *(float *)(a3 + 56) = v28;
      char v34 = (_DWORD *)(a1 + 1528 + 12LL * *(unsigned __int16 *)(a1 + 1528));
      *(_DWORD *)(a3 + 60) = v34[2];
      *(_DWORD *)(a3 + 64) = v34[3];
      *(_DWORD *)(a3 + 68) = v34[4];
      return 1LL;
    }
  }

  return result;
}

uint64_t sub_100E0934C(uint64_t a1, float *a2, uint64_t a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v49 = __PAIR64__(LODWORD(v50[3]), LODWORD(v50[0]));
  unint64_t v48 = __PAIR64__(LODWORD(v50[5]), LODWORD(v50[2]));
  LODWORD(v46) = sub_100833470(a2);
  HIDWORD(v46) = v10;
  int v47 = v11;
  float v12 = (float *)sub_1004E2C54((uint64_t)&v49, 0LL);
  float v13 = sub_1007E0EF4((void *)(a1 + 840), 0LL, *v12);
  *(float *)(a1 + 848) = v13;
  *(float *)(a1 + 848) = sub_1007E0EF4((void *)(a1 + 840), 1LL, v13);
  uint64_t v14 = (float *)sub_1004E2C54((uint64_t)&v49, 1uLL);
  float v15 = sub_1007E0EF4((void *)(a1 + 880), 0LL, *v14);
  *(float *)(a1 + 888) = v15;
  *(float *)(a1 + 888) = sub_1007E0EF4((void *)(a1 + 880), 1LL, v15);
  unint64_t v16 = (float *)sub_1004E2C54((uint64_t)&v48, 0LL);
  float v17 = sub_1007E0EF4((void *)(a1 + 1176), 0LL, *v16);
  *(float *)(a1 + 1184) = v17;
  *(float *)(a1 + 1184) = sub_1007E0EF4((void *)(a1 + 1176), 1LL, v17);
  float v18 = (float *)sub_1004E2C54((uint64_t)&v48, 1uLL);
  float v19 = sub_1007E0EF4((void *)(a1 + 1216), 0LL, *v18);
  *(float *)(a1 + 1224) = v19;
  unint64_t v20 = 0LL;
  *(float *)(a1 + 1224) = sub_1007E0EF4((void *)(a1 + 1216), 1LL, v19);
  uint64_t v21 = a1 + 640;
  do
  {
    unint64_t v22 = (float *)sub_1002BA24C((uint64_t)&v46, v20);
    float v23 = sub_1007E0EF4((void *)v21, 0LL, *v22);
    *(float *)(v21 + 8) = v23;
    *(float *)(v21 + 8) = sub_1007E0EF4((void *)v21, 1LL, v23);
    ++v20;
    v21 += 40LL;
  }

  while (v20 != 3);
  int v24 = *(_DWORD *)(a1 + 1432);
  *(_DWORD *)(a1 + 1432) = v24 + 1;
  if (v24 <= 9) {
    return 0LL;
  }
  *(_DWORD *)(a1 + 1432) = 0;
  float v25 = sub_1007E0EF4((void *)(a1 + 760), 0LL, *(float *)(a1 + 848));
  *(float *)(a1 + 768) = v25;
  *(float *)(a1 + 768) = sub_1007E0EF4((void *)(a1 + 760), 1LL, v25);
  float v26 = sub_1007E0EF4((void *)(a1 + 800), 0LL, *(float *)(a1 + 888));
  *(float *)(a1 + 808) = v26;
  *(float *)(a1 + 808) = sub_1007E0EF4((void *)(a1 + 800), 1LL, v26);
  float v27 = sub_1007E0EF4((void *)(a1 + 1096), 0LL, *(float *)(a1 + 1184));
  *(float *)(a1 + 1104) = v27;
  *(float *)(a1 + 1104) = sub_1007E0EF4((void *)(a1 + 1096), 1LL, v27);
  float v28 = sub_1007E0EF4((void *)(a1 + 1136), 0LL, *(float *)(a1 + 1224));
  *(float *)(a1 + 1144) = v28;
  *(float *)(a1 + 1144) = sub_1007E0EF4((void *)(a1 + 1136), 1LL, v28);
  for (uint64_t i = 264LL; i != 384; i += 40LL)
  {
    uint64_t v30 = (float *)(a1 + i);
    float v31 = sub_1007E0EF4((void *)(a1 + i - 8), 0LL, *(float *)(a1 + i + 384));
    float *v30 = v31;
    float *v30 = sub_1007E0EF4((void *)(a1 + i - 8), 1LL, v31);
  }

  int v32 = *(_DWORD *)(a1 + 1436);
  *(_DWORD *)(a1 + 1436) = v32 + 1;
  if (v32 <= 9) {
    return 0LL;
  }
  *(_DWORD *)(a1 + 1436) = 0;
  int v45 = *(_DWORD *)(a1 + 768);
  (*(void (**)(uint64_t, int *))(*(void *)(a1 + 920) + 24LL))(a1 + 920, &v45);
  int v45 = *(_DWORD *)(a1 + 808);
  (*(void (**)(uint64_t, int *))(*(void *)(a1 + 1008) + 24LL))(a1 + 1008, &v45);
  int v45 = *(_DWORD *)(a1 + 1104);
  (*(void (**)(uint64_t, int *))(*(void *)(a1 + 1256) + 24LL))(a1 + 1256, &v45);
  int v45 = *(_DWORD *)(a1 + 1144);
  (*(void (**)(uint64_t, int *))(*(void *)(a1 + 1344) + 24LL))(a1 + 1344, &v45);
  uint64_t v33 = 0LL;
  char v34 = (void *)(a1 + 376);
  char v35 = (void *)(a1 + 376);
  unint64_t v36 = (void *)(a1 + 376);
  do
  {
    int v45 = *(_DWORD *)(a1 + 264 + v33);
    uint64_t v37 = *v36;
    v36 += 11;
    (*(void (**)(void *, int *))(v37 + 24))(v35, &v45);
    v33 += 40LL;
    char v35 = v36;
  }

  while (v33 != 120);
  if (*(void *)(a1 + 1000) != *(_DWORD *)(a1 + 928)) {
    return 0LL;
  }
  float32x2_t v38 = (_DWORD *)sub_1004E2C54((uint64_t)&v49, 0LL);
  sub_10074DE7C((void *)(a1 + 920), 2, v38);
  float32x2_t v39 = (_DWORD *)sub_1004E2C54((uint64_t)&v49, 1uLL);
  sub_10074DE7C((void *)(a1 + 1008), 2, v39);
  float v40 = (_DWORD *)sub_1004E2C54((uint64_t)&v48, 0LL);
  sub_10074DE7C((void *)(a1 + 1256), 2, v40);
  float v41 = (_DWORD *)sub_1004E2C54((uint64_t)&v48, 1uLL);
  sub_10074DE7C((void *)(a1 + 1344), 2, v41);
  for (unint64_t j = 0LL; j != 3; ++j)
  {
    float32x2_t v43 = (_DWORD *)sub_1002BA24C((uint64_t)&v46, j);
    sub_10074DE7C(v34, 2, v43);
    v34 += 11;
  }

  *(void *)a3 = v46;
  *(_DWORD *)(a3 + 8) = v47;
  *a4 = v49;
  *a5 = v48;
  sub_10040B364((unsigned __int16 *)(a1 + 1528), a3);
  sub_100E09C54((unsigned __int16 *)(a1 + 1596), a4);
  sub_100E09C54((unsigned __int16 *)(a1 + 1644), a5);
  return 1LL;
}

BOOL sub_100E097B0(uint64_t a1, float *a2, float *a3, float *a4)
{
  uint64_t v8 = 0LL;
  float v10 = *a4;
  float v9 = a4[1];
  float v11 = a4[2];
  *(float *)buf = *a4;
  unint64_t v72 = __PAIR64__(LODWORD(v11), LODWORD(v9));
  float v12 = 0.0;
  do
  {
    float v12 = v12 + (float)(*(float *)&buf[v8] * *(float *)&buf[v8]);
    v8 += 4LL;
  }

  while (v8 != 12);
  if (sqrtf(v12) > 0.00000011921)
  {
    uint64_t v13 = 0LL;
    float v14 = 0.0;
    do
    {
      float v14 = v14 + (float)(*(float *)&buf[v13] * *(float *)&buf[v13]);
      v13 += 4LL;
    }

    while (v13 != 12);
    float v15 = sqrtf(v14);
    float v10 = v10 / v15;
    float v9 = v9 / v15;
    float v11 = v11 / v15;
  }

  float v16 = *a2;
  float v17 = a2[1];
  float v18 = sqrtf((float)(v16 * v16) + (float)(v17 * v17));
  if (v18 > 0.00000011921)
  {
    float v16 = v16 / v18;
    float v17 = v17 / v18;
  }

  float v19 = *a3;
  float v20 = a3[1];
  float v21 = sqrtf((float)(v19 * v19) + (float)(v20 * v20));
  if (v21 > 0.00000011921)
  {
    float v19 = v19 / v21;
    float v20 = v20 / v21;
  }

  float v22 = *(float *)(a1 + 1440);
  if (v22 == -3.4028e38)
  {
    BOOL result = 0LL;
    *(float *)(a1 + 1440) = v10;
    *(float *)(a1 + 1444) = v9;
    *(float *)(a1 + 1448) = v11;
  }

  else
  {
    HIDWORD(v50) = acosf( fmaxf( fminf( (float)((float)(v11 * *(float *)(a1 + 1448)) + (float)(*(float *)(a1 + 1444) * v9))
                       + (float)(v22 * v10),
                         1.0),
                       -1.0));
    sub_1007E0E20(a1 + 1452, (float *)&v50 + 1);
    *(float *)(a1 + 1440) = v10;
    *(float *)(a1 + 1444) = v9;
    *(float *)(a1 + 1448) = v11;
    int v24 = (float *)(a1 + 1692);
    *(float *)(a1 + 1692) = atan2f(v17, v16);
    float v25 = (float *)(a1 + 1780);
    *(float *)(a1 + 1780) = atan2f(v20, v19);
    float v27 = sub_100E09CB4(v26, a1 + 1692);
    sub_100E09CB4((uint64_t)v27, a1 + 1780);
    unint64_t v28 = 0LL;
    float v29 = 0.0;
    do
      float v29 = v29 + *(float *)sub_100208A44((unsigned __int16 *)(a1 + 1480), v28++);
    while (v28 != 10);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101884A88);
    }
    uint64_t v30 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEBUG))
    {
      *(double *)&unint64_t v31 = *v24;
      double v32 = *v25;
      double v33 = *a2;
      double v34 = a2[1];
      double v35 = *a3;
      double v36 = a3[1];
      double v37 = *a4;
      double v38 = a4[1];
      double v39 = a4[2];
      *(_DWORD *)buf = 134220288;
      unint64_t v72 = v31;
      __int16 v73 = 2048;
      double v74 = v32;
      __int16 v75 = 2048;
      double v76 = v29;
      __int16 v77 = 2048;
      double v78 = v33;
      __int16 v79 = 2048;
      double v80 = v34;
      __int16 v81 = 2048;
      double v82 = v35;
      __int16 v83 = 2048;
      double v84 = v36;
      __int16 v85 = 2048;
      double v86 = v37;
      __int16 v87 = 2048;
      double v88 = v38;
      __int16 v89 = 2048;
      double v90 = v39;
      _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "headingCrown,%f,headingFace,%f,bodySum,%f,cx,%f,cy,%f,fx,%f,fy,%f,gx,%f,gy,%f,gz,%f",  buf,  0x66u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101884A88);
      }
      double v40 = *v24;
      double v41 = *v25;
      double v42 = *a2;
      double v43 = a2[1];
      double v44 = *a3;
      double v45 = a3[1];
      double v46 = *a4;
      double v47 = a4[1];
      double v48 = a4[2];
      int v51 = 134220288;
      double v52 = v40;
      __int16 v53 = 2048;
      double v54 = v41;
      __int16 v55 = 2048;
      double v56 = v29;
      __int16 v57 = 2048;
      double v58 = v42;
      __int16 v59 = 2048;
      double v60 = v43;
      __int16 v61 = 2048;
      double v62 = v44;
      __int16 v63 = 2048;
      double v64 = v45;
      __int16 v65 = 2048;
      double v66 = v46;
      __int16 v67 = 2048;
      double v68 = v47;
      __int16 v69 = 2048;
      double v70 = v48;
      LODWORD(v50) = 102;
      unint64_t v49 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  2LL,  "headingCrown,%f,headingFace,%f,bodySum,%f,cx,%f,cy,%f,fx,%f,fy,%f,gx,%f,gy,%f,gz,%f",  COERCE_DOUBLE(&v51),  v50);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWorkoutPredictorTurnDetector::accumulateAngleDeltas(const CMVector<float, 2> &, const CMVector<float, 2> &, const CMVector<float, 3> &)",  "%s\n",  v49);
    }

    return *(_DWORD *)(a1 + 1736) == *(unsigned __int16 *)(a1 + 1734);
  }

  return result;
}

unsigned __int16 *sub_100E09C54(unsigned __int16 *result, void *a2)
{
  unint64_t v2 = *((unsigned int *)result + 1);
  unint64_t v3 = *result + (unint64_t)result[1];
  if (v3 < v2) {
    unint64_t v2 = 0LL;
  }
  *(void *)&result[4 * (v3 - v2) + 4] = *a2;
  unsigned int v4 = result[1];
  unint64_t v5 = *((unsigned int *)result + 1);
  if (v5 <= v4)
  {
    unint64_t v6 = *result + 1LL;
    if (v6 < v5) {
      LOWORD(v5) = 0;
    }
    *BOOL result = v6 - v5;
  }

  else
  {
    result[1] = v4 + 1;
  }

  return result;
}

unsigned __int16 *sub_100E09CB4(uint64_t a1, uint64_t a2)
{
  float v2 = *(float *)a2;
  float v3 = *(float *)(a2 + 4);
  float v8 = v3;
  if (*(unsigned __int16 *)(a2 + 42) >= 2u)
  {
    if (vabds_f32(v2, v3) <= 3.1416)
    {
      int v5 = *(_DWORD *)(a2 + 8);
    }

    else
    {
      int v4 = *(_DWORD *)(a2 + 8);
      if (v2 < v3) {
        int v5 = v4 + 1;
      }
      else {
        int v5 = v4 - 1;
      }
      *(_DWORD *)(a2 + 8) = v5;
    }

    float v6 = v2 + (double)v5 * 6.28318531;
    float v8 = v6;
  }

  *(float *)(a2 + 4) = v2;
  return sub_1007E0E20(a2 + 12, &v8);
}

void sub_100E09D3C(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

uint64_t sub_100E09D68(uint64_t result)
{
  unsigned int v1 = *(unsigned __int16 *)(result + 30);
  if (v1 > 1)
  {
    float v4 = *(float *)(result + 12);
    float v2 = v4 / (float)v1;
    float v3 = (float)(*(float *)(result + 20) - (float)(v4 * v2)) / (float)v1;
  }

  else
  {
    float v2 = *(float *)(result + 12);
    float v3 = 0.0;
  }

  *(float *)(result + 4) = v2;
  *(float *)(result + 8) = v3;
  *(_BYTE *)BOOL result = 0;
  return result;
}

void sub_100E0A190( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100E0A2E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100E0A9BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_100E0AC54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100E0B86C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100E0B9AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100E0BAC4(id a1)
{
  qword_1019346A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Altimeter");
}

void sub_100E0BAF0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101884AD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E0BB04(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101884AD8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_100E0BB30(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101884B28;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E0BB44(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101884B28;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100E0BB70()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_10199EB90, (void *)&_mh_execute_header);
}

void sub_100E0BC58(id a1)
{
  qword_10199EC00 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLNatalimetryNotifierSilo");
}

uint64_t sub_100E0BD0C(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100E0DF74;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_10199EC20 != -1) {
    dispatch_once(&qword_10199EC20, block);
  }
  return qword_1019A20D0;
}

uint64_t sub_100E0BE90(uint64_t a1, float a2)
{
  uint64_t v11 = CMNatalimeterSetUserPal;
  float v12 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:");
  sub_100E13D68( a1,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v12,  &v11,  1LL),  1,  0LL);
  v6[1] = 2146435071;
  uint64_t v7 = 0LL;
  unint64_t v8 = 0xBFF0000000000000LL;
  uint64_t v9 = 0LL;
  v10[0] = 0LL;
  *(void *)((char *)v10 + 5) = 0LL;
  memset(&v10[2], 0, 24);
  *(float *)float v6 = a2;
  int v5 = 3;
  return (*(uint64_t (**)(uint64_t, int *, _DWORD *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v5,  v6,  1LL,  0xFFFFFFFFLL,  0LL);
}

void sub_100E0BFE8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 2752);
  __int128 v31 = *(_OWORD *)(v2 + 1352);
  float v3 = *(float *)(v2 + 1368);
  float v4 = *(float *)(v2 + 1388);
  int v5 = *(_DWORD *)(v2 + 1392);
  float v6 = *(float *)(v2 + 1396);
  float v32 = v3;
  __int128 v33 = *(_OWORD *)(v2 + 1372);
  float v34 = v4;
  int v35 = v5;
  float v36 = v6;
  uint64_t v37 = *(void *)(v2 + 1400);
  int v38 = *(_DWORD *)(v2 + 1408);
  if (sub_100E155C8(a1, (uint64_t)&v31))
  {
    if (v34 == v4)
    {
      if (v32 != v3)
      {
        if (v32 >= 0.0)
        {
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101884E60);
          }
          uint64_t v11 = (os_log_s *)qword_1019344D8;
          if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "UserProfile, Forcing a vo2max update.",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344D0 != -1) {
              dispatch_once(&qword_1019344D0, &stru_101884E60);
            }
            v30[0] = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "UserProfile, Forcing a vo2max update.",  v30,  2);
            int v24 = (uint8_t *)v23;
            sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryNotifier::refreshMetrics()", "%s\n", v23);
            if (v24 != buf) {
              free(v24);
            }
          }

          uint64_t v43 = CMNatalimeterSetUserVo2max;
          *(float *)&double v12 = v32;
          double v44 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v12);
          uint64_t v9 = &v44;
          float v10 = &v43;
        }

        else
        {
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101884E60);
          }
          unint64_t v8 = (os_log_s *)qword_1019344D8;
          if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "UserProfile, Forcing a vo2max clear.",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344D0 != -1) {
              dispatch_once(&qword_1019344D0, &stru_101884E60);
            }
            v30[0] = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "UserProfile, Forcing a vo2max clear.",  v30,  2);
            float v22 = (uint8_t *)v21;
            sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryNotifier::refreshMetrics()", "%s\n", v21);
            if (v22 != buf) {
              free(v22);
            }
          }

          uint64_t v45 = CMNatalimeterSetUserVo2max;
          double v46 = &off_1018D73C8;
          uint64_t v9 = (NSNumber **)&v46;
          float v10 = &v45;
        }

        sub_100E13D68( a1,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v9,  v10,  1LL),  0,  0LL);
      }

      if (v36 != v6)
      {
        if (v36 >= 0.0)
        {
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101884E60);
          }
          float v16 = (os_log_s *)qword_1019344D8;
          if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "UserProfile, Forcing a run vo2max update.",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344D0 != -1) {
              dispatch_once(&qword_1019344D0, &stru_101884E60);
            }
            v30[0] = 0;
            LODWORD(v29) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "UserProfile, Forcing a run vo2max update.",  v30,  v29);
            unint64_t v28 = (uint8_t *)v27;
            sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryNotifier::refreshMetrics()", "%s\n", v27);
            if (v28 != buf) {
              free(v28);
            }
          }

          uint64_t v17 = sub_1002F8DDC();
          buf[0] = 1;
          sub_1002AB464(v17, @"ActiveJacksonCalibration", buf);
          sub_100E0C81C(a1, 1);
          uint64_t v39 = CMNatalimeterSetUserRunVo2max;
          *(float *)&double v18 = v36;
          double v40 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v18);
          float v14 = &v40;
          float v15 = &v39;
        }

        else
        {
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101884E60);
          }
          uint64_t v13 = (os_log_s *)qword_1019344D8;
          if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "UserProfile, Forcing a run vo2max clear.",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344D0 != -1) {
              dispatch_once(&qword_1019344D0, &stru_101884E60);
            }
            v30[0] = 0;
            LODWORD(v29) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "UserProfile, Forcing a run vo2max clear.",  v30,  v29);
            uint64_t v26 = (uint8_t *)v25;
            sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryNotifier::refreshMetrics()", "%s\n", v25);
            if (v26 != buf) {
              free(v26);
            }
          }

          sub_100E0C81C(a1, 0);
          uint64_t v41 = CMNatalimeterSetUserRunVo2max;
          double v42 = &off_1018D73C8;
          float v14 = (NSNumber **)&v42;
          float v15 = &v41;
        }

        sub_100E13D68( a1,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v14,  v15,  1LL),  1,  0LL);
      }
    }

    else
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      uint64_t v7 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "UserProfile, Forcing a pal update.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        v30[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "UserProfile, Forcing a pal update.",  v30,  2);
        float v20 = (uint8_t *)v19;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryNotifier::refreshMetrics()", "%s\n", v19);
        if (v20 != buf) {
          free(v20);
        }
      }

      sub_100E0BE90(a1, v34);
    }
  }

void sub_100E0C81C(uint64_t a1, char a2)
{
  uint64_t v2 = (_BYTE *)(a1 + 392);
  *(_BYTE *)(a1 + 392) = a2;
  uint64_t v3 = sub_1002F8DDC();
  sub_1002AB464(v3, @"ActiveJacksonCalibration", v2);
  uint64_t v4 = sub_1002F8DDC();
  (*(void (**)(uint64_t))(*(void *)v4 + 944LL))(v4);
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  int v5 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *v2;
    *(_DWORD *)buf = 67109120;
    int v12 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "fActiveVo2maxOverride has been set to %d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v7 = *v2;
    v10[0] = 67109120;
    v10[1] = v7;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "fActiveVo2maxOverride has been set to %d",  v10);
    uint64_t v9 = (uint8_t *)v8;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryNotifier::setActiveVo2maxOverride(BOOL)", "%s\n", v8);
    if (v9 != buf) {
      free(v9);
    }
  }

id sub_100E0CA08(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 416)) {
    return &__NSDictionary0__struct;
  }
  uint64_t v1 = *(void *)(a1 + 2752);
  uint64_t v2 = -[NSMutableDictionary initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableDictionary), "initWithCapacity:", 6LL);
  if (*(_BYTE *)(v1 + 1409))
  {
    LODWORD(v3) = *(_DWORD *)(v1 + 1360);
    uint64_t v4 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v3);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v4,  CMNatalimeterSetUserHeightMeter);
  }

  if (*(_BYTE *)(v1 + 1410))
  {
    LODWORD(v3) = *(_DWORD *)(v1 + 1364);
    int v5 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v3);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v5,  CMNatalimeterSetUserWeightKG);
  }

  if (*(_BYTE *)(v1 + 1408))
  {
    LODWORD(v3) = *(_DWORD *)(v1 + 1372);
    int v6 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v3);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v6,  CMNatalimeterSetUserAgeYr);
  }

  int v7 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v1 + 1356));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v7,  CMNatalimeterSetUserBiologicalSex);
  unint64_t v8 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v1 + 1392));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v8,  CMNatalimeterSetUserCondition);
  uint64_t v9 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(v1 + 1400));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v9,  CMNatalimeterSetUserBetaBlockerUse);
  id v10 = -[NSMutableDictionary copy](v2, "copy");

  return v10;
}

id sub_100E0CB78(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 416)) {
    return &__NSDictionary0__struct;
  }
  uint64_t v2 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  11LL);
  uint64_t v4 = *(void *)(a1 + 2752);
  if (*(_BYTE *)(v4 + 1409))
  {
    LODWORD(v3) = *(_DWORD *)(v4 + 1360);
    int v5 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v3);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v5,  CMNatalimeterSetUserHeightMeter);
  }

  if (*(_BYTE *)(v4 + 1410))
  {
    LODWORD(v3) = *(_DWORD *)(v4 + 1364);
    int v6 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v3);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v6,  CMNatalimeterSetUserWeightKG);
  }

  if (*(_BYTE *)(v4 + 1408))
  {
    LODWORD(v3) = *(_DWORD *)(v4 + 1372);
    int v7 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v3);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v7,  CMNatalimeterSetUserAgeYr);
  }

  unint64_t v8 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v4 + 1356));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v8,  CMNatalimeterSetUserBiologicalSex);
  uint64_t v9 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v4 + 1392));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v9,  CMNatalimeterSetUserCondition);
  id v10 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(unsigned __int8 *)(v4 + 1400));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v10,  CMNatalimeterSetUserBetaBlockerUse);
  LODWORD(v11) = *(_DWORD *)(v4 + 1376);
  int v12 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v11);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v12,  CMNatalimeterSetUserHrmin);
  LODWORD(v13) = *(_DWORD *)(v4 + 1384);
  float v14 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v13);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v14,  CMNatalimeterSetUserHronset);
  LODWORD(v15) = *(_DWORD *)(v4 + 1368);
  float v16 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v15);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v16,  CMNatalimeterSetUserVo2max);
  LODWORD(v17) = *(_DWORD *)(v4 + 1396);
  double v18 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v17);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v18,  CMNatalimeterSetUserRunVo2max);
  LODWORD(v19) = *(_DWORD *)(v4 + 1404);
  float v20 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v19);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v2,  "setObject:forKeyedSubscript:",  v20,  CMNatalimeterSetUserAdaptiveExerciseMinuteThreshold);
  LODWORD(v21) = *(_DWORD *)(v4 + 1388);
  float v22 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v21);
  -[NSMutableDictionary setObject:forKeyedSubscript:](v2, "setObject:forKeyedSubscript:", v22, CMNatalimeterSetUserPal);
  id v23 = -[NSMutableDictionary copy](v2, "copy");

  return v23;
}

void sub_100E0CDD4(uint64_t a1, void *a2)
{
  v16[0] = CMNatalimeterSetUserBiologicalSex;
  v16[1] = CMNatalimeterSetUserAgeYr;
  v16[2] = CMNatalimeterSetUserWeightKG;
  _DWORD v16[3] = CMNatalimeterSetUserHeightMeter;
  v16[4] = CMNatalimeterSetUserCondition;
  v16[5] = CMNatalimeterSetUserBetaBlockerUse;
  uint64_t v4 = +[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v16, 6LL);
  id v5 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  id v6 = -[NSArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v11,  v15,  16LL);
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v12;
    do
    {
      for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v12 != v8) {
          objc_enumerationMutation(v4);
        }
        uint64_t v10 = *(void *)(*((void *)&v11 + 1) + 8LL * (void)i);
        if (![a2 objectForKeyedSubscript:v10]) {
          [v5 addObject:v10];
        }
      }

      id v7 = -[NSArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v11,  v15,  16LL);
    }

    while (v7);
  }

  sub_100E13D68(a1, a2, 1, v5);
}

void sub_100E0CFC4(uint64_t a1, void *a2)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  uint64_t v4 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412290;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "UserProfile, Resetting to defaults for keys, %@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v30 = 138412290;
    __int128 v31 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "UserProfile, Resetting to defaults for keys, %@",  &v30,  12);
    double v21 = (char *)v20;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::resetUserProfileForKeys(NSArray<NSString *> *)",  "%s\n",  v20);
  }

  v28[0] = CMNatalimeterSetUserBiologicalSex;
  v28[1] = CMNatalimeterSetUserPal;
  v29[0] = &off_1018D46D0;
  v29[1] = &off_1018D73A8;
  uint64_t v5 = CMNatalimeterSetUserVo2max;
  v28[2] = CMNatalimeterSetUserHrmin;
  v28[3] = CMNatalimeterSetUserVo2max;
  v29[2] = &off_1018D73B8;
  v29[3] = &off_1018D73C8;
  v28[4] = CMNatalimeterSetUserRunVo2max;
  v28[5] = CMNatalimeterSetUserHronset;
  v29[4] = &off_1018D73C8;
  v29[5] = &off_1018D73B8;
  v28[6] = CMNatalimeterSetUserCondition;
  v28[7] = CMNatalimeterSetUserBetaBlockerUse;
  v29[6] = &off_1018D46D0;
  v29[7] = &__kCFBooleanFalse;
  v28[8] = CMNatalimeterSetUserAdaptiveExerciseMinuteThreshold;
  v29[8] = &off_1018D73D8;
  id v6 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v29,  v28,  9LL);
  id v7 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  id v8 = [a2 countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v24;
    do
    {
      __int128 v11 = 0LL;
      do
      {
        if (*(void *)v24 != v10) {
          objc_enumerationMutation(a2);
        }
        __int128 v12 = *(void **)(*((void *)&v23 + 1) + 8LL * (void)v11);
        objc_msgSend( v7,  "setObject:forKeyedSubscript:",  -[NSDictionary objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", v12),  v12);
        if ([v12 isEqualToString:v5])
        {
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101884E60);
          }
          __int128 v13 = (os_log_s *)qword_1019344D8;
          if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "UserProfile, Resetting ActiveVo2Calibration, NumActiveCalibrations, and TimeFirstPAL.",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344D0 != -1) {
              dispatch_once(&qword_1019344D0, &stru_101884E60);
            }
            LOWORD(v30) = 0;
            LODWORD(v22) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "UserProfile, Resetting ActiveVo2Calibration, NumActiveCalibrations, and TimeFirstPAL.",  &v30,  v22);
            double v18 = (char *)v17;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::resetUserProfileForKeys(NSArray<NSString *> *)",  "%s\n",  v17);
          }

          sub_100E0C81C(a1, 0);
          uint64_t v14 = sub_1002F8DDC();
          *(_DWORD *)buf = 0;
          sub_1002AC288(v14, @"NumActiveCalibrations", buf);
          uint64_t v15 = sub_1002F8DDC();
          *(void *)buf = 0xFFEFFFFFFFFFFFFFLL;
          sub_1002AC820(v15, @"TimeFirstPAL", buf);
          uint64_t v16 = sub_1002F8DDC();
          (*(void (**)(uint64_t))(*(void *)v16 + 944LL))(v16);
        }

        __int128 v11 = (char *)v11 + 1;
      }

      while (v9 != v11);
      id v19 = [a2 countByEnumeratingWithState:&v23 objects:v27 count:16];
      id v9 = v19;
    }

    while (v19);
  }

  sub_100E13D68(a1, v7, 0, 0LL);
}

void sub_100E0D630( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E0D654(uint64_t a1, uint64_t a2, double a3, double a4)
{
  __p = 0LL;
  id v9 = 0LL;
  uint64_t v10 = 0LL;
  uint64_t v6 = sub_100F8FBE8(*(void *)(a1 + 128), &__p, a3, a4);
  if ((_DWORD)v6 == 100) {
    sub_100282000((double **)&__p, a2, a3);
  }
  if (__p)
  {
    id v9 = __p;
    operator delete(__p);
  }

  return v6;
}

void sub_100E0D6D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E0DADC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E0DB24(uint64_t a1, xpc_activity_t activity)
{
  if (!activity)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    id v7 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Invalid xpc activity.", buf, 2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "Invalid xpc activity.");
LABEL_31:
    __int128 v12 = (uint8_t *)v8;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNatalimetryNotifier::onCalorieAggregationActivity(xpc_activity_t)",  "%s\n",  v8);
    if (v12 != buf) {
      free(v12);
    }
    return;
  }

  xpc_activity_state_t state = xpc_activity_get_state(activity);
  if (state == 4 || (xpc_activity_state_t v5 = state, state == 2))
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    uint64_t v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Running aggregation for calorie-related tables",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      LOWORD(v13) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "Running aggregation for calorie-related tables",  &v13,  2);
      __int128 v11 = (uint8_t *)v10;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::onCalorieAggregationActivity(xpc_activity_t)",  "%s\n",  v10);
      if (v11 != buf) {
        free(v11);
      }
    }

    sub_100E1169C(a1, activity);
    return;
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  id v9 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134217984;
    xpc_activity_state_t v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Unexpected activity state: %ld", buf, 0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "Unexpected activity state: %ld",  &v13);
    goto LABEL_31;
  }

void sub_100E0DF44(id a1)
{
  if (sub_1004F7000())
  {
    if (sub_1008FA690()) {
      byte_10199EC10 = 1;
    }
  }

uint64_t sub_100E0DF74(uint64_t a1)
{
  uint64_t v2 = operator new(0x1450uLL);
  uint64_t result = sub_100E0E0EC((uint64_t)v2, *(void **)(a1 + 32));
  qword_1019A20D0 = (uint64_t)v2;
  return result;
}

void sub_100E0DFAC(_Unwind_Exception *a1)
{
}

uint64_t sub_100E0DFC0(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100E0E034;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_10199EC30 != -1) {
    dispatch_once(&qword_10199EC30, block);
  }
  return byte_10199EC28;
}

id sub_100E0E034(uint64_t a1)
{
  id result = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "isServiceEnabled:", @"CLNatalimetryNotifier");
  byte_10199EC28 = (char)result;
  return result;
}

unsigned __int8 *sub_100E0E060@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  id result = sub_101204164(v6, "MotionLoggerPostWorkoutLoggingInterval", &qword_10135F4C8, 0);
  if (v6[0]
    || (id result = (unsigned __int8 *)objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "isServiceEnabled:",  @"CLWorkoutRecorder"),  (_DWORD)result))
  {
    *(_BYTE *)a2 = 1;
    uint64_t v5 = v7;
    *(void *)(a2 + 8) = v7;
  }

  else
  {
    *(_BYTE *)a2 = 0;
    *(void *)(a2 + 8) = 0x403E000000000000LL;
    uint64_t v5 = v7;
  }

  *(void *)(a2 + 16) = v5;
  return result;
}

uint64_t sub_100E0E0EC(uint64_t a1, void *a2)
{
  double v3 = (void *)sub_100E0F3E8(a1, "CLNatalimetryNotifier", a2);
  v3[14] = off_101884CC8;
  uint64_t v4 = (uint64_t)(v3 + 14);
  v3[15] = off_101884D00;
  uint64_t v5 = (uint64_t)(v3 + 15);
  *double v3 = off_101884BB8;
  uint64_t v6 = operator new(0x208uLL);
  sub_100F8E1B8(v6, 0LL);
  sub_100282760((void *)(a1 + 128), (uint64_t)v6);
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 136);
  uint64_t v113 = *(void *)(a1 + 128);
  float v114 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  sub_1001B4E14(a1 + 144, &v113);
  uint64_t v10 = v114;
  if (v114)
  {
    __int128 v11 = (unint64_t *)&v114->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  __int128 v13 = operator new(0x178uLL);
  sub_100711C44(v13, 0);
  sub_100E1D8F0((void *)(a1 + 192), (uint64_t)v13);
  uint64_t v14 = *(std::__shared_weak_count **)(a1 + 200);
  uint64_t v111 = *(void *)(a1 + 192);
  float v112 = v14;
  if (v14)
  {
    xpc_activity_state_t v15 = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }

  sub_1001B4E14(a1 + 208, &v111);
  double v17 = v112;
  if (v112)
  {
    double v18 = (unint64_t *)&v112->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  LOBYTE(v115[0]) = 0;
  sub_100E1D9B0((unsigned __int8 *)v115, (void *)(a1 + 256));
  float v20 = *(std::__shared_weak_count **)(a1 + 264);
  uint64_t v109 = *(void *)(a1 + 256);
  unint64_t v110 = v20;
  if (v20)
  {
    double v21 = (unint64_t *)&v20->__shared_owners_;
    do
      unint64_t v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }

  sub_1001B4E14(a1 + 272, &v109);
  __int128 v23 = v110;
  if (v110)
  {
    __int128 v24 = (unint64_t *)&v110->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  LOBYTE(v115[0]) = 0;
  sub_100E1DAA0((unsigned __int8 *)v115, (void *)(a1 + 320));
  LOBYTE(v115[0]) = 0;
  sub_100E1DB90((unsigned __int8 *)v115, (void *)(a1 + 336));
  buf[0] = 0;
  sub_1012049AC((unsigned __int8 *)(a1 + 352), "LogBinaryNatalimetryOutputs", buf, 0);
  *(void *)(a1 + 360) = 0LL;
  *(void *)(a1 + 368) = 0LL;
  *(_WORD *)(a1 + 376) = 1;
  *(void *)(a1 + 384) = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  *(_BYTE *)(a1 + 392) = 0;
  buf[0] = 0;
  sub_1012049AC((unsigned __int8 *)(a1 + 393), "SimulateVo2MaxEstimates", buf, 0);
  *(void *)(a1 + 396) = 0x8000000000000002LL;
  *(void *)(a1 + 408) = 0LL;
  *(_BYTE *)(a1 + 416) = 0;
  sub_100E0E060(a1, a1 + 424);
  sub_100E1DC80((void *)(a1 + 448), "GPS", *(void **)(a1 + 32), 0, 10.0, 10.0, *(double *)(a1 + 440));
  sub_100E1E5EC((void *)(a1 + 592), "Elevation", *(void **)(a1 + 32), 0, 30.0, 10.0, *(double *)(a1 + 432));
  sub_100E1F43C((void *)(a1 + 992), "CoarseElevation", *(void **)(a1 + 32), 0, 30.0, 200.0, *(double *)(a1 + 432));
  sub_100E2066C((void *)(a1 + 1136), "Catherine", *(void **)(a1 + 32), 0, 35.0, 8.0, *(double *)(a1 + 432));
  double v26 = *(double *)(a1 + 432);
  *(void *)(a1 + 1288) = strdup("RawHR");
  *(void *)(a1 + 1296) = 0x4020000000000000LL;
  *(_OWORD *)(a1 + 1304) = 0u;
  *(_OWORD *)(a1 + 1320) = 0u;
  *(_OWORD *)(a1 + 1336) = 0u;
  *(void *)(a1 + 1280) = off_101885E28;
  *(void *)(a1 + 1352) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 1360) = 0;
  *(void *)(a1 + 1368) = 0LL;
  *(_OWORD *)(a1 + 1376) = xmmword_10135F4A0;
  *(double *)(a1 + 1392) = v26;
  *(_WORD *)(a1 + 1400) = 0;
  sub_100E218E8((void *)(a1 + 1408), "StepCount", *(void **)(a1 + 32), 1, 10.0, 0.1, v26);
  double v27 = *(double *)(a1 + 432);
  *(void *)(a1 + 1552) = off_101863548;
  *(void *)(a1 + 1560) = strdup("Activity");
  *(void *)(a1 + 1568) = 0x7FEFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 1576) = 0u;
  *(_OWORD *)(a1 + 1592) = 0u;
  *(_OWORD *)(a1 + 1608) = 0u;
  *(void *)(a1 + 1552) = off_101863680;
  *(_OWORD *)(a1 + 1648) = xmmword_10135F4B0;
  *(double *)(a1 + 1664) = v27;
  *(_WORD *)(a1 + 1672) = 256;
  *(void *)(a1 + 1624) = 0LL;
  *(_BYTE *)(a1 + 1632) = 1;
  *(void *)(a1 + 1640) = 0x7FEFFFFFFFFFFFFFLL;
  sub_100E22600((void *)(a1 + 1680), "Swim", *(void **)(a1 + 32), 0, 10.0, 5.0, v27);
  sub_100E232E4((void *)(a1 + 1824), "FitnessMachine", *(void **)(a1 + 32), 0, 10.0, 5.0, *(double *)(a1 + 432));
  v117[0] = &off_101886348;
  v117[1] = a1;
  float v118 = v117;
  sub_100E1ACE4(a1 + 1968, (uint64_t)v117);
  unint64_t v28 = v118;
  if (v118 == v117)
  {
    uint64_t v29 = 4LL;
    unint64_t v28 = v117;
  }

  else
  {
    if (!v118) {
      goto LABEL_30;
    }
    uint64_t v29 = 5LL;
  }

  (*(void (**)(void))(*v28 + 8 * v29))();
LABEL_30:
  int v30 = operator new(0x590uLL);
  *(void *)&__int128 v100 = a1 + 2000;
  *((void *)&v100 + 1) = a1 + 2320;
  *((void *)&v99 + 1) = a1 + 2160;
  *(void *)&__int128 v99 = a1 + 1824;
  sub_1003DA5C8( (uint64_t)v30,  a1 + 1136,  a1 + 448,  a1 + 592,  a1 + 992,  a1 + 1408,  a1 + 1552,  a1 + 1680,  v99,  v100,  a1 + 2480,  a1 + 1280);
  sub_100E243EC((void *)(a1 + 2752), (uint64_t)v30);
  __int128 v31 = (uint64_t *)(a1 + 2768);
  *(_DWORD *)(a1 + 2800) = 0;
  *(_OWORD *)(a1 + 2784) = 0u;
  *(_OWORD *)(a1 + 2768) = 0u;
  *(void *)(a1 + 2808) = 0xFFEFFFFFFFFFFFFFLL;
  *(void *)(a1 + 2816) = 0LL;
  *(void *)(a1 + 2824) = 0x7FF0000000000000LL;
  *(void *)(a1 + 2832) = 0LL;
  *(_BYTE *)(a1 + 2840) = 0;
  *(int64x2_t *)(a1 + 2848) = vdupq_n_s64(0xFFF0000000000000LL);
  *(void *)(a1 + 2864) = 0LL;
  *(_DWORD *)(a1 + 2872) = 0;
  *(CFAbsoluteTime *)(a1 + 2880) = CFAbsoluteTimeGetCurrent();
  *(_BYTE *)(a1 + 2888) = 0;
  nullsub_10(a1 + 2889);
  nullsub_10(a1 + 2890);
  LOBYTE(v115[0]) = 0;
  sub_10028E878((unsigned __int8 *)v115, (void *)(a1 + 2896));
  sub_1004F2598();
  *(_DWORD *)(a1 + 2912) = sub_1004F2690();
  float v32 = *(std::__shared_weak_count **)(a1 + 2904);
  uint64_t v107 = *(void *)(a1 + 2896);
  float v108 = v32;
  if (v32)
  {
    __int128 v33 = (unint64_t *)&v32->__shared_owners_;
    do
      unint64_t v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }

  LOBYTE(v115[0]) = 0;
  sub_1012049AC(buf, "FallStatsEnabled", (unsigned __int8 *)v115, 0);
  uint64_t v35 = buf[1];
  float v36 = *(std::__shared_weak_count **)(a1 + 264);
  uint64_t v105 = *(void *)(a1 + 256);
  float v106 = v36;
  if (v36)
  {
    uint64_t v37 = (unint64_t *)&v36->__shared_owners_;
    do
      unint64_t v38 = __ldxr(v37);
    while (__stxr(v38 + 1, v37));
  }

  sub_100C7FDDC(a1 + 2920, &v107, v35, &v105, *(unsigned int *)(a1 + 2912));
  uint64_t v39 = v106;
  if (v106)
  {
    double v40 = (unint64_t *)&v106->__shared_owners_;
    do
      unint64_t v41 = __ldaxr(v40);
    while (__stlxr(v41 - 1, v40));
    if (!v41)
    {
      ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
      std::__shared_weak_count::__release_weak(v39);
    }
  }

  double v42 = v108;
  if (v108)
  {
    uint64_t v43 = (unint64_t *)&v108->__shared_owners_;
    do
      unint64_t v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
  }

  uint64_t v45 = *(std::__shared_weak_count **)(a1 + 344);
  uint64_t v103 = *(void *)(a1 + 336);
  int v104 = v45;
  if (v45)
  {
    double v46 = (unint64_t *)&v45->__shared_owners_;
    do
      unint64_t v47 = __ldxr(v46);
    while (__stxr(v47 + 1, v46));
  }

  sub_1005B29AC(a1 + 4616, &v103);
  double v48 = v104;
  if (v104)
  {
    unint64_t v49 = (unint64_t *)&v104->__shared_owners_;
    do
      unint64_t v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }

  sub_100281FFC((void *)(a1 + 4736), 0LL);
  *(_DWORD *)(a1 + 4784) = 1;
  uint64_t v51 = a1 + 4792;
  *(void *)(a1 + 4848) = 0LL;
  *(_OWORD *)(a1 + 4792) = 0u;
  *(_OWORD *)(a1 + 4808) = 0u;
  *(_OWORD *)(a1 + 4824) = 0u;
  *(_BYTE *)(a1 + 4840) = 0;
  *(void *)(a1 + 4856) = 0x4334000042820000LL;
  *(_OWORD *)(a1 + 4864) = 0u;
  *(_OWORD *)(a1 + 4880) = 0u;
  *(_OWORD *)(a1 + 4896) = 0u;
  *(void *)(a1 + 4912) = 0LL;
  *(_DWORD *)buf = 1084227584;
  sub_101206C88((unsigned __int8 *)(a1 + 4920), "AdaptiveExerciseMinuteThresholdMaxPercentIncreasePerDay", buf, 0);
  *(_DWORD *)buf = 1097859072;
  sub_101206C88((unsigned __int8 *)(a1 + 4932), "AdaptiveExerciseMinuteThresholdMaxPercentDecreasePerDay", buf, 0);
  sub_100F1BBCC(a1 + 4944, 0LL);
  *(void *)(a1 + 5184) = dispatch_queue_create("CLNatalimetryNotifier.OffSiloQueue", 0LL);
  *(void *)(a1 + 5192) = 0LL;
  int v52 = *(_DWORD *)(a1 + 4784);
  __int16 v53 = *(std::__shared_weak_count **)(a1 + 2760);
  uint64_t v101 = *(void *)(a1 + 2752);
  unint64_t v102 = v53;
  if (v53)
  {
    double v54 = (unint64_t *)&v53->__shared_owners_;
    do
      unint64_t v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
  }

  sub_1005C8534(v52 == 2, v4, &v101, buf);
  uint64_t v56 = *(void *)buf;
  *(void *)buf = 0LL;
  uint64_t v57 = *v31;
  *__int128 v31 = v56;
  if (v57)
  {
    (*(void (**)(uint64_t))(*(void *)v57 + 48LL))(v57);
    uint64_t v58 = *(void *)buf;
    *(void *)buf = 0LL;
    if (v58) {
      (*(void (**)(uint64_t))(*(void *)v58 + 48LL))(v58);
    }
  }

  __int16 v59 = v102;
  if (v102)
  {
    double v60 = (unint64_t *)&v102->__shared_owners_;
    do
      unint64_t v61 = __ldaxr(v60);
    while (__stlxr(v61 - 1, v60));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }

  sub_100251780(v5, buf);
  uint64_t v62 = *(void *)buf;
  *(void *)buf = 0LL;
  uint64_t v63 = *(void *)(a1 + 2776);
  *(void *)(a1 + 2776) = v62;
  if (v63)
  {
    (*(void (**)(uint64_t))(*(void *)v63 + 48LL))(v63);
    uint64_t v64 = *(void *)buf;
    *(void *)buf = 0LL;
    if (v64) {
      (*(void (**)(uint64_t))(*(void *)v64 + 48LL))(v64);
    }
  }

  sub_100468458((uint64_t)sub_100E0F484, a1, *(void **)(a1 + 32), buf);
  uint64_t v65 = *(void *)buf;
  *(void *)buf = 0LL;
  uint64_t v66 = *(void *)v51;
  *(void *)uint64_t v51 = v65;
  if (v66)
  {
    (*(void (**)(uint64_t))(*(void *)v66 + 8LL))(v66);
    uint64_t v67 = *(void *)buf;
    *(void *)buf = 0LL;
    if (v67) {
      (*(void (**)(uint64_t))(*(void *)v67 + 8LL))(v67);
    }
  }

  [*(id *)(*(void *)v51 + 16) register:*(void *)(*(void *)v51 + 8) forNotification:0 registrationInfo:0];
  [*(id *)(*(void *)v51 + 16) register:*(void *)(*(void *)v51 + 8) forNotification:2 registrationInfo:0];
  sub_10070EDF0((uint64_t)sub_100E0F4D4, a1, *(void **)(a1 + 32), buf);
  uint64_t v68 = *(void *)buf;
  *(void *)buf = 0LL;
  uint64_t v69 = *(void *)(a1 + 4808);
  *(void *)(a1 + 4808) = v68;
  if (v69)
  {
    (*(void (**)(uint64_t))(*(void *)v69 + 8LL))(v69);
    uint64_t v70 = *(void *)buf;
    *(void *)buf = 0LL;
    if (v70) {
      (*(void (**)(uint64_t))(*(void *)v70 + 8LL))(v70);
    }
  }

  [*(id *)(*(void *)(a1 + 4808) + 16) register:*(void *)(*(void *)(a1 + 4808) + 8) forNotification:2 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 4808) + 16) register:*(void *)(*(void *)(a1 + 4808) + 8) forNotification:3 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 4808) + 16) register:*(void *)(*(void *)(a1 + 4808) + 8) forNotification:5 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 4808) + 16) register:*(void *)(*(void *)(a1 + 4808) + 8) forNotification:7 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 4808) + 16) register:*(void *)(*(void *)(a1 + 4808) + 8) forNotification:6 registrationInfo:0];
  sub_100ACD980((uint64_t)sub_100E0F6AC, a1, *(void **)(a1 + 32), buf);
  uint64_t v71 = *(void *)buf;
  *(void *)buf = 0LL;
  uint64_t v72 = *(void *)(a1 + 4800);
  *(void *)(a1 + 4800) = v71;
  if (v72)
  {
    (*(void (**)(uint64_t))(*(void *)v72 + 8LL))(v72);
    uint64_t v73 = *(void *)buf;
    *(void *)buf = 0LL;
    if (v73) {
      (*(void (**)(uint64_t))(*(void *)v73 + 8LL))(v73);
    }
  }

  [*(id *)(*(void *)(a1 + 4800) + 16) register:*(void *)(*(void *)(a1 + 4800) + 8) forNotification:0 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 4800) + 16) register:*(void *)(*(void *)(a1 + 4800) + 8) forNotification:1 registrationInfo:0];
  id v74 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "proxyForService:", @"CLDataProtectionManager");
  *(_BYTE *)(a1 + 376) = [v74 syncgetDataAvailability] == 0;
  *(_BYTE *)(a1 + 377) = [v74 syncgetDeviceUnlockedSinceFirstBoot];

  sub_1003A09BC((uint64_t)sub_100E0F884, a1, *(void **)(a1 + 32), buf);
  uint64_t v75 = *(void *)buf;
  *(void *)buf = 0LL;
  uint64_t v76 = *(void *)(a1 + 4816);
  *(void *)(a1 + 4816) = v75;
  if (v76)
  {
    (*(void (**)(uint64_t))(*(void *)v76 + 8LL))(v76);
    uint64_t v77 = *(void *)buf;
    *(void *)buf = 0LL;
    if (v77) {
      (*(void (**)(uint64_t))(*(void *)v77 + 8LL))(v77);
    }
  }

  [*(id *)(*(void *)(a1 + 4816) + 16) register:*(void *)(*(void *)(a1 + 4816) + 8) forNotification:6 registrationInfo:0];
  sub_1005C4E40((uint64_t)sub_100E0FA38, a1, *(void **)(a1 + 32), buf);
  uint64_t v78 = *(void *)buf;
  *(void *)buf = 0LL;
  uint64_t v79 = *(void *)(a1 + 4824);
  *(void *)(a1 + 4824) = v78;
  if (v79)
  {
    (*(void (**)(uint64_t))(*(void *)v79 + 8LL))(v79);
    uint64_t v80 = *(void *)buf;
    *(void *)buf = 0LL;
    if (v80) {
      (*(void (**)(uint64_t))(*(void *)v80 + 8LL))(v80);
    }
  }

  [*(id *)(*(void *)(a1 + 4824) + 16) register:*(void *)(*(void *)(a1 + 4824) + 8) forNotification:0 registrationInfo:0];
  sub_10060B0A4((uint64_t)sub_100E0FC10, a1, *(void **)(a1 + 32), buf);
  uint64_t v81 = *(void *)buf;
  *(void *)buf = 0LL;
  uint64_t v82 = *(void *)(a1 + 4832);
  *(void *)(a1 + 4832) = v81;
  if (v82)
  {
    (*(void (**)(uint64_t))(*(void *)v82 + 8LL))(v82);
    uint64_t v83 = *(void *)buf;
    *(void *)buf = 0LL;
    if (v83) {
      (*(void (**)(uint64_t))(*(void *)v83 + 8LL))(v83);
    }
  }

  [*(id *)(*(void *)(a1 + 4832) + 16) register:*(void *)(*(void *)(a1 + 4832) + 8) forNotification:4 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 4832) + 16) register:*(void *)(*(void *)(a1 + 4832) + 8) forNotification:5 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 4832) + 16) register:*(void *)(*(void *)(a1 + 4832) + 8) forNotification:0 registrationInfo:0];
  double v84 = operator new(0x38uLL);
  sub_1003DE40C(v84, *(void **)(a1 + 40), (uint64_t)sub_100E0FDE8, a1, 0LL);
  *(void *)(a1 + 408) = v84;
  uint64_t v85 = sub_1008FA854(0);
  sub_1006DCB40(v85, 4, *(void *)(a1 + 408), -1.0);
  uint64_t v86 = sub_1002F8DDC();
  __int16 v87 = (unsigned __int8 *)(a1 + 392);
  if (sub_1002A6FD4(v86, (uint64_t)@"ActiveJacksonCalibration", (BOOL *)(a1 + 392)))
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    double v88 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      int v89 = *v87;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v89;
      _os_log_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_DEBUG,  "Found vo2max calibration override flag,%d ",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      int v96 = *v87;
      v115[0] = 67109120;
      v115[1] = v96;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Found vo2max calibration override flag,%d ",  v115);
      unint64_t v98 = (uint8_t *)v97;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLNatalimetryNotifier::CLNatalimetryNotifier(id<CLIntersiloUniverse>)",  "%s\n",  v97);
      if (v98 != buf) {
        free(v98);
      }
    }
  }

  *(_BYTE *)(a1 + 184) = 1;
  *(_BYTE *)(a1 + 248) = 1;
  sub_100E0FFB8((id *)a1);
  sub_100E1012C((void *)a1);
  LOBYTE(v115[0]) = 0;
  sub_1012049AC(buf, "SimulateCyclingPowerMetersFromMets", (unsigned __int8 *)v115, 0);
  sub_100F1BC1C(a1 + 4944, buf[1]);
  sub_100E101C8(a1, (__int128 *)(*(void *)(a1 + 2752) + 1352LL));
  if (!*(_BYTE *)(a1 + 376)) {
    sub_100E102F0(a1);
  }
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver( DarwinNotifyCenter,  (const void *)a1,  (CFNotificationCallback)sub_100E105DC,  @"NanolifestyleSessionTrackerAppForegroundedNotification",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  int v91 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver( v91,  (const void *)a1,  (CFNotificationCallback)sub_100E105DC,  @"NanolifestyleSessionTrackerAppForegroundedForMachinePairingNotification",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  float v92 = -[CLDeviceMotionProperties initWithMode:]( objc_alloc(&OBJC_CLASS___CLDeviceMotionProperties),  "initWithMode:",  3LL);
  float v93 = operator new(0x38uLL);
  sub_1011C06A0(v93, *(void **)(a1 + 40), (uint64_t)sub_100E107FC, a1, v92);
  uint64_t v94 = *(void *)(a1 + 5192);
  *(void *)(a1 + 5192) = v93;
  if (v94) {
    (*(void (**)(uint64_t))(*(void *)v94 + 8LL))(v94);
  }

  return a1;
}

void sub_100E0F020( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36)
{
  uint64_t v43 = v36[649];
  v36[649] = 0LL;
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8LL))(v43);
  }
  sub_100E1D544(v37);
  sub_100231C10(v36 + 608);
  uint64_t v44 = v36[604];
  v36[604] = 0LL;
  if (v44) {
    (*(void (**)(uint64_t))(*(void *)v44 + 8LL))(v44);
  }
  uint64_t v45 = v36[603];
  v36[603] = 0LL;
  if (v45) {
    (*(void (**)(uint64_t))(*(void *)v45 + 8LL))(v45);
  }
  uint64_t v46 = v36[602];
  v36[602] = 0LL;
  if (v46) {
    (*(void (**)(uint64_t))(*(void *)v46 + 8LL))(v46);
  }
  uint64_t v47 = v36[601];
  v36[601] = 0LL;
  if (v47) {
    (*(void (**)(uint64_t))(*(void *)v47 + 8LL))(v47);
  }
  uint64_t v48 = v36[600];
  v36[600] = 0LL;
  if (v48) {
    (*(void (**)(uint64_t))(*(void *)v48 + 8LL))(v48);
  }
  uint64_t v49 = *v40;
  *double v40 = 0LL;
  if (v49) {
    (*(void (**)(uint64_t))(*(void *)v49 + 8LL))(v49);
  }
  sub_100E109D0(a15);
  sub_10000AE14(a16);
  sub_100E10A00(a17);
  sub_10000AE14(a18);
  __n128 v50 = nullsub_10(a19);
  uint64_t v51 = v36[347];
  v36[347] = 0LL;
  if (v51) {
    (*(void (**)(uint64_t, __n128))(*(void *)v51 + 48LL))(v51, v50);
  }
  uint64_t v52 = *v38;
  *unint64_t v38 = 0LL;
  if (v52) {
    (*(void (**)(uint64_t, __n128))(*(void *)v52 + 48LL))(v52, v50);
  }
  sub_10000AE14(a20);
  sub_100E1D5EC(a21);
  sub_100E247D0(a31);
  sub_100E24768(a22);
  sub_10098A93C(v41);
  sub_100E24700(a32);
  sub_100E10A8C(v39);
  sub_100E24698(a33);
  sub_100E24630(a34);
  sub_100E245B0(a35);
  sub_100E24548(a36);
  uint64_t v53 = v36[46];
  v36[46] = 0LL;
  if (v53) {
    (*(void (**)(uint64_t))(*(void *)v53 + 8LL))(v53);
  }
  sub_10000AE14(a23);
  sub_10000AE14(a24);
  sub_1001B4FBC(a25);
  sub_10000AE14(a26);
  sub_1001B4FBC(a27);
  sub_10000AE14(a28);
  sub_1001B4FBC(a29);
  sub_10000AE14(a30);
  sub_100E10ADC((uint64_t)v36);
  _Unwind_Resume(a1);
}

uint64_t sub_100E0F3E8(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_101885798;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = [a3 silo];
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 80) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 108) = 0;
  return a1;
}

void sub_100E0F468(_Unwind_Exception *exception_object)
{
}

void sub_100E0F484(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
}

void sub_100E0F4D4(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101884E40);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v12 = 1;
    unint64_t v9 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLNatalimetryNotifier::onCatherineNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v9, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v14 = 0;
      __int16 v15 = 2082;
      unint64_t v16 = "";
      __int16 v17 = 2082;
      double v18 = "activity";
      __int16 v19 = 2050;
      uint64_t v20 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLNatalimetryNotifier::onCatherineNotification, event:%{public, location:escape_onl y}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v12 = 0;
  }

  sub_100E16CE8(a4, v8, v7, a2, a3);
  if (v12) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E0F68C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E0F6AC(uint64_t a1, _DWORD *a2, int *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101884E40);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    CFAbsoluteTime v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLNatalimetryNotifier::onDataProtectionNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    unint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLNatalimetryNotifier::onDataProtectionNotification, event:%{public, location:escap e_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100E17528(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E0F864( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E0F884(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101884E40);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v8 = 1;
    uint64_t v5 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLNatalimetryNotifier::onCompanionNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v5, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    uint64_t v6 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v10 = 0;
      __int16 v11 = 2082;
      char v12 = "";
      __int16 v13 = 2082;
      __int16 v14 = "activity";
      __int16 v15 = 2050;
      uint64_t v16 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLNatalimetryNotifier::onCompanionNotification, event:%{public, location:escape_onl y}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v8 = 0;
  }

  if (v8) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E0FA1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E0FA38(uint64_t a1, _DWORD *a2, int *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101884E40);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    char v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLNatalimetryNotifier::onWatchOrientationSettingsNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    unint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLNatalimetryNotifier::onWatchOrientationSettingsNotification, event:%{public, loca tion:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100E179C0(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E0FBF0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E0FC10(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101884E40);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    char v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLNatalimetryNotifier::onFitnessTrackingNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    unint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      __int16 v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLNatalimetryNotifier::onFitnessTrackingNotification, event:%{public, location:esca pe_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100E17B9C(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E0FDC8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E0FDE8(uint64_t a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101884E40);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLNatalimetryNotifier::onStoredUserInfo",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      char v11 = "";
      __int16 v12 = 2082;
      int v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLNatalimetryNotifier::onStoredUserInfo, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100E177E0(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E0FF98( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E0FFB8(id *a1)
{
  int v11 = 7200;
  uint64_t v2 = sub_1006E27E8();
  sub_100413284(v2, &v9);
  sub_1002A7CB0(v9, "CalorieAggregationTimeInterval", &v11);
  double v3 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  xpc_object_t v6 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_BOOL(v6, XPC_ACTIVITY_REPEATING, 1);
  xpc_dictionary_set_int64(v6, XPC_ACTIVITY_INTERVAL, v11);
  xpc_dictionary_set_BOOL(v6, XPC_ACTIVITY_ALLOW_BATTERY, 1);
  id v7 = objc_msgSend(objc_msgSend(a1[4], "vendor"), "proxyForService:", @"CLNatalimetryNotifier");
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  v8[2] = sub_100E114B4;
  v8[3] = &unk_101831AF8;
  v8[4] = v7;
  xpc_activity_register("com.apple.locationd.Calorimetry.CalorieAggregation", v6, v8);
  xpc_release(v6);
}

void sub_100E10118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_100E1012C(void *a1)
{
  uint64_t v2 = a1[16];
  double v3 = (void *)a1[5];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  v7[2] = sub_100E137DC;
  v7[3] = &unk_101884D28;
  v7[4] = a1;
  sub_100F8E200(v2, v3, v7);
  uint64_t v4 = a1[24];
  unint64_t v5 = (void *)a1[5];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  _DWORD v6[2] = sub_100E13AD0;
  v6[3] = &unk_101884D48;
  _DWORD v6[4] = a1;
  sub_100711C8C(v4, v5, v6);
}

void sub_100E101C8(uint64_t a1, __int128 *a2)
{
  uint64_t v4 = (__int128 *)(*(void *)(a1 + 128) + 460LL);
  __int128 v5 = *a2;
  __int128 v6 = a2[1];
  __int128 v7 = a2[2];
  *(__int128 *)((char *)v4 + 44) = *(__int128 *)((char *)a2 + 44);
  v4[1] = v6;
  v4[2] = v7;
  *uint64_t v4 = v5;
  (*(void (**)(void, __int128 *))(**(void **)(a1 + 2768) + 16LL))(*(void *)(a1 + 2768), a2);
  sub_100B88F60(a1 + 4848, (uint64_t)a2);
  sub_100F1D93C(a1 + 4944, (uint64_t)a2);
  bzero(&v12, 0x554uLL);
  __int128 v8 = a2[1];
  v10[0] = *a2;
  v10[1] = v8;
  *(_OWORD *)int v11 = a2[2];
  *(_OWORD *)&v11[12] = *(__int128 *)((char *)a2 + 44);
  int v9 = 2;
  (*(void (**)(uint64_t, int *, _OWORD *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v9,  v10,  1LL,  0xFFFFFFFFLL,  0LL);
  sub_100C806D0(a1 + 2920, (uint64_t)a2);
  sub_1005B29B0((_OWORD *)(a1 + 4616), a2);
}

void sub_100E102F0(uint64_t a1)
{
  uint64_t v2 = (__int128 *)(*(void *)(a1 + 2752) + 1352LL);
  __int128 v3 = *(_OWORD *)(*(void *)(a1 + 2752) + 1368LL);
  __int128 v17 = *v2;
  __int128 v18 = v3;
  *(_OWORD *)uint64_t v19 = v2[2];
  *(_OWORD *)&v19[12] = *(__int128 *)((char *)v2 + 44);
  if (sub_100E155C8(a1, (uint64_t)&v17))
  {
    *(_BYTE *)(a1 + 416) = 1;
    v16[0] = *(_DWORD *)&v19[8];
    uint64_t v4 = sub_1006E27E8();
    sub_100413284(v4, buf);
    int v5 = sub_1002A7CB0(*(uint64_t *)buf, "UserCondition", v16);
    __int128 v6 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      __int128 v7 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v8 = __ldaxr(v7);
      while (__stlxr(v8 - 1, v7));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }

    if (v5) {
      *(_DWORD *)&v19[8] = v16[0];
    }
    float v9 = sub_100A9C998(a1 + 2889, (uint64_t)&v17);
    *((float *)&v18 + 3) = v9;
    *(_DWORD *)&v19[20] = sub_100A9FE60(a1 + 4920, (float *)&v17);
    sub_100E14758(a1, *(void **)(a1 + 384), (uint64_t)&v17, 1, (uint64_t)buf);
    sub_100E101C8(a1, (__int128 *)buf);
    uint64_t v10 = sub_1008FA854(0);
    (*(void (**)(uint64_t, uint8_t *))(*(void *)(v10 + 56) + 32LL))(v10 + 56, buf);
    float v11 = *(float *)(*(void *)(a1 + 2752) + 1360LL);
    uint64_t v12 = sub_1008FA854(0);
    (*(void (**)(uint64_t, void))(*(void *)(v12 + 56) + 16LL))( v12 + 56,  (int)(float)((float)(v11 * 100.0) + 0.5));
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v13 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "UserProfile, Unable to read from disk!",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      LOWORD(v16[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "UserProfile, Unable to read from disk!",  v16,  2);
      uint64_t v15 = (uint8_t *)v14;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryNotifier::readUserProfile()", "%s\n", v14);
      if (v15 != buf) {
        free(v15);
      }
    }
  }

void sub_100E105C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_100E105DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101884E40);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v15 = 1;
    uint64_t v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLNatalimetryNotifier::onSessionTrackerAppLaunchNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    float v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v17 = 0;
      __int16 v18 = 2082;
      uint64_t v19 = "";
      __int16 v20 = 2082;
      double v21 = "activity";
      __int16 v22 = 2050;
      uint64_t v23 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLNatalimetryNotifier::onSessionTrackerAppLaunchNotification, event:%{public, locat ion:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v15 = 0;
  }

  id v12 = [*(id *)(a2 + 32) silo];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  v13[2] = nullsub_1140;
  v13[3] = &unk_10182D1B8;
  v13[4] = a2;
  v13[5] = a1;
  v13[6] = a3;
  v13[7] = a4;
  v13[8] = a5;
  [v12 sync:v13];
  if (v15) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E107DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_activity_scope_state_s state, char a19)
{
  if (a19) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E107FC(uint64_t *a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101884E40);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLNatalimetryNotifier::onDeviceMotionData",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    int v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      float v11 = "";
      __int16 v12 = 2082;
      int v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLNatalimetryNotifier::onDeviceMotionData, event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100E1856C(a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E109AC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E109D0(uint64_t a1)
{
  return sub_10000AE14(a1);
}

void *sub_100E10A00(void *a1)
{
  uint64_t v2 = (void *)a1[156];
  if (v2)
  {
    a1[157] = v2;
    operator delete(v2);
  }

  sub_10000AE14((uint64_t)(a1 + 154));
  sub_10028EB1C(a1 + 148);
  sub_10000AE14((uint64_t)(a1 + 143));
  __int128 v3 = (void *)a1[133];
  if (v3)
  {
    a1[134] = v3;
    operator delete(v3);
  }

  uint64_t v4 = (void *)a1[130];
  if (v4)
  {
    a1[131] = v4;
    operator delete(v4);
  }

  sub_101024EBC(a1 + 17);
  sub_1000EAA04(a1 + 9);
  return a1;
}

uint64_t sub_100E10A8C(uint64_t a1)
{
  *(void *)a1 = off_1018856D0;
  free(*(void **)(a1 + 8));
  sub_1000EAA04((void *)(a1 + 24));
  return a1;
}

uint64_t sub_100E10ADC(uint64_t a1)
{
  *(void *)a1 = off_101885798;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

uint64_t sub_100E10B50(uint64_t a1)
{
  *(void *)a1 = off_101884BB8;
  *(void *)(a1 + 112) = off_101884CC8;
  *(void *)(a1 + 120) = off_101884D00;

  *(void *)(a1 + 384) = 0LL;
  (*(void (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  uint64_t v2 = *(void *)(a1 + 5192);
  *(void *)(a1 + 5192) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  sub_100E1D544(a1 + 4944);
  sub_100231C10((void *)(a1 + 4864));
  uint64_t v3 = *(void *)(a1 + 4832);
  *(void *)(a1 + 4832) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 4824);
  *(void *)(a1 + 4824) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 4816);
  *(void *)(a1 + 4816) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 4808);
  *(void *)(a1 + 4808) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 4800);
  *(void *)(a1 + 4800) = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  uint64_t v8 = *(void *)(a1 + 4792);
  *(void *)(a1 + 4792) = 0LL;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  sub_10000AE14(a1 + 4768);
  sub_10000AE14(a1 + 4752);
  sub_10000AE14(a1 + 4736);
  sub_10000AE14(a1 + 4616);
  int v9 = *(void **)(a1 + 4168);
  if (v9)
  {
    *(void *)(a1 + 4176) = v9;
    operator delete(v9);
  }

  sub_10000AE14(a1 + 4152);
  sub_10028EB1C((void *)(a1 + 4104));
  sub_10000AE14(a1 + 4064);
  __int16 v10 = *(void **)(a1 + 3984);
  if (v10)
  {
    *(void *)(a1 + 3992) = v10;
    operator delete(v10);
  }

  float v11 = *(void **)(a1 + 3960);
  if (v11)
  {
    *(void *)(a1 + 3968) = v11;
    operator delete(v11);
  }

  sub_101024EBC(a1 + 3056);
  sub_1000EAA04((void *)(a1 + 2992));
  sub_10000AE14(a1 + 2896);
  __n128 v12 = nullsub_10(a1 + 2890);
  uint64_t v13 = *(void *)(a1 + 2776);
  *(void *)(a1 + 2776) = 0LL;
  if (v13) {
    (*(void (**)(uint64_t, __n128))(*(void *)v13 + 48LL))(v13, v12);
  }
  uint64_t v14 = *(void *)(a1 + 2768);
  *(void *)(a1 + 2768) = 0LL;
  if (v14) {
    (*(void (**)(uint64_t, __n128))(*(void *)v14 + 48LL))(v14, v12);
  }
  sub_10000AE14(a1 + 2752);
  sub_100E1D5EC(a1 + 1968);
  sub_100E247D0(a1 + 1824);
  sub_100E24768(a1 + 1680);
  *(void *)(a1 + 1552) = off_101863548;
  free(*(void **)(a1 + 1560));
  sub_10041385C((void *)(a1 + 1576));
  sub_100E24700(a1 + 1408);
  *(void *)(a1 + 1280) = off_1018856D0;
  free(*(void **)(a1 + 1288));
  sub_1000EAA04((void *)(a1 + 1304));
  sub_100E24698(a1 + 1136);
  sub_100E24630(a1 + 992);
  sub_100E245B0(a1 + 592);
  sub_100E24548(a1 + 448);
  uint64_t v15 = *(void *)(a1 + 368);
  *(void *)(a1 + 368) = 0LL;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
  }
  sub_10000AE14(a1 + 336);
  sub_10000AE14(a1 + 320);
  sub_1001B4FBC(a1 + 272);
  sub_10000AE14(a1 + 256);
  sub_1001B4FBC(a1 + 208);
  sub_10000AE14(a1 + 192);
  sub_1001B4FBC(a1 + 144);
  sub_10000AE14(a1 + 128);
  return sub_100E10ADC(a1);
}

uint64_t sub_100E10E28(uint64_t a1)
{
  return sub_100E10B50(a1 - 112);
}

uint64_t sub_100E10E30(uint64_t a1)
{
  return sub_100E10B50(a1 - 120);
}

void sub_100E10E38(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E10B50(a1);
  operator delete(v1);
}

void sub_100E10E4C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E10B50(a1 - 112);
  operator delete(v1);
}

void sub_100E10E64(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E10B50(a1 - 120);
  operator delete(v1);
}

void sub_100E10E7C(uint64_t a1)
{
  uint64_t v2 = *(dispatch_source_s **)(a1 + 360);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(a1 + 360));
    *(void *)(a1 + 360) = 0LL;
  }

  uint64_t v3 = *(void *)(a1 + 4792);
  *(void *)(a1 + 4792) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 4808);
  *(void *)(a1 + 4808) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 4800);
  *(void *)(a1 + 4800) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 5184));
  uint64_t v6 = sub_1008FA854(0);
  sub_1006DD2A0(v6, 4, *(void *)(a1 + 408));
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver( DarwinNotifyCenter,  (const void *)a1,  @"NanolifestyleSessionTrackerAppForegroundedNotification",  0LL);
  uint64_t v8 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterRemoveObserver( v8,  (const void *)a1,  @"NanolifestyleSessionTrackerAppForegroundedForMachinePairingNotification",  0LL);
  *(_BYTE *)(a1 + 108) = 1;
}

void sub_100E10F4C(void **a1, double a2)
{
  if (a2 >= 0.0)
  {
    int v9 = a1[2];
    uint64_t v7 = (uint64_t)(a1 + 2);
    uint64_t v8 = v9;
    unint64_t v10 = *(void *)(v7 - 8);
    if (v10 >= (unint64_t)v9)
    {
      unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - (void)*a1) >> 3);
      unint64_t v13 = v12 + 1;
      if (v12 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100007008();
      }
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v8 - (_BYTE *)*a1) >> 3);
      if (2 * v14 > v13) {
        unint64_t v13 = 2 * v14;
      }
      if (v14 >= 0x555555555555555LL) {
        unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15) {
        __int16 v16 = (char *)sub_10000701C(v7, v15);
      }
      else {
        __int16 v16 = 0LL;
      }
      int v17 = &v16[24 * v12];
      __int16 v18 = &v16[24 * v15];
      *(double *)int v17 = a2;
      *((void *)v17 + 1) = 0x7FEFFFFFFFFFFFFFLL;
      v17[16] = 0;
      float v11 = v17 + 24;
      __int16 v20 = (char *)*a1;
      uint64_t v19 = (char *)a1[1];
      if (v19 != *a1)
      {
        do
        {
          __int128 v21 = *(_OWORD *)(v19 - 24);
          *(v17 - 8) = *(v19 - 8);
          *(_OWORD *)(v17 - 24) = v21;
          v17 -= 24;
          v19 -= 24;
        }

        while (v19 != v20);
        uint64_t v19 = (char *)*a1;
      }

      *a1 = v17;
      a1[1] = v11;
      a1[2] = v18;
      if (v19) {
        operator delete(v19);
      }
    }

    else
    {
      *(double *)unint64_t v10 = a2;
      *(void *)(v10 + 8) = 0x7FEFFFFFFFFFFFFFLL;
      *(_BYTE *)(v10 + 16) = 0;
      float v11 = (char *)(v10 + 24);
    }

    a1[1] = v11;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v3 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134349056;
      double v25 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Programmer error, this expiration rule with time %{public}fis not valid.",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101885A60);
      }
      int v22 = 134349056;
      double v23 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Programmer error, this expiration rule with time %{public}fis not valid.",  &v22,  12);
      uint64_t v5 = (uint8_t *)v4;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLActivityAggregator<CLNatalieData>::setExpirationRule(CFTimeInterval) [T = CLNatalieData, DataProtectionPo licy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v4);
      if (v5 != buf) {
        free(v5);
      }
    }
  }

void sub_100E11200(void **a1, double a2)
{
  if (a2 >= 0.0)
  {
    int v9 = a1[2];
    uint64_t v7 = (uint64_t)(a1 + 2);
    uint64_t v8 = v9;
    unint64_t v10 = *(void *)(v7 - 8);
    if (v10 >= (unint64_t)v9)
    {
      unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - (void)*a1) >> 3);
      unint64_t v13 = v12 + 1;
      if (v12 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100007008();
      }
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v8 - (_BYTE *)*a1) >> 3);
      if (2 * v14 > v13) {
        unint64_t v13 = 2 * v14;
      }
      if (v14 >= 0x555555555555555LL) {
        unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15) {
        __int16 v16 = (char *)sub_10000701C(v7, v15);
      }
      else {
        __int16 v16 = 0LL;
      }
      int v17 = &v16[24 * v12];
      __int16 v18 = &v16[24 * v15];
      *(double *)int v17 = a2;
      *((void *)v17 + 1) = 0x7FEFFFFFFFFFFFFFLL;
      v17[16] = 0;
      float v11 = v17 + 24;
      __int16 v20 = (char *)*a1;
      uint64_t v19 = (char *)a1[1];
      if (v19 != *a1)
      {
        do
        {
          __int128 v21 = *(_OWORD *)(v19 - 24);
          *(v17 - 8) = *(v19 - 8);
          *(_OWORD *)(v17 - 24) = v21;
          v17 -= 24;
          v19 -= 24;
        }

        while (v19 != v20);
        uint64_t v19 = (char *)*a1;
      }

      *a1 = v17;
      a1[1] = v11;
      a1[2] = v18;
      if (v19) {
        operator delete(v19);
      }
    }

    else
    {
      *(double *)unint64_t v10 = a2;
      *(void *)(v10 + 8) = 0x7FEFFFFFFFFFFFFFLL;
      *(_BYTE *)(v10 + 16) = 0;
      float v11 = (char *)(v10 + 24);
    }

    a1[1] = v11;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v3 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134349056;
      double v25 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Programmer error, this expiration rule with time %{public}fis not valid.",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101885A60);
      }
      int v22 = 134349056;
      double v23 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Programmer error, this expiration rule with time %{public}fis not valid.",  &v22,  12);
      uint64_t v5 = (uint8_t *)v4;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLActivityAggregator<CLExerciseMinuteData>::setExpirationRule(CFTimeInterval) [T = CLExerciseMinuteData, Da taProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v4);
      if (v5 != buf) {
        free(v5);
      }
    }
  }

void sub_100E114B4(uint64_t a1, _xpc_activity_s *a2)
{
  if (xpc_activity_get_state(a2) == 2 && !xpc_activity_set_state(a2, 4LL))
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    uint64_t v3 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134349056;
      xpc_activity_state_t state = xpc_activity_get_state(a2);
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Failed to mark activity as Continue. Current state is %{public}ld",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      uint64_t v4 = qword_1019344D8;
      int v7 = 134349056;
      xpc_activity_state_t v8 = xpc_activity_get_state(a2);
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v4,  17LL,  "Failed to mark activity as Continue. Current state is %{public}ld",  &v7,  12);
      uint64_t v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNatalimetryNotifier::setUpAggregationOnTimer()_block_invoke",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

void sub_100E1169C(uint64_t a1, _xpc_activity_s *a2)
{
  if (*(_DWORD *)(a1 + 4784) == 1)
  {
    uint64_t v46 = CMNatalimeterSetUserAdaptiveExerciseMinuteThreshold;
    *(float *)&double v4 = sub_100A9FE60(a1 + 4920, (float *)(*(void *)(a1 + 2752) + 1352LL));
    uint64_t v47 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v4);
    sub_100E13D68( a1,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v47,  &v46,  1LL),  0,  0LL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    uint64_t v5 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "CalorieAggregation: Estimating MaxMets",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      LOWORD(v41) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "CalorieAggregation: Estimating MaxMets",  &v41,  2);
      double v27 = (char *)v26;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::runCalorieAggregation(xpc_activity_t)",  "%s\n",  v26);
      if (v27 != buf) {
        free(v27);
      }
    }

    CFAbsoluteTimeGetCurrent();
    nullsub_10(a1 + 4736);
    if (!sub_100E1246C(v6, a2))
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      int v7 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "CalorieAggregation: Aggregating CalorieHistory",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        LOWORD(v41) = 0;
        LODWORD(v40) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "CalorieAggregation: Aggregating CalorieHistory",  &v41,  v40);
        uint64_t v29 = (char *)v28;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::runCalorieAggregation(xpc_activity_t)",  "%s\n",  v28);
        if (v29 != buf) {
          free(v29);
        }
      }

      sub_100E12780(a1 + 144);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      xpc_activity_state_t v8 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "CalorieAggregation: Aggregating ftp data history",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        LOWORD(v41) = 0;
        LODWORD(v40) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "CalorieAggregation: Aggregating ftp data history",  &v41,  v40);
        __int128 v31 = (char *)v30;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::runCalorieAggregation(xpc_activity_t)",  "%s\n",  v30);
        if (v31 != buf) {
          free(v31);
        }
      }

      sub_100F1EB3C(a1 + 4944);
      int v9 = sub_100E02D88();
      if (v9 == 2)
      {
        double Current = CFAbsoluteTimeGetCurrent();
        if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 2776) + 32LL))( *(void *)(a1 + 2776),  1LL))
        {
          double v11 = vabdd_f64(Current, *(double *)(a1 + 2784)) + 2.56;
          double v12 = vabdd_f64(Current, *(double *)(a1 + 2792));
          double v13 = v12 + 2.56;
          if (v11 >= v12 + 2.56) {
            double v14 = v11;
          }
          else {
            double v14 = v12 + 2.56;
          }
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101884E60);
          }
          unint64_t v15 = (os_log_s *)qword_1019344D8;
          if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134349312;
            *(double *)&uint8_t buf[4] = v11;
            *(_WORD *)&_BYTE buf[12] = 2050;
            *(double *)&buf[14] = v13;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "CalorieAggregation: Secondary CalorieHistory aggregation with activeDelay, %{public}f, basalDelay, %{public}f",  buf,  0x16u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344D0 != -1) {
              dispatch_once(&qword_1019344D0, &stru_101884E60);
            }
            int v41 = 134349312;
            double v42 = v11;
            __int16 v43 = 2050;
            double v44 = v13;
            LODWORD(v40) = 22;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "CalorieAggregation: Secondary CalorieHistory aggregation with activeDelay, %{public}f, basalDelay, %{public}f",  &v41,  v40);
            int v17 = (char *)v16;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::runCalorieAggregation(xpc_activity_t)",  "%s\n",  v16);
            if (v17 != buf) {
              free(v17);
            }
          }
        }

        else
        {
          double v14 = 3600.0;
        }

        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        __int16 v18 = (os_log_s *)qword_1019344D8;
        if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134349056;
          *(double *)&uint8_t buf[4] = v14;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "CalorieAggregation: Secondary CalorieHistory aggregation for %{public}f",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101884E60);
          }
          int v41 = 134349056;
          double v42 = v14;
          LODWORD(v40) = 12;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "CalorieAggregation: Secondary CalorieHistory aggregation for %{public}f",  &v41,  v40);
          __int128 v33 = (char *)v32;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::runCalorieAggregation(xpc_activity_t)",  "%s\n",  v32);
          if (v33 != buf) {
            free(v33);
          }
        }

        uint64_t v19 = operator new(0x18uLL);
        *(void *)buf = v19;
        *(void *)&buf[16] = v19 + 3;
        *(double *)uint64_t v19 = v14;
        v19[1] = 0x7FEFFFFFFFFFFFFFLL;
        *((_BYTE *)v19 + 16) = 0;
        *(void *)&uint8_t buf[8] = v19 + 3;
        (*(void (**)(void, _BYTE *))(**(void **)(a1 + 128) + 32LL))(*(void *)(a1 + 128), buf);
        int v9 = *(_DWORD *)buf;
        if (*(void *)buf)
        {
          *(void *)&uint8_t buf[8] = *(void *)buf;
          operator delete(*(void **)buf);
        }
      }

      if (!sub_100E1246C(v9, a2))
      {
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        __int16 v20 = (os_log_s *)qword_1019344D8;
        if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "CalorieAggregation: Aggregating MaxMetsHistory",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101884E60);
          }
          LOWORD(v41) = 0;
          LODWORD(v40) = 2;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "CalorieAggregation: Aggregating MaxMetsHistory",  &v41,  v40);
          uint64_t v35 = (char *)v34;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::runCalorieAggregation(xpc_activity_t)",  "%s\n",  v34);
          if (v35 != buf) {
            free(v35);
          }
        }

        int v21 = sub_100E12CF4(a1 + 272);
        if (!sub_100E1246C(v21, a2))
        {
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_101884E60);
          }
          int v22 = (os_log_s *)qword_1019344D8;
          if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "CalorieAggregation: Aggregating ExerciseMinuteHistory",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344D0 != -1) {
              dispatch_once(&qword_1019344D0, &stru_101884E60);
            }
            LOWORD(v41) = 0;
            LODWORD(v40) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "CalorieAggregation: Aggregating ExerciseMinuteHistory",  &v41,  v40);
            uint64_t v37 = (char *)v36;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::runCalorieAggregation(xpc_activity_t)",  "%s\n",  v36);
            if (v37 != buf) {
              free(v37);
            }
          }

          int v23 = sub_100E13268(a1 + 208);
          if (!sub_100E1246C(v23, a2))
          {
            if (qword_1019344D0 != -1) {
              dispatch_once(&qword_1019344D0, &stru_101884E60);
            }
            __int128 v24 = (os_log_s *)qword_1019344D8;
            if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "CalorieAggregation: Aggregating VO2Max data",  buf,  2u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019344D0 != -1) {
                dispatch_once(&qword_1019344D0, &stru_101884E60);
              }
              LOWORD(v41) = 0;
              LODWORD(v40) = 2;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "CalorieAggregation: Aggregating VO2Max data",  &v41,  v40);
              uint64_t v39 = (char *)v38;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::runCalorieAggregation(xpc_activity_t)",  "%s\n",  v38);
              if (v39 != buf) {
                free(v39);
              }
            }

            sub_100C7FDE0(a1 + 2920);
            sub_100E122A0(v25, a2);
          }
        }
      }
    }
  }

  else
  {
    sub_100E122A0(a1, a2);
  }

void sub_100E1227C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E122A0(int a1, xpc_activity_t activity)
{
  if (!xpc_activity_set_state(activity, 5LL))
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    uint64_t v3 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134349056;
      xpc_activity_state_t state = xpc_activity_get_state(activity);
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Failed to mark CalorieAggregation activity as done. Current state is %{public}ld",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      uint64_t v4 = qword_1019344D8;
      int v7 = 134349056;
      xpc_activity_state_t v8 = xpc_activity_get_state(activity);
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v4,  17LL,  "Failed to mark CalorieAggregation activity as done. Current state is %{public}ld",  &v7,  12);
      int v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNatalimetryNotifier::markXpcActivityDone(xpc_activity_t)",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

BOOL sub_100E1246C(int a1, xpc_activity_t activity)
{
  BOOL result = xpc_activity_should_defer(activity);
  if (result)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    uint64_t v4 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Attempting to defer CalorieAggregation activity",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      LOWORD(v15) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "Attempting to defer CalorieAggregation activity",  &v15,  2);
      int v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLNatalimetryNotifier::deferXpcActivityIfNecessary(xpc_activity_t)",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }

    if (xpc_activity_set_state(activity, 3LL))
    {
      return 1LL;
    }

    else
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      uint64_t v5 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
      {
        xpc_activity_state_t state = xpc_activity_get_state(activity);
        *(_DWORD *)buf = 134349056;
        xpc_activity_state_t v18 = state;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "Failed to mark CalorieAggregation activity as deferred. Current state is %{public}ld",  buf,  0xCu);
      }

      BOOL v7 = sub_1002921D0(115, 0);
      BOOL result = 0LL;
      if (v7)
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        uint64_t v10 = qword_1019344D8;
        xpc_activity_state_t v11 = xpc_activity_get_state(activity);
        int v15 = 134349056;
        xpc_activity_state_t v16 = v11;
        LODWORD(v14) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  17LL,  "Failed to mark CalorieAggregation activity as deferred. Current state is %{public}ld",  &v15,  v14);
        double v13 = (uint8_t *)v12;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLNatalimetryNotifier::deferXpcActivityIfNecessary(xpc_activity_t)",  "%s\n",  v12);
        if (v13 != buf) {
          free(v13);
        }
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_100E12780(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 40)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v3 = sub_101171D38();
    int v4 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)buf = 134218240;
    *(double *)float v36 = v3;
    *(_WORD *)&v36[8] = 1024;
    int v37 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Aggregating records start %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v16 = qword_101934A78;
    double v17 = sub_101171D38();
    int v18 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v32 = 134218240;
    *(double *)__int128 v33 = v17;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  2LL,  "Aggregating records start %f, count ~%d",  COERCE_DOUBLE(&v32),  18);
    __int16 v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLNatalieData>::aggregateRecords() [T = CLNatalieData, DataProtectionPolicy = CLActivity DB::ClassCDataProtectionPolicy]",  "%s\n",  v19);
    if (v20 != buf) {
      free(v20);
    }
  }

  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  int v6 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v7 = sub_101171D38();
    int v8 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)buf = 134218240;
    *(double *)float v36 = v7;
    *(_WORD *)&v36[8] = 1024;
    int v37 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Aggregating records stop %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v21 = qword_101934A78;
    double v22 = sub_101171D38();
    int v23 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v32 = 134218240;
    *(double *)__int128 v33 = v22;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v23;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  2LL,  "Aggregating records stop %f, count ~%d",  COERCE_DOUBLE(&v32),  18);
    int v25 = (uint8_t *)v24;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLNatalieData>::aggregateRecords() [T = CLNatalieData, DataProtectionPolicy = CLActivity DB::ClassCDataProtectionPolicy]",  "%s\n",  v24);
    if (v25 != buf) {
      free(v25);
    }
  }

  uint64_t v9 = *(void *)(a1 + 24);
  double v10 = (double)*(int *)(v9 + 132);
  if ((double)(int)sub_100E24838(v9, (double **)a1) * 1.2 < v10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    xpc_activity_state_t v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 24);
      int v13 = *(_DWORD *)(v12 + 132);
      int v14 = sub_100E24838(v12, (double **)a1);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)float v36 = v13;
      *(_WORD *)&v36[4] = 1024;
      *(_DWORD *)&v36[6] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101885A60);
      }
      uint64_t v26 = qword_101934A78;
      uint64_t v27 = *(void *)(a1 + 24);
      int v28 = *(_DWORD *)(v27 + 132);
      int v29 = sub_100E24838(v27, (double **)a1);
      int v32 = 67109376;
      *(_DWORD *)__int128 v33 = v28;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v29;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  0LL,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  &v32,  14);
      __int128 v31 = (uint8_t *)v30;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLNatalieData>::aggregateRecords() [T = CLNatalieData, DataProtectionPolicy = CLActivi tyDB::ClassCDataProtectionPolicy]",  "%s\n",  v30);
      if (v31 != buf) {
        free(v31);
      }
    }
  }

  return v5;
}

uint64_t sub_100E12CF4(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 40)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v3 = sub_101171D38();
    int v4 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)buf = 134218240;
    *(double *)float v36 = v3;
    *(_WORD *)&v36[8] = 1024;
    int v37 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Aggregating records start %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v16 = qword_101934A78;
    double v17 = sub_101171D38();
    int v18 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v32 = 134218240;
    *(double *)__int128 v33 = v17;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  2LL,  "Aggregating records start %f, count ~%d",  COERCE_DOUBLE(&v32),  18);
    __int16 v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = MaxMets, Dat aProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v19);
    if (v20 != buf) {
      free(v20);
    }
  }

  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  int v6 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v7 = sub_101171D38();
    int v8 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)buf = 134218240;
    *(double *)float v36 = v7;
    *(_WORD *)&v36[8] = 1024;
    int v37 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Aggregating records stop %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v21 = qword_101934A78;
    double v22 = sub_101171D38();
    int v23 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v32 = 134218240;
    *(double *)__int128 v33 = v22;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v23;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  2LL,  "Aggregating records stop %f, count ~%d",  COERCE_DOUBLE(&v32),  18);
    int v25 = (uint8_t *)v24;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = MaxMets, Dat aProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v24);
    if (v25 != buf) {
      free(v25);
    }
  }

  uint64_t v9 = *(void *)(a1 + 24);
  double v10 = (double)*(int *)(v9 + 132);
  if ((double)(int)sub_100E24A34(v9, (double **)a1) * 1.2 < v10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    xpc_activity_state_t v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 24);
      int v13 = *(_DWORD *)(v12 + 132);
      int v14 = sub_100E24A34(v12, (double **)a1);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)float v36 = v13;
      *(_WORD *)&v36[4] = 1024;
      *(_DWORD *)&v36[6] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101885A60);
      }
      uint64_t v26 = qword_101934A78;
      uint64_t v27 = *(void *)(a1 + 24);
      int v28 = *(_DWORD *)(v27 + 132);
      int v29 = sub_100E24A34(v27, (double **)a1);
      int v32 = 67109376;
      *(_DWORD *)__int128 v33 = v28;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v29;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  0LL,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  &v32,  14);
      __int128 v31 = (uint8_t *)v30;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::aggregateRecords() [T = MaxMets, D ataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v30);
      if (v31 != buf) {
        free(v31);
      }
    }
  }

  return v5;
}

uint64_t sub_100E13268(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 40)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v3 = sub_101171D38();
    int v4 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)buf = 134218240;
    *(double *)float v36 = v3;
    *(_WORD *)&v36[8] = 1024;
    int v37 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Aggregating records start %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v16 = qword_101934A78;
    double v17 = sub_101171D38();
    int v18 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v32 = 134218240;
    *(double *)__int128 v33 = v17;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  2LL,  "Aggregating records start %f, count ~%d",  COERCE_DOUBLE(&v32),  18);
    __int16 v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLExerciseMinuteData>::aggregateRecords() [T = CLExerciseMinuteData, DataProtectionPolic y = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v19);
    if (v20 != buf) {
      free(v20);
    }
  }

  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  int v6 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v7 = sub_101171D38();
    int v8 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)buf = 134218240;
    *(double *)float v36 = v7;
    *(_WORD *)&v36[8] = 1024;
    int v37 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Aggregating records stop %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v21 = qword_101934A78;
    double v22 = sub_101171D38();
    int v23 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v32 = 134218240;
    *(double *)__int128 v33 = v22;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v23;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  2LL,  "Aggregating records stop %f, count ~%d",  COERCE_DOUBLE(&v32),  18);
    int v25 = (uint8_t *)v24;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLExerciseMinuteData>::aggregateRecords() [T = CLExerciseMinuteData, DataProtectionPolic y = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v24);
    if (v25 != buf) {
      free(v25);
    }
  }

  uint64_t v9 = *(void *)(a1 + 24);
  double v10 = (double)*(int *)(v9 + 132);
  if ((double)(int)sub_100E24C30(v9, (double **)a1) * 1.2 < v10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    xpc_activity_state_t v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 24);
      int v13 = *(_DWORD *)(v12 + 132);
      int v14 = sub_100E24C30(v12, (double **)a1);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)float v36 = v13;
      *(_WORD *)&v36[4] = 1024;
      *(_DWORD *)&v36[6] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101885A60);
      }
      uint64_t v26 = qword_101934A78;
      uint64_t v27 = *(void *)(a1 + 24);
      int v28 = *(_DWORD *)(v27 + 132);
      int v29 = sub_100E24C30(v27, (double **)a1);
      int v32 = 67109376;
      *(_DWORD *)__int128 v33 = v28;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v29;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  0LL,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  &v32,  14);
      __int128 v31 = (uint8_t *)v30;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLExerciseMinuteData>::aggregateRecords() [T = CLExerciseMinuteData, DataProtectionPol icy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v30);
      if (v31 != buf) {
        free(v31);
      }
    }
  }

  return v5;
}

uint64_t sub_100E137DC(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  double v7 = *(void ***)(a1 + 32);
  (*(void (**)(void *, uint64_t))(*v7[347] + 32LL))(v7[347], 1LL);
  bzero(&v56, 0x538uLL);
  __int128 v8 = *((_OWORD *)a2 + 3);
  v54[2] = *((_OWORD *)a2 + 2);
  v54[3] = v8;
  v54[4] = *((_OWORD *)a2 + 4);
  uint64_t v55 = *((void *)a2 + 10);
  __int128 v9 = *((_OWORD *)a2 + 1);
  v54[0] = *(_OWORD *)a2;
  v54[1] = v9;
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  double v10 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
  {
    int v11 = *a2;
    uint64_t v12 = *((void *)a2 + 2);
    uint64_t v14 = *((void *)a2 + 7);
    uint64_t v13 = *((void *)a2 + 8);
    int v15 = a2[6];
    uint64_t v16 = *((void *)a2 + 4);
    uint64_t v17 = *((void *)a2 + 6);
    *(_DWORD *)buf = 67111168;
    int v37 = v11;
    __int16 v38 = 2048;
    uint64_t v39 = v12;
    __int16 v40 = 2048;
    uint64_t v41 = v13;
    __int16 v42 = 1024;
    int v43 = v15;
    __int16 v44 = 2048;
    uint64_t v45 = v16;
    __int16 v46 = 2048;
    uint64_t v47 = v17;
    __int16 v48 = 2048;
    uint64_t v49 = v14;
    __int16 v50 = 2048;
    uint64_t v51 = a3;
    __int16 v52 = 2048;
    uint64_t v53 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "CalorieHistory,recordId,%d,startTime,%.3f,duration,%f,activityType,%d,userMets,%lf,calories,%lld,basalCalories,%ll d,incrementalActiveCalories,%lld,incrementalBasalCalories,%lld",  buf,  0x54u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v19 = *a2;
    uint64_t v20 = *((void *)a2 + 2);
    uint64_t v22 = *((void *)a2 + 7);
    uint64_t v21 = *((void *)a2 + 8);
    int v23 = a2[6];
    uint64_t v24 = *((void *)a2 + 4);
    uint64_t v25 = *((void *)a2 + 6);
    LODWORD(v29) = 67111168;
    HIDWORD(v29) = v19;
    *(_WORD *)int v30 = 2048;
    *(void *)&v30[2] = v20;
    *(_WORD *)&v30[10] = 2048;
    *(void *)&v30[12] = v21;
    *(_WORD *)&v30[20] = 1024;
    *(_DWORD *)&v30[22] = v23;
    *(_WORD *)&v30[26] = 2048;
    *(void *)&v30[28] = v24;
    *(_WORD *)&v30[36] = 2048;
    *(void *)&v30[38] = v25;
    *(_WORD *)&v30[46] = 2048;
    uint64_t v31 = v22;
    __int16 v32 = 2048;
    uint64_t v33 = a3;
    __int16 v34 = 2048;
    uint64_t v35 = a4;
    LODWORD(v28) = 84;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "CalorieHistory,recordId,%d,startTime,%.3f,duration,%f,activityType,%d,userMets,%lf,calories,%lld,basalCalories,%ll d,incrementalActiveCalories,%lld,incrementalBasalCalories,%lld",  &v29,  v28,  v29,  *(_DWORD *)v30,  *(double *)&v30[8],  *(void *)&v30[16],  *(void *)&v30[24],  *(void *)&v30[32],  *(void *)&v30[40]);
    uint64_t v27 = (uint8_t *)v26;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::setUpdateFinishedHandler()_block_invoke",  "%s\n",  v26);
    if (v27 != buf) {
      free(v27);
    }
  }

  *(_DWORD *)buf = 0;
  return ((uint64_t (*)(void **, uint8_t *, _OWORD *, uint64_t, uint64_t, void))(*v7)[19])( v7,  buf,  v54,  1LL,  0xFFFFFFFFLL,  0LL);
}

uint64_t sub_100E13AD0(uint64_t a1, __int128 *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  bzero(&v21, 0x578uLL);
  __int128 v19 = *a2;
  uint64_t v20 = *((void *)a2 + 2);
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  int v4 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)a2;
    uint64_t v6 = *((void *)a2 + 1);
    *(_DWORD *)buf = 67240448;
    int v16 = v5;
    __int16 v17 = 2050;
    uint64_t v18 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "ExerciseMinuteHistory,recordId,%{public}d,startTime,%{public}.3f",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v8 = *(_DWORD *)a2;
    uint64_t v9 = *((void *)a2 + 1);
    v12[0] = 67240448;
    v12[1] = v8;
    __int16 v13 = 2050;
    uint64_t v14 = v9;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "ExerciseMinuteHistory,recordId,%{public}d,startTime,%{public}.3f",  v12,  18);
    int v11 = (uint8_t *)v10;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::setUpdateFinishedHandler()_block_invoke",  "%s\n",  v10);
    if (v11 != buf) {
      free(v11);
    }
  }

  *(_DWORD *)buf = 4;
  return (*(uint64_t (**)(uint64_t, uint8_t *, __int128 *, uint64_t, uint64_t, void))(*(void *)v3 + 152LL))( v3,  buf,  &v19,  1LL,  0xFFFFFFFFLL,  0LL);
}

void *sub_100E13CF0@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

void sub_100E13D68(uint64_t a1, void *a2, int a3, void *a4)
{
  id v8 = [a4 mutableCopy];
  sub_100E1403C(a1, v8);
  uint64_t v9 = (_OWORD *)(*(void *)(a1 + 2752) + 1352LL);
  __int128 v10 = *(_OWORD *)(*(void *)(a1 + 2752) + 1368LL);
  v50[0] = *v9;
  v50[1] = v10;
  v51[0] = v9[2];
  *(_OWORD *)((char *)v51 + 12) = *(_OWORD *)((char *)v9 + 44);
  if (v8) {
    sub_100E14410((uint64_t)[*(id *)(a1 + 384) removeObjectsForKeys:v8], v8, (uint64_t)v50);
  }

  sub_100E14758(a1, *(void **)(a1 + 384), (uint64_t)v50, a3, (uint64_t)&v43);
  if (*(int *)(a1 + 396) >= 1)
  {
    if ([a2 objectForKey:CMNatalimeterSetUserPal])
    {
      uint64_t v11 = sub_1002F8DDC();
      if ((sub_1002A832C(v11, (uint64_t)@"TimeFirstPAL", (void *)(a1 + 2808)) & 1) == 0)
      {
        uint64_t v12 = sub_1002F8DDC();
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        sub_1002AC820(v12, @"TimeFirstPAL", &Current);
      }
    }
  }

  sub_100E101C8(a1, &v43);
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserHeightMeter])
  {
    uint64_t v13 = (int)(float)((float)(*(float *)(*(void *)(a1 + 2752) + 1360LL) * 100.0) + 0.5);
    uint64_t v14 = sub_1008FA854(0);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v14 + 56) + 16LL))(v14 + 56, v13);
  }

  if (*(_BYTE *)(a1 + 416))
  {
    uint64_t v15 = sub_1008FA854(0);
    (*(void (**)(uint64_t, __int128 *))(*(void *)(v15 + 56) + 32LL))(v15 + 56, &v43);
  }

  int v16 = objc_autoreleasePoolPush();
  __int16 v17 = objc_alloc_init(&OBJC_CLASS___ALActivityLog);
  -[ALActivityLog setTimestamp:](v17, "setTimestamp:", CFAbsoluteTimeGetCurrent());
  -[ALActivityLog setBodyMetrics:]( v17,  "setBodyMetrics:",  objc_alloc_init(&OBJC_CLASS___ALCLBodyMetrics));
  -[ALCLBodyMetrics setGender:](-[ALActivityLog bodyMetrics](v17, "bodyMetrics"), "setGender:", v43);
  int v18 = DWORD2(v43);
  __int128 v19 = -[ALActivityLog bodyMetrics](v17, "bodyMetrics");
  LODWORD(v20) = v18;
  -[ALCLBodyMetrics setHeightM:](v19, "setHeightM:", v20);
  int v21 = HIDWORD(v43);
  uint64_t v22 = -[ALActivityLog bodyMetrics](v17, "bodyMetrics");
  LODWORD(v23) = v21;
  -[ALCLBodyMetrics setWeightKG:](v22, "setWeightKG:", v23);
  int v24 = v44;
  uint64_t v25 = -[ALActivityLog bodyMetrics](v17, "bodyMetrics");
  LODWORD(v26) = v24;
  -[ALCLBodyMetrics setVo2max:](v25, "setVo2max:", v26);
  int v27 = v45;
  double v28 = -[ALActivityLog bodyMetrics](v17, "bodyMetrics");
  LODWORD(v29) = v27;
  -[ALCLBodyMetrics setAge:](v28, "setAge:", v29);
  int v30 = v46;
  uint64_t v31 = -[ALActivityLog bodyMetrics](v17, "bodyMetrics");
  LODWORD(v32) = v30;
  -[ALCLBodyMetrics setHrmin:](v31, "setHrmin:", v32);
  int v33 = v47;
  __int16 v34 = -[ALActivityLog bodyMetrics](v17, "bodyMetrics");
  LODWORD(v35) = v33;
  -[ALCLBodyMetrics setHrmax:](v34, "setHrmax:", v35);
  int v36 = v48;
  int v37 = -[ALActivityLog bodyMetrics](v17, "bodyMetrics");
  LODWORD(v38) = v36;
  -[ALCLBodyMetrics setHronset:](v37, "setHronset:", v38);
  int v39 = v49;
  __int16 v40 = -[ALActivityLog bodyMetrics](v17, "bodyMetrics");
  LODWORD(v41) = v39;
  -[ALCLBodyMetrics setPal:](v40, "setPal:", v41);
  objc_msgSend( -[CLServiceVendor proxyForService:]( +[CLServiceVendor sharedInstance](CLServiceVendor, "sharedInstance"),  "proxyForService:",  @"CLActivityLogger"),  "logData:",  v17);
  objc_autoreleasePoolPop(v16);
}

void sub_100E1403C(uint64_t a1, void *a2)
{
  uint64_t v4 = CMNatalimeterSetUserHeightMeter;
  if ([*(id *)(a1 + 384) objectForKeyedSubscript:CMNatalimeterSetUserHeightMeter])
  {
    objc_msgSend(objc_msgSend(*(id *)(a1 + 384), "objectForKeyedSubscript:", v4), "floatValue");
    float v6 = v5;
    if (v5 < 0.54 || v5 > 2.73)
    {
      [*(id *)(a1 + 384) removeObjectForKey:v4];
      [a2 addObject:v4];
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v7 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        double v20 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "UserProfile, Error in user info,heightM,%f",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        int v17 = 134217984;
        double v18 = v6;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "UserProfile, Error in user info,heightM,%f",  COERCE_DOUBLE(&v17));
        uint64_t v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::sanitizeUserProfile(NSMutableArray<NSString *> *)",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }
  }

  uint64_t v8 = CMNatalimeterSetUserAgeYr;
  if ([*(id *)(a1 + 384) objectForKeyedSubscript:CMNatalimeterSetUserAgeYr])
  {
    objc_msgSend(objc_msgSend(*(id *)(a1 + 384), "objectForKeyedSubscript:", v8), "floatValue");
    float v10 = v9;
    if (v9 < 5.0 || v9 > 150.0)
    {
      [*(id *)(a1 + 384) removeObjectForKey:v8];
      [a2 addObject:v8];
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      uint64_t v12 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        double v20 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "UserProfile, Error in user info,ageYr,%f",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        int v17 = 134217984;
        double v18 = v10;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "UserProfile, Error in user info,ageYr,%f",  COERCE_DOUBLE(&v17));
        int v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::sanitizeUserProfile(NSMutableArray<NSString *> *)",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }
    }
  }

id sub_100E14410(uint64_t a1, void *a2, uint64_t a3)
{
  id result = [a2 count];
  if (result)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    float v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138477827;
      uint64_t v12 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "UserProfile, resetting CLBodyMetrics for keys: %{private}@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      int v9 = 138477827;
      float v10 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "UserProfile, resetting CLBodyMetrics for keys: %{private}@",  &v9,  12);
      uint64_t v8 = (uint8_t *)v7;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::resetBodyMetricFieldsForKeys(NSArray<NSString *> *, CLBodyMetrics &)",  "%s\n",  v7);
      if (v8 != buf) {
        free(v8);
      }
    }

    if ([a2 containsObject:CMNatalimeterSetUserHeightMeter])
    {
      *(_BYTE *)(a3 + 57) = 0;
      *(_DWORD *)(a3 + 8) = 1071225242;
    }

    if ([a2 containsObject:CMNatalimeterSetUserWeightKG])
    {
      *(_BYTE *)(a3 + 58) = 0;
      *(_DWORD *)(a3 + 12) = 1116213084;
    }

    if ([a2 containsObject:CMNatalimeterSetUserAgeYr])
    {
      *(_BYTE *)(a3 + 56) = 0;
      *(_DWORD *)(a3 + 20) = 1106247680;
    }

    id result = [a2 containsObject:CMNatalimeterSetUserBetaBlockerUse];
    if ((_DWORD)result) {
      *(_BYTE *)(a3 + 48) = 0;
    }
  }

  return result;
}

void sub_100E14758(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  __int128 v9 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a5 = *(_OWORD *)a3;
  *(_OWORD *)(a5 + 16) = v9;
  *(_OWORD *)(a5 + 32) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a5 + 44) = *(_OWORD *)(a3 + 44);
  uint64_t v10 = CMNatalimeterSetUserBiologicalSex;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserBiologicalSex])
  {
    int v11 = sub_1003DA0F4((uint64_t)objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v10), "intValue"));
    *(_DWORD *)a5 = v11 != 2;
    *(_DWORD *)(a5 + 4) = v11;
  }

  uint64_t v12 = CMNatalimeterSetUserHeightMeter;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserHeightMeter])
  {
    objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v12), "floatValue");
    *(_BYTE *)(a5 + 57) = 1;
    *(_DWORD *)(a5 + 8) = v13;
  }

  uint64_t v14 = CMNatalimeterSetUserWeightKG;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserWeightKG])
  {
    objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v14), "floatValue");
    *(_BYTE *)(a5 + 58) = 1;
    *(_DWORD *)(a5 + 12) = v15;
  }

  uint64_t v16 = CMNatalimeterSetUserAgeYr;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserAgeYr])
  {
    objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v16), "floatValue");
    *(_BYTE *)(a5 + 56) = 1;
    *(_DWORD *)(a5 + 20) = v17;
  }

  uint64_t v18 = CMNatalimeterSetUserPal;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserPal])
  {
    objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v18), "floatValue");
    *(float *)(a5 + 36) = v19;
    *(_DWORD *)(a1 + 400) = (int)(float)(*(float *)(a3 + 36) - v19);
  }

  uint64_t v20 = CMNatalimeterSetUserHronset;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserHronset])
  {
    objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v20), "floatValue");
    *(_DWORD *)(a5 + 32) = v21;
  }

  uint64_t v22 = CMNatalimeterSetUserCondition;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserCondition]) {
    *(_DWORD *)(a5 + 40) = objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v22), "intValue");
  }
  uint64_t v23 = CMNatalimeterSetUserBetaBlockerUse;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserBetaBlockerUse]) {
    *(_BYTE *)(a5 + 48) = objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v23), "BOOLValue");
  }
  uint64_t v24 = CMNatalimeterSetUserRunVo2max;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserRunVo2max])
  {
    objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v24), "floatValue");
    *(_DWORD *)(a5 + 44) = v25;
  }

  uint64_t v26 = CMNatalimeterSetUserAdaptiveExerciseMinuteThreshold;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserAdaptiveExerciseMinuteThreshold])
  {
    objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v26), "floatValue");
    *(_DWORD *)(a5 + 52) = v27;
  }

  uint64_t v28 = CMNatalimeterSetUserVo2max;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserVo2max])
  {
    objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v28), "floatValue");
    *(_DWORD *)(a5 + 16) = v29;
  }

  uint64_t v30 = CMNatalimeterSetUserHrmax;
  if ([a2 objectForKeyedSubscript:CMNatalimeterSetUserHrmax])
  {
    objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v30), "floatValue");
    *(_DWORD *)(a5 + 28) = v31;
  }

  sub_1003DAEEC(a5);
  *(_DWORD *)(a5 + 24) = v32;
  int v33 = *(unsigned __int8 *)(a3 + 48);
  int v34 = *(unsigned __int8 *)(a5 + 48);
  if (a4)
  {
    id v35 = [a2 objectForKeyedSubscript:v24];
    uint64_t v36 = CMNatalimeterSetUserOnsetVo2max;
    id v37 = [a2 objectForKeyedSubscript:CMNatalimeterSetUserOnsetVo2max];
    id v38 = [a2 objectForKeyedSubscript:v18];
    __int128 v39 = *(_OWORD *)(a5 + 16);
    __int128 v69 = *(_OWORD *)a5;
    __int128 v70 = v39;
    v71[0] = *(_OWORD *)(a5 + 32);
    *(_OWORD *)((char *)v71 + 12) = *(_OWORD *)(a5 + 44);
    sub_1003DA2B8((uint64_t)&v69);
    float v41 = v40;
    float v42 = 7.0;
    if (v37)
    {
      objc_msgSend(objc_msgSend(a2, "objectForKeyedSubscript:", v36), "floatValue");
      float v42 = v43;
    }

    float v44 = *(float *)(a5 + 44);
    if (!*(_BYTE *)(a1 + 392)) {
      float v44 = 7.0;
    }
    float v45 = fmaxf(fmaxf(v44, v41), v42);
    float v46 = v45;
    if (v33 == v34) {
      float v46 = sub_100E15348(a1, v45, *(float *)(a3 + 16));
    }
    HIDWORD(v66) = v37 != 0LL;
    BOOL v67 = v38 != 0LL;
    BOOL v47 = v35 != 0LL;
    *(float *)(a5 + 16) = fmaxf(v46, 7.0);
    double v48 = v41;
    double v49 = v45;
  }

  else
  {
    HIDWORD(v66) = 0;
    BOOL v67 = 0;
    BOOL v47 = 0;
    double v49 = 7.0;
    float v46 = 7.0;
    float v42 = 7.0;
    double v48 = 7.0;
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  __int16 v50 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
  {
    double v51 = *(float *)(a5 + 44);
    int v52 = *(unsigned __int8 *)(a1 + 392);
    double v53 = *(float *)(a3 + 16);
    double v54 = *(float *)(a5 + 16);
    double v55 = *(float *)(a5 + 52);
    *(_DWORD *)buf = 134221312;
    double v101 = v51;
    __int16 v102 = 1024;
    int v103 = v52;
    __int16 v104 = 1024;
    BOOL v105 = v47;
    __int16 v106 = 2048;
    double v107 = v42;
    __int16 v108 = 1024;
    int v109 = HIDWORD(v66);
    __int16 v110 = 2048;
    double v111 = v48;
    __int16 v112 = 1024;
    BOOL v113 = v67;
    __int16 v114 = 2048;
    double v115 = v53;
    __int16 v116 = 2048;
    double v117 = v49;
    __int16 v118 = 2048;
    double v119 = v46;
    __int16 v120 = 2048;
    double v121 = v54;
    __int16 v122 = 1024;
    int v123 = a4;
    __int16 v124 = 1024;
    BOOL v125 = v33 != v34;
    __int16 v126 = 2048;
    double v127 = v55;
    _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_INFO,  "UserProfile,runVo2maxVal,%f,runVo2maxFlag,%d,runVo2maxUpdatedFlag,%d,hronsetVo2max,%f,hronsetVo2maxFlag,%d,derived Vo2max,%f,derivedVo2maxFlag,%d,oldVo2max,%f,estimatedVo2max,%f,mergedVo2max,%f,boundedVo2max,%f,doMerge,%d,betaBlo ckerUseChanged,%d,adaptiveEmThresh,%f",  buf,  0x76u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    double v57 = *(float *)(a5 + 44);
    int v58 = *(unsigned __int8 *)(a1 + 392);
    double v59 = *(float *)(a3 + 16);
    double v60 = *(float *)(a5 + 16);
    double v61 = *(float *)(a5 + 52);
    int v72 = 134221312;
    double v73 = v57;
    __int16 v74 = 1024;
    int v75 = v58;
    __int16 v76 = 1024;
    BOOL v77 = v47;
    __int16 v78 = 2048;
    double v79 = v42;
    __int16 v80 = 1024;
    int v81 = HIDWORD(v66);
    __int16 v82 = 2048;
    double v83 = v48;
    __int16 v84 = 1024;
    BOOL v85 = v67;
    __int16 v86 = 2048;
    double v87 = v59;
    __int16 v88 = 2048;
    double v89 = v49;
    __int16 v90 = 2048;
    double v91 = v46;
    __int16 v92 = 2048;
    double v93 = v60;
    __int16 v94 = 1024;
    int v95 = a4;
    __int16 v96 = 1024;
    BOOL v97 = v33 != v34;
    __int16 v98 = 2048;
    double v99 = v61;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "UserProfile,runVo2maxVal,%f,runVo2maxFlag,%d,runVo2maxUpdatedFlag,%d,hronsetVo2max,%f,hronsetVo2maxFlag,%d,derived Vo2max,%f,derivedVo2maxFlag,%d,oldVo2max,%f,estimatedVo2max,%f,mergedVo2max,%f,boundedVo2max,%f,doMerge,%d,betaBlo ckerUseChanged,%d,adaptiveEmThresh,%f",  COERCE_DOUBLE(&v72),  118,  v67,  *(double *)&a1,  (_DWORD)v69,  *((double *)&v69 + 1),  (_DWORD)v70,  *((double *)&v70 + 1),  *(double *)v71,  *((double *)v71 + 1),  *(double *)&v71[1],  DWORD2(v71[1]));
    uint64_t v63 = (uint8_t *)v62;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLBodyMetrics CLNatalimetryNotifier::setUserProfileToBodyMetrics(NSDictionary *, const CLBodyMetrics &, BOOL) const",  "%s\n",  v62);
    if (v63 != buf) {
      free(v63);
    }
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  uint64_t v56 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138477827;
    double v101 = *(double *)&a2;
    _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_INFO,  "UserProfile, update completed with result, %{private}@",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v72 = 138477827;
    double v73 = *(double *)&a2;
    LODWORD(v66) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  1LL,  "UserProfile, update completed with result, %{private}@",  &v72,  v66);
    uint64_t v65 = (uint8_t *)v64;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLBodyMetrics CLNatalimetryNotifier::setUserProfileToBodyMetrics(NSDictionary *, const CLBodyMetrics &, BOOL) const",  "%s\n",  v64);
    if (v65 != buf) {
      free(v65);
    }
  }

uint64_t sub_100E14FAC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 368);
  if (v2)
  {
    uint64_t v3 = (_OWORD *)(*(void *)(a1 + 2752) + 1352LL);
    *(_OWORD *)&v23[12] = *(_OWORD *)(*(void *)(a1 + 2752) + 1396LL);
    __int128 v4 = v3[1];
    *(_OWORD *)buf = *v3;
    __int128 v22 = v4;
    *(_OWORD *)uint64_t v23 = v3[2];
    if (v23[25])
    {
      v20[0] = *(float *)&buf[8];
      sub_1002AC820(v2, CMNatalimeterSetUserHeightMeter, v20);
    }

    else
    {
      sub_1002A66DC(v2);
    }

    uint64_t v10 = *(void *)(a1 + 368);
    if (v23[26])
    {
      v20[0] = *(float *)&buf[12];
      sub_1002AC820(v10, CMNatalimeterSetUserWeightKG, v20);
    }

    else
    {
      sub_1002A66DC(v10);
    }

    uint64_t v11 = *(void *)(a1 + 368);
    if (v23[24])
    {
      v20[0] = *((float *)&v22 + 1);
      sub_1002AC820(v11, CMNatalimeterSetUserAgeYr, v20);
    }

    else
    {
      sub_1002A66DC(v11);
    }

    uint64_t v12 = *(void *)(a1 + 368);
    LODWORD(v20[0]) = *(_DWORD *)buf;
    sub_1002AC288(v12, CMNatalimeterSetUserBiologicalSex, v20);
    uint64_t v13 = *(void *)(a1 + 368);
    LODWORD(v20[0]) = *(_DWORD *)&buf[4];
    sub_1002AC288(v13, @"HKBiologicalSex", v20);
    uint64_t v14 = *(void *)(a1 + 368);
    v20[0] = *(float *)&v23[4];
    sub_1002AC820(v14, CMNatalimeterSetUserPal, v20);
    uint64_t v15 = *(void *)(a1 + 368);
    v20[0] = *((float *)&v22 + 2);
    sub_1002AC820(v15, CMNatalimeterSetUserHrmin, v20);
    uint64_t v16 = *(void *)(a1 + 368);
    v20[0] = *(float *)&v22;
    sub_1002AC820(v16, CMNatalimeterSetUserVo2max, v20);
    uint64_t v17 = *(void *)(a1 + 368);
    v20[0] = *(float *)&v23[12];
    sub_1002AC820(v17, CMNatalimeterSetUserRunVo2max, v20);
    uint64_t v18 = *(void *)(a1 + 368);
    v20[0] = *(float *)&v23[20];
    sub_1002AC820(v18, CMNatalimeterSetUserAdaptiveExerciseMinuteThreshold, v20);
    uint64_t v19 = *(void *)(a1 + 368);
    LODWORD(v20[0]) = *(_DWORD *)&v23[8];
    sub_1002AC288(v19, CMNatalimeterSetUserCondition, v20);
    sub_1002AB464(*(void *)(a1 + 368), CMNatalimeterSetUserBetaBlockerUse, &v23[16]);
    return (*(uint64_t (**)(void))(**(void **)(a1 + 368) + 944LL))(*(void *)(a1 + 368));
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    float v5 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "UserProfile, Persistent store not yet initialized ",  buf,  2u);
    }

    BOOL v6 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v6)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      LOWORD(v20[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  17LL,  "UserProfile, Persistent store not yet initialized ",  v20,  2);
      __int128 v9 = (uint8_t *)v8;
      sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLNatalimetryNotifier::persistCachedValues()", "%s\n", v8);
      if (v9 != buf) {
        free(v9);
      }
      return 0LL;
    }
  }

  return result;
}

float sub_100E15348(uint64_t a1, float a2, float a3)
{
  int v21 = 0;
  double v20 = 2.22507386e-308;
  uint64_t v6 = sub_1002F8DDC();
  sub_1002A7D20(v6, (uint64_t)@"NumActiveCalibrations", &v21);
  uint64_t v7 = sub_1002F8DDC();
  sub_1002A832C(v7, (uint64_t)@"TimeFirstPAL", &v20);
  float v8 = a2 - a3;
  float v9 = (float)(v8 * 100.0) / a3;
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  uint64_t v10 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    int v11 = *(_DWORD *)(a1 + 2800);
    uint64_t v12 = *(void *)(a1 + 2808);
    *(_DWORD *)buf = 67109632;
    int v28 = v11;
    __int16 v29 = 2048;
    uint64_t v30 = v12;
    __int16 v31 = 2048;
    double v32 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "UserProfile, Number of active vo2max calibrations, %d, first PAL estimate at, %.3f, VO2max delta, %f",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v15 = *(_DWORD *)(a1 + 2800);
    uint64_t v16 = *(void *)(a1 + 2808);
    v22[0] = 67109632;
    v22[1] = v15;
    __int16 v23 = 2048;
    uint64_t v24 = v16;
    __int16 v25 = 2048;
    double v26 = v9;
    LODWORD(v19) = 28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "UserProfile, Number of active vo2max calibrations, %d, first PAL estimate at, %.3f, VO2max delta, %f",  v22,  v19,  v20);
    uint64_t v18 = (uint8_t *)v17;
    sub_10029211C("Generic", 1LL, 0, 2LL, "float CLNatalimetryNotifier::mergeVo2max(float, float) const", "%s\n", v17);
    if (v18 != buf) {
      free(v18);
    }
  }

  double v13 = -2.0;
  if (v9 > 0.0) {
    double v13 = 20.0;
  }
  return v13 * fabsf(v8) / 100.0 + a3;
}

BOOL sub_100E155C8(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 376);
  if (*(_BYTE *)(a1 + 376))
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    uint64_t v3 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "UserProfile, read before device unlock",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      LOWORD(v24[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "UserProfile, read before device unlock",  v24,  2);
      float v5 = (uint8_t *)v4;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLNatalimetryNotifier::readFromDisk(CLBodyMetrics &)", "%s\n", v4);
      if (v5 != buf) {
        free(v5);
      }
    }
  }

  else
  {
    float v8 = operator new(0x80uLL);
    sub_10030ABE8((uint64_t)v8, *(void *)(a1 + 32), "userinfo", 1, 0, 0);
    uint64_t v9 = *(void *)(a1 + 368);
    *(void *)(a1 + 368) = v8;
    if (v9)
    {
      (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
      float v8 = *(void **)(a1 + 368);
    }

    *(_DWORD *)buf = 0;
    sub_1002A7D20((uint64_t)v8, CMNatalimeterSetUserBiologicalSex, buf);
    v24[0] = 0;
    sub_1002A7D20(*(void *)(a1 + 368), (uint64_t)@"HKBiologicalSex", v24);
    uint64_t v10 = (uint64_t *)(a1 + 368);
    int v23 = 1071225242;
    sub_1002A827C(*v10, CMNatalimeterSetUserHeightMeter, (float *)&v23);
    float v12 = *(float *)&v23;
    if (!v11) {
      float v12 = 1.7;
    }
    *(_BYTE *)(a2 + 57) = v11;
    *(float *)(a2 + 8) = v12;
    int v22 = 1116213084;
    sub_1002A827C(*v10, CMNatalimeterSetUserWeightKG, (float *)&v22);
    float v14 = *(float *)&v22;
    if (!v13) {
      float v14 = 68.03;
    }
    *(_BYTE *)(a2 + 58) = v13;
    *(float *)(a2 + 12) = v14;
    sub_1002A827C(*v10, CMNatalimeterSetUserVo2max, (float *)(a2 + 16));
    sub_1002A827C(*v10, CMNatalimeterSetUserRunVo2max, (float *)(a2 + 44));
    int v21 = -1082130432;
    sub_1002A827C(*v10, CMNatalimeterSetUserAdaptiveExerciseMinuteThreshold, (float *)&v21);
    *(_DWORD *)(a2 + 52) = v21;
    int v20 = 1106247680;
    sub_1002A827C(*v10, CMNatalimeterSetUserAgeYr, (float *)&v20);
    float v16 = *(float *)&v20;
    if (!v15) {
      float v16 = 30.0;
    }
    *(_BYTE *)(a2 + 56) = v15;
    *(float *)(a2 + 20) = v16;
    sub_1002A827C(*v10, CMNatalimeterSetUserHrmin, (float *)(a2 + 24));
    sub_1002A827C(*v10, CMNatalimeterSetUserPal, (float *)(a2 + 36));
    int v19 = 0;
    sub_1002A7D20(*v10, CMNatalimeterSetUserCondition, &v19);
    *(_DWORD *)a2 = *(_DWORD *)buf;
    *(_DWORD *)(a2 + 4) = sub_1003DA0F4(v24[0]);
    *(_DWORD *)(a2 + 40) = v19;
    BOOL v18 = 0;
    sub_1002A6FD4(*v10, CMNatalimeterSetUserBetaBlockerUse, &v18);
    *(_BYTE *)(a2 + 48) = v18;
  }

  return v2 == 0;
}

void sub_100E159B4(_Unwind_Exception *a1)
{
}

uint64_t sub_100E159D0(void *a1)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (sub_100E15D98(a1 + 56, &v12) && vabdd_f64(*(double *)&v12, Current) < 10.0)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    uint64_t v3 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134218752;
      double v23 = Current;
      __int16 v24 = 2048;
      uint64_t v25 = v12;
      __int16 v26 = 2048;
      uint64_t v27 = v13;
      __int16 v28 = 1024;
      int v29 = 1;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "GPS availability at time %lf, companion time, %lf, GPS timestamp, %lf, %d",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      int v14 = 134218752;
      double v15 = Current;
      __int16 v16 = 2048;
      uint64_t v17 = v12;
      __int16 v18 = 2048;
      uint64_t v19 = v13;
      __int16 v20 = 1024;
      int v21 = 1;
      LODWORD(v11) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "GPS availability at time %lf, companion time, %lf, GPS timestamp, %lf, %d",  COERCE_DOUBLE(&v14),  v11,  *(double *)&v12,  DWORD2(v12));
      uint64_t v10 = (uint8_t *)v9;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryNotifier::checkAndNotifyGpsAvailability()", "%s\n", v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    uint8_t v4 = 1;
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    float v5 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      double v23 = Current;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "GPS not available at time %lf", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      int v14 = 134217984;
      double v15 = Current;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "GPS not available at time %lf",  COERCE_DOUBLE(&v14));
      float v8 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryNotifier::checkAndNotifyGpsAvailability()", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
    }

    uint8_t v4 = 0;
  }

  bzero(buf, 0x590uLL);
  buf[0] = v4;
  int v14 = 1;
  return (*(uint64_t (**)(void *, int *, uint8_t *, uint64_t, uint64_t, void))(*a1 + 152LL))( a1,  &v14,  buf,  1LL,  0xFFFFFFFFLL,  0LL);
}

uint64_t sub_100E15D98(void *a1, _OWORD *a2)
{
  uint64_t v2 = a1[4];
  if (a1[5] == v2) {
    return 0LL;
  }
  unint64_t v3 = a1[7];
  unint64_t v4 = v3 + a1[8];
  unint64_t v5 = v4 / 0x15;
  unint64_t v6 = v4 % 0x15;
  uint64_t v7 = *(void *)(v2 + 8 * (v4 / 0x15)) + 192 * (v4 % 0x15);
  if (v7 == *(void *)(v2 + 8 * (v3 / 0x15)) + 192 * (v3 % 0x15)) {
    return 0LL;
  }
  if (!v6) {
    uint64_t v7 = *(void *)(v2 + 8 * v5 - 8) + 4032LL;
  }
  __int128 v8 = *(_OWORD *)(v7 - 192);
  __int128 v9 = *(_OWORD *)(v7 - 176);
  __int128 v10 = *(_OWORD *)(v7 - 144);
  a2[2] = *(_OWORD *)(v7 - 160);
  a2[3] = v10;
  *a2 = v8;
  a2[1] = v9;
  __int128 v11 = *(_OWORD *)(v7 - 128);
  __int128 v12 = *(_OWORD *)(v7 - 112);
  __int128 v13 = *(_OWORD *)(v7 - 80);
  a2[6] = *(_OWORD *)(v7 - 96);
  a2[7] = v13;
  a2[4] = v11;
  a2[5] = v12;
  __int128 v14 = *(_OWORD *)(v7 - 64);
  __int128 v15 = *(_OWORD *)(v7 - 48);
  __int128 v16 = *(_OWORD *)(v7 - 16);
  a2[10] = *(_OWORD *)(v7 - 32);
  a2[11] = v16;
  a2[8] = v14;
  a2[9] = v15;
  return 1LL;
}

void sub_100E15E54(void *a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 2)
  {
    uint64_t v25 = *(void *)(a4 + 16);
    if (v25 == 1)
    {
      *((_BYTE *)a1 + 4840) = 0;
      uint64_t v32 = sub_1008FA854(0);
      (*(void (**)(uint64_t, void, void))(*(void *)(v32 + 56) + 24LL))(v32 + 56, 0LL, 0LL);
      char v33 = 0;
      a1[352] = 0LL;
      a1[353] = 0x7FF0000000000000LL;
      a1[354] = 0LL;
      *((_BYTE *)a1 + 2840) = 0;
      *((int64x2_t *)a1 + 178) = vdupq_n_s64(0xFFF0000000000000LL);
      a1[358] = 0LL;
      *((_DWORD *)a1 + 718) = 0;
      *((_BYTE *)a1 + 2888) = 0;
    }

    else
    {
      if (v25) {
        goto LABEL_30;
      }
      *((_BYTE *)a1 + 4840) = 1;
      unint64_t v26 = sub_100672D30(*(void *)(a4 + 112));
      if ((_DWORD)v26 == 14) {
        uint64_t v27 = *(unsigned int *)(a4 + 128);
      }
      else {
        uint64_t v27 = 0LL;
      }
      uint64_t v28 = sub_1008FA854(0);
      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)(v28 + 56) + 24LL))(v28 + 56, v26, v27);
      a1[352] = 0LL;
      a1[353] = 0x7FF0000000000000LL;
      a1[354] = 0LL;
      *((_BYTE *)a1 + 2840) = 0;
      *((int64x2_t *)a1 + 178) = vdupq_n_s64(0xFFF0000000000000LL);
      a1[358] = 0LL;
      *((_DWORD *)a1 + 718) = 0;
      a1[360] = *(void *)(a4 + 24);
      *((_BYTE *)a1 + 2888) = 0;
      int v29 = *((_DWORD *)a1 + 100);
      uint64_t v30 = sub_100F5A080();
      if (v29)
      {
        sub_100F5C5C4(v30, 1);
        __int16 v31 = (dispatch_queue_t *)sub_100B354EC();
        *(_DWORD *)buf = 1;
      }

      else
      {
        sub_100F5C5C4(v30, 2);
        __int16 v31 = (dispatch_queue_t *)sub_100B354EC();
        *(_DWORD *)buf = 2;
      }

      sub_100B36F60(v31, (uint64_t)buf);
      char v33 = 1;
    }

    *((_BYTE *)a1 + 1115) = v33;
LABEL_30:
    if (sub_100BEF640(a4) == 1)
    {
      double v34 = sub_100A9C9B8((uint64_t)a1 + 2889, a1[344] + 1352LL, (double *)buf);
      *(float *)&double v34 = v34;
      uint64_t v100 = CMNatalimeterSetUserHrmax;
      double v101 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v34);
      sub_100E13D68( (uint64_t)a1,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v101,  &v100,  1LL),  0,  0LL);
      sub_100C8089C((uint64_t)(a1 + 365), (float64x2_t *)buf);
    }

    sub_100C80908((uint64_t)(a1 + 365), a4, (uint64_t)&v95);
    if (*((_DWORD *)a1 + 99) == 2 && *(double *)&v96 != -1.0 && BYTE11(v96))
    {
      uint64_t v35 = sub_1002F8DDC();
      sub_1002A7D20(v35, (uint64_t)@"NumActiveCalibrations", (_DWORD *)a1 + 700);
      ++*((_DWORD *)a1 + 700);
      uint64_t v36 = sub_1002F8DDC();
      sub_1002AC288(v36, @"NumActiveCalibrations", a1 + 350);
      uint64_t v37 = sub_1006E27E8();
      sub_100413284(v37, buf);
      sub_1002A7CB0(*(uint64_t *)buf, "Vo2MaxCalLevel", (_DWORD *)a1 + 99);
      id v38 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        __int128 v39 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v40 = __ldaxr(v39);
        while (__stlxr(v40 - 1, v39));
        if (!v40)
        {
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v38);
        }
      }

      *((_BYTE *)a1 + 392) = 1;
      uint64_t v93 = CMNatalimeterSetUserRunVo2max;
      __int16 v94 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)&v96 / 3.5);
      sub_100E13D68( (uint64_t)a1,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v94,  &v93,  1LL),  1,  0LL);
      bzero(&v82[8], 0x548uLL);
      *(_OWORD *)int v81 = v97;
      *(_OWORD *)&v81[16] = v98;
      *(void *)__int16 v82 = v99;
      __int128 v79 = v95;
      __int128 v80 = v96;
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101885708);
      }
      float v41 = (os_log_s *)qword_101934688;
      if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134284033;
        *(void *)&uint8_t buf[4] = v96;
        *(_WORD *)&_BYTE buf[12] = 1025;
        *(_DWORD *)&buf[14] = BYTE9(v96);
        *(_WORD *)&buf[18] = 1025;
        *(_DWORD *)&buf[20] = BYTE10(v96);
        _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_INFO,  "VO2Max, estimate, %{private}.2f, betaBlockerUser, %{private}d, eligibleForHealthKit, %{private}d",  buf,  0x18u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934680 != -1) {
          dispatch_once(&qword_101934680, &stru_101885708);
        }
        int v75 = 134284033;
        uint64_t v76 = v96;
        __int16 v77 = 1025;
        *(_DWORD *)__int16 v78 = BYTE9(v96);
        v78[2] = 1025;
        *(_DWORD *)&v78[3] = BYTE10(v96);
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  1LL,  "VO2Max, estimate, %{private}.2f, betaBlockerUser, %{private}d, eligibleForHealthKit, %{private}d",  &v75,  24);
        int v72 = (char *)v71;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notificat ion &, const CLMotionStateMediator_Type::NotificationData &)",  "%s\n",  v71);
        if (v72 != buf) {
          free(v72);
        }
      }

      *(_DWORD *)buf = 6;
      (*(void (**)(void *, _BYTE *, __int128 *, uint64_t, uint64_t, void))(*a1 + 152LL))( a1,  buf,  &v79,  1LL,  0xFFFFFFFFLL,  0LL);
    }

    else if (*(void *)(a4 + 16) == 1LL)
    {
      unint64_t v42 = sub_100BEF6EC(*(void *)(a4 + 112), *(void *)(a4 + 120));
      if (v42 <= 0x18 && ((1LL << v42) & 0x1028000) != 0)
      {
        HIDWORD(v99) = *(_DWORD *)(a4 + 32);
        bzero(&v106[8], 0x548uLL);
        *(_OWORD *)BOOL v105 = v97;
        *(_OWORD *)&v105[16] = v98;
        *(void *)__int16 v106 = v99;
        *(_OWORD *)&uint8_t buf[16] = v96;
        *(_OWORD *)buf = v95;
        LODWORD(v79) = 6;
        (*(void (**)(void *, __int128 *, _BYTE *, uint64_t, uint64_t, void))(*a1 + 152LL))( a1,  &v79,  buf,  1LL,  0xFFFFFFFFLL,  0LL);
      }
    }

    uint64_t v43 = v98;
    if (*(double *)&v98 != 0.0)
    {
      bzero(&buf[8], 0x588uLL);
      *(void *)buf = v43;
      LODWORD(v79) = 8;
      (*(void (**)(void *, __int128 *, _BYTE *, void, uint64_t, void))(*a1 + 152LL))( a1,  &v79,  buf,  0LL,  0xFFFFFFFFLL,  0LL);
    }

    if (BYTE12(v97))
    {
      float v44 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", (char *)&v96 + 12);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_101885728);
      }
      float v45 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
      {
        float v46 = -[NSUUID UUIDString](v44, "UUIDString");
        *(_DWORD *)buf = 138412290;
        *(void *)&uint8_t buf[4] = v46;
        _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEFAULT,  "Sending sessionId %@ to CLVO2MaxCloudKitManager",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_101885728);
        }
        uint64_t v67 = qword_1019346E8;
        uint64_t v68 = -[NSUUID UUIDString](v44, "UUIDString");
        LODWORD(v79) = 138412290;
        *(void *)((char *)&v79 + 4) = v68;
        LODWORD(v74) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v67,  0LL,  "Sending sessionId %@ to CLVO2MaxCloudKitManager",  &v79,  *(void *)&v74);
        __int128 v70 = (char *)v69;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notificat ion &, const CLMotionStateMediator_Type::NotificationData &)",  "%s\n",  v69);
        if (v70 != buf) {
          free(v70);
        }
      }

      objc_msgSend( objc_msgSend(objc_msgSend((id)a1[4], "vendor"), "proxyForService:", @"CLVO2MaxCloudKitManager"),  "saveInputsAndOutputsForSessionId:",  -[NSUUID UUIDString](v44, "UUIDString"));
    }

    (*(void (**)(void, uint64_t))(*(void *)a1[347] + 24LL))(a1[347], a4);
    (*(void (**)(void, uint64_t))(*(void *)a1[346] + 8LL))(a1[346], a4);
    sub_100F1D958((uint64_t)(a1 + 618), a4, (uint64_t)&v79);
    if (!v81[8]) {
      goto LABEL_74;
    }
    if ((_BYTE)v80)
    {
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_101885748);
      }
      BOOL v47 = (os_log_s *)qword_1019347A8;
      if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        *(void *)&uint8_t buf[4] = v79;
        *(_WORD *)&_BYTE buf[12] = 2048;
        *(void *)&buf[14] = *((void *)&v79 + 1);
        _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "Cycling Session Ended, ftp: %f confidence %f",  buf,  0x16u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_74;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_101885748);
      }
      int v75 = 134218240;
      uint64_t v76 = v79;
      __int16 v77 = 2048;
      *(void *)__int16 v78 = *((void *)&v79 + 1);
      LODWORD(v74) = 22;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "Cycling Session Ended, ftp: %f confidence %f",  COERCE_DOUBLE(&v75),  v74);
      double v49 = (char *)v48;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notificatio n &, const CLMotionStateMediator_Type::NotificationData &)",  "%s\n",  v48);
    }

    else
    {
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_101885748);
      }
      __int16 v50 = (os_log_s *)qword_1019347A8;
      if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEBUG,  "Cycling session ended but was not eligible for FTP calculation.",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_74;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_101885748);
      }
      LOWORD(v75) = 0;
      LODWORD(v74) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  2LL,  "Cycling session ended but was not eligible for FTP calculation.",  &v75,  *(void *)&v74);
      double v49 = (char *)v73;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notificatio n &, const CLMotionStateMediator_Type::NotificationData &)",  "%s\n",  v73);
    }

    if (v49 != buf) {
      free(v49);
    }
LABEL_74:
    sub_1003DBFF4(a1[344], a4);
    return;
  }

  if (!*a3)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    unint64_t v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      int v7 = *(_DWORD *)(a4 + 8);
      int v8 = *(_DWORD *)(a4 + 12);
      int v9 = *(_DWORD *)(a4 + 20);
      int v10 = *(_DWORD *)(a4 + 24);
      int v11 = *(_DWORD *)(a4 + 60);
      uint64_t v12 = *(void *)(a4 + 64);
      uint64_t v13 = *(void *)(a4 + 88);
      double v14 = *(float *)(a4 + 152);
      int v15 = *(_DWORD *)(a4 + 176);
      int v16 = *(unsigned __int8 *)(a4 + 180);
      double v17 = *(float *)(a4 + 160);
      double v18 = *(float *)(a4 + 164);
      double v19 = *(float *)(a4 + 168);
      double v20 = *(float *)(a4 + 172);
      double v21 = *(float *)(a4 + 156);
      *(_DWORD *)buf = 67112704;
      *(_DWORD *)&uint8_t buf[4] = v7;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v8;
      *(_WORD *)&buf[14] = 1024;
      *(_DWORD *)&uint8_t buf[16] = v9;
      *(_WORD *)&buf[20] = 1024;
      *(_DWORD *)&buf[22] = v10;
      *(_WORD *)&buf[26] = 1024;
      *(_DWORD *)&buf[28] = v11;
      *(_WORD *)BOOL v105 = 2048;
      *(void *)&v105[2] = v12;
      *(_WORD *)&v105[10] = 2048;
      *(void *)&v105[12] = v13;
      *(_WORD *)&v105[20] = 2048;
      *(double *)&v105[22] = v14;
      *(_WORD *)&v105[30] = 1024;
      *(_DWORD *)__int16 v106 = v15;
      *(_WORD *)&v106[4] = 1024;
      *(_DWORD *)&v106[6] = v16;
      __int16 v107 = 2048;
      double v108 = v17;
      __int16 v109 = 2048;
      double v110 = v18;
      __int16 v111 = 2048;
      double v112 = v19;
      __int16 v113 = 2048;
      double v114 = v20;
      __int16 v115 = 2048;
      double v116 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "ActivitySpectator,activity{State,%d,Confidence,%d,MountedState,%d,MountedConfidence,%d,exitState,%d,estExitTime, %f,startTime,%f},nataliFeatures{fVectorMagnitude,%f,fEpochType,%d,fStanding,%d,fMachineFrequency,%f,fRowStrokeFr equency,%f,fRowStrokeAmplitude,%f,fRowStrokePower,%f,fPushVectorMagnitude,%f}",  buf,  0x7Cu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      int v51 = *(_DWORD *)(a4 + 8);
      int v52 = *(_DWORD *)(a4 + 12);
      int v53 = *(_DWORD *)(a4 + 20);
      int v54 = *(_DWORD *)(a4 + 24);
      uint64_t v55 = *(void *)(a4 + 64);
      uint64_t v56 = *(void *)(a4 + 88);
      double v57 = *(float *)(a4 + 152);
      int v58 = *(_DWORD *)(a4 + 176);
      int v59 = *(unsigned __int8 *)(a4 + 180);
      double v60 = *(float *)(a4 + 160);
      double v61 = *(float *)(a4 + 164);
      double v62 = *(float *)(a4 + 168);
      double v63 = *(float *)(a4 + 172);
      double v64 = *(float *)(a4 + 156);
      LODWORD(v79) = 67112704;
      DWORD1(v79) = v51;
      WORD4(v79) = 1024;
      *(_DWORD *)((char *)&v79 + 10) = v52;
      HIWORD(v79) = 1024;
      WORD4(v80) = HIWORD(v54);
      WORD5(v80) = 1024;
      *(_WORD *)int v81 = 2048;
      *(void *)&v81[2] = v55;
      *(_WORD *)&v81[10] = 2048;
      *(void *)&v81[12] = v56;
      *(_WORD *)&v81[20] = 2048;
      *(double *)&v81[22] = v57;
      *(_WORD *)&v81[30] = 1024;
      *(_DWORD *)__int16 v82 = v58;
      *(_WORD *)&v82[4] = 1024;
      *(_DWORD *)&v82[6] = v59;
      __int16 v83 = 2048;
      double v84 = v60;
      __int16 v85 = 2048;
      double v86 = v61;
      __int16 v87 = 2048;
      double v88 = v62;
      __int16 v89 = 2048;
      double v90 = v63;
      __int16 v91 = 2048;
      double v92 = v64;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "ActivitySpectator,activity{State,%d,Confidence,%d,MountedState,%d,MountedConfidence,%d,exitState,%d,estExitTime, %f,startTime,%f},nataliFeatures{fVectorMagnitude,%f,fEpochType,%d,fStanding,%d,fMachineFrequency,%f,fRowStrokeFr equency,%f,fRowStrokeAmplitude,%f,fRowStrokePower,%f,fPushVectorMagnitude,%f}",  &v79,  124,  v75,  HIDWORD(v76),  *(_DWORD *)&v78[1],  *(double *)&v78[5],  *(double *)&v79,  *((double *)&v79 + 1),  v53,  DWORD2(v80),  *(double *)v81,  *(double *)&v81[8],  *(double *)&v81[16],  *(double *)&v81[24],  *(double *)v82);
      uint64_t v66 = (char *)v65;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::onMotionStateMediatorNotification(int, const CLMotionStateMediator_Type::Notificatio n &, const CLMotionStateMediator_Type::NotificationData &)",  "%s\n",  v65);
      if (v66 != buf) {
        free(v66);
      }
    }

    if (*((_BYTE *)a1 + 4840) && *((_BYTE *)a1 + 424)) {
      sub_100253308((uint64_t)(a1 + 142));
    }
    *(double *)(a1[344] + 1416LL) = sub_100B88B90((double *)a1 + 606, *(double *)a4);
    (**(void (***)(void, uint64_t))a1[346])(a1[346], a4);
    __int128 v22 = *(_OWORD *)(a4 + 148);
    __int128 v23 = *(_OWORD *)(a4 + 164);
    *((_DWORD *)a1 + 686) = *(_DWORD *)(a4 + 180);
    *(_OWORD *)(a1 + 341) = v23;
    *(_OWORD *)(a1 + 339) = v22;
    if (CFAbsoluteTimeGetCurrent() - *((double *)a1 + 360) > 90.0 && *((_BYTE *)a1 + 2888))
    {
      float v24 = sub_1003DAE8C((float *)a1[344], *((double *)a1 + 353));
      if (v24 > 0.0)
      {
        uint64_t v102 = CMNatalimeterSetUserOnsetVo2max;
        int v103 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", v24);
        sub_100E13D68( (uint64_t)a1,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v103,  &v102,  1LL),  1,  0LL);
      }

      *((_BYTE *)a1 + 2888) = 0;
    }

    if (*(_BYTE *)(a4 + 208))
    {
    }
  }

void sub_100E16CCC(_Unwind_Exception *a1)
{
}

float sub_100E16CE8(uint64_t a1, CFAbsoluteTime Current, uint64_t a3, int *a4, uint64_t a5)
{
  switch(*a4)
  {
    case 2:
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      int v8 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v9 = *(void *)(a5 + 8);
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Received Onset notification from CatherineNotifier (%f bpm)!",  (uint8_t *)&buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        uint64_t v44 = *(void *)(a5 + 8);
        LODWORD(v59) = 134217984;
        *(void *)((char *)&v59 + 4) = v44;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Received Onset notification from CatherineNotifier (%f bpm)!",  COERCE_DOUBLE(&v59));
        float v46 = (char *)v45;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::onCatherineNotification(int, const CLCatherineNotifier_Type::Notification &, const CLCatherineNotifier_Type::NotificationData &)",  "%s\n",  v45);
      }

      uint64_t v66 = CMNatalimeterSetUserHronset;
      uint64_t v67 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a5 + 8));
      sub_100E13D68( a1,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v67,  &v66,  1LL),  0,  0LL);
      if ((*(_DWORD *)a5 - 3) <= 1)
      {
        __int128 v10 = *(_OWORD *)a5;
        __int128 v11 = *(_OWORD *)(a5 + 16);
        __int128 v12 = *(_OWORD *)(a5 + 32);
        *(_OWORD *)(a1 + 2864) = *(_OWORD *)(a5 + 48);
        *(_OWORD *)(a1 + 2848) = v12;
        *(_OWORD *)(a1 + 2832) = v11;
        *(_OWORD *)(a1 + 2816) = v10;
        *(_BYTE *)(a1 + 2888) = 1;
      }

      double Current = CFAbsoluteTimeGetCurrent();
      if (*(_BYTE *)(a1 + 353))
      {
        CFAbsoluteTime v13 = Current;
        *(void *)&__int128 v59 = &off_101857F30;
        *((CFAbsoluteTime *)&v59 + 1) = Current;
        uint64_t v60 = *(void *)a5;
        __int128 v61 = *(_OWORD *)(a5 + 8);
        char v62 = *(_BYTE *)(a5 + 24);
        __int128 v63 = *(_OWORD *)(a5 + 32);
        uint64_t v64 = *(void *)(a5 + 48);
        BOOL v65 = *(_DWORD *)(a5 + 56) == 5;
        uint64_t v14 = sub_100E00E14();
        sub_100E022E0(v14, (uint64_t)&v59);
        sub_101125260(&buf);
        sub_10113AC74(&buf);
        v58 |= 1u;
        CFAbsoluteTime v56 = v13;
        uint64_t v15 = v57;
        int v16 = *(_DWORD *)a5;
        *(_WORD *)(v57 + 68) |= 0x40u;
        *(_DWORD *)(v15 + 52) = v16;
        uint64_t v17 = v57;
        int v18 = *(_DWORD *)(a5 + 4);
        *(_WORD *)(v57 + 68) |= 0x80u;
        *(_DWORD *)(v17 + 56) = v18;
        uint64_t v19 = v57;
        uint64_t v20 = *(void *)(a5 + 8);
        *(_WORD *)(v57 + 68) |= 2u;
        *(void *)(v19 + 16) = v20;
        uint64_t v21 = v57;
        uint64_t v22 = *(void *)(a5 + 16);
        *(_WORD *)(v57 + 68) |= 1u;
        *(void *)(v21 + 8) = v22;
        uint64_t v23 = v57;
        LOBYTE(v18) = *(_BYTE *)(a5 + 24);
        *(_WORD *)(v57 + 68) |= 0x200u;
        *(_BYTE *)(v23 + 64) = v18;
        uint64_t v24 = v57;
        uint64_t v25 = *(void *)(a5 + 32);
        *(_WORD *)(v57 + 68) |= 0x10u;
        *(void *)(v24 + 40) = v25;
        uint64_t v26 = v57;
        uint64_t v27 = *(void *)(a5 + 40);
        *(_WORD *)(v57 + 68) |= 8u;
        *(void *)(v26 + 32) = v27;
        uint64_t v28 = v57;
        uint64_t v29 = *(void *)(a5 + 48);
        *(_WORD *)(v57 + 68) |= 4u;
        *(void *)(v28 + 24) = v29;
        uint64_t v30 = v57;
        int v31 = *(_DWORD *)(a5 + 56);
        *(_WORD *)(v57 + 68) |= 0x20u;
        *(_DWORD *)(v30 + 48) = v31;
        if (qword_1019A1D00 != -1) {
          dispatch_once(&qword_1019A1D00, &stru_101885768);
        }
        if (qword_1019A1D08) {
          sub_1011CF3D0(qword_1019A1D08, (uint64_t)&buf);
        }
        sub_101127D00((PB::Base *)&buf);
      }

      break;
    case 3:
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      uint64_t v32 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v33 = *(void *)(a5 + 8);
        LODWORD(buf) = 134217984;
        *(void *)((char *)&buf + 4) = v33;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "Updating min. HR, %f", (uint8_t *)&buf, 0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        uint64_t v47 = *(void *)(a5 + 8);
        LODWORD(v59) = 134217984;
        *(void *)((char *)&v59 + 4) = v47;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Updating min. HR, %f",  COERCE_DOUBLE(&v59));
        double v49 = (char *)v48;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::onCatherineNotification(int, const CLCatherineNotifier_Type::Notification &, const CLCatherineNotifier_Type::NotificationData &)",  "%s\n",  v48);
      }

      uint64_t v51 = CMNatalimeterSetUserHrmin;
      int v52 = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a5 + 8));
      sub_100E13D68( a1,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v52,  &v51,  1LL),  0,  0LL);
      break;
    case 5:
      sub_100C80758(a1 + 2920, (int *)a5);
      sub_100B88974((void *)(a1 + 4848), a5);
      uint64_t v39 = *(void *)(a5 + 8);
      double v40 = *(double *)(a5 + 16);
      *(void *)&__int128 buf = *(void *)(a5 + 40);
      *((void *)&buf + 1) = v39;
      BOOL v55 = *(_DWORD *)a5 == 4;
      double v41 = 1.0;
      if (!v55) {
        double v41 = v40;
      }
      double v54 = v41;
      LODWORD(Current) = sub_100E25600((void *)(a1 + 1304), (uint64_t)&buf).n128_u32[0];
      break;
    case 6:
      if (*(_DWORD *)(a5 + 24) == 2) {
        *(float *)&double Current = sub_100C8083C(a1 + 2920, *(double *)(a5 + 16));
      }
      break;
    case 7:
      float v42 = *(double *)(a5 + 16);
      float v43 = *(double *)(a5 + 24);
      sub_100C807C8(a1 + 2920, v42, v43);
      break;
    default:
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v34 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
      {
        int v35 = *a4;
        LODWORD(buf) = 67240192;
        DWORD1(buf) = v35;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "Natalimetry Notifier received unexpected catherine type: %{public}d",  (uint8_t *)&buf,  8u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        int v36 = *a4;
        LODWORD(v59) = 67240192;
        DWORD1(v59) = v36;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "Natalimetry Notifier received unexpected catherine type: %{public}d",  &v59,  8);
        id v38 = (char *)v37;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNatalimetryNotifier::onCatherineNotification(int, const CLCatherineNotifier_Type::Notification &, const CLCatherineNotifier_Type::NotificationData &)",  "%s\n",  v37);
      }

      break;
  }

  return *(float *)&Current;
}

void sub_100E174E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

double sub_100E17520(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = sub_100E25600((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

void sub_100E17528(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  if (*a3 == 1)
  {
    *(_BYTE *)(a1 + 377) = *((_BYTE *)a4 + 4);
  }

  else if (!*a3)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    unint64_t v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      int v7 = *(unsigned __int8 *)(a1 + 376);
      int v8 = *a4;
      BOOL v9 = *a4 != 1;
      *(_DWORD *)__int128 buf = 67109632;
      int v25 = v7;
      __int16 v26 = 1024;
      BOOL v27 = v9;
      __int16 v28 = 1024;
      int v29 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "UserProfile, Encrypted data availability, was, %d, now, %d, availability, %d",  buf,  0x14u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      int v12 = *(unsigned __int8 *)(a1 + 376);
      int v13 = *a4;
      BOOL v14 = *a4 != 1;
      v19[0] = 67109632;
      v19[1] = v12;
      __int16 v20 = 1024;
      BOOL v21 = v14;
      __int16 v22 = 1024;
      int v23 = v13;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "UserProfile, Encrypted data availability, was, %d, now, %d, availability, %d",  v19,  20,  v17);
      int v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::onDataProtectionNotification(int, const CLDataProtectionManager_Type::Notification & , const CLDataProtectionManager_Type::NotificationData &)",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }

    BOOL v10 = *a4 == 1;
    *(_BYTE *)(a1 + 376) = *a4 != 1;
    if (v10)
    {
      if (!*(_BYTE *)(a1 + 416)) {
        sub_100E102F0(a1);
      }
      uint64_t v17 = CMNatalimeterSetUserAdaptiveExerciseMinuteThreshold;
      *(float *)&double v11 = sub_100A9FE60(a1 + 4920, (float *)(*(void *)(a1 + 2752) + 1352LL));
      int v18 = +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v11);
      sub_100E13D68( a1,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL),  0,  0LL);
      if ([*(id *)(a1 + 384) count])
      {
      }
    }
  }

void sub_100E177E0(uint64_t a1, uint64_t a2)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  unint64_t v4 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    int v5 = *(unsigned __int8 *)(a1 + 376);
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "UserProfile, Received from SPU, data protection enabled %d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v6 = *(unsigned __int8 *)(a1 + 376);
    v9[0] = 67109120;
    v9[1] = v6;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "UserProfile, Received from SPU, data protection enabled %d",  v9);
    int v8 = (uint8_t *)v7;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::onStoredUserInfo(const CLMotionCoprocessorInterface::NotificationData *)",  "%s\n",  v7);
    if (v8 != buf) {
      free(v8);
    }
  }

  if (!*(_BYTE *)(a1 + 416))
  {
    sub_100E14758(a1, *(void **)(a1 + 384), a2, 1, (uint64_t)buf);
    sub_100E101C8(a1, (__int128 *)buf);
  }

void sub_100E179C0(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  if (!*a3)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      int v8 = *a4;
      int v7 = a4[1];
      *(_DWORD *)__int128 buf = 67240448;
      int v17 = v7;
      __int16 v18 = 1026;
      int v19 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Watch orientation settings updated, crown, %{public}d, wrist, %{public}d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      int v10 = *a4;
      int v9 = a4[1];
      v13[0] = 67240448;
      v13[1] = v9;
      __int16 v14 = 1026;
      int v15 = v10;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Watch orientation settings updated, crown, %{public}d, wrist, %{public}d",  v13,  14);
      int v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLNatalimetryNotifier::onWatchOrientationSettingsNotification(int, const CLWatchOrientationSettingsNotifier _Type::Notification &, const CLWatchOrientationSettingsNotifier_Type::NotificationData &)",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }

    *(void *)(a1 + 2704) = *(void *)a4;
  }

uint64_t sub_100E17B9C(uint64_t result, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v4 = result;
  int v5 = *a3;
  if (!*a3)
  {
    uint64_t v7 = *(void *)(result + 2752);
    if (*(_BYTE *)(a4 + 3)) {
      sub_1003DAAE4(v7);
    }
    else {
      sub_1003DA6FC(v7);
    }
    int v6 = *(uint64_t (**)(void))(**(void **)(v4 + 2776) + 8LL);
    return v6();
  }

  if (v5 == 5)
  {
    int v6 = *(uint64_t (**)(void))(**(void **)(result + 2776) + 16LL);
    return v6();
  }

  if (v5 == 4)
  {
    *(_DWORD *)(result + 4784) = *(_DWORD *)a4;
    int v6 = ***(uint64_t (****)(void))(result + 2776);
    return v6();
  }

  return result;
}

void sub_100E17C44(uint64_t a1, unint64_t *a2)
{
  v8.n128_u32[0] = 0;
  v8.n128_u64[1] = *a2;
  uint64_t v9 = 0LL;
  sub_100E17E10(a1 + 208, &v8);
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  unint64_t v3 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v4 = *a2;
    *(_DWORD *)__int128 buf = 134349056;
    unint64_t v13 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "ExerciseMinute, startTime, %{public}f",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    unint64_t v5 = *a2;
    int v10 = 134349056;
    unint64_t v11 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "ExerciseMinute, startTime, %{public}f",  &v10,  12);
    uint64_t v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalimetryNotifier::onExerciseMinuteUpdate(const ExerciseMinuteUpdate &)",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

uint64_t sub_100E17E10(uint64_t a1, __n128 *a2)
{
  uint64_t result = sub_100E259A0(*(void *)(a1 + 24), a2);
  if (!*(_BYTE *)(a1 + 41))
  {
    uint64_t result = sub_100D8A92C(*(void *)(a1 + 24) + 72LL);
    if ((_DWORD)result)
    {
      *(_BYTE *)(a1 + 41) = 1;
      return sub_100E13268(a1);
    }
  }

  return result;
}

void sub_100E17E64(uint64_t a1, unint64_t *a2)
{
}

uint64_t sub_100E17E6C(_BYTE *a1, _OWORD *a2)
{
  if (*((_BYTE *)a2 + 176))
  {
    sub_100E18228((uint64_t)(a1 + 144), (uint64_t)a2);
    double Current = CFAbsoluteTimeGetCurrent();
    if (a1[353]) {
      BOOL v5 = *((_BYTE *)a2 + 28) == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5)
    {
      double v6 = Current;
      sub_101125260(&v35);
      sub_10113AB78(&v35);
      v39 |= 1u;
      *(double *)&v37[74] = v6;
      uint64_t v7 = v38;
      uint64_t v8 = *((void *)a2 + 2);
      *(_WORD *)(v38 + 68) |= 0x10u;
      *(void *)(v7 + 40) = v8;
      uint64_t v9 = v38;
      int v10 = *((_DWORD *)a2 + 6);
      *(_WORD *)(v38 + 68) |= 0x20u;
      *(_DWORD *)(v9 + 48) = v10;
      uint64_t v11 = v38;
      LOBYTE(v10) = *((_BYTE *)a2 + 29);
      *(_WORD *)(v38 + 68) |= 0x400u;
      *(_BYTE *)(v11 + 65) = v10;
      uint64_t v12 = v38;
      uint64_t v13 = *((void *)a2 + 12);
      *(_WORD *)(v38 + 68) |= 2u;
      *(void *)(v12 + 16) = v13;
      uint64_t v14 = v38;
      int v15 = *((_DWORD *)a2 + 26);
      *(_WORD *)(v38 + 68) |= 0x40u;
      *(_DWORD *)(v14 + 52) = v15;
      uint64_t v16 = v38;
      int v17 = *((_DWORD *)a2 + 22);
      *(_WORD *)(v38 + 68) |= 0x80u;
      *(_DWORD *)(v16 + 56) = v17;
      uint64_t v18 = v38;
      uint64_t v19 = *((void *)a2 + 15);
      *(_WORD *)(v38 + 68) |= 4u;
      *(void *)(v18 + 24) = v19;
      uint64_t v20 = v38;
      uint64_t v21 = *((void *)a2 + 4);
      *(_WORD *)(v38 + 68) |= 8u;
      *(void *)(v20 + 32) = v21;
      uint64_t v22 = v38;
      uint64_t v23 = *((void *)a2 + 8);
      *(_WORD *)(v38 + 68) |= 1u;
      *(void *)(v22 + 8) = v23;
      uint64_t v24 = v38;
      LOBYTE(v17) = *((_BYTE *)a2 + 128);
      *(_WORD *)(v38 + 68) |= 0x200u;
      *(_BYTE *)(v24 + 64) = v17;
      if (qword_1019A1D00 != -1) {
        dispatch_once(&qword_1019A1D00, &stru_101885768);
      }
      if (qword_1019A1D08) {
        sub_1011CF3D0(qword_1019A1D08, (uint64_t)&v35);
      }
      sub_101127D00((PB::Base *)&v35);
    }

    sub_100C80114( (uint64_t)(a1 + 2920),  *((_DWORD *)a2 + 26),  *((unsigned __int8 *)a2 + 128),  *((unsigned __int8 *)a2 + 152),  (uint64_t)__dst,  *((double *)a2 + 2),  *((float *)a2 + 39),  *((double *)a2 + 12),  *((double *)a2 + 17),  *((double *)a2 + 18));
    if (LOBYTE(__dst[0]))
    {
      int v33 = 7;
      bzero(&v36, 0x580uLL);
      __int128 v35 = *(_OWORD *)((char *)__dst + 8);
      (*(void (**)(_BYTE *, int *, __int128 *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v33,  &v35,  1LL,  0xFFFFFFFFLL,  0LL);
    }
  }

  sub_100F1EB2C((uint64_t)(a1 + 4944), (uint64_t)a2 + 184);
  bzero(v37, 0x578uLL);
  uint64_t v25 = *((void *)a2 + 20);
  uint64_t v26 = *((void *)a2 + 21);
  *(void *)&__int128 v35 = *((void *)a2 + 2);
  *((void *)&v35 + 1) = v25;
  uint64_t v36 = v26;
  LODWORD(__dst[0]) = 5;
  (*(void (**)(_BYTE *, _OWORD *, __int128 *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  __dst,  &v35,  1LL,  0xFFFFFFFFLL,  0LL);
  int v33 = 11;
  memcpy(__dst, a2, sizeof(__dst));
  (*(void (**)(_BYTE *, int *, _OWORD *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v33,  __dst,  1LL,  0xFFFFFFFFLL,  0LL);
  int v33 = 9;
  bzero((char *)&__dst[11] + 8, 0x4D8uLL);
  __int128 v27 = a2[9];
  __dst[8] = a2[8];
  __dst[9] = v27;
  __dst[10] = a2[10];
  *(void *)&__dst[11] = *((void *)a2 + 22);
  __int128 v28 = a2[5];
  __dst[4] = a2[4];
  __dst[5] = v28;
  __int128 v29 = a2[7];
  __dst[6] = a2[6];
  __dst[7] = v29;
  __int128 v30 = a2[1];
  __dst[0] = *a2;
  __dst[1] = v30;
  __int128 v31 = a2[3];
  __dst[2] = a2[2];
  __dst[3] = v31;
  return (*(uint64_t (**)(_BYTE *, int *, _OWORD *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  &v33,  __dst,  1LL,  0xFFFFFFFFLL,  0LL);
}

void sub_100E18208(_Unwind_Exception *a1)
{
}

uint64_t sub_100E18228(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100E25EF0(*(void *)(a1 + 24), a2);
  if (!*(_BYTE *)(a1 + 41))
  {
    uint64_t result = sub_100D8A92C(*(void *)(a1 + 24) + 72LL);
    if ((_DWORD)result)
    {
      *(_BYTE *)(a1 + 41) = 1;
      return sub_100E12780(a1);
    }
  }

  return result;
}

uint64_t sub_100E1827C(uint64_t a1, _OWORD *a2)
{
  return sub_100E17E6C((_BYTE *)(a1 - 112), a2);
}

void sub_100E18284(uint64_t a1, int a2)
{
  if (sub_100DDA4D4())
  {
    if (a2)
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      unint64_t v4 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Enabled device motion for calorimetry",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        v12[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "Enabled device motion for calorimetry",  v12,  2);
        uint64_t v9 = (uint8_t *)v8;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryNotifier::startStopDeviceMotion(BOOL)", "%s\n", v8);
        if (v9 != buf) {
          free(v9);
        }
      }

      uint64_t v5 = sub_100DDA4D4();
      sub_100DDAEA4(v5, *(void *)(a1 + 5192), 0.01);
    }

    else
    {
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v6 = (os_log_s *)qword_1019344D8;
      if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Disabled device motion for calorimetry",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344D0 != -1) {
          dispatch_once(&qword_1019344D0, &stru_101884E60);
        }
        v12[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "Disabled device motion for calorimetry",  v12,  2);
        uint64_t v11 = (uint8_t *)v10;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLNatalimetryNotifier::startStopDeviceMotion(BOOL)", "%s\n", v10);
        if (v11 != buf) {
          free(v11);
        }
      }

      uint64_t v7 = sub_100DDA4D4();
      sub_100DDB140(v7, *(void *)(a1 + 5192));
    }
  }

uint64_t sub_100E1856C(uint64_t a1, uint64_t *a2)
{
  int8x16_t v4 = (int8x16_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a2 + 1)), *(float64x2_t *)(a2 + 3));
  int8x16_t v13 = vextq_s8(v4, v4, 4uLL);
  float32x4_t v8 = *(float32x4_t *)(a2 + 5);
  uint64_t v5 = a2[7];
  sub_100833700((float32x4_t *)&v13, v8);
  v9[0] = v13;
  v9[1] = v8;
  uint64_t v6 = *a2;
  uint64_t v10 = v5;
  uint64_t v11 = v6;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  return sub_1005D413C(a1 + 2640, (uint64_t)v9);
}

void sub_100E185F0(uint64_t a1, uint64_t *a2)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  unint64_t v3 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *a2;
    *(_DWORD *)__int128 buf = 134349056;
    uint64_t v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "MoveMinute, startTime, %{public}f", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    uint64_t v5 = *a2;
    int v8 = 134349056;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "MoveMinute, startTime, %{public}f",  &v8,  12);
    uint64_t v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalimetryNotifier::onMoveMinuteUpdate(const MoveMinuteUpdate &)",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

void sub_100E187A4(uint64_t a1, int a2)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  uint64_t v4 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "ActiveEnergy";
    if (a2 == 2) {
      uint64_t v5 = "MoveMinutes";
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "FitnessMode, setting fitness controller to type %{public}s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v17 = "ActiveEnergy";
    if (a2 == 2) {
      int v17 = "MoveMinutes";
    }
    int v22 = 136446210;
    uint64_t v23 = v17;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "FitnessMode, setting fitness controller to type %{public}s",  &v22,  12);
    uint64_t v19 = (char *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalimetryNotifier::setFitnessController(CLFitnessTrackingNotifier_Type::ActivityMoveMode)",  "%s\n",  v18);
  }

  uint64_t v6 = *(void *)(a1 + 2768);
  *(void *)(a1 + 2768) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 48LL))(v6);
  }
  int v7 = *(_DWORD *)(a1 + 4784);
  int v8 = *(std::__shared_weak_count **)(a1 + 2760);
  uint64_t v20 = *(void *)(a1 + 2752);
  uint64_t v21 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }

  sub_1005C8534(v7 == 2, a1 + 112, &v20, buf);
  uint64_t v11 = *(void *)buf;
  *(void *)__int128 buf = 0LL;
  uint64_t v12 = *(void *)(a1 + 2768);
  *(void *)(a1 + 2768) = v11;
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 48LL))(v12);
    uint64_t v13 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 48LL))(v13);
    }
  }

  uint64_t v14 = v21;
  if (v21)
  {
    int v15 = (unint64_t *)&v21->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

void sub_100E18A48( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

void sub_100E18A64(uint64_t a1, int a2)
{
}

void sub_100E18A6C(uint64_t a1, int a2, int a3)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  uint64_t v5 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = "ActiveEnergy";
    if (a2 == 2) {
      uint64_t v6 = "MoveMinutes";
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v19 = v6;
    __int16 v20 = 1026;
    int v21 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "HKDataCollector, starting HK collector for type %{public}s, handleHistorical, %{public}d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v8 = "ActiveEnergy";
    if (a2 == 2) {
      int v8 = "MoveMinutes";
    }
    int v14 = 136446466;
    int v15 = v8;
    __int16 v16 = 1026;
    int v17 = a3;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "HKDataCollector, starting HK collector for type %{public}s, handleHistorical, %{public}d",  &v14,  18);
    unint64_t v10 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalimetryNotifier::startHealthKitCollector(CLFitnessTrackingNotifier_Type::ActivityMoveMode, BOOL)",  "%s\n",  v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  if (!a2)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    int v7 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "HKDataCollector, attempting to start collector in unknown move mode",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      LOWORD(v14) = 0;
      LODWORD(v13) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  16LL,  "HKDataCollector, attempting to start collector in unknown move mode",  &v14,  v13);
      uint64_t v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNatalimetryNotifier::startHealthKitCollector(CLFitnessTrackingNotifier_Type::ActivityMoveMode, BOOL)",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }
  }

void sub_100E18D90()
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101884E60);
  }
  unsigned __int8 v0 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_DEFAULT,  "HKDataCollector, stopping HK collectors",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    v3[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "HKDataCollector, stopping HK collectors",  v3,  2);
    uint64_t v2 = (uint8_t *)v1;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLNatalimetryNotifier::stopHealthKitCollector()", "%s\n", v1);
    if (v2 != buf) {
      free(v2);
    }
  }

void sub_100E18F18(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  int v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLNatalimetryNotifier");
  sub_100E18FE0((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  void *v8 = off_101884D78;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100E18FB4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100E18FE0(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = off_101886458;
  *(void *)(a1 + 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  else {
    uint64_t v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

void sub_100E190B4(uint64_t a1, uint64_t a2)
{
  HIDWORD(v15) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)__int128 buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v15 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101884E40);
      }
      char v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v11 = (void *)(a1 + 8);
        *(_DWORD *)__int128 buf = 136446466;
        int v21 = v11;
        __int16 v22 = 1026;
        int v23 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101884E40);
        }
        uint64_t v12 = (void *)(a1 + 8);
        int v16 = 136446466;
        int v17 = v12;
        __int16 v18 = 1026;
        int v19 = a2;
        LODWORD(v15) = 18;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
          &v16,
          v15);
        id v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData >::removeClient(int) [Notification_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatali metryNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }
  }

uint64_t sub_100E19328(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_101991240);
}

uint64_t sub_100E1933C(uint64_t a1, int a2, int *a3, char *a4)
{
  int v42 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)float v43 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          uint64_t v24 = (uint64_t *)v18;
        }
        else {
          uint64_t v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }

      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          __int128 v29 = (uint64_t *)v25;
        }
        else {
          __int128 v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }

      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v41 = v26;
        uint64_t v34 = *(void *)(v26 + 56);
        char v35 = *a4;
        *(void *)__int128 buf = &v42;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v26 + 40), &v42, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v35;
        bzero(v47, 0x578uLL);
        *(void *)__int128 buf = 0x7FEFFFFFFFFFFFFFLL;
        *(void *)&uint8_t buf[8] = 0LL;
        *(void *)&uint8_t buf[16] = 0xBFF0000000000000LL;
        int v50 = 0;
        v47[0] = 0;
        uint64_t v48 = 0LL;
        uint64_t v49 = 0LL;
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, _BYTE *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          uint64_t v36 = sub_100E268AC(buf);
          sub_100E25288((_BYTE *)a1, (uint64_t)v43, (uint64_t)&v41, v36);
        }

        if (v34) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        uint64_t v41 = a1 + 64;
        char v30 = byte_101991241;
        HIDWORD(v40) = v17;
        *(void *)__int128 buf = (char *)&v40 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 80) = v30;
        HIDWORD(v40) = *a3;
        *(void *)__int128 buf = (char *)&v40 + 4;
        __int128 v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v31 + 8);
        char v32 = *a4;
        HIDWORD(v40) = *a3;
        *(void *)__int128 buf = (char *)&v40 + 4;
        int v33 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)__int128 buf = &v42;
        *((_BYTE *)sub_1004EF3D4(v33 + 5, &v42, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v32;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v21 == v19)
      {
        *(_DWORD *)__int128 buf = *a3;
        sub_10004A8FC((uint64_t **)(*(void *)v43 + 40LL), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101884E40);
  }
  id v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    uint64_t v15 = (void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL v16 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    uint64_t v37 = (void *)(a1 + 8);
    *(_DWORD *)float v43 = 136446466;
    *(void *)&v43[4] = v37;
    __int16 v44 = 1026;
    int v45 = a2;
    LODWORD(v40) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
      v43,
      v40);
    char v39 = (char *)v38;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData>::r egisterForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLNatalimetryNot ifier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v38);
    if (v39 != buf) {
      free(v39);
    }
    return 0LL;
  }

  return result;
}

BOOL sub_100E197C0(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        uint64_t v21 = (uint64_t *)v15;
      }
      else {
        uint64_t v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136446466;
      char v30 = v11;
      __int16 v31 = 1026;
      int v32 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101884E40);
      }
      int v22 = (void *)(a1 + 8);
      int v25 = 136446466;
      uint64_t v26 = v22;
      __int16 v27 = 1026;
      int v28 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
        &v25,
        18);
      uint64_t v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData>: :clientRegistered(int, const Notification_T &) [Notification_T = CLNatalimetryNotifier_Type::Notification, Notif icationData_T = CLNatalimetryNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100E19A40(char *a1, int a2, int *a3)
{
  HIDWORD(v34) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        id v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            id v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            int v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                int v25 = (uint64_t *)v20;
              }
              else {
                int v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                int v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v34 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101884E40);
              }
              uint64_t v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                __int16 v27 = a1 + 8;
                if (a1[31] < 0) {
                  __int16 v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v44 >= 0) {
                  int v28 = __p;
                }
                else {
                  int v28 = (void **)__p[0];
                }
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v36 = 2082;
                uint64_t v37 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v44 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101884E40);
                }
                __int128 v29 = a1 + 8;
                if (a1[31] < 0) {
                  __int128 v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v38 >= 0) {
                  __int16 v31 = buf;
                }
                else {
                  __int16 v31 = *(_BYTE **)buf;
                }
                int v39 = 136446466;
                uint64_t v40 = v29;
                __int16 v41 = 2082;
                int v42 = v31;
                LODWORD(v34) = 22;
                _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                  &v39,
                  v34);
                int v33 = v32;
                if (v38 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::Notifica tionData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLNatalimetryNotif ier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::NotificationData, Notificatio nInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v33);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_100E19DC8(uint64_t a1, int *a2, void *__dst)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v6 = *a2;
  uint64_t v7 = v3;
  do
  {
    int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 < v6;
    if (v8 >= v6) {
      BOOL v10 = (uint64_t *)v4;
    }
    else {
      BOOL v10 = (uint64_t *)(v4 + 8);
    }
    if (!v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }

  while (*v10);
  if (v7 == v3) {
    return 0LL;
  }
  if (v6 < *(_DWORD *)(v7 + 32)) {
    return 0LL;
  }
  int v11 = *(const void **)(v7 + 64);
  if (!v11) {
    return 0LL;
  }
  memcpy(__dst, v11, 0x590uLL);
  return 1LL;
}

uint64_t sub_100E19E38(uint64_t a1, int *a2, const void *a3)
{
  int v6 = operator new(0x5A8uLL);
  _DWORD v6[2] = 0LL;
  void *v6 = off_1018863C8;
  v6[1] = 0LL;
  memcpy(v6 + 3, a3, 0x590uLL);
  *(void *)&__int128 v13 = v6 + 3;
  *((void *)&v13 + 1) = v6;
  int v12 = *a2;
  uint64_t v14 = &v12;
  uint64_t v7 = sub_10023347C((uint64_t **)(a1 + 56), &v12, (uint64_t)&unk_1012CF090, &v14);
  sub_10005F550((uint64_t)(v7 + 8), &v13);
  int v8 = (std::__shared_weak_count *)*((void *)&v13 + 1);
  if (*((void *)&v13 + 1))
  {
    BOOL v9 = (unint64_t *)(*((void *)&v13 + 1) + 8LL);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  return 1LL;
}

void sub_100E19F20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100E19F34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[0] = 0x7FEFFFFFFFFFFFFFLL;
  v9[1] = 0LL;
  _OWORD v9[2] = 0xBFF0000000000000LL;
  int v13 = 0;
  v10[0] = 0;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  v9,  a3,  a4,  0LL);
}

void sub_100E19FF0(uint64_t a1, unsigned int *a2, const void *a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    unint64_t v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    uint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v12 = (void *)(a1 + 8);
      int v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)__int128 buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = "activity";
      __int16 v67 = 2082;
      uint64_t v68 = v12;
      __int16 v69 = 2050;
      __int128 v70 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    uint64_t v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      uint64_t v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)uint64_t v71 = &v71[8];
      memset(&v71[8], 0, 24);
      int v72 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v71);
      int v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v70;
      if (v70)
      {
        p_shared_owners = (unint64_t *)&v70->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&buf[8], *(void **)&buf[16]);
      BOOL v24 = v72;
      if (v72)
      {
        int v25 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v71, *(void **)&v71[8]);
    }

    if (a4)
    {
      __int16 v27 = operator new(0x5A8uLL);
      v27[2] = 0LL;
      *__int16 v27 = off_1018863C8;
      v27[1] = 0LL;
      memcpy(v27 + 3, a3, 0x590uLL);
      *(void *)__int128 buf = v27 + 3;
      *(void *)&uint8_t buf[8] = v27;
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      int v28 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        __int128 v29 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    __int16 v31 = sub_100E24E2C(a3);
    if (a5 == -1)
    {
      sub_100E24EB4((void *)a1, (int *)a2, v31);
    }

    else
    {
      uint64_t v32 = a1 + 88;
      uint64_t v33 = *(void *)(a1 + 88);
      if (!v33) {
        goto LABEL_48;
      }
      uint64_t v34 = a1 + 88;
      do
      {
        int v35 = *(_DWORD *)(v33 + 32);
        BOOL v36 = v35 < a5;
        if (v35 >= a5) {
          uint64_t v37 = (uint64_t *)v33;
        }
        else {
          uint64_t v37 = (uint64_t *)(v33 + 8);
        }
        if (!v36) {
          uint64_t v34 = v33;
        }
        uint64_t v33 = *v37;
      }

      while (*v37);
      if (v34 == v32 || *(_DWORD *)(v34 + 32) > a5) {
LABEL_48:
      }
        uint64_t v34 = a1 + 88;
      uint64_t v64 = v34;
      unint64_t v38 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v39 = *a2;
      uint64_t v40 = (__n128 *)(a1 + 64);
      do
      {
        int v41 = *(_DWORD *)(v38 + 32);
        BOOL v42 = v41 < v39;
        if (v41 >= v39) {
          float v43 = (unint64_t *)v38;
        }
        else {
          float v43 = (unint64_t *)(v38 + 8);
        }
        if (!v42) {
          uint64_t v40 = (__n128 *)v38;
        }
        unint64_t v38 = *v43;
      }

      while (*v43);
      if (v40 == v15 || v39 < (signed __int32)v40[2].n128_u32[0])
      {
LABEL_59:
        __int128 v63 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101884E40);
        }
        char v44 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          int v45 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v71, a1, a2);
          if (v71[23] >= 0) {
            float v46 = v71;
          }
          else {
            float v46 = *(_BYTE **)v71;
          }
          *(_DWORD *)__int128 buf = 136315650;
          *(void *)&uint8_t buf[4] = v45;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a5;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&buf[20] = v46;
          _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v71[23] & 0x80000000) != 0) {
            operator delete(*(void **)v71);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_101884E40);
          }
          uint64_t v47 = (void *)(a1 + 8);
          uint64_t v48 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v62 >= 0) {
            uint64_t v49 = __p;
          }
          else {
            uint64_t v49 = (void **)__p[0];
          }
          *(_DWORD *)uint64_t v71 = 136315650;
          *(void *)&v71[4] = v47;
          *(_WORD *)&v71[12] = 1024;
          *(_DWORD *)&v71[14] = a5;
          *(_WORD *)&v71[18] = 2080;
          *(void *)&v71[20] = v49;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v48,  2LL,  "%s; client %d has deregistered, not notifying %s",
            v71,
            28,
            v60);
          uint64_t v51 = v50;
          if (v62 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationDa ta>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Notificatio n_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::Notificatio nData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v51);
          if (v51 != buf) {
            free(v51);
          }
        }

        goto LABEL_83;
      }

      __int128 v63 = v40;
      if (v34 == v32) {
        goto LABEL_60;
      }
      uint64_t v54 = v40[3].n128_i64[0];
      int v52 = v40 + 3;
      int v53 = (__n128 *)v54;
      if (!v54) {
        goto LABEL_60;
      }
      int v55 = *(_DWORD *)(v34 + 32);
      CFAbsoluteTime v56 = v52;
      do
      {
        int v57 = v53[1].n128_i32[3];
        BOOL v58 = v57 < v55;
        if (v57 >= v55) {
          __int128 v59 = v53;
        }
        else {
          __int128 v59 = (__n128 *)&v53->n128_i8[8];
        }
        if (!v58) {
          CFAbsoluteTime v56 = v53;
        }
        int v53 = (__n128 *)v59->n128_u64[0];
      }

      while (v59->n128_u64[0]);
      sub_100E25288((_BYTE *)a1, (uint64_t)&v64, (uint64_t)&v63, v31);
    }

void sub_100E1A634( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_100E1A680(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    uint64_t v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136315138;
      uint64_t v37 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101884E40);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v32 = 136315138;
      uint64_t v33 = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
        (const char *)&v32);
      int v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData>: :listClients() [Notification_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatalimetryNot ifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101884E40);
    }
    uint64_t v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      int v8 = (void *)(a1 + 8);
      uint64_t v9 = *(void *)(a1 + 96);
      *(_DWORD *)__int128 buf = 136315394;
      uint64_t v37 = v8;
      __int16 v38 = 2048;
      v39[0] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101884E40);
      }
      __int16 v27 = (void *)(a1 + 8);
      uint64_t v28 = *(void *)(a1 + 96);
      int v32 = 136315394;
      uint64_t v33 = v27;
      __int16 v34 = 2048;
      v35[0] = v28;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
        (const char *)&v32,
        22);
      unint64_t v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData>: :listClients() [Notification_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatalimetryNot ifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }

    unint64_t v10 = *(void **)(a1 + 80);
    if (v10 != (void *)(a1 + 88))
    {
      uint64_t v11 = (void *)(a1 + 8);
      do
      {
        uint64_t v12 = (void *)v10[5];
        if (v12 != v10 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_101884E40);
            }
            int v13 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v14 = (void *)(a1 + 8);
              int v15 = *((_DWORD *)v10 + 8);
              int v16 = *((_DWORD *)v12 + 7);
              *(_DWORD *)__int128 buf = 136315650;
              uint64_t v37 = v14;
              __int16 v38 = 1024;
              LODWORD(v39[0]) = v15;
              WORD2(v39[0]) = 1024;
              *(_DWORD *)((char *)v39 + 6) = v16;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101884E40);
              }
              uint64_t v20 = (void *)(a1 + 8);
              int v21 = *((_DWORD *)v10 + 8);
              int v22 = *((_DWORD *)v12 + 7);
              int v32 = 136315650;
              uint64_t v33 = v20;
              __int16 v34 = 1024;
              LODWORD(v35[0]) = v21;
              WORD2(v35[0]) = 1024;
              *(_DWORD *)((char *)v35 + 6) = v22;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                (const char *)&v32,
                24,
                v31);
              BOOL v24 = (uint8_t *)v23;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::Notificati onData>::listClients() [Notification_T = CLNatalimetryNotifier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
              if (v24 != buf) {
                free(v24);
              }
            }

            int v17 = (void *)v12[1];
            if (v17)
            {
              do
              {
                signed __int32 v18 = v17;
                int v17 = (void *)*v17;
              }

              while (v17);
            }

            else
            {
              do
              {
                signed __int32 v18 = (void *)v12[2];
                BOOL v19 = *v18 == (void)v12;
                uint64_t v12 = v18;
              }

              while (!v19);
            }

            uint64_t v12 = v18;
          }

          while (v18 != v10 + 6);
        }

        int v25 = (void *)v10[1];
        if (v25)
        {
          do
          {
            unint64_t v26 = v25;
            int v25 = (void *)*v25;
          }

          while (v25);
        }

        else
        {
          do
          {
            unint64_t v26 = (void *)v10[2];
            BOOL v19 = *v26 == (void)v10;
            unint64_t v10 = v26;
          }

          while (!v19);
        }

        unint64_t v10 = v26;
      }

      while (v26 != (void *)(a1 + 88));
    }
  }

void sub_100E1AC2C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E2684C(a1);
  operator delete(v1);
}

id sub_100E1AC40(uint64_t a1, int a2, void *a3)
{
  id result = sub_100E253B4(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_100E1AC8C(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100E1ACB8(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_100E1ACE4(uint64_t a1, uint64_t a2)
{
  int v22 = &off_101884E90;
  uint64_t v23 = sub_10001A504(a1, a2);
  BOOL v24 = &v22;
  sub_100E1B35C(v23 + 32, (uint64_t)&v22, "Dance", 0, 10.0, 10.0, 30.0);
  uint64_t v3 = v24;
  if (v24 == &v22)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = &v22;
  }

  else
  {
    if (!v24) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*v3)[v4]();
LABEL_6:
  v20[0] = &off_101885068;
  v20[1] = a1;
  int v21 = v20;
  sub_100E1BD14(a1 + 192, (uint64_t)v20, "FST", 0, 10.0, 10.0, 30.0);
  uint64_t v5 = v21;
  if (v21 == v20)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v20;
  }

  else
  {
    if (!v21) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  v18[0] = &off_101885240;
  v18[1] = a1;
  BOOL v19 = v18;
  sub_100E1C5E0(a1 + 352, (uint64_t)v18, "Rowing", 0, 10.0, 10.0, 30.0);
  uint64_t v7 = v19;
  if (v19 == v18)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = v18;
  }

  else
  {
    if (!v19) {
      goto LABEL_16;
    }
    uint64_t v8 = 5LL;
  }

  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_16:
  v16[0] = &off_101885418;
  v16[1] = a1;
  int v17 = v16;
  sub_100E1CEC0(a1 + 512, (uint64_t)v16, "Kickboxing", 0, 10.0, 10.0, 30.0);
  uint64_t v9 = v17;
  if (v17 == v16)
  {
    uint64_t v10 = 4LL;
    uint64_t v9 = v16;
  }

  else
  {
    if (!v17) {
      goto LABEL_21;
    }
    uint64_t v10 = 5LL;
  }

  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_21:
  v14[0] = &off_1018855F0;
  v14[1] = a1;
  int v15 = v14;
  sub_1005D3EAC((_OWORD *)(a1 + 672), (uint64_t)v14);
  uint64_t v11 = v15;
  if (v15 == v14)
  {
    uint64_t v12 = 4LL;
    uint64_t v11 = v14;
    goto LABEL_25;
  }

  if (v15)
  {
    uint64_t v12 = 5LL;
LABEL_25:
    (*(void (**)(void))(*v11 + 8 * v12))();
  }

  return a1;
}

void sub_100E1AF4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  BOOL v19 = a13;
  if (a13 == &a10)
  {
    uint64_t v20 = 4LL;
    BOOL v19 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*(void *)v19 + 8 * v20))();
LABEL_6:
  sub_100E1B0AC(v17);
  sub_100E1B12C(v16);
  sub_100E1B1AC(v15);
  sub_100E1B22C(v14);
  int v21 = (void *)v13[3];
  if (v21 == v13)
  {
    uint64_t v22 = 4LL;
  }

  else
  {
    if (!v21) {
      goto LABEL_11;
    }
    uint64_t v22 = 5LL;
    int v13 = (void *)v13[3];
  }

  (*(void (**)(void *))(*v13 + 8 * v22))(v13);
LABEL_11:
  _Unwind_Resume(a1);
}

void sub_100E1B078()
{
  uint64_t v2 = *(void **)(v1 - 64);
  if (v2 == v0)
  {
    uint64_t v3 = 4LL;
    uint64_t v2 = (void *)(v1 - 88);
  }

  else
  {
    if (!v2) {
      goto LABEL_6;
    }
    uint64_t v3 = 5LL;
  }

  (*(void (**)(void))(*v2 + 8 * v3))();
LABEL_6:
  JUMPOUT(0x100E1B040LL);
}

uint64_t sub_100E1B0AC(uint64_t a1)
{
  *(void *)a1 = off_101885498;
  uint64_t v2 = (void *)(a1 + 128);
  uint64_t v3 = *(void **)(a1 + 152);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  *(void *)a1 = off_1018855B8;
  free(*(void **)(a1 + 8));
  sub_100210A00((void *)(a1 + 24));
  return a1;
}

uint64_t sub_100E1B12C(uint64_t a1)
{
  *(void *)a1 = off_1018852C0;
  uint64_t v2 = (void *)(a1 + 128);
  uint64_t v3 = *(void **)(a1 + 152);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  *(void *)a1 = off_1018853E0;
  free(*(void **)(a1 + 8));
  sub_1000EAA04((void *)(a1 + 24));
  return a1;
}

uint64_t sub_100E1B1AC(uint64_t a1)
{
  *(void *)a1 = off_1018850E8;
  uint64_t v2 = (void *)(a1 + 128);
  uint64_t v3 = *(void **)(a1 + 152);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  *(void *)a1 = off_101885208;
  free(*(void **)(a1 + 8));
  sub_100231C10((void *)(a1 + 24));
  return a1;
}

uint64_t sub_100E1B22C(uint64_t a1)
{
  *(void *)a1 = off_101884F10;
  uint64_t v2 = (void *)(a1 + 128);
  uint64_t v3 = *(void **)(a1 + 152);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  *(void *)a1 = off_101885030;
  free(*(void **)(a1 + 8));
  sub_100210A00((void *)(a1 + 24));
  return a1;
}

void *sub_100E1B2AC(uint64_t a1)
{
  id result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *id result = &off_101884E90;
  result[1] = v3;
  return result;
}

uint64_t sub_100E1B2E4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_101884E90;
  a2[1] = v2;
  return result;
}

uint64_t sub_100E1B304(uint64_t a1, unsigned __int8 *a2)
{
  return sub_100BD34CC(*(void *)(a1 + 8), *a2, 0);
}

uint64_t sub_100E1B314(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E1B350()
{
  return &off_101884EF0;
}

uint64_t sub_100E1B35C(uint64_t a1, uint64_t a2, const char *a3, int a4, double a5, double a6, double a7)
{
  uint64_t v9 = (void *)sub_100E1B3B8(a1, a3, a4, a5, a6, a7);
  void *v9 = off_101884F10;
  sub_10001A504((uint64_t)(v9 + 16), a2);
  return a1;
}

void sub_100E1B3A4(_Unwind_Exception *a1)
{
}

uint64_t sub_100E1B3B8(uint64_t a1, const char *a2, int a3, double a4, double a5, double a6)
{
  *(void *)a1 = off_101885030;
  if (a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = "NatalieInputSrc";
  }
  uint64_t v12 = strdup(v11);
  *(double *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_101884FC0;
  *(void *)(a1 + 8) = v12;
  *(void *)(a1 + 72) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0LL;
  *(double *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  *(double *)(a1 + 112) = a6;
  *(_BYTE *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 121) = a3;
  if (a3)
  {
    *(void *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
    *(void *)(a1 + 88) = 0x7FEFFFFFFFFFFFFFLL;
  }

  return a1;
}

uint64_t sub_100E1B478(uint64_t a1)
{
  *(void *)a1 = off_101885030;
  free(*(void **)(a1 + 8));
  sub_100210A00((void *)(a1 + 24));
  return a1;
}

void sub_100E1B4B8(char *a1)
{
  *(void *)a1 = off_101884F10;
  uint64_t v2 = a1 + 128;
  uint64_t v3 = (void *)*((void *)a1 + 19);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  *(void *)a1 = off_101885030;
  free(*((void **)a1 + 1));
  sub_100210A00((void *)a1 + 3);
  operator delete(a1);
}

BOOL sub_100E1B538(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  unint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = (void *)(v5 + 8 * (v4 / 0xAA));
  if (*(void *)(a1 + 40) == v5) {
    unint64_t v7 = 0LL;
  }
  else {
    unint64_t v7 = *v6 + 24 * (v4 % 0xAA);
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = v6;
  a3[3] = v7;
  __int128 v8 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v8;
  unint64_t v9 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = (uint64_t *)(v10 + 8 * (v9 / 0xAA));
  if (*(void *)(a1 + 40) == v10) {
    unint64_t v12 = 0LL;
  }
  else {
    unint64_t v12 = *v11 + 24 * (v9 % 0xAA);
  }
  uint64_t v13 = a3[3];
  if (v12 != v13)
  {
    uint64_t v14 = *v11;
    double v15 = 1.79769313e308;
    unint64_t v16 = v12;
    uint64_t v17 = v11;
    while (1)
    {
      uint64_t v18 = v16;
      if (v16 == v14) {
        uint64_t v18 = *(v17 - 1) + 4080;
      }
      double v19 = vabdd_f64(*(double *)(v18 - 24), a4);
      if (v19 < v15 && v19 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v11;
        *(void *)(a2 + 8) = v12;
        *(void *)(a2 + 16) = v17;
        *(void *)(a2 + 24) = v16;
        uint64_t v14 = *v17;
        uint64_t v20 = v16;
        if (v16 == *v17) {
          uint64_t v20 = *(v17 - 1) + 4080;
        }
        double v15 = v19;
      }

      if (v16 == v14)
      {
        uint64_t v21 = *--v17;
        uint64_t v14 = v21;
        unint64_t v16 = v21 + 4080;
      }

      v16 -= 24LL;
      uint64_t v13 = a3[3];
      if (v16 == v13) {
        return v13 != *(void *)(a2 + 24);
      }
    }

    uint64_t v13 = a3[3];
  }

  return v13 != *(void *)(a2 + 24);
}

uint64_t sub_100E1B67C(uint64_t a1, void *a2)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, __int128 *, __int128 *))(*(void *)a1 + 16LL))(a1, &v8, &v6);
  if ((_DWORD)result)
  {
    uint64_t v4 = *((void *)&v9 + 1);
    if (*((void *)&v9 + 1) == *((void *)&v7 + 1))
    {
      return 0LL;
    }

    else
    {
      if (*(void *)v9 == *((void *)&v9 + 1)) {
        uint64_t v4 = *(void *)(v9 - 8) + 4080LL;
      }
      __int128 v5 = *(_OWORD *)(v4 - 24);
      a2[2] = *(void *)(v4 - 8);
      *(_OWORD *)a2 = v5;
      return 1LL;
    }
  }

  return result;
}

double sub_100E1B710(uint64_t a1, __n128 *a2)
{
  *(void *)&double result = sub_100BD3588((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

unint64_t sub_100E1B718(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    __int128 v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)__int128 buf = 134218752;
      double v34 = v7 - v4;
      __int16 v35 = 2048;
      double v36 = v4;
      __int16 v37 = 2048;
      double v38 = v7;
      __int16 v39 = 1024;
      int v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v20 = *(double *)(a1 + 104);
      int v21 = *(unsigned __int8 *)(a1 + 121);
      int v25 = 134218752;
      double v26 = v20 - v4;
      __int16 v27 = 2048;
      double v28 = v4;
      __int16 v29 = 2048;
      double v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      LODWORD(v24) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  COERCE_DOUBLE(&v25),  v24);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInput<CLCalorimetryDanceDMFeatures>::update(CFAbsoluteTime) [Data_T = CLCalorimetryDanceDMFeatures]",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

  if (*(_BYTE *)(a1 + 80)
    && !*(_BYTE *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(_BYTE *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1))
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0LL;
  }

  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  unint64_t v12 = (void *)(v10 + 8 * (v9 / 0xAA));
  if (v11 == v10) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = (char *)(*v12 + 24 * (v9 % 0xAA));
  }
  uint64_t v14 = (void *)(v10 + 8 * (v9 / 0xAA));
LABEL_15:
  double v15 = (double *)v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0LL
        : *(void *)(v10 + 8 * ((*(void *)(a1 + 64) + v9) / 0xAA)) + 24 * ((*(void *)(a1 + 64) + v9) % 0xAA);
    v15 += 3;
    v13 += 24;
    if ((char *)(*v14 + 4080LL) == v13)
    {
      uint64_t v17 = (char *)v14[1];
      ++v14;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }

  if (v11 == v10) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = (char *)(*v12 + 24 * (v9 % 0xAA));
  }
  return sub_100CE617C((void *)(a1 + 24), v12, v18, v14, v13);
}

BOOL sub_100E1BA78(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
  else
  }
    double v5 = -1.79769313e308;
  if (v5 >= a2)
  {
    __int128 v6 = (_BYTE *)(a1 + 80);
    goto LABEL_11;
  }

  __int128 v6 = (_BYTE *)(a1 + 80);
  if (*(_BYTE *)(a1 + 80))
  {
    double v7 = *(double *)(a1 + 16);
    if (*(double *)(a1 + 72) - v7 < a2 && v7 + *(double *)(a1 + 88) > a2)
    {
      double v8 = *(double *)(a1 + 104);
    }

uint64_t sub_100E1BBAC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 152);
  uint64_t result = 1LL;
  if (v1)
  {
    char v3 = 1;
    return (*(uint64_t (**)(uint64_t, char *))(*(void *)v1 + 48LL))(v1, &v3);
  }

  return result;
}

uint64_t sub_100E1BBE8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 152);
  if (!v1) {
    return 1LL;
  }
  char v3 = 0;
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v1 + 48LL))(v1, &v3);
}

void sub_100E1BC24(void **a1)
{
  *a1 = off_101885030;
  free(a1[1]);
  sub_100210A00(a1 + 3);
  operator delete(a1);
}

void *sub_100E1BC64(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_101885068;
  result[1] = v3;
  return result;
}

uint64_t sub_100E1BC9C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_101885068;
  a2[1] = v2;
  return result;
}

uint64_t sub_100E1BCBC(uint64_t a1, unsigned __int8 *a2)
{
  return sub_100BD34CC(*(void *)(a1 + 8), *a2, 2);
}

uint64_t sub_100E1BCCC(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E1BD08()
{
  return &off_1018850C8;
}

uint64_t sub_100E1BD14(uint64_t a1, uint64_t a2, const char *a3, int a4, double a5, double a6, double a7)
{
  unint64_t v9 = (void *)sub_100E1BD70(a1, a3, a4, a5, a6, a7);
  void *v9 = off_1018850E8;
  sub_10001A504((uint64_t)(v9 + 16), a2);
  return a1;
}

void sub_100E1BD5C(_Unwind_Exception *a1)
{
}

uint64_t sub_100E1BD70(uint64_t a1, const char *a2, int a3, double a4, double a5, double a6)
{
  *(void *)a1 = off_101885208;
  if (a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = "NatalieInputSrc";
  }
  unint64_t v12 = strdup(v11);
  *(double *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_101885198;
  *(void *)(a1 + 8) = v12;
  *(void *)(a1 + 72) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0LL;
  *(double *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  *(double *)(a1 + 112) = a6;
  *(_BYTE *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 121) = a3;
  if (a3)
  {
    *(void *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
    *(void *)(a1 + 88) = 0x7FEFFFFFFFFFFFFFLL;
  }

  return a1;
}

uint64_t sub_100E1BE30(uint64_t a1)
{
  *(void *)a1 = off_101885208;
  free(*(void **)(a1 + 8));
  sub_100231C10((void *)(a1 + 24));
  return a1;
}

void sub_100E1BE70(char *a1)
{
  *(void *)a1 = off_1018850E8;
  uint64_t v2 = a1 + 128;
  uint64_t v3 = (void *)*((void *)a1 + 19);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  *(void *)a1 = off_101885208;
  free(*((void **)a1 + 1));
  sub_100231C10((void *)a1 + 3);
  operator delete(a1);
}

BOOL sub_100E1BEF0(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  unint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  __int128 v6 = (void *)(v5 + 8 * (v4 >> 8));
  if (*(void *)(a1 + 40) == v5) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = *v6 + 16LL * v4;
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = v6;
  a3[3] = v7;
  __int128 v8 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v8;
  unint64_t v9 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = (uint64_t *)(v10 + 8 * (v9 >> 8));
  if (*(void *)(a1 + 40) == v10) {
    uint64_t v12 = 0LL;
  }
  else {
    uint64_t v12 = *v11 + 16LL * v9;
  }
  uint64_t v13 = a3[3];
  if (v12 != v13)
  {
    uint64_t v14 = *v11;
    double v15 = 1.79769313e308;
    uint64_t v16 = v12;
    uint64_t v17 = v11;
    while (1)
    {
      uint64_t v18 = v16;
      if (v16 == v14) {
        uint64_t v18 = *(v17 - 1) + 4096;
      }
      double v19 = vabdd_f64(*(double *)(v18 - 16), a4);
      if (v19 < v15 && v19 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v11;
        *(void *)(a2 + 8) = v12;
        *(void *)(a2 + 16) = v17;
        *(void *)(a2 + 24) = v16;
        uint64_t v14 = *v17;
        uint64_t v20 = v16;
        if (v16 == *v17) {
          uint64_t v20 = *(v17 - 1) + 4096;
        }
        double v15 = v19;
      }

      if (v16 == v14)
      {
        uint64_t v21 = *--v17;
        uint64_t v14 = v21;
        uint64_t v16 = v21 + 4096;
      }

      v16 -= 16LL;
      uint64_t v13 = a3[3];
      if (v16 == v13) {
        return v13 != *(void *)(a2 + 24);
      }
    }

    uint64_t v13 = a3[3];
  }

  return v13 != *(void *)(a2 + 24);
}

uint64_t sub_100E1C00C(uint64_t a1, void *a2)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  __int128 v5 = 0u;
  __int128 v6 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, __int128 *, __int128 *))(*(void *)a1 + 16LL))(a1, &v7, &v5);
  if ((_DWORD)result)
  {
    uint64_t v4 = *((void *)&v8 + 1);
    if (*((void *)&v8 + 1) == *((void *)&v6 + 1))
    {
      return 0LL;
    }

    else
    {
      if (*(void *)v8 == *((void *)&v8 + 1)) {
        uint64_t v4 = *(void *)(v8 - 8) + 4096LL;
      }
      *(_OWORD *)a2 = *(_OWORD *)(v4 - 16);
      return 1LL;
    }
  }

  return result;
}

double sub_100E1C094(uint64_t a1, __n128 *a2)
{
  *(void *)&double result = sub_100BD3CE8((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

void *sub_100E1C09C(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    __int128 v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)__int128 buf = 134218752;
      double v34 = v7 - v4;
      __int16 v35 = 2048;
      double v36 = v4;
      __int16 v37 = 2048;
      double v38 = v7;
      __int16 v39 = 1024;
      int v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v20 = *(double *)(a1 + 104);
      int v21 = *(unsigned __int8 *)(a1 + 121);
      int v25 = 134218752;
      double v26 = v20 - v4;
      __int16 v27 = 2048;
      double v28 = v4;
      __int16 v29 = 2048;
      double v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      LODWORD(v24) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  COERCE_DOUBLE(&v25),  v24);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInput<CLCalorimetryFunctionalStrengthDMFeatures>::update(CFAbsoluteTime) [Data_T = CLCalor imetryFunctionalStrengthDMFeatures]",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

  if (*(_BYTE *)(a1 + 80)
    && !*(_BYTE *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(_BYTE *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1))
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0LL;
  }

  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 8));
  if (v11 == v10) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = *(void *)v12 + 16LL * v9;
  }
  uint64_t v14 = v10 + 8 * (v9 >> 8);
LABEL_15:
  double v15 = (double *)v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0LL
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 5) & 0x7FFFFFFFFFFFFF8LL))
        + 16LL * (*(_BYTE *)(a1 + 64) + v9);
    v15 += 2;
    v13 += 16LL;
    if (*(void *)v14 + 4096LL == v13)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      v14 += 8LL;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }

  if (v11 == v10) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = *(void *)v12 + 16LL * v9;
  }
  return sub_10025A918((void *)(a1 + 24), v12, v18, (char *)v14, v13);
}

BOOL sub_100E1C3CC(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    double v5 = *(double *)(*(void *)(*(void *)(a1 + 32)
  }
  else {
    double v5 = -1.79769313e308;
  }
  if (v5 >= a2)
  {
    __int128 v6 = (_BYTE *)(a1 + 80);
    goto LABEL_11;
  }

  __int128 v6 = (_BYTE *)(a1 + 80);
  if (*(_BYTE *)(a1 + 80))
  {
    double v7 = *(double *)(a1 + 16);
    if (*(double *)(a1 + 72) - v7 < a2 && v7 + *(double *)(a1 + 88) > a2)
    {
      double v8 = *(double *)(a1 + 104);
    }

void sub_100E1C4F0(void **a1)
{
  *a1 = off_101885208;
  free(a1[1]);
  sub_100231C10(a1 + 3);
  operator delete(a1);
}

void *sub_100E1C530(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &off_101885240;
  result[1] = v3;
  return result;
}

uint64_t sub_100E1C568(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_101885240;
  a2[1] = v2;
  return result;
}

uint64_t sub_100E1C588(uint64_t a1, unsigned __int8 *a2)
{
  return sub_100BD34CC(*(void *)(a1 + 8), *a2, 1);
}

uint64_t sub_100E1C598(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E1C5D4()
{
  return &off_1018852A0;
}

uint64_t sub_100E1C5E0(uint64_t a1, uint64_t a2, const char *a3, int a4, double a5, double a6, double a7)
{
  unint64_t v9 = (void *)sub_100E1C63C(a1, a3, a4, a5, a6, a7);
  void *v9 = off_1018852C0;
  sub_10001A504((uint64_t)(v9 + 16), a2);
  return a1;
}

void sub_100E1C628(_Unwind_Exception *a1)
{
}

uint64_t sub_100E1C63C(uint64_t a1, const char *a2, int a3, double a4, double a5, double a6)
{
  *(void *)a1 = off_1018853E0;
  if (a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = "NatalieInputSrc";
  }
  uint64_t v12 = strdup(v11);
  *(double *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_101885370;
  *(void *)(a1 + 8) = v12;
  *(void *)(a1 + 72) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0LL;
  *(double *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  *(double *)(a1 + 112) = a6;
  *(_BYTE *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 121) = a3;
  if (a3)
  {
    *(void *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
    *(void *)(a1 + 88) = 0x7FEFFFFFFFFFFFFFLL;
  }

  return a1;
}

uint64_t sub_100E1C6FC(uint64_t a1)
{
  *(void *)a1 = off_1018853E0;
  free(*(void **)(a1 + 8));
  sub_1000EAA04((void *)(a1 + 24));
  return a1;
}

void sub_100E1C73C(char *a1)
{
  *(void *)a1 = off_1018852C0;
  uint64_t v2 = a1 + 128;
  uint64_t v3 = (void *)*((void *)a1 + 19);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  *(void *)a1 = off_1018853E0;
  free(*((void **)a1 + 1));
  sub_1000EAA04((void *)a1 + 3);
  operator delete(a1);
}

BOOL sub_100E1C7BC(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  double v5 = (void *)(v4 + 8LL * (*(void *)(a1 + 56) >> 7));
  if (*(void *)(a1 + 40) == v4) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = *v5 + 32 * (*(void *)(a1 + 56) & 0x7FLL);
  }
  *a3 = v5;
  a3[1] = v6;
  a3[2] = v5;
  a3[3] = v6;
  __int128 v7 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v7;
  unint64_t v8 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = (uint64_t *)(v9 + 8 * (v8 >> 7));
  if (*(void *)(a1 + 40) == v9) {
    uint64_t v11 = 0LL;
  }
  else {
    uint64_t v11 = *v10 + 32 * (v8 & 0x7F);
  }
  uint64_t v12 = a3[3];
  if (v11 != v12)
  {
    uint64_t v13 = *v10;
    double v14 = 1.79769313e308;
    uint64_t v15 = v11;
    uint64_t v16 = v10;
    while (1)
    {
      uint64_t v17 = v15;
      if (v15 == v13) {
        uint64_t v17 = *(v16 - 1) + 4096;
      }
      double v18 = vabdd_f64(*(double *)(v17 - 32), a4);
      if (v18 < v14 && v18 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v10;
        *(void *)(a2 + 8) = v11;
        *(void *)(a2 + 16) = v16;
        *(void *)(a2 + 24) = v15;
        uint64_t v13 = *v16;
        uint64_t v19 = v15;
        if (v15 == *v16) {
          uint64_t v19 = *(v16 - 1) + 4096;
        }
        double v14 = v18;
      }

      if (v15 == v13)
      {
        uint64_t v20 = *--v16;
        uint64_t v13 = v20;
        uint64_t v15 = v20 + 4096;
      }

      v15 -= 32LL;
      uint64_t v12 = a3[3];
      if (v15 == v12) {
        return v12 != *(void *)(a2 + 24);
      }
    }

    uint64_t v12 = a3[3];
  }

  return v12 != *(void *)(a2 + 24);
}

uint64_t sub_100E1C8E0(uint64_t a1, _OWORD *a2)
{
  *a2 = 0u;
  a2[1] = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v6 = 0u;
  __int128 v7 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, __int128 *, __int128 *))(*(void *)a1 + 16LL))(a1, &v8, &v6);
  if ((_DWORD)result)
  {
    uint64_t v4 = *((void *)&v9 + 1);
    if (*((void *)&v9 + 1) == *((void *)&v7 + 1))
    {
      return 0LL;
    }

    else
    {
      if (*(void *)v9 == *((void *)&v9 + 1)) {
        uint64_t v4 = *(void *)(v9 - 8) + 4096LL;
      }
      __int128 v5 = *(_OWORD *)(v4 - 16);
      *a2 = *(_OWORD *)(v4 - 32);
      a2[1] = v5;
      return 1LL;
    }
  }

  return result;
}

double sub_100E1C968(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = sub_100BD3948((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

void *sub_100E1C970(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    __int128 v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)__int128 buf = 134218752;
      double v34 = v7 - v4;
      __int16 v35 = 2048;
      double v36 = v4;
      __int16 v37 = 2048;
      double v38 = v7;
      __int16 v39 = 1024;
      int v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v20 = *(double *)(a1 + 104);
      int v21 = *(unsigned __int8 *)(a1 + 121);
      int v25 = 134218752;
      double v26 = v20 - v4;
      __int16 v27 = 2048;
      double v28 = v4;
      __int16 v29 = 2048;
      double v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      LODWORD(v24) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  COERCE_DOUBLE(&v25),  v24);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInput<CLCalorimetryRowingDMFeatures>::update(CFAbsoluteTime) [Data_T = CLCalorimetryRowingDMFeatures]",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

  if (*(_BYTE *)(a1 + 80)
    && !*(_BYTE *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(_BYTE *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1))
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0LL;
  }

  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 7));
  if (v11 == v10) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = *(void *)v12 + 32 * (*(void *)(a1 + 56) & 0x7FLL);
  }
  uint64_t v14 = v10 + 8 * (v9 >> 7);
LABEL_15:
  uint64_t v15 = (double *)v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0LL
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 4) & 0xFFFFFFFFFFFFFF8LL))
        + 32 * ((*(void *)(a1 + 64) + v9) & 0x7F);
    v15 += 4;
    v13 += 32LL;
    if (*(void *)v14 + 4096LL == v13)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      v14 += 8LL;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }

  if (v11 == v10) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = *(void *)v12 + 32 * (*(void *)(a1 + 56) & 0x7FLL);
  }
  return sub_10079DD74((void *)(a1 + 24), v12, v18, (char *)v14, v13);
}

BOOL sub_100E1CCAC(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    double v5 = *(double *)(*(void *)(*(void *)(a1 + 32)
  }
  else {
    double v5 = -1.79769313e308;
  }
  if (v5 >= a2)
  {
    __int128 v6 = (_BYTE *)(a1 + 80);
    goto LABEL_11;
  }

  __int128 v6 = (_BYTE *)(a1 + 80);
  if (*(_BYTE *)(a1 + 80))
  {
    double v7 = *(double *)(a1 + 16);
    if (*(double *)(a1 + 72) - v7 < a2 && v7 + *(double *)(a1 + 88) > a2)
    {
      double v8 = *(double *)(a1 + 104);
    }

void sub_100E1CDD0(void **a1)
{
  *a1 = off_1018853E0;
  free(a1[1]);
  sub_1000EAA04(a1 + 3);
  operator delete(a1);
}

void *sub_100E1CE10(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &off_101885418;
  result[1] = v3;
  return result;
}

uint64_t sub_100E1CE48(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_101885418;
  a2[1] = v2;
  return result;
}

uint64_t sub_100E1CE68(uint64_t a1, unsigned __int8 *a2)
{
  return sub_100BD34CC(*(void *)(a1 + 8), *a2, 3);
}

uint64_t sub_100E1CE78(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E1CEB4()
{
  return &off_101885478;
}

uint64_t sub_100E1CEC0(uint64_t a1, uint64_t a2, const char *a3, int a4, double a5, double a6, double a7)
{
  unint64_t v9 = (void *)sub_100E1CF1C(a1, a3, a4, a5, a6, a7);
  void *v9 = off_101885498;
  sub_10001A504((uint64_t)(v9 + 16), a2);
  return a1;
}

void sub_100E1CF08(_Unwind_Exception *a1)
{
}

uint64_t sub_100E1CF1C(uint64_t a1, const char *a2, int a3, double a4, double a5, double a6)
{
  *(void *)a1 = off_1018855B8;
  if (a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = "NatalieInputSrc";
  }
  uint64_t v12 = strdup(v11);
  *(double *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_101885548;
  *(void *)(a1 + 8) = v12;
  *(void *)(a1 + 72) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0LL;
  *(double *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  *(double *)(a1 + 112) = a6;
  *(_BYTE *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 121) = a3;
  if (a3)
  {
    *(void *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
    *(void *)(a1 + 88) = 0x7FEFFFFFFFFFFFFFLL;
  }

  return a1;
}

uint64_t sub_100E1CFDC(uint64_t a1)
{
  *(void *)a1 = off_1018855B8;
  free(*(void **)(a1 + 8));
  sub_100210A00((void *)(a1 + 24));
  return a1;
}

void sub_100E1D01C(char *a1)
{
  *(void *)a1 = off_101885498;
  uint64_t v2 = a1 + 128;
  uint64_t v3 = (void *)*((void *)a1 + 19);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
    goto LABEL_5;
  }

  if (v3)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  *(void *)a1 = off_1018855B8;
  free(*((void **)a1 + 1));
  sub_100210A00((void *)a1 + 3);
  operator delete(a1);
}

double sub_100E1D09C(uint64_t a1, __n128 *a2)
{
  *(void *)&double result = sub_100BD4084((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

unint64_t sub_100E1D0A4(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    __int128 v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)__int128 buf = 134218752;
      double v34 = v7 - v4;
      __int16 v35 = 2048;
      double v36 = v4;
      __int16 v37 = 2048;
      double v38 = v7;
      __int16 v39 = 1024;
      int v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v20 = *(double *)(a1 + 104);
      int v21 = *(unsigned __int8 *)(a1 + 121);
      int v25 = 134218752;
      double v26 = v20 - v4;
      __int16 v27 = 2048;
      double v28 = v4;
      __int16 v29 = 2048;
      double v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      LODWORD(v24) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  COERCE_DOUBLE(&v25),  v24);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInput<CLCalorimetryKickboxingDMFeatures>::update(CFAbsoluteTime) [Data_T = CLCalorimetryKi ckboxingDMFeatures]",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

  if (*(_BYTE *)(a1 + 80)
    && !*(_BYTE *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(_BYTE *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1))
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0LL;
  }

  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (void *)(v10 + 8 * (v9 / 0xAA));
  if (v11 == v10) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = (char *)(*v12 + 24 * (v9 % 0xAA));
  }
  uint64_t v14 = (void *)(v10 + 8 * (v9 / 0xAA));
LABEL_15:
  uint64_t v15 = (double *)v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0LL
        : *(void *)(v10 + 8 * ((*(void *)(a1 + 64) + v9) / 0xAA)) + 24 * ((*(void *)(a1 + 64) + v9) % 0xAA);
    v15 += 3;
    v13 += 24;
    if ((char *)(*v14 + 4080LL) == v13)
    {
      uint64_t v17 = (char *)v14[1];
      ++v14;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }

  if (v11 == v10) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = (char *)(*v12 + 24 * (v9 % 0xAA));
  }
  return sub_100CE617C((void *)(a1 + 24), v12, v18, v14, v13);
}

void sub_100E1D404(void **a1)
{
  *a1 = off_1018855B8;
  free(a1[1]);
  sub_100210A00(a1 + 3);
  operator delete(a1);
}

void *sub_100E1D444(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &off_1018855F0;
  result[1] = v3;
  return result;
}

uint64_t sub_100E1D47C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1018855F0;
  a2[1] = v2;
  return result;
}

double sub_100E1D49C(uint64_t a1, int *a2, __n128 *a3)
{
  int v3 = *a2;
  __n128 v4 = a3[1];
  v6[0] = *a3;
  v6[1] = v4;
  return sub_100BD3530(*(void **)(a1 + 8), v3, v6);
}

uint64_t sub_100E1D4CC(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E1D508()
{
  return &off_101885660;
}

void sub_100E1D514(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_100E1D544(uint64_t a1)
{
  *(void *)a1 = off_1018856A0;
  uint64_t v2 = a1 + 8;
  sub_10000AE14(a1 + 160);
  sub_10000AE14(a1 + 144);
  sub_10000AE14(a1 + 128);
  sub_10000AE14(a1 + 112);
  sub_10000AE14(a1 + 96);
  __n128 v4 = (void **)(a1 + 72);
  sub_10004CC28(&v4);
  sub_10000AE14(a1 + 56);
  sub_10000AE14(a1 + 40);
  sub_10000AE14(a1 + 24);
  sub_10000AE14(v2);
  return a1;
}

void sub_100E1D5D8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E1D544(a1);
  operator delete(v1);
}

uint64_t sub_100E1D5EC(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 704);
  int v3 = *(void **)(a1 + 728);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    int v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
  BOOL v5 = *(void **)(a1 + 696);
  *(void *)(a1 + 696) = 0LL;
  if (v5) {
    operator delete(v5);
  }
  __int128 v6 = *(void **)(a1 + 688);
  *(void *)(a1 + 688) = 0LL;
  if (v6) {
    operator delete(v6);
  }
  double v7 = *(void **)(a1 + 680);
  *(void *)(a1 + 680) = 0LL;
  if (v7) {
    operator delete(v7);
  }
  int v8 = *(void **)(a1 + 672);
  *(void *)(a1 + 672) = 0LL;
  if (v8) {
    operator delete(v8);
  }
  *(void *)(a1 + 512) = off_101885498;
  unint64_t v9 = *(void **)(a1 + 664);
  if (v9 == (void *)(a1 + 640))
  {
    uint64_t v10 = 4LL;
    unint64_t v9 = (void *)(a1 + 640);
  }

  else
  {
    if (!v9) {
      goto LABEL_19;
    }
    uint64_t v10 = 5LL;
  }

  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_19:
  *(void *)(a1 + 512) = off_1018855B8;
  free(*(void **)(a1 + 520));
  sub_100210A00((void *)(a1 + 536));
  *(void *)(a1 + 352) = off_1018852C0;
  uint64_t v11 = *(void **)(a1 + 504);
  if (v11 == (void *)(a1 + 480))
  {
    uint64_t v12 = 4LL;
    uint64_t v11 = (void *)(a1 + 480);
  }

  else
  {
    if (!v11) {
      goto LABEL_24;
    }
    uint64_t v12 = 5LL;
  }

  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_24:
  *(void *)(a1 + 352) = off_1018853E0;
  free(*(void **)(a1 + 360));
  sub_1000EAA04((void *)(a1 + 376));
  *(void *)(a1 + 192) = off_1018850E8;
  uint64_t v13 = *(void **)(a1 + 344);
  if (v13 == (void *)(a1 + 320))
  {
    uint64_t v14 = 4LL;
    uint64_t v13 = (void *)(a1 + 320);
  }

  else
  {
    if (!v13) {
      goto LABEL_29;
    }
    uint64_t v14 = 5LL;
  }

  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_29:
  *(void *)(a1 + 192) = off_101885208;
  free(*(void **)(a1 + 200));
  sub_100231C10((void *)(a1 + 216));
  *(void *)(a1 + 32) = off_101884F10;
  uint64_t v15 = *(void **)(a1 + 184);
  if (v15 == (void *)(a1 + 160))
  {
    uint64_t v16 = 4LL;
    uint64_t v15 = (void *)(a1 + 160);
  }

  else
  {
    if (!v15) {
      goto LABEL_34;
    }
    uint64_t v16 = 5LL;
  }

  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_34:
  *(void *)(a1 + 32) = off_101885030;
  free(*(void **)(a1 + 40));
  sub_100210A00((void *)(a1 + 56));
  uint64_t v17 = *(void **)(a1 + 24);
  if (v17 == (void *)a1)
  {
    uint64_t v18 = 4LL;
    uint64_t v17 = (void *)a1;
    goto LABEL_38;
  }

  if (v17)
  {
    uint64_t v18 = 5LL;
LABEL_38:
    (*(void (**)(void))(*v17 + 8 * v18))();
  }

  return a1;
}

void sub_100E1D828(void **a1)
{
  *a1 = off_1018856D0;
  free(a1[1]);
  sub_1000EAA04(a1 + 3);
  operator delete(a1);
}

void sub_100E1D868(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

void sub_100E1D894(id a1)
{
  qword_1019346E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "VO2Max");
}

void sub_100E1D8C0(id a1)
{
  qword_1019347A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "CyclingPower");
}

void *sub_100E1D8F0(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &off_101885878;
  v4[1] = 0LL;
  v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100E1D938(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E1D958(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

uint64_t sub_100E1D970(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *sub_100E1D9B0@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x178uLL);
  uint64_t result = sub_100E1DA08(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100E1D9F4(_Unwind_Exception *a1)
{
}

void *sub_100E1DA08(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1018858F0;
  sub_100FB49F8(a1 + 3, *a2);
  return a1;
}

void sub_100E1DA44(_Unwind_Exception *a1)
{
}

void sub_100E1DA58(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1018858F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E1DA6C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1018858F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100E1DA90(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void *sub_100E1DAA0@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x1A0uLL);
  uint64_t result = sub_100E1DAF8(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100E1DAE4(_Unwind_Exception *a1)
{
}

void *sub_100E1DAF8(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_101885940;
  sub_100AC01D8(a1 + 3, *a2);
  return a1;
}

void sub_100E1DB34(_Unwind_Exception *a1)
{
}

void sub_100E1DB48(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101885940;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E1DB5C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101885940;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100E1DB80(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void *sub_100E1DB90@<X0>(unsigned __int8 *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x158uLL);
  uint64_t result = sub_100E1DBE8(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100E1DBD4(_Unwind_Exception *a1)
{
}

void *sub_100E1DBE8(void *a1, unsigned __int8 *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_101885990;
  sub_1006F0074(a1 + 3, *a2);
  return a1;
}

void sub_100E1DC24(_Unwind_Exception *a1)
{
}

void sub_100E1DC38(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_101885990;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E1DC4C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_101885990;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100E1DC70(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 24) + 16LL))(a1 + 24);
}

void *sub_100E1DC80(void *a1, const char *a2, void *a3, int a4, double a5, double a6, double a7)
{
  *(void *)sub_100E1DD68((uint64_t)a1, a2, a4, a5, a6, a7) = off_1018859E0;
  a1[16] = [a3 silo];
  a1[17] = 0LL;
  sub_10027EB5C((uint64_t)sub_100E1DE28, (uint64_t)a1, a3, &v13);
  uint64_t v9 = v13;
  uint64_t v13 = 0LL;
  uint64_t v10 = a1[17];
  a1[17] = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    uint64_t v11 = v13;
    uint64_t v13 = 0LL;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
  }

  (*(void (**)(void *))(*a1 + 80LL))(a1);
  return a1;
}

void sub_100E1DD30(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 136);
  *(void *)(v1 + 136) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_1008324B4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E1DD68(uint64_t a1, const char *a2, int a3, double a4, double a5, double a6)
{
  *(void *)a1 = &off_101859FE8;
  if (a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = "NatalieInputSrc";
  }
  uint64_t v12 = strdup(v11);
  *(double *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_101859F50;
  *(void *)(a1 + 8) = v12;
  *(void *)(a1 + 72) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0LL;
  *(double *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  *(double *)(a1 + 112) = a6;
  *(_BYTE *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 121) = a3;
  if (a3)
  {
    *(void *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
    *(void *)(a1 + 88) = 0x7FEFFFFFFFFFFFFFLL;
  }

  return a1;
}

uint64_t sub_100E1DE28(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  return (*((uint64_t (**)(id *, uint64_t, uint64_t, uint64_t))*a4 + 12))(a4, a1, a2, a3);
}

void sub_100E1DE78(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E24548(a1);
  operator delete(v1);
}

uint64_t sub_100E1DE8C(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Activate src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Activate src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieSourceFromNotifier<CLOdometerEntry>::startActive() [Data_T = CLOdometerEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  [*(id *)(*(void *)(a1 + 136) + 16) register:*(void *)(*(void *)(a1 + 136) + 8) forNotification:2 registrationInfo:0];
  return 1LL;
}

uint64_t sub_100E1E054(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Inactivate src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Inactivate src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieSourceFromNotifier<CLOdometerEntry>::stopActive() [Data_T = CLOdometerEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  [*(id *)(*(void *)(a1 + 136) + 16) unregister:*(void *)(*(void *)(a1 + 136) + 8) forNotification:2];
  return 1LL;
}

id sub_100E1E218(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Start spectator for src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Start spectator for src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieSourceFromNotifier<CLOdometerEntry>::startSpectator() [Data_T = CLOdometerEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return [*(id *)(*(void *)(a1 + 136) + 16) register:*(void *)(*(void *)(a1 + 136) + 8) forNotification:4 registrationInfo:0];
}

id sub_100E1E3DC(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Stop spectator for src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Stop spectator for src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieSourceFromNotifier<CLOdometerEntry>::stopSpectator() [Data_T = CLOdometerEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return [*(id *)(*(void *)(a1 + 136) + 16) unregister:*(void *)(*(void *)(a1 + 136) + 8) forNotification:4];
}

uint64_t sub_100E1E59C(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 4 || *a3 == 2) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 32LL))(result, a4);
  }
  return result;
}

void sub_100E1E5C0(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void *sub_100E1E5EC(void *a1, const char *a2, void *a3, char a4, double a5, double a6, double a7)
{
  *(void *)sub_100F71FA0((uint64_t)a1, a2, a4, a5, a6, a7) = off_101885A90;
  a1[48] = [a3 silo];
  a1[49] = 0LL;
  sub_10027EB5C((uint64_t)sub_100E1E6D4, (uint64_t)a1, a3, &v13);
  uint64_t v9 = v13;
  uint64_t v13 = 0LL;
  uint64_t v10 = a1[49];
  a1[49] = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    uint64_t v11 = v13;
    uint64_t v13 = 0LL;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
  }

  (*(void (**)(void *))(*a1 + 80LL))(a1);
  return a1;
}

void sub_100E1E69C(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 392);
  *(void *)(v1 + 392) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_100E1E724(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E1E6D4(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  return (*((uint64_t (**)(id *, uint64_t, uint64_t, uint64_t))*a4 + 12))(a4, a1, a2, a3);
}

uint64_t sub_100E1E724(uint64_t a1)
{
  *(void *)a1 = off_10188EED0;
  sub_10046E138((void *)(a1 + 128));
  *(void *)a1 = off_101885B20;
  free(*(void **)(a1 + 8));
  sub_1002D62D8((void *)(a1 + 24));
  return a1;
}

void sub_100E1E778(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E245B0(a1);
  operator delete(v1);
}

BOOL sub_100E1E78C(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(v4 + 8LL * (*(void *)(a1 + 56) >> 6));
  if (*(void *)(a1 + 40) == v4) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = *v5 + ((*(void *)(a1 + 56) & 0x3FLL) << 6);
  }
  *a3 = v5;
  a3[1] = v6;
  a3[2] = v5;
  a3[3] = v6;
  __int128 v7 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v7;
  unint64_t v8 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = (uint64_t *)(v9 + 8 * (v8 >> 6));
  if (*(void *)(a1 + 40) == v9) {
    uint64_t v11 = 0LL;
  }
  else {
    uint64_t v11 = *v10 + ((v8 & 0x3F) << 6);
  }
  uint64_t v12 = a3[3];
  if (v11 != v12)
  {
    uint64_t v13 = *v10;
    double v14 = 1.79769313e308;
    uint64_t v15 = v11;
    uint64_t v16 = v10;
    while (1)
    {
      uint64_t v17 = v15;
      if (v15 == v13) {
        uint64_t v17 = *(v16 - 1) + 4096;
      }
      double v18 = vabdd_f64(*(double *)(v17 - 56), a4);
      if (v18 < v14 && v18 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v10;
        *(void *)(a2 + 8) = v11;
        *(void *)(a2 + 16) = v16;
        *(void *)(a2 + 24) = v15;
        uint64_t v13 = *v16;
        uint64_t v19 = v15;
        if (v15 == *v16) {
          uint64_t v19 = *(v16 - 1) + 4096;
        }
        double v14 = v18;
      }

      if (v15 == v13)
      {
        uint64_t v20 = *--v16;
        uint64_t v13 = v20;
        uint64_t v15 = v20 + 4096;
      }

      v15 -= 64LL;
      uint64_t v12 = a3[3];
      if (v15 == v12) {
        return v12 != *(void *)(a2 + 24);
      }
    }

    uint64_t v12 = a3[3];
  }

  return v12 != *(void *)(a2 + 24);
}

uint64_t sub_100E1E8B0(uint64_t a1, _OWORD *a2)
{
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, __int128 *, __int128 *))(*(void *)a1 + 16LL))(a1, &v10, &v8);
  if ((_DWORD)result)
  {
    uint64_t v4 = *((void *)&v11 + 1);
    if (*((void *)&v11 + 1) == *((void *)&v9 + 1))
    {
      return 0LL;
    }

    else
    {
      if (*(void *)v11 == *((void *)&v11 + 1)) {
        uint64_t v4 = *(void *)(v11 - 8) + 4096LL;
      }
      __int128 v5 = *(_OWORD *)(v4 - 64);
      __int128 v6 = *(_OWORD *)(v4 - 48);
      __int128 v7 = *(_OWORD *)(v4 - 16);
      a2[2] = *(_OWORD *)(v4 - 32);
      a2[3] = v7;
      *a2 = v5;
      a2[1] = v6;
      return 1LL;
    }
  }

  return result;
}

void *sub_100E1E944(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    __int128 v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)__int128 buf = 134218752;
      double v34 = v7 - v4;
      __int16 v35 = 2048;
      double v36 = v4;
      __int16 v37 = 2048;
      double v38 = v7;
      __int16 v39 = 1024;
      int v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Input, elevation, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v20 = *(double *)(a1 + 104);
      int v21 = *(unsigned __int8 *)(a1 + 121);
      int v25 = 134218752;
      double v26 = v20 - v4;
      __int16 v27 = 2048;
      double v28 = v4;
      __int16 v29 = 2048;
      double v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      LODWORD(v24) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Input, elevation, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  COERCE_DOUBLE(&v25),  v24);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInput<CLElevationChangeEntry>::update(CFAbsoluteTime)",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

  if (*(_BYTE *)(a1 + 80)
    && !*(_BYTE *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(_BYTE *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1))
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0LL;
  }

  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 6));
  if (v11 == v10) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = *(void *)v12 + ((*(void *)(a1 + 56) & 0x3FLL) << 6);
  }
  uint64_t v14 = v10 + 8 * (v9 >> 6);
LABEL_15:
  uint64_t v15 = v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0LL
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 3) & 0x1FFFFFFFFFFFFFF8LL))
        + (((*(void *)(a1 + 64) + v9) & 0x3F) << 6);
    v13 += 64LL;
    v15 += 64LL;
    if (*(void *)v14 + 4096LL == v13)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      v14 += 8LL;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }

  if (v11 == v10) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = *(void *)v12 + ((*(void *)(a1 + 56) & 0x3FLL) << 6);
  }
  return sub_100CE4620((void *)(a1 + 24), v12, v18, (char *)v14, v13);
}

uint64_t sub_100E1EC80(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Activate src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Activate src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieSourceFromNotifier<CLElevationChangeEntry>::startActive() [Data_T = CLElevationChangeEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  [*(id *)(*(void *)(a1 + 392) + 16) register:*(void *)(*(void *)(a1 + 392) + 8) forNotification:3 registrationInfo:0];
  return 1LL;
}

uint64_t sub_100E1EE48(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Inactivate src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Inactivate src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieSourceFromNotifier<CLElevationChangeEntry>::stopActive() [Data_T = CLElevationChangeEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  [*(id *)(*(void *)(a1 + 392) + 16) unregister:*(void *)(*(void *)(a1 + 392) + 8) forNotification:3];
  return 1LL;
}

id sub_100E1F00C(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Start spectator for src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Start spectator for src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieSourceFromNotifier<CLElevationChangeEntry>::startSpectator() [Data_T = CLElevationChangeEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return [*(id *)(*(void *)(a1 + 392) + 16) register:*(void *)(*(void *)(a1 + 392) + 8) forNotification:7 registrationInfo:0];
}

id sub_100E1F1D0(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Stop spectator for src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Stop spectator for src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieSourceFromNotifier<CLElevationChangeEntry>::stopSpectator() [Data_T = CLElevationChangeEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return [*(id *)(*(void *)(a1 + 392) + 16) unregister:*(void *)(*(void *)(a1 + 392) + 8) forNotification:7];
}

uint64_t sub_100E1F390(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if ((*a3 | 4) == 7) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 32LL))(result, a4);
  }
  return result;
}

uint64_t sub_100E1F3B4(uint64_t a1)
{
  *(void *)a1 = off_101885B20;
  free(*(void **)(a1 + 8));
  sub_1002D62D8((void *)(a1 + 24));
  return a1;
}

void sub_100E1F3F4(void **a1)
{
  *a1 = off_101885B20;
  free(a1[1]);
  sub_1002D62D8(a1 + 3);
  operator delete(a1);
}

double sub_100E1F434(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = sub_10046E4C0((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

void *sub_100E1F43C(void *a1, const char *a2, void *a3, int a4, double a5, double a6, double a7)
{
  *(void *)sub_100E1F524((uint64_t)a1, a2, a4, a5, a6, a7) = off_101885B68;
  a1[16] = [a3 silo];
  a1[17] = 0LL;
  sub_10027EB5C((uint64_t)sub_100E1F5E8, (uint64_t)a1, a3, &v13);
  uint64_t v9 = v13;
  uint64_t v13 = 0LL;
  uint64_t v10 = a1[17];
  a1[17] = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    uint64_t v11 = v13;
    uint64_t v13 = 0LL;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
  }

  (*(void (**)(void *))(*a1 + 80LL))(a1);
  return a1;
}

void sub_100E1F4EC(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 136);
  *(void *)(v1 + 136) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_100E1F638(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E1F524(uint64_t a1, const char *a2, int a3, double a4, double a5, double a6)
{
  *(void *)a1 = off_101885C90;
  if (a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = "NatalieInputSrc";
  }
  uint64_t v12 = strdup(v11);
  *(double *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_101885C20;
  *(void *)(a1 + 8) = v12;
  *(void *)(a1 + 72) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0LL;
  *(double *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  *(double *)(a1 + 112) = a6;
  *(_WORD *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 122) = a3;
  *(_BYTE *)(a1 + 123) = 0;
  if (a3)
  {
    *(void *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
    *(void *)(a1 + 88) = 0x7FEFFFFFFFFFFFFFLL;
  }

  return a1;
}

uint64_t sub_100E1F5E8(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  return (*((uint64_t (**)(id *, uint64_t, uint64_t, uint64_t))*a4 + 12))(a4, a1, a2, a3);
}

uint64_t sub_100E1F638(uint64_t a1)
{
  *(void *)a1 = off_101885C90;
  free(*(void **)(a1 + 8));
  sub_100231C10((void *)(a1 + 24));
  return a1;
}

void sub_100E1F678(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E24630(a1);
  operator delete(v1);
}

double sub_100E1F68C(uint64_t a1, __n128 *a2)
{
  *(void *)&double result = sub_100E202D0((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

void *sub_100E1F694(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(a1 + 121) = v5;
  if (v5)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    __int128 v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 122);
      *(_DWORD *)__int128 buf = 134218752;
      double v37 = v7 - v4;
      __int16 v38 = 2048;
      double v39 = v4;
      __int16 v40 = 2048;
      double v41 = v7;
      __int16 v42 = 1024;
      int v43 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Input, all-day elevation, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v23 = *(double *)(a1 + 104);
      int v24 = *(unsigned __int8 *)(a1 + 122);
      int v28 = 134218752;
      double v29 = v23 - v4;
      __int16 v30 = 2048;
      double v31 = v4;
      __int16 v32 = 2048;
      double v33 = v23;
      __int16 v34 = 1024;
      int v35 = v24;
      LODWORD(v27) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Input, all-day elevation, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  COERCE_DOUBLE(&v28),  v27);
      double v26 = (uint8_t *)v25;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInput<CLCoarseElevationChangeEntry>::update(CFAbsoluteTime)",  "%s\n",  v25);
      if (v26 != buf) {
        free(v26);
      }
    }
  }

  if (*(_BYTE *)(a1 + 80)
    && !*(_BYTE *)(a1 + 122)
    && (*(double *)(a1 + 88) < a2 || *(_BYTE *)(a1 + 121))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1))
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0LL;
  }

  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 8));
  if (v11 == v10) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = *(void *)v12 + 16LL * v9;
  }
  uint64_t v14 = v10 + 8 * (v9 >> 8);
LABEL_15:
  uint64_t v15 = (double *)v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0LL
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 5) & 0x7FFFFFFFFFFFFF8LL))
        + 16LL * (*(_BYTE *)(a1 + 64) + v9);
    v15 += 2;
    v13 += 16LL;
    if (*(void *)v14 + 4096LL == v13)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      v14 += 8LL;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }

  if (v11 == v10) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = *(void *)v12 + 16LL * v9;
  }
  double result = sub_10025A918((void *)(a1 + 24), v12, v18, (char *)v14, v13);
  uint64_t v20 = *(void *)(a1 + 64);
  if (v20) {
    double v21 = *(double *)(*(void *)(*(void *)(a1 + 32)
  }
                                + (((unint64_t)(v20 + *(void *)(a1 + 56) - 1) >> 5) & 0x7FFFFFFFFFFFFF8LL))
                    + 16LL * (v20 + *(_BYTE *)(a1 + 56) - 1))
        + 180.0
        + 20.0;
  else {
    double v21 = -1.79769313e308;
  }
  BOOL v22 = v21 > a2 && !*(_BYTE *)(a1 + 123);
  *(_BYTE *)(a1 + 120) = v22;
  return result;
}

BOOL sub_100E1FA34(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    double v5 = *(double *)(*(void *)(*(void *)(a1 + 32)
  }
  else {
    double v5 = -1.79769313e308;
  }
  if (v5 >= a2 && sub_100E1BEF0(a1, (uint64_t)v26, v25, a2)
    || (double v6 = *(double *)(a1 + 104), v6 - (*(double (**)(uint64_t, double))(*(void *)a1 + 56LL))(a1, a2) >= a2)
    || *(_BYTE *)(a1 + 121))
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    double v7 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = *(void *)(a1 + 8);
      double v9 = (*(double (**)(uint64_t, double))(*(void *)a1 + 56LL))(a1, a2);
      *(_DWORD *)__int128 buf = 136315650;
      uint64_t v34 = v8;
      __int16 v35 = 2048;
      double v36 = a2;
      __int16 v37 = 2048;
      double v38 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "%s is ready at, %f, timeout, %f", buf, 0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      uint64_t v19 = qword_1019344D8;
      uint64_t v20 = *(void *)(a1 + 8);
      double v21 = (*(double (**)(uint64_t, double))(*(void *)a1 + 56LL))(a1, a2);
      int v27 = 136315650;
      uint64_t v28 = v20;
      __int16 v29 = 2048;
      double v30 = a2;
      __int16 v31 = 2048;
      double v32 = v21;
      LODWORD(v24) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v19,  2LL,  "%s is ready at, %f, timeout, %f",  (const char *)&v27,  v24,  *(double *)v25);
      double v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieInput<CLCoarseElevationChangeEntry>::isReady(CFAbsoluteTime)",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }

    return 1LL;
  }

  else
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    uint64_t v11 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v12 = *(void *)(a1 + 8);
      double v13 = (*(double (**)(uint64_t, double))(*(void *)a1 + 56LL))(a1, a2);
      *(_DWORD *)__int128 buf = 136315650;
      uint64_t v34 = v12;
      __int16 v35 = 2048;
      double v36 = a2;
      __int16 v37 = 2048;
      double v38 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "%s is not ready at, %f, timeout, %f",  buf,  0x20u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      uint64_t v14 = qword_1019344D8;
      uint64_t v15 = *(void *)(a1 + 8);
      double v16 = (*(double (**)(uint64_t, double))(*(void *)a1 + 56LL))(a1, a2);
      int v27 = 136315650;
      uint64_t v28 = v15;
      __int16 v29 = 2048;
      double v30 = a2;
      __int16 v31 = 2048;
      double v32 = v16;
      LODWORD(v24) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  2LL,  "%s is not ready at, %f, timeout, %f",  (const char *)&v27,  v24,  *(double *)v25);
      uint64_t v18 = (uint8_t *)v17;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieInput<CLCoarseElevationChangeEntry>::isReady(CFAbsoluteTime)",  "%s\n",  v17);
      if (v18 != buf) {
        free(v18);
      }
      return 0LL;
    }
  }

  return result;
}

double sub_100E1FE74(uint64_t a1, double a2)
{
  double v2 = 2.0;
  if (*(_BYTE *)(a1 + 120) && !*(_BYTE *)(a1 + 123))
  {
    uint64_t v3 = *(void *)(a1 + 64);
    if (v3) {
      double v4 = *(double *)(*(void *)(*(void *)(a1 + 32)
    }
                                 + (((unint64_t)(v3 + *(void *)(a1 + 56) - 1) >> 5) & 0x7FFFFFFFFFFFFF8LL))
                     + 16LL * (v3 + *(_BYTE *)(a1 + 56) - 1))
         + 180.0
         + 20.0;
    else {
      double v4 = -1.79769313e308;
    }
    double v2 = v4 - a2;
  }

  *(double *)(a1 + 96) = v2;
  return v2;
}

id sub_100E1FEE8(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  double v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Start spectator for src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Start spectator for src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieSourceFromNotifier<CLCoarseElevationChangeEntry>::startSpectator() [Data_T = CLCoarseElevationChangeEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return [*(id *)(*(void *)(a1 + 136) + 16) register:*(void *)(*(void *)(a1 + 136) + 8) forNotification:5 registrationInfo:0];
}

id sub_100E200AC(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  double v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Stop spectator for src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Stop spectator for src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieSourceFromNotifier<CLCoarseElevationChangeEntry>::stopSpectator() [Data_T = CLCoarseElevationChangeEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return [*(id *)(*(void *)(a1 + 136) + 16) unregister:*(void *)(*(void *)(a1 + 136) + 8) forNotification:5];
}

uint64_t sub_100E2026C(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 5 || *a3 == -1) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 32LL))(result, a4);
  }
  return result;
}

void sub_100E20290(void **a1)
{
  *a1 = off_101885C90;
  free(a1[1]);
  sub_100231C10(a1 + 3);
  operator delete(a1);
}

__n128 sub_100E202D0(void *a1, __n128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 32 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100E20358(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  __n128 result = *a2;
  *(__n128 *)(*(void *)(v5 + ((v7 >> 5) & 0x7FFFFFFFFFFFFF8LL)) + 16LL * v7) = *a2;
  ++a1[5];
  return result;
}

void sub_100E20358(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    int v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)int v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      __int16 v37 = &v34[8 * v36];
      double v38 = (uint64_t *)a1[1];
      int v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        int v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100E20620( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_100E2066C(void *a1, const char *a2, void *a3, int a4, double a5, double a6, double a7)
{
  *(void *)sub_100E20754((uint64_t)a1, a2, a4, a5, a6, a7) = off_101885CC8;
  a1[16] = [a3 silo];
  a1[17] = 0LL;
  sub_10070EDF0((uint64_t)sub_100E20814, (uint64_t)a1, a3, &v13);
  uint64_t v9 = v13;
  uint64_t v13 = 0LL;
  uint64_t v10 = a1[17];
  a1[17] = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    uint64_t v11 = v13;
    uint64_t v13 = 0LL;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
  }

  (*(void (**)(void *))(*a1 + 80LL))(a1);
  return a1;
}

void sub_100E2071C(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 136);
  *(void *)(v1 + 136) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_100E20864(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E20754(uint64_t a1, const char *a2, int a3, double a4, double a5, double a6)
{
  *(void *)a1 = off_101885DF0;
  if (a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = "NatalieInputSrc";
  }
  uint64_t v12 = strdup(v11);
  *(double *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_101885D80;
  *(void *)(a1 + 8) = v12;
  *(void *)(a1 + 72) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0LL;
  *(double *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  *(double *)(a1 + 112) = a6;
  *(_BYTE *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 121) = a3;
  if (a3)
  {
    *(void *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
    *(void *)(a1 + 88) = 0x7FEFFFFFFFFFFFFFLL;
  }

  return a1;
}

uint64_t sub_100E20814(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  return (*((uint64_t (**)(id *, uint64_t, uint64_t, uint64_t))*a4 + 12))(a4, a1, a2, a3);
}

uint64_t sub_100E20864(uint64_t a1)
{
  *(void *)a1 = off_101885DF0;
  free(*(void **)(a1 + 8));
  sub_1002D62D8((void *)(a1 + 24));
  return a1;
}

void sub_100E208A4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E24698(a1);
  operator delete(v1);
}

BOOL sub_100E208B8(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = (void *)(v4 + 8LL * (*(void *)(a1 + 56) >> 6));
  if (*(void *)(a1 + 40) == v4) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = *v5 + ((*(void *)(a1 + 56) & 0x3FLL) << 6);
  }
  *a3 = v5;
  a3[1] = v6;
  a3[2] = v5;
  a3[3] = v6;
  __int128 v7 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v7;
  unint64_t v8 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = (uint64_t *)(v9 + 8 * (v8 >> 6));
  if (*(void *)(a1 + 40) == v9) {
    uint64_t v11 = 0LL;
  }
  else {
    uint64_t v11 = *v10 + ((v8 & 0x3F) << 6);
  }
  uint64_t v12 = a3[3];
  if (v11 != v12)
  {
    uint64_t v13 = *v10;
    double v14 = 1.79769313e308;
    uint64_t v15 = v11;
    uint64_t v16 = v10;
    while (1)
    {
      uint64_t v17 = v15;
      if (v15 == v13) {
        uint64_t v17 = *(v16 - 1) + 4096;
      }
      double v18 = vabdd_f64(*(double *)(v17 - 24), a4);
      if (v18 < v14 && v18 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v10;
        *(void *)(a2 + 8) = v11;
        *(void *)(a2 + 16) = v16;
        *(void *)(a2 + 24) = v15;
        uint64_t v13 = *v16;
        uint64_t v19 = v15;
        if (v15 == *v16) {
          uint64_t v19 = *(v16 - 1) + 4096;
        }
        double v14 = v18;
      }

      if (v15 == v13)
      {
        uint64_t v20 = *--v16;
        uint64_t v13 = v20;
        uint64_t v15 = v20 + 4096;
      }

      v15 -= 64LL;
      uint64_t v12 = a3[3];
      if (v15 == v12) {
        return v12 != *(void *)(a2 + 24);
      }
    }

    uint64_t v12 = a3[3];
  }

  return v12 != *(void *)(a2 + 24);
}

void *sub_100E209DC(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    uint64_t v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)__int128 buf = 134218752;
      double v34 = v7 - v4;
      __int16 v35 = 2048;
      double v36 = v4;
      __int16 v37 = 2048;
      double v38 = v7;
      __int16 v39 = 1024;
      int v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v20 = *(double *)(a1 + 104);
      int v21 = *(unsigned __int8 *)(a1 + 121);
      int v25 = 134218752;
      double v26 = v20 - v4;
      __int16 v27 = 2048;
      double v28 = v4;
      __int16 v29 = 2048;
      double v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      LODWORD(v24) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  COERCE_DOUBLE(&v25),  v24);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInput<CLCatherineData>::update(CFAbsoluteTime) [Data_T = CLCatherineData]",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

  if (*(_BYTE *)(a1 + 80)
    && !*(_BYTE *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(_BYTE *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1))
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0LL;
  }

  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 6));
  if (v11 == v10) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = *(void *)v12 + ((*(void *)(a1 + 56) & 0x3FLL) << 6);
  }
  uint64_t v14 = v10 + 8 * (v9 >> 6);
LABEL_15:
  uint64_t v15 = v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0LL
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 3) & 0x1FFFFFFFFFFFFFF8LL))
        + (((*(void *)(a1 + 64) + v9) & 0x3F) << 6);
    v13 += 64LL;
    v15 += 64LL;
    if (*(void *)v14 + 4096LL == v13)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      v14 += 8LL;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }

  if (v11 == v10) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = *(void *)v12 + ((*(void *)(a1 + 56) & 0x3FLL) << 6);
  }
  return sub_100CE4620((void *)(a1 + 24), v12, v18, (char *)v14, v13);
}

BOOL sub_100E20D18(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    double v5 = *(double *)(*(void *)(*(void *)(a1 + 32)
  }
                               + (((unint64_t)(v4 + *(void *)(a1 + 56) - 1) >> 3) & 0x1FFFFFFFFFFFFFF8LL))
                   + (((v4 + *(void *)(a1 + 56) - 1) & 0x3F) << 6)
                   + 40);
  else {
    double v5 = -1.79769313e308;
  }
  if (v5 >= a2)
  {
    uint64_t v6 = (_BYTE *)(a1 + 80);
    goto LABEL_11;
  }

  uint64_t v6 = (_BYTE *)(a1 + 80);
  if (*(_BYTE *)(a1 + 80))
  {
    double v7 = *(double *)(a1 + 16);
    if (*(double *)(a1 + 72) - v7 < a2 && v7 + *(double *)(a1 + 88) > a2)
    {
      double v8 = *(double *)(a1 + 104);
    }

uint64_t sub_100E20E3C(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  unint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Activate src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Activate src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieSourceFromNotifier<CLCatherineData>::startActive() [Data_T = CLCatherineData]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  [*(id *)(*(void *)(a1 + 136) + 16) register:*(void *)(*(void *)(a1 + 136) + 8) forNotification:1 registrationInfo:0];
  return 1LL;
}

uint64_t sub_100E21004(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  unint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Inactivate src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Inactivate src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieSourceFromNotifier<CLCatherineData>::stopActive() [Data_T = CLCatherineData]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  [*(id *)(*(void *)(a1 + 136) + 16) unregister:*(void *)(*(void *)(a1 + 136) + 8) forNotification:1];
  return 1LL;
}

id sub_100E211C8(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  unint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Start spectator for src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Start spectator for src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieSourceFromNotifier<CLCatherineData>::startSpectator() [Data_T = CLCatherineData]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return [*(id *)(*(void *)(a1 + 136) + 16) register:*(void *)(*(void *)(a1 + 136) + 8) forNotification:0 registrationInfo:0];
}

id sub_100E2138C(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  unint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Stop spectator for src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Stop spectator for src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieSourceFromNotifier<CLCatherineData>::stopSpectator() [Data_T = CLCatherineData]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return [*(id *)(*(void *)(a1 + 136) + 16) unregister:*(void *)(*(void *)(a1 + 136) + 8) forNotification:0];
}

uint64_t sub_100E2154C(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 <= 1u) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 32LL))(result, a4);
  }
  return result;
}

void sub_100E2156C(void **a1)
{
  *a1 = off_101885DF0;
  free(a1[1]);
  sub_1002D62D8(a1 + 3);
  operator delete(a1);
}

void *sub_100E215AC(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    uint64_t v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)__int128 buf = 134218752;
      double v34 = v7 - v4;
      __int16 v35 = 2048;
      double v36 = v4;
      __int16 v37 = 2048;
      double v38 = v7;
      __int16 v39 = 1024;
      int v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v20 = *(double *)(a1 + 104);
      int v21 = *(unsigned __int8 *)(a1 + 121);
      int v25 = 134218752;
      double v26 = v20 - v4;
      __int16 v27 = 2048;
      double v28 = v4;
      __int16 v29 = 2048;
      double v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      LODWORD(v24) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  COERCE_DOUBLE(&v25),  v24);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInput<CLRawHR>::update(CFAbsoluteTime) [Data_T = CLRawHR]",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

  if (*(_BYTE *)(a1 + 80)
    && !*(_BYTE *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(_BYTE *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1))
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0LL;
  }

  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  uint64_t v12 = (char *)(v10 + 8 * (v9 >> 7));
  if (v11 == v10) {
    uint64_t v13 = 0LL;
  }
  else {
    uint64_t v13 = *(void *)v12 + 32 * (*(void *)(a1 + 56) & 0x7FLL);
  }
  uint64_t v14 = v10 + 8 * (v9 >> 7);
LABEL_15:
  uint64_t v15 = (double *)v13;
  while (1)
  {
    uint64_t v16 = v11 == v10
        ? 0LL
        : *(void *)(v10 + (((*(void *)(a1 + 64) + v9) >> 4) & 0xFFFFFFFFFFFFFF8LL))
        + 32 * ((*(void *)(a1 + 64) + v9) & 0x7F);
    v15 += 4;
    v13 += 32LL;
    if (*(void *)v14 + 4096LL == v13)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      v14 += 8LL;
      uint64_t v13 = v17;
      goto LABEL_15;
    }
  }

  if (v11 == v10) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = *(void *)v12 + 32 * (*(void *)(a1 + 56) & 0x7FLL);
  }
  return sub_10079DD74((void *)(a1 + 24), v12, v18, (char *)v14, v13);
}

void *sub_100E218E8(void *a1, const char *a2, void *a3, int a4, double a5, double a6, double a7)
{
  *(void *)sub_100E219D0((uint64_t)a1, a2, a4, a5, a6, a7) = off_101885EB0;
  a1[16] = [a3 silo];
  a1[17] = 0LL;
  sub_101037234((uint64_t)sub_100E21A90, (uint64_t)a1, a3, &v13);
  uint64_t v9 = v13;
  uint64_t v13 = 0LL;
  uint64_t v10 = a1[17];
  a1[17] = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    uint64_t v11 = v13;
    uint64_t v13 = 0LL;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
  }

  (*(void (**)(void *))(*a1 + 80LL))(a1);
  return a1;
}

void sub_100E21998(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 136);
  *(void *)(v1 + 136) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_100E21AE0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E219D0(uint64_t a1, const char *a2, int a3, double a4, double a5, double a6)
{
  *(void *)a1 = off_101885FD8;
  if (a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = "NatalieInputSrc";
  }
  uint64_t v12 = strdup(v11);
  *(double *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_101885F68;
  *(void *)(a1 + 8) = v12;
  *(void *)(a1 + 72) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0LL;
  *(double *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  *(double *)(a1 + 112) = a6;
  *(_BYTE *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 121) = a3;
  if (a3)
  {
    *(void *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
    *(void *)(a1 + 88) = 0x7FEFFFFFFFFFFFFFLL;
  }

  return a1;
}

uint64_t sub_100E21A90(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  return (*((uint64_t (**)(id *, uint64_t, uint64_t, uint64_t))*a4 + 12))(a4, a1, a2, a3);
}

uint64_t sub_100E21AE0(uint64_t a1)
{
  *(void *)a1 = off_101885FD8;
  free(*(void **)(a1 + 8));
  sub_10046CA00((void *)(a1 + 24));
  return a1;
}

void sub_100E21B20(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E24700(a1);
  operator delete(v1);
}

BOOL sub_100E21B34(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  unint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = (void *)(v5 + 8 * (v4 / 0x17));
  if (*(void *)(a1 + 40) == v5) {
    unint64_t v7 = 0LL;
  }
  else {
    unint64_t v7 = *v6 + 176 * (v4 % 0x17);
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = v6;
  a3[3] = v7;
  __int128 v8 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v8;
  unint64_t v9 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = (uint64_t *)(v10 + 8 * (v9 / 0x17));
  if (*(void *)(a1 + 40) == v10) {
    unint64_t v12 = 0LL;
  }
  else {
    unint64_t v12 = *v11 + 176 * (v9 % 0x17);
  }
  uint64_t v13 = a3[3];
  if (v12 != v13)
  {
    uint64_t v14 = *v11;
    double v15 = 1.79769313e308;
    unint64_t v16 = v12;
    uint64_t v17 = v11;
    while (1)
    {
      uint64_t v18 = v16;
      if (v16 == v14) {
        uint64_t v18 = *(v17 - 1) + 4048;
      }
      double v19 = vabdd_f64(*(double *)(v18 - 168), a4);
      if (v19 < v15 && v19 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v11;
        *(void *)(a2 + 8) = v12;
        *(void *)(a2 + 16) = v17;
        *(void *)(a2 + 24) = v16;
        uint64_t v14 = *v17;
        uint64_t v20 = v16;
        if (v16 == *v17) {
          uint64_t v20 = *(v17 - 1) + 4048;
        }
        double v15 = v19;
      }

      if (v16 == v14)
      {
        uint64_t v21 = *--v17;
        uint64_t v14 = v21;
        unint64_t v16 = v21 + 4048;
      }

      v16 -= 176LL;
      uint64_t v13 = a3[3];
      if (v16 == v13) {
        return v13 != *(void *)(a2 + 24);
      }
    }

    uint64_t v13 = a3[3];
  }

  return v13 != *(void *)(a2 + 24);
}

uint64_t sub_100E21C90(uint64_t a1, _OWORD *a2)
{
  a2[9] = 0u;
  a2[10] = 0u;
  a2[7] = 0u;
  a2[8] = 0u;
  a2[5] = 0u;
  a2[6] = 0u;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, __int128 *, __int128 *))(*(void *)a1 + 16LL))(a1, &v15, &v13);
  if ((_DWORD)result)
  {
    uint64_t v4 = *((void *)&v16 + 1);
    if (*((void *)&v16 + 1) == *((void *)&v14 + 1))
    {
      return 0LL;
    }

    else
    {
      if (*(void *)v16 == *((void *)&v16 + 1)) {
        uint64_t v4 = *(void *)(v16 - 8) + 4048LL;
      }
      __int128 v5 = *(_OWORD *)(v4 - 176);
      __int128 v6 = *(_OWORD *)(v4 - 144);
      a2[1] = *(_OWORD *)(v4 - 160);
      a2[2] = v6;
      *a2 = v5;
      __int128 v7 = *(_OWORD *)(v4 - 128);
      __int128 v8 = *(_OWORD *)(v4 - 112);
      __int128 v9 = *(_OWORD *)(v4 - 80);
      a2[5] = *(_OWORD *)(v4 - 96);
      a2[6] = v9;
      a2[3] = v7;
      a2[4] = v8;
      __int128 v10 = *(_OWORD *)(v4 - 64);
      __int128 v11 = *(_OWORD *)(v4 - 48);
      __int128 v12 = *(_OWORD *)(v4 - 16);
      a2[9] = *(_OWORD *)(v4 - 32);
      a2[10] = v12;
      a2[7] = v10;
      a2[8] = v11;
      return 1LL;
    }
  }

  return result;
}

double sub_100E21D54(uint64_t a1, __int128 *a2)
{
  *(void *)&double result = sub_10046CDA4((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

unint64_t sub_100E21D5C(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    __int128 v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)__int128 buf = 134218752;
      double v34 = v7 - v4;
      __int16 v35 = 2048;
      double v36 = v4;
      __int16 v37 = 2048;
      double v38 = v7;
      __int16 v39 = 1024;
      int v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v20 = *(double *)(a1 + 104);
      int v21 = *(unsigned __int8 *)(a1 + 121);
      int v25 = 134218752;
      double v26 = v20 - v4;
      __int16 v27 = 2048;
      double v28 = v4;
      __int16 v29 = 2048;
      double v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      LODWORD(v24) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  COERCE_DOUBLE(&v25),  v24);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInput<CLStepCountEntry>::update(CFAbsoluteTime) [Data_T = CLStepCountEntry]",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

  if (*(_BYTE *)(a1 + 80)
    && !*(_BYTE *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(_BYTE *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1))
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0LL;
  }

  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  __int128 v12 = (void *)(v10 + 8 * (v9 / 0x17));
  if (v11 == v10) {
    __int128 v13 = 0LL;
  }
  else {
    __int128 v13 = (char *)(*v12 + 176 * (v9 % 0x17));
  }
  __int128 v14 = (void *)(v10 + 8 * (v9 / 0x17));
LABEL_15:
  __int128 v15 = v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0LL
        : *(void *)(v10 + 8 * ((*(void *)(a1 + 64) + v9) / 0x17)) + 176 * ((*(void *)(a1 + 64) + v9) % 0x17);
    v13 += 176;
    v15 += 176;
    if ((char *)(*v14 + 4048LL) == v13)
    {
      uint64_t v17 = (char *)v14[1];
      ++v14;
      __int128 v13 = v17;
      goto LABEL_15;
    }
  }

  if (v11 == v10) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = (char *)(*v12 + 176 * (v9 % 0x17));
  }
  return sub_100CE4DA0((void *)(a1 + 24), v12, v18, v14, v13);
}

BOOL sub_100E220D4(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    double v5 = *(double *)(*(void *)(*(void *)(a1 + 32) + 8 * ((v4 + *(void *)(a1 + 56) - 1) / 0x17uLL))
  }
                   + 176 * ((v4 + *(void *)(a1 + 56) - 1) % 0x17uLL)
                   + 8);
  else {
    double v5 = -1.79769313e308;
  }
  if (v5 >= a2)
  {
    __int128 v6 = (_BYTE *)(a1 + 80);
    goto LABEL_11;
  }

  __int128 v6 = (_BYTE *)(a1 + 80);
  if (*(_BYTE *)(a1 + 80))
  {
    double v7 = *(double *)(a1 + 16);
    if (*(double *)(a1 + 72) - v7 < a2 && v7 + *(double *)(a1 + 88) > a2)
    {
      double v8 = *(double *)(a1 + 104);
    }

id sub_100E22218(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  unint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Start spectator for src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Start spectator for src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieSourceFromNotifier<CLStepCountEntry>::startSpectator() [Data_T = CLStepCountEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return [*(id *)(*(void *)(a1 + 136) + 16) register:*(void *)(*(void *)(a1 + 136) + 8) forNotification:0 registrationInfo:0];
}

id sub_100E223DC(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  unint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Stop spectator for src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Stop spectator for src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieSourceFromNotifier<CLStepCountEntry>::stopSpectator() [Data_T = CLStepCountEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return [*(id *)(*(void *)(a1 + 136) + 16) unregister:*(void *)(*(void *)(a1 + 136) + 8) forNotification:0];
}

uint64_t sub_100E2259C(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  return result;
}

void sub_100E225C0(void **a1)
{
  *a1 = off_101885FD8;
  free(a1[1]);
  sub_10046CA00(a1 + 3);
  operator delete(a1);
}

void *sub_100E22600(void *a1, const char *a2, void *a3, int a4, double a5, double a6, double a7)
{
  *(void *)sub_100E226E8((uint64_t)a1, a2, a4, a5, a6, a7) = off_101886010;
  a1[16] = [a3 silo];
  a1[17] = 0LL;
  sub_101041EA0((uint64_t)sub_100E227A8, (uint64_t)a1, a3, &v13);
  uint64_t v9 = v13;
  uint64_t v13 = 0LL;
  uint64_t v10 = a1[17];
  a1[17] = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    uint64_t v11 = v13;
    uint64_t v13 = 0LL;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
  }

  (*(void (**)(void *))(*a1 + 80LL))(a1);
  return a1;
}

void sub_100E226B0(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 136);
  *(void *)(v1 + 136) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_100E227F8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E226E8(uint64_t a1, const char *a2, int a3, double a4, double a5, double a6)
{
  *(void *)a1 = off_101886138;
  if (a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = "NatalieInputSrc";
  }
  __int128 v12 = strdup(v11);
  *(double *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_1018860C8;
  *(void *)(a1 + 8) = v12;
  *(void *)(a1 + 72) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0LL;
  *(double *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  *(double *)(a1 + 112) = a6;
  *(_BYTE *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 121) = a3;
  if (a3)
  {
    *(void *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
    *(void *)(a1 + 88) = 0x7FEFFFFFFFFFFFFFLL;
  }

  return a1;
}

uint64_t sub_100E227A8(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  return (*((uint64_t (**)(id *, uint64_t, uint64_t, uint64_t))*a4 + 12))(a4, a1, a2, a3);
}

uint64_t sub_100E227F8(uint64_t a1)
{
  *(void *)a1 = off_101886138;
  free(*(void **)(a1 + 8));
  sub_100210A94((void *)(a1 + 24));
  return a1;
}

void sub_100E22838(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E24768(a1);
  operator delete(v1);
}

BOOL sub_100E2284C(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  unint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  __int128 v6 = (void *)(v5 + 8 * (v4 / 0x1A));
  if (*(void *)(a1 + 40) == v5) {
    unint64_t v7 = 0LL;
  }
  else {
    unint64_t v7 = *v6 + 152 * (v4 % 0x1A);
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = v6;
  a3[3] = v7;
  __int128 v8 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v8;
  unint64_t v9 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = (uint64_t *)(v10 + 8 * (v9 / 0x1A));
  if (*(void *)(a1 + 40) == v10) {
    unint64_t v12 = 0LL;
  }
  else {
    unint64_t v12 = *v11 + 152 * (v9 % 0x1A);
  }
  uint64_t v13 = a3[3];
  if (v12 != v13)
  {
    uint64_t v14 = *v11;
    double v15 = 1.79769313e308;
    unint64_t v16 = v12;
    uint64_t v17 = v11;
    while (1)
    {
      uint64_t v18 = v16;
      if (v16 == v14) {
        uint64_t v18 = *(v17 - 1) + 3952;
      }
      double v19 = vabdd_f64(*(double *)(v18 - 112), a4);
      if (v19 < v15 && v19 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v11;
        *(void *)(a2 + 8) = v12;
        *(void *)(a2 + 16) = v17;
        *(void *)(a2 + 24) = v16;
        uint64_t v14 = *v17;
        uint64_t v20 = v16;
        if (v16 == *v17) {
          uint64_t v20 = *(v17 - 1) + 3952;
        }
        double v15 = v19;
      }

      if (v16 == v14)
      {
        uint64_t v21 = *--v17;
        uint64_t v14 = v21;
        unint64_t v16 = v21 + 3952;
      }

      v16 -= 152LL;
      uint64_t v13 = a3[3];
      if (v16 == v13) {
        return v13 != *(void *)(a2 + 24);
      }
    }

    uint64_t v13 = a3[3];
  }

  return v13 != *(void *)(a2 + 24);
}

uint64_t sub_100E22998(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 144) = 0LL;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, __int128 *, __int128 *))(*(void *)a1 + 16LL))(a1, &v14, &v12);
  if ((_DWORD)result)
  {
    uint64_t v4 = *((void *)&v15 + 1);
    if (*((void *)&v15 + 1) == *((void *)&v13 + 1))
    {
      return 0LL;
    }

    else
    {
      if (*(void *)v15 == *((void *)&v15 + 1)) {
        uint64_t v4 = *(void *)(v15 - 8) + 3952LL;
      }
      __int128 v5 = *(_OWORD *)(v4 - 136);
      *(_OWORD *)a2 = *(_OWORD *)(v4 - 152);
      *(_OWORD *)(a2 + 16) = v5;
      __int128 v6 = *(_OWORD *)(v4 - 120);
      __int128 v7 = *(_OWORD *)(v4 - 104);
      __int128 v8 = *(_OWORD *)(v4 - 72);
      *(_OWORD *)(a2 + 64) = *(_OWORD *)(v4 - 88);
      *(_OWORD *)(a2 + 80) = v8;
      *(_OWORD *)(a2 + 32) = v6;
      *(_OWORD *)(a2 + 48) = v7;
      __int128 v9 = *(_OWORD *)(v4 - 56);
      __int128 v10 = *(_OWORD *)(v4 - 40);
      __int128 v11 = *(_OWORD *)(v4 - 24);
      *(void *)(a2 + 144) = *(void *)(v4 - 8);
      *(_OWORD *)(a2 + 112) = v10;
      *(_OWORD *)(a2 + 128) = v11;
      *(_OWORD *)(a2 + 96) = v9;
      return 1LL;
    }
  }

  return result;
}

double sub_100E22A6C(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = sub_10020FFB4((void *)(a1 + 24), a2).n128_u64[0];
  return result;
}

unint64_t sub_100E22A74(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    __int128 v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)__int128 buf = 134218752;
      double v34 = v7 - v4;
      __int16 v35 = 2048;
      double v36 = v4;
      __int16 v37 = 2048;
      double v38 = v7;
      __int16 v39 = 1024;
      int v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v20 = *(double *)(a1 + 104);
      int v21 = *(unsigned __int8 *)(a1 + 121);
      int v25 = 134218752;
      double v26 = v20 - v4;
      __int16 v27 = 2048;
      double v28 = v4;
      __int16 v29 = 2048;
      double v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      LODWORD(v24) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  COERCE_DOUBLE(&v25),  v24);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInput<CLSwimEntry>::update(CFAbsoluteTime) [Data_T = CLSwimEntry]",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

  if (*(_BYTE *)(a1 + 80)
    && !*(_BYTE *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(_BYTE *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1))
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0LL;
  }

  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  __int128 v12 = (void *)(v10 + 8 * (v9 / 0x1A));
  if (v11 == v10) {
    __int128 v13 = 0LL;
  }
  else {
    __int128 v13 = (char *)(*v12 + 152 * (v9 % 0x1A));
  }
  __int128 v14 = (void *)(v10 + 8 * (v9 / 0x1A));
LABEL_15:
  __int128 v15 = v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0LL
        : *(void *)(v10 + 8 * ((*(void *)(a1 + 64) + v9) / 0x1A)) + 152 * ((*(void *)(a1 + 64) + v9) % 0x1A);
    v13 += 152;
    v15 += 152;
    if ((char *)(*v14 + 3952LL) == v13)
    {
      uint64_t v17 = (char *)v14[1];
      ++v14;
      __int128 v13 = v17;
      goto LABEL_15;
    }
  }

  if (v11 == v10) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = (char *)(*v12 + 152 * (v9 % 0x1A));
  }
  return sub_10020CA7C((void *)(a1 + 24), v12, v18, v14, v13);
}

BOOL sub_100E22DDC(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
    double v5 = *(double *)(*(void *)(*(void *)(a1 + 32) + 8 * ((v4 + *(void *)(a1 + 56) - 1) / 0x1AuLL))
  }
                   + 152 * ((v4 + *(void *)(a1 + 56) - 1) % 0x1AuLL)
                   + 40);
  else {
    double v5 = -1.79769313e308;
  }
  if (v5 >= a2)
  {
    __int128 v6 = (_BYTE *)(a1 + 80);
    goto LABEL_11;
  }

  __int128 v6 = (_BYTE *)(a1 + 80);
  if (*(_BYTE *)(a1 + 80))
  {
    double v7 = *(double *)(a1 + 16);
    if (*(double *)(a1 + 72) - v7 < a2 && v7 + *(double *)(a1 + 88) > a2)
    {
      double v8 = *(double *)(a1 + 104);
    }

uint64_t sub_100E22F18(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  unint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Activate src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Activate src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieSourceFromNotifier<CLSwimEntry>::startActive() [Data_T = CLSwimEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  [*(id *)(*(void *)(a1 + 136) + 16) register:*(void *)(*(void *)(a1 + 136) + 8) forNotification:0 registrationInfo:0];
  return 1LL;
}

uint64_t sub_100E230E0(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  unint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Inactivate src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Inactivate src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieSourceFromNotifier<CLSwimEntry>::stopActive() [Data_T = CLSwimEntry]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  [*(id *)(*(void *)(a1 + 136) + 16) unregister:*(void *)(*(void *)(a1 + 136) + 8) forNotification:0];
  return 1LL;
}

void sub_100E232A4(void **a1)
{
  *a1 = off_101886138;
  free(a1[1]);
  sub_100210A94(a1 + 3);
  operator delete(a1);
}

void *sub_100E232E4(void *a1, const char *a2, void *a3, int a4, double a5, double a6, double a7)
{
  *(void *)sub_100E233CC((uint64_t)a1, a2, a4, a5, a6, a7) = off_101886170;
  a1[16] = [a3 silo];
  a1[17] = 0LL;
  sub_100D3BE3C((uint64_t)sub_100E2348C, (uint64_t)a1, a3, &v13);
  uint64_t v9 = v13;
  uint64_t v13 = 0LL;
  uint64_t v10 = a1[17];
  a1[17] = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    uint64_t v11 = v13;
    uint64_t v13 = 0LL;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
  }

  (*(void (**)(void *))(*a1 + 80LL))(a1);
  return a1;
}

void sub_100E23394(_Unwind_Exception *a1)
{
  uint64_t v3 = *(void *)(v1 + 136);
  *(void *)(v1 + 136) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_100E234DC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E233CC(uint64_t a1, const char *a2, int a3, double a4, double a5, double a6)
{
  *(void *)a1 = off_101886298;
  if (a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = "NatalieInputSrc";
  }
  __int128 v12 = strdup(v11);
  *(double *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)a1 = off_101886228;
  *(void *)(a1 + 8) = v12;
  *(void *)(a1 + 72) = 0x7FEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0LL;
  *(double *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = 0LL;
  *(double *)(a1 + 112) = a6;
  *(_BYTE *)(a1 + 120) = 0;
  *(_BYTE *)(a1 + 121) = a3;
  if (a3)
  {
    *(void *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
    *(void *)(a1 + 88) = 0x7FEFFFFFFFFFFFFFLL;
  }

  return a1;
}

uint64_t sub_100E2348C(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  return (*((uint64_t (**)(id *, uint64_t, uint64_t, uint64_t))*a4 + 12))(a4, a1, a2, a3);
}

uint64_t sub_100E234DC(uint64_t a1)
{
  *(void *)a1 = off_101886298;
  free(*(void **)(a1 + 8));
  sub_1002C5F18((void *)(a1 + 24));
  return a1;
}

void sub_100E2351C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E247D0(a1);
  operator delete(v1);
}

BOOL sub_100E23530(uint64_t a1, uint64_t a2, void *a3, double a4)
{
  unint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  __int128 v6 = (void *)(v5 + 8 * (v4 / 0x18));
  if (*(void *)(a1 + 40) == v5) {
    unint64_t v7 = 0LL;
  }
  else {
    unint64_t v7 = *v6 + 168 * (v4 % 0x18);
  }
  *a3 = v6;
  a3[1] = v7;
  a3[2] = v6;
  a3[3] = v7;
  __int128 v8 = *((_OWORD *)a3 + 1);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v8;
  unint64_t v9 = *(void *)(a1 + 56) + *(void *)(a1 + 64);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = (uint64_t *)(v10 + 8 * (v9 / 0x18));
  if (*(void *)(a1 + 40) == v10) {
    unint64_t v12 = 0LL;
  }
  else {
    unint64_t v12 = *v11 + 168 * (v9 % 0x18);
  }
  uint64_t v13 = a3[3];
  if (v12 != v13)
  {
    uint64_t v14 = *v11;
    double v15 = 1.79769313e308;
    unint64_t v16 = v12;
    uint64_t v17 = v11;
    while (1)
    {
      uint64_t v18 = v16;
      if (v16 == v14) {
        uint64_t v18 = *(v17 - 1) + 4032;
      }
      double v19 = vabdd_f64(*(double *)(v18 - 168), a4);
      if (v19 < v15 && v19 < *(double *)(a1 + 16))
      {
        *(void *)a2 = v11;
        *(void *)(a2 + 8) = v12;
        *(void *)(a2 + 16) = v17;
        *(void *)(a2 + 24) = v16;
        uint64_t v14 = *v17;
        uint64_t v20 = v16;
        if (v16 == *v17) {
          uint64_t v20 = *(v17 - 1) + 4032;
        }
        double v15 = v19;
      }

      if (v16 == v14)
      {
        uint64_t v21 = *--v17;
        uint64_t v14 = v21;
        unint64_t v16 = v21 + 4032;
      }

      v16 -= 168LL;
      uint64_t v13 = a3[3];
      if (v16 == v13) {
        return v13 != *(void *)(a2 + 24);
      }
    }

    uint64_t v13 = a3[3];
  }

  return v13 != *(void *)(a2 + 24);
}

uint64_t sub_100E23674(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 160) = 0LL;
  *(_OWORD *)(a2 + 128) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  uint64_t result = (*(uint64_t (**)(uint64_t, __int128 *, __int128 *))(*(void *)a1 + 16LL))(a1, &v15, &v13);
  if ((_DWORD)result)
  {
    uint64_t v4 = *((void *)&v16 + 1);
    if (*((void *)&v16 + 1) == *((void *)&v14 + 1))
    {
      return 0LL;
    }

    else
    {
      if (*(void *)v16 == *((void *)&v16 + 1)) {
        uint64_t v4 = *(void *)(v16 - 8) + 4032LL;
      }
      __int128 v5 = *(_OWORD *)(v4 - 168);
      __int128 v6 = *(_OWORD *)(v4 - 136);
      *(_OWORD *)(a2 + 16) = *(_OWORD *)(v4 - 152);
      *(_OWORD *)(a2 + 32) = v6;
      *(_OWORD *)a2 = v5;
      __int128 v7 = *(_OWORD *)(v4 - 120);
      __int128 v8 = *(_OWORD *)(v4 - 104);
      __int128 v9 = *(_OWORD *)(v4 - 72);
      *(_OWORD *)(a2 + 80) = *(_OWORD *)(v4 - 88);
      *(_OWORD *)(a2 + 96) = v9;
      *(_OWORD *)(a2 + 48) = v7;
      *(_OWORD *)(a2 + 64) = v8;
      __int128 v10 = *(_OWORD *)(v4 - 56);
      __int128 v11 = *(_OWORD *)(v4 - 40);
      __int128 v12 = *(_OWORD *)(v4 - 24);
      *(void *)(a2 + 160) = *(void *)(v4 - 8);
      *(_OWORD *)(a2 + 128) = v11;
      *(_OWORD *)(a2 + 144) = v12;
      *(_OWORD *)(a2 + 112) = v10;
      return 1LL;
    }
  }

  return result;
}

unint64_t sub_100E23750(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 104);
  *(double *)(a1 + 104) = a2;
  BOOL v5 = a2 > 0.0;
  if (v4 <= a2) {
    BOOL v5 = 0;
  }
  *(_BYTE *)(a1 + 120) = v5;
  if (v5)
  {
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101884E60);
    }
    __int128 v6 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
    {
      double v7 = *(double *)(a1 + 104);
      int v8 = *(unsigned __int8 *)(a1 + 121);
      *(_DWORD *)__int128 buf = 134218752;
      double v34 = v7 - v4;
      __int16 v35 = 2048;
      double v36 = v4;
      __int16 v37 = 2048;
      double v38 = v7;
      __int16 v39 = 1024;
      int v40 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  buf,  0x26u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_101884E60);
      }
      double v20 = *(double *)(a1 + 104);
      int v21 = *(unsigned __int8 *)(a1 + 121);
      int v25 = 134218752;
      double v26 = v20 - v4;
      __int16 v27 = 2048;
      double v28 = v4;
      __int16 v29 = 2048;
      double v30 = v20;
      __int16 v31 = 1024;
      int v32 = v21;
      LODWORD(v24) = 38;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  0LL,  "#Warning Input, time rolled back. Delta %f, Previous Time %f, Current Time %f, Always Active %d.",  COERCE_DOUBLE(&v25),  v24);
      uint64_t v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNatalieInput<_CLFitnessMachineData>::update(CFAbsoluteTime) [Data_T = _CLFitnessMachineData]",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

  if (*(_BYTE *)(a1 + 80)
    && !*(_BYTE *)(a1 + 121)
    && (*(double *)(a1 + 88) < a2 || *(_BYTE *)(a1 + 120))
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 72LL))(a1))
  {
    *(_BYTE *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0LL;
  }

  unint64_t v9 = *(void *)(a1 + 56);
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 40);
  __int128 v12 = (void *)(v10 + 8 * (v9 / 0x18));
  if (v11 == v10) {
    __int128 v13 = 0LL;
  }
  else {
    __int128 v13 = (char *)(*v12 + 168 * (v9 % 0x18));
  }
  __int128 v14 = (void *)(v10 + 8 * (v9 / 0x18));
LABEL_15:
  __int128 v15 = (double *)v13;
  while (1)
  {
    unint64_t v16 = v11 == v10
        ? 0LL
        : *(void *)(v10 + 8 * ((*(void *)(a1 + 64) + v9) / 0x18)) + 168 * ((*(void *)(a1 + 64) + v9) % 0x18);
    v15 += 21;
    v13 += 168;
    if ((char *)(*v14 + 4032LL) == v13)
    {
      uint64_t v17 = (char *)v14[1];
      ++v14;
      __int128 v13 = v17;
      goto LABEL_15;
    }
  }

  if (v11 == v10) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = (char *)(*v12 + 168 * (v9 % 0x18));
  }
  return sub_100E23FB0((void *)(a1 + 24), v12, v18, v14, v13);
}

BOOL sub_100E23AB0(uint64_t a1, double a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4) {
  else
  }
    double v5 = -1.79769313e308;
  if (v5 >= a2)
  {
    __int128 v6 = (_BYTE *)(a1 + 80);
    goto LABEL_11;
  }

  __int128 v6 = (_BYTE *)(a1 + 80);
  if (*(_BYTE *)(a1 + 80))
  {
    double v7 = *(double *)(a1 + 16);
    if (*(double *)(a1 + 72) - v7 < a2 && v7 + *(double *)(a1 + 88) > a2)
    {
      double v8 = *(double *)(a1 + 104);
    }

uint64_t sub_100E23BE4(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  unint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Activate src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Activate src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieSourceFromNotifier<_CLFitnessMachineData>::startActive() [Data_T = _CLFitnessMachineData]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  [*(id *)(*(void *)(a1 + 136) + 16) register:*(void *)(*(void *)(a1 + 136) + 8) forNotification:0 registrationInfo:0];
  return 1LL;
}

uint64_t sub_100E23DAC(uint64_t a1)
{
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101885A60);
  }
  unint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v11 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Inactivate src %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101885A60);
    }
    uint64_t v5 = *(void *)(a1 + 8);
    int v8 = 136315138;
    uint64_t v9 = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Inactivate src %s",  (const char *)&v8);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLNatalieSourceFromNotifier<_CLFitnessMachineData>::stopActive() [Data_T = _CLFitnessMachineData]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  [*(id *)(*(void *)(a1 + 136) + 16) unregister:*(void *)(*(void *)(a1 + 136) + 8) forNotification:0];
  return 1LL;
}

void sub_100E23F70(void **a1)
{
  *a1 = off_101886298;
  free(a1[1]);
  sub_1002C5F18(a1 + 3);
  operator delete(a1);
}

unint64_t sub_100E23FB0(void *a1, void *a2, char *a3, void *a4, char *a5)
{
  if (a5 == a3) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = 24 * (a4 - a2)
  }
  unint64_t v7 = a1[4];
  uint64_t v8 = a1[1];
  uint64_t v9 = (char **)(v8 + 8 * (v7 / 0x18));
  if (a1[2] == v8) {
    uint64_t v10 = 0LL;
  }
  else {
    uint64_t v10 = &(*v9)[168 * (v7 % 0x18)];
  }
  if (a3 == v10) {
    unint64_t v11 = 0LL;
  }
  else {
    unint64_t v11 = 24 * ((char **)a2 - v9)
  }
  v24[0].n128_u64[0] = v8 + 8 * (v7 / 0x18);
  v24[0].n128_u64[1] = (unint64_t)v10;
  sub_10046F180(v24, v11);
  if (v6 >= 1)
  {
    __n128 v12 = v24[0];
    if (v11 <= (unint64_t)(a1[5] - v6) >> 1)
    {
      sub_10046F180(v24, v6);
      sub_100E24240( v9,  v10,  (char **)v12.n128_u64[0],  (char *)v12.n128_u64[1],  v24[0].n128_u64[0],  (char *)v24[0].n128_u64[1],  v24);
      uint64_t v18 = a1[5] - v6;
      a1[4] += v6;
      a1[5] = v18;
    }

    else
    {
      sub_10046F180(v24, v6);
      __n128 v13 = v24[0];
      unint64_t v14 = a1[4] + a1[5];
      uint64_t v15 = a1[1];
      unint64_t v16 = (_BYTE **)(v15 + 8 * (v14 / 0x18));
      if (a1[2] == v15) {
        uint64_t v17 = 0LL;
      }
      else {
        uint64_t v17 = &(*v16)[168 * (v14 % 0x18)];
      }
      v24[0] = v12;
      sub_10046FC90(v13.n128_u64[0], (_BYTE *)v13.n128_u64[1], v16, v17, (uint64_t)v24);
      a1[5] -= v6;
      while ((sub_10046FE0C(a1, 1) & 1) != 0)
        ;
    }
  }

  unint64_t v19 = a1[4];
  uint64_t v20 = a1[1];
  int v21 = (void *)(v20 + 8 * (v19 / 0x18));
  if (a1[2] == v20) {
    unint64_t v22 = 0LL;
  }
  else {
    unint64_t v22 = *v21 + 168 * (v19 % 0x18);
  }
  v24[0].n128_u64[0] = (unint64_t)v21;
  v24[0].n128_u64[1] = v22;
  sub_10046F180(v24, v11);
  return v24[0].n128_u64[0];
}

__n128 sub_100E24240@<Q0>( char **a1@<X1>, char *a2@<X2>, char **a3@<X3>, char *a4@<X4>, void *a5@<X5>, char *a6@<X6>, __n128 *a7@<X8>)
{
  if (a1 == a3)
  {
    unint64_t v19 = a2;
    uint64_t v18 = a4;
    uint64_t v15 = a5;
    unint64_t v16 = a6;
  }

  else
  {
    __n128 v13 = a3 - 1;
    __n128 v12 = *a3;
    unint64_t v14 = a4;
    uint64_t v15 = a5;
    unint64_t v16 = a6;
    while (1)
    {
      sub_100E2430C(v12, v14, v15, v16, &v21);
      unint64_t v16 = (char *)v22.n128_u64[1];
      uint64_t v15 = (void *)v22.n128_u64[0];
      if (v13 == a1) {
        break;
      }
      uint64_t v17 = *v13--;
      __n128 v12 = v17;
      unint64_t v14 = v17 + 4032;
    }

    uint64_t v18 = *a1 + 4032;
    unint64_t v19 = a2;
  }

  sub_100E2430C(v19, v18, v15, v16, &v21);
  __n128 result = v22;
  a7->n128_u64[0] = (unint64_t)a3;
  a7->n128_u64[1] = (unint64_t)a4;
  a7[1] = result;
  return result;
}

void *sub_100E2430C@<X0>(char *a1@<X1>, char *a2@<X2>, void *a3@<X3>, char *a4@<X4>, void *a5@<X8>)
{
  uint64_t v6 = a3;
  if (a1 == a2)
  {
    uint64_t v9 = a1;
  }

  else
  {
    uint64_t v9 = a2;
    uint64_t v10 = *a3;
    unint64_t v11 = a2;
    while (1)
    {
      int64_t v12 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)&a4[-v10] >> 3);
      v11 -= 168 * v12;
      a4 -= 168 * v12;
      if (v12) {
        __n128 result = memmove(a4, v11, 168 * v12);
      }
      if (v11 == a1) {
        break;
      }
      uint64_t v14 = *--v6;
      uint64_t v10 = v14;
      a4 = (char *)(v14 + 4032);
    }

    if ((char *)(*v6 + 4032LL) == a4)
    {
      uint64_t v15 = (char *)v6[1];
      ++v6;
      a4 = v15;
    }
  }

  *a5 = v9;
  a5[1] = v6;
  a5[2] = a4;
  return result;
}

void *sub_100E243EC(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &off_1018862D0;
  v4[1] = 0LL;
  v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100E24434(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2444C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t sub_100E2445C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *sub_100E2449C(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &off_101886348;
  result[1] = v3;
  return result;
}

uint64_t sub_100E244D4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_101886348;
  a2[1] = v2;
  return result;
}

void sub_100E244F4(uint64_t a1, unsigned __int8 *a2)
{
}

uint64_t sub_100E24500(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E2453C()
{
  return &off_1018863A8;
}

uint64_t sub_100E24548(uint64_t a1)
{
  *(void *)a1 = off_1018859E0;
  uint64_t v2 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *(void *)a1 = &off_101859FE8;
  free(*(void **)(a1 + 8));
  sub_10046D318((void *)(a1 + 24));
  return a1;
}

uint64_t sub_100E245B0(uint64_t a1)
{
  *(void *)a1 = off_101885A90;
  uint64_t v2 = *(void *)(a1 + 392);
  *(void *)(a1 + 392) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *(void *)a1 = off_10188EED0;
  sub_10046E138((void *)(a1 + 128));
  *(void *)a1 = off_101885B20;
  free(*(void **)(a1 + 8));
  sub_1002D62D8((void *)(a1 + 24));
  return a1;
}

uint64_t sub_100E24630(uint64_t a1)
{
  *(void *)a1 = off_101885B68;
  uint64_t v2 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *(void *)a1 = off_101885C90;
  free(*(void **)(a1 + 8));
  sub_100231C10((void *)(a1 + 24));
  return a1;
}

uint64_t sub_100E24698(uint64_t a1)
{
  *(void *)a1 = off_101885CC8;
  uint64_t v2 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *(void *)a1 = off_101885DF0;
  free(*(void **)(a1 + 8));
  sub_1002D62D8((void *)(a1 + 24));
  return a1;
}

uint64_t sub_100E24700(uint64_t a1)
{
  *(void *)a1 = off_101885EB0;
  uint64_t v2 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *(void *)a1 = off_101885FD8;
  free(*(void **)(a1 + 8));
  sub_10046CA00((void *)(a1 + 24));
  return a1;
}

uint64_t sub_100E24768(uint64_t a1)
{
  *(void *)a1 = off_101886010;
  uint64_t v2 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *(void *)a1 = off_101886138;
  free(*(void **)(a1 + 8));
  sub_100210A94((void *)(a1 + 24));
  return a1;
}

uint64_t sub_100E247D0(uint64_t a1)
{
  *(void *)a1 = off_101886170;
  uint64_t v2 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *(void *)a1 = off_101886298;
  free(*(void **)(a1 + 8));
  sub_1002C5F18((void *)(a1 + 24));
  return a1;
}

uint64_t sub_100E24838(uint64_t a1, double **a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  double v4 = (*a2)[1];
  double v5 = *(float *)(a1 + 136);
  if (v4 <= v5) {
    double v4 = *(float *)(a1 + 136);
  }
  uint64_t v6 = v3 + 3;
  if (v3 + 3 == v2)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    LODWORD(v7) = 0;
    double v8 = *v3;
    do
    {
      double v9 = *v6;
      double v10 = v6[1];
      v6 += 3;
      uint64_t v7 = (v7 + (int)((v9 - v8) / v4));
      if (v10 <= v5) {
        double v4 = *(float *)(a1 + 136);
      }
      else {
        double v4 = v10;
      }
      double v8 = v9;
    }

    while (v6 != v2);
  }

  if (v4 != 1.79769313e308)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101885670);
    }
    unint64_t v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning No expiration rule was added so the number of records will be unbounded.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101885670);
      }
      v15[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning No expiration rule was added so the number of records will be unbounded.",  v15,  2);
      uint64_t v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLActivityRecorderDb<CLNatalieData>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLNatalieData, D ataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }
  }

  return v7;
}

uint64_t sub_100E24A34(uint64_t a1, double **a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  double v4 = (*a2)[1];
  double v5 = *(float *)(a1 + 136);
  if (v4 <= v5) {
    double v4 = *(float *)(a1 + 136);
  }
  uint64_t v6 = v3 + 3;
  if (v3 + 3 == v2)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    LODWORD(v7) = 0;
    double v8 = *v3;
    do
    {
      double v9 = *v6;
      double v10 = v6[1];
      v6 += 3;
      uint64_t v7 = (v7 + (int)((v9 - v8) / v4));
      if (v10 <= v5) {
        double v4 = *(float *)(a1 + 136);
      }
      else {
        double v4 = v10;
      }
      double v8 = v9;
    }

    while (v6 != v2);
  }

  if (v4 != 1.79769313e308)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101885670);
    }
    unint64_t v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning No expiration rule was added so the number of records will be unbounded.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101885670);
      }
      v15[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning No expiration rule was added so the number of records will be unbounded.",  v15,  2);
      uint64_t v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLActivityRecorderDb<MaxMets, CLActivityDB::ClassBDataProtectionPolicy>::estimateRecordsNeeded(const CLAggre gationRules &) [T = MaxMets, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }
  }

  return v7;
}

uint64_t sub_100E24C30(uint64_t a1, double **a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  double v4 = (*a2)[1];
  double v5 = *(float *)(a1 + 136);
  if (v4 <= v5) {
    double v4 = *(float *)(a1 + 136);
  }
  uint64_t v6 = v3 + 3;
  if (v3 + 3 == v2)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    LODWORD(v7) = 0;
    double v8 = *v3;
    do
    {
      double v9 = *v6;
      double v10 = v6[1];
      v6 += 3;
      uint64_t v7 = (v7 + (int)((v9 - v8) / v4));
      if (v10 <= v5) {
        double v4 = *(float *)(a1 + 136);
      }
      else {
        double v4 = v10;
      }
      double v8 = v9;
    }

    while (v6 != v2);
  }

  if (v4 != 1.79769313e308)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101885670);
    }
    unint64_t v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning No expiration rule was added so the number of records will be unbounded.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101885670);
      }
      v15[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning No expiration rule was added so the number of records will be unbounded.",  v15,  2);
      uint64_t v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLActivityRecorderDb<CLExerciseMinuteData>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLExercis eMinuteData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }
  }

  return v7;
}

CLCppContainer *sub_100E24E2C(const void *a1)
{
  uint64_t v2 = operator new(0x590uLL);
  memcpy(v2, a1, 0x590uLL);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100E253A4;
  v4[3] = &unk_10181D3D0;
  v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  0LL,  1424LL);
}

void sub_100E24EB4(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    double v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      double v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          int64_t v12 = (uint64_t *)v4;
        }
        else {
          int64_t v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          double v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        uint64_t v51 = v9;
        id v13 = sub_100E253B4(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        uint64_t v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          uint64_t v15 = a1 + 11;
          unint64_t v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            unint64_t v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                __n128 v22 = (uint64_t *)v17;
              }
              else {
                __n128 v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                unint64_t v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              uint64_t v50 = v19;
              sub_100E25288(a1, (uint64_t)&v50, (uint64_t)&v51, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              __int16 v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  int v32 = (uint64_t *)v27;
                }
                else {
                  int v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  __int16 v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              uint64_t v51 = v29;
              uint64_t v34 = v29[6];
              uint64_t v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                __int16 v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    __int16 v39 = (uint64_t *)v36;
                  }
                  else {
                    __int16 v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    __int16 v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      uint64_t v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      uint64_t v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      uint64_t v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  int v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      uint64_t v14 = v43;
                      int v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      uint64_t v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      __int16 v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              uint64_t v50 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101884E40);
              }
              double v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)__int128 buf = 136446466;
                int v57 = v25;
                __int16 v58 = 1026;
                int v59 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101884E40);
                }
                uint64_t v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v52 = 136446466;
                int v53 = v45;
                __int16 v54 = 1026;
                int v55 = v46;
                LODWORD(v49) = 18;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                  &v52,
                  v49);
                uint64_t v48 = (uint8_t *)v47;
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLNatalimetryNotifier_Type::Notification, CLNatalimetryNotifier_Type::NotificationData >::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLNatalimetryNoti fier_Type::Notification, NotificationData_T = CLNatalimetryNotifier_Type::NotificationData, Notificati onInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
                if (v48 != buf) {
                  free(v48);
                }
              }
            }
          }

          while (v14 != v51 + 6);
        }
      }
    }
  }

_BYTE *sub_100E25288(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    uint64_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_100E253B4(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40LL);
    uint64_t v14 = (int *)(*(void *)a2 + 32LL);
    int64_t v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    __n128 result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

void sub_100E25364(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1018863C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E25378(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1018863C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_100E253A4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

id sub_100E253B4(void *a1)
{
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_100E25400(a1);
  }
  else {
    return 0LL;
  }
}

id sub_100E25400(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101886408);
    }
    uint64_t v3 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    int v8 = 134218498;
    id v9 = v2;
    __int16 v10 = 2048;
    uint64_t v11 = 0LL;
    __int16 v12 = 2080;
    unint64_t v13 = 0x800000010136056DLL & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v4 = (os_log_s *)v3;
    os_log_type_t v5 = OS_LOG_TYPE_ERROR;
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101886408);
    }
    uint64_t v7 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    int v8 = 134218498;
    id v9 = v2;
    __int16 v10 = 2048;
    uint64_t v11 = 0LL;
    __int16 v12 = 2080;
    unint64_t v13 = 0x800000010136056DLL & 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v4 = (os_log_s *)v7;
    os_log_type_t v5 = OS_LOG_TYPE_FAULT;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v4,  v5,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has cha nged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  (uint8_t *)&v8,  0x20u);
  return 0LL;
}

void sub_100E255D4(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

__n128 sub_100E25600(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100E2568C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  int v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v7 & 0x7F));
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  _OWORD *v8 = *(_OWORD *)a2;
  v8[1] = v10;
  ++a1[5];
  return result;
}

void sub_100E2568C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    int v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    id v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)int v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      BOOL v38 = (uint64_t *)a1[1];
      int v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        int v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        BOOL v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)BOOL v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100E25954( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100E259A0(uint64_t a1, __n128 *a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  *(void *)&v23[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v24 = 256;
  v23[0] = a2->n128_f64[1];
  if (sub_100D8AB44(v6, v23))
  {
    if (sub_100D8A92C(v6))
    {
      (*(void (**)(uint64_t, __n128 *, void))(*(void *)a1 + 80LL))(a1, a2, 0LL);
    }

    else if (!*(_BYTE *)(a1 + 128))
    {
      uint64_t v12 = (void *)(a1 + 176);
      unint64_t v13 = *(void *)(a1 + 216);
      if (v13 > *(int *)(a1 + 248))
      {
        ++*(void *)(a1 + 208);
        *(void *)(a1 + 216) = v13 - 1;
        sub_100211164(a1 + 176, 1);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101885670);
        }
        BOOL v14 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "Maximum number of entries exceeded, throwing out oldest entry.",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_101885670);
          }
          v22[0] = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Maximum number of entries exceeded, throwing out oldest entry.",  v22,  2);
          int64_t v20 = (uint8_t *)v19;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityRecorderDb<CLExerciseMinuteData>::addSuspectRecord(const T &) [T = CLExerciseMinuteData, Data ProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v19);
          if (v20 != buf) {
            free(v20);
          }
        }
      }

      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_101886428);
      }
      uint64_t v15 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Buffer was added to since db was inaccesible.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_101886428);
        }
        v22[0] = 0;
        LODWORD(v21) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Buffer was added to since db was inaccesible.",  v22,  v21);
        uint64_t v18 = (uint8_t *)v17;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityRecorderDb<CLExerciseMinuteData>::addSuspectRecord(const T &) [T = CLExerciseMinuteData, DataPr otectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v17);
        if (v18 != buf) {
          free(v18);
        }
      }

      __n128 v7 = sub_100478594(v12, a2);
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101885670);
    }
    int v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
    {
      id v9 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289538;
      int v26 = 0;
      __int16 v27 = 2082;
      uint64_t v28 = "";
      __int16 v29 = 1026;
      int v30 = (int)v23[0];
      __int16 v31 = 2082;
      __int128 v32 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CL database error, record contains invalid time, invalid time:%{public}d, name: %{public, location:escape_only}s}",  buf,  0x22u);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101885670);
      }
    }

    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      uint64_t v11 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289538;
      int v26 = 0;
      __int16 v27 = 2082;
      uint64_t v28 = "";
      __int16 v29 = 1026;
      int v30 = (int)v23[0];
      __int16 v31 = 2082;
      __int128 v32 = v11;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CL database error, record contains invalid time",  "{msg%{public}.0s:CL database error, record contains invalid time, invalid time:%{public}d, name: %{public, location:escape_only}s}",  buf,  0x22u);
    }
  }

  return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v5 + 24LL))(v5, v7);
}

void sub_100E25E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_100E25EC4(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

uint64_t sub_100E25EF0(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  *(void *)&v23[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v24 = 256;
  v23[0] = *(double *)(a2 + 16);
  if (sub_100D8AB44(v6, v23))
  {
    if (sub_100D8A92C(v6))
    {
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 80LL))(a1, a2, 0LL);
    }

    else if (!*(_BYTE *)(a1 + 128))
    {
      uint64_t v12 = (void *)(a1 + 176);
      unint64_t v13 = *(void *)(a1 + 216);
      if (v13 > *(int *)(a1 + 312))
      {
        ++*(void *)(a1 + 208);
        *(void *)(a1 + 216) = v13 - 1;
        sub_100E264DC(a1 + 176, 1);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101885670);
        }
        BOOL v14 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "Maximum number of entries exceeded, throwing out oldest entry.",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_101885670);
          }
          v22[0] = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Maximum number of entries exceeded, throwing out oldest entry.",  v22,  2);
          int64_t v20 = (uint8_t *)v19;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityRecorderDb<CLNatalieData>::addSuspectRecord(const T &) [T = CLNatalieData, DataProtectionPoli cy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v19);
          if (v20 != buf) {
            free(v20);
          }
        }
      }

      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_101886428);
      }
      uint64_t v15 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Buffer was added to since db was inaccesible.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_101886428);
        }
        v22[0] = 0;
        LODWORD(v21) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Buffer was added to since db was inaccesible.",  v22,  v21);
        uint64_t v18 = (uint8_t *)v17;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityRecorderDb<CLNatalieData>::addSuspectRecord(const T &) [T = CLNatalieData, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v17);
        if (v18 != buf) {
          free(v18);
        }
      }

      __n128 v7 = sub_100E26414(v12, a2);
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101885670);
    }
    int v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
    {
      id v9 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289538;
      int v26 = 0;
      __int16 v27 = 2082;
      uint64_t v28 = "";
      __int16 v29 = 1026;
      int v30 = (int)v23[0];
      __int16 v31 = 2082;
      __int128 v32 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CL database error, record contains invalid time, invalid time:%{public}d, name: %{public, location:escape_only}s}",  buf,  0x22u);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101885670);
      }
    }

    uint64_t v10 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      uint64_t v11 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289538;
      int v26 = 0;
      __int16 v27 = 2082;
      uint64_t v28 = "";
      __int16 v29 = 1026;
      int v30 = (int)v23[0];
      __int16 v31 = 2082;
      __int128 v32 = v11;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CL database error, record contains invalid time",  "{msg%{public}.0s:CL database error, record contains invalid time, invalid time:%{public}d, name: %{public, location:escape_only}s}",  buf,  0x22u);
    }
  }

  return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v5 + 24LL))(v5, v7);
}

void sub_100E263E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

__n128 sub_100E26414(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 46 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100E26538(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x2E)) + 88 * (v7 % 0x2E);
  __int128 v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  __n128 result = *(__n128 *)(a2 + 32);
  __int128 v11 = *(_OWORD *)(a2 + 48);
  __int128 v12 = *(_OWORD *)(a2 + 64);
  *(void *)(v8 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)(v8 + 48) = v11;
  *(_OWORD *)(v8 + 64) = v12;
  *(__n128 *)(v8 + 32) = result;
  ++a1[5];
  return result;
}

uint64_t sub_100E264DC(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x2E) {
    a2 = 1;
  }
  if (v2 < 0x5C) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 46LL;
  }

  return v4 ^ 1u;
}

void sub_100E26538(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x2E;
  unint64_t v4 = v2 - 46;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      __int16 v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      BOOL v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        BOOL v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)BOOL v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100E26800( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100E2684C(uint64_t a1)
{
  *(void *)a1 = off_101886458;
  unint64_t v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *unint64_t v2 = 0LL;
  *(void *)(a1 + 16) = 0LL;
  return a1;
}

CLCppContainer *sub_100E268AC(const void *a1)
{
  unint64_t v2 = operator new(0x590uLL);
  memcpy(v2, a1, 0x590uLL);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_100E26934;
  v4[3] = &unk_10181D3D0;
  v4[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v4,  0LL,  1424LL);
}

void sub_100E26934(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

uint64_t sub_100E26944()
{
  dword_10199EBD8 = 800;
  __cxa_atexit((void (*)(void *))sub_100355650, qword_10199EBC0, (void *)&_mh_execute_header);
  sub_1010DDBC0(qword_10199EBE0, "DmFp");
  dword_10199EBF8 = 200;
  return __cxa_atexit((void (*)(void *))sub_100355650, qword_10199EBE0, (void *)&_mh_execute_header);
}

double sub_100E269FC(uint64_t a1)
{
  *(void *)a1 = off_101886480;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  return result;
}

double sub_100E26A2C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  *(_DWORD *)(a3 + 16) = 0;
  *(float *)(a3 + 20) = sub_100E26A78(a1, a2 + 1024, *(_BYTE *)(a2 + 352), *(double *)(a2 + 112));
  *(void *)(a3 + 24) = 0LL;
  *(void *)&double result = 3LL;
  *(void *)(a3 + 32) = 3LL;
  return result;
}

float sub_100E26A78(uint64_t a1, uint64_t a2, char a3, double a4)
{
  HIDWORD(v30) = 0;
  double v5 = *(double *)a2;
  if (*(double *)a2 <= a4)
  {
    uint64_t v6 = (double *)(a1 + 8);
    double v7 = *(double *)(a1 + 8);
    if (v5 > v7)
    {
      if ((a3 & 1) == 0)
      {
        double v9 = v5 - v7;
        double v10 = fmin(v9, 60.0);
        unsigned int v11 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 16);
        if (v11 >= 0x12C) {
          int v12 = 300;
        }
        else {
          int v12 = *(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 16);
        }
        if (v9 > 180.0) {
          unsigned int v11 = v12;
        }
        if (v10 > 0.0)
        {
          float v13 = (float)v11 / 100.0;
          float v14 = (float)(v13 * 23.94) / v10;
          *((float *)&v30 + 1) = v14;
          if (qword_1019344D0 != -1) {
            dispatch_once(&qword_1019344D0, &stru_1018864C0);
          }
          uint64_t v15 = (os_log_s *)qword_1019344D8;
          if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v16 = *(void *)(a1 + 64);
            *(_DWORD *)__int128 buf = 134218752;
            double v40 = v13;
            __int16 v41 = 2048;
            double v42 = v10;
            __int16 v43 = 2048;
            double v44 = v14;
            __int16 v45 = 2048;
            uint64_t v46 = v16;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Climbing,deltaElevation,%f,ascentDuration,%f,climbingMets,%f,len,%lu",  buf,  0x2Au);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344D0 != -1) {
              dispatch_once(&qword_1019344D0, &stru_1018864C0);
            }
            uint64_t v27 = *(void *)(a1 + 64);
            int v31 = 134218752;
            double v32 = v13;
            __int16 v33 = 2048;
            double v34 = v10;
            __int16 v35 = 2048;
            double v36 = *((float *)&v30 + 1);
            __int16 v37 = 2048;
            uint64_t v38 = v27;
            LODWORD(v30) = 42;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Climbing,deltaElevation,%f,ascentDuration,%f,climbingMets,%f,len,%lu",  COERCE_DOUBLE(&v31),  v30);
            __int16 v29 = (uint8_t *)v28;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "float CLCalorieClimbingModel::estimateClimbingMETs(CFAbsoluteTime, const CLCoarseElevationChangeEntry &, BOOL)",  "%s\n",  v28);
            if (v29 != buf) {
              free(v29);
            }
          }

          if (*(double *)a2 - *v6 >= 180.0)
          {
            do
            {
              sub_10047109C((void *)(a1 + 72), (float *)&v30 + 1);
              double v10 = v10 + -2.55999994;
            }

            while (v10 > 0.0);
          }

          else
          {
            do
            {
              sub_10047109C((void *)(a1 + 24), (float *)&v30 + 1);
              double v10 = v10 + -2.55999994;
            }

            while (v10 > 0.0);
          }
        }
      }

      *(_OWORD *)uint64_t v6 = *(_OWORD *)a2;
    }
  }

  uint64_t v17 = *(void *)(a1 + 64);
  if (v17)
  {
    ++*(void *)(a1 + 56);
    *(void *)(a1 + 64) = v17 - 1;
    sub_10074E0DC(a1 + 24, 1);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_1018864C0);
    }
    unint64_t v19 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      double v20 = *(double *)(a1 + 64);
      *(_DWORD *)__int128 buf = 134218240;
      double v40 = v18;
      __int16 v41 = 2048;
      double v42 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "Climbing,epochMets,%f,bufferLength,%lu",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_1018864C0);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Climbing,epochMets,%f,bufferLength,%lu",  &v31);
LABEL_38:
      unint64_t v25 = (uint8_t *)v21;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "float CLCalorieClimbingModel::estimateClimbingMETs(CFAbsoluteTime, const CLCoarseElevationChangeEntry &, BOOL)",  "%s\n",  v21);
      if (v25 != buf) {
        free(v25);
      }
    }
  }

  else
  {
    uint64_t v22 = *(void *)(a1 + 112);
    if (!v22) {
      return 0.0;
    }
    ++*(void *)(a1 + 104);
    *(void *)(a1 + 112) = v22 - 1;
    sub_10074E0DC(a1 + 72, 1);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_1018864C0);
    }
    uint64_t v23 = (os_log_s *)qword_1019344D8;
    if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
    {
      double v24 = *(double *)(a1 + 112);
      *(_DWORD *)__int128 buf = 134218240;
      double v40 = v18;
      __int16 v41 = 2048;
      double v42 = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "Climbing,epochMets,%f,historicalBufferLength,%lu",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344D0 != -1) {
        dispatch_once(&qword_1019344D0, &stru_1018864C0);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Climbing,epochMets,%f,historicalBufferLength,%lu",  &v31);
      goto LABEL_38;
    }
  }

  return v18;
}

void *sub_100E2708C(void *a1)
{
  *a1 = off_101886480;
  unint64_t v2 = a1 + 3;
  sub_10046E180(a1 + 9);
  sub_10046E180(v2);
  return a1;
}

void sub_100E270CC(void *a1)
{
  *a1 = off_101886480;
  unint64_t v2 = a1 + 3;
  sub_10046E180(a1 + 9);
  sub_10046E180(v2);
  operator delete(a1);
}

void sub_100E2710C(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

BOOL sub_100E27138(double *a1, double *a2)
{
  double v2 = *a1;
  if (*a1 >= 51.1 && v2 <= 61.1 && *a2 >= -13.2 && *a2 <= 1.87) {
    return 1LL;
  }
  if (v2 >= 49.866 && v2 <= 61.1 && *a2 >= -6.48 && *a2 <= 0.15) {
    return 1LL;
  }
  if (v2 >= 50.688 && v2 <= 61.1 && *a2 >= 0.15 && *a2 <= 1.43) {
    return 1LL;
  }
  if (v2 >= 29.32 && v2 <= 35.8 && *a2 >= 130.0 && *a2 <= 141.0) {
    return 1LL;
  }
  if (v2 >= 35.8 && v2 <= 41.3 && *a2 >= 135.8 && *a2 <= 142.95) {
    return 1LL;
  }
  if (v2 >= 41.3 && v2 <= 45.7 && *a2 >= 139.5 && *a2 <= 145.8) {
    return 1LL;
  }
  if (v2 >= 25.7 && v2 <= 34.756 && *a2 >= 128.837 && *a2 <= 130.0) {
    return 1LL;
  }
  if (v2 >= 23.861 && v2 <= 27.891 && *a2 >= 122.927 && *a2 <= 131.426) {
    return 1LL;
  }
  if (v2 >= -45.0 && v2 <= 4.3 && *a2 >= 104.0 && *a2 <= 156.25) {
    return 1LL;
  }
  if (v2 >= 0.0 && v2 <= 7.408 && *a2 >= 108.75 && *a2 <= 119.215) {
    return 1LL;
  }
  if (v2 >= -14.25 && v2 <= 8.35 && *a2 >= 88.9289 && *a2 <= 108.75) {
    return 1LL;
  }
  if (v2 >= -56.4 && v2 <= -28.0)
  {
    double v3 = *a2;
    if (*a2 >= 155.0 && v3 <= 180.1) {
      return 1LL;
    }
    if (v3 >= -180.1 && v3 <= -175.74) {
      return 1LL;
    }
  }

  if (v2 >= -9.0 && v2 <= 27.3 && *a2 >= 67.0 && *a2 <= 92.17) {
    return 1LL;
  }
  if (v2 >= 27.3 && v2 <= 35.44 && *a2 >= 71.746 && *a2 <= 77.876) {
    return 1LL;
  }
  if (v2 >= 26.29 && v2 <= 27.8959 && *a2 >= 79.734 && *a2 <= 88.251) {
    return 1LL;
  }
  if (v2 >= 27.3 && v2 <= 29.15 && *a2 >= 77.83 && *a2 <= 84.154) {
    return 1LL;
  }
  if (v2 >= 27.3 && v2 <= 30.0 && *a2 >= 77.83 && *a2 <= 82.4) {
    return 1LL;
  }
  if (v2 >= 24.18 && v2 <= 29.338 && *a2 >= 63.36 && *a2 <= 71.746) {
    return 1LL;
  }
  if (v2 >= 29.338 && v2 <= 30.917 && *a2 >= 66.437 && *a2 <= 71.746) {
    return 1LL;
  }
  if (v2 >= 30.917 && v2 <= 33.0 && *a2 >= 69.584 && *a2 <= 71.746) {
    return 1LL;
  }
  if (v2 >= -36.08 && v2 <= -18.04 && *a2 >= 11.32 && *a2 <= 37.9) {
    return 1LL;
  }
  if (v2 >= -18.5 && v2 <= -13.45 && *a2 >= 23.5008 && *a2 <= 41.892382) {
    return 1LL;
  }
  if (v2 >= -13.45 && v2 <= 1.68 && *a2 >= 30.905 && *a2 <= 40.987) {
    return 1LL;
  }
  if (v2 >= 1.68 && v2 <= 3.388 && *a2 >= 31.324836 && *a2 <= 40.987) {
    return 1LL;
  }
  if (v2 >= -13.8 && v2 <= -12.44 && *a2 >= 24.07 && *a2 <= 28.33) {
    return 1LL;
  }
  if (v2 >= 11.671 && v2 <= 14.258 && *a2 >= -62.322 && *a2 <= -59.263) {
    return 1LL;
  }
  if (v2 >= 22.950919 && v2 <= 27.567702 && *a2 >= -79.487787 && *a2 <= -72.604668) {
    return 1LL;
  }
  if (v2 >= 21.74346 && v2 <= 27.567702 && *a2 >= -76.173118 && *a2 <= -72.604668) {
    return 1LL;
  }
  if (v2 >= 20.668412 && v2 <= 27.567702 && *a2 >= -73.949372 && *a2 <= -72.604668) {
    return 1LL;
  }
  if (v2 >= 8.3 && v2 <= 17.45 && *a2 >= 99.675 && *a2 <= 102.316) {
    return 1LL;
  }
  if (v2 >= 14.481 && v2 <= 17.51 && *a2 >= 102.286 && *a2 <= 104.683) {
    return 1LL;
  }
  if (v2 >= 17.45 && v2 <= 19.45 && *a2 >= 98.1 && *a2 <= 100.94) {
    return 1LL;
  }
  if (v2 >= 18.142198 && v2 <= 18.315026 && *a2 >= -63.184398 && *a2 <= -62.912807) {
    return 1LL;
  }
  if (v2 >= 16.914842 && v2 <= 17.240077 && *a2 >= -61.964541 && *a2 <= -61.607641) {
    return 1LL;
  }
  if (v2 >= 21.497173 && v2 <= 26.635702 && *a2 >= 88.025462 && *a2 <= 92.577511) {
    return 1LL;
  }
  if (v2 >= 32.166353 && v2 <= 32.577428 && *a2 >= -65.0 && *a2 <= -64.50204) {
    return 1LL;
  }
  if (v2 >= 26.902547 && v2 <= 27.854393 && *a2 >= 89.351473 && *a2 <= 91.521758) {
    return 1LL;
  }
  if (v2 >= 19.103 && v2 <= 20.058 && *a2 >= -81.654 && *a2 <= -79.5) {
    return 1LL;
  }
  if (v2 >= -23.5 && v2 <= -8.32 && *a2 >= -166.288 && *a2 <= -155.88) {
    return 1LL;
  }
  if (v2 >= 34.3297 && v2 <= 35.757 && *a2 >= 32.09 && *a2 <= 34.6509) {
    return 1LL;
  }
  if (v2 >= 15.06 && v2 <= 15.816 && *a2 >= -61.61 && *a2 <= -60.984) {
    return 1LL;
  }
  if (v2 >= -53.02 && v2 <= -50.229 && *a2 >= -61.937 && *a2 <= -56.853) {
    return 1LL;
  }
  if (v2 >= -21.1769 && v2 <= -12.1 && *a2 >= 176.19 && *a2 <= 180.1) {
    return 1LL;
  }
  if (v2 >= -21.1769 && v2 <= -15.057 && *a2 >= -180.1 && *a2 <= -178.097) {
    return 1LL;
  }
  BOOL v4 = v2 > 49.589 || v2 < 49.07;
  if (!v4 && *a2 >= -2.82 && *a2 <= -1.96) {
    return 1LL;
  }
  BOOL v5 = v2 < 2.6019;
  if (v2 > 8.469) {
    BOOL v5 = 1;
  }
  return !v5 && *a2 >= -59.5 && *a2 <= -54.489
      || v2 >= 22.178 && v2 <= 22.4435 && *a2 >= 113.828 && *a2 <= 114.4585
      || v2 >= 22.4435 && v2 <= 22.502 && *a2 >= 113.952 && *a2 <= 114.4585
      || v2 >= 17.366 && v2 <= 18.926 && *a2 >= -78.498 && *a2 <= -75.908
      || !v4 && *a2 >= -2.82 && *a2 <= -1.96
      || v2 >= 22.175 && v2 <= 22.203 && *a2 >= 113.53 && *a2 <= 113.6
      || v2 >= 22.107 && v2 <= 22.175 && *a2 >= 113.548 && *a2 <= 113.6
      || v2 >= 35.656 && v2 <= 36.201 && *a2 >= 14.04 && *a2 <= 14.713
      || v2 >= -20.76 && v2 <= -19.6 && *a2 >= 56.9 && *a2 <= 58.4
      || v2 >= 16.61 && v2 <= 16.91 && *a2 >= -62.3 && *a2 <= -62.06
      || v2 >= -0.6 && v2 <= -0.42 && *a2 >= 166.866 && *a2 <= 167.028
      || v2 >= -19.3 && v2 <= -18.67 && *a2 >= -170.126 && *a2 <= -169.6
      || v2 >= -25.858 && v2 <= -23.42 && *a2 >= -131.33 && *a2 <= -123.664
      || v2 >= -14.457 && v2 <= -12.864 && *a2 >= -173.081 && *a2 <= -171.117
      || v2 >= -16.4 && v2 <= -15.4 && *a2 >= -6.2 && *a2 <= -5.0
      || v2 >= 16.986 && v2 <= 17.508 && *a2 >= -62.918 && *a2 <= -62.478
      || v2 >= -5.4 && v2 <= -3.15 && *a2 >= 54.5 && *a2 <= 56.8
      || v2 >= -12.139 && v2 <= -6.353 && *a2 >= 156.267 && *a2 <= 167.87
      || !v5 && *a2 >= -59.5 && *a2 <= -54.489
      || v2 >= -9.8 && v2 <= -8.01 && *a2 >= -172.9 && *a2 <= -170.9
      || v2 >= -22.115 && v2 <= -14.7 && *a2 >= -176.47 && *a2 <= -172.98
      || v2 >= 10.0 && v2 <= 11.585 && *a2 >= -61.8316 && *a2 <= -60.32
      || v2 >= 20.8 && v2 <= 22.35 && *a2 >= -72.56 && *a2 <= -70.81
      || v2 >= 17.555 && v2 <= 18.9639 && *a2 >= -65.11 && *a2 <= -64.14;
}

BOOL sub_100E28324(double *a1, double *a2)
{
  double v2 = *a1;
  return *a1 >= 22.4434 && v2 <= 22.62 && *a2 >= 113.952 && *a2 <= 114.4585
      || v2 >= 22.088 && v2 <= 22.244 && *a2 >= 113.511 && *a2 <= 113.621
      || v2 >= 20.439 && v2 <= 29.709 && *a2 >= 92.078 && *a2 <= 97.72
      || v2 >= 26.211 && v2 <= 30.6 && *a2 >= 77.862 && *a2 <= 97.72
      || v2 >= 8.42 && v2 <= 20.553 && *a2 >= 97.2 && *a2 <= 105.72
      || v2 >= 30.6 && v2 <= 37.23 && *a2 >= 69.13 && *a2 <= 80.725
      || v2 >= 24.09 && v2 <= 31.9 && *a2 >= 60.726 && *a2 <= 69.13
      || v2 >= -18.347 && v2 <= -16.74 && *a2 >= 11.05 && *a2 <= 23.74
      || v2 >= -17.067 && v2 <= -10.64 && *a2 >= 21.69 && *a2 <= 24.313
      || v2 >= -13.672 && v2 <= -10.44 && *a2 >= 23.327 && *a2 <= 31.131
      || v2 >= -10.65 && v2 <= 4.07 && *a2 >= 28.115 && *a2 <= 31.96
      || v2 >= -3.03 && v2 <= 5.2 && *a2 >= 31.65 && *a2 <= 42.51
      || v2 >= 0.96 && v2 <= 8.6 && *a2 >= -61.6 && *a2 <= -53.7;
}

BOOL sub_100E286A8(double *a1, double *a2)
{
  double v2 = *a1;
  BOOL result = 1;
  if ((*a1 < 27.6 || v2 > 90.0 || *a2 < -180.0 || *a2 > -65.0) && (v2 < 37.1 || v2 > 90.0 || *a2 < 2.75 || *a2 > 129.7))
  {
    if (v2 < -49.0 || v2 > 0.0 || (*a2 >= -93.0 ? (BOOL v3 = *a2 > -30.0) : (BOOL v3 = 1), v3))
    {
      if ((v2 < 22.7 || v2 > 90.0 || *a2 < 97.7 || *a2 > 122.7)
        && (v2 < 5.24 || v2 > 33.0 || *a2 < -29.8 || *a2 > 54.475)
        && (v2 < 31.75 || v2 > 49.0 || *a2 < -13.0 || *a2 > 3.0))
      {
        BOOL v4 = v2 < -1.0 || v2 > 28.0;
        if ((v4 || *a2 < -120.0 || *a2 > -81.67) && (v2 < 14.3 || v2 > 25.4 || *a2 < -163.4 || *a2 > -150.8)) {
          return 0;
        }
      }
    }
  }

  return result;
}

uint64_t sub_100E288AC(double a1, double a2)
{
  double v3 = a2;
  double v4 = a1;
  if (sub_100E286A8(&v4, &v3)) {
    return 2LL;
  }
  if (sub_100E27138(&v4, &v3)) {
    return 1LL;
  }
  if (sub_100E28324(&v4, &v3)) {
    return 0LL;
  }
  return 2LL;
}

uint64_t sub_100E28910()
{
  if (qword_10199EC38 != -1) {
    dispatch_once(&qword_10199EC38, &stru_1018864E0);
  }
  return qword_1019A20D8;
}

void sub_100E28950(id a1)
{
  id v1 = +[CLIntersiloUniverse newSharedVendorUniverseWithSilo:]( &OBJC_CLASS___CLIntersiloUniverse,  "newSharedVendorUniverseWithSilo:",  sub_1006E282C());
  double v2 = operator new(0x448uLL);
  sub_100E289B4((uint64_t)v2, (uint64_t)v1);
  qword_1019A20D8 = (uint64_t)v2;
}

void sub_100E289A0(_Unwind_Exception *a1)
{
}

uint64_t sub_100E289B4(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 40) = off_10184DB68;
  *(void *)a1 = off_101886510;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 48) = 60LL;
  *(void *)(a1 + 56) = off_10184DB98;
  *(void *)(a1 + 64) = 60LL;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 120) = 0LL;
  *(void *)(a1 + 128) = off_10184DB98;
  *(void *)(a1 + 136) = 60LL;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(void *)(a1 + 192) = 0LL;
  *(void *)(a1 + 200) = off_10184DB98;
  *(void *)(a1 + 208) = 60LL;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 264) = 0LL;
  *(void *)(a1 + 272) = off_10184DB68;
  *(void *)(a1 + 280) = 30LL;
  *(void *)(a1 + 288) = off_10184DB98;
  *(void *)(a1 + 296) = 30LL;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(void *)(a1 + 352) = 0LL;
  *(void *)(a1 + 360) = off_10184DB98;
  *(void *)(a1 + 368) = 30LL;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 424) = 0LL;
  *(void *)(a1 + 432) = off_10184DB98;
  *(void *)(a1 + 440) = 30LL;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(void *)(a1 + 496) = 0LL;
  *(void *)(a1 + 504) = off_10184DB98;
  *(void *)(a1 + 512) = 30LL;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(void *)(a1 + 568) = 0LL;
  *(void *)(a1 + 576) = off_10184DB68;
  *(void *)(a1 + 584) = 256LL;
  *(void *)(a1 + 592) = off_10184DB98;
  *(void *)(a1 + 600) = 256LL;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(void *)(a1 + 656) = 0LL;
  *(void *)(a1 + 664) = off_10184DB98;
  *(void *)(a1 + 672) = 256LL;
  *(void *)(a1 + 728) = 0LL;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_OWORD *)(a1 + 680) = 0u;
  *(void *)(a1 + 736) = off_10184DB98;
  *(void *)(a1 + 744) = 256LL;
  *(void *)(a1 + 800) = 0LL;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(void *)(a1 + 808) = off_10184DB98;
  *(void *)(a1 + 816) = 256LL;
  *(void *)(a1 + 872) = 0LL;
  *(_OWORD *)(a1 + 840) = 0u;
  *(_OWORD *)(a1 + 856) = 0u;
  *(_OWORD *)(a1 + 824) = 0u;
  *(void *)(a1 + 904) = 0LL;
  *(_BYTE *)(a1 + 912) = 1;
  *(void *)(a1 + 920) = 0LL;
  *(void *)(a1 + 928) = 0x41E000007F7FFFFFLL;
  *(void *)(a1 + 936) = &off_10184D7B0;
  *(void *)(a1 + 944) = 0LL;
  *(_DWORD *)(a1 + 952) = 0;
  *(void *)(a1 + 960) = &off_10184D7B0;
  *(void *)(a1 + 968) = 0LL;
  *(_DWORD *)(a1 + 976) = 0;
  *(void *)(a1 + 984) = &off_10184D7B0;
  *(void *)(a1 + 992) = 0LL;
  *(_DWORD *)(a1 + 1000) = 0;
  *(_WORD *)(a1 + 1008) = 0;
  *(void *)(a1 + 1016) = 0LL;
  uint64_t v25 = a1 + 16;
  if ((sub_1004F97F4() & 0x40000) != 0)
  {
    sub_1004F2598();
    char v3 = sub_1004F89A4() ^ 1;
  }

  else
  {
    char v3 = 0;
  }

  *(_BYTE *)(a1 + 1024) = v3;
  *(_BYTE *)(a1 + 1025) = 0;
  *(_WORD *)(a1 + 1064) = 0;
  *(_OWORD *)(a1 + 1032) = 0u;
  *(_OWORD *)(a1 + 1048) = 0u;
  *(void *)(a1 + 1072) = a1 + 1072;
  *(void *)(a1 + 1080) = a1 + 1072;
  *(void *)(a1 + 1088) = 0LL;
  double v4 = operator new(0x38uLL);
  v4[4] = &off_10184D7B0;
  void v4[5] = 0LL;
  *((_DWORD *)v4 + 12) = 0;
  *double v4 = 0x3D209B4000000000LL;
  v4[1] = &off_10184D7B0;
  *((_DWORD *)v4 + 6) = 0;
  v4[2] = 0LL;
  *(void *)(a1 + 880) = v4;
  BOOL v5 = operator new(0x38uLL);
  v5[4] = &off_10184D7B0;
  v5[5] = 0LL;
  *((_DWORD *)v5 + 12) = 0;
  *BOOL v5 = 0x3D782A0000000000LL;
  v5[1] = &off_10184D7B0;
  *((_DWORD *)v5 + 6) = 0;
  v5[2] = 0LL;
  *(void *)(a1 + 888) = v5;
  uint64_t v6 = operator new(0x38uLL);
  _DWORD v6[4] = &off_10184D7B0;
  void v6[5] = 0LL;
  *((_DWORD *)v6 + 12) = 0;
  void *v6 = 0x3BA36E8000000000LL;
  v6[1] = &off_10184D7B0;
  *((_DWORD *)v6 + 6) = 0;
  __n128 v6[2] = 0LL;
  *(void *)(a1 + 896) = v6;
  *(void *)(a1 + 1016) = dispatch_queue_create("com.apple.locationd.CoreMotion.CLGyroBiasEstimator", 0LL);
  uint64_t v7 = sub_1006E27E8();
  sub_100413284(v7, buf);
  char v8 = sub_1002A6F64(*(uint64_t *)&buf[0], "DisableDynamicGyroBias", (BOOL *)(a1 + 1009));
  double v9 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (*((void *)&buf[0] + 1))
  {
    double v10 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  int v12 = (_BYTE *)(a1 + 1024);
  if ((v8 & 1) == 0) {
    *(_BYTE *)(a1 + 1009) = 0;
  }
  int v13 = *v12;
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  sub_1002A6F64(*(uint64_t *)&buf[0], "EnableGyroNonlinearCalibration", (BOOL *)(a1 + 1024));
  uint64_t v15 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (*((void *)&buf[0] + 1))
  {
    uint64_t v16 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
    do
      unint64_t v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

  if (*v12 && sub_1001B9A1C())
  {
    uint64_t v18 = sub_1006E27E8();
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472LL;
    _OWORD v26[2] = sub_100E29040;
    v26[3] = &unk_10181D3D0;
    v26[4] = a1;
    sub_1006E2970(v18, (uint64_t)v26);
  }

  else
  {
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    unint64_t v19 = (os_log_s *)off_101934598;
    if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
    {
      double v20 = "Yes";
      if (!v13) {
        double v20 = "No";
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "[CLGBE] SPU bias NOT available,default,%{public}s",  (uint8_t *)buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934590 != -1) {
        dispatch_once(&qword_101934590, &stru_101886570);
      }
      uint64_t v22 = "Yes";
      if (!v13) {
        uint64_t v22 = "No";
      }
      int v27 = 136446210;
      uint64_t v28 = v22;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] SPU bias NOT available,default,%{public}s",  &v27,  12,  v25);
      double v24 = (char *)v23;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLGyroBiasEstimator::CLGyroBiasEstimator(id<CLIntersiloUniverse>)",  "%s\n",  v23);
    }
  }

  return a1;
}

void sub_100E28F48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t *a11)
{
  uint64_t v18 = *v16;
  *uint64_t v16 = 0LL;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
  }
  uint64_t v19 = v11[115];
  v11[115] = 0LL;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  v11[101] = off_10184DB98;
  sub_10046E180(v11 + 104);
  sub_10074DF98(v14);
  v11[63] = off_10184DB98;
  sub_10046E180(v11 + 66);
  sub_10074DF98(v13);
  sub_10074DF98(v12);
  uint64_t v20 = v11[4];
  v11[4] = 0LL;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  }
  uint64_t v21 = v11[3];
  v11[3] = 0LL;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
  }
  uint64_t v22 = *a11;
  *a11 = 0LL;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
  }
  _Unwind_Resume(a1);
}

void *sub_100E29040(uint64_t a1)
{
  return sub_100E29048(*(void **)(a1 + 32));
}

void *sub_100E29048(void *result)
{
  if (*((_BYTE *)result + 1065)) {
    return result;
  }
  uint64_t v1 = (uint64_t)result;
  if (!*((_BYTE *)result + 1024)) {
    sub_1012726BC();
  }
  if (result[129]) {
    return result;
  }
  double v2 = operator new(0x40uLL);
  double v10 = v9;
  v7[0] = &off_101886A80;
  char v8 = v7;
  v9[0] = &off_1018869F0;
  sub_100E2E37C(v2, (uint64_t)v9, (uint64_t)v7, (uint64_t)sub_100E2A66C, v1);
  uint64_t v3 = *(void *)(v1 + 1032);
  *(void *)(v1 + 1032) = v2;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  double v4 = v8;
  if (v8 == v7)
  {
    uint64_t v5 = 4LL;
    double v4 = v7;
    goto LABEL_10;
  }

  if (v8)
  {
    uint64_t v5 = 5LL;
LABEL_10:
    (*(void (**)(void))(*v4 + 8 * v5))();
  }

  BOOL result = v10;
  if (v10 == v9)
  {
    uint64_t v6 = 4LL;
    BOOL result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v6 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v6))();
}

void sub_100E29184(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  va_list v12 = va_arg(va1, va_list);
  va_list v6 = v12;
  if (v12 == v4)
  {
    uint64_t v7 = 4LL;
    va_copy(v6, va);
  }

  else
  {
    if (!v12) {
      goto LABEL_6;
    }
    uint64_t v7 = 5LL;
  }

  (*(void (**)(void))(*(void *)v6 + 8 * v7))();
LABEL_6:
  sub_101272848(v3, (uint64_t *)va1);
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100E291D4(uint64_t result)
{
  if (!*(_BYTE *)(result + 1008))
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)(result + 16);
    *(void *)(v1 + 16) = 0LL;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
    uint64_t v3 = *(void *)(v1 + 24);
    *(void *)(v1 + 24) = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    BOOL result = *(void *)(v1 + 32);
    *(void *)(v1 + 32) = 0LL;
    if (result) {
      BOOL result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
    if (*(_BYTE *)(v1 + 1065))
    {
      BOOL result = *(void *)(v1 + 1032);
      *(void *)(v1 + 1032) = 0LL;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
      }
    }
  }

  return result;
}

uint64_t sub_100E29268(uint64_t a1)
{
  *(void *)a1 = off_101886510;
  dispatch_release(*(dispatch_object_t *)(a1 + 1016));
  sub_1001B4C40((void *)(a1 + 1072));
  uint64_t v2 = *(void *)(a1 + 1032);
  *(void *)(a1 + 1032) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 920);
  *(void *)(a1 + 920) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  *(void *)(a1 + 808) = off_10184DB98;
  sub_10046E180((void *)(a1 + 832));
  sub_10074DF98((void *)(a1 + 576));
  *(void *)(a1 + 504) = off_10184DB98;
  sub_10046E180((void *)(a1 + 528));
  sub_10074DF98((void *)(a1 + 272));
  sub_10074DF98((void *)(a1 + 40));
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  return a1;
}

void sub_100E2935C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E29268(a1);
  operator delete(v1);
}

void sub_100E29370(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t v8 = sub_1006E27E8();
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  _OWORD v9[2] = sub_100E293EC;
  void v9[3] = &unk_10185F3C8;
  v9[5] = a1;
  v9[6] = a2;
  char v10 = a3;
  _DWORD v9[4] = a4;
  sub_1006E28B8(v8, (uint64_t)v9);
}

void sub_100E293EC(uint64_t a1)
{
}

void sub_100E29400(uint64_t a1, uint64_t a2, char a3, void *a4)
{
  if (*(_BYTE *)(a1 + 1065)) {
    return;
  }
  char v8 = sub_100E296A0((void *)a1, a2);
  if (a4 || (v8 & 1) != 0)
  {
    if (a4) {
      sub_100E298B8(a1, a2, a3, a4);
    }
    uint64_t v10 = a1 + 1072;
    uint64_t v11 = *(void *)(a1 + 1080);
    if (v11 == a1 + 1072)
    {
      *(_BYTE *)(a1 + 1008) = 0;
      uint64_t v11 = a1 + 1072;
      if (!*(_BYTE *)(a1 + 1024)) {
        goto LABEL_26;
      }
    }

    else
    {
      uint64_t v12 = *(void *)(a1 + 1080);
      while (!*(_BYTE *)(v12 + 32))
      {
        uint64_t v12 = *(void *)(v12 + 8);
        if (v12 == v10)
        {
          *(_BYTE *)(a1 + 1008) = 0;
          goto LABEL_21;
        }
      }

      *(_BYTE *)(a1 + 1008) = v12 != v10;
      if (v12 != v10) {
        *(_DWORD *)(a1 + 932) = 1105199104;
      }
LABEL_21:
      if (!*(_BYTE *)(a1 + 1024)) {
        goto LABEL_26;
      }
      while (*(_BYTE *)(v11 + 32))
      {
        uint64_t v11 = *(void *)(v11 + 8);
        if (v11 == v10)
        {
          uint64_t v11 = a1 + 1072;
          break;
        }
      }
    }

    *(_BYTE *)(a1 + 1025) = v11 != v10;
LABEL_26:
    sub_100E29D0C(a1);
    return;
  }

  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  double v9 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 134349056;
    uint64_t v18 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "[CLGBE] Client instance %{public}p already unregistered",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    int v15 = 134349056;
    uint64_t v16 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Client instance %{public}p already unregistered",  &v15,  12);
    uint64_t v14 = (uint8_t *)v13;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGyroBiasEstimator::setHandlerForInstanceInternal(const void *, const BOOL, Handler)",  "%s\n",  v13);
    if (v14 != buf) {
      free(v14);
    }
  }

uint64_t sub_100E296A0(void *a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t *)a1[135];
  if (v2 == a1 + 134) {
    return 0LL;
  }
  while (v2[2] != a2)
  {
    uint64_t v2 = (uint64_t *)v2[1];
    if (v2 == a1 + 134) {
      return 0LL;
    }
  }

  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  uint64_t v6 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 134349056;
    uint64_t v13 = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "[CLGBE] Removing client %{public}p", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    int v10 = 134349056;
    uint64_t v11 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Removing client %{public}p",  &v10,  12);
    double v9 = (uint8_t *)v8;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLGyroBiasEstimator::removeClientInternal(const void *)", "%s\n", v8);
    if (v9 != buf) {
      free(v9);
    }
  }

  _Block_release((const void *)v2[3]);
  uint64_t v7 = *v2;
  *(void *)(v7 + 8) = v2[1];
  *(void *)v2[1] = v7;
  --a1[136];
  operator delete(v2);
  return 1LL;
}

void sub_100E298B8(uint64_t a1, uint64_t a2, char a3, void *aBlock)
{
  char v8 = _Block_copy(aBlock);
  double v9 = operator new(0x28uLL);
  _OWORD v9[2] = a2;
  void v9[3] = v8;
  *((_BYTE *)v9 + 32) = a3;
  uint64_t v10 = *(void *)(a1 + 1072);
  *(void *)(v10 + 8) = v9;
  *(void *)(a1 + 1072) = v9;
  void *v9 = v10;
  v9[1] = a1 + 1072;
  ++*(void *)(a1 + 1088);
  if (*(_BYTE *)(a1 + 1064))
  {
    char v11 = *(_BYTE *)(a1 + 912);
    if (v11) {
      char v11 = *(_DWORD *)(a1 + 908) != 0;
    }
    uint64_t v29 = *(void *)(a1 + 1040);
    int v30 = *(_DWORD *)(a1 + 1048);
    int v32 = *(_DWORD *)(a1 + 1060);
    uint64_t v31 = *(void *)(a1 + 1052);
    char v33 = v11;
    (*((void (**)(void *, uint64_t *))aBlock + 2))(aBlock, &v29);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    uint64_t v12 = (os_log_s *)off_101934598;
    if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
    {
      double v13 = *(float *)(a1 + 1040);
      double v14 = *(float *)(a1 + 1044);
      double v15 = *(float *)(a1 + 1048);
      double v16 = *(float *)(a1 + 1052);
      double v17 = *(float *)(a1 + 1056);
      double v18 = *(float *)(a1 + 1060);
      *(_DWORD *)__int128 buf = 134350592;
      uint64_t v49 = a2;
      __int16 v50 = 2050;
      double v51 = v13;
      __int16 v52 = 2050;
      double v53 = v14;
      __int16 v54 = 2050;
      double v55 = v15;
      __int16 v56 = 2050;
      double v57 = v16;
      __int16 v58 = 2050;
      double v59 = v17;
      __int16 v60 = 2050;
      double v61 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "[CLGBE] Adding client %{public}p, sending out cached gyro bias,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{publ ic}f,var.x,%{public}f,var.y,%{public}f,var.z,%{public}f",  buf,  0x48u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934590 != -1) {
        dispatch_once(&qword_101934590, &stru_101886570);
      }
      double v19 = *(float *)(a1 + 1040);
      double v20 = *(float *)(a1 + 1044);
      double v21 = *(float *)(a1 + 1048);
      double v22 = *(float *)(a1 + 1052);
      double v23 = *(float *)(a1 + 1056);
      double v24 = *(float *)(a1 + 1060);
      int v34 = 134350592;
      uint64_t v35 = a2;
      __int16 v36 = 2050;
      double v37 = v19;
      __int16 v38 = 2050;
      double v39 = v20;
      __int16 v40 = 2050;
      double v41 = v21;
      __int16 v42 = 2050;
      double v43 = v22;
      __int16 v44 = 2050;
      double v45 = v23;
      __int16 v46 = 2050;
      double v47 = v24;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Adding client %{public}p, sending out cached gyro bias,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{publ ic}f,var.x,%{public}f,var.y,%{public}f,var.z,%{public}f",  &v34,  72);
      uint64_t v26 = (uint8_t *)v25;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGyroBiasEstimator::addClientInternal(const void *, const BOOL, CLGyroBiasEstimator::Handler)",  "%s\n",  v25);
LABEL_21:
      if (v26 != buf) {
        free(v26);
      }
    }
  }

  else
  {
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    int v27 = (os_log_s *)off_101934598;
    if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 134349056;
      uint64_t v49 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_INFO,  "[CLGBE] Adding client %{public}p, no cached gyro bias available",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934590 != -1) {
        dispatch_once(&qword_101934590, &stru_101886570);
      }
      int v34 = 134349056;
      uint64_t v35 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Adding client %{public}p, no cached gyro bias available",  &v34,  12);
      uint64_t v26 = (uint8_t *)v28;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGyroBiasEstimator::addClientInternal(const void *, const BOOL, CLGyroBiasEstimator::Handler)",  "%s\n",  v28);
      goto LABEL_21;
    }
  }

void sub_100E29D0C(uint64_t a1)
{
  if ((sub_1001B9A1C() & 1) != 0)
  {
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    uint64_t v2 = (os_log_s *)off_101934598;
    if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = *(unsigned __int8 *)(a1 + 1025);
      int v4 = *(unsigned __int8 *)(a1 + 1008);
      uint64_t v5 = *(void *)(a1 + 1088);
      *(_DWORD *)__int128 buf = 67240704;
      int v25 = v3;
      __int16 v26 = 1026;
      int v27 = v4;
      __int16 v28 = 2050;
      uint64_t v29 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "[CLGBE] SPUEnabled,%{public}d,BuildingGYTT,%{public}d,NumClients,%{public}lu",  buf,  0x18u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934590 != -1) {
        dispatch_once(&qword_101934590, &stru_101886570);
      }
      int v13 = *(unsigned __int8 *)(a1 + 1025);
      int v14 = *(unsigned __int8 *)(a1 + 1008);
      uint64_t v15 = *(void *)(a1 + 1088);
      v19[0] = 67240704;
      v19[1] = v13;
      __int16 v20 = 1026;
      int v21 = v14;
      __int16 v22 = 2050;
      uint64_t v23 = v15;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  0LL,  "[CLGBE] SPUEnabled,%{public}d,BuildingGYTT,%{public}d,NumClients,%{public}lu",  v19,  24);
      double v17 = (uint8_t *)v16;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGyroBiasEstimator::refreshDispatchersIfNecessaryInternal()",  "%s\n",  v16);
      if (v17 != buf) {
        free(v17);
      }
    }

    if (*(void *)(a1 + 1088))
    {
      if (*(_BYTE *)(a1 + 1025))
      {
        sub_100E29048((void *)a1);
        uint64_t v6 = sub_1008FA854(0);
        (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 + 136) + 16LL))(v6 + 136, 1LL);
      }

      if (*(_BYTE *)(a1 + 1008) || !*(_BYTE *)(a1 + 1024)) {
        sub_100E2A104((void *)a1);
      }
    }

    if (*(_BYTE *)(a1 + 1024))
    {
      if (*(_BYTE *)(a1 + 1025)
        || (uint64_t v10 = sub_1008FA854(0),
            (*(void (**)(uint64_t, void))(*(void *)(v10 + 136) + 16LL))(v10 + 136, 0LL),
            *(_BYTE *)(a1 + 1024)))
      {
        if (*(_BYTE *)(a1 + 1008)) {
          return;
        }
        goto LABEL_26;
      }
    }

    if (!*(void *)(a1 + 1088))
    {
LABEL_26:
      dispatch_time_t v11 = dispatch_time(0LL, 2000000000LL);
      uint64_t v12 = *(dispatch_queue_s **)(a1 + 1016);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100E2A560;
      block[3] = &unk_10181D3D0;
      block[4] = a1;
      dispatch_after(v11, v12, block);
    }
  }

  else
  {
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    uint64_t v7 = (os_log_s *)off_101934598;
    if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "[CLGBE] Gyro not available", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934590 != -1) {
        dispatch_once(&qword_101934590, &stru_101886570);
      }
      LOWORD(v19[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Gyro not available",  v19,  2);
      double v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGyroBiasEstimator::refreshDispatchersIfNecessaryInternal()",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }
  }

void *sub_100E2A104(void *result)
{
  if (*((_BYTE *)result + 1065)) {
    return result;
  }
  uint64_t v1 = (uint64_t)result;
  if (!result[115] && !*((_BYTE *)result + 1024))
  {
    uint64_t v2 = (void *)sub_1006E2838();
    sub_100395860((uint64_t)sub_100E2A5C8, v1, v2, &v21);
    uint64_t v3 = v21;
    uint64_t v21 = 0LL;
    uint64_t v4 = *(void *)(v1 + 920);
    *(void *)(v1 + 920) = v3;
    if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
      uint64_t v5 = v21;
      uint64_t v21 = 0LL;
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
      }
    }

    BOOL result = objc_msgSend( *(id *)(*(void *)(v1 + 920) + 16),  "register:forNotification:registrationInfo:",  *(void *)(*(void *)(v1 + 920) + 8),  0,  0,  v21);
  }

  if (*(void *)(v1 + 16)) {
    goto LABEL_22;
  }
  BOOL result = (void *)sub_1001B9A1C();
  if (!(_DWORD)result) {
    goto LABEL_22;
  }
  uint64_t v6 = operator new(0x40uLL);
  char v33 = v32;
  v30[0] = &off_101886630;
  uint64_t v31 = v30;
  v32[0] = &off_1018865A0;
  sub_100E2D020(v6, (uint64_t)v32, (uint64_t)v30, (uint64_t)sub_100E2A63C, v1);
  uint64_t v7 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = v6;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  char v8 = v31;
  if (v31 == v30)
  {
    uint64_t v9 = 4LL;
    char v8 = v30;
    goto LABEL_16;
  }

  if (v31)
  {
    uint64_t v9 = 5LL;
LABEL_16:
    (*(void (**)(void))(*v8 + 8 * v9))();
  }

  BOOL result = v33;
  if (v33 == v32)
  {
    uint64_t v10 = 4LL;
    BOOL result = v32;
    goto LABEL_21;
  }

  if (v33)
  {
    uint64_t v10 = 5LL;
LABEL_21:
    BOOL result = (void *)(*(uint64_t (**)(void))(*result + 8 * v10))();
  }

void sub_100E2A450( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25)
{
  __int16 v28 = a13;
  if (a13 == v26)
  {
    uint64_t v29 = 4LL;
    __int16 v28 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v29 = 5LL;
  }

  (*(void (**)(void))(*(void *)v28 + 8 * v29))();
LABEL_6:
  int v30 = a17;
  if (a17 == &a14)
  {
    uint64_t v31 = 4LL;
    int v30 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_11;
    }
    uint64_t v31 = 5LL;
  }

  (*(void (**)(void))(*(void *)v30 + 8 * v31))();
LABEL_11:
  operator delete(v25);
  _Unwind_Resume(a1);
}

void sub_100E2A560(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = sub_1006E27E8();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100E2A5C0;
  v3[3] = &unk_10181D3D0;
  v3[4] = v1;
  sub_1006E2970(v2, (uint64_t)v3);
}

uint64_t sub_100E2A5C0(uint64_t a1)
{
  return sub_100E291D4(*(void *)(a1 + 32));
}

void sub_100E2A5C8(int a1, _DWORD *a2, void *__src, uint64_t a4)
{
  if (!*a2)
  {
    memcpy(__dst, __src, sizeof(__dst));
    sub_100E2C000(a4, (uint64_t)__dst);
  }

float32x2_t sub_100E2A63C(uint64_t a1, float32x2_t *a2, float32x2_t a3)
{
  return sub_100E2A67C(a2, a1, a3);
}

void sub_100E2A64C(uint64_t a1, float32x2_t *a2)
{
}

void sub_100E2A65C(float32x2_t *a1, uint64_t a2)
{
}

void sub_100E2A66C(uint64_t *a1, uint64_t a2)
{
}

float32x2_t sub_100E2A67C(float32x2_t *a1, uint64_t a2, float32x2_t result)
{
  if (!a1[126].i8[1])
  {
    int v5 = *(_DWORD *)(a2 + 16);
    uint64_t v6 = (float32x2_t *)a1[110];
    v22[0] = (float32x2_t)&off_10184D7B0;
    v22[1] = *(float32x2_t *)(a2 + 8);
    int v23 = v5;
    sub_100E2ADA0(v6, v22);
    float32x2_t v7 = a1[110];
    uint64_t v19 = &off_10184D7B0;
    uint64_t v20 = *(void *)(*(void *)&v7 + 16LL);
    int v21 = *(_DWORD *)(*(void *)&v7 + 24LL);
    sub_10074DC40((uint64_t)&a1[36], (float *)&v20);
    sub_10074DC40((uint64_t)&a1[45], (float *)&v20 + 1);
    sub_10074DC40((uint64_t)&a1[54], (float *)&v21);
    sub_10074DC40((uint64_t)&a1[63], (float *)&a1[116]);
    if (a1[114].i8[0] || a1[126].i8[0])
    {
      int v8 = 0;
      int v9 = 0;
      if (a1[44]) {
        int v9 = *(_DWORD *)(*(void *)(*(void *)&a1[40] + ((*(void *)&a1[43] >> 7) & 0x1FFFFFFFFFFFFF8LL))
      }
                       + 4 * (*(void *)&a1[43] & 0x3FFLL));
      if (a1[53]) {
        int v8 = *(_DWORD *)(*(void *)(*(void *)&a1[49] + ((*(void *)&a1[52] >> 7) & 0x1FFFFFFFFFFFFF8LL))
      }
                       + 4 * (*(void *)&a1[52] & 0x3FFLL));
      float v10 = 0.0;
      int v11 = 0;
      if (a1[62]) {
        int v11 = *(_DWORD *)(*(void *)(*(void *)&a1[58] + ((*(void *)&a1[61] >> 7) & 0x1FFFFFFFFFFFFF8LL))
      }
                        + 4 * (*(void *)&a1[61] & 0x3FFLL));
      uint64_t v15 = &off_10184D7B0;
      int v16 = v9;
      int v17 = v8;
      int v18 = v11;
      if (a1[71]) {
      sub_100E2AE58(a1, (float32x2_t *)&v15, v10, *(double *)a2);
      }
    }

    else
    {
      uint64_t v12 = (float32x2_t *)a1[112];
      ++v12->i32[0];
      float v13 = v12->f32[1] * -0.2 + 1.0;
      float32_t v14 = v12[3].f32[0] * v13;
      BOOL result = vmul_n_f32(v12[2], v13);
      _DWORD v12[2] = result;
      v12[3].f32[0] = v14;
    }
  }

  return result;
}

void sub_100E2A854(float32x2_t *a1, uint64_t a2)
{
  float v2 = *(float *)(a2 + 8);
  a1[116].f32[0] = v2;
  float32_t v3 = (float)(v2 * a1[119].f32[0]) + a1[122].f32[0];
  a1[124] = vadd_f32(vmul_n_f32(a1[118], v2), a1[121]);
  a1[125].f32[0] = v3;
  if (!a1[113].i32[1])
  {
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    uint64_t v6 = (os_log_s *)off_101934598;
    if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
    {
      double v7 = a1[116].f32[0];
      *(_DWORD *)__int128 buf = 134349056;
      double v14 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "[CLGBE] Notifying clients on temperature update,temperature,%{public}f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934590 != -1) {
        dispatch_once(&qword_101934590, &stru_101886570);
      }
      double v8 = a1[116].f32[0];
      int v11 = 134349056;
      double v12 = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Notifying clients on temperature update,temperature,%{public}f",  &v11,  12);
      float v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGyroBiasEstimator::feedGyroTemperature(const CLGyro::Temperature *)",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    sub_100E2AF74((uint64_t)a1, *(double *)a2);
  }

void sub_100E2AA58(uint64_t a1, float32x2_t *a2)
{
  if (*(_BYTE *)(a1 + 1008)) {
    goto LABEL_2;
  }
  __int32 v3 = a2[2].i32[0];
  uint64_t v4 = *(float32x2_t **)(a1 + 888);
  v37[0] = (float32x2_t)&off_10184D7B0;
  v37[1] = a2[1];
  __int32 v38 = v3;
  sub_100E2ADA0(v4, v37);
  uint64_t v5 = *(void *)(a1 + 888);
  uint64_t v35 = *(void *)(v5 + 16);
  int v36 = *(_DWORD *)(v5 + 24);
  sub_10074DC40(a1 + 56, (float *)&v35);
  sub_10074DC40(a1 + 128, (float *)&v35 + 1);
  sub_10074DC40(a1 + 200, (float *)&v36);
  unint64_t v6 = *(void *)(a1 + 120);
  double v7 = 0.0;
  if ((int)v6 >= 2)
  {
    unint64_t v8 = *(void *)(a1 + 192);
    float v9 = 0.0;
    float v10 = 0.0;
    if (v8) {
      float v10 = *(float *)(a1 + 144) / (float)v8;
    }
    unint64_t v11 = *(void *)(a1 + 264);
    if (v11) {
      float v9 = *(float *)(a1 + 216) / (float)v11;
    }
    unint64_t v12 = *(void *)(a1 + 112);
    uint64_t v13 = *(void *)(a1 + 120);
    float v14 = 0.0;
    float v15 = 0.0;
    float v16 = 0.0;
    float v17 = 0.0;
    unint64_t v18 = *(void *)(a1 + 184);
    float v19 = 0.0;
    float v20 = 0.0;
    unint64_t v21 = *(void *)(a1 + 256);
    do
    {
      float v24 = *(float *)(*(void *)(*(void *)(a1 + 232) + ((v21 >> 7) & 0x1FFFFFFFFFFFFF8LL)) + 4 * (v21 & 0x3FF)) - v9;
      float v16 = v16 + (float)(v22 * v22);
      float v15 = v15 + (float)(v23 * v23);
      float v14 = v14 + (float)(v24 * v24);
      float v20 = v20 + v22;
      float v19 = v19 + v23;
      float v17 = v17 + v24;
      ++v21;
      ++v18;
      ++v12;
      --v13;
    }

    while (v13);
    double v7 = (float)((float)((float)((float)(v16 - (float)((float)(v20 * v20) / (float)(int)v6)) / (float)((int)v6 - 1))
  }

  float v25 = 0.0;
  float v26 = 0.0;
  if (v6) {
  uint64_t v27 = *(void *)(a1 + 192);
  }
  if (v27) {
    float v25 = *(float *)(*(void *)(*(void *)(a1 + 160)
  }
  uint64_t v28 = *(void *)(a1 + 264);
  float v29 = 0.0;
  float v30 = 0.0;
  if (v28) {
    float v30 = *(float *)(*(void *)(*(void *)(a1 + 232)
  }
  if (v6) {
  float v31 = 0.0;
  }
  float v32 = 0.0;
  if (v27) {
  if (v28)
  }
  char v33 = (unsigned int *)(a1 + 904);
  if (v7
     + (float)((float)((float)((float)(v25 - v32) * (float)(v25 - v32))
                     + (float)((float)(v26 - v29) * (float)(v26 - v29)))
             + (float)((float)(v30 - v31) * (float)(v30 - v31)))
     * 0.2 <= 0.5)
  {
    unsigned int v34 = *v33 + 1;
    *char v33 = v34;
    if (v34 >= 5) {
LABEL_2:
    }
      *(_BYTE *)(a1 + 912) = 1;
  }

  else
  {
    *(_BYTE *)(a1 + 912) = 0;
    *(void *)char v33 = 0LL;
    sub_100E2BD44((void *)a1);
  }

float32x2_t sub_100E2ADA0(float32x2_t *a1, float32x2_t *a2)
{
  if (&a1[4] != a2)
  {
    float32x2_t result = a2[1];
    a1[5] = result;
    a1[6].i32[0] = a2[2].i32[0];
  }

  int v3 = a1->i32[0];
  int v4 = a1->i32[0] + 1;
  a1->i32[0] = v4;
  if (v3 > 2)
  {
    float v6 = a1->f32[1];
    float32_t v7 = (float)((float)(1.0 - v6) * a1[3].f32[0]) + (float)(v6 * a2[2].f32[0]);
    float32x2_t result = vadd_f32(vmul_n_f32(a1[2], 1.0 - v6), vmul_n_f32(a2[1], v6));
    a1[2] = result;
    a1[3].f32[0] = v7;
  }

  else
  {
    float v5 = 1.0 / (double)v4;
    result.f32[0] = (float)((float)(a1[3].f32[0] * (float)v3) + a2[2].f32[0]) * v5;
    a1[2] = vmul_n_f32(vadd_f32(vmul_n_f32(a1[2], (float)v3), a2[1]), v5);
    a1[3].i32[0] = result.i32[0];
  }

  return result;
}

void sub_100E2AE58(float32x2_t *a1, float32x2_t *a2, float a3, double a4)
{
  if (a3 != 3.4028e38)
  {
    float v8 = a1[125].f32[0];
    float32x2_t v9 = vsub_f32(a2[1], a1[124]);
    float v10 = a2[2].f32[0];
    float v11 = a1[116].f32[1];
    float v12 = fabsf(v9.f32[1]);
    float v13 = vabds_f32(v10, v8);
    if (fabsf(v9.f32[0]) <= v11 && v12 <= v11 && v13 <= v11)
    {
      ++a1[113].i32[1];
      float v16 = (float32x2_t *)a1[112];
      v19[0] = (float32x2_t)&off_10184D7B0;
      v19[1] = v9;
      float v20 = v10 - v8;
      sub_100E2ADA0(v16, v19);
      if ((a1[113].i32[1] & 7) == 1) {
        sub_100E2AF74((uint64_t)a1, a4);
      }
      v17[0] = &off_10184D7B0;
      v17[1] = a2[1];
      __int32 v18 = a2[2].i32[0];
      sub_100E2B488((uint64_t)a1, (float *)v17, a3);
    }

    else
    {
      a1[113].i32[1] = 0;
      sub_100E2BD44(a1);
    }
  }

void sub_100E2AF74(uint64_t a1, double a2)
{
  int v4 = *(float32x2_t **)(a1 + 896);
  float32x2_t v5 = vmul_f32(vadd_f32(v4[2], *(float32x2_t *)(a1 + 992)), (float32x2_t)vdup_n_s32(0x3C8EFA35u));
  float v6 = (float)(v4[3].f32[0] + *(float *)(a1 + 1000)) * 0.017453;
  unint64_t v7 = *(void *)(a1 + 656);
  if ((int)v7 >= 2)
  {
    float v10 = 0.0;
    float v11 = 0.0;
    unint64_t v12 = *(void *)(a1 + 728);
    if (v12) {
      float v11 = *(float *)(a1 + 680) / (float)v12;
    }
    unint64_t v13 = *(void *)(a1 + 800);
    if (v13) {
      float v10 = *(float *)(a1 + 752) / (float)v13;
    }
    unint64_t v14 = *(void *)(a1 + 648);
    unint64_t v15 = *(void *)(a1 + 720);
    uint64_t v16 = *(void *)(a1 + 656);
    float32x2_t v17 = 0LL;
    unint64_t v18 = *(void *)(a1 + 792);
    float v19 = 0.0;
    float v20 = 0.0;
    int32x2_t v21 = 0LL;
    *(float *)&v22.i32[1] = v11;
    do
    {
      v23.i32[0] = *(_DWORD *)(*(void *)(*(void *)(a1 + 624) + ((v14 >> 7) & 0x1FFFFFFFFFFFFF8LL))
                             + 4 * (v14 & 0x3FF));
      v23.i32[1] = *(_DWORD *)(*(void *)(*(void *)(a1 + 696) + ((v15 >> 7) & 0x1FFFFFFFFFFFFF8LL))
                             + 4 * (v15 & 0x3FF));
      *(float *)v22.i32 = *(float *)(a1 + 608) / (float)v7;
      float32x2_t v24 = vsub_f32(v23, (float32x2_t)v22);
      float32x2_t v17 = vmla_f32(v17, v24, v24);
      float v19 = v19 + (float)(v25 * v25);
      int32x2_t v21 = (int32x2_t)vadd_f32((float32x2_t)v21, v24);
      float v20 = v20 + v25;
      ++v18;
      ++v15;
      ++v14;
      --v16;
    }

    while (v16);
    float32x2_t v26 = vmul_f32((float32x2_t)v21, (float32x2_t)v21);
    *(float *)v22.i32 = (float)(int)v7;
    *(float *)v21.i32 = (float)((int)v7 - 1);
    float32x2_t v27 = vdiv_f32(vsub_f32(v17, vdiv_f32(v26, (float32x2_t)vdup_lane_s32(v22, 0))), (float32x2_t)vdup_lane_s32(v21, 0));
    float32x2_t v28 = (float32x2_t)vdup_n_s32(0x3C8EFA35u);
    float32x2_t v8 = vmul_f32(vmul_f32(v27, v28), v28);
  }

  else
  {
    float32x2_t v8 = 0LL;
    float v9 = 0.0;
  }

  *(float32x2_t *)(a1 + 1040) = v5;
  *(float *)(a1 + 1048) = v6;
  *(float32x2_t *)(a1 + 1052) = v8;
  *(float *)(a1 + 1060) = v9;
  *(_BYTE *)(a1 + 1064) = 1;
  uint64_t v29 = *(void *)(a1 + 1080);
  if (v29 != a1 + 1072)
  {
    double v30 = v5.f32[0];
    double v31 = v5.f32[1];
    double v32 = v6;
    double v33 = v8.f32[0];
    double v34 = v8.f32[1];
    double v35 = v9;
    do
    {
      if (*(_BYTE *)(v29 + 32) || !*(_BYTE *)(a1 + 1024))
      {
        (*(void (**)(void))(*(void *)(v29 + 24) + 16LL))();
        if (qword_101934590 != -1) {
          dispatch_once(&qword_101934590, &stru_101886570);
        }
        int v36 = (os_log_s *)off_101934598;
        if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_DEBUG))
        {
          double v37 = *(float *)(a1 + 928);
          __int32 v38 = *(float **)(a1 + 896);
          double v39 = v38[4];
          double v40 = v38[5];
          double v41 = v38[6];
          uint64_t v42 = *(void *)(v29 + 16);
          *(_DWORD *)__int128 buf = 134351872;
          double v77 = a2;
          __int16 v78 = 2050;
          double v79 = v37;
          __int16 v80 = 2050;
          double v81 = v30;
          __int16 v82 = 2050;
          double v83 = v31;
          __int16 v84 = 2050;
          double v85 = v32;
          __int16 v86 = 2050;
          double v87 = v39;
          __int16 v88 = 2050;
          double v89 = v40;
          __int16 v90 = 2050;
          double v91 = v41;
          __int16 v92 = 2050;
          double v93 = v33;
          __int16 v94 = 2050;
          double v95 = v34;
          __int16 v96 = 2050;
          double v97 = v35;
          __int16 v98 = 2050;
          uint64_t v99 = v42;
          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEBUG,  "[CLGBE] GyroBias,time,%{public}f,temperature,%{public}f,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{public} f,dbias.x,%{public}f,dbias.y,%{public}f,dbias.z,%{public}f,var.x,%{public}f,var.y,%{public}f,var.z,%{public} f,client,%{public}p",  buf,  0x7Au);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934590 != -1) {
            dispatch_once(&qword_101934590, &stru_101886570);
          }
          double v43 = *(float *)(a1 + 928);
          __int16 v44 = *(float **)(a1 + 896);
          double v45 = v44[4];
          double v46 = v44[5];
          double v47 = v44[6];
          uint64_t v48 = *(void *)(v29 + 16);
          int v52 = 134351872;
          double v53 = a2;
          __int16 v54 = 2050;
          double v55 = v43;
          __int16 v56 = 2050;
          double v57 = v30;
          __int16 v58 = 2050;
          double v59 = v31;
          __int16 v60 = 2050;
          double v61 = v32;
          __int16 v62 = 2050;
          double v63 = v45;
          __int16 v64 = 2050;
          double v65 = v46;
          __int16 v66 = 2050;
          double v67 = v47;
          __int16 v68 = 2050;
          double v69 = v33;
          __int16 v70 = 2050;
          double v71 = v34;
          __int16 v72 = 2050;
          double v73 = v35;
          __int16 v74 = 2050;
          uint64_t v75 = v48;
          LODWORD(v51) = 122;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  2LL,  "[CLGBE] GyroBias,time,%{public}f,temperature,%{public}f,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{public} f,dbias.x,%{public}f,dbias.y,%{public}f,dbias.z,%{public}f,var.x,%{public}f,var.y,%{public}f,var.z,%{public} f,client,%{public}p",  &v52,  v51);
          __int16 v50 = (uint8_t *)v49;
          sub_10029211C("Generic", 1LL, 0, 2LL, "void CLGyroBiasEstimator::notifyClients(CFTimeInterval)", "%s\n", v49);
          if (v50 != buf) {
            free(v50);
          }
        }
      }

      uint64_t v29 = *(void *)(v29 + 8);
    }

    while (v29 != a1 + 1072);
  }

void sub_100E2B488(uint64_t a1, float *a2, float a3)
{
  float v78 = a3;
  float32x2_t v5 = (void *)(a1 + 808);
  sub_10074DC40(a1 + 808, &v78);
  float v6 = sub_100E2BC04(v5);
  float v7 = sub_100E2BCA4(v5);
  if ((float)(v6 - v7) > 2.0)
  {
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    float32x2_t v8 = (os_log_s *)off_101934598;
    if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134349312;
      double v86 = v6;
      __int16 v87 = 2050;
      double v88 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "[CLGBE] #Warning Temperature is changing too quickly, clearing GYTT buffers,max,%{public}f,min,%{public}f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934590 != -1) {
        dispatch_once(&qword_101934590, &stru_101886570);
      }
      int v79 = 134349312;
      double v80 = v6;
      __int16 v81 = 2050;
      double v82 = v7;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  16LL,  "[CLGBE] #Warning Temperature is changing too quickly, clearing GYTT buffers,max,%{public}f,min,%{public}f",  &v79,  22);
      double v69 = (uint8_t *)v68;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLGyroBiasEstimator::tryBuildGYTT(CLVector3d<float>, float)",  "%s\n",  v68);
      if (v69 != buf) {
        free(v69);
      }
    }

    sub_100E2BD44((void *)a1);
    sub_10074DC40((uint64_t)v5, &v78);
  }

  sub_10074DC40(a1 + 592, a2 + 2);
  sub_10074DC40(a1 + 664, a2 + 3);
  sub_10074DC40(a1 + 736, a2 + 4);
  unint64_t v9 = *(void *)(a1 + 656);
  float v10 = 0.0;
  float v11 = 0.0;
  float v12 = 0.0;
  if ((int)v9 >= 2)
  {
    unint64_t v13 = *(void *)(a1 + 728);
    float v14 = 0.0;
    float v15 = 0.0;
    if (v13) {
      float v15 = *(float *)(a1 + 680) / (float)v13;
    }
    unint64_t v16 = *(void *)(a1 + 800);
    if (v16) {
      float v14 = *(float *)(a1 + 752) / (float)v16;
    }
    unint64_t v17 = *(void *)(a1 + 648);
    uint64_t v18 = *(void *)(a1 + 656);
    float v19 = 0.0;
    float v20 = 0.0;
    float v21 = 0.0;
    float v22 = 0.0;
    unint64_t v23 = *(void *)(a1 + 720);
    float v24 = 0.0;
    float v25 = 0.0;
    unint64_t v26 = *(void *)(a1 + 792);
    do
    {
      float v21 = v21 + (float)(v27 * v27);
      float v20 = v20 + (float)(v28 * v28);
      float v19 = v19 + (float)(v29 * v29);
      float v25 = v25 + v27;
      float v24 = v24 + v28;
      float v22 = v22 + v29;
      ++v26;
      ++v23;
      ++v17;
      --v18;
    }

    while (v18);
    float v30 = v21 - (float)((float)(v25 * v25) / (float)(int)v9);
    float v31 = (float)((int)v9 - 1);
    float v10 = v30 / v31;
    float v11 = (float)(v20 - (float)((float)(v24 * v24) / (float)(int)v9)) / v31;
    float v12 = (float)(v19 - (float)((float)(v22 * v22) / (float)(int)v9)) / v31;
  }

  if (*(void *)(a1 + 584) < 0x21uLL || (float)((float)(v10 + v11) + v12) <= 0.012)
  {
    if (v9 < *(void *)(a1 + 600)) {
      return;
    }
    float v35 = 0.0;
    float v36 = 0.0;
    if (v9) {
      float v36 = *(float *)(a1 + 608) / (float)v9;
    }
    unint64_t v37 = *(void *)(a1 + 728);
    if (v37) {
      float v35 = *(float *)(a1 + 680) / (float)v37;
    }
    unint64_t v38 = *(void *)(a1 + 800);
    float v39 = 0.0;
    float v40 = 0.0;
    if (v38) {
      float v40 = *(float *)(a1 + 752) / (float)v38;
    }
    float v41 = 0.0;
    float v42 = 0.0;
    if ((int)v9 >= 2)
    {
      unint64_t v43 = *(void *)(a1 + 648);
      uint64_t v44 = *(void *)(a1 + 656);
      float v45 = 0.0;
      uint64_t v46 = v44;
      float v47 = 0.0;
      do
      {
        float v45 = v45 + (float)(v48 * v48);
        float v47 = v47 + v48;
        ++v43;
        --v46;
      }

      while (v46);
      float v49 = (float)(int)v9;
      float v50 = v45 - (float)((float)(v47 * v47) / (float)(int)v9);
      float v51 = (float)((int)v9 - 1);
      float v52 = 0.0;
      float v53 = 0.0;
      if (v37) {
        float v53 = *(float *)(a1 + 680) / (float)v37;
      }
      unint64_t v54 = *(void *)(a1 + 720);
      uint64_t v55 = *(void *)(a1 + 656);
      float v56 = 0.0;
      float v41 = v50 / v51;
      do
      {
        float v52 = v52 + (float)(v57 * v57);
        float v56 = v56 + v57;
        ++v54;
        --v55;
      }

      while (v55);
      float v58 = v52 - (float)((float)(v56 * v56) / v49);
      float v59 = 0.0;
      float v60 = 0.0;
      if (v38) {
        float v60 = *(float *)(a1 + 752) / (float)v38;
      }
      unint64_t v61 = *(void *)(a1 + 792);
      float v62 = 0.0;
      float v39 = v58 / v51;
      do
      {
        float v59 = v59 + (float)(v63 * v63);
        float v62 = v62 + v63;
        ++v61;
        --v44;
      }

      while (v44);
      float v42 = (float)(v59 - (float)((float)(v62 * v62) / v49)) / v51;
    }

    unint64_t v64 = *(void *)(a1 + 872);
    if (v64) {
      double v65 = (float)(*(float *)(a1 + 824) / (float)v64);
    }
    else {
      double v65 = 0.0;
    }
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    id v67 = objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "vendor"), "proxyForService:", @"CLGyroCalibrationDatabase");
    v71[0] = _NSConcreteStackBlock;
    v71[1] = 3221225472LL;
    _OWORD v71[2] = sub_100E2BD7C;
    v71[3] = &unk_101886520;
    float v72 = v36;
    float v73 = v35;
    float v74 = v40;
    float v75 = v41;
    float v76 = v39;
    float v77 = v42;
    *(double *)&v71[4] = v65;
    *(CFAbsoluteTime *)&v71[5] = Current;
    [v67 doAsync:v71];
  }

  else if (*(_BYTE *)(a1 + 1008))
  {
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    double v32 = (os_log_s *)off_101934598;
    if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134349568;
      double v86 = v10;
      __int16 v87 = 2050;
      double v88 = v11;
      __int16 v89 = 2050;
      double v90 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_ERROR,  "[CLGBE] #Warning Could not insert GYTT because bump was detected,variance.x,%{public}f,y,%{public}f,z,%{public}f",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934590 != -1) {
        dispatch_once(&qword_101934590, &stru_101886570);
      }
      int v79 = 134349568;
      double v80 = v10;
      __int16 v81 = 2050;
      double v82 = v11;
      __int16 v83 = 2050;
      double v84 = v12;
      LODWORD(v70) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  16LL,  "[CLGBE] #Warning Could not insert GYTT because bump was detected,variance.x,%{public}f,y,%{public}f,z,%{public}f",  &v79,  v70);
      double v34 = (uint8_t *)v33;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLGyroBiasEstimator::tryBuildGYTT(CLVector3d<float>, float)",  "%s\n",  v33);
      if (v34 != buf) {
        free(v34);
      }
    }
  }

  sub_100E2BD44((void *)a1);
}

float sub_100E2BC04(void *a1)
{
  uint64_t v1 = a1[4];
  if (a1[5] == v1) {
    goto LABEL_12;
  }
  unint64_t v2 = a1[7];
  int v3 = (float **)(v1 + 8 * (v2 >> 10));
  int v4 = *v3;
  uint64_t v5 = (uint64_t)&(*v3)[v2 & 0x3FF];
  unint64_t v6 = a1[8] + v2;
  unint64_t v7 = v6 >> 10;
  uint64_t v8 = *(void *)(v1 + 8 * (v6 >> 10));
  uint64_t v9 = v6 & 0x3FF;
  float v10 = (float *)(v8 + 4 * v9);
  if ((float *)v5 != v10)
  {
    float v11 = &(*v3)[a1[7] & 0x3FFLL];
    while (1)
    {
      if ((char *)++v11 - (char *)v4 == 4096)
      {
        float v12 = v3[1];
        ++v3;
        int v4 = v12;
        float v11 = v12;
      }

      if (v11 == v10) {
        break;
      }
    }
  }

  if (v5 == *(void *)(v1 + 8 * v7) + 4 * v9) {
LABEL_12:
  }
    sub_101272888();
  return *(float *)v5;
}

float sub_100E2BCA4(void *a1)
{
  uint64_t v1 = a1[4];
  if (a1[5] == v1) {
    goto LABEL_12;
  }
  unint64_t v2 = a1[7];
  int v3 = (float **)(v1 + 8 * (v2 >> 10));
  int v4 = *v3;
  uint64_t v5 = (uint64_t)&(*v3)[v2 & 0x3FF];
  unint64_t v6 = a1[8] + v2;
  unint64_t v7 = v6 >> 10;
  uint64_t v8 = *(void *)(v1 + 8 * (v6 >> 10));
  uint64_t v9 = v6 & 0x3FF;
  float v10 = (float *)(v8 + 4 * v9);
  if (v10 != (float *)v5)
  {
    float v11 = &(*v3)[a1[7] & 0x3FFLL];
    while (1)
    {
      if ((char *)++v11 - (char *)v4 == 4096)
      {
        float v12 = v3[1];
        ++v3;
        int v4 = v12;
        float v11 = v12;
      }

      if (v11 == v10) {
        break;
      }
    }
  }

  if (v5 == *(void *)(v1 + 8 * v7) + 4 * v9) {
LABEL_12:
  }
    sub_1012729FC();
  return *(float *)v5;
}

void sub_100E2BD44(void *a1)
{
}

void sub_100E2BD7C(uint64_t a1, uint64_t a2)
{
  float v3 = *(double *)(a1 + 32);
  (*(void (**)(uint64_t, uint64_t, uint64_t, float, double))(*(void *)a2 + 208LL))( a2,  a1 + 48,  a1 + 60,  v3,  *(double *)(a1 + 40));
  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  int v4 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_DEFAULT))
  {
    double v5 = *(float *)(a1 + 48);
    double v6 = *(float *)(a1 + 52);
    double v7 = *(float *)(a1 + 56);
    double v8 = *(float *)(a1 + 60);
    double v9 = *(float *)(a1 + 64);
    double v10 = *(float *)(a1 + 68);
    uint64_t v11 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 134350592;
    double v36 = v5;
    __int16 v37 = 2050;
    double v38 = v6;
    __int16 v39 = 2050;
    double v40 = v7;
    __int16 v41 = 2050;
    double v42 = v8;
    __int16 v43 = 2050;
    double v44 = v9;
    __int16 v45 = 2050;
    double v46 = v10;
    __int16 v47 = 2050;
    uint64_t v48 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "[CLGBE] Bias estimate inserted: bias,%{public}f,%{public}f,%{public}f,variance,%{public}f,%{public}f,%{public}f,te mperature,%{public}f",  buf,  0x48u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    double v12 = *(float *)(a1 + 48);
    double v13 = *(float *)(a1 + 52);
    double v14 = *(float *)(a1 + 56);
    double v15 = *(float *)(a1 + 60);
    double v16 = *(float *)(a1 + 64);
    double v17 = *(float *)(a1 + 68);
    uint64_t v18 = *(void *)(a1 + 32);
    int v21 = 134350592;
    double v22 = v12;
    __int16 v23 = 2050;
    double v24 = v13;
    __int16 v25 = 2050;
    double v26 = v14;
    __int16 v27 = 2050;
    double v28 = v15;
    __int16 v29 = 2050;
    double v30 = v16;
    __int16 v31 = 2050;
    double v32 = v17;
    __int16 v33 = 2050;
    uint64_t v34 = v18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  0LL,  "[CLGBE] Bias estimate inserted: bias,%{public}f,%{public}f,%{public}f,variance,%{public}f,%{public}f,%{public}f,te mperature,%{public}f",  &v21,  72);
    float v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGyroBiasEstimator::tryBuildGYTT(CLVector3d<float>, float)_block_invoke",  "%s\n",  v19);
    if (v20 != buf) {
      free(v20);
    }
  }

void sub_100E2C000(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a2 == 1)
  {
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    int v4 = (os_log_s *)off_101934598;
    if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_DEBUG))
    {
      double v5 = *(float *)(a2 + 32);
      double v6 = *(float *)(a2 + 36);
      double v7 = *(float *)(a2 + 40);
      double v8 = *(float *)(a2 + 44);
      double v9 = *(float *)(a2 + 48);
      double v10 = *(float *)(a2 + 52);
      uint64_t v11 = *(void *)(a2 + 8);
      *(_DWORD *)__int128 buf = 134350592;
      double v39 = v5;
      __int16 v40 = 2050;
      double v41 = v6;
      __int16 v42 = 2050;
      double v43 = v7;
      __int16 v44 = 2050;
      double v45 = v8;
      __int16 v46 = 2050;
      double v47 = v9;
      __int16 v48 = 2050;
      double v49 = v10;
      __int16 v50 = 2050;
      uint64_t v51 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "[CLGBE] GyroBiasFit,slope.x,%{public}f,slope.y,%{public}f,slope.z,%{public}f,intercept.x,%{public}f,intercept.y, %{public}f,intercept.z,%{public}f,lastMiniCal,%{public}f",  buf,  0x48u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934590 != -1) {
        dispatch_once(&qword_101934590, &stru_101886570);
      }
      double v13 = *(float *)(a2 + 32);
      double v14 = *(float *)(a2 + 36);
      double v15 = *(float *)(a2 + 40);
      double v16 = *(float *)(a2 + 44);
      double v17 = *(float *)(a2 + 48);
      double v18 = *(float *)(a2 + 52);
      uint64_t v19 = *(void *)(a2 + 8);
      int v24 = 134350592;
      double v25 = v13;
      __int16 v26 = 2050;
      double v27 = v14;
      __int16 v28 = 2050;
      double v29 = v15;
      __int16 v30 = 2050;
      double v31 = v16;
      __int16 v32 = 2050;
      double v33 = v17;
      __int16 v34 = 2050;
      double v35 = v18;
      __int16 v36 = 2050;
      uint64_t v37 = v19;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  2LL,  "[CLGBE] GyroBiasFit,slope.x,%{public}f,slope.y,%{public}f,slope.z,%{public}f,intercept.x,%{public}f,intercept.y, %{public}f,intercept.z,%{public}f,lastMiniCal,%{public}f",  &v24,  72);
      int v21 = (uint8_t *)v20;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGyroBiasEstimator::feedGyroBiasFit(CLMotionTypeGyroBiasFit)",  "%s\n",  v20);
      if (v21 != buf) {
        free(v21);
      }
    }

    if (!*(_BYTE *)(a1 + 1008)) {
      *(_DWORD *)(a1 + 932) = 1080033280;
    }
    *(void *)(a1 + 944) = *(void *)(a2 + 32);
    *(_DWORD *)(a1 + 952) = *(_DWORD *)(a2 + 40);
    *(void *)(a1 + 968) = *(void *)(a2 + 44);
    *(_DWORD *)(a1 + 976) = *(_DWORD *)(a2 + 52);
  }

  else
  {
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    double v12 = (os_log_s *)off_101934598;
    if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "[CLGBE] Expected linear fit.", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934590 != -1) {
        dispatch_once(&qword_101934590, &stru_101886570);
      }
      LOWORD(v24) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  16LL,  "[CLGBE] Expected linear fit.",  &v24,  2);
      __int16 v23 = (uint8_t *)v22;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLGyroBiasEstimator::feedGyroBiasFit(CLMotionTypeGyroBiasFit)",  "%s\n",  v22);
      if (v23 != buf) {
        free(v23);
      }
    }
  }

void sub_100E2C3D4(uint64_t a1, uint64_t *a2)
{
  *(_OWORD *)double v29 = *(_OWORD *)((char *)a2 + 12);
  *(void *)&v29[16] = *(uint64_t *)((char *)a2 + 28);
  BOOL v30 = *((_BYTE *)a2 + 9) != 0;
  *(_DWORD *)(a1 + 1048) = *(_DWORD *)&v29[8];
  *(void *)(a1 + 1040) = *(void *)v29;
  *(_DWORD *)(a1 + 1060) = *(_DWORD *)&v29[20];
  *(void *)(a1 + 1052) = *(void *)&v29[12];
  *(_BYTE *)(a1 + 1064) = 1;
  float v4 = *((float *)a2 + 9);
  uint64_t v5 = *a2;
  uint64_t v6 = a1 + 1072;
  uint64_t v7 = *(void *)(a1 + 1080);
  if (v7 != a1 + 1072)
  {
    do
    {
      if (!*(_BYTE *)(v7 + 32))
      {
        (*(void (**)(void))(*(void *)(v7 + 24) + 16LL))();
        if (qword_101934590 != -1) {
          dispatch_once(&qword_101934590, &stru_101886570);
        }
        double v8 = (os_log_s *)off_101934598;
        if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v9 = *(void *)(v7 + 16);
          *(_DWORD *)__int128 buf = 134350848;
          double v48 = v4;
          __int16 v49 = 2050;
          double v50 = *(float *)v29;
          __int16 v51 = 2050;
          double v52 = *(float *)&v29[4];
          __int16 v53 = 2050;
          double v54 = *(float *)&v29[8];
          __int16 v55 = 2050;
          double v56 = *(float *)&v29[12];
          __int16 v57 = 2050;
          double v58 = *(float *)&v29[16];
          __int16 v59 = 2050;
          double v60 = *(float *)&v29[20];
          __int16 v61 = 2050;
          uint64_t v62 = v9;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "[CLGBE] SPUGyroBias,temperature,%{public}f,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{public}f,var.x,%{pub lic}f,var.y,%{public}f,var.z,%{public}f,client,%{public}p",  buf,  0x52u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934590 != -1) {
            dispatch_once(&qword_101934590, &stru_101886570);
          }
          uint64_t v10 = *(void *)(v7 + 16);
          int v31 = 134350848;
          double v32 = v4;
          __int16 v33 = 2050;
          double v34 = *(float *)v29;
          __int16 v35 = 2050;
          double v36 = *(float *)&v29[4];
          __int16 v37 = 2050;
          double v38 = *(float *)&v29[8];
          __int16 v39 = 2050;
          double v40 = *(float *)&v29[12];
          __int16 v41 = 2050;
          double v42 = *(float *)&v29[16];
          __int16 v43 = 2050;
          double v44 = *(float *)&v29[20];
          __int16 v45 = 2050;
          uint64_t v46 = v10;
          LODWORD(v23) = 82;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  2LL,  "[CLGBE] SPUGyroBias,temperature,%{public}f,bias.x,%{public}f,bias.y,%{public}f,bias.z,%{public}f,var.x,%{pub lic}f,var.y,%{public}f,var.z,%{public}f,client,%{public}p",  &v31,  v23);
          double v12 = (uint8_t *)v11;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGyroBiasEstimator::notifySPUClients(const CLMotionCoprocessorInterface::GyroBiasAndVariance *)",  "%s\n",  v11);
          if (v12 != buf) {
            free(v12);
          }
        }
      }

      uint64_t v7 = *(void *)(v7 + 8);
    }

    while (v7 != v6);
  }

  if (!*(_BYTE *)(a1 + 1008))
  {
    int v13 = *((unsigned __int8 *)a2 + 10);
    if ((sub_1004FC57C() & v13) == 1)
    {
      if (qword_101934590 != -1) {
        dispatch_once(&qword_101934590, &stru_101886570);
      }
      double v14 = (os_log_s *)off_101934598;
      if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "[CLGBE] Ignoring bias estimate during charging",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934590 != -1) {
          dispatch_once(&qword_101934590, &stru_101886570);
        }
        LOWORD(v31) = 0;
        LODWORD(v23) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  2LL,  "[CLGBE] Ignoring bias estimate during charging",  &v31,  v23);
        double v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGyroBiasEstimator::notifySPUClients(const CLMotionCoprocessorInterface::GyroBiasAndVariance *)",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }
    }

    else
    {
      float v17 = *((float *)a2 + 5);
      float v18 = *((float *)a2 + 8);
      float32x2_t v19 = *(float32x2_t *)((char *)a2 + 12);
      float32x2_t v20 = (float32x2_t)a2[3];
      id v21 = objc_msgSend( objc_msgSend(*(id *)(a1 + 8), "vendor"),  "proxyForService:",  @"CLGyroCalibrationDatabase");
      float32x2_t v22 = (float32x2_t)vdup_n_s32(0x42652EE1u);
      v24[1] = 3221225472LL;
      v24[0] = _NSConcreteStackBlock;
      __n128 v24[2] = sub_100E2C908;
      void v24[3] = &unk_101886540;
      v24[5] = vmul_f32(v19, v22);
      float v25 = v17 * 57.296;
      float32x2_t v26 = vmul_f32(vmul_f32(v20, v22), v22);
      float v27 = (float)(v18 * 57.296) * 57.296;
      float v28 = v4;
      _DWORD v24[4] = v5;
      [v21 doAsync:v24];
    }
  }

void sub_100E2C908(uint64_t a1, uint64_t a2)
{
  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  float v3 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_DEBUG))
  {
    double v4 = *(float *)(a1 + 40);
    double v5 = *(float *)(a1 + 44);
    double v6 = *(float *)(a1 + 48);
    double v7 = *(float *)(a1 + 52);
    double v8 = *(float *)(a1 + 56);
    double v9 = *(float *)(a1 + 60);
    double v10 = *(float *)(a1 + 64);
    *(_DWORD *)__int128 buf = 134350592;
    double v35 = v4;
    __int16 v36 = 2050;
    double v37 = v5;
    __int16 v38 = 2050;
    double v39 = v6;
    __int16 v40 = 2050;
    double v41 = v7;
    __int16 v42 = 2050;
    double v43 = v8;
    __int16 v44 = 2050;
    double v45 = v9;
    __int16 v46 = 2050;
    double v47 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "[CLGBE] SPU bias estimate inserted: bias,%{public}f,%{public}f,%{public}f,variance,%{public}f,%{public}f,%{public} f,temperature,%{public}f",  buf,  0x48u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    double v11 = *(float *)(a1 + 40);
    double v12 = *(float *)(a1 + 44);
    double v13 = *(float *)(a1 + 48);
    double v14 = *(float *)(a1 + 52);
    double v15 = *(float *)(a1 + 56);
    double v16 = *(float *)(a1 + 60);
    double v17 = *(float *)(a1 + 64);
    int v20 = 134350592;
    double v21 = v11;
    __int16 v22 = 2050;
    double v23 = v12;
    __int16 v24 = 2050;
    double v25 = v13;
    __int16 v26 = 2050;
    double v27 = v14;
    __int16 v28 = 2050;
    double v29 = v15;
    __int16 v30 = 2050;
    double v31 = v16;
    __int16 v32 = 2050;
    double v33 = v17;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  2LL,  "[CLGBE] SPU bias estimate inserted: bias,%{public}f,%{public}f,%{public}f,variance,%{public}f,%{public}f,%{public} f,temperature,%{public}f",  &v20,  72);
    float32x2_t v19 = (uint8_t *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLGyroBiasEstimator::notifySPUClients(const CLMotionCoprocessorInterface::GyroBiasAndVariance *)_block_invoke",  "%s\n",  v18);
    if (v19 != buf) {
      free(v19);
    }
  }

void sub_100E2CB94(id a1)
{
  off_101934598 = os_log_create("com.apple.locationd.Motion", "Gyro");
}

void *sub_100E2CBC8()
{
  float32x2_t result = operator new(0x10uLL);
  *float32x2_t result = &off_1018865A0;
  return result;
}

void sub_100E2CBEC(uint64_t a1, void *a2)
{
  *a2 = &off_1018865A0;
}

uint64_t sub_100E2CC04(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  float v3 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "[CLGBE] Registering for gyro notifications",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    v8[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Registering for gyro notifications",  v8,  2);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLGyroBiasEstimator::registerInputNotificationsInternal()::(anonymous class)::operator()(auto *) const [dispa tcher:auto = CLMotionNotifier::CallbackDispatcher<CLGyro::Sample>]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  uint64_t v4 = sub_1006FE6A0();
  return sub_1006DCB40(v4, 0, v2, 0.02);
}

uint64_t sub_100E2CDAC(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E2CDE8()
{
}

void *sub_100E2CDFC()
{
  float32x2_t result = operator new(0x10uLL);
  *float32x2_t result = &off_101886630;
  return result;
}

void sub_100E2CE20(uint64_t a1, void *a2)
{
  *a2 = &off_101886630;
}

void sub_100E2CE38(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  float v3 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "[CLGBE] Unregistering for gyro notifications",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    v7[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Unregistering for gyro notifications",  v7,  2);
    double v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLGyroBiasEstimator::registerInputNotificationsInternal()::(anonymous class)::operator()(auto *) const [dispa tcher:auto = CLMotionNotifier::CallbackDispatcher<CLGyro::Sample>]",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  uint64_t v4 = sub_1006FE6A0();
  sub_1006DD2A0(v4, 0, v2);
}

uint64_t sub_100E2CFD8(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E2D014()
{
}

void *sub_100E2D020(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = off_1018A2210;
  a1[2] = a4;
  a1[3] = a5;
  *a1 = off_1018866C0;
  a1[1] = 0LL;
  double v7 = a1 + 4;
  a1[7] = 0LL;
  double v12 = a1;
  uint64_t v8 = *(void *)(a2 + 24);
  if (!v8) {
    sub_100008BDC();
  }
  else {
    double v14 = 0LL;
  }
  sub_100021B50(v7, (uint64_t)v13);
  double v9 = v14;
  if (v14 == v13)
  {
    uint64_t v10 = 4LL;
    double v9 = v13;
    goto LABEL_9;
  }

  if (v14)
  {
    uint64_t v10 = 5LL;
LABEL_9:
    (*(void (**)(void *))(*v9 + 8 * v10))(v9);
  }

  return a1;
}

void sub_100E2D13C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2D194(void *a1)
{
  uint64_t v1 = (void *)sub_100E2D1A8(a1);
  operator delete(v1);
}

uint64_t sub_100E2D1A8(void *a1)
{
  *a1 = off_1018866C0;
  uint64_t v2 = a1[7];
  if (v2)
  {
    double v6 = a1;
    (*(void (**)(uint64_t, void **))(*(void *)v2 + 48LL))(v2, &v6);
    float v3 = (void *)a1[7];
    if (v3 == a1 + 4)
    {
      uint64_t v4 = 4LL;
      float v3 = a1 + 4;
      goto LABEL_6;
    }

    if (v3)
    {
      uint64_t v4 = 5LL;
LABEL_6:
      (*(void (**)(void))(*v3 + 8 * v4))();
    }
  }

  return sub_1011C07F8((uint64_t)a1);
}

void *sub_100E2D23C()
{
  float32x2_t result = operator new(0x10uLL);
  *float32x2_t result = &off_101886710;
  return result;
}

void sub_100E2D260(uint64_t a1, void *a2)
{
  *a2 = &off_101886710;
}

uint64_t sub_100E2D278(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  float v3 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "[CLGBE] Registering for gyro temperature notifications",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    v8[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Registering for gyro temperature notifications",  v8,  2);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLGyroBiasEstimator::registerInputNotificationsInternal()::(anonymous class)::operator()(auto *) const [dispa tcher:auto = CLMotionNotifier::CallbackDispatcher<CLGyro::Temperature>]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  uint64_t v4 = sub_1006FE6A0();
  return sub_1006DCB40(v4, 1, v2, 1.0);
}

uint64_t sub_100E2D41C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E2D458()
{
}

void *sub_100E2D46C()
{
  float32x2_t result = operator new(0x10uLL);
  *float32x2_t result = &off_1018867A0;
  return result;
}

void sub_100E2D490(uint64_t a1, void *a2)
{
  *a2 = &off_1018867A0;
}

void sub_100E2D4A8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  float v3 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "[CLGBE] Unregistering for gyro temperature notifications",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    v7[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Unregistering for gyro temperature notifications",  v7,  2);
    double v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLGyroBiasEstimator::registerInputNotificationsInternal()::(anonymous class)::operator()(auto *) const [dispa tcher:auto = CLMotionNotifier::CallbackDispatcher<CLGyro::Temperature>]",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  uint64_t v4 = sub_1006FE6A0();
  sub_1006DD2A0(v4, 1, v2);
}

uint64_t sub_100E2D648(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E2D684()
{
}

void *sub_100E2D690(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = off_1018A2210;
  a1[2] = a4;
  a1[3] = a5;
  *a1 = off_101886830;
  a1[1] = 0LL;
  double v7 = a1 + 4;
  a1[7] = 0LL;
  double v12 = a1;
  uint64_t v8 = *(void *)(a2 + 24);
  if (!v8) {
    sub_100008BDC();
  }
  else {
    double v14 = 0LL;
  }
  sub_100021B50(v7, (uint64_t)v13);
  double v9 = v14;
  if (v14 == v13)
  {
    uint64_t v10 = 4LL;
    double v9 = v13;
    goto LABEL_9;
  }

  if (v14)
  {
    uint64_t v10 = 5LL;
LABEL_9:
    (*(void (**)(void *))(*v9 + 8 * v10))(v9);
  }

  return a1;
}

void sub_100E2D7AC(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2D804(void *a1)
{
  uint64_t v1 = (void *)sub_100E2D818(a1);
  operator delete(v1);
}

uint64_t sub_100E2D818(void *a1)
{
  *a1 = off_101886830;
  uint64_t v2 = a1[7];
  if (v2)
  {
    double v6 = a1;
    (*(void (**)(uint64_t, void **))(*(void *)v2 + 48LL))(v2, &v6);
    float v3 = (void *)a1[7];
    if (v3 == a1 + 4)
    {
      uint64_t v4 = 4LL;
      float v3 = a1 + 4;
      goto LABEL_6;
    }

    if (v3)
    {
      uint64_t v4 = 5LL;
LABEL_6:
      (*(void (**)(void))(*v3 + 8 * v4))();
    }
  }

  return sub_1011C07F8((uint64_t)a1);
}

void *sub_100E2D8AC()
{
  float32x2_t result = operator new(0x10uLL);
  *float32x2_t result = &off_101886880;
  return result;
}

void sub_100E2D8D0(uint64_t a1, void *a2)
{
  *a2 = &off_101886880;
}

uint64_t sub_100E2D8E8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  float v3 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "[CLGBE] Registering for magnetometer notifications",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    v8[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Registering for magnetometer notifications",  v8,  2);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLGyroBiasEstimator::registerInputNotificationsInternal()::(anonymous class)::operator()(auto *) const [dispa tcher:auto = CLMotionNotifier::CallbackDispatcher<CLMagnetometer::Sample>]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  uint64_t v4 = sub_1007C3B70();
  return sub_1006DCB40(v4, 0, v2, 0.025);
}

uint64_t sub_100E2DA90(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E2DACC()
{
}

void *sub_100E2DAE0()
{
  float32x2_t result = operator new(0x10uLL);
  *float32x2_t result = &off_101886910;
  return result;
}

void sub_100E2DB04(uint64_t a1, void *a2)
{
  *a2 = &off_101886910;
}

void sub_100E2DB1C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  float v3 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "[CLGBE] Unregistering for magnetometer notifications",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    v7[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Unregistering for magnetometer notifications",  v7,  2);
    double v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLGyroBiasEstimator::registerInputNotificationsInternal()::(anonymous class)::operator()(auto *) const [dispa tcher:auto = CLMotionNotifier::CallbackDispatcher<CLMagnetometer::Sample>]",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  uint64_t v4 = sub_1007C3B70();
  sub_1006DD2A0(v4, 0, v2);
}

uint64_t sub_100E2DCBC(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E2DCF8()
{
}

void *sub_100E2DD04(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = off_1018A2210;
  a1[2] = a4;
  a1[3] = a5;
  *a1 = off_1018869A0;
  a1[1] = 0LL;
  double v7 = a1 + 4;
  a1[7] = 0LL;
  double v12 = a1;
  uint64_t v8 = *(void *)(a2 + 24);
  if (!v8) {
    sub_100008BDC();
  }
  else {
    double v14 = 0LL;
  }
  sub_100021B50(v7, (uint64_t)v13);
  double v9 = v14;
  if (v14 == v13)
  {
    uint64_t v10 = 4LL;
    double v9 = v13;
    goto LABEL_9;
  }

  if (v14)
  {
    uint64_t v10 = 5LL;
LABEL_9:
    (*(void (**)(void *))(*v9 + 8 * v10))(v9);
  }

  return a1;
}

void sub_100E2DE20(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2DE78(void *a1)
{
  uint64_t v1 = (void *)sub_100E2DE8C(a1);
  operator delete(v1);
}

uint64_t sub_100E2DE8C(void *a1)
{
  *a1 = off_1018869A0;
  uint64_t v2 = a1[7];
  if (v2)
  {
    double v6 = a1;
    (*(void (**)(uint64_t, void **))(*(void *)v2 + 48LL))(v2, &v6);
    float v3 = (void *)a1[7];
    if (v3 == a1 + 4)
    {
      uint64_t v4 = 4LL;
      float v3 = a1 + 4;
      goto LABEL_6;
    }

    if (v3)
    {
      uint64_t v4 = 5LL;
LABEL_6:
      (*(void (**)(void))(*v3 + 8 * v4))();
    }
  }

  return sub_1011C07F8((uint64_t)a1);
}

void *sub_100E2DF20()
{
  float32x2_t result = operator new(0x10uLL);
  *float32x2_t result = &off_1018869F0;
  return result;
}

void sub_100E2DF44(uint64_t a1, void *a2)
{
  *a2 = &off_1018869F0;
}

uint64_t sub_100E2DF5C(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  float v3 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "[CLGBE] Registering for SPU Gyro Bias And Variance",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    v8[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Registering for SPU Gyro Bias And Variance",  v8,  2);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLGyroBiasEstimator::prepareSPUGyroBiasAndVarianceDispatcher()::(anonymous class)::operator()(auto *) const [ dispatcher:auto = CLMotionNotifier::CallbackDispatcher<CLMotionCoprocessorInterface::GyroBiasAndVariance>]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  uint64_t v4 = sub_100358938(0);
  return sub_1006DCB40(v4, 8, v2, -1.0);
}

uint64_t sub_100E2E104(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100E2E140()
{
}

void *sub_100E2E154()
{
  float32x2_t result = operator new(0x10uLL);
  *float32x2_t result = &off_101886A80;
  return result;
}

void sub_100E2E178(uint64_t a1, void *a2)
{
  *a2 = &off_101886A80;
}

void sub_100E2E190(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (qword_101934590 != -1) {
    dispatch_once(&qword_101934590, &stru_101886570);
  }
  float v3 = (os_log_s *)off_101934598;
  if (os_log_type_enabled((os_log_t)off_101934598, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "[CLGBE] Removing SPU Gyro Bias And Variance dispatcher",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934590 != -1) {
      dispatch_once(&qword_101934590, &stru_101886570);
    }
    v7[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  off_101934598,  1LL,  "[CLGBE] Removing SPU Gyro Bias And Variance dispatcher",  v7,  2);
    double v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLGyroBiasEstimator::prepareSPUGyroBiasAndVarianceDispatcher()::(anonymous class)::operator()(auto *) const [ dispatcher:auto = CLMotionNotifier::CallbackDispatcher<CLMotionCoprocessorInterface::GyroBiasAndVariance>]",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  uint64_t v4 = sub_100358938(0);
  sub_1006DD2A0(v4, 8, v2);
}

uint64_t sub_100E2E334(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100E2E370()
{
}

void *sub_100E2E37C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *a1 = off_1018A2210;
  a1[2] = a4;
  a1[3] = a5;
  *a1 = off_101886B10;
  a1[1] = 0LL;
  double v7 = a1 + 4;
  a1[7] = 0LL;
  double v12 = a1;
  uint64_t v8 = *(void *)(a2 + 24);
  if (!v8) {
    sub_100008BDC();
  }
  else {
    double v14 = 0LL;
  }
  sub_100021B50(v7, (uint64_t)v13);
  double v9 = v14;
  if (v14 == v13)
  {
    uint64_t v10 = 4LL;
    double v9 = v13;
    goto LABEL_9;
  }

  if (v14)
  {
    uint64_t v10 = 5LL;
LABEL_9:
    (*(void (**)(void *))(*v9 + 8 * v10))(v9);
  }

  return a1;
}

void sub_100E2E498(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E2E4F0(void *a1)
{
  uint64_t v1 = (void *)sub_100E2E504(a1);
  operator delete(v1);
}

uint64_t sub_100E2E504(void *a1)
{
  *a1 = off_101886B10;
  uint64_t v2 = a1[7];
  if (v2)
  {
    double v6 = a1;
    (*(void (**)(uint64_t, void **))(*(void *)v2 + 48LL))(v2, &v6);
    float v3 = (void *)a1[7];
    if (v3 == a1 + 4)
    {
      uint64_t v4 = 4LL;
      float v3 = a1 + 4;
      goto LABEL_6;
    }

    if (v3)
    {
      uint64_t v4 = 5LL;
LABEL_6:
      (*(void (**)(void))(*v3 + 8 * v4))();
    }
  }

  return sub_1011C07F8((uint64_t)a1);
}

void sub_100E2E590(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void *sub_100E2E5BC(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  if (v3)
  {
    uint64_t v4 = (unint64_t *)(v3 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  a1[2] = 0LL;
  a1[3] = 0LL;
  sub_100E2E618();
  return a1;
}

void sub_100E2E604(_Unwind_Exception *a1)
{
}

uint64_t sub_100E2E618()
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  uint64_t result = sub_1006E2AB4();
  if (Current != (CFRunLoopRef)result) {
    sub_101272B70();
  }
  return result;
}

uint64_t sub_100E2E650(void *a1)
{
  return sub_10000AE14((uint64_t)a1);
}

void sub_100E2E678(void *a1)
{
  if (!*a1) {
    return;
  }
  if (qword_1019344C0 != -1) {
    dispatch_once(&qword_1019344C0, &stru_101886B88);
  }
  uint64_t v2 = (os_log_s *)qword_1019344C8;
  if (os_log_type_enabled((os_log_t)qword_1019344C8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "[CLSPUHIDDriverInterface] Close hid driver interface",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    LOWORD(v14) = 0;
    double v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344C8,  2LL,  "[CLSPUHIDDriverInterface] Close hid driver interface",  &v14,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSPUHIDDriverInterface::closeHIDDriverInterface()", "%s\n", v9);
  }

  uint64_t v3 = (IOCFPlugInInterface **)a1[2];
  uint64_t v4 = a1[3];
  unint64_t v5 = a1 + 2;
  if (v4)
  {
    (*(void (**)(void, void))(*(void *)v4 + 72LL))(a1[3], 0LL);
    if (!v3) {
      goto LABEL_12;
    }
  }

  else if (!v3)
  {
    *(void *)(*a1 + 8LL) = 0LL;
    *unint64_t v5 = 0LL;
    a1[3] = 0LL;
    return;
  }

  ((void (*)(IOCFPlugInInterface **))(*v3)->Release)(v3);
  IODestroyPlugInInterface(v3);
LABEL_12:
  *(void *)(*a1 + 8LL) = 0LL;
  *unint64_t v5 = 0LL;
  a1[3] = 0LL;
  if (qword_1019344C0 != -1) {
    dispatch_once(&qword_1019344C0, &stru_101886B88);
  }
  double v6 = (os_log_s *)qword_1019344C8;
  if (os_log_type_enabled((os_log_t)qword_1019344C8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = a1[2];
    uint64_t v8 = a1[3];
    *(_DWORD *)__int128 buf = 134218752;
    double v23 = v3;
    __int16 v24 = 2048;
    uint64_t v25 = v4;
    __int16 v26 = 2048;
    uint64_t v27 = v7;
    __int16 v28 = 2048;
    uint64_t v29 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[CLSPUHIDDriverInterface] Closed hid driver interface, {cfPlugInInterface, hidDriverInterface} was then {%p,%p}, is now {%p,%p}",  buf,  0x2Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    uint64_t v10 = a1[2];
    uint64_t v11 = a1[3];
    int v14 = 134218752;
    double v15 = v3;
    __int16 v16 = 2048;
    uint64_t v17 = v4;
    __int16 v18 = 2048;
    uint64_t v19 = v10;
    __int16 v20 = 2048;
    uint64_t v21 = v11;
    LODWORD(v13) = 42;
    double v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344C8,  0LL,  "[CLSPUHIDDriverInterface] Closed hid driver interface, {cfPlugInInterface, hidDriverInterface} was t hen {%p,%p}, is now {%p,%p}",  &v14,  v13);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSPUHIDDriverInterface::closeHIDDriverInterface()", "%s\n", v12);
  }

void sub_100E2EA00(uint64_t *a1)
{
  if (qword_1019344C0 != -1) {
    dispatch_once(&qword_1019344C0, &stru_101886B88);
  }
  uint64_t v2 = (os_log_s *)qword_1019344C8;
  if (os_log_type_enabled((os_log_t)qword_1019344C8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "[CLSPUHIDDriverInterface] Open hid driver interface",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    LOWORD(v53) = 0;
    __int16 v36 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344C8,  2LL,  "[CLSPUHIDDriverInterface] Open hid driver interface",  &v53,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSPUHIDDriverInterface::openHIDDriverInterface()", "%s\n", v36);
  }

  uint64_t v3 = *a1;
  if (!*a1) {
    return;
  }
  double v50 = 0LL;
  theInterface = 0LL;
  uint64_t v4 = (__IOHIDServiceClient *)sub_100719C6C(v3);
  if (!v4)
  {
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    __int16 v18 = (os_log_s *)qword_1019344C8;
    if (os_log_type_enabled((os_log_t)qword_1019344C8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "[CLSPUHIDDriverInterface] IoHidDevice is not ready",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    LOWORD(v53) = 0;
    LODWORD(byte15) = 2;
    uint64_t v17 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344C8,  1LL,  "[CLSPUHIDDriverInterface] IoHidDevice is not ready",  &v53,  byte15);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLSPUHIDDriverInterface::openHIDDriverInterface()", "%s\n");
LABEL_35:
    if (v17 == buf) {
      return;
    }
    goto LABEL_36;
  }

  unint64_t v5 = v4;
  RegistryID = (const __CFNumber *)IOHIDServiceClientGetRegistryID(v4);
  CFNumberGetValue(RegistryID, kCFNumberSInt64Type, &valuePtr);
  uint64_t v7 = IORegistryEntryIDMatching(valuePtr);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v7);
  if (!MatchingService)
  {
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    uint64_t v19 = (os_log_s *)qword_1019344C8;
    if (os_log_type_enabled((os_log_t)qword_1019344C8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_FAULT,  "[CLSPUHIDDriverInterface] Service doesn't exist",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    LOWORD(v53) = 0;
    LODWORD(byte15) = 2;
    uint64_t v17 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344C8,  17LL,  "[CLSPUHIDDriverInterface] Service doesn't exist",  &v53,  byte15);
    sub_10029211C("Generic", 1LL, 0, 0LL, "void CLSPUHIDDriverInterface::openHIDDriverInterface()", "%s\n");
    goto LABEL_35;
  }

  io_service_t v9 = MatchingService;
  uint64_t v10 = CFUUIDGetConstantUUIDWithBytes( kCFAllocatorSystemDefault,  0x3Bu,  0xC5u,  0xCCu,  0x87u,  0x84u,  0x5Eu,  0x48u,  0xABu,  0xA9u,  0xC2u,  0x94u,  0x36u,  0,  0x1Bu,  0xA6u,  0x8Au);
  uint64_t v11 = CFUUIDGetConstantUUIDWithBytes( 0LL,  0xC2u,  0x44u,  0xE8u,  0x58u,  0x10u,  0x9Cu,  0x11u,  0xD4u,  0x91u,  0xD4u,  0,  0x50u,  0xE4u,  0xC6u,  0x42u,  0x6Fu);
  mach_error_t v12 = IOCreatePlugInInterfaceForService(v9, v10, v11, &theInterface, (SInt32 *)&v49 + 1);
  IOObjectRelease(v9);
  if (v12)
  {
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    double v13 = (os_log_s *)qword_1019344C8;
    if (os_log_type_enabled((os_log_t)qword_1019344C8, OS_LOG_TYPE_FAULT))
    {
      int v14 = mach_error_string(v12);
      *(_DWORD *)__int128 buf = 67240706;
      *(_DWORD *)double v60 = v12;
      *(_WORD *)&v60[4] = 2082;
      *(void *)&v60[6] = v14;
      *(_WORD *)&v60[14] = 2114;
      *(void *)&v60[16] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "[CLSPUHIDDriverInterface] Unable to create plugin interface,retCode,0x%{public}x,retStr,%{public}s,service,%{public}@",  buf,  0x1Cu);
    }

    if (!sub_1002921D0(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    uint64_t v15 = qword_1019344C8;
    __int16 v16 = mach_error_string(v12);
    int v53 = 67240706;
    *(_DWORD *)double v54 = v12;
    *(_WORD *)&v54[4] = 2082;
    *(void *)&v54[6] = v16;
    *(_WORD *)&v54[14] = 2114;
    *(void *)&v54[16] = v5;
    LODWORD(byte15a) = 28;
    uint64_t v17 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  17LL,  "[CLSPUHIDDriverInterface] Unable to create plugin interface,retCode,0x%{public}x,retStr,%{public} s,service,%{public}@",  &v53,  byte15a);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSPUHIDDriverInterface::openHIDDriverInterface()",  "%s\n",  (const char *)v17);
    if (v17 == buf) {
      return;
    }
LABEL_36:
    free(v17);
    return;
  }

  __int16 v20 = theInterface;
  QueryInterface = (*theInterface)->QueryInterface;
  __int16 v22 = CFUUIDGetConstantUUIDWithBytes( kCFAllocatorSystemDefault,  0x6Eu,  0xBEu,  0xBAu,  0x6Eu,  9u,  0x1Eu,  0x45u,  0x2Eu,  0x82u,  0xEAu,  0x29u,  0x79u,  0x81u,  0x6Fu,  0xB1u,  0xB5u);
  CFUUIDBytes v23 = CFUUIDGetUUIDBytes(v22);
  mach_error_t v24 = ((uint64_t (*)(IOCFPlugInInterface **, void, void, const void **))QueryInterface)( v20,  *(void *)&v23.byte0,  *(void *)&v23.byte8,  &v50);
  if (v24)
  {
    mach_error_t v25 = v24;
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    __int16 v26 = (os_log_s *)qword_1019344C8;
    if (os_log_type_enabled((os_log_t)qword_1019344C8, OS_LOG_TYPE_FAULT))
    {
      uint64_t v27 = mach_error_string(v25);
      *(_DWORD *)__int128 buf = 67240706;
      *(_DWORD *)double v60 = v25;
      *(_WORD *)&v60[4] = 2082;
      *(void *)&v60[6] = v27;
      *(_WORD *)&v60[14] = 2114;
      *(void *)&v60[16] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "[CLSPUHIDDriverInterface] Unable to set up query interface,retCode,0x%{public}x,retStr,%{public}s,service,%{public}@",  buf,  0x1Cu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344C0 != -1) {
        dispatch_once(&qword_1019344C0, &stru_101886B88);
      }
      uint64_t v37 = qword_1019344C8;
      __int16 v38 = mach_error_string(v25);
      int v53 = 67240706;
      *(_DWORD *)double v54 = v25;
      *(_WORD *)&v54[4] = 2082;
      *(void *)&v54[6] = v38;
      *(_WORD *)&v54[14] = 2114;
      *(void *)&v54[16] = v5;
      LODWORD(byte15b) = 28;
      double v39 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v37,  17LL,  "[CLSPUHIDDriverInterface] Unable to set up query interface,retCode,0x%{public}x,retStr,%{public}s, service,%{public}@",  &v53,  byte15b);
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLSPUHIDDriverInterface::openHIDDriverInterface()", "%s\n", v39);
    }

uint64_t sub_100E2F5E4(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5)
{
  if (qword_1019344C0 != -1) {
    dispatch_once(&qword_1019344C0, &stru_101886B88);
  }
  uint64_t v10 = (os_log_s *)qword_1019344C8;
  if (os_log_type_enabled((os_log_t)qword_1019344C8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 134217984;
    __int16 v26 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "[CLSPUHIDDriverInterface] Attempting to send command with reply to SPU,length,%zu",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    int v21 = 134217984;
    __int16 v22 = a3;
    __int16 v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344C8,  2LL,  "[CLSPUHIDDriverInterface] Attempting to send command with reply to SPU,length,%zu",  (size_t)&v21);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "IOReturn CLSPUHIDDriverInterface::sendCommand(const void *, size_t, void *, size_t *)",  "%s\n",  v20);
  }

  uint64_t v11 = *(void *)(a1 + 24);
  if (v11)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t, uint64_t))(*(void *)v11 + 80LL))( v11,  a2,  a3,  a4,  a5);
    if ((_DWORD)v12)
    {
      if (qword_1019344C0 != -1) {
        dispatch_once(&qword_1019344C0, &stru_101886B88);
      }
      double v13 = (os_log_s *)qword_1019344C8;
      if (os_log_type_enabled((os_log_t)qword_1019344C8, OS_LOG_TYPE_FAULT))
      {
        int v14 = mach_error_string(v12);
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v26 = v14;
        __int16 v27 = 1026;
        int v28 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "[CLSPUHIDDriverInterface] sendCommand() = %{public}s (0x%{public}x)",  buf,  0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344C0 != -1) {
          dispatch_once(&qword_1019344C0, &stru_101886B88);
        }
        uint64_t v15 = qword_1019344C8;
        __int16 v16 = mach_error_string(v12);
        int v21 = 136446466;
        __int16 v22 = v16;
        __int16 v23 = 1026;
        int v24 = v12;
        uint64_t v17 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  17LL,  "[CLSPUHIDDriverInterface] sendCommand() = %{public}s (0x%{public}x)",  &v21,  18);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "IOReturn CLSPUHIDDriverInterface::sendCommand(const void *, size_t, void *, size_t *)",  "%s\n");
LABEL_29:
        if (v17 != buf) {
          free(v17);
        }
      }
    }
  }

  else
  {
    if (qword_1019344C0 != -1) {
      dispatch_once(&qword_1019344C0, &stru_101886B88);
    }
    __int16 v18 = (os_log_s *)qword_1019344C8;
    if (os_log_type_enabled((os_log_t)qword_1019344C8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "[CLSPUHIDDriverInterface] hidDriverInterface NULL, unable to send command",  buf,  2u);
    }

    uint64_t v12 = 3758097084LL;
    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344C0 != -1) {
        dispatch_once(&qword_1019344C0, &stru_101886B88);
      }
      LOWORD(v21) = 0;
      uint64_t v17 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344C8,  1LL,  "[CLSPUHIDDriverInterface] hidDriverInterface NULL, unable to send command",  &v21,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "IOReturn CLSPUHIDDriverInterface::sendCommand(const void *, size_t, void *, size_t *)",  "%s\n");
      goto LABEL_29;
    }
  }

  return v12;
}

void sub_100E2FA64(id a1)
{
  qword_1019344C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "AOP");
}

uint64_t sub_100E2FA90(uint64_t a1, void *a2)
{
  uint64_t v3 = sub_100900DB4(a1, a2);
  *(void *)uint64_t v3 = off_101886BB8;
  *(_OWORD *)(v3 + 112) = 0u;
  *(_OWORD *)(v3 + 128) = 0u;
  *(_DWORD *)(v3 + 144) = 100;
  *(_BYTE *)(v3 + 148) = 1;
  *(void *)(v3 + 164) = 0x10000000000LL;
  *(_DWORD *)(v3 + 160) = 1031798784;
  *(_BYTE *)(v3 + 1196) = 1;
  *(_DWORD *)(v3 + 1216) = 256;
  *(void *)(v3 + 1208) = 1031798784LL;
  *(_BYTE *)(v3 + 2244) = 1;
  *(_DWORD *)(v3 + 2264) = 256;
  *(void *)(v3 + 2256) = 1031798784LL;
  sub_10101B1A0(v3 + 3296, v3 + 136);
  sub_1005CECA0((void *)(a1 + 17216));
  uint64_t v4 = (float *)(a1 + 17512);
  *(_DWORD *)(a1 + 17512) = 1067030938;
  *(_WORD *)(a1 + 17516) = 0;
  *(_DWORD *)(a1 + 17520) = 3;
  *(void *)(a1 + 17528) = 0LL;
  *(_WORD *)(a1 + 17536) = 0;
  unint64_t v5 = (_BYTE *)(a1 + 17536);
  sub_100AD258C(v30);
  sub_1005CED08(a1 + 17216, (uint64_t)v30);
  if (qword_101934700 != -1) {
    dispatch_once(&qword_101934700, &stru_101886CB8);
  }
  double v6 = (os_log_s *)qword_101934708;
  if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
  {
    double v7 = *v4;
    LODWORD(buf[0]) = 134217984;
    *(double *)((char *)buf + 4) = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "configuration: wake threshold = %f",  (uint8_t *)buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934700 != -1) {
      dispatch_once(&qword_101934700, &stru_101886CB8);
    }
    double v25 = *v4;
    int v31 = 134217984;
    double v32 = v25;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "configuration: wake threshold = %f",  COERCE_DOUBLE(&v31));
    __int16 v27 = (char *)v26;
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLOnBodyNotifier6::CLOnBodyNotifier6(id<CLIntersiloUniverse>)", "%s\n", v26);
  }

  sub_1005CEFE0(a1 + 17216);
  uint64_t v8 = sub_1006E27E8();
  sub_100413284(v8, buf);
  char v9 = sub_1002A6F64(*(uint64_t *)&buf[0], "EnablePmOnBodyDetection", (BOOL *)(a1 + 17536));
  char v10 = v9;
  uint64_t v11 = (std::__shared_weak_count *)*((void *)&buf[0] + 1);
  if (!*((void *)&buf[0] + 1)) {
    goto LABEL_10;
  }
  uint64_t v12 = (unint64_t *)(*((void *)&buf[0] + 1) + 8LL);
  do
    unint64_t v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (v13)
  {
LABEL_10:
    if ((v9 & 1) != 0) {
      goto LABEL_11;
    }
LABEL_22:
    *unint64_t v5 = 0;
    goto LABEL_23;
  }

  ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
  std::__shared_weak_count::__release_weak(v11);
  if ((v10 & 1) == 0) {
    goto LABEL_22;
  }
LABEL_11:
  if (*v5)
  {
    sub_100E30048(a1, 1);
    if (qword_101934700 != -1) {
      dispatch_once(&qword_101934700, &stru_101886CB8);
    }
    int v14 = (os_log_s *)qword_101934708;
    if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "Registering with daemon status",  (uint8_t *)buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934700 != -1) {
        dispatch_once(&qword_101934700, &stru_101886CB8);
      }
      LOWORD(v31) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "Registering with daemon status",  &v31,  2);
      mach_error_t v29 = (char *)v28;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLOnBodyNotifier6::CLOnBodyNotifier6(id<CLIntersiloUniverse>)",  "%s\n",  v28);
    }

    sub_1003CC884((uint64_t)sub_100E303F0, a1, *(void **)(a1 + 32), buf);
    uint64_t v15 = *(void *)&buf[0];
    *(void *)&buf[0] = 0LL;
    uint64_t v16 = *(void *)(a1 + 128);
    *(void *)(a1 + 128) = v15;
    if (v16)
    {
      (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
      uint64_t v17 = *(void *)&buf[0];
      *(void *)&buf[0] = 0LL;
      if (v17) {
        (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
      }
    }

    [*(id *)(*(void *)(a1 + 128) + 16) register:*(void *)(*(void *)(a1 + 128) + 8) forNotification:2 registrationInfo:0];
    [*(id *)(*(void *)(a1 + 128) + 16) register:*(void *)(*(void *)(a1 + 128) + 8) forNotification:3 registrationInfo:0];
  }

void sub_100E2FFB4(_Unwind_Exception *a1)
{
  *uint64_t v3 = off_101842798;
  sub_1009AF3C8(v3);
  *uint64_t v2 = &off_10183F330;
  uint64_t v5 = *(void *)(v1 + 128);
  *(void *)(v1 + 128) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  sub_100900FAC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E30048(uint64_t result, int a2)
{
  uint64_t v2 = result + 17516;
  if (*(_BYTE *)(result + 17536)) {
    BOOL v3 = a2 == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    uint64_t v4 = result;
    if (sub_1006E5C40() && !*(void *)(v4 + 112))
    {
      if (qword_101934700 != -1) {
        dispatch_once(&qword_101934700, &stru_101886CB8);
      }
      uint64_t v5 = (os_log_s *)qword_101934708;
      if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Registering with CLAccelerometer", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934700 != -1) {
          dispatch_once(&qword_101934700, &stru_101886CB8);
        }
        v15[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "Registering with CLAccelerometer",  v15,  2);
        uint64_t v11 = (uint8_t *)v10;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLOnBodyNotifier6::startOnBodyDetectionHelper(BOOL)", "%s\n", v10);
        if (v11 != buf) {
          free(v11);
        }
      }

      double v6 = operator new(0x48uLL);
      sub_100A36124((uint64_t)v6, *(void **)(v4 + 40), (uint64_t)sub_100E30C2C, 0x100u, v4);
      *(void *)(v4 + 112) = v6;
      uint64_t v7 = sub_1006E5C40();
      sub_1006DCB40(v7, 0, *(void *)(v4 + 112), 0.01);
    }

    if (!*(_BYTE *)(v2 + 21) && sub_1006E5C40() && !*(void *)(v4 + 120))
    {
      if (qword_101934700 != -1) {
        dispatch_once(&qword_101934700, &stru_101886CB8);
      }
      uint64_t v8 = (os_log_s *)qword_101934708;
      if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "Registering throttledDispatcher with CLAccelerometer",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934700 != -1) {
          dispatch_once(&qword_101934700, &stru_101886CB8);
        }
        v15[0] = 0;
        LODWORD(v14) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "Registering throttledDispatcher with CLAccelerometer",  v15,  v14);
        unint64_t v13 = (uint8_t *)v12;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLOnBodyNotifier6::startOnBodyDetectionHelper(BOOL)", "%s\n", v12);
        if (v13 != buf) {
          free(v13);
        }
      }

      char v9 = operator new(0x38uLL);
      sub_101212E7C(v9, *(void **)(v4 + 40), (uint64_t)sub_100E30E04, v4, 0LL);
      *(void *)(v4 + 120) = v9;
    }

    *(_WORD *)uint64_t v2 = 0;
    *(_DWORD *)(v2 + 4) = 3;
    return sub_1005CF718(v4 + 17216);
  }

  return result;
}

void sub_100E303D0(_Unwind_Exception *a1)
{
}

void sub_100E303F0(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101886CD8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v10 = 1;
    uint64_t v7 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLOnBodyNotifier6::onDaemonStatusNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101886CD8);
    }
    uint64_t v8 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 2082;
      uint64_t v16 = "activity";
      __int16 v17 = 2050;
      uint64_t v18 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLOnBodyNotifier6::onDaemonStatusNotification, event:%{public, location:escape_only }s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v10 = 0;
  }

  sub_100E31A3C((_BYTE *)a4, v6, a2);
  if (v10) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E305A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E305C4(void *a1)
{
  *a1 = off_101886BB8;
  a1[2152] = off_101842798;
  sub_1009AF3C8(a1 + 2152);
  a1[412] = &off_10183F330;
  uint64_t v2 = a1[16];
  a1[16] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return sub_100900FAC((uint64_t)a1);
}

void sub_100E30638(void *a1)
{
  uint64_t v1 = (void *)sub_100E305C4(a1);
  operator delete(v1);
}

void sub_100E3064C(uint64_t a1, void *a2)
{
  uint64_t v4 = a1 + 17512;
  uint64_t v5 = *(void *)(a1 + 112);
  if (v5) {
    sub_100E30884((_BYTE *)a1, 1);
  }
  sub_100AD2964(a2, 0LL, (uint64_t)v11);
  *(_DWORD *)uint64_t v4 = v12;
  sub_1005CED08(a1 + 17216, (uint64_t)v11);
  *(_WORD *)(v4 + 4) = 0;
  *(_DWORD *)(v4 + 8) = 3;
  sub_1005CF718(a1 + 17216);
  if (qword_101934700 != -1) {
    dispatch_once(&qword_101934700, &stru_101886CB8);
  }
  uint64_t v6 = (os_log_s *)qword_101934708;
  if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
  {
    double v7 = *(float *)v4;
    *(_DWORD *)__int128 buf = 134217984;
    double v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "configuration: wake threshold = %f", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934700 != -1) {
      dispatch_once(&qword_101934700, &stru_101886CB8);
    }
    double v8 = *(float *)v4;
    int v13 = 134217984;
    double v14 = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "configuration: wake threshold = %f",  COERCE_DOUBLE(&v13));
    char v10 = (uint8_t *)v9;
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLOnBodyNotifier6::feedParams(NSDictionary *)", "%s\n", v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  sub_1005CEFE0(a1 + 17216);
  if (v5) {
    sub_100E30048(a1, 1);
  }
}

_BYTE *sub_100E30884(_BYTE *result, int a2)
{
  uint64_t v2 = result + 17536;
  if (result[17536]) {
    BOOL v3 = a2 == 0;
  }
  else {
    BOOL v3 = 0;
  }
  if (!v3)
  {
    uint64_t v4 = result;
    uint64_t result = (_BYTE *)sub_1006E5C40();
    if (result && *((void *)v4 + 14))
    {
      if (qword_101934700 != -1) {
        dispatch_once(&qword_101934700, &stru_101886CB8);
      }
      uint64_t v5 = (os_log_s *)qword_101934708;
      if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Unregistering with CLAccelerometer", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934700 != -1) {
          dispatch_once(&qword_101934700, &stru_101886CB8);
        }
        v14[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "Unregistering with CLAccelerometer",  v14,  2);
        char v10 = (uint8_t *)v9;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLOnBodyNotifier6::stopOnBodyDetectionHelper(BOOL)", "%s\n", v9);
        if (v10 != buf) {
          free(v10);
        }
      }

      uint64_t v6 = sub_1006E5C40();
      sub_1006DD2A0(v6, 0, *((void *)v4 + 14));
      uint64_t result = (_BYTE *)*((void *)v4 + 14);
      if (result) {
        uint64_t result = (_BYTE *)(*(uint64_t (**)(_BYTE *))(*(void *)result + 8LL))(result);
      }
      *((void *)v4 + 14) = 0LL;
    }

    if (!v2[1])
    {
      uint64_t result = (_BYTE *)sub_1006E5C40();
      if (result)
      {
        if (*((void *)v4 + 15))
        {
          if (qword_101934700 != -1) {
            dispatch_once(&qword_101934700, &stru_101886CB8);
          }
          double v7 = (os_log_s *)qword_101934708;
          if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "Unregistering throttleDispatcher with CLAccelerometer",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934700 != -1) {
              dispatch_once(&qword_101934700, &stru_101886CB8);
            }
            v14[0] = 0;
            LODWORD(v13) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "Unregistering throttleDispatcher with CLAccelerometer",  v14,  v13);
            int v12 = (uint8_t *)v11;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOnBodyNotifier6::stopOnBodyDetectionHelper(BOOL)",  "%s\n",  v11);
            if (v12 != buf) {
              free(v12);
            }
          }

          uint64_t v8 = sub_1006E5C40();
          sub_1006DD2A0(v8, 0, *((void *)v4 + 15));
          uint64_t result = (_BYTE *)*((void *)v4 + 15);
          if (result) {
            uint64_t result = (_BYTE *)(*(uint64_t (**)(_BYTE *))(*(void *)result + 8LL))(result);
          }
          *((void *)v4 + 15) = 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t sub_100E30BD8(uint64_t a1)
{
  uint64_t v2 = (_BYTE *)(a1 + 17536);
  if (*(_BYTE *)(a1 + 17536))
  {
    uint64_t v3 = *(void *)(a1 + 128);
    *(void *)(a1 + 128) = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    *uint64_t v2 = 0;
  }

  return sub_100900FB8((_BYTE *)a1);
}

uint64_t sub_100E30C24(uint64_t a1)
{
  return sub_100E30048(a1, 0);
}

void sub_100E30C2C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101886CD8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v9 = 1;
    uint64_t v6 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLOnBodyNotifier6::onAccelerometerData",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v6, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101886CD8);
    }
    double v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      __int16 v14 = 2082;
      __int16 v15 = "activity";
      __int16 v16 = 2050;
      uint64_t v17 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLOnBodyNotifier6::onAccelerometerData, event:%{public, location:escape_only}s, t his:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v9 = 0;
  }

  sub_100E30FDC(a3, a1, a2);
  if (v9) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E30DE4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E30E04(uint64_t a1, uint64_t a2)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101886CD8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    uint64_t v4 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLOnBodyNotifier6::onThrottledAccelerometerData",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v4, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101886CD8);
    }
    uint64_t v5 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      int v11 = "";
      __int16 v12 = 2082;
      uint64_t v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLOnBodyNotifier6::onThrottledAccelerometerData, event:%{public, location:escape_on ly}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  sub_100E3159C((uint64_t *)a2, a1);
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E30FB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *sub_100E30FD4(_BYTE *a1)
{
  return sub_100E30884(a1, 0);
}

void sub_100E30FDC(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v5 = a1 + 17308;
  if (a3)
  {
    unint64_t v6 = *(unsigned int *)(a1 + 168);
    unint64_t v7 = *(unsigned int *)(a1 + 1216);
    unint64_t v8 = *(unsigned int *)(a1 + 2264);
    unsigned __int16 v9 = *(_WORD *)(a1 + 166);
    uint64_t v10 = *(unsigned __int16 *)(a1 + 164);
    unsigned __int16 v11 = *(_WORD *)(a1 + 1214);
    uint64_t v12 = *(unsigned __int16 *)(a1 + 1212);
    uint64_t v13 = 24LL * (a3 - 1);
    uint64_t v14 = a3;
    uint64_t v15 = (float *)(a2 + 16);
    unsigned __int16 v16 = *(_WORD *)(a1 + 2262);
    uint64_t v17 = *(unsigned __int16 *)(a1 + 2260);
    do
    {
      float v18 = fminf(fmaxf(*(v15 - 2), -4.0), 4.0);
      unint64_t v19 = v10 + v9;
      if (v19 >= v6) {
        unint64_t v20 = v6;
      }
      else {
        unint64_t v20 = 0LL;
      }
      *(float *)(a1 + 172 + 4 * (v19 - v20)) = v18;
      if (v6 <= v9)
      {
        unint64_t v21 = v10 + 1;
        if (v21 >= v6) {
          __int16 v22 = v6;
        }
        else {
          __int16 v22 = 0;
        }
        unsigned __int16 v23 = v21 - v22;
        uint64_t v10 = v23;
        *(_WORD *)(a1 + 164) = v23;
      }

      else
      {
        *(_WORD *)(a1 + 166) = ++v9;
      }

      float v24 = fminf(fmaxf(*(v15 - 1), -4.0), 4.0);
      unint64_t v25 = v12 + v11;
      if (v25 >= v7) {
        unint64_t v26 = v7;
      }
      else {
        unint64_t v26 = 0LL;
      }
      *(float *)(a1 + 1220 + 4 * (v25 - v26)) = v24;
      if (v7 <= v11)
      {
        unint64_t v27 = v12 + 1;
        if (v27 >= v7) {
          __int16 v28 = v7;
        }
        else {
          __int16 v28 = 0;
        }
        unsigned __int16 v29 = v27 - v28;
        uint64_t v12 = v29;
        *(_WORD *)(a1 + 1212) = v29;
      }

      else
      {
        *(_WORD *)(a1 + 1214) = ++v11;
      }

      float v30 = fminf(fmaxf(*v15, -4.0), 4.0);
      unint64_t v31 = v17 + v16;
      if (v31 >= v8) {
        unint64_t v32 = v8;
      }
      else {
        unint64_t v32 = 0LL;
      }
      *(float *)(a1 + 2268 + 4 * (v31 - v32)) = v30;
      if (v8 <= v16)
      {
        unint64_t v33 = v17 + 1;
        if (v33 >= v8) {
          __int16 v34 = v8;
        }
        else {
          __int16 v34 = 0;
        }
        unsigned __int16 v35 = v33 - v34;
        uint64_t v17 = v35;
        *(_WORD *)(a1 + 2260) = v35;
      }

      else
      {
        *(_WORD *)(a1 + 2262) = ++v16;
      }

      v15 += 6;
      --v14;
    }

    while (v14);
    double v3 = *(double *)(a2 + v13);
    *(_BYTE *)(a1 + 148) = 1;
    *(_BYTE *)(a1 + 1196) = 1;
    *(_BYTE *)(a1 + 2244) = 1;
  }

  *(void *)(a1 + 136) = (unint64_t)(v3 * 1000000.0);
  sub_100FF6904((void *)(a1 + 3296));
  unint64_t v36 = sub_1005CF7F0(a1 + 17216);
  int v37 = v36;
  unint64_t v38 = HIDWORD(v36);
  float v40 = *(float *)(v5 + 4);
  float v39 = *(float *)(v5 + 8);
  if ((_DWORD)v36) {
    float v41 = *(float *)v5;
  }
  else {
    float v41 = 1.0 - *(float *)v5;
  }
  if (qword_101934700 != -1) {
    dispatch_once(&qword_101934700, &stru_101886CB8);
  }
  __int16 v42 = (os_log_s *)qword_101934708;
  if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v43 = *(void *)(a1 + 136);
    *(_DWORD *)__int128 buf = 134219264;
    uint64_t v67 = v43;
    __int16 v68 = 2048;
    double v69 = v40;
    __int16 v70 = 2048;
    double v71 = v39;
    __int16 v72 = 1024;
    int v73 = v37;
    __int16 v74 = 1024;
    int v75 = v38;
    __int16 v76 = 2048;
    double v77 = v41;
    _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEBUG,  "detection @ %llu : low %f high %f status %d confidence %d odds %.2f",  buf,  0x36u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934700 != -1) {
      dispatch_once(&qword_101934700, &stru_101886CB8);
    }
    uint64_t v50 = *(void *)(a1 + 136);
    int v56 = 134219264;
    *(void *)__int16 v57 = v50;
    *(_WORD *)&v57[8] = 2048;
    *(double *)&v57[10] = v40;
    __int16 v58 = 2048;
    double v59 = v39;
    __int16 v60 = 1024;
    int v61 = v37;
    __int16 v62 = 1024;
    int v63 = v38;
    __int16 v64 = 2048;
    double v65 = v41;
    LODWORD(v53) = 54;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "detection @ %llu : low %f high %f status %d confidence %d odds %.2f",  &v56,  v53,  v54,  v55);
    double v52 = (uint8_t *)v51;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOnBodyNotifier6::onAccelerometerData(const CLAccelerometer::Sample *, unsigned int)",  "%s\n",  v51);
    if (v52 != buf) {
      free(v52);
    }
  }

  int v56 = v37;
  *(_DWORD *)__int16 v57 = v38;
  *(double *)&v57[4] = v3;
  *(_DWORD *)__int128 buf = 0;
  (*(void (**)(uint64_t, uint8_t *, int *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  buf,  &v56,  1LL,  0xFFFFFFFFLL,  0LL);
  if (!*(_BYTE *)(v5 + 229))
  {
    if (*(_DWORD *)(v5 + 212) == v37)
    {
      unsigned int v44 = (unsigned __int16)++*(_WORD *)(v5 + 208);
      *(void *)(a1 + 17528) = *(void *)(a1 + 136);
      if (v44 >= 8)
      {
        *(_WORD *)(v5 + 208) = 0;
        uint64_t v45 = sub_1006E5C40();
        if ((sub_1006DCB40(v45, 0, *(void *)(a1 + 120), 0.2) & 1) != 0)
        {
          uint64_t v46 = sub_1006E5C40();
          sub_1006DD2A0(v46, 0, *(void *)(a1 + 112));
        }

        else
        {
          if (qword_101934700 != -1) {
            dispatch_once(&qword_101934700, &stru_101886CB8);
          }
          double v47 = (os_log_s *)qword_101934708;
          if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEBUG,  "Failed to add throttled dispatcher",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934700 != -1) {
              dispatch_once(&qword_101934700, &stru_101886CB8);
            }
            LOWORD(v54) = 0;
            LODWORD(v53) = 2;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "Failed to add throttled dispatcher",  &v54,  *(void *)&v53);
            __int16 v49 = (uint8_t *)v48;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOnBodyNotifier6::onAccelerometerData(const CLAccelerometer::Sample *, unsigned int)",  "%s\n",  v48);
            if (v49 != buf) {
              free(v49);
            }
          }
        }
      }
    }

    else
    {
      *(_DWORD *)(v5 + 212) = v37;
      *(_WORD *)(v5 + 208) = 0;
      *(void *)(a1 + 17528) = *(void *)(a1 + 136);
    }
  }

void sub_100E3159C(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1 + 2189;
  float v5 = fminf(fmaxf(*(float *)(a2 + 8), -4.0), 4.0);
  float v6 = fminf(fmaxf(*(float *)(a2 + 12), -4.0), 4.0);
  unint64_t v7 = (unint64_t)(*(double *)a2 * 1000000.0);
  float v8 = fminf(fmaxf(*(float *)(a2 + 16), -4.0), 4.0);
  if (qword_101934700 != -1) {
    dispatch_once(&qword_101934700, &stru_101886CB8);
  }
  float v9 = (float)((float)(v6 * v6) + (float)(v5 * v5)) + (float)(v8 * v8);
  uint64_t v10 = (os_log_s *)qword_101934708;
  if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
  {
    float v11 = *(float *)v4;
    *(_DWORD *)__int128 buf = 134219264;
    *(void *)unint64_t v38 = v7;
    *(_WORD *)&v38[8] = 2048;
    *(double *)&v38[10] = v5;
    __int16 v39 = 2048;
    double v40 = v6;
    __int16 v41 = 2048;
    double v42 = v8;
    __int16 v43 = 2048;
    double v44 = v9;
    __int16 v45 = 2048;
    double v46 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "throttled @ %llu: accel = [%.2f %.2f %.2f] = %.2f ? %.2f",  buf,  0x3Eu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934700 != -1) {
      dispatch_once(&qword_101934700, &stru_101886CB8);
    }
    double v19 = *(float *)v4;
    int v25 = 134219264;
    unint64_t v26 = v7;
    __int16 v27 = 2048;
    double v28 = v5;
    __int16 v29 = 2048;
    double v30 = v6;
    __int16 v31 = 2048;
    double v32 = v8;
    __int16 v33 = 2048;
    double v34 = v9;
    __int16 v35 = 2048;
    double v36 = v19;
    LODWORD(v24) = 62;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "throttled @ %llu: accel = [%.2f %.2f %.2f] = %.2f ? %.2f",  &v25,  v24);
    unint64_t v21 = (uint8_t *)v20;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOnBodyNotifier6::onThrottledAccelerometerData(const CLAccelerometer::Sample *)",  "%s\n",  v20);
    if (v21 != buf) {
      free(v21);
    }
  }

  uint64_t v12 = a1[2191];
  a1[2191] = v7;
  unint64_t v13 = v12 + 400000;
  if (v9 <= *(float *)v4 && v13 >= v7)
  {
    __int16 v17 = (unsigned __int16)(*((_WORD *)v4 + 2) + 1) % 0xDu;
    *((_WORD *)v4 + 2) = v17;
    if (!v17)
    {
      *(_DWORD *)__int128 buf = *((_DWORD *)v4 + 2);
      *(_DWORD *)unint64_t v38 = 1;
      *(void *)&v38[4] = *(void *)a2;
      int v25 = 0;
      (*(void (**)(uint64_t *, int *, uint8_t *, uint64_t, uint64_t, void))(*a1 + 152))( a1,  &v25,  buf,  1LL,  0xFFFFFFFFLL,  0LL);
    }
  }

  else
  {
    *((_WORD *)v4 + 2) = 0;
    *((_DWORD *)v4 + 2) = 3;
    sub_1005CF718((uint64_t)(a1 + 2152));
    uint64_t v15 = sub_1006E5C40();
    if ((sub_1006DCB40(v15, 0, a1[14], 0.01) & 1) != 0)
    {
      uint64_t v16 = sub_1006E5C40();
      sub_1006DD2A0(v16, 0, a1[15]);
    }

    else
    {
      if (qword_101934700 != -1) {
        dispatch_once(&qword_101934700, &stru_101886CB8);
      }
      float v18 = (os_log_s *)qword_101934708;
      if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Failed to add dispatcher", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934700 != -1) {
          dispatch_once(&qword_101934700, &stru_101886CB8);
        }
        LOWORD(v25) = 0;
        LODWORD(v24) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "Failed to add dispatcher",  &v25,  *(void *)&v24);
        unsigned __int16 v23 = (uint8_t *)v22;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOnBodyNotifier6::onThrottledAccelerometerData(const CLAccelerometer::Sample *)",  "%s\n",  v22);
        if (v23 != buf) {
          free(v23);
        }
      }
    }
  }

_BYTE *sub_100E31A3C(_BYTE *result, uint64_t a2, _DWORD *a3)
{
  double v3 = result;
  if (*a3 == 3)
  {
    if (qword_101934700 != -1) {
      dispatch_once(&qword_101934700, &stru_101886CB8);
    }
    float v5 = (os_log_s *)qword_101934708;
    if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "kNotificationWake. Turning on on body detector",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934700 != -1) {
        dispatch_once(&qword_101934700, &stru_101886CB8);
      }
      v10[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "kNotificationWake. Turning on on body detector",  v10,  2);
      float v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOnBodyNotifier6::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemo nStatus_Type::NotificationData &)",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }

    return (_BYTE *)sub_100E30048((uint64_t)v3, 1);
  }

  else if (*a3 == 2)
  {
    if (qword_101934700 != -1) {
      dispatch_once(&qword_101934700, &stru_101886CB8);
    }
    uint64_t v4 = (os_log_s *)qword_101934708;
    if (os_log_type_enabled((os_log_t)qword_101934708, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "kNotificationSleep. Turning off on body detector",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934700 != -1) {
        dispatch_once(&qword_101934700, &stru_101886CB8);
      }
      v10[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934708,  2LL,  "kNotificationSleep. Turning off on body detector",  v10,  2);
      unint64_t v7 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLOnBodyNotifier6::onDaemonStatusNotification(int, const CLDaemonStatus_Type::Notification &, const CLDaemo nStatus_Type::NotificationData &)",  "%s\n",  v6);
      if (v7 != buf) {
        free(v7);
      }
    }

    return sub_100E30884(v3, 1);
  }

  return result;
}

void sub_100E31D2C(id a1)
{
  qword_101934708 = (uint64_t)os_log_create("com.apple.locationd.Motion", "OnBody");
}

void sub_100E31D58(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_100E31D84(uint64_t result, char a2, int a3, int a4, char a5, double a6, double a7, double a8)
{
  *(_BYTE *)uint64_t result = a2;
  *(double *)(result + 8) = a6;
  *(double *)(result + 16) = a7;
  *(double *)(result + 24) = a8;
  *(_DWORD *)(result + 32) = a3;
  *(_DWORD *)(result + 36) = a4;
  *(_BYTE *)(result + 40) = a5;
  return result;
}

void sub_100E31D9C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 16LL;
  if (!*(_BYTE *)(a2 + 9)) {
    uint64_t v2 = 24LL;
  }
  if (*(double *)(a1 + v2) == -1.0)
  {
    uint64_t v3 = sub_101272D3C();
    sub_100E31DD4(v3);
  }

void sub_100E31DD4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 32) == 1000)
  {
    a1 = sub_101272EA0();
    goto LABEL_5;
  }

  if (*(_DWORD *)(a1 + 36) == 1000)
  {
LABEL_5:
    uint64_t v1 = (void *)sub_101273004(a1);
    sub_100E31E10(v1);
  }

void sub_100E31E10(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_100E31E3C(uint64_t a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *(void *)a1 = off_101886D40;
  *(void *)(a1 + 72) = off_101886DF8;
  *(_BYTE *)(a1 + 488) = 0;
  sub_100E33F0C(a1);
  return a1;
}

void sub_100E31EC8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_100E31EF4(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v12 = (void *)(a1 + 8);
  *(void *)a1 = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 8));
  *uint64_t v12 = &off_101826EF8;
  *(void *)a1 = off_101887218;
  *(void *)(a1 + 72) = off_1018872C0;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_101887218;
  *(void *)(a1 + 72) = off_1018872C0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(void *)(a1 + 224) = 0LL;
  *(void *)(a1 + 232) = 0x7FEFFFFFFFFFFFFFLL;
  *(void *)(a1 + 240) = 0LL;
  *(void *)(a1 + 264) = 0x7FEFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_DWORD *)(a1 + 400) = 1;
  *(_DWORD *)(a1 + 408) = 12000;
  *(void *)(a1 + 416) = off_101826EC8;
  sub_1001B9AC4((void *)(a1 + 424));
  *(void *)(a1 + 424) = &off_101826EF8;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v29 = a1 + 112;
  (*(void (**)(void))(v13 + 16))();
  __int16 v31 = 256;
  if (a3)
  {
    *(void *)(a1 + 232) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)__p = *(_OWORD *)a4;
    uint64_t v28 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  uint64_t v15 = (int *)(a1 + 408);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 408));
  __int16 v17 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    int *v15 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101887300);
  }
  unint64_t v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v15;
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101887300);
    }
    int v24 = *v15;
    v32[0] = 67109120;
    v32[1] = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v32);
    unint64_t v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<VO2MaxSummary, CLActivityDB::ClassBDataProtectionPolicy>::CLActivityRecorderDb(const char *, BOOL, float, const std::string &, const CLSqliteDatabase::SqlitePropertyPersistence) [T = VO2MaxSummary, DataProte ctionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  int v22 = HIBYTE(v31);
  *(void *)(a1 + 232) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v31)
    {
      pthread_mutex_unlock(v30);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_100E322C4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[52] = off_101826EC8;
  sub_1001B9C98(v27);
  sub_1009A5488(v26);
  sub_100D8A88C(a12);
  *int v24 = off_101826EC8;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_100E32368()
{
}

void *sub_100E32370(void *a1)
{
  a1[9] = off_1018872C0;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_101887218;
  a1[52] = off_101826EC8;
  sub_1001B9C98(a1 + 53);
  sub_1009A5488(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_101826EC8;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_100E323F0(uint64_t a1)
{
  return sub_100E32370((void *)(a1 - 72));
}

void sub_100E323F8(void *a1)
{
  uint64_t v1 = sub_100E32370(a1);
  operator delete(v1);
}

void sub_100E3240C(uint64_t a1)
{
  uint64_t v1 = sub_100E32370((void *)(a1 - 72));
  operator delete(v1);
}

uint64_t sub_100E32424(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 488)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 112LL))(a1);
  }
  sub_1003C0454(*(void *)(a1 + 80));
  double Current = CFAbsoluteTimeGetCurrent();
  sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM VO2MaxSummaryHistory WHERE startTime < ?", &v13);
  uint64_t v5 = v13;
  char v6 = (sqlite3_stmt *)sub_100019240(v13);
  if (sub_1003B7480(v6, 1, Current - *(double *)(*(void *)(a2 + 8) - 24LL)))
  {
    uint64_t v7 = *(void *)(a1 + 80);
    float v8 = (sqlite3_stmt *)sub_100019240(v5);
    sub_1003BB2BC(v7, v8);
    uint64_t v9 = (*(int (**)(uint64_t))(*(void *)a1 + 152LL))(a1);
  }

  else
  {
    uint64_t v9 = -1LL;
  }

  sub_1003C05BC(*(void *)(a1 + 80));
  uint64_t v10 = *(void *)(a1 + 80);
  else {
    uint64_t v11 = *(void *)(v10 + 88);
  }
  sub_1003C1EC0(v10, v11);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return v9;
}

void sub_100E32554(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E32574(uint64_t a1, uint64_t a2)
{
  return sub_100E32424(a1 - 72, a2);
}

uint64_t sub_100E3257C(uint64_t a1, char **a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * from VO2MaxSummaryHistory ORDER BY startTime ASC", &v46);
    uint64_t v5 = v46;
    uint64_t v45 = v46;
    sub_1003C0454(*(void *)(a1 + 80));
    *(void *)&__int128 v46 = 0LL;
    *((void *)&v46 + 1) = 0x7FEFFFFFFFFFFFFFLL;
    *(void *)&__int128 v47 = 0LL;
    *((void *)&v48 + 1) = 0x7FEFFFFFFFFFFFFFLL;
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    __int128 v51 = 0u;
    __int128 v52 = 0u;
    __int128 v53 = 0u;
    __int128 v54 = 0u;
    __int128 v55 = 0u;
    LODWORD(v57) = 1;
    __int128 v56 = 0u;
    while (!sub_100E328AC(&v45, (uint64_t)&v46))
    {
      unint64_t v6 = (unint64_t)a2[1];
      unint64_t v7 = (unint64_t)a2[2];
      if (v6 >= v7)
      {
        unint64_t v18 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v6 - (void)*a2) >> 3);
        unint64_t v19 = v18 + 1;
        if (v18 + 1 > 0x1642C8590B21642LL) {
          sub_100007008();
        }
        unint64_t v20 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v7 - (void)*a2) >> 3);
        if (2 * v20 > v19) {
          unint64_t v19 = 2 * v20;
        }
        if (v20 >= 0xB21642C8590B21LL) {
          unint64_t v21 = 0x1642C8590B21642LL;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21) {
          int v22 = (char *)sub_1002DF6FC((uint64_t)(a2 + 2), v21);
        }
        else {
          int v22 = 0LL;
        }
        unsigned __int16 v23 = &v22[184 * v18];
        __int128 v24 = v46;
        __int128 v25 = v47;
        __int128 v26 = v49;
        *((_OWORD *)v23 + 2) = v48;
        *((_OWORD *)v23 + 3) = v26;
        *(_OWORD *)unsigned __int16 v23 = v24;
        *((_OWORD *)v23 + 1) = v25;
        __int128 v27 = v50;
        __int128 v28 = v51;
        __int128 v29 = v53;
        *((_OWORD *)v23 + 6) = v52;
        *((_OWORD *)v23 + 7) = v29;
        *((_OWORD *)v23 + 4) = v27;
        *((_OWORD *)v23 + 5) = v28;
        __int128 v30 = v54;
        __int128 v31 = v55;
        __int128 v32 = v56;
        *((void *)v23 + 22) = v57;
        *((_OWORD *)v23 + 9) = v31;
        *((_OWORD *)v23 + 10) = v32;
        *((_OWORD *)v23 + 8) = v30;
        double v34 = *a2;
        __int16 v33 = a2[1];
        __int16 v35 = v23;
        if (v33 != *a2)
        {
          do
          {
            __int128 v36 = *(_OWORD *)(v33 - 184);
            __int128 v37 = *(_OWORD *)(v33 - 168);
            __int128 v38 = *(_OWORD *)(v33 - 152);
            *(_OWORD *)(v35 - 136) = *(_OWORD *)(v33 - 136);
            *(_OWORD *)(v35 - 152) = v38;
            *(_OWORD *)(v35 - 168) = v37;
            *(_OWORD *)(v35 - 184) = v36;
            __int128 v39 = *(_OWORD *)(v33 - 120);
            __int128 v40 = *(_OWORD *)(v33 - 104);
            __int128 v41 = *(_OWORD *)(v33 - 88);
            *(_OWORD *)(v35 - 72) = *(_OWORD *)(v33 - 72);
            *(_OWORD *)(v35 - 88) = v41;
            *(_OWORD *)(v35 - 104) = v40;
            *(_OWORD *)(v35 - 120) = v39;
            __int128 v42 = *(_OWORD *)(v33 - 56);
            __int128 v43 = *(_OWORD *)(v33 - 40);
            __int128 v44 = *(_OWORD *)(v33 - 24);
            *((void *)v35 - 1) = *((void *)v33 - 1);
            *(_OWORD *)(v35 - 24) = v44;
            *(_OWORD *)(v35 - 40) = v43;
            *(_OWORD *)(v35 - 56) = v42;
            v35 -= 184;
            v33 -= 184;
          }

          while (v33 != v34);
          __int16 v33 = *a2;
        }

        __int16 v17 = v23 + 184;
        *a2 = v35;
        a2[1] = v23 + 184;
        a2[2] = &v22[184 * v21];
        if (v33) {
          operator delete(v33);
        }
      }

      else
      {
        __int128 v8 = v46;
        __int128 v9 = v47;
        __int128 v10 = v49;
        *(_OWORD *)(v6 + 32) = v48;
        *(_OWORD *)(v6 + 48) = v10;
        *(_OWORD *)unint64_t v6 = v8;
        *(_OWORD *)(v6 + 16) = v9;
        __int128 v11 = v50;
        __int128 v12 = v51;
        __int128 v13 = v53;
        *(_OWORD *)(v6 + 96) = v52;
        *(_OWORD *)(v6 + 112) = v13;
        *(_OWORD *)(v6 + 64) = v11;
        *(_OWORD *)(v6 + 80) = v12;
        __int128 v14 = v54;
        __int128 v15 = v55;
        __int128 v16 = v56;
        *(void *)(v6 + 176) = v57;
        *(_OWORD *)(v6 + 144) = v15;
        *(_OWORD *)(v6 + 160) = v16;
        *(_OWORD *)(v6 + 128) = v14;
        __int16 v17 = (char *)(v6 + 184);
      }

      a2[1] = v17;
    }

    uint64_t result = sub_1003C05BC(*(void *)(a1 + 80));
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100E3287C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E328AC(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  unint64_t v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)a2 = sqlite3_column_int(v6, 0);
  unint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 8) = sqlite3_column_double(v7, 1);
  __int128 v8 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)(a2 + 16) = sqlite3_column_int(v8, 2);
  __int128 v9 = (sqlite3_stmt *)sub_100019240(*a1);
  __int128 v10 = sqlite3_column_text(v9, 3);
  uuid_parse((const char *)v10, (unsigned __int8 *)(a2 + 24));
  __int128 v11 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 40) = sqlite3_column_double(v11, 4);
  __int128 v12 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)(a2 + 48) = sqlite3_column_int(v12, 5);
  __int128 v13 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 64) = sqlite3_column_double(v13, 6);
  __int128 v14 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 56) = sqlite3_column_double(v14, 7);
  __int128 v15 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 72) = sqlite3_column_double(v15, 8);
  __int128 v16 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 96) = sqlite3_column_double(v16, 9);
  __int16 v17 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 104) = sqlite3_column_double(v17, 10);
  unint64_t v18 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 112) = sqlite3_column_double(v18, 11);
  unint64_t v19 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 80) = sqlite3_column_double(v19, 12);
  unint64_t v20 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 88) = sqlite3_column_double(v20, 13);
  unint64_t v21 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 120) = sqlite3_column_double(v21, 14);
  int v22 = (sqlite3_stmt *)sub_100019240(*a1);
  *(_DWORD *)(a2 + 176) = sqlite3_column_int(v22, 15);
  unsigned __int16 v23 = (sqlite3_stmt *)sub_100019240(*a1);
  int v24 = sqlite3_column_int(v23, 16);
  uint64_t result = 0LL;
  *(_DWORD *)(a2 + 180) = v24;
  return result;
}

uint64_t sub_100E32A64(uint64_t a1)
{
  uint64_t v3 = v8;
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(v8);
  int v5 = sqlite3_step(v4);
  if (v5 == 100)
  {
    unint64_t v6 = (sqlite3_stmt *)sub_100019240(v3);
    uint64_t v1 = sqlite3_column_int(v6, 0);
  }

  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v5 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_100E32B04(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E32B28(uint64_t a1)
{
  return sub_100E32A64(a1 - 72);
}

uint64_t sub_100E32B30(uint64_t a1, char **a2, double a3)
{
  if ((sub_100D8A92C(a1 + 72) & 1) != 0)
  {
    a2[1] = *a2;
    sub_1003C0D54( *(void *)(a1 + 80),  "SELECT * FROM VO2MaxSummaryHistory WHERE pointCount > 0 AND startTime > ? ORDER BY startTime DESC",  buf);
    uint64_t v6 = *(void *)buf;
    v51[0] = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = 0x7FEFFFFFFFFFFFFFLL;
    *(void *)&__int128 v53 = 0LL;
    *((void *)&v54 + 1) = 0x7FEFFFFFFFFFFFFFLL;
    __int128 v55 = 0u;
    __int128 v56 = 0u;
    __int128 v57 = 0u;
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    LODWORD(v63) = 1;
    unint64_t v7 = (sqlite3_stmt *)sub_100019240(v51[0]);
    if (sub_1003C28BC(v7, 1, (int)a3))
    {
      while (!sub_100E328AC(v51, (uint64_t)buf))
      {
        unint64_t v8 = (unint64_t)a2[1];
        unint64_t v9 = (unint64_t)a2[2];
        if (v8 >= v9)
        {
          unint64_t v20 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v8 - (void)*a2) >> 3);
          unint64_t v21 = v20 + 1;
          if (v20 + 1 > 0x1642C8590B21642LL) {
            sub_100007008();
          }
          unint64_t v22 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v9 - (void)*a2) >> 3);
          if (2 * v22 > v21) {
            unint64_t v21 = 2 * v22;
          }
          if (v22 >= 0xB21642C8590B21LL) {
            unint64_t v23 = 0x1642C8590B21642LL;
          }
          else {
            unint64_t v23 = v21;
          }
          if (v23) {
            int v24 = (char *)sub_1002DF6FC((uint64_t)(a2 + 2), v23);
          }
          else {
            int v24 = 0LL;
          }
          __int128 v25 = &v24[184 * v20];
          __int128 v26 = *(_OWORD *)buf;
          __int128 v27 = v53;
          __int128 v28 = v55;
          *((_OWORD *)v25 + 2) = v54;
          *((_OWORD *)v25 + 3) = v28;
          *(_OWORD *)__int128 v25 = v26;
          *((_OWORD *)v25 + 1) = v27;
          __int128 v29 = v56;
          __int128 v30 = v57;
          __int128 v31 = v59;
          *((_OWORD *)v25 + 6) = v58;
          *((_OWORD *)v25 + 7) = v31;
          *((_OWORD *)v25 + 4) = v29;
          *((_OWORD *)v25 + 5) = v30;
          __int128 v32 = v60;
          __int128 v33 = v61;
          __int128 v34 = v62;
          *((void *)v25 + 22) = v63;
          *((_OWORD *)v25 + 9) = v33;
          *((_OWORD *)v25 + 10) = v34;
          *((_OWORD *)v25 + 8) = v32;
          __int128 v36 = *a2;
          __int16 v35 = a2[1];
          __int128 v37 = v25;
          if (v35 != *a2)
          {
            do
            {
              __int128 v38 = *(_OWORD *)(v35 - 184);
              __int128 v39 = *(_OWORD *)(v35 - 168);
              __int128 v40 = *(_OWORD *)(v35 - 152);
              *(_OWORD *)(v37 - 136) = *(_OWORD *)(v35 - 136);
              *(_OWORD *)(v37 - 152) = v40;
              *(_OWORD *)(v37 - 168) = v39;
              *(_OWORD *)(v37 - 184) = v38;
              __int128 v41 = *(_OWORD *)(v35 - 120);
              __int128 v42 = *(_OWORD *)(v35 - 104);
              __int128 v43 = *(_OWORD *)(v35 - 88);
              *(_OWORD *)(v37 - 72) = *(_OWORD *)(v35 - 72);
              *(_OWORD *)(v37 - 88) = v43;
              *(_OWORD *)(v37 - 104) = v42;
              *(_OWORD *)(v37 - 120) = v41;
              __int128 v44 = *(_OWORD *)(v35 - 56);
              __int128 v45 = *(_OWORD *)(v35 - 40);
              __int128 v46 = *(_OWORD *)(v35 - 24);
              *((void *)v37 - 1) = *((void *)v35 - 1);
              *(_OWORD *)(v37 - 24) = v46;
              *(_OWORD *)(v37 - 40) = v45;
              *(_OWORD *)(v37 - 56) = v44;
              v37 -= 184;
              v35 -= 184;
            }

            while (v35 != v36);
            __int16 v35 = *a2;
          }

          unint64_t v19 = v25 + 184;
          *a2 = v37;
          a2[1] = v25 + 184;
          a2[2] = &v24[184 * v23];
          if (v35) {
            operator delete(v35);
          }
        }

        else
        {
          __int128 v10 = *(_OWORD *)buf;
          __int128 v11 = v53;
          __int128 v12 = v55;
          *(_OWORD *)(v8 + 32) = v54;
          *(_OWORD *)(v8 + 48) = v12;
          *(_OWORD *)unint64_t v8 = v10;
          *(_OWORD *)(v8 + 16) = v11;
          __int128 v13 = v56;
          __int128 v14 = v57;
          __int128 v15 = v59;
          *(_OWORD *)(v8 + 96) = v58;
          *(_OWORD *)(v8 + 112) = v15;
          *(_OWORD *)(v8 + 64) = v13;
          *(_OWORD *)(v8 + 80) = v14;
          __int128 v16 = v60;
          __int128 v17 = v61;
          __int128 v18 = v62;
          *(void *)(v8 + 176) = v63;
          *(_OWORD *)(v8 + 144) = v17;
          *(_OWORD *)(v8 + 160) = v18;
          *(_OWORD *)(v8 + 128) = v16;
          unint64_t v19 = (char *)(v8 + 184);
        }

        a2[1] = v19;
      }
    }

    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
    return 100LL;
  }

  else
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_101886E88);
    }
    __int128 v47 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEBUG,  "VO2MaxSummaryHistory, DB not accessible",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_101886E88);
      }
      LOWORD(v51[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  2LL,  "VO2MaxSummaryHistory, DB not accessible",  v51,  2);
      __int128 v50 = (uint8_t *)v49;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLVO2MaxSummaryRecorderDb::querySince(const CFAbsoluteTime, std::vector<VO2MaxSummary> &) const",  "%s\n",  v49);
      if (v50 != buf) {
        free(v50);
      }
    }

    return 109LL;
  }

void sub_100E32F4C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100E32F78(uint64_t a1, int a2, char **a3, double a4)
{
  if ((sub_100D8A92C(a1 + 72) & 1) != 0)
  {
    a3[1] = *a3;
    sub_1003C0D54( *(void *)(a1 + 80),  "SELECT vsh.* FROM VO2MaxSummaryHistory vsh INNER JOIN VO2MaxSessionAttributesHistory vsah ON vsh.sessionId = vsah. sessionId WHERE vsah.betaBlockerUse = ? AND vsh.pointCount > 0 AND vsh.startTime > ? ORDER BY vsh.startTime DESC",  buf);
    uint64_t v8 = *(void *)buf;
    v54[0] = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = 0x7FEFFFFFFFFFFFFFLL;
    *(void *)&__int128 v56 = 0LL;
    *((void *)&v57 + 1) = 0x7FEFFFFFFFFFFFFFLL;
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    __int128 v63 = 0u;
    __int128 v64 = 0u;
    __int128 v65 = 0u;
    LODWORD(v66) = 1;
    unint64_t v9 = (sqlite3_stmt *)sub_100019240(v54[0]);
    if (sub_1003C28BC(v9, 1, a2))
    {
      __int128 v10 = (sqlite3_stmt *)sub_100019240(v8);
      if (sub_1003C28BC(v10, 2, (int)a4))
      {
        while (!sub_100E328AC(v54, (uint64_t)buf))
        {
          unint64_t v11 = (unint64_t)a3[1];
          unint64_t v12 = (unint64_t)a3[2];
          if (v11 >= v12)
          {
            unint64_t v23 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v11 - (void)*a3) >> 3);
            unint64_t v24 = v23 + 1;
            if (v23 + 1 > 0x1642C8590B21642LL) {
              sub_100007008();
            }
            unint64_t v25 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v12 - (void)*a3) >> 3);
            if (2 * v25 > v24) {
              unint64_t v24 = 2 * v25;
            }
            if (v25 >= 0xB21642C8590B21LL) {
              unint64_t v26 = 0x1642C8590B21642LL;
            }
            else {
              unint64_t v26 = v24;
            }
            if (v26) {
              __int128 v27 = (char *)sub_1002DF6FC((uint64_t)(a3 + 2), v26);
            }
            else {
              __int128 v27 = 0LL;
            }
            __int128 v28 = &v27[184 * v23];
            __int128 v29 = *(_OWORD *)buf;
            __int128 v30 = v56;
            __int128 v31 = v58;
            *((_OWORD *)v28 + 2) = v57;
            *((_OWORD *)v28 + 3) = v31;
            *(_OWORD *)__int128 v28 = v29;
            *((_OWORD *)v28 + 1) = v30;
            __int128 v32 = v59;
            __int128 v33 = v60;
            __int128 v34 = v62;
            *((_OWORD *)v28 + 6) = v61;
            *((_OWORD *)v28 + 7) = v34;
            *((_OWORD *)v28 + 4) = v32;
            *((_OWORD *)v28 + 5) = v33;
            __int128 v35 = v63;
            __int128 v36 = v64;
            __int128 v37 = v65;
            *((void *)v28 + 22) = v66;
            *((_OWORD *)v28 + 9) = v36;
            *((_OWORD *)v28 + 10) = v37;
            *((_OWORD *)v28 + 8) = v35;
            __int128 v39 = *a3;
            __int128 v38 = a3[1];
            __int128 v40 = v28;
            if (v38 != *a3)
            {
              do
              {
                __int128 v41 = *(_OWORD *)(v38 - 184);
                __int128 v42 = *(_OWORD *)(v38 - 168);
                __int128 v43 = *(_OWORD *)(v38 - 152);
                *(_OWORD *)(v40 - 136) = *(_OWORD *)(v38 - 136);
                *(_OWORD *)(v40 - 152) = v43;
                *(_OWORD *)(v40 - 168) = v42;
                *(_OWORD *)(v40 - 184) = v41;
                __int128 v44 = *(_OWORD *)(v38 - 120);
                __int128 v45 = *(_OWORD *)(v38 - 104);
                __int128 v46 = *(_OWORD *)(v38 - 88);
                *(_OWORD *)(v40 - 72) = *(_OWORD *)(v38 - 72);
                *(_OWORD *)(v40 - 88) = v46;
                *(_OWORD *)(v40 - 104) = v45;
                *(_OWORD *)(v40 - 120) = v44;
                __int128 v47 = *(_OWORD *)(v38 - 56);
                __int128 v48 = *(_OWORD *)(v38 - 40);
                __int128 v49 = *(_OWORD *)(v38 - 24);
                *((void *)v40 - 1) = *((void *)v38 - 1);
                *(_OWORD *)(v40 - 24) = v49;
                *(_OWORD *)(v40 - 40) = v48;
                *(_OWORD *)(v40 - 56) = v47;
                v40 -= 184;
                v38 -= 184;
              }

              while (v38 != v39);
              __int128 v38 = *a3;
            }

            unint64_t v22 = v28 + 184;
            *a3 = v40;
            a3[1] = v28 + 184;
            a3[2] = &v27[184 * v26];
            if (v38) {
              operator delete(v38);
            }
          }

          else
          {
            __int128 v13 = *(_OWORD *)buf;
            __int128 v14 = v56;
            __int128 v15 = v58;
            *(_OWORD *)(v11 + 32) = v57;
            *(_OWORD *)(v11 + 48) = v15;
            *(_OWORD *)unint64_t v11 = v13;
            *(_OWORD *)(v11 + 16) = v14;
            __int128 v16 = v59;
            __int128 v17 = v60;
            __int128 v18 = v62;
            *(_OWORD *)(v11 + 96) = v61;
            *(_OWORD *)(v11 + 112) = v18;
            *(_OWORD *)(v11 + 64) = v16;
            *(_OWORD *)(v11 + 80) = v17;
            __int128 v19 = v63;
            __int128 v20 = v64;
            __int128 v21 = v65;
            *(void *)(v11 + 176) = v66;
            *(_OWORD *)(v11 + 144) = v20;
            *(_OWORD *)(v11 + 160) = v21;
            *(_OWORD *)(v11 + 128) = v19;
            unint64_t v22 = (char *)(v11 + 184);
          }

          a3[1] = v22;
        }
      }
    }

    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    }
    return 100LL;
  }

  else
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_101886E88);
    }
    __int128 v50 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEBUG,  "VO2MaxSummaryHistory, DB not accessible",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_101886E88);
      }
      LOWORD(v54[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  2LL,  "VO2MaxSummaryHistory, DB not accessible",  v54,  2);
      __int128 v53 = (uint8_t *)v52;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLVO2MaxSummaryRecorderDb::querySinceAndFilterByBetaBlockerUse(const CFAbsoluteTime, BOOL, std::vector<V O2MaxSummary> &) const",  "%s\n",  v52);
      if (v53 != buf) {
        free(v53);
      }
    }

    return 109LL;
  }

void sub_100E333B0(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100E333DC(uint64_t a1, char **a2, double a3, double a4)
{
  if ((sub_100D8A92C(a1 + 72) & 1) != 0)
  {
    a2[1] = *a2;
    sub_1003C0D54( *(void *)(a1 + 80),  "SELECT * FROM VO2MaxSummaryHistory WHERE pointCount > 0 AND startTime > ? and startTime < ? ORDER BY startTime DESC",  buf);
    uint64_t v8 = *(void *)buf;
    v53[0] = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = 0x7FEFFFFFFFFFFFFFLL;
    *(void *)&__int128 v55 = 0LL;
    *((void *)&v56 + 1) = 0x7FEFFFFFFFFFFFFFLL;
    __int128 v57 = 0u;
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    __int128 v63 = 0u;
    __int128 v64 = 0u;
    LODWORD(v65) = 1;
    unint64_t v9 = (sqlite3_stmt *)sub_100019240(v53[0]);
    if (sub_1003C28BC(v9, 1, (int)a3))
    {
      __int128 v10 = (sqlite3_stmt *)sub_100019240(v8);
      if (sub_1003C28BC(v10, 2, (int)a4))
      {
        while (!sub_100E328AC(v53, (uint64_t)buf))
        {
          unint64_t v11 = (unint64_t)a2[1];
          unint64_t v12 = (unint64_t)a2[2];
          if (v11 >= v12)
          {
            unint64_t v23 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v11 - (void)*a2) >> 3);
            unint64_t v24 = v23 + 1;
            if (v23 + 1 > 0x1642C8590B21642LL) {
              sub_100007008();
            }
            unint64_t v25 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v12 - (void)*a2) >> 3);
            if (2 * v25 > v24) {
              unint64_t v24 = 2 * v25;
            }
            if (v25 >= 0xB21642C8590B21LL) {
              unint64_t v26 = 0x1642C8590B21642LL;
            }
            else {
              unint64_t v26 = v24;
            }
            if (v26) {
              __int128 v27 = (char *)sub_1002DF6FC((uint64_t)(a2 + 2), v26);
            }
            else {
              __int128 v27 = 0LL;
            }
            __int128 v28 = &v27[184 * v23];
            __int128 v29 = *(_OWORD *)buf;
            __int128 v30 = v55;
            __int128 v31 = v57;
            *((_OWORD *)v28 + 2) = v56;
            *((_OWORD *)v28 + 3) = v31;
            *(_OWORD *)__int128 v28 = v29;
            *((_OWORD *)v28 + 1) = v30;
            __int128 v32 = v58;
            __int128 v33 = v59;
            __int128 v34 = v61;
            *((_OWORD *)v28 + 6) = v60;
            *((_OWORD *)v28 + 7) = v34;
            *((_OWORD *)v28 + 4) = v32;
            *((_OWORD *)v28 + 5) = v33;
            __int128 v35 = v62;
            __int128 v36 = v63;
            __int128 v37 = v64;
            *((void *)v28 + 22) = v65;
            *((_OWORD *)v28 + 9) = v36;
            *((_OWORD *)v28 + 10) = v37;
            *((_OWORD *)v28 + 8) = v35;
            __int128 v39 = *a2;
            __int128 v38 = a2[1];
            __int128 v40 = v28;
            if (v38 != *a2)
            {
              do
              {
                __int128 v41 = *(_OWORD *)(v38 - 184);
                __int128 v42 = *(_OWORD *)(v38 - 168);
                __int128 v43 = *(_OWORD *)(v38 - 152);
                *(_OWORD *)(v40 - 136) = *(_OWORD *)(v38 - 136);
                *(_OWORD *)(v40 - 152) = v43;
                *(_OWORD *)(v40 - 168) = v42;
                *(_OWORD *)(v40 - 184) = v41;
                __int128 v44 = *(_OWORD *)(v38 - 120);
                __int128 v45 = *(_OWORD *)(v38 - 104);
                __int128 v46 = *(_OWORD *)(v38 - 88);
                *(_OWORD *)(v40 - 72) = *(_OWORD *)(v38 - 72);
                *(_OWORD *)(v40 - 88) = v46;
                *(_OWORD *)(v40 - 104) = v45;
                *(_OWORD *)(v40 - 120) = v44;
                __int128 v47 = *(_OWORD *)(v38 - 56);
                __int128 v48 = *(_OWORD *)(v38 - 40);
                __int128 v49 = *(_OWORD *)(v38 - 24);
                *((void *)v40 - 1) = *((void *)v38 - 1);
                *(_OWORD *)(v40 - 24) = v49;
                *(_OWORD *)(v40 - 40) = v48;
                *(_OWORD *)(v40 - 56) = v47;
                v40 -= 184;
                v38 -= 184;
              }

              while (v38 != v39);
              __int128 v38 = *a2;
            }

            unint64_t v22 = v28 + 184;
            *a2 = v40;
            a2[1] = v28 + 184;
            a2[2] = &v27[184 * v26];
            if (v38) {
              operator delete(v38);
            }
          }

          else
          {
            __int128 v13 = *(_OWORD *)buf;
            __int128 v14 = v55;
            __int128 v15 = v57;
            *(_OWORD *)(v11 + 32) = v56;
            *(_OWORD *)(v11 + 48) = v15;
            *(_OWORD *)unint64_t v11 = v13;
            *(_OWORD *)(v11 + 16) = v14;
            __int128 v16 = v58;
            __int128 v17 = v59;
            __int128 v18 = v61;
            *(_OWORD *)(v11 + 96) = v60;
            *(_OWORD *)(v11 + 112) = v18;
            *(_OWORD *)(v11 + 64) = v16;
            *(_OWORD *)(v11 + 80) = v17;
            __int128 v19 = v62;
            __int128 v20 = v63;
            __int128 v21 = v64;
            *(void *)(v11 + 176) = v65;
            *(_OWORD *)(v11 + 144) = v20;
            *(_OWORD *)(v11 + 160) = v21;
            *(_OWORD *)(v11 + 128) = v19;
            unint64_t v22 = (char *)(v11 + 184);
          }

          a2[1] = v22;
        }
      }
    }

    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    }
    return 100LL;
  }

  else
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_101886E88);
    }
    __int128 v50 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEBUG,  "VO2MaxSummaryHistory, DB not accessible",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_101886E88);
      }
      LOWORD(v53[0]) = 0;
      __int128 v52 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  2LL,  "VO2MaxSummaryHistory, DB not accessible",  v53,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLVO2MaxSummaryRecorderDb::queryInTimeRange(CFAbsoluteTime, CFAbsoluteTime, std::vector<VO2MaxSummary> &) const",  "%s\n",  v52);
    }

    return 109LL;
  }

void sub_100E33814(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100E33840(uint64_t a1, const unsigned __int8 *a2, char **a3)
{
  if ((sub_100D8A92C(a1 + 72) & 1) != 0)
  {
    a3[1] = *a3;
    uuid_unparse(a2, out);
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * from VO2MaxSummaryHistory WHERE sessionId = ?", buf);
    uint64_t v6 = *(void *)buf;
    uint64_t v50 = *(void *)buf;
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = 0x7FEFFFFFFFFFFFFFLL;
    *(void *)&__int128 v53 = 0LL;
    *((void *)&v54 + 1) = 0x7FEFFFFFFFFFFFFFLL;
    __int128 v55 = 0u;
    __int128 v56 = 0u;
    __int128 v57 = 0u;
    __int128 v58 = 0u;
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    LODWORD(v63) = 1;
    unint64_t v7 = (sqlite3_stmt *)sub_100019240(v6);
    if (sub_1003BC1F0(v7, 1, out))
    {
      while (!sub_100E328AC(&v50, (uint64_t)buf))
      {
        unint64_t v8 = (unint64_t)a3[1];
        unint64_t v9 = (unint64_t)a3[2];
        if (v8 >= v9)
        {
          unint64_t v20 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v8 - (void)*a3) >> 3);
          unint64_t v21 = v20 + 1;
          if (v20 + 1 > 0x1642C8590B21642LL) {
            sub_100007008();
          }
          unint64_t v22 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v9 - (void)*a3) >> 3);
          if (2 * v22 > v21) {
            unint64_t v21 = 2 * v22;
          }
          if (v22 >= 0xB21642C8590B21LL) {
            unint64_t v23 = 0x1642C8590B21642LL;
          }
          else {
            unint64_t v23 = v21;
          }
          if (v23) {
            unint64_t v24 = (char *)sub_1002DF6FC((uint64_t)(a3 + 2), v23);
          }
          else {
            unint64_t v24 = 0LL;
          }
          unint64_t v25 = &v24[184 * v20];
          __int128 v26 = *(_OWORD *)buf;
          __int128 v27 = v53;
          __int128 v28 = v55;
          *((_OWORD *)v25 + 2) = v54;
          *((_OWORD *)v25 + 3) = v28;
          *(_OWORD *)unint64_t v25 = v26;
          *((_OWORD *)v25 + 1) = v27;
          __int128 v29 = v56;
          __int128 v30 = v57;
          __int128 v31 = v59;
          *((_OWORD *)v25 + 6) = v58;
          *((_OWORD *)v25 + 7) = v31;
          *((_OWORD *)v25 + 4) = v29;
          *((_OWORD *)v25 + 5) = v30;
          __int128 v32 = v60;
          __int128 v33 = v61;
          __int128 v34 = v62;
          *((void *)v25 + 22) = v63;
          *((_OWORD *)v25 + 9) = v33;
          *((_OWORD *)v25 + 10) = v34;
          *((_OWORD *)v25 + 8) = v32;
          __int128 v36 = *a3;
          __int128 v35 = a3[1];
          __int128 v37 = v25;
          if (v35 != *a3)
          {
            do
            {
              __int128 v38 = *(_OWORD *)(v35 - 184);
              __int128 v39 = *(_OWORD *)(v35 - 168);
              __int128 v40 = *(_OWORD *)(v35 - 152);
              *(_OWORD *)(v37 - 136) = *(_OWORD *)(v35 - 136);
              *(_OWORD *)(v37 - 152) = v40;
              *(_OWORD *)(v37 - 168) = v39;
              *(_OWORD *)(v37 - 184) = v38;
              __int128 v41 = *(_OWORD *)(v35 - 120);
              __int128 v42 = *(_OWORD *)(v35 - 104);
              __int128 v43 = *(_OWORD *)(v35 - 88);
              *(_OWORD *)(v37 - 72) = *(_OWORD *)(v35 - 72);
              *(_OWORD *)(v37 - 88) = v43;
              *(_OWORD *)(v37 - 104) = v42;
              *(_OWORD *)(v37 - 120) = v41;
              __int128 v44 = *(_OWORD *)(v35 - 56);
              __int128 v45 = *(_OWORD *)(v35 - 40);
              __int128 v46 = *(_OWORD *)(v35 - 24);
              *((void *)v37 - 1) = *((void *)v35 - 1);
              *(_OWORD *)(v37 - 24) = v46;
              *(_OWORD *)(v37 - 40) = v45;
              *(_OWORD *)(v37 - 56) = v44;
              v37 -= 184;
              v35 -= 184;
            }

            while (v35 != v36);
            __int128 v35 = *a3;
          }

          __int128 v19 = v25 + 184;
          *a3 = v37;
          a3[1] = v25 + 184;
          a3[2] = &v24[184 * v23];
          if (v35) {
            operator delete(v35);
          }
        }

        else
        {
          __int128 v10 = *(_OWORD *)buf;
          __int128 v11 = v53;
          __int128 v12 = v55;
          *(_OWORD *)(v8 + 32) = v54;
          *(_OWORD *)(v8 + 48) = v12;
          *(_OWORD *)unint64_t v8 = v10;
          *(_OWORD *)(v8 + 16) = v11;
          __int128 v13 = v56;
          __int128 v14 = v57;
          __int128 v15 = v59;
          *(_OWORD *)(v8 + 96) = v58;
          *(_OWORD *)(v8 + 112) = v15;
          *(_OWORD *)(v8 + 64) = v13;
          *(_OWORD *)(v8 + 80) = v14;
          __int128 v16 = v60;
          __int128 v17 = v61;
          __int128 v18 = v62;
          *(void *)(v8 + 176) = v63;
          *(_OWORD *)(v8 + 144) = v17;
          *(_OWORD *)(v8 + 160) = v18;
          *(_OWORD *)(v8 + 128) = v16;
          __int128 v19 = (char *)(v8 + 184);
        }

        a3[1] = v19;
      }
    }

    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
    return 100LL;
  }

  else
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_101886E88);
    }
    __int128 v47 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEBUG,  "VO2MaxSummaryHistory, DB not accessible",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_101886E88);
      }
      *(_WORD *)out = 0;
      __int128 v49 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  2LL,  "VO2MaxSummaryHistory, DB not accessible",  out,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLVO2MaxSummaryRecorderDb::queryBySessionId(unsigned char *, std::vector<VO2MaxSummary> &) const",  "%s\n",  v49);
    }

    return 109LL;
  }

void sub_100E33C6C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100E33C98(uint64_t a1, const unsigned __int8 *a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    uuid_unparse(a2, out);
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM VO2MaxSummaryHistory WHERE sessionId = ?", buf);
    uint64_t v5 = *(void *)buf;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
    uint64_t result = sub_1003BC1F0(v6, 1, out);
    if ((_DWORD)result)
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_101886E88);
      }
      unint64_t v7 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = out;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "Deleting VO2MaxSummaryHistory records from db where sessionId = %{public}s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_101886E88);
        }
        int v12 = 136446210;
        __int128 v13 = out;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  2LL,  "Deleting VO2MaxSummaryHistory records from db where sessionId = %{public}s",  &v12,  12);
        __int128 v11 = (char *)v10;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLVO2MaxSummaryRecorderDb::deleteRecordsForSessionId(unsigned char *)",  "%s\n",  v10);
        if (v11 != buf) {
          free(v11);
        }
      }

      uint64_t v8 = *(void *)(a1 + 80);
      unint64_t v9 = (sqlite3_stmt *)sub_100019240(v5);
      uint64_t result = sub_1003BB2BC(v8, v9);
    }

    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100E33EC0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100E33EEC@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "VO2MaxSummaryHistory");
}

void *sub_100E33EFC@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "VO2MaxSummaryHistory");
}

uint64_t sub_100E33F0C(uint64_t a1)
{
  uint64_t result = sub_1003C1048(*(void *)(a1 + 80));
  if ((_DWORD)result)
  {
    sub_100E33F68(a1);
    uint64_t result = sub_1003B59A0( *(void *)(a1 + 80),  "VO2MaxSummaryHistory",  (const char **)&off_101886EA8,  (const std::string::value_type **)&off_101991248,  0);
    *(_BYTE *)(a1 + 488) = 1;
  }

  return result;
}

void sub_100E33F68(uint64_t a1)
{
  if (sub_1003B747C(*(void *)(a1 + 80), "VO2MaxSummaryHistory"))
  {
    uint64_t v2 = 0LL;
    int v3 = 0;
    unint64_t v7 = "meanCadence";
    do
    {
      __int128 v43 = v7;
      int v44 = 5;
      __int16 v45 = 0;
      char v46 = 0;
      char v47 = 0;
      if ((sub_1003BC790(*(void *)(a1 + 80), "VO2MaxSummaryHistory", v7, (uint64_t)&v43) & 1) == 0)
      {
        sub_1003C0454(*(void *)(a1 + 80));
        sub_10000CE18((uint64_t)v39);
        uint64_t v8 = sub_10000CF44(&v40, (uint64_t)"ALTER TABLE VO2MaxSummaryHistory ADD COLUMN ", 44LL);
        size_t v9 = strlen(v7);
        __int128 v10 = sub_10000CF44(v8, (uint64_t)v7, v9);
        __int128 v11 = sub_10000CF44(v10, (uint64_t)" ", 1LL);
        int v12 = (const char *)sub_1003BCC40((int)(&off_101886EA8)[v2 + 85]);
        size_t v13 = strlen(v12);
        __int128 v14 = sub_10000CF44(v11, (uint64_t)v12, v13);
        sub_10000CF44(v14, (uint64_t)";", 1LL);
        uint64_t v15 = *(void *)(a1 + 80);
        std::stringbuf::str(&v36, &v41);
        if ((v36.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v16 = &v36;
        }
        else {
          __int128 v16 = (std::stringbuf::string_type *)v36.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v15, (char *)v16, &v34);
        uint64_t v17 = v34.__r_.__value_.__r.__words[0];
        v34.__r_.__value_.__r.__words[0] = 0LL;
        uint64_t v18 = *(void *)(a1 + 80);
        __int128 v19 = (sqlite3_stmt *)sub_100019240(v17);
        sub_1003BB2BC(v18, v19);
        sub_10000CE18((uint64_t)&v36);
        if (!strcmp(v7, "vo2MaxModelSource"))
        {
          unint64_t v25 = sub_10000CF44(&v36.__r_.__value_.__l.__cap_, (uint64_t)"UPDATE VO2MaxSummaryHistory SET ", 32LL);
          size_t v26 = strlen(v7);
          __int128 v27 = sub_10000CF44(v25, (uint64_t)v7, v26);
          __int128 v28 = sub_10000CF44(v27, (uint64_t)" = ", 3LL);
          unint64_t v22 = (void *)std::ostream::operator<<(v28, 0xFFFFFFFFLL);
          unint64_t v23 = ";";
          uint64_t v24 = 1LL;
        }

        else
        {
          unint64_t v20 = sub_10000CF44(&v36.__r_.__value_.__l.__cap_, (uint64_t)"UPDATE VO2MaxSummaryHistory SET ", 32LL);
          size_t v21 = strlen(v7);
          unint64_t v22 = sub_10000CF44(v20, (uint64_t)v7, v21);
          unint64_t v23 = " = 0;";
          uint64_t v24 = 5LL;
        }

        sub_10000CF44(v22, (uint64_t)v23, v24);
        uint64_t v29 = *(void *)(a1 + 80);
        std::stringbuf::str(&v34, &v37);
        if ((v34.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int128 v30 = &v34;
        }
        else {
          __int128 v30 = (std::stringbuf::string_type *)v34.__r_.__value_.__r.__words[0];
        }
        sub_1003C0D54(v29, (char *)v30, &v35);
        uint64_t v31 = v35;
        uint64_t v35 = 0LL;
        uint64_t v32 = *(void *)(a1 + 80);
        __int128 v33 = (sqlite3_stmt *)sub_100019240(v31);
        sub_1003BB2BC(v32, v33);
        sub_1003C05BC(*(void *)(a1 + 80));
        if (v31) {
          (*(void (**)(uint64_t))(*(void *)v31 + 8LL))(v31);
        }
        v36.__r_.__value_.__r.__words[0] = v4;
        *(std::string::size_type *)((char *)v36.__r_.__value_.__r.__words + *(void *)(v4 - 24)) = v6;
        v36.__r_.__value_.__l.__cap_ = v5;
        std::streambuf::~streambuf(&v37);
        std::ios::~ios(&v38);
        if (v17) {
          (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
        }
        v39[0] = v4;
        *(void *)((char *)v39 + *(void *)(v4 - 24)) = v6;
        std::string::size_type v40 = v5;
        std::streambuf::~streambuf(&v41);
        std::ios::~ios(&v42);
        int v3 = 1;
      }

      unint64_t v7 = (&off_101886EA8)[v2 + 90];
      v2 += 6LL;
    }

    while (v2 != 18);
    if (((v3 | sub_100E3497C( a1,  "VO2MaxSummaryHistory",  (const char **)&off_101886EA8,  (const std::string::value_type **)&off_101991248)) & 1) != 0) {
      sub_1003BF200(*(void *)(a1 + 80), "VO2MaxSummaryHistory");
    }
    sub_100E35E34(a1);
  }

void sub_100E34380( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a21);
  if (v59) {
    (*(void (**)(uint64_t))(*(void *)v59 + 8LL))(v59);
  }
  sub_1011F8850((uint64_t)&a59);
  _Unwind_Resume(a1);
}

uint64_t sub_100E34418(uint64_t a1)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM VO2MaxSummaryHistory", &v8);
    uint64_t v3 = v8;
    uint64_t v4 = *(void *)(a1 + 80);
    std::string::size_type v5 = (sqlite3_stmt *)sub_100019240(v8);
    sub_1003BB2BC(v4, v5);
    uint64_t v6 = *(void *)(a1 + 80);
    else {
      uint64_t v7 = *(void *)(v6 + 88);
    }
    uint64_t result = sub_1003C1EC0(v6, v7);
    if (v3) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return result;
}

void sub_100E344AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E344CC(uint64_t a1)
{
  return sub_100E34418(a1 - 72);
}

uint64_t sub_100E344D4(uint64_t *a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t *, uint64_t, uint64_t))(*a1 + 120))(a1, a2, 1LL);
    sub_1003C0D54(a1[10], "DELETE FROM VO2MaxSummaryHistory WHERE startTime > ?", &v11);
    uint64_t v5 = v11;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v11);
    if (sub_1003B7480(v6, 1, *(double *)(a2 + 8)))
    {
      uint64_t v7 = a1[10];
      uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
      sub_1003BB2BC(v7, v8);
    }

    uint64_t v9 = a1[10];
    else {
      uint64_t v10 = *(void *)(v9 + 88);
    }
    uint64_t result = sub_1003C1EC0(v9, v10);
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100E3459C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E345BC(uint64_t a1, double a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "UPDATE VO2MaxSummaryHistory SET startTime = startTime + ?", &v9);
    uint64_t v5 = v9;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v9);
    uint64_t result = sub_1003B7480(v6, 1, a2);
    if ((_DWORD)result)
    {
      uint64_t v7 = *(void *)(a1 + 80);
      uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
      uint64_t result = sub_1003BB2BC(v7, v8);
    }

    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100E34654(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E34674(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54( *(void *)(a1 + 80),  "INSERT INTO VO2MaxSummaryHistory (startTime, workoutType, sessionId, durationInSeconds, pointCount, hrMax, hrMin, meanHr, meanVo2, meanSpeed, meanGrade, meanHrConfidence, meanHrCadenceAgreement, meanCadence, vo2MaxModelSource, s essionType) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",  v24);
    uint64_t v5 = *(void *)v24;
    uuid_unparse((const unsigned __int8 *)(a2 + 24), v24);
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v5);
    uint64_t result = sub_1003B7480(v6, 1, *(double *)(a2 + 8));
    if ((_DWORD)result)
    {
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v5);
      uint64_t result = sub_1003C28BC(v7, 2, *(_DWORD *)(a2 + 16));
      if ((_DWORD)result)
      {
        uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
        uint64_t result = sub_1003BC1F0(v8, 3, v24);
        if ((_DWORD)result)
        {
          uint64_t v9 = (sqlite3_stmt *)sub_100019240(v5);
          uint64_t result = sub_1003B7480(v9, 4, *(double *)(a2 + 40));
          if ((_DWORD)result)
          {
            uint64_t v10 = (sqlite3_stmt *)sub_100019240(v5);
            uint64_t result = sub_1003C2D24(v10, 5, *(void *)(a2 + 48));
            if ((_DWORD)result)
            {
              uint64_t v11 = (sqlite3_stmt *)sub_100019240(v5);
              uint64_t result = sub_1003B7480(v11, 6, *(double *)(a2 + 64));
              if ((_DWORD)result)
              {
                int v12 = (sqlite3_stmt *)sub_100019240(v5);
                uint64_t result = sub_1003B7480(v12, 7, *(double *)(a2 + 56));
                if ((_DWORD)result)
                {
                  size_t v13 = (sqlite3_stmt *)sub_100019240(v5);
                  uint64_t result = sub_1003B7480(v13, 8, *(double *)(a2 + 72));
                  if ((_DWORD)result)
                  {
                    __int128 v14 = (sqlite3_stmt *)sub_100019240(v5);
                    uint64_t result = sub_1003B7480(v14, 9, *(double *)(a2 + 96));
                    if ((_DWORD)result)
                    {
                      uint64_t v15 = (sqlite3_stmt *)sub_100019240(v5);
                      uint64_t result = sub_1003B7480(v15, 10, *(double *)(a2 + 104));
                      if ((_DWORD)result)
                      {
                        __int128 v16 = (sqlite3_stmt *)sub_100019240(v5);
                        uint64_t result = sub_1003B7480(v16, 11, *(double *)(a2 + 112));
                        if ((_DWORD)result)
                        {
                          uint64_t v17 = (sqlite3_stmt *)sub_100019240(v5);
                          uint64_t result = sub_1003B7480(v17, 12, *(double *)(a2 + 80));
                          if ((_DWORD)result)
                          {
                            uint64_t v18 = (sqlite3_stmt *)sub_100019240(v5);
                            uint64_t result = sub_1003B7480(v18, 13, *(double *)(a2 + 88));
                            if ((_DWORD)result)
                            {
                              __int128 v19 = (sqlite3_stmt *)sub_100019240(v5);
                              uint64_t result = sub_1003B7480(v19, 14, *(double *)(a2 + 120));
                              if ((_DWORD)result)
                              {
                                unint64_t v20 = (sqlite3_stmt *)sub_100019240(v5);
                                uint64_t result = sub_1003C28BC(v20, 15, *(_DWORD *)(a2 + 176));
                                if ((_DWORD)result)
                                {
                                  size_t v21 = (sqlite3_stmt *)sub_100019240(v5);
                                  uint64_t result = sub_1003C28BC(v21, 16, *(_DWORD *)(a2 + 180));
                                  if ((_DWORD)result)
                                  {
                                    uint64_t v22 = *(void *)(a1 + 80);
                                    unint64_t v23 = (sqlite3_stmt *)sub_100019240(v5);
                                    uint64_t result = sub_1003BB2BC(v22, v23);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100E348AC(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100E348D4()
{
  return 0LL;
}

uint64_t sub_100E348DC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v7;
  uint64_t v8 = v7;
  uint64_t v5 = sub_100E328AC(&v8, a2);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  return v5;
}

void sub_100E3495C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E3497C(uint64_t a1, char *a2, const char **a3, const std::string::value_type **a4)
{
  if (!sub_1003B79FC(*(void *)(a1 + 80), a2))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101887300);
    }
    uint64_t v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s needs autoincrement migration",  (uint8_t *)buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101887300);
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136446210;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s needs autoincrement migration",  &__p,  12);
      int v132 = (std::string *)v131;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<VO2MaxSummary, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const c har *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxSummary, DataProtectionPolicy = CLActivit yDB::ClassBDataProtectionPolicy]",  "%s\n",  v131);
      if (v132 != buf) {
        free(v132);
      }
    }

    memset(&__p, 0, sizeof(__p));
    sub_1010DDBC0(buf, a2);
    uint64_t v9 = std::string::append(buf, "AutoIncr");
    __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t cap = v9->__r_.__value_.__l.__cap_;
    *(_OWORD *)uint64_t v143 = v10;
    v9->__r_.__value_.__l.__size_ = 0LL;
    v9->__r_.__value_.__l.__cap_ = 0LL;
    v9->__r_.__value_.__r.__words[0] = 0LL;
    sub_1010DDBC0(buf, a2);
    uint64_t v11 = std::string::append(buf, "Index");
    __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    int64_t v142 = v11->__r_.__value_.__l.__cap_;
    *(_OWORD *)unint64_t v141 = v12;
    v11->__r_.__value_.__l.__size_ = 0LL;
    v11->__r_.__value_.__l.__cap_ = 0LL;
    v11->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003C0454(*(void *)(a1 + 80));
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t size = __p.__r_.__value_.__l.__size_;
    }
    __int128 v14 = buf;
    sub_1000392EC((uint64_t)buf, size + 21);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int128 v14 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (size)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v14, p_p, size);
    }

    strcpy((char *)v14 + size, "DROP TABLE IF EXISTS ");
    if (cap >= 0) {
      __int128 v16 = v143;
    }
    else {
      __int128 v16 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v17 = HIBYTE(cap);
    }
    else {
      std::string::size_type v17 = (std::string::size_type)v143[1];
    }
    uint64_t v18 = std::string::append(buf, (const std::string::value_type *)v16, v17);
    std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v18->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v20 = v18->__r_.__value_.__s.__size_;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v19;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v20;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v20 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v19 = __p.__r_.__value_.__r.__words[0];
    }

    if (v20 >= 0) {
      size_t v21 = &__p;
    }
    else {
      size_t v21 = (std::string *)v19;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v21, buf);
    uint64_t v22 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v23 = sqlite3_step(v22);
    std::string::size_type v24 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v24) {
      (*(void (**)(std::string::size_type))(*(void *)v24 + 8LL))(v24);
    }
    if (v23 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v25 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v25 = __p.__r_.__value_.__l.__size_;
    }
    size_t v26 = &v148;
    sub_1000392EC((uint64_t)&v148, v25 + 13);
    if ((v148.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      size_t v26 = (std::string *)v148.__r_.__value_.__r.__words[0];
    }
    if (v25)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v27 = &__p;
      }
      else {
        __int128 v27 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v26, v27, v25);
    }

    strcpy((char *)v26 + v25, "CREATE TABLE ");
    if (cap >= 0) {
      __int128 v28 = v143;
    }
    else {
      __int128 v28 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v29 = HIBYTE(cap);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)v143[1];
    }
    __int128 v30 = std::string::append(&v148, (const std::string::value_type *)v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v32 = std::string::append(&v140, " (");
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    sub_1003BE030(a3, 1, 1, (uint64_t)&v139);
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::stringbuf::string_type v34 = &v139;
    }
    else {
      std::stringbuf::string_type v34 = (std::string *)v139.__r_.__value_.__r.__words[0];
    }
    if ((v139.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v35 = v139.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v35 = v139.__r_.__value_.__l.__size_;
    }
    std::stringbuf::string_type v36 = std::string::append(&v149, (const std::string::value_type *)v34, v35);
    __int128 v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v36->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0LL;
    v36->__r_.__value_.__l.__cap_ = 0LL;
    v36->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v38 = std::string::append(buf, ")");
    std::string::size_type v39 = v38->__r_.__value_.__r.__words[0];
    v146.__r_.__value_.__r.__words[0] = v38->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v38->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v40 = v38->__r_.__value_.__s.__size_;
    v38->__r_.__value_.__l.__size_ = 0LL;
    v38->__r_.__value_.__l.__cap_ = 0LL;
    v38->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v39;
    __p.__r_.__value_.__l.__size_ = v146.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v146.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v40;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::stringbuf v41 = &__p;
    }
    else {
      std::stringbuf v41 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v41, buf);
    uint64_t v42 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v43 = sqlite3_step(v42);
    std::string::size_type v44 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v44) {
      (*(void (**)(std::string::size_type))(*(void *)v44 + 8LL))(v44);
    }
    if (v43 != 101) {
      goto LABEL_234;
    }
    sub_1003BE030(a3, 0, 0, (uint64_t)buf);
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v45 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v45 = __p.__r_.__value_.__l.__size_;
    }
    char v46 = &v145;
    sub_1000392EC((uint64_t)&v145, v45 + 12);
    if ((v145.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      char v46 = (std::string *)v145.__r_.__value_.__r.__words[0];
    }
    if (v45)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        char v47 = &__p;
      }
      else {
        char v47 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v46, v47, v45);
    }

    strcpy((char *)v46 + v45, "INSERT INTO ");
    if (cap >= 0) {
      __int128 v48 = v143;
    }
    else {
      __int128 v48 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v49 = HIBYTE(cap);
    }
    else {
      std::string::size_type v49 = (std::string::size_type)v143[1];
    }
    uint64_t v50 = std::string::append(&v145, (const std::string::value_type *)v48, v49);
    __int128 v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v138.__r_.__value_.__l.__cap_ = v50->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v138.__r_.__value_.__l.__data_ = v51;
    v50->__r_.__value_.__l.__size_ = 0LL;
    v50->__r_.__value_.__l.__cap_ = 0LL;
    v50->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v52 = std::string::append(&v138, " (");
    __int128 v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
    v146.__r_.__value_.__l.__cap_ = v52->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v53;
    v52->__r_.__value_.__l.__size_ = 0LL;
    v52->__r_.__value_.__l.__cap_ = 0LL;
    v52->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v54 = buf;
    }
    else {
      __int128 v54 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v55 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v55 = buf[0].__r_.__value_.__l.__size_;
    }
    __int128 v56 = std::string::append(&v146, (const std::string::value_type *)v54, v55);
    __int128 v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
    v139.__r_.__value_.__l.__cap_ = v56->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v57;
    v56->__r_.__value_.__l.__size_ = 0LL;
    v56->__r_.__value_.__l.__cap_ = 0LL;
    v56->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v58 = std::string::append(&v139, ") SELECT ");
    __int128 v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v148.__r_.__value_.__l.__cap_ = v58->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0LL;
    v58->__r_.__value_.__l.__cap_ = 0LL;
    v58->__r_.__value_.__r.__words[0] = 0LL;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v60 = buf;
    }
    else {
      __int128 v60 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v61 = buf[0].__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v61 = buf[0].__r_.__value_.__l.__size_;
    }
    __int128 v62 = std::string::append(&v148, (const std::string::value_type *)v60, v61);
    __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v140.__r_.__value_.__l.__cap_ = v62->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0LL;
    v62->__r_.__value_.__l.__cap_ = 0LL;
    v62->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v64 = std::string::append(&v140, " FROM ");
    __int128 v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v64->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0LL;
    v64->__r_.__value_.__l.__cap_ = 0LL;
    v64->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v66 = std::string::append(&v149, a2);
    std::string::size_type v67 = v66->__r_.__value_.__r.__words[0];
    v147[0] = v66->__r_.__value_.__l.__size_;
    *(void *)((char *)v147 + 7) = *(std::string::size_type *)((char *)&v66->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v68 = v66->__r_.__value_.__s.__size_;
    v66->__r_.__value_.__l.__size_ = 0LL;
    v66->__r_.__value_.__l.__cap_ = 0LL;
    v66->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v67;
    __p.__r_.__value_.__l.__size_ = v147[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v147 + 7);
    __p.__r_.__value_.__s.__size_ = v68;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v69 = &__p;
    }
    else {
      double v69 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v69, &v149);
    __int16 v70 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
    int v71 = sqlite3_step(v70);
    std::string::size_type v72 = v149.__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = 0LL;
    if (v72) {
      (*(void (**)(std::string::size_type))(*(void *)v72 + 8LL))(v72);
    }
    if (v71 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v73 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v73 = __p.__r_.__value_.__l.__size_;
    }
    __int16 v74 = buf;
    sub_1000392EC((uint64_t)buf, v73 + 11);
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int16 v74 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
    }
    if (v73)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        int v75 = &__p;
      }
      else {
        int v75 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v74, v75, v73);
    }

    strcpy((char *)v74 + v73, "DROP TABLE ");
    __int16 v76 = std::string::append(buf, a2);
    std::string::size_type v77 = v76->__r_.__value_.__r.__words[0];
    v149.__r_.__value_.__r.__words[0] = v76->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v76->__r_.__value_.__r.__words[1] + 7);
    signed __int8 v78 = v76->__r_.__value_.__s.__size_;
    v76->__r_.__value_.__l.__size_ = 0LL;
    v76->__r_.__value_.__l.__cap_ = 0LL;
    v76->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v77;
    __p.__r_.__value_.__l.__size_ = v149.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v78;
    if ((char)buf[0].__r_.__value_.__s.__size_ < 0)
    {
      operator delete(buf[0].__r_.__value_.__l.__data_);
      signed __int8 v78 = __p.__r_.__value_.__s.__size_;
      std::string::size_type v77 = __p.__r_.__value_.__r.__words[0];
    }

    if (v78 >= 0) {
      int v79 = &__p;
    }
    else {
      int v79 = (std::string *)v77;
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v79, buf);
    double v80 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v81 = sqlite3_step(v80);
    std::string::size_type v82 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v82) {
      (*(void (**)(std::string::size_type))(*(void *)v82 + 8LL))(v82);
    }
    if (v81 != 101) {
      goto LABEL_234;
    }
    std::string::assign(&__p, "");
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      size_t v83 = __p.__r_.__value_.__s.__size_;
    }
    else {
      size_t v83 = __p.__r_.__value_.__l.__size_;
    }
    double v84 = &v140;
    sub_1000392EC((uint64_t)&v140, v83 + 12);
    if ((v140.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      double v84 = (std::string *)v140.__r_.__value_.__r.__words[0];
    }
    if (v83)
    {
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        double v85 = &__p;
      }
      else {
        double v85 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      memmove(v84, v85, v83);
    }

    strcpy((char *)v84 + v83, "ALTER TABLE ");
    if (cap >= 0) {
      double v86 = v143;
    }
    else {
      double v86 = (void **)v143[0];
    }
    if (cap >= 0) {
      std::string::size_type v87 = HIBYTE(cap);
    }
    else {
      std::string::size_type v87 = (std::string::size_type)v143[1];
    }
    double v88 = std::string::append(&v140, (const std::string::value_type *)v86, v87);
    __int128 v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
    v149.__r_.__value_.__l.__cap_ = v88->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v89;
    v88->__r_.__value_.__l.__size_ = 0LL;
    v88->__r_.__value_.__l.__cap_ = 0LL;
    v88->__r_.__value_.__r.__words[0] = 0LL;
    double v90 = std::string::append(&v149, " RENAME TO ");
    __int128 v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
    buf[0].__r_.__value_.__l.__cap_ = v90->__r_.__value_.__l.__cap_;
    *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v91;
    v90->__r_.__value_.__l.__size_ = 0LL;
    v90->__r_.__value_.__l.__cap_ = 0LL;
    v90->__r_.__value_.__r.__words[0] = 0LL;
    __int16 v92 = std::string::append(buf, a2);
    std::string::size_type v93 = v92->__r_.__value_.__r.__words[0];
    v148.__r_.__value_.__r.__words[0] = v92->__r_.__value_.__l.__size_;
    *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v92->__r_.__value_.__r.__words[1] + 7);
    unsigned __int8 v94 = v92->__r_.__value_.__s.__size_;
    v92->__r_.__value_.__l.__size_ = 0LL;
    v92->__r_.__value_.__l.__cap_ = 0LL;
    v92->__r_.__value_.__r.__words[0] = 0LL;
    __p.__r_.__value_.__r.__words[0] = v93;
    __p.__r_.__value_.__l.__size_ = v148.__r_.__value_.__r.__words[0];
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v148.__r_.__value_.__r.__words + 7);
    __p.__r_.__value_.__s.__size_ = v94;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v95 = &__p;
    }
    else {
      double v95 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)(a1 + 80), (char *)v95, buf);
    __int16 v96 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
    int v97 = sqlite3_step(v96);
    std::string::size_type v98 = buf[0].__r_.__value_.__r.__words[0];
    buf[0].__r_.__value_.__r.__words[0] = 0LL;
    if (v98) {
      (*(void (**)(std::string::size_type))(*(void *)v98 + 8LL))(v98);
    }
    if (v97 != 101) {
      goto LABEL_234;
    }
    sub_1003BAFA4(a4, buf);
    std::string::size_type v99 = buf[0].__r_.__value_.__s.__size_;
    unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v99 = buf[0].__r_.__value_.__l.__size_;
    }
    if (v99)
    {
      std::string::assign(&__p, "");
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        size_t v101 = __p.__r_.__value_.__s.__size_;
      }
      else {
        size_t v101 = __p.__r_.__value_.__l.__size_;
      }
      uint64_t v102 = &v138;
      sub_1000392EC((uint64_t)&v138, v101 + 13);
      if ((v138.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v102 = (std::string *)v138.__r_.__value_.__r.__words[0];
      }
      if (v101)
      {
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v103 = &__p;
        }
        else {
          int v103 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        memmove(v102, v103, v101);
      }

      strcpy((char *)v102 + v101, "CREATE INDEX ");
      if (v142 >= 0) {
        __int16 v104 = v141;
      }
      else {
        __int16 v104 = (void **)v141[0];
      }
      if (v142 >= 0) {
        std::string::size_type v105 = HIBYTE(v142);
      }
      else {
        std::string::size_type v105 = (std::string::size_type)v141[1];
      }
      __int16 v106 = std::string::append(&v138, (const std::string::value_type *)v104, v105);
      __int128 v107 = *(_OWORD *)&v106->__r_.__value_.__l.__data_;
      v146.__r_.__value_.__l.__cap_ = v106->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v107;
      v106->__r_.__value_.__l.__size_ = 0LL;
      v106->__r_.__value_.__l.__cap_ = 0LL;
      v106->__r_.__value_.__r.__words[0] = 0LL;
      double v108 = std::string::append(&v146, " ON ");
      __int128 v109 = *(_OWORD *)&v108->__r_.__value_.__l.__data_;
      v139.__r_.__value_.__l.__cap_ = v108->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v139.__r_.__value_.__l.__data_ = v109;
      v108->__r_.__value_.__l.__size_ = 0LL;
      v108->__r_.__value_.__l.__cap_ = 0LL;
      v108->__r_.__value_.__r.__words[0] = 0LL;
      double v110 = std::string::append(&v139, a2);
      __int128 v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
      v148.__r_.__value_.__l.__cap_ = v110->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v148.__r_.__value_.__l.__data_ = v111;
      v110->__r_.__value_.__l.__size_ = 0LL;
      v110->__r_.__value_.__l.__cap_ = 0LL;
      v110->__r_.__value_.__r.__words[0] = 0LL;
      double v112 = std::string::append(&v148, " (");
      __int128 v113 = *(_OWORD *)&v112->__r_.__value_.__l.__data_;
      v140.__r_.__value_.__l.__cap_ = v112->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v140.__r_.__value_.__l.__data_ = v113;
      v112->__r_.__value_.__l.__size_ = 0LL;
      v112->__r_.__value_.__l.__cap_ = 0LL;
      v112->__r_.__value_.__r.__words[0] = 0LL;
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        double v114 = buf;
      }
      else {
        double v114 = (std::string *)buf[0].__r_.__value_.__r.__words[0];
      }
      if ((buf[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v115 = buf[0].__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v115 = buf[0].__r_.__value_.__l.__size_;
      }
      double v116 = std::string::append(&v140, (const std::string::value_type *)v114, v115);
      __int128 v117 = *(_OWORD *)&v116->__r_.__value_.__l.__data_;
      v149.__r_.__value_.__l.__cap_ = v116->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v149.__r_.__value_.__l.__data_ = v117;
      v116->__r_.__value_.__l.__size_ = 0LL;
      v116->__r_.__value_.__l.__cap_ = 0LL;
      v116->__r_.__value_.__r.__words[0] = 0LL;
      __int16 v118 = std::string::append(&v149, ")");
      std::string::size_type v119 = v118->__r_.__value_.__r.__words[0];
      v145.__r_.__value_.__r.__words[0] = v118->__r_.__value_.__l.__size_;
      *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v118->__r_.__value_.__r.__words[1] + 7);
      unsigned __int8 v120 = v118->__r_.__value_.__s.__size_;
      v118->__r_.__value_.__l.__size_ = 0LL;
      v118->__r_.__value_.__l.__cap_ = 0LL;
      v118->__r_.__value_.__r.__words[0] = 0LL;
      __p.__r_.__value_.__r.__words[0] = v119;
      __p.__r_.__value_.__l.__size_ = v145.__r_.__value_.__r.__words[0];
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v145.__r_.__value_.__r.__words + 7);
      __p.__r_.__value_.__s.__size_ = v120;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        double v121 = &__p;
      }
      else {
        double v121 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      sub_1003C0D54(*(void *)(a1 + 80), (char *)v121, &v149);
      __int16 v122 = (sqlite3_stmt *)sub_100019240((uint64_t)v149.__r_.__value_.__l.__data_);
      int v123 = sqlite3_step(v122);
      std::string::size_type v124 = v149.__r_.__value_.__r.__words[0];
      v149.__r_.__value_.__r.__words[0] = 0LL;
      if (v124) {
        (*(void (**)(std::string::size_type))(*(void *)v124 + 8LL))(v124);
      }
      unsigned __int8 v100 = buf[0].__r_.__value_.__s.__size_;
    }

    else
    {
      int v123 = 101;
    }

    if ((v100 & 0x80) != 0) {
      operator delete(buf[0].__r_.__value_.__l.__data_);
    }
    if (v123 == 101)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101887300);
      }
      BOOL v125 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_DEFAULT,  "#Notice %{public}s autoincrement migration succeeded",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101887300);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice %{public}s autoincrement migration succeeded",  &v149,  v137);
        uint64_t v136 = (std::string *)v135;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLActivityRecorderDb<VO2MaxSummary, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxSummary, DataProtectionPolicy = CLAct ivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v135);
        if (v136 != buf) {
          free(v136);
        }
      }

      sub_1003C05BC(*(void *)(a1 + 80));
      char v126 = 0;
    }

    else
    {
LABEL_234:
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101887300);
      }
      double v127 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        LODWORD(buf[0].__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_FAULT,  "%{public}s autoincrement migration failed",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101887300);
        }
        LODWORD(v149.__r_.__value_.__l.__data_) = 136446210;
        *(std::string::size_type *)((char *)v149.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
        LODWORD(v137) = 12;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "%{public}s autoincrement migration failed",  &v149,  v137);
        int v134 = (std::string *)v133;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLActivityRecorderDb<VO2MaxSummary, CLActivityDB::ClassBDataProtectionPolicy>::migrateDbConstraints(const char *, const CLSqliteDatabase::ColumnInfo *, const char **) [T = VO2MaxSummary, DataProtectionPolicy = CLAct ivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v133);
        if (v134 != buf) {
          free(v134);
        }
      }

      sub_1003C0E18(*(void *)(a1 + 80));
      char v126 = 1;
    }

    if (SHIBYTE(v142) < 0) {
      operator delete(v141[0]);
    }
    if (SHIBYTE(cap) < 0) {
      operator delete(v143[0]);
    }
    if ((char)__p.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if ((v126 & 1) != 0) {
        goto LABEL_246;
      }
    }

    else if ((v126 & 1) != 0)
    {
      goto LABEL_246;
    }

    return 1LL;
  }

void sub_100E35B14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a60 < 0) {
    operator delete(a55);
  }
  _Unwind_Resume(a1);
}

void sub_100E35E34(uint64_t a1)
{
  sub_1003C0D54( *(void *)(a1 + 80),  "SELECT COUNT(name) FROM sqlite_master WHERE type='index' AND name = 'VO2MaxSummaryHistorySessionIdIndex'",  buf);
  uint64_t v2 = *(void *)buf;
  uint64_t v3 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
  if (sqlite3_step(v3) == 100)
  {
    uint64_t v4 = (sqlite3_stmt *)sub_100019240(v2);
    if (sqlite3_column_int(v4, 0) >= 1)
    {
      if (qword_1019346E0 != -1) {
        dispatch_once(&qword_1019346E0, &stru_101886E88);
      }
      uint64_t v5 = (os_log_s *)qword_1019346E8;
      if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "Index VO2MaxSummaryHistorySessionIdIndex already exists; not re-creating",
          buf,
          2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346E0 != -1) {
          dispatch_once(&qword_1019346E0, &stru_101886E88);
        }
        v16[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  2LL,  "Index VO2MaxSummaryHistorySessionIdIndex already exists; not re-creating",
          v16,
          2);
        uint64_t v7 = (uint8_t *)v6;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLVO2MaxSummaryRecorderDb::createIndexOnSessionIdIfNecessary()",  "%s\n",  v6);
        if (v7 != buf) {
          free(v7);
        }
      }

      goto LABEL_28;
    }
  }

  sub_1003C0D54( *(void *)(a1 + 80),  "CREATE INDEX VO2MaxSummaryHistorySessionIdIndex ON VO2MaxSummaryHistory (sessionId)",  buf);
  uint64_t v8 = *(void *)buf;
  uint64_t v9 = *(void *)(a1 + 80);
  __int128 v10 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
  if (sub_1003BB2BC(v9, v10))
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_101886E88);
    }
    uint64_t v11 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Index VO2MaxSummaryHistorySessionIdIndex created successfully",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_26;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_101886E88);
    }
    v16[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  0LL,  "Index VO2MaxSummaryHistorySessionIdIndex created successfully",  v16,  2);
    size_t v13 = (uint8_t *)v12;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLVO2MaxSummaryRecorderDb::createIndexOnSessionIdIfNecessary()",  "%s\n",  v12);
  }

  else
  {
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_101886E88);
    }
    __int128 v14 = (os_log_s *)qword_1019346E8;
    if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "Unable to create index VO2MaxSummaryHistorySessionIdIndex",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_26;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_101886E88);
    }
    v16[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  16LL,  "Unable to create index VO2MaxSummaryHistorySessionIdIndex",  v16,  2);
    size_t v13 = (uint8_t *)v15;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLVO2MaxSummaryRecorderDb::createIndexOnSessionIdIfNecessary()",  "%s\n",  v15);
  }

  if (v13 != buf) {
    free(v13);
  }
LABEL_26:
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
LABEL_28:
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
}

void sub_100E362A8(_Unwind_Exception *exception_object)
{
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E362FC(void *a1, void **a2, double a3, double a4)
{
  uint64_t v8 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v63);
  if ((SHIBYTE(v64) & 0x80000000) == 0)
  {
    if (HIBYTE(v64)) {
      goto LABEL_3;
    }
LABEL_40:
    sub_101273168(v8);
    __break(1u);
  }

  __int128 v58 = v63[1];
  operator delete(v63[0]);
  if (!v58) {
    goto LABEL_40;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v63);
  uint64_t v9 = sub_10000CF44(&v64, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(__int128 *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((SBYTE7(v68) & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (__int128 *)__p;
  }
  if ((SBYTE7(v68) & 0x80u) == 0) {
    uint64_t v11 = BYTE7(v68);
  }
  else {
    uint64_t v11 = *((void *)&__p + 1);
  }
  __int128 v12 = sub_10000CF44(v9, (uint64_t)p_p, v11);
  sub_10000CF44(v12, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if (SBYTE7(v68) < 0) {
    operator delete((void *)__p);
  }
  uint64_t v13 = a1[10];
  std::stringbuf::str((std::stringbuf::string_type *)&__p, &v65);
  if ((SBYTE7(v68) & 0x80u) == 0) {
    __int128 v14 = (char *)&__p;
  }
  else {
    __int128 v14 = (char *)__p;
  }
  sub_1003C0D54(v13, v14, &v61);
  uint64_t v15 = v61;
  uint64_t v61 = 0LL;
  uint64_t v62 = v15;
  if (SBYTE7(v68) < 0) {
    operator delete((void *)__p);
  }
  __int128 v16 = (sqlite3_stmt *)sub_100019240(v15);
  if (sub_1003B7480(v16, 1, a3) && (std::string::size_type v17 = (sqlite3_stmt *)sub_100019240(v15), sub_1003B7480(v17, 2, a4)))
  {
    *(void *)&__int128 __p = 0LL;
    *((void *)&__p + 1) = 0x7FEFFFFFFFFFFFFFLL;
    *(void *)&__int128 v68 = 0LL;
    *((void *)&v69 + 1) = 0x7FEFFFFFFFFFFFFFLL;
    __int128 v70 = 0u;
    __int128 v71 = 0u;
    __int128 v72 = 0u;
    __int128 v73 = 0u;
    __int128 v74 = 0u;
    __int128 v75 = 0u;
    LODWORD(v78) = 1;
    __int128 v76 = 0u;
    __int128 v77 = 0u;
    while (1)
    {
      uint64_t v18 = sub_1001BA11C((uint64_t)a1, &v62, (uint64_t)&__p);
      if ((_DWORD)v18) {
        break;
      }
      std::string::size_type v19 = (char *)a2[1];
      signed __int8 v20 = (char *)a2[2];
      if (v19 >= v20)
      {
        unint64_t v31 = 0xD37A6F4DE9BD37A7LL * ((v19 - (_BYTE *)*a2) >> 3);
        unint64_t v32 = v31 + 1;
        if (v31 + 1 > 0x1642C8590B21642LL) {
          sub_100007008();
        }
        unint64_t v33 = 0xD37A6F4DE9BD37A7LL * ((v20 - (_BYTE *)*a2) >> 3);
        if (2 * v33 > v32) {
          unint64_t v32 = 2 * v33;
        }
        if (v33 >= 0xB21642C8590B21LL) {
          unint64_t v34 = 0x1642C8590B21642LL;
        }
        else {
          unint64_t v34 = v32;
        }
        if (v34) {
          std::string::size_type v35 = (char *)sub_1002DF6FC((uint64_t)(a2 + 2), v34);
        }
        else {
          std::string::size_type v35 = 0LL;
        }
        std::stringbuf::string_type v36 = &v35[184 * v31];
        __int128 v37 = __p;
        __int128 v38 = v68;
        __int128 v39 = v70;
        *((_OWORD *)v36 + 2) = v69;
        *((_OWORD *)v36 + 3) = v39;
        *(_OWORD *)std::stringbuf::string_type v36 = v37;
        *((_OWORD *)v36 + 1) = v38;
        __int128 v40 = v71;
        __int128 v41 = v72;
        __int128 v42 = v74;
        *((_OWORD *)v36 + 6) = v73;
        *((_OWORD *)v36 + 7) = v42;
        *((_OWORD *)v36 + 4) = v40;
        *((_OWORD *)v36 + 5) = v41;
        __int128 v43 = v75;
        __int128 v44 = v76;
        __int128 v45 = v77;
        *((void *)v36 + 22) = v78;
        *((_OWORD *)v36 + 9) = v44;
        *((_OWORD *)v36 + 10) = v45;
        *((_OWORD *)v36 + 8) = v43;
        char v47 = (char *)*a2;
        char v46 = (char *)a2[1];
        __int128 v48 = v36;
        if (v46 != *a2)
        {
          do
          {
            __int128 v49 = *(_OWORD *)(v46 - 184);
            __int128 v50 = *(_OWORD *)(v46 - 168);
            __int128 v51 = *(_OWORD *)(v46 - 152);
            *(_OWORD *)(v48 - 136) = *(_OWORD *)(v46 - 136);
            *(_OWORD *)(v48 - 152) = v51;
            *(_OWORD *)(v48 - 168) = v50;
            *(_OWORD *)(v48 - 184) = v49;
            __int128 v52 = *(_OWORD *)(v46 - 120);
            __int128 v53 = *(_OWORD *)(v46 - 104);
            __int128 v54 = *(_OWORD *)(v46 - 88);
            *(_OWORD *)(v48 - 72) = *(_OWORD *)(v46 - 72);
            *(_OWORD *)(v48 - 88) = v54;
            *(_OWORD *)(v48 - 104) = v53;
            *(_OWORD *)(v48 - 120) = v52;
            __int128 v55 = *(_OWORD *)(v46 - 56);
            __int128 v56 = *(_OWORD *)(v46 - 40);
            __int128 v57 = *(_OWORD *)(v46 - 24);
            *((void *)v48 - 1) = *((void *)v46 - 1);
            *(_OWORD *)(v48 - 24) = v57;
            *(_OWORD *)(v48 - 40) = v56;
            *(_OWORD *)(v48 - 56) = v55;
            v48 -= 184;
            v46 -= 184;
          }

          while (v46 != v47);
          char v46 = (char *)*a2;
        }

        __int128 v30 = v36 + 184;
        *a2 = v48;
        a2[1] = v36 + 184;
        a2[2] = &v35[184 * v34];
        if (v46) {
          operator delete(v46);
        }
      }

      else
      {
        __int128 v21 = __p;
        __int128 v22 = v68;
        __int128 v23 = v70;
        *((_OWORD *)v19 + 2) = v69;
        *((_OWORD *)v19 + 3) = v23;
        *(_OWORD *)std::string::size_type v19 = v21;
        *((_OWORD *)v19 + 1) = v22;
        __int128 v24 = v71;
        __int128 v25 = v72;
        __int128 v26 = v74;
        *((_OWORD *)v19 + 6) = v73;
        *((_OWORD *)v19 + 7) = v26;
        *((_OWORD *)v19 + 4) = v24;
        *((_OWORD *)v19 + 5) = v25;
        __int128 v27 = v75;
        __int128 v28 = v76;
        __int128 v29 = v77;
        *((void *)v19 + 22) = v78;
        *((_OWORD *)v19 + 9) = v28;
        *((_OWORD *)v19 + 10) = v29;
        *((_OWORD *)v19 + 8) = v27;
        __int128 v30 = v19 + 184;
      }

      a2[1] = v30;
    }

    uint64_t v15 = v62;
  }

  else
  {
    uint64_t v18 = 2LL;
  }

  uint64_t v62 = 0LL;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
  }
  *(void **)((char *)v63
  uint64_t v64 = v59;
  std::streambuf::~streambuf(&v65);
  std::ios::~ios(&v66);
  return v18;
}

void sub_100E36754( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, void *__p, uint64_t a47, int a48, __int16 a49, char a50,char a51)
{
  if (a51 < 0) {
    operator delete(__p);
  }
  sub_1011F8850((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t sub_100E367C4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v40 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101887300);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      char v46 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101887300);
      }
      uint64_t v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)__int128 buf = 134349056;
        *(void *)__int128 v44 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101887300);
        }
        uint64_t v35 = *(void *)(a1 + 216);
        int v41 = 134349056;
        uint64_t v42 = v35;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v41,  12);
        __int128 v37 = (uint8_t *)v36;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<VO2MaxSummary, CLActivityDB::ClassBDataProtectionPolicy>::setDatabaseAccessi ble() [T = VO2MaxSummary, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v36);
        if (v37 != buf) {
          free(v37);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101887300);
    }
    __int128 v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      char v46 = v11;
      __int16 v47 = 2049;
      uint64_t v48 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    unint64_t v13 = *(void *)(a1 + 208);
    uint64_t v14 = *(void *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 192);
    __int128 v16 = (void *)(v14 + 8 * (v13 / 0x16));
    unsigned int v39 = v9;
    if (v15 == v14) {
      unint64_t v17 = 0LL;
    }
    else {
      unint64_t v17 = *v16 + 184 * (v13 % 0x16);
    }
    while (1)
    {
      if (v15 == v14)
      {
        unint64_t v23 = 0LL;
      }

      else
      {
        unint64_t v22 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        unint64_t v23 = *(void *)(v14 + 8 * (v22 / 0x16)) + 184 * (v22 % 0x16);
      }

      if (v17 == v23) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_101887320);
      }
      __int128 v24 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_101887320);
        }
        LOWORD(v41) = 0;
        LODWORD(v38) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v41,  v38);
        __int128 v27 = (uint8_t *)v26;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<VO2MaxSummary, CLActivityDB::ClassBDataProtectionPolicy>::setDatabaseAccessi ble() [T = VO2MaxSummary, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v26);
        if (v27 != buf) {
          free(v27);
        }
      }

      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v17, 1LL);
      v17 += 184LL;
      if (v17 - *v16 == 4048)
      {
        unint64_t v25 = v16[1];
        ++v16;
        unint64_t v17 = v25;
      }

      uint64_t v14 = *(void *)(a1 + 184);
      uint64_t v15 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    uint64_t v9 = v39;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101887300);
    }
    uint64_t v18 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      std::string::size_type v19 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      char v46 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101887300);
      }
    }

    signed __int8 v20 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      __int128 v21 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)__int128 v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      char v46 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 128) = 1;
  }

  __int128 v28 = *(void ***)(a1 + 184);
  uint64_t v29 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v30 = v29 - (void)v28;
  if (v30 >= 0x11)
  {
    do
    {
      operator delete(*v28);
      uint64_t v31 = *(void *)(a1 + 192);
      __int128 v28 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v28;
      unint64_t v30 = v31 - (void)v28;
    }

    while (v30 > 0x10);
  }

  if (v30 >> 3 == 1)
  {
    uint64_t v32 = 11LL;
  }

  else
  {
    if (v30 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v32 = 22LL;
  }

  *(void *)(a1 + 208) = v32;
LABEL_61:
  unint64_t v33 = *(void **)(a1 + 144);
  if (v33)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_100E36EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

id *sub_100E36F2C(uint64_t a1, __int128 *a2, char a3)
{
  v40[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v40[1] = 0LL;
  if (*(double *)(a1 + 232) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, __int128 *))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, __int128 *))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v40);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  uint64_t v49 = 0LL;
  double v50 = 1.79769313e308;
  uint64_t v51 = 0LL;
  uint64_t v52 = 0x7FEFFFFFFFFFFFFFLL;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  __int128 v60 = 0u;
  __int128 v53 = 0u;
  __int128 v54 = 0u;
  __int128 v56 = 0u;
  __int128 v55 = 0u;
  int v61 = 1;
  int v6 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 104LL))(a1, &v49);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, __int128 *, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101887300);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101887300);
        }
        LOWORD(v41) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v41,  2);
        __int128 v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<VO2MaxSummary, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreRe cordUL(const T &, BOOL) [T = VO2MaxSummary, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      goto LABEL_43;
    }

    double v7 = *((double *)a2 + 1);
    double v8 = v50;
    double v9 = v7 - v50;
    if (v7 - v50 < 0.0) {
      double v9 = -(v7 - v50);
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101887300);
      }
      __int128 v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *((void *)a2 + 1);
        *(_DWORD *)__int128 buf = 134349312;
        double v46 = v50;
        __int16 v47 = 2050;
        uint64_t v48 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101887300);
        }
        uint64_t v31 = *((void *)a2 + 1);
        int v41 = 134349312;
        double v42 = v50;
        __int16 v43 = 2050;
        uint64_t v44 = v31;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v41,  22);
        unint64_t v33 = (uint8_t *)v32;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxSummary, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreRe cordUL(const T &, BOOL) [T = VO2MaxSummary, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v32);
        if (v33 != buf) {
          free(v33);
        }
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *((double *)a2 + 1);
      double v8 = v50;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101887300);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *((double *)a2 + 1);
          *(_DWORD *)__int128 buf = 134217984;
          double v46 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_101887300);
          }
          double v34 = *((double *)a2 + 1);
          int v41 = 134217984;
          double v42 = v34;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v41));
          std::stringbuf::string_type v36 = (uint8_t *)v35;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxSummary, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStore RecordUL(const T &, BOOL) [T = VO2MaxSummary, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v35);
          if (v36 != buf) {
            free(v36);
          }
        }

        (*(void (**)(uint64_t, __int128 *))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v17 = v7 - v8;
      double v18 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v39 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_101887300);
        double v18 = v39;
      }

      double v19 = v17 - v18;
      signed __int8 v20 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 134217984;
        double v46 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_101887300);
        }
        int v41 = 134217984;
        double v42 = v19;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v41));
        uint64_t v38 = (uint8_t *)v37;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<VO2MaxSummary, CLActivityDB::ClassBDataProtectionPolicy>::sanitizeAndStoreRe cordUL(const T &, BOOL) [T = VO2MaxSummary, DataProtectionPolicy = CLActivityDB::ClassBDataProtectionPolicy]",  "%s\n",  v37);
        if (v38 != buf) {
          free(v38);
        }
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v19);
    }

    (*(void (**)(uint64_t, uint64_t *, uint64_t, __int128 *))(*(void *)a1 + 144LL))(a1, &v49, a1 + 224, a2);
    (*(void (**)(uint64_t, __int128 *, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_100E376D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100E37704(uint64_t a1)
{
  return sub_100E367C4(a1 - 72);
}

void sub_100E3770C(id a1)
{
  qword_1019346E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "VO2Max");
}

uint64_t sub_100E37738(uint64_t *a1, char **a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64))(v57);
  if ((SHIBYTE(v58) & 0x80000000) == 0)
  {
    if (HIBYTE(v58)) {
      goto LABEL_3;
    }
LABEL_43:
    sub_1012732D4(v4);
    __break(1u);
  }

  __int128 v54 = v57[1];
  operator delete(v57[0]);
  if (!v54) {
    goto LABEL_43;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    a2[1] = *a2;
    sub_10000CE18((uint64_t)v57);
    int v6 = sub_10000CF44(&v58, (uint64_t)"SELECT * from ", 14LL);
    (*(void (**)(__int128 *__return_ptr, uint64_t *))(*a1 + 64))(&__p, a1);
    if ((SBYTE7(v62) & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (__int128 *)__p;
    }
    if ((SBYTE7(v62) & 0x80u) == 0) {
      uint64_t v8 = BYTE7(v62);
    }
    else {
      uint64_t v8 = *((void *)&__p + 1);
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, v8);
    sub_10000CF44(v9, (uint64_t)" ORDER BY id ASC", 16LL);
    if (SBYTE7(v62) < 0) {
      operator delete((void *)__p);
    }
    uint64_t v10 = a1[10];
    std::stringbuf::str((std::stringbuf::string_type *)&__p, &v59);
    if ((SBYTE7(v62) & 0x80u) == 0) {
      uint64_t v11 = (char *)&__p;
    }
    else {
      uint64_t v11 = (char *)__p;
    }
    sub_1003C0D54(v10, v11, &v55);
    uint64_t v12 = v55;
    uint64_t v55 = 0LL;
    uint64_t v56 = v12;
    if (SBYTE7(v62) < 0) {
      operator delete((void *)__p);
    }
    sub_1003C0454(a1[10]);
    *(void *)&__int128 __p = 0LL;
    *((void *)&__p + 1) = 0x7FEFFFFFFFFFFFFFLL;
    *(void *)&__int128 v62 = 0LL;
    *((void *)&v63 + 1) = 0x7FEFFFFFFFFFFFFFLL;
    __int128 v64 = 0u;
    __int128 v65 = 0u;
    __int128 v66 = 0u;
    __int128 v67 = 0u;
    __int128 v68 = 0u;
    __int128 v69 = 0u;
    LODWORD(v72) = 1;
    __int128 v70 = 0u;
    __int128 v71 = 0u;
    while (!sub_1001BA11C((uint64_t)a1, &v56, (uint64_t)&__p))
    {
      unint64_t v13 = (unint64_t)a2[1];
      unint64_t v14 = (unint64_t)a2[2];
      if (v13 >= v14)
      {
        unint64_t v25 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v13 - (void)*a2) >> 3);
        unint64_t v26 = v25 + 1;
        if (v25 + 1 > 0x1642C8590B21642LL) {
          sub_100007008();
        }
        unint64_t v27 = 0xD37A6F4DE9BD37A7LL * ((uint64_t)(v14 - (void)*a2) >> 3);
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0xB21642C8590B21LL) {
          unint64_t v28 = 0x1642C8590B21642LL;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28) {
          __int128 v29 = (char *)sub_1002DF6FC((uint64_t)(a2 + 2), v28);
        }
        else {
          __int128 v29 = 0LL;
        }
        unint64_t v30 = &v29[184 * v25];
        __int128 v31 = __p;
        __int128 v32 = v62;
        __int128 v33 = v64;
        *((_OWORD *)v30 + 2) = v63;
        *((_OWORD *)v30 + 3) = v33;
        *(_OWORD *)unint64_t v30 = v31;
        *((_OWORD *)v30 + 1) = v32;
        __int128 v34 = v65;
        __int128 v35 = v66;
        __int128 v36 = v68;
        *((_OWORD *)v30 + 6) = v67;
        *((_OWORD *)v30 + 7) = v36;
        *((_OWORD *)v30 + 4) = v34;
        *((_OWORD *)v30 + 5) = v35;
        __int128 v37 = v69;
        __int128 v38 = v70;
        __int128 v39 = v71;
        *((void *)v30 + 22) = v72;
        *((_OWORD *)v30 + 9) = v38;
        *((_OWORD *)v30 + 10) = v39;
        *((_OWORD *)v30 + 8) = v37;
        int v41 = *a2;
        uint64_t v40 = a2[1];
        double v42 = v30;
        if (v40 != *a2)
        {
          do
          {
            __int128 v43 = *(_OWORD *)(v40 - 184);
            __int128 v44 = *(_OWORD *)(v40 - 168);
            __int128 v45 = *(_OWORD *)(v40 - 152);
            *(_OWORD *)(v42 - 136) = *(_OWORD *)(v40 - 136);
            *(_OWORD *)(v42 - 152) = v45;
            *(_OWORD *)(v42 - 168) = v44;
            *(_OWORD *)(v42 - 184) = v43;
            __int128 v46 = *(_OWORD *)(v40 - 120);
            __int128 v47 = *(_OWORD *)(v40 - 104);
            __int128 v48 = *(_OWORD *)(v40 - 88);
            *(_OWORD *)(v42 - 72) = *(_OWORD *)(v40 - 72);
            *(_OWORD *)(v42 - 88) = v48;
            *(_OWORD *)(v42 - 104) = v47;
            *(_OWORD *)(v42 - 120) = v46;
            __int128 v49 = *(_OWORD *)(v40 - 56);
            __int128 v50 = *(_OWORD *)(v40 - 40);
            __int128 v51 = *(_OWORD *)(v40 - 24);
            *((void *)v42 - 1) = *((void *)v40 - 1);
            *(_OWORD *)(v42 - 24) = v51;
            *(_OWORD *)(v42 - 40) = v50;
            *(_OWORD *)(v42 - 56) = v49;
            v42 -= 184;
            v40 -= 184;
          }

          while (v40 != v41);
          uint64_t v40 = *a2;
        }

        __int128 v24 = v30 + 184;
        *a2 = v42;
        a2[1] = v30 + 184;
        a2[2] = &v29[184 * v28];
        if (v40) {
          operator delete(v40);
        }
      }

      else
      {
        __int128 v15 = __p;
        __int128 v16 = v62;
        __int128 v17 = v64;
        *(_OWORD *)(v13 + 32) = v63;
        *(_OWORD *)(v13 + 48) = v17;
        *(_OWORD *)unint64_t v13 = v15;
        *(_OWORD *)(v13 + 16) = v16;
        __int128 v18 = v65;
        __int128 v19 = v66;
        __int128 v20 = v68;
        *(_OWORD *)(v13 + 96) = v67;
        *(_OWORD *)(v13 + 112) = v20;
        *(_OWORD *)(v13 + 64) = v18;
        *(_OWORD *)(v13 + 80) = v19;
        __int128 v21 = v69;
        __int128 v22 = v70;
        __int128 v23 = v71;
        *(void *)(v13 + 176) = v72;
        *(_OWORD *)(v13 + 144) = v22;
        *(_OWORD *)(v13 + 160) = v23;
        *(_OWORD *)(v13 + 128) = v21;
        __int128 v24 = (char *)(v13 + 184);
      }

      a2[1] = v24;
    }

    sub_1003C05BC(a1[10]);
    uint64_t v52 = v56;
    uint64_t v56 = 0LL;
    if (v52) {
      (*(void (**)(uint64_t))(*(void *)v52 + 8LL))(v52);
    }
    *(void **)((char *)v57
    uint64_t v58 = v53;
    std::streambuf::~streambuf(&v59);
    return std::ios::~ios(&v60);
  }

  return result;
}

void sub_100E37B4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, void *__p, uint64_t a47, int a48, __int16 a49, char a50,char a51)
{
  if (v51) {
    (*(void (**)(uint64_t))(*(void *)v51 + 8LL))(v51);
  }
  sub_1011F8850((uint64_t)&a11);
  _Unwind_Resume(a1);
}

uint64_t sub_100E37BBC(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v23);
  if ((SHIBYTE(v24) & 0x80000000) == 0)
  {
    if (HIBYTE(v24)) {
      goto LABEL_3;
    }
LABEL_29:
    __int128 v20 = (_Unwind_Exception *)sub_101273440(v4);
    sub_1011F8850((uint64_t)v23);
    _Unwind_Resume(v20);
  }

  __int128 v19 = v23[1];
  operator delete(v23[0]);
  if (!v19) {
    goto LABEL_29;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 120LL))(a1, a2, 1LL);
    sub_10000CE18((uint64_t)v23);
    int v6 = sub_10000CF44(&v24, (uint64_t)"DELETE FROM ", 12LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" WHERE startTime > ?", 20LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v25);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v21);
    uint64_t v12 = v21;
    uint64_t v21 = 0LL;
    unint64_t v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, *(double *)(a2 + 8)))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    uint64_t v16 = a1[10];
    else {
      uint64_t v17 = *(void *)(v16 + 88);
    }
    sub_1003C1EC0(v16, v17);
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v23
    uint64_t v24 = v18;
    std::streambuf::~streambuf(&v25);
    return std::ios::~ios(&v26);
  }

  return result;
}

uint64_t sub_100E37E1C(void *a1, double a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v21);
  if ((SHIBYTE(v22) & 0x80000000) == 0)
  {
    if (HIBYTE(v22)) {
      goto LABEL_3;
    }
LABEL_26:
    uint64_t v18 = (_Unwind_Exception *)sub_1012735AC(v4);
    sub_1011F8850((uint64_t)v21);
    _Unwind_Resume(v18);
  }

  uint64_t v17 = v21[1];
  operator delete(v21[0]);
  if (!v17) {
    goto LABEL_26;
  }
LABEL_3:
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_10000CE18((uint64_t)v21);
    int v6 = sub_10000CF44(&v22, (uint64_t)"UPDATE ", 7LL);
    (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t size = __p.__r_.__value_.__s.__size_;
    }
    else {
      uint64_t size = __p.__r_.__value_.__l.__size_;
    }
    double v9 = sub_10000CF44(v6, (uint64_t)p_p, size);
    sub_10000CF44(v9, (uint64_t)" SET startTime = startTime + ?", 30LL);
    uint64_t v10 = a1[10];
    std::stringbuf::str(&__p, &v23);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v11 = &__p;
    }
    else {
      uint64_t v11 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(v10, (char *)v11, &v19);
    uint64_t v12 = v19;
    uint64_t v19 = 0LL;
    unint64_t v13 = (sqlite3_stmt *)sub_100019240(v12);
    if (sub_1003B7480(v13, 1, a2))
    {
      uint64_t v14 = a1[10];
      __int128 v15 = (sqlite3_stmt *)sub_100019240(v12);
      sub_1003BB2BC(v14, v15);
    }

    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
    }
    *(void **)((char *)v21
    uint64_t v22 = v16;
    std::streambuf::~streambuf(&v23);
    return std::ios::~ios(&v24);
  }

  return result;
}

uint64_t sub_100E38054(void *a1, uint64_t a2)
{
  uint64_t v4 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v22);
  if ((SHIBYTE(v23) & 0x80000000) == 0)
  {
    if (HIBYTE(v23)) {
      goto LABEL_3;
    }
LABEL_25:
    uint64_t v17 = (_Unwind_Exception *)sub_101273718(v4);
    uint64_t v18 = v20;
    uint64_t v20 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
    sub_1011F8850((uint64_t)v22);
    _Unwind_Resume(v17);
  }

  uint64_t v16 = v22[1];
  operator delete(v22[0]);
  if (!v16) {
    goto LABEL_25;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v22);
  uint64_t v5 = sub_10000CF44(&v23, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(std::stringbuf::string_type *__return_ptr, void *))(*a1 + 64LL))(&__p, a1);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t size = __p.__r_.__value_.__s.__size_;
  }
  else {
    uint64_t size = __p.__r_.__value_.__l.__size_;
  }
  uint64_t v8 = sub_10000CF44(v5, (uint64_t)p_p, size);
  sub_10000CF44(v8, (uint64_t)" ORDER BY ROWID DESC LIMIT 1", 28LL);
  uint64_t v9 = a1[10];
  std::stringbuf::str(&__p, &v24);
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v10 = &__p;
  }
  else {
    uint64_t v10 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(v9, (char *)v10, &v19);
  uint64_t v11 = v19;
  uint64_t v19 = 0LL;
  uint64_t v20 = v11;
  uint64_t v12 = sub_1001BA11C((uint64_t)a1, &v20, a2);
  uint64_t v13 = v20;
  uint64_t v20 = 0LL;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  *(void **)((char *)v22
  uint64_t v23 = v14;
  std::streambuf::~streambuf(&v24);
  std::ios::~ios(&v25);
  return v12;
}

void sub_100E3827C(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_100E382A8(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

uint64_t sub_100E382D4()
{
  if (qword_1019A20E0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A20E0 + 8LL))(qword_1019A20E0);
  }
  if (qword_1019A20E8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A20E8 + 8LL))(qword_1019A20E8);
  }
  if (qword_1019A20F0) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A20F0 + 8LL))(qword_1019A20F0);
  }
  if (qword_1019A20F8) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A20F8 + 8LL))(qword_1019A20F8);
  }
  if (qword_1019A2100) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A2100 + 8LL))(qword_1019A2100);
  }
  if (qword_1019A2108) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A2108 + 8LL))(qword_1019A2108);
  }
  if (qword_1019A2110) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A2110 + 8LL))(qword_1019A2110);
  }
  if (qword_1019A2118) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A2118 + 8LL))(qword_1019A2118);
  }
  if (qword_1019A2120) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A2120 + 8LL))(qword_1019A2120);
  }
  if (qword_1019A2128) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A2128 + 8LL))(qword_1019A2128);
  }
  if (qword_1019A2130) {
    (*(void (**)(uint64_t))(*(void *)qword_1019A2130 + 8LL))(qword_1019A2130);
  }
  uint64_t result = qword_1019A2138;
  if (qword_1019A2138) {
    return (*(uint64_t (**)(uint64_t))(*(void *)qword_1019A2138 + 8LL))(qword_1019A2138);
  }
  return result;
}

void sub_100E38408(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  if ((byte_10199EC40 & 1) == 0)
  {
    byte_10199EC40 = 1;
    wireless_diagnostics::google::protobuf::internal::VerifyVersion( (wireless_diagnostics::google::protobuf::internal *)0x1E9808,  2005000,  (int)"/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  a4);
    uint64_t v4 = (char *)operator new(0x58uLL);
    *(void *)uint64_t v4 = off_101887350;
    *(_OWORD *)(v4 + 8) = 0u;
    *(_OWORD *)(v4 + 24) = 0u;
    *(_OWORD *)(v4 + 40) = 0u;
    *(_OWORD *)(v4 + 56) = 0u;
    *(_OWORD *)(v4 + 72) = 0u;
    qword_1019A20E0 = (uint64_t)v4;
    uint64_t v5 = (char *)operator new(0x28uLL);
    *(void *)uint64_t v5 = off_1018873C8;
    *(_OWORD *)(v5 + 8) = 0u;
    *(_OWORD *)(v5 + 24) = 0u;
    qword_1019A20E8 = (uint64_t)v5;
    int v6 = (char *)operator new(0x38uLL);
    *(void *)int v6 = off_101887440;
    *(_OWORD *)(v6 + 8) = 0u;
    *(_OWORD *)(v6 + 24) = 0u;
    *(_OWORD *)(v6 + 40) = 0u;
    qword_1019A20F0 = (uint64_t)v6;
    double v7 = operator new(0x20uLL);
    v7[1] = 0LL;
    v7[2] = 0LL;
    void *v7 = &off_1018874B8;
    *((_DWORD *)v7 + 6) = 0;
    qword_1019A20F8 = (uint64_t)v7;
    uint64_t v8 = (char *)operator new(0x28uLL);
    *(void *)uint64_t v8 = &off_101887530;
    *(_OWORD *)(v8 + 8) = 0u;
    *(_OWORD *)(v8 + 24) = 0u;
    qword_1019A2100 = (uint64_t)v8;
    uint64_t v9 = operator new(0x90uLL);
    v9[5] = 0LL;
    v9[6] = 0LL;
    *((_DWORD *)v9 + 14) = 0;
    v9[8] = 0LL;
    v9[9] = 0LL;
    *((_DWORD *)v9 + 20) = 0;
    v9[11] = 0LL;
    v9[12] = 0LL;
    *((_DWORD *)v9 + 26) = 0;
    v9[14] = 0LL;
    v9[15] = 0LL;
    *((_DWORD *)v9 + 32) = 0;
    v9[17] = 0LL;
    void *v9 = off_101887620;
    v9[1] = 0LL;
    _OWORD v9[2] = 0LL;
    void v9[3] = 0LL;
    *((_DWORD *)v9 + 8) = 0;
    qword_1019A2108 = (uint64_t)v9;
    uint64_t v10 = operator new(0x20uLL);
    v10[1] = 0LL;
    _OWORD v10[2] = 0LL;
    void *v10 = off_1018875A8;
    *((_DWORD *)v10 + 6) = 0;
    qword_1019A2110 = (uint64_t)v10;
    uint64_t v11 = operator new(0x28uLL);
    *(void *)((char *)v11 + 28) = 0LL;
    v11[1] = 0LL;
    _OWORD v11[2] = 0LL;
    void *v11 = &off_101887698;
    *((_BYTE *)v11 + 24) = 0;
    qword_1019A2118 = (uint64_t)v11;
    uint64_t v12 = operator new(0x20uLL);
    v12[1] = 0LL;
    _DWORD v12[2] = 0LL;
    *uint64_t v12 = &off_101887710;
    *((_DWORD *)v12 + 6) = 0;
    qword_1019A2120 = (uint64_t)v12;
    uint64_t v13 = operator new(0x20uLL);
    void *v13 = &off_101887788;
    v13[1] = 0LL;
    _DWORD v13[2] = 0LL;
    v13[3] = 0LL;
    qword_1019A2128 = (uint64_t)v13;
    uint64_t v14 = operator new(0x20uLL);
    *uint64_t v14 = &off_101887800;
    v14[1] = 0LL;
    v14[2] = 0LL;
    void v14[3] = 0LL;
    qword_1019A2130 = (uint64_t)v14;
    __int128 v15 = operator new(0x20uLL);
    void *v15 = &off_101887878;
    v15[1] = 0LL;
    v15[2] = 0LL;
    v15[3] = 0LL;
    qword_1019A2138 = (uint64_t)v15;
    uint64_t v16 = sub_100E38828((uint64_t)v4);
    uint64_t v18 = qword_1019A20F0;
    uint64_t v19 = qword_1019A20E8;
    if (qword_1019A20E8)
    {
      *(void *)(qword_1019A20F0 + 8) = qword_1019A20E8;
LABEL_5:
      *(void *)(v18 + 16) = v19;
      *(void *)(qword_1019A20F8 + 8) = v19;
      uint64_t v21 = qword_1019A2100;
LABEL_6:
      *(void *)(v21 + 8) = v19;
      *(void *)(qword_1019A2108 + 8) = v19;
      uint64_t v22 = qword_1019A2118;
LABEL_7:
      uint64_t v23 = &qword_1019A2000;
      *(void *)(v22 + 8) = v19;
      *(void *)(qword_1019A2120 + 8) = v19;
      uint64_t v24 = qword_1019A2128;
LABEL_8:
      *(void *)(v24 + 8) = v19;
      *(void *)(qword_1019A2130 + 8) = v19;
LABEL_9:
      uint64_t v25 = v23[39];
LABEL_10:
      *(void *)(v25 + 8) = v19;
      wireless_diagnostics::google::protobuf::internal::OnShutdown( (wireless_diagnostics::google::protobuf::internal *)sub_100E382D4,  v17);
      return;
    }

    uint64_t v20 = sub_100E38408(v16);
    uint64_t v19 = qword_1019A20E8;
    *(void *)(v18 + 8) = qword_1019A20E8;
    if (v19) {
      goto LABEL_5;
    }
    uint64_t v26 = sub_100E38408(v20);
    uint64_t v19 = qword_1019A20E8;
    *(void *)(v18 + 16) = qword_1019A20E8;
    uint64_t v27 = qword_1019A20F8;
    if (v19)
    {
      *(void *)(qword_1019A20F8 + 8) = v19;
      *(void *)(qword_1019A2100 + 8) = v19;
      uint64_t v28 = qword_1019A2108;
    }

    else
    {
      uint64_t v31 = sub_100E38408(v26);
      uint64_t v19 = qword_1019A20E8;
      *(void *)(v27 + 8) = qword_1019A20E8;
      uint64_t v21 = qword_1019A2100;
      if (v19) {
        goto LABEL_6;
      }
      uint64_t v32 = sub_100E38408(v31);
      uint64_t v19 = qword_1019A20E8;
      *(void *)(v21 + 8) = qword_1019A20E8;
      uint64_t v28 = qword_1019A2108;
      if (!v19)
      {
        uint64_t v33 = sub_100E38408(v32);
        uint64_t v19 = qword_1019A20E8;
        *(void *)(v28 + 8) = qword_1019A20E8;
        uint64_t v22 = qword_1019A2118;
        if (v19) {
          goto LABEL_7;
        }
        uint64_t v34 = sub_100E38408(v33);
        uint64_t v19 = qword_1019A20E8;
        *(void *)(v22 + 8) = qword_1019A20E8;
        uint64_t v29 = qword_1019A2120;
        if (!v19)
        {
          uint64_t v35 = sub_100E38408(v34);
          uint64_t v19 = qword_1019A20E8;
          *(void *)(v29 + 8) = qword_1019A20E8;
          uint64_t v24 = qword_1019A2128;
          if (v19)
          {
            uint64_t v23 = &qword_1019A2000;
            goto LABEL_8;
          }

          uint64_t v36 = sub_100E38408(v35);
          uint64_t v19 = qword_1019A20E8;
          *(void *)(v24 + 8) = qword_1019A20E8;
          uint64_t v30 = qword_1019A2130;
          if (!v19)
          {
            uint64_t v37 = sub_100E38408(v36);
            uint64_t v19 = qword_1019A20E8;
            *(void *)(v30 + 8) = qword_1019A20E8;
            uint64_t v25 = qword_1019A2138;
            if (!v19)
            {
              sub_100E38408(v37);
              uint64_t v19 = qword_1019A20E8;
            }

            goto LABEL_10;
          }

          uint64_t v23 = &qword_1019A2000;
LABEL_15:
          *(void *)(v30 + 8) = v19;
          goto LABEL_9;
        }

double sub_100E38800(uint64_t a1)
{
  *(void *)a1 = off_101887350;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  return result;
}

uint64_t sub_100E38828(uint64_t result)
{
  uint64_t v1 = (void *)result;
  uint64_t v2 = qword_1019A20F0;
  if (!qword_1019A20F0)
  {
    double result = sub_100E38408();
    uint64_t v2 = qword_1019A20F0;
  }

  v1[1] = v2;
  uint64_t v3 = qword_1019A20F8;
  if (!qword_1019A20F8)
  {
    double result = sub_100E38408();
    uint64_t v3 = qword_1019A20F8;
  }

  v1[2] = v3;
  uint64_t v4 = qword_1019A2100;
  if (!qword_1019A2100)
  {
    double result = sub_100E38408();
    uint64_t v4 = qword_1019A2100;
  }

  v1[3] = v4;
  uint64_t v5 = qword_1019A2108;
  if (!qword_1019A2108)
  {
    double result = sub_100E38408();
    uint64_t v5 = qword_1019A2108;
  }

  v1[4] = v5;
  uint64_t v6 = qword_1019A2118;
  if (!qword_1019A2118)
  {
    double result = sub_100E38408();
    uint64_t v6 = qword_1019A2118;
  }

  _OWORD v1[5] = v6;
  uint64_t v7 = qword_1019A2120;
  if (!qword_1019A2120)
  {
    double result = sub_100E38408();
    uint64_t v7 = qword_1019A2120;
  }

  v1[6] = v7;
  uint64_t v8 = qword_1019A2128;
  if (!qword_1019A2128)
  {
    double result = sub_100E38408();
    uint64_t v8 = qword_1019A2128;
  }

  v1[7] = v8;
  uint64_t v9 = qword_1019A2130;
  if (!qword_1019A2130)
  {
    double result = sub_100E38408();
    uint64_t v9 = qword_1019A2130;
  }

  v1[8] = v9;
  uint64_t v10 = qword_1019A2138;
  if (!qword_1019A2138)
  {
    double result = sub_100E38408();
    uint64_t v10 = qword_1019A2138;
  }

  v1[9] = v10;
  return result;
}

double sub_100E3891C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v26,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  570LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v26,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v25, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v26);
  }

  int v6 = *(_DWORD *)(a2 + 84);
  if (!(_BYTE)v6) {
    goto LABEL_12;
  }
  if ((v6 & 1) != 0)
  {
    *(_DWORD *)(a1 + 84) |= 1u;
    uint64_t v7 = *(char **)(a1 + 8);
    if (!v7)
    {
      uint64_t v7 = (char *)operator new(0x38uLL);
      *(void *)uint64_t v7 = off_101887440;
      *(_OWORD *)(v7 + 8) = 0u;
      *(_OWORD *)(v7 + 24) = 0u;
      *(_OWORD *)(v7 + 40) = 0u;
      *(void *)(a1 + 8) = v7;
    }

    uint64_t v8 = *(void *)(a2 + 8);
    if (!v8) {
      uint64_t v8 = *(void *)(qword_1019A20E0 + 8);
    }
    double result = sub_100E3A164((uint64_t)v7, v8);
    int v6 = *(_DWORD *)(a2 + 84);
    if ((v6 & 2) == 0)
    {
LABEL_6:
      if ((v6 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_24;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_6;
  }

  *(_DWORD *)(a1 + 84) |= 2u;
  uint64_t v9 = *(void **)(a1 + 16);
  if (!v9)
  {
    uint64_t v9 = operator new(0x20uLL);
    v9[1] = 0LL;
    _OWORD v9[2] = 0LL;
    void *v9 = &off_1018874B8;
    *((_DWORD *)v9 + 6) = 0;
    *(void *)(a1 + 16) = v9;
  }

  uint64_t v10 = *(void *)(a2 + 16);
  if (!v10) {
    uint64_t v10 = *(void *)(qword_1019A20E0 + 16);
  }
  sub_100E3A338((uint64_t)v9, v10);
  int v6 = *(_DWORD *)(a2 + 84);
  if ((v6 & 4) == 0)
  {
LABEL_7:
    if ((v6 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_29;
  }

void sub_100E38CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void *sub_100E38CE8(void *result)
{
  if ((void *)qword_1019A20E0 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
    uint64_t v3 = v1[2];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    uint64_t v4 = v1[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    uint64_t v5 = v1[4];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
    uint64_t v6 = v1[5];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
    uint64_t v7 = v1[6];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
    }
    uint64_t v8 = v1[7];
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    }
    uint64_t v9 = v1[8];
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    }
    double result = (void *)v1[9];
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8LL))(result);
    }
  }

  return result;
}

void sub_100E38DD0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101887350;
  sub_100E38CE8(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100E38E00(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101887350;
  sub_100E38CE8(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

uint64_t sub_100E38E34(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t result = qword_1019A20E0;
  if (!qword_1019A20E0)
  {
    sub_100E38408(0LL, a2, a3, a4);
    return qword_1019A20E0;
  }

  return result;
}

double sub_100E38E60()
{
  unsigned __int8 v0 = (char *)operator new(0x58uLL);
  *(void *)unsigned __int8 v0 = off_101887350;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_OWORD *)(v0 + 56) = 0u;
  *(_OWORD *)(v0 + 72) = 0u;
  return result;
}

uint64_t sub_100E38E9C(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(_DWORD *)(result + 84);
  if ((_BYTE)v2)
  {
    if ((v2 & 1) != 0)
    {
      double result = *(void *)(result + 8);
      if (result)
      {
        double result = sub_100E38F78(result);
        int v2 = *(_DWORD *)(v1 + 84);
      }
    }

    if ((v2 & 2) != 0)
    {
      double result = *(void *)(v1 + 16);
      if (result)
      {
        double result = sub_100E38FD4(result);
        int v2 = *(_DWORD *)(v1 + 84);
      }
    }

    if ((v2 & 4) != 0)
    {
      double result = *(void *)(v1 + 24);
      if (result)
      {
        double result = sub_100E39008(result);
        int v2 = *(_DWORD *)(v1 + 84);
      }
    }

    if ((v2 & 8) != 0)
    {
      double result = *(void *)(v1 + 32);
      if (result)
      {
        double result = sub_100E3903C(result);
        int v2 = *(_DWORD *)(v1 + 84);
      }
    }

    if ((v2 & 0x10) != 0)
    {
      double result = *(void *)(v1 + 40);
      if (result)
      {
        double result = sub_100E39198(result);
        int v2 = *(_DWORD *)(v1 + 84);
      }
    }

    if ((v2 & 0x20) != 0)
    {
      double result = *(void *)(v1 + 48);
      if (result)
      {
        double result = sub_100E391E4(result);
        int v2 = *(_DWORD *)(v1 + 84);
      }
    }

    if ((v2 & 0x40) != 0)
    {
      double result = *(void *)(v1 + 56);
      if (result)
      {
        double result = sub_100E39218(result);
        int v2 = *(_DWORD *)(v1 + 84);
      }
    }

    if ((v2 & 0x80) != 0)
    {
      double result = *(void *)(v1 + 64);
      if (result)
      {
        double result = sub_100E3924C(result);
        int v2 = *(_DWORD *)(v1 + 84);
      }
    }
  }

  if ((v2 & 0x100) != 0)
  {
    double result = *(void *)(v1 + 72);
    if (result) {
      double result = sub_100E39280(result);
    }
  }

  *(_DWORD *)(v1 + 84) = 0;
  return result;
}

uint64_t sub_100E38F78(uint64_t result)
{
  LOBYTE(v1) = *(_BYTE *)(result + 52);
  if ((_BYTE)v1)
  {
    if ((*(_BYTE *)(result + 52) & 1) != 0)
    {
      uint64_t v2 = *(void *)(result + 8);
      if (v2)
      {
        if (*(_BYTE *)(v2 + 36))
        {
          *(void *)(v2 + 8) = 0LL;
          *(void *)(v2 + 16) = 0LL;
          *(void *)(v2 + 24) = 0LL;
        }

        *(_DWORD *)(v2 + 36) = 0;
        int v1 = *(_DWORD *)(result + 52);
      }
    }

    if ((v1 & 2) != 0)
    {
      uint64_t v3 = *(void *)(result + 16);
      if (v3)
      {
        if (*(_BYTE *)(v3 + 36))
        {
          *(void *)(v3 + 8) = 0LL;
          *(void *)(v3 + 16) = 0LL;
          *(void *)(v3 + 24) = 0LL;
        }

        *(_DWORD *)(v3 + 36) = 0;
      }
    }

    *(void *)(result + 24) = 0LL;
    *(void *)(result + 32) = 0LL;
    *(void *)(result + 40) = 0LL;
  }

  *(_DWORD *)(result + 52) = 0;
  return result;
}

uint64_t sub_100E38FD4(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    if ((*(_BYTE *)(result + 24) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if (v1)
      {
        if (*(_BYTE *)(v1 + 36))
        {
          *(void *)(v1 + 8) = 0LL;
          *(void *)(v1 + 16) = 0LL;
          *(void *)(v1 + 24) = 0LL;
        }

        *(_DWORD *)(v1 + 36) = 0;
      }
    }

    *(_DWORD *)(result + 16) = 0;
  }

  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100E39008(uint64_t result)
{
  if (*(_BYTE *)(result + 36))
  {
    if ((*(_BYTE *)(result + 36) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if (v1)
      {
        if (*(_BYTE *)(v1 + 36))
        {
          *(void *)(v1 + 8) = 0LL;
          *(void *)(v1 + 16) = 0LL;
          *(void *)(v1 + 24) = 0LL;
        }

        *(_DWORD *)(v1 + 36) = 0;
      }
    }

    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
  }

  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100E3903C(uint64_t result)
{
  uint64_t v1 = result;
  if ((*(_BYTE *)(result + 140) & 1) != 0)
  {
    uint64_t v2 = *(void *)(result + 8);
    if (v2)
    {
      if (*(_BYTE *)(v2 + 36))
      {
        *(void *)(v2 + 8) = 0LL;
        *(void *)(v2 + 16) = 0LL;
        *(void *)(v2 + 24) = 0LL;
      }

      *(_DWORD *)(v2 + 36) = 0;
    }
  }

  if (*(int *)(result + 24) >= 1)
  {
    uint64_t v3 = 0LL;
    do
    {
      uint64_t v4 = *(void *)(*(void *)(v1 + 16) + 8 * v3);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 32LL))(v4);
      ++v3;
    }

    while (v3 < *(int *)(v1 + 24));
  }

  *(_DWORD *)(v1 + 24) = 0;
  if (*(int *)(v1 + 48) >= 1)
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(v1 + 40) + 8 * v5);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 32LL))(v6);
      ++v5;
    }

    while (v5 < *(int *)(v1 + 48));
  }

  *(_DWORD *)(v1 + 48) = 0;
  if (*(int *)(v1 + 72) >= 1)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = *(void *)(*(void *)(v1 + 64) + 8 * v7);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 32LL))(v8);
      ++v7;
    }

    while (v7 < *(int *)(v1 + 72));
  }

  *(_DWORD *)(v1 + 72) = 0;
  if (*(int *)(v1 + 96) >= 1)
  {
    uint64_t v9 = 0LL;
    do
    {
      uint64_t v10 = *(void *)(*(void *)(v1 + 88) + 8 * v9);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 32LL))(v10);
      ++v9;
    }

    while (v9 < *(int *)(v1 + 96));
  }

  *(_DWORD *)(v1 + 96) = 0;
  if (*(int *)(v1 + 120) >= 1)
  {
    uint64_t v11 = 0LL;
    do
    {
      uint64_t v12 = *(void *)(*(void *)(v1 + 112) + 8 * v11);
      double result = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 32LL))(v12);
      ++v11;
    }

    while (v11 < *(int *)(v1 + 120));
  }

  *(_DWORD *)(v1 + 120) = 0;
  *(_DWORD *)(v1 + 140) = 0;
  return result;
}

uint64_t sub_100E39198(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 32);
  if ((_BYTE)v1)
  {
    if ((v1 & 1) != 0)
    {
      uint64_t v2 = *(void *)(result + 8);
      if (v2)
      {
        if (*(_BYTE *)(v2 + 36))
        {
          *(void *)(v2 + 8) = 0LL;
          *(void *)(v2 + 16) = 0LL;
          *(void *)(v2 + 24) = 0LL;
        }

        *(_DWORD *)(v2 + 36) = 0;
        int v1 = *(_DWORD *)(result + 32);
      }
    }

    *(_DWORD *)(result + 19) = 0;
    *(_DWORD *)(result + 16) = 0;
  }

  if ((v1 & 0xFF00) != 0) {
    *(_WORD *)(result + 23) = 0;
  }
  *(_DWORD *)(result + 32) = 0;
  return result;
}

uint64_t sub_100E391E4(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    if ((*(_BYTE *)(result + 24) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if (v1)
      {
        if (*(_BYTE *)(v1 + 36))
        {
          *(void *)(v1 + 8) = 0LL;
          *(void *)(v1 + 16) = 0LL;
          *(void *)(v1 + 24) = 0LL;
        }

        *(_DWORD *)(v1 + 36) = 0;
      }
    }

    *(_DWORD *)(result + 16) = 0;
  }

  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100E39218(uint64_t result)
{
  if (*(_BYTE *)(result + 28))
  {
    if ((*(_BYTE *)(result + 28) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if (v1)
      {
        if (*(_BYTE *)(v1 + 36))
        {
          *(void *)(v1 + 8) = 0LL;
          *(void *)(v1 + 16) = 0LL;
          *(void *)(v1 + 24) = 0LL;
        }

        *(_DWORD *)(v1 + 36) = 0;
      }
    }

    *(void *)(result + 16) = 0LL;
  }

  *(_DWORD *)(result + 28) = 0;
  return result;
}

uint64_t sub_100E3924C(uint64_t result)
{
  if (*(_BYTE *)(result + 28))
  {
    if ((*(_BYTE *)(result + 28) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if (v1)
      {
        if (*(_BYTE *)(v1 + 36))
        {
          *(void *)(v1 + 8) = 0LL;
          *(void *)(v1 + 16) = 0LL;
          *(void *)(v1 + 24) = 0LL;
        }

        *(_DWORD *)(v1 + 36) = 0;
      }
    }

    *(void *)(result + 16) = 0LL;
  }

  *(_DWORD *)(result + 28) = 0;
  return result;
}

uint64_t sub_100E39280(uint64_t result)
{
  if (*(_BYTE *)(result + 28))
  {
    if ((*(_BYTE *)(result + 28) & 1) != 0)
    {
      uint64_t v1 = *(void *)(result + 8);
      if (v1)
      {
        if (*(_BYTE *)(v1 + 36))
        {
          *(void *)(v1 + 8) = 0LL;
          *(void *)(v1 + 16) = 0LL;
          *(void *)(v1 + 24) = 0LL;
        }

        *(_DWORD *)(v1 + 36) = 0;
      }
    }

    *(void *)(result + 16) = 0LL;
  }

  *(_DWORD *)(result + 28) = 0;
  return result;
}

uint64_t sub_100E392B4( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 < *((void *)this + 2) && (*v5 & 0x80000000) == 0)
    {
      TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
      goto LABEL_6;
    }

    TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
    *((_DWORD *)this + 8) = (_DWORD)TagFallback;
    if (!(_DWORD)TagFallback) {
      return 1LL;
    }
LABEL_6:
    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_29;
        }
        *(_DWORD *)(a1 + 84) |= 1u;
        uint64_t v8 = *(char **)(a1 + 8);
        if (!v8)
        {
          uint64_t v8 = (char *)operator new(0x38uLL);
          *(void *)uint64_t v8 = off_101887440;
          *(_OWORD *)(v8 + 8) = 0u;
          *(_OWORD *)(v8 + 24) = 0u;
          *(_OWORD *)(v8 + 40) = 0u;
          *(void *)(a1 + 8) = v8;
        }

        uint64_t v9 = (char *)*((void *)this + 1);
        if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v90)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v90 = *v9;
          *((void *)this + 1) = v9 + 1;
        }

        int v10 = *((_DWORD *)this + 14);
        int v11 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v10 + 1;
        if (v10 >= v11) {
          return 0LL;
        }
        int v12 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v90);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v12);
        int v14 = *((_DWORD *)this + 14);
        BOOL v15 = __OFSUB__(v14, 1);
        int v16 = v14 - 1;
        if (v16 < 0 == v15) {
          *((_DWORD *)this + 14) = v16;
        }
        uint64_t v17 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v17 + 1;
        goto LABEL_41;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_29;
        }
LABEL_41:
        *(_DWORD *)(a1 + 84) |= 2u;
        uint64_t v18 = *(void **)(a1 + 16);
        if (!v18)
        {
          uint64_t v18 = operator new(0x20uLL);
          v18[1] = 0LL;
          v18[2] = 0LL;
          *uint64_t v18 = &off_1018874B8;
          *((_DWORD *)v18 + 6) = 0;
          *(void *)(a1 + 16) = v18;
        }

        uint64_t v19 = (char *)*((void *)this + 1);
        if ((unint64_t)v19 >= *((void *)this + 2) || *v19 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v90)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v90 = *v19;
          *((void *)this + 1) = v19 + 1;
        }

        int v20 = *((_DWORD *)this + 14);
        int v21 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v20 + 1;
        if (v20 >= v21) {
          return 0LL;
        }
        int v22 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v90);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v22);
        int v24 = *((_DWORD *)this + 14);
        BOOL v15 = __OFSUB__(v24, 1);
        int v25 = v24 - 1;
        if (v25 < 0 == v15) {
          *((_DWORD *)this + 14) = v25;
        }
        uint64_t v26 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v26 + 1;
LABEL_55:
        *(_DWORD *)(a1 + 84) |= 4u;
        uint64_t v27 = *(char **)(a1 + 24);
        if (!v27)
        {
          uint64_t v27 = (char *)operator new(0x28uLL);
          *(void *)uint64_t v27 = &off_101887530;
          *(_OWORD *)(v27 + 8) = 0u;
          *(_OWORD *)(v27 + 24) = 0u;
          *(void *)(a1 + 24) = v27;
        }

        uint64_t v28 = (char *)*((void *)this + 1);
        if ((unint64_t)v28 >= *((void *)this + 2) || *v28 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v90)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v90 = *v28;
          *((void *)this + 1) = v28 + 1;
        }

        int v29 = *((_DWORD *)this + 14);
        int v30 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v29 + 1;
        if (v29 >= v30) {
          return 0LL;
        }
        int v31 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v90);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v31);
        int v33 = *((_DWORD *)this + 14);
        BOOL v15 = __OFSUB__(v33, 1);
        int v34 = v33 - 1;
        if (v34 < 0 == v15) {
          *((_DWORD *)this + 14) = v34;
        }
        uint64_t v35 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v35 + 1;
LABEL_69:
        *(_DWORD *)(a1 + 84) |= 8u;
        uint64_t v36 = *(void **)(a1 + 32);
        if (!v36)
        {
          uint64_t v36 = operator new(0x90uLL);
          v36[5] = 0LL;
          v36[6] = 0LL;
          *((_DWORD *)v36 + 14) = 0;
          v36[8] = 0LL;
          v36[9] = 0LL;
          *((_DWORD *)v36 + 20) = 0;
          v36[11] = 0LL;
          v36[12] = 0LL;
          *((_DWORD *)v36 + 26) = 0;
          v36[14] = 0LL;
          v36[15] = 0LL;
          *((_DWORD *)v36 + 32) = 0;
          v36[17] = 0LL;
          *uint64_t v36 = off_101887620;
          v36[1] = 0LL;
          v36[2] = 0LL;
          v36[3] = 0LL;
          *((_DWORD *)v36 + 8) = 0;
          *(void *)(a1 + 32) = v36;
        }

        uint64_t v37 = (char *)*((void *)this + 1);
        if ((unint64_t)v37 >= *((void *)this + 2) || *v37 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v90)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v90 = *v37;
          *((void *)this + 1) = v37 + 1;
        }

        int v38 = *((_DWORD *)this + 14);
        int v39 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v38 + 1;
        if (v38 >= v39) {
          return 0LL;
        }
        int v40 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v90);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v40);
        int v42 = *((_DWORD *)this + 14);
        BOOL v15 = __OFSUB__(v42, 1);
        int v43 = v42 - 1;
        if (v43 < 0 == v15) {
          *((_DWORD *)this + 14) = v43;
        }
        __int128 v44 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v44 + 1;
LABEL_83:
        *(_DWORD *)(a1 + 84) |= 0x10u;
        __int128 v45 = *(_DWORD **)(a1 + 40);
        if (!v45)
        {
          __int128 v45 = operator new(0x28uLL);
          v45[7] = 0;
          v45[8] = 0;
          *((void *)v45 + 1) = 0LL;
          *((void *)v45 + 2) = 0LL;
          *(void *)__int128 v45 = &off_101887698;
          *((_BYTE *)v45 + 24) = 0;
          *(void *)(a1 + 40) = v45;
        }

        __int128 v46 = (char *)*((void *)this + 1);
        if ((unint64_t)v46 >= *((void *)this + 2) || *v46 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v90)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v90 = *v46;
          *((void *)this + 1) = v46 + 1;
        }

        int v47 = *((_DWORD *)this + 14);
        int v48 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v47 + 1;
        if (v47 >= v48) {
          return 0LL;
        }
        int v49 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v90);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v49);
        int v51 = *((_DWORD *)this + 14);
        BOOL v15 = __OFSUB__(v51, 1);
        int v52 = v51 - 1;
        if (v52 < 0 == v15) {
          *((_DWORD *)this + 14) = v52;
        }
        uint64_t v53 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v53 + 1;
LABEL_97:
        *(_DWORD *)(a1 + 84) |= 0x20u;
        __int128 v54 = *(void **)(a1 + 48);
        if (!v54)
        {
          __int128 v54 = operator new(0x20uLL);
          v54[1] = 0LL;
          uint64_t v54[2] = 0LL;
          *__int128 v54 = &off_101887710;
          *((_DWORD *)v54 + 6) = 0;
          *(void *)(a1 + 48) = v54;
        }

        uint64_t v55 = (char *)*((void *)this + 1);
        if ((unint64_t)v55 >= *((void *)this + 2) || *v55 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v90)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v90 = *v55;
          *((void *)this + 1) = v55 + 1;
        }

        int v56 = *((_DWORD *)this + 14);
        int v57 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v56 + 1;
        if (v56 >= v57) {
          return 0LL;
        }
        int v58 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v90);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v58);
        int v60 = *((_DWORD *)this + 14);
        BOOL v15 = __OFSUB__(v60, 1);
        int v61 = v60 - 1;
        if (v61 < 0 == v15) {
          *((_DWORD *)this + 14) = v61;
        }
        __int128 v62 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v62 + 1;
LABEL_111:
        *(_DWORD *)(a1 + 84) |= 0x40u;
        __int128 v63 = *(void **)(a1 + 56);
        if (!v63)
        {
          __int128 v63 = operator new(0x20uLL);
          *__int128 v63 = &off_101887788;
          v63[1] = 0LL;
          v63[2] = 0LL;
          v63[3] = 0LL;
          *(void *)(a1 + 56) = v63;
        }

        __int128 v64 = (char *)*((void *)this + 1);
        if ((unint64_t)v64 >= *((void *)this + 2) || *v64 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v90)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v90 = *v64;
          *((void *)this + 1) = v64 + 1;
        }

        int v65 = *((_DWORD *)this + 14);
        int v66 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v65 + 1;
        if (v65 >= v66) {
          return 0LL;
        }
        int v67 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v90);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v67);
        int v69 = *((_DWORD *)this + 14);
        BOOL v15 = __OFSUB__(v69, 1);
        int v70 = v69 - 1;
        if (v70 < 0 == v15) {
          *((_DWORD *)this + 14) = v70;
        }
        __int128 v71 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v71 + 1;
LABEL_125:
        *(_DWORD *)(a1 + 84) |= 0x80u;
        uint64_t v72 = *(void **)(a1 + 64);
        if (!v72)
        {
          uint64_t v72 = operator new(0x20uLL);
          *uint64_t v72 = &off_101887800;
          v72[1] = 0LL;
          v72[2] = 0LL;
          v72[3] = 0LL;
          *(void *)(a1 + 64) = v72;
        }

        __int128 v73 = (char *)*((void *)this + 1);
        if ((unint64_t)v73 >= *((void *)this + 2) || *v73 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v90)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v90 = *v73;
          *((void *)this + 1) = v73 + 1;
        }

        int v74 = *((_DWORD *)this + 14);
        int v75 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v74 + 1;
        if (v74 >= v75) {
          return 0LL;
        }
        int v76 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v90);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v76);
        int v78 = *((_DWORD *)this + 14);
        BOOL v15 = __OFSUB__(v78, 1);
        int v79 = v78 - 1;
        if (v79 < 0 == v15) {
          *((_DWORD *)this + 14) = v79;
        }
        double v80 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v80 + 1;
LABEL_139:
        *(_DWORD *)(a1 + 84) |= 0x100u;
        int v81 = *(void **)(a1 + 72);
        if (!v81)
        {
          int v81 = operator new(0x20uLL);
          *int v81 = &off_101887878;
          v81[1] = 0LL;
          v81[2] = 0LL;
          v81[3] = 0LL;
          *(void *)(a1 + 72) = v81;
        }

        std::string::size_type v82 = (char *)*((void *)this + 1);
        if ((unint64_t)v82 >= *((void *)this + 2) || *v82 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v90)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v90 = *v82;
          *((void *)this + 1) = v82 + 1;
        }

        int v83 = *((_DWORD *)this + 14);
        int v84 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v83 + 1;
        if (v83 >= v84) {
          return 0LL;
        }
        int v85 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v90);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v85);
        int v87 = *((_DWORD *)this + 14);
        BOOL v15 = __OFSUB__(v87, 1);
        int v88 = v87 - 1;
        if (v88 < 0 == v15) {
          *((_DWORD *)this + 14) = v88;
        }
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }

        break;
      case 3u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_55;
        }
        goto LABEL_29;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_69;
        }
        goto LABEL_29;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_83;
        }
        goto LABEL_29;
      case 6u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_97;
        }
        goto LABEL_29;
      case 7u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_111;
        }
        goto LABEL_29;
      case 8u:
        int v7 = TagFallback & 7;
        if (v7 == 2) {
          goto LABEL_125;
        }
        goto LABEL_29;
      case 9u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_29;
        }
        goto LABEL_139;
      default:
        int v7 = TagFallback & 7;
LABEL_29:
        if (v7 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100E39C7C( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 84);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A20E0 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 84);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_17;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t v8 = *(void *)(v5 + 16);
  if (!v8) {
    uint64_t v8 = *(void *)(qword_1019A20E0 + 16);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v8,  a2,  a4);
  int v6 = *(_DWORD *)(v5 + 84);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_20;
  }

uint64_t sub_100E39E2C(uint64_t a1, unsigned int a2)
{
  int v3 = *(_DWORD *)(a1 + 84);
  if (!(_BYTE)v3)
  {
    uint64_t v4 = 0LL;
    if ((v3 & 0x100) == 0) {
      goto LABEL_69;
    }
    goto LABEL_63;
  }

  if ((v3 & 1) == 0)
  {
    uint64_t v4 = 0LL;
    if ((v3 & 2) == 0) {
      goto LABEL_19;
    }
    goto LABEL_13;
  }

  uint64_t v5 = *(void *)(a1 + 8);
  if (!v5) {
    uint64_t v5 = *(void *)(qword_1019A20E0 + 8);
  }
  int v6 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100E3BAA8(v5, a2);
  int v7 = (int)v6;
  else {
    int v8 = 1;
  }
  uint64_t v4 = (v7 + v8 + 1);
  int v3 = *(_DWORD *)(a1 + 84);
  if ((v3 & 2) != 0)
  {
LABEL_13:
    uint64_t v9 = *(void *)(a1 + 16);
    if (!v9) {
      uint64_t v9 = *(void *)(qword_1019A20E0 + 16);
    }
    uint64_t v10 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100E3BFB0(v9, a2);
    int v11 = (int)v10;
    else {
      int v12 = 1;
    }
    uint64_t v4 = (v4 + v11 + v12 + 1);
    int v3 = *(_DWORD *)(a1 + 84);
  }

double sub_100E3A118(uint64_t a1, void *lpsrc)
{
  return sub_100E3891C(a1, (uint64_t)lpsrc);
}

double sub_100E3A164(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v14,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  1175LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v14,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v13, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v14);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 52);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 52) & 1) != 0)
    {
      *(_DWORD *)(a1 + 52) |= 1u;
      int v7 = *(char **)(a1 + 8);
      if (!v7)
      {
        int v7 = (char *)operator new(0x28uLL);
        *(void *)int v7 = off_1018873C8;
        *(_OWORD *)(v7 + 8) = 0u;
        *(_OWORD *)(v7 + 24) = 0u;
        *(void *)(a1 + 8) = v7;
      }

      uint64_t v8 = *(void *)(a2 + 8);
      if (!v8) {
        uint64_t v8 = *(void *)(qword_1019A20F0 + 8);
      }
      double result = sub_100E3B034((uint64_t)v7, v8);
      int v6 = *(_DWORD *)(a2 + 52);
      if ((v6 & 2) == 0)
      {
LABEL_6:
        if ((v6 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_23;
      }
    }

    else if ((*(_BYTE *)(a2 + 52) & 2) == 0)
    {
      goto LABEL_6;
    }

    *(_DWORD *)(a1 + 52) |= 2u;
    uint64_t v9 = *(char **)(a1 + 16);
    if (!v9)
    {
      uint64_t v9 = (char *)operator new(0x28uLL);
      *(void *)uint64_t v9 = off_1018873C8;
      *(_OWORD *)(v9 + 8) = 0u;
      *(_OWORD *)(v9 + 24) = 0u;
      *(void *)(a1 + 16) = v9;
    }

    uint64_t v10 = *(void *)(a2 + 16);
    if (!v10) {
      uint64_t v10 = *(void *)(qword_1019A20F0 + 16);
    }
    double result = sub_100E3B034((uint64_t)v9, v10);
    int v6 = *(_DWORD *)(a2 + 52);
    if ((v6 & 4) == 0)
    {
LABEL_7:
      if ((v6 & 8) == 0) {
        goto LABEL_8;
      }
      goto LABEL_25;
    }

void sub_100E3A320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100E3A338(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  1429LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      *(_DWORD *)(a1 + 24) |= 1u;
      int v6 = *(char **)(a1 + 8);
      if (!v6)
      {
        int v6 = (char *)operator new(0x28uLL);
        *(void *)int v6 = off_1018873C8;
        *(_OWORD *)(v6 + 8) = 0u;
        *(_OWORD *)(v6 + 24) = 0u;
        *(void *)(a1 + 8) = v6;
      }

      uint64_t v7 = *(void *)(a2 + 8);
      if (!v7) {
        uint64_t v7 = *(void *)(qword_1019A20F8 + 8);
      }
      sub_100E3B034((uint64_t)v6, v7);
      int v5 = *(_DWORD *)(a2 + 24);
    }

    if ((v5 & 2) != 0)
    {
      unsigned int v8 = *(_DWORD *)(a2 + 16);
      if (v8 >= 6) {
        sub_1012738D4();
      }
      *(_DWORD *)(a1 + 24) |= 2u;
      *(_DWORD *)(a1 + 16) = v8;
    }
  }

void sub_100E3A428(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

double sub_100E3A440(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v12,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  1745LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v12,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v11, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v12);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 36);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 36) & 1) != 0)
    {
      *(_DWORD *)(a1 + 36) |= 1u;
      uint64_t v7 = *(char **)(a1 + 8);
      if (!v7)
      {
        uint64_t v7 = (char *)operator new(0x28uLL);
        *(void *)uint64_t v7 = off_1018873C8;
        *(_OWORD *)(v7 + 8) = 0u;
        *(_OWORD *)(v7 + 24) = 0u;
        *(void *)(a1 + 8) = v7;
      }

      uint64_t v8 = *(void *)(a2 + 8);
      if (!v8) {
        uint64_t v8 = *(void *)(qword_1019A2100 + 8);
      }
      double result = sub_100E3B034((uint64_t)v7, v8);
      int v6 = *(_DWORD *)(a2 + 36);
    }

    if ((v6 & 2) != 0)
    {
      unsigned int v9 = *(_DWORD *)(a2 + 16);
      if (v9 >= 3) {
        sub_101273924();
      }
      *(_DWORD *)(a1 + 36) |= 2u;
      *(_DWORD *)(a1 + 16) = v9;
      int v6 = *(_DWORD *)(a2 + 36);
    }

    if ((v6 & 4) != 0)
    {
      unsigned int v10 = *(_DWORD *)(a2 + 20);
      if (v10 >= 4) {
        sub_1012738FC();
      }
      *(_DWORD *)(a1 + 36) |= 4u;
      *(_DWORD *)(a1 + 20) = v10;
      int v6 = *(_DWORD *)(a2 + 36);
    }

    if ((v6 & 8) != 0)
    {
      double result = *(double *)(a2 + 24);
      *(_DWORD *)(a1 + 36) |= 8u;
      *(double *)(a1 + 24) = result;
    }
  }

  return result;
}

void sub_100E3A574(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

double sub_100E3A58C(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v49,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  2318LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v49,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v48, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v49);
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 16),  *(_DWORD *)(a2 + 24) + *(_DWORD *)(a1 + 24));
  if (*(int *)(a2 + 24) >= 1)
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(a2 + 16) + 8 * v5);
      int v7 = *(_DWORD *)(a1 + 28);
      uint64_t v8 = *(int *)(a1 + 24);
      if ((int)v8 >= v7)
      {
        if (v7 == *(_DWORD *)(a1 + 32))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 16),  v7 + 1);
          int v7 = *(_DWORD *)(a1 + 28);
        }

        *(_DWORD *)(a1 + 28) = v7 + 1;
        unsigned int v10 = operator new(0x20uLL);
        v10[1] = 0LL;
        _OWORD v10[2] = 0LL;
        void *v10 = off_1018875A8;
        *((_DWORD *)v10 + 6) = 0;
        uint64_t v11 = *(void *)(a1 + 16);
        uint64_t v12 = *(int *)(a1 + 24);
        *(_DWORD *)(a1 + 24) = v12 + 1;
        *(void *)(v11 + 8 * v12) = v10;
      }

      else
      {
        uint64_t v9 = *(void *)(a1 + 16);
        *(_DWORD *)(a1 + 24) = v8 + 1;
        unsigned int v10 = *(void **)(v9 + 8 * v8);
      }

      sub_100E3C694((uint64_t)v10, v6);
      ++v5;
    }

    while (v5 < *(int *)(a2 + 24));
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 40),  *(_DWORD *)(a2 + 48) + *(_DWORD *)(a1 + 48));
  if (*(int *)(a2 + 48) >= 1)
  {
    uint64_t v13 = 0LL;
    do
    {
      uint64_t v14 = *(void *)(*(void *)(a2 + 40) + 8 * v13);
      int v15 = *(_DWORD *)(a1 + 52);
      uint64_t v16 = *(int *)(a1 + 48);
      if ((int)v16 >= v15)
      {
        if (v15 == *(_DWORD *)(a1 + 56))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 40),  v15 + 1);
          int v15 = *(_DWORD *)(a1 + 52);
        }

        *(_DWORD *)(a1 + 52) = v15 + 1;
        uint64_t v18 = operator new(0x20uLL);
        v18[1] = 0LL;
        v18[2] = 0LL;
        *uint64_t v18 = off_1018875A8;
        *((_DWORD *)v18 + 6) = 0;
        uint64_t v19 = *(void *)(a1 + 40);
        uint64_t v20 = *(int *)(a1 + 48);
        *(_DWORD *)(a1 + 48) = v20 + 1;
        *(void *)(v19 + 8 * v20) = v18;
      }

      else
      {
        uint64_t v17 = *(void *)(a1 + 40);
        *(_DWORD *)(a1 + 48) = v16 + 1;
        uint64_t v18 = *(void **)(v17 + 8 * v16);
      }

      sub_100E3C694((uint64_t)v18, v14);
      ++v13;
    }

    while (v13 < *(int *)(a2 + 48));
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 64),  *(_DWORD *)(a2 + 72) + *(_DWORD *)(a1 + 72));
  if (*(int *)(a2 + 72) >= 1)
  {
    uint64_t v21 = 0LL;
    do
    {
      uint64_t v22 = *(void *)(*(void *)(a2 + 64) + 8 * v21);
      int v23 = *(_DWORD *)(a1 + 76);
      uint64_t v24 = *(int *)(a1 + 72);
      if ((int)v24 >= v23)
      {
        if (v23 == *(_DWORD *)(a1 + 80))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 64),  v23 + 1);
          int v23 = *(_DWORD *)(a1 + 76);
        }

        *(_DWORD *)(a1 + 76) = v23 + 1;
        uint64_t v26 = operator new(0x20uLL);
        v26[1] = 0LL;
        _OWORD v26[2] = 0LL;
        *uint64_t v26 = off_1018875A8;
        *((_DWORD *)v26 + 6) = 0;
        uint64_t v27 = *(void *)(a1 + 64);
        uint64_t v28 = *(int *)(a1 + 72);
        *(_DWORD *)(a1 + 72) = v28 + 1;
        *(void *)(v27 + 8 * v28) = v26;
      }

      else
      {
        uint64_t v25 = *(void *)(a1 + 64);
        *(_DWORD *)(a1 + 72) = v24 + 1;
        uint64_t v26 = *(void **)(v25 + 8 * v24);
      }

      sub_100E3C694((uint64_t)v26, v22);
      ++v21;
    }

    while (v21 < *(int *)(a2 + 72));
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 88),  *(_DWORD *)(a2 + 96) + *(_DWORD *)(a1 + 96));
  if (*(int *)(a2 + 96) >= 1)
  {
    uint64_t v29 = 0LL;
    do
    {
      uint64_t v30 = *(void *)(*(void *)(a2 + 88) + 8 * v29);
      int v31 = *(_DWORD *)(a1 + 100);
      uint64_t v32 = *(int *)(a1 + 96);
      if ((int)v32 >= v31)
      {
        if (v31 == *(_DWORD *)(a1 + 104))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 88),  v31 + 1);
          int v31 = *(_DWORD *)(a1 + 100);
        }

        *(_DWORD *)(a1 + 100) = v31 + 1;
        int v34 = operator new(0x20uLL);
        v34[1] = 0LL;
        v34[2] = 0LL;
        *int v34 = off_1018875A8;
        *((_DWORD *)v34 + 6) = 0;
        uint64_t v35 = *(void *)(a1 + 88);
        uint64_t v36 = *(int *)(a1 + 96);
        *(_DWORD *)(a1 + 96) = v36 + 1;
        *(void *)(v35 + 8 * v36) = v34;
      }

      else
      {
        uint64_t v33 = *(void *)(a1 + 88);
        *(_DWORD *)(a1 + 96) = v32 + 1;
        int v34 = *(void **)(v33 + 8 * v32);
      }

      sub_100E3C694((uint64_t)v34, v30);
      ++v29;
    }

    while (v29 < *(int *)(a2 + 96));
  }

  wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 112),  *(_DWORD *)(a2 + 120) + *(_DWORD *)(a1 + 120));
  if (*(int *)(a2 + 120) >= 1)
  {
    uint64_t v38 = 0LL;
    do
    {
      uint64_t v39 = *(void *)(*(void *)(a2 + 112) + 8 * v38);
      int v40 = *(_DWORD *)(a1 + 124);
      uint64_t v41 = *(int *)(a1 + 120);
      if ((int)v41 >= v40)
      {
        if (v40 == *(_DWORD *)(a1 + 128))
        {
          wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve( (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 112),  v40 + 1);
          int v40 = *(_DWORD *)(a1 + 124);
        }

        *(_DWORD *)(a1 + 124) = v40 + 1;
        int v43 = operator new(0x20uLL);
        v43[1] = 0LL;
        v43[2] = 0LL;
        *int v43 = off_1018875A8;
        *((_DWORD *)v43 + 6) = 0;
        uint64_t v44 = *(void *)(a1 + 112);
        uint64_t v45 = *(int *)(a1 + 120);
        *(_DWORD *)(a1 + 120) = v45 + 1;
        *(void *)(v44 + 8 * v45) = v43;
      }

      else
      {
        uint64_t v42 = *(void *)(a1 + 112);
        *(_DWORD *)(a1 + 120) = v41 + 1;
        int v43 = *(void **)(v42 + 8 * v41);
      }

      *(float *)&double result = sub_100E3C694((uint64_t)v43, v39);
      ++v38;
    }

    while (v38 < *(int *)(a2 + 120));
  }

  if ((*(_BYTE *)(a2 + 140) & 1) != 0)
  {
    *(_DWORD *)(a1 + 140) |= 1u;
    __int128 v46 = *(char **)(a1 + 8);
    if (!v46)
    {
      __int128 v46 = (char *)operator new(0x28uLL);
      *(void *)__int128 v46 = off_1018873C8;
      *(_OWORD *)(v46 + 8) = 0u;
      *(_OWORD *)(v46 + 24) = 0u;
      *(void *)(a1 + 8) = v46;
    }

    uint64_t v47 = *(void *)(a2 + 8);
    if (!v47) {
      uint64_t v47 = *(void *)(qword_1019A2108 + 8);
    }
    return sub_100E3B034((uint64_t)v46, v47);
  }

  return result;
}

void sub_100E3AA00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100E3AA18(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v18,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  2768LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v18,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v17, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v18);
  }

  int v5 = *(_DWORD *)(a2 + 32);
  if (!(_BYTE)v5) {
    goto LABEL_13;
  }
  if ((v5 & 1) != 0)
  {
    *(_DWORD *)(a1 + 32) |= 1u;
    uint64_t v9 = *(char **)(a1 + 8);
    if (!v9)
    {
      uint64_t v9 = (char *)operator new(0x28uLL);
      *(void *)uint64_t v9 = off_1018873C8;
      *(_OWORD *)(v9 + 8) = 0u;
      *(_OWORD *)(v9 + 24) = 0u;
      *(void *)(a1 + 8) = v9;
    }

    uint64_t v10 = *(void *)(a2 + 8);
    if (!v10) {
      uint64_t v10 = *(void *)(qword_1019A2118 + 8);
    }
    sub_100E3B034((uint64_t)v9, v10);
    int v5 = *(_DWORD *)(a2 + 32);
    if ((v5 & 2) == 0)
    {
LABEL_6:
      if ((v5 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_25;
    }
  }

  else if ((v5 & 2) == 0)
  {
    goto LABEL_6;
  }

  char v11 = *(_BYTE *)(a2 + 16);
  *(_DWORD *)(a1 + 32) |= 2u;
  *(_BYTE *)(a1 + 16) = v11;
  int v5 = *(_DWORD *)(a2 + 32);
  if ((v5 & 4) == 0)
  {
LABEL_7:
    if ((v5 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_26;
  }

void sub_100E3AC08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100E3AC20(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  3084LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  LOBYTE(sub_1012279C0(0LL, v4, v5) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v5)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      *(_DWORD *)(a1 + 24) |= 1u;
      char v6 = *(char **)(a1 + 8);
      if (!v6)
      {
        char v6 = (char *)operator new(0x28uLL);
        *(void *)char v6 = off_1018873C8;
        *(_OWORD *)(v6 + 8) = 0u;
        *(_OWORD *)(v6 + 24) = 0u;
        *(void *)(a1 + 8) = v6;
      }

      uint64_t v7 = *(void *)(a2 + 8);
      if (!v7) {
        uint64_t v7 = *(void *)(qword_1019A2120 + 8);
      }
      sub_100E3B034((uint64_t)v6, v7);
      int v5 = *(_DWORD *)(a2 + 24);
    }

    if ((v5 & 2) != 0)
    {
      unsigned int v8 = *(_DWORD *)(a2 + 16);
      if (v8 >= 0x1C) {
        sub_10127394C();
      }
      *(_DWORD *)(a1 + 24) |= 2u;
      *(_DWORD *)(a1 + 16) = v8;
    }
  }

void sub_100E3AD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

double sub_100E3AD28(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  3292LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 28);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 28) & 1) != 0)
    {
      *(_DWORD *)(a1 + 28) |= 1u;
      uint64_t v7 = *(char **)(a1 + 8);
      if (!v7)
      {
        uint64_t v7 = (char *)operator new(0x28uLL);
        *(void *)uint64_t v7 = off_1018873C8;
        *(_OWORD *)(v7 + 8) = 0u;
        *(_OWORD *)(v7 + 24) = 0u;
        *(void *)(a1 + 8) = v7;
      }

      uint64_t v8 = *(void *)(a2 + 8);
      if (!v8) {
        uint64_t v8 = *(void *)(qword_1019A2128 + 8);
      }
      double result = sub_100E3B034((uint64_t)v7, v8);
      int v6 = *(_DWORD *)(a2 + 28);
    }

    if ((v6 & 2) != 0)
    {
      double result = *(double *)(a2 + 16);
      *(_DWORD *)(a1 + 28) |= 2u;
      *(double *)(a1 + 16) = result;
    }
  }

  return result;
}

void sub_100E3AE0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

double sub_100E3AE24(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  3500LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 28);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 28) & 1) != 0)
    {
      *(_DWORD *)(a1 + 28) |= 1u;
      uint64_t v7 = *(char **)(a1 + 8);
      if (!v7)
      {
        uint64_t v7 = (char *)operator new(0x28uLL);
        *(void *)uint64_t v7 = off_1018873C8;
        *(_OWORD *)(v7 + 8) = 0u;
        *(_OWORD *)(v7 + 24) = 0u;
        *(void *)(a1 + 8) = v7;
      }

      uint64_t v8 = *(void *)(a2 + 8);
      if (!v8) {
        uint64_t v8 = *(void *)(qword_1019A2130 + 8);
      }
      double result = sub_100E3B034((uint64_t)v7, v8);
      int v6 = *(_DWORD *)(a2 + 28);
    }

    if ((v6 & 2) != 0)
    {
      double result = *(double *)(a2 + 16);
      *(_DWORD *)(a1 + 28) |= 2u;
      *(double *)(a1 + 16) = result;
    }
  }

  return result;
}

void sub_100E3AF08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

double sub_100E3AF20(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v10,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  3708LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v10,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v9, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v10);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 28);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 28) & 1) != 0)
    {
      *(_DWORD *)(a1 + 28) |= 1u;
      uint64_t v7 = *(char **)(a1 + 8);
      if (!v7)
      {
        uint64_t v7 = (char *)operator new(0x28uLL);
        *(void *)uint64_t v7 = off_1018873C8;
        *(_OWORD *)(v7 + 8) = 0u;
        *(_OWORD *)(v7 + 24) = 0u;
        *(void *)(a1 + 8) = v7;
      }

      uint64_t v8 = *(void *)(a2 + 8);
      if (!v8) {
        uint64_t v8 = *(void *)(qword_1019A2138 + 8);
      }
      double result = sub_100E3B034((uint64_t)v7, v8);
      int v6 = *(_DWORD *)(a2 + 28);
    }

    if ((v6 & 2) != 0)
    {
      double result = *(double *)(a2 + 16);
      *(_DWORD *)(a1 + 28) |= 2u;
      *(double *)(a1 + 16) = result;
    }
  }

  return result;
}

void sub_100E3B004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100E3B01C()
{
  return 1LL;
}

void *sub_100E3B024@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.LogEntry");
}

double sub_100E3B034(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v8,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  827LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v8,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v7, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 36);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 36) & 1) != 0)
    {
      double result = *(double *)(a2 + 8);
      *(_DWORD *)(a1 + 36) |= 1u;
      *(double *)(a1 + 8) = result;
      int v6 = *(_DWORD *)(a2 + 36);
      if ((v6 & 2) == 0)
      {
LABEL_6:
        if ((v6 & 4) == 0) {
          return result;
        }
        goto LABEL_7;
      }
    }

    else if ((*(_BYTE *)(a2 + 36) & 2) == 0)
    {
      goto LABEL_6;
    }

    double result = *(double *)(a2 + 16);
    *(_DWORD *)(a1 + 36) |= 2u;
    *(double *)(a1 + 16) = result;
    if ((*(_DWORD *)(a2 + 36) & 4) == 0) {
      return result;
    }
LABEL_7:
    double result = *(double *)(a2 + 24);
    *(_DWORD *)(a1 + 36) |= 4u;
    *(double *)(a1 + 24) = result;
  }

  return result;
}

void sub_100E3B104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100E3B11C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018873C8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100E3B12C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018873C8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

double sub_100E3B14C()
{
  unsigned __int8 v0 = (char *)operator new(0x28uLL);
  *(void *)unsigned __int8 v0 = off_1018873C8;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  return result;
}

uint64_t sub_100E3B17C(uint64_t result)
{
  if (*(_BYTE *)(result + 36))
  {
    *(void *)(result + 8) = 0LL;
    *(void *)(result + 16) = 0LL;
    *(void *)(result + 24) = 0LL;
  }

  *(_DWORD *)(result + 36) = 0;
  return result;
}

uint64_t sub_100E3B194( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  do
  {
    while (1)
    {
      while (1)
      {
        int v5 = (char *)*((void *)this + 1);
        if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v5 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        unsigned int v7 = TagFallback >> 3;
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_27;
        }
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v12) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 8) = v12;
        *(_DWORD *)(a1 + 36) |= 1u;
        char v9 = (_BYTE *)*((void *)this + 1);
        if ((unint64_t)v9 < *((void *)this + 2) && *v9 == 17)
        {
          *((void *)this + 1) = v9 + 1;
LABEL_17:
          if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v12) & 1) == 0) {
            return 0LL;
          }
          *(void *)(a1 + 16) = v12;
          *(_DWORD *)(a1 + 36) |= 2u;
          uint64_t v10 = (_BYTE *)*((void *)this + 1);
          if ((unint64_t)v10 < *((void *)this + 2) && *v10 == 25)
          {
            *((void *)this + 1) = v10 + 1;
            goto LABEL_21;
          }
        }
      }

      if (v7 == 2)
      {
        int v8 = TagFallback & 7;
        if (v8 != 1) {
          goto LABEL_27;
        }
        goto LABEL_17;
      }

      if (v7 != 3)
      {
        int v8 = TagFallback & 7;
        goto LABEL_27;
      }

      int v8 = TagFallback & 7;
      if (v8 == 1) {
        break;
      }
LABEL_27:
      if (v8 == 4) {
        return 1LL;
      }
    }

uint64_t sub_100E3B34C( uint64_t result, int a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 36);
  if ((v5 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  a2,  *(double *)(result + 8),  a3);
    int v5 = *(_DWORD *)(v4 + 36);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        return result;
      }
      return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  a2,  *(double *)(v4 + 24),  a3);
    }
  }

  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  a2,  *(double *)(v4 + 16),  a3);
  if ((*(_DWORD *)(v4 + 36) & 4) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  a2,  *(double *)(v4 + 24),  a3);
  }
  return result;
}

uint64_t sub_100E3B3C4(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 36);
  if (*(_BYTE *)(a1 + 36))
  {
    unsigned int v2 = ((int)((_DWORD)v1 << 31) >> 31) & 9;
    if ((v1 & 2) != 0) {
      v2 += 9;
    }
    if ((v1 & 4) != 0) {
      uint64_t v1 = v2 + 9;
    }
    else {
      uint64_t v1 = v2;
    }
  }

  *(_DWORD *)(a1 + 32) = v1;
  return v1;
}

double sub_100E3B3FC(uint64_t a1, void *lpsrc)
{
  return sub_100E3B034(a1, (uint64_t)lpsrc);
}

uint64_t sub_100E3B448()
{
  return 1LL;
}

void *sub_100E3B450@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.Timestamp");
}

void *sub_100E3B460(void *result)
{
  if ((void *)qword_1019A20F0 != result)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[1];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
    uint64_t result = (void *)v1[2];
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8LL))(result);
    }
  }

  return result;
}

void sub_100E3B4BC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101887440;
  sub_100E3B460(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100E3B4EC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101887440;
  sub_100E3B460(a1);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v2);
}

double sub_100E3B520()
{
  unsigned __int8 v0 = (char *)operator new(0x38uLL);
  *(void *)unsigned __int8 v0 = off_101887440;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  return result;
}

uint64_t sub_100E3B554( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_23;
        }
        *(_DWORD *)(a1 + 52) |= 1u;
        int v8 = *(char **)(a1 + 8);
        if (!v8)
        {
          int v8 = (char *)operator new(0x28uLL);
          *(void *)int v8 = off_1018873C8;
          *(_OWORD *)(v8 + 8) = 0u;
          *(_OWORD *)(v8 + 24) = 0u;
          *(void *)(a1 + 8) = v8;
        }

        char v9 = (char *)*((void *)this + 1);
        if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v37)) {
            return 0LL;
          }
        }

        else
        {
          v37[0] = *v9;
          *((void *)this + 1) = v9 + 1;
        }

        int v14 = *((_DWORD *)this + 14);
        int v15 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v14 + 1;
        if (v14 >= v15) {
          return 0LL;
        }
        int v16 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v37[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v16);
        int v18 = *((_DWORD *)this + 14);
        BOOL v19 = __OFSUB__(v18, 1);
        int v20 = v18 - 1;
        if (v20 < 0 == v19) {
          *((_DWORD *)this + 14) = v20;
        }
        uint64_t v21 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v21 + 1;
        goto LABEL_35;
      case 2u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_23;
        }
LABEL_35:
        *(_DWORD *)(a1 + 52) |= 2u;
        uint64_t v22 = *(char **)(a1 + 16);
        if (!v22)
        {
          uint64_t v22 = (char *)operator new(0x28uLL);
          *(void *)uint64_t v22 = off_1018873C8;
          *(_OWORD *)(v22 + 8) = 0u;
          *(_OWORD *)(v22 + 24) = 0u;
          *(void *)(a1 + 16) = v22;
        }

        int v23 = (char *)*((void *)this + 1);
        if ((unint64_t)v23 >= *((void *)this + 2) || *v23 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v37)) {
            return 0LL;
          }
        }

        else
        {
          v37[0] = *v23;
          *((void *)this + 1) = v23 + 1;
        }

        int v24 = *((_DWORD *)this + 14);
        int v25 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v24 + 1;
        if (v24 >= v25) {
          return 0LL;
        }
        int v26 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v37[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v26);
        int v28 = *((_DWORD *)this + 14);
        BOOL v19 = __OFSUB__(v28, 1);
        int v29 = v28 - 1;
        if (v29 < 0 == v19) {
          *((_DWORD *)this + 14) = v29;
        }
        uint64_t v30 = (_BYTE *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        char v11 = v30 + 1;
        *((void *)this + 1) = v11;
LABEL_49:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v37);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v31 = v37[0];
        }

        else
        {
          unsigned int v31 = *v11;
          *((void *)this + 1) = v11 + 1;
        }

        if (v31 <= 2)
        {
          *(_DWORD *)(a1 + 52) |= 4u;
          *(_DWORD *)(a1 + 24) = v31;
        }

        uint64_t v33 = (_BYTE *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        char v13 = v33 + 1;
        *((void *)this + 1) = v13;
LABEL_59:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v37);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v34 = v37[0];
        }

        else
        {
          unsigned int v34 = *v13;
          *((void *)this + 1) = v13 + 1;
        }

        if (v34 <= 3)
        {
          *(_DWORD *)(a1 + 52) |= 8u;
          *(_DWORD *)(a1 + 28) = v34;
        }

        uint64_t v35 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v35 + 1;
LABEL_69:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v37) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 32) = *(void *)v37;
        *(_DWORD *)(a1 + 52) |= 0x10u;
        uint64_t v36 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v36 + 1;
LABEL_73:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v37) & 1) != 0)
        {
          *(void *)(a1 + 40) = *(void *)v37;
          *(_DWORD *)(a1 + 52) |= 0x20u;
          if (*((void *)this + 1) == *((void *)this + 2)
            && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          continue;
        }

        return 0LL;
      case 3u:
        int v7 = TagFallback & 7;
        char v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_49;
      case 4u:
        int v7 = TagFallback & 7;
        char v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_59;
      case 5u:
        int v7 = TagFallback & 7;
        if (v7 == 1) {
          goto LABEL_69;
        }
        goto LABEL_23;
      case 6u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_23;
        }
        goto LABEL_73;
      default:
        int v7 = TagFallback & 7;
LABEL_23:
        if (v7 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100E3B9BC( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 52);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A20F0 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 52);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t v8 = *(void *)(v5 + 16);
  if (!v8) {
    uint64_t v8 = *(void *)(qword_1019A20F0 + 16);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  v8,  a2,  a4);
  int v6 = *(_DWORD *)(v5 + 52);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_15;
  }

uint64_t sub_100E3BAA8(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 52);
  if (!(_BYTE)v3)
  {
    uint64_t result = 0LL;
    goto LABEL_44;
  }

  if ((*(_BYTE *)(a1 + 52) & 1) == 0)
  {
    int v4 = 0;
    if ((*(_BYTE *)(a1 + 52) & 2) == 0) {
      goto LABEL_24;
    }
    goto LABEL_15;
  }

  uint64_t v6 = *(void *)(a1 + 8);
  if (!v6) {
    uint64_t v6 = *(void *)(qword_1019A20F0 + 8);
  }
  int v7 = *(unsigned __int8 *)(v6 + 36);
  if (*(_BYTE *)(v6 + 36))
  {
    int v8 = (v7 << 31 >> 31) & 9;
    if ((v7 & 2) != 0) {
      v8 += 9;
    }
    if ((v7 & 4) != 0) {
      int v7 = v8 + 9;
    }
    else {
      int v7 = v8;
    }
  }

  *(_DWORD *)(v6 + 32) = v7;
  int v4 = v7 + 2;
  int v3 = *(_DWORD *)(a1 + 52);
  if ((v3 & 2) != 0)
  {
LABEL_15:
    uint64_t v9 = *(void *)(a1 + 16);
    if (!v9) {
      uint64_t v9 = *(void *)(qword_1019A20F0 + 16);
    }
    int v10 = *(unsigned __int8 *)(v9 + 36);
    if (*(_BYTE *)(v9 + 36))
    {
      int v11 = (v10 << 31 >> 31) & 9;
      if ((v10 & 2) != 0) {
        v11 += 9;
      }
      if ((v10 & 4) != 0) {
        int v10 = v11 + 9;
      }
      else {
        int v10 = v11;
      }
    }

    *(_DWORD *)(v9 + 32) = v10;
    v4 += v10 + 2;
    int v3 = *(_DWORD *)(a1 + 52);
  }

double sub_100E3BC10(uint64_t a1, void *lpsrc)
{
  return sub_100E3A164(a1, (uint64_t)lpsrc);
}

uint64_t sub_100E3BC5C()
{
  return 1LL;
}

void *sub_100E3BC64@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.CLIndoorOutdoorUpdate");
}

void sub_100E3BC74(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_1018874B8;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A20F8 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100E3BCC8(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100E3BCDC()
{
  uint64_t result = operator new(0x20uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = &off_1018874B8;
  *((_DWORD *)result + 6) = 0;
  return result;
}

uint64_t sub_100E3BD08( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      if (TagFallback >> 3 == 2)
      {
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) == 0)
        {
          uint64_t v9 = (char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
          goto LABEL_29;
        }
      }

      else
      {
        int v7 = TagFallback & 7;
      }

uint64_t sub_100E3BF44( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  (int)a2,  a4);
  }

  uint64_t v7 = *(void *)(result + 8);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_1019A20F8 + 8);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
  if ((*(_DWORD *)(v5 + 24) & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  (int)a2,  a4);
  }
  return result;
}

uint64_t sub_100E3BFB0(uint64_t a1, unsigned int a2)
{
  if (!*(_BYTE *)(a1 + 24))
  {
    uint64_t v3 = 0LL;
    goto LABEL_21;
  }

  if ((*(_BYTE *)(a1 + 24) & 1) == 0)
  {
    uint64_t v3 = 0LL;
    if ((*(_BYTE *)(a1 + 24) & 2) == 0) {
      goto LABEL_21;
    }
    goto LABEL_15;
  }

  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    uint64_t v4 = *(void *)(qword_1019A20F8 + 8);
  }
  int v5 = *(unsigned __int8 *)(v4 + 36);
  if (*(_BYTE *)(v4 + 36))
  {
    int v6 = (v5 << 31 >> 31) & 9;
    if ((v5 & 2) != 0) {
      v6 += 9;
    }
    if ((v5 & 4) != 0) {
      int v5 = v6 + 9;
    }
    else {
      int v5 = v6;
    }
  }

  *(_DWORD *)(v4 + 32) = v5;
  uint64_t v3 = (v5 + 2);
  if ((*(_DWORD *)(a1 + 24) & 2) != 0)
  {
LABEL_15:
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v7 & 0x80000000) != 0)
    {
      int v8 = 11;
    }

    else if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2) + 1;
    }

    else
    {
      int v8 = 2;
    }

    uint64_t v3 = (v8 + v3);
  }

void sub_100E3C070(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100E3C0BC()
{
  return 1LL;
}

void *sub_100E3C0C4@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.SignalEnvironment");
}

void sub_100E3C0D4(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101887530;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A2100 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100E3C128(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

double sub_100E3C13C()
{
  unsigned __int8 v0 = (char *)operator new(0x28uLL);
  *(void *)unsigned __int8 v0 = &off_101887530;
  double result = 0.0;
  *(_OWORD *)(v0 + 8) = 0u;
  *(_OWORD *)(v0 + 24) = 0u;
  return result;
}

uint64_t sub_100E3C16C( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_19;
        }
        *(_DWORD *)(a1 + 36) |= 1u;
        int v8 = *(char **)(a1 + 8);
        if (!v8)
        {
          int v8 = (char *)operator new(0x28uLL);
          *(void *)int v8 = off_1018873C8;
          *(_OWORD *)(v8 + 8) = 0u;
          *(_OWORD *)(v8 + 24) = 0u;
          *(void *)(a1 + 8) = v8;
        }

        uint64_t v9 = (char *)*((void *)this + 1);
        if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  v27)) {
            return 0LL;
          }
        }

        else
        {
          v27[0] = *v9;
          *((void *)this + 1) = v9 + 1;
        }

        int v14 = *((_DWORD *)this + 14);
        int v15 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v14 + 1;
        if (v14 >= v15) {
          return 0LL;
        }
        int v16 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v27[0]);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v16);
        int v18 = *((_DWORD *)this + 14);
        BOOL v19 = __OFSUB__(v18, 1);
        int v20 = v18 - 1;
        if (v20 < 0 == v19) {
          *((_DWORD *)this + 14) = v20;
        }
        uint64_t v21 = (_BYTE *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        int v11 = v21 + 1;
        *((void *)this + 1) = v11;
        goto LABEL_31;
      case 2u:
        int v7 = TagFallback & 7;
        int v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
LABEL_31:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v27);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v22 = v27[0];
        }

        else
        {
          unsigned int v22 = *v11;
          *((void *)this + 1) = v11 + 1;
        }

        if (v22 <= 2)
        {
          *(_DWORD *)(a1 + 36) |= 2u;
          *(_DWORD *)(a1 + 16) = v22;
        }

        int v24 = (_BYTE *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        int v13 = v24 + 1;
        *((void *)this + 1) = v13;
LABEL_41:
        if ((unint64_t)v13 >= v12 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, v27);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v25 = v27[0];
        }

        else
        {
          unsigned int v25 = *v13;
          *((void *)this + 1) = v13 + 1;
        }

        if (v25 <= 3)
        {
          *(_DWORD *)(a1 + 36) |= 4u;
          *(_DWORD *)(a1 + 20) = v25;
        }

        int v26 = (_BYTE *)*((void *)this + 1);
        *((void *)this + 1) = v26 + 1;
LABEL_51:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback( this,  (unint64_t *)v27) & 1) != 0)
        {
          *(void *)(a1 + 24) = *(void *)v27;
          *(_DWORD *)(a1 + 36) |= 8u;
          if (*((void *)this + 1) == *((void *)this + 2)
            && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
          {
            *((_DWORD *)this + 8) = 0;
            uint64_t result = 1LL;
            *((_BYTE *)this + 36) = 1;
            return result;
          }

          continue;
        }

        return 0LL;
      case 3u:
        int v7 = TagFallback & 7;
        int v13 = (char *)*((void *)this + 1);
        unint64_t v12 = *((void *)this + 2);
        goto LABEL_41;
      case 4u:
        int v7 = TagFallback & 7;
        if (v7 != 1) {
          goto LABEL_19;
        }
        goto LABEL_51;
      default:
        int v7 = TagFallback & 7;
LABEL_19:
        if (v7 == 4) {
          return 1LL;
        }
        continue;
    }
  }

uint64_t sub_100E3C48C( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 36);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A2100 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 36);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  (int)a2,  a4);
  int v6 = *(_DWORD *)(v5 + 36);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4,  (int)a2,  *(double *)(v5 + 24),  a3);
  }

uint64_t sub_100E3C530(uint64_t a1, unsigned int a2)
{
  LOBYTE(v3) = *(_BYTE *)(a1 + 36);
  if (!(_BYTE)v3)
  {
    uint64_t result = 0LL;
    goto LABEL_31;
  }

  if ((*(_BYTE *)(a1 + 36) & 1) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (!v6) {
      uint64_t v6 = *(void *)(qword_1019A2100 + 8);
    }
    int v7 = *(unsigned __int8 *)(v6 + 36);
    if (*(_BYTE *)(v6 + 36))
    {
      int v8 = (v7 << 31 >> 31) & 9;
      if ((v7 & 2) != 0) {
        v8 += 9;
      }
      if ((v7 & 4) != 0) {
        int v7 = v8 + 9;
      }
      else {
        int v7 = v8;
      }
    }

    *(_DWORD *)(v6 + 32) = v7;
    unsigned int v4 = v7 + 2;
    int v3 = *(_DWORD *)(a1 + 36);
    if ((v3 & 2) == 0) {
      goto LABEL_21;
    }
    goto LABEL_15;
  }

  unsigned int v4 = 0;
  if ((*(_BYTE *)(a1 + 36) & 2) != 0)
  {
LABEL_15:
    uint64_t v9 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v9 & 0x80000000) != 0)
    {
      int v10 = 11;
    }

    else if (v9 >= 0x80)
    {
      int v10 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v9, a2) + 1;
      int v3 = *(_DWORD *)(a1 + 36);
    }

    else
    {
      int v10 = 2;
    }

    v4 += v10;
  }

double sub_100E3C630(uint64_t a1, void *lpsrc)
{
  return sub_100E3A440(a1, (uint64_t)lpsrc);
}

uint64_t sub_100E3C67C()
{
  return 1LL;
}

void *sub_100E3C684@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.GnssAvailabilityPredictorData");
}

float sub_100E3C694(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    wireless_diagnostics::google::protobuf::internal::LogMessage::LogMessage( v8,  3LL,  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/ProtobufDefs/CLPOutdoorEstimatorLogEntry.pb.cc",  1980LL);
    uint64_t v4 = wireless_diagnostics::google::protobuf::internal::LogMessage::operator<<( v8,  "CHECK failed: (&from) != (this): ");
    wireless_diagnostics::google::protobuf::internal::LogFinisher::operator=(&v7, v4);
    wireless_diagnostics::google::protobuf::internal::LogMessage::~LogMessage((wireless_diagnostics::google::protobuf::internal::LogMessage *)v8);
  }

  LOBYTE(v6) = *(_BYTE *)(a2 + 24);
  if ((_BYTE)v6)
  {
    if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    {
      float result = *(float *)(a2 + 8);
      *(_DWORD *)(a1 + 24) |= 1u;
      *(float *)(a1 + 8) = result;
      int v6 = *(_DWORD *)(a2 + 24);
      if ((v6 & 2) == 0)
      {
LABEL_6:
        if ((v6 & 4) == 0) {
          return result;
        }
        goto LABEL_7;
      }
    }

    else if ((*(_BYTE *)(a2 + 24) & 2) == 0)
    {
      goto LABEL_6;
    }

    float result = *(float *)(a2 + 12);
    *(_DWORD *)(a1 + 24) |= 2u;
    *(float *)(a1 + 12) = result;
    if ((*(_DWORD *)(a2 + 24) & 4) == 0) {
      return result;
    }
LABEL_7:
    float result = *(float *)(a2 + 16);
    *(_DWORD *)(a1 + 24) |= 4u;
    *(float *)(a1 + 16) = result;
  }

  return result;
}

void sub_100E3C764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100E3C77C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018875A8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100E3C78C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_1018875A8;
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
  operator delete(v1);
}

void *sub_100E3C7AC()
{
  float result = operator new(0x20uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *float result = off_1018875A8;
  *((_DWORD *)result + 6) = 0;
  return result;
}

uint64_t sub_100E3C7D8(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    *(void *)(result + 8) = 0LL;
    *(_DWORD *)(result + 16) = 0;
  }

  *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100E3C7F0( _DWORD *a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  do
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (char *)*((void *)this + 1);
        if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
        {
          TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        else
        {
          TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
          *((_DWORD *)this + 8) = (_DWORD)TagFallback;
          *((void *)this + 1) = v5 + 1;
          if (!(_DWORD)TagFallback) {
            return 1LL;
          }
        }

        unsigned int v7 = TagFallback >> 3;
        int v8 = TagFallback & 7;
        if (v8 != 5) {
          goto LABEL_27;
        }
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v14) & 1) == 0) {
          return 0LL;
        }
        a1[2] = v14;
        a1[6] |= 1u;
        uint64_t v9 = (_BYTE *)*((void *)this + 1);
        if ((unint64_t)v9 < *((void *)this + 2) && *v9 == 21)
        {
          *((void *)this + 1) = v9 + 1;
LABEL_17:
          if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian32Fallback(this, &v13) & 1) == 0) {
            return 0LL;
          }
          a1[3] = v13;
          a1[6] |= 2u;
          int v10 = (_BYTE *)*((void *)this + 1);
          if ((unint64_t)v10 < *((void *)this + 2) && *v10 == 29)
          {
            *((void *)this + 1) = v10 + 1;
            goto LABEL_21;
          }
        }
      }

      if (v7 == 2)
      {
        int v8 = TagFallback & 7;
        if (v8 != 5) {
          goto LABEL_27;
        }
        goto LABEL_17;
      }

      if (v7 != 3)
      {
        int v8 = TagFallback & 7;
        goto LABEL_27;
      }

      int v8 = TagFallback & 7;
      if (v8 == 5) {
        break;
      }
LABEL_27:
      if (v8 == 4) {
        return 1LL;
      }
    }

uint64_t sub_100E3C9A8( uint64_t result, int a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 24);
  if ((v5 & 1) != 0)
  {
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  a2,  *(float *)(result + 8),  a3);
    int v5 = *(_DWORD *)(v4 + 24);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0) {
        return result;
      }
      return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  a2,  *(float *)(v4 + 16),  a3);
    }
  }

  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  a2,  *(float *)(v4 + 12),  a3);
  if ((*(_DWORD *)(v4 + 24) & 4) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteFloat( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  a2,  *(float *)(v4 + 16),  a3);
  }
  return result;
}

uint64_t sub_100E3CA20(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 24);
  if (*(_BYTE *)(a1 + 24))
  {
    unsigned int v2 = ((int)((_DWORD)v1 << 31) >> 31) & 5;
    if ((v1 & 2) != 0) {
      v2 += 5;
    }
    if ((v1 & 4) != 0) {
      uint64_t v1 = v2 + 5;
    }
    else {
      uint64_t v1 = v2;
    }
  }

  *(_DWORD *)(a1 + 20) = v1;
  return v1;
}

float sub_100E3CA58(uint64_t a1, void *lpsrc)
{
  return sub_100E3C694(a1, (uint64_t)lpsrc);
}

uint64_t sub_100E3CAA4()
{
  return 1LL;
}

void *sub_100E3CAAC@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.GnssLeechLocationData.SatelliteInfo");
}

void sub_100E3CABC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
  *(void *)a1 = off_101887620;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A2108 != a1)
  {
    uint64_t v2 = *((void *)a1 + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  sub_10008D0EC((uint64_t)a1 + 112);
  sub_10008D0EC((uint64_t)a1 + 88);
  sub_10008D0EC((uint64_t)a1 + 64);
  sub_10008D0EC((uint64_t)a1 + 40);
  sub_10008D0EC((uint64_t)a1 + 16);
  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(a1);
}

void sub_100E3CB4C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100E3CB60()
{
  uint64_t result = operator new(0x90uLL);
  result[5] = 0LL;
  result[6] = 0LL;
  *((_DWORD *)result + 14) = 0;
  result[8] = 0LL;
  result[9] = 0LL;
  *((_DWORD *)result + 20) = 0;
  result[11] = 0LL;
  result[12] = 0LL;
  *((_DWORD *)result + 26) = 0;
  result[14] = 0LL;
  result[15] = 0LL;
  *((_DWORD *)result + 32) = 0;
  result[17] = 0LL;
  *uint64_t result = off_101887620;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  *((_DWORD *)result + 8) = 0;
  return result;
}

uint64_t sub_100E3CBB0( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  std::string::size_type v93 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 16);
  uint64_t v5 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 40);
  int v6 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 64);
  unsigned int v7 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 88);
  int v8 = (wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase *)(a1 + 112);
LABEL_2:
  while (2)
  {
    uint64_t v9 = (char *)*((void *)this + 1);
    if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
    {
      TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v9;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v9 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v11 = TagFallback & 7;
        if (v11 != 2) {
          goto LABEL_24;
        }
        *(_DWORD *)(a1 + 140) |= 1u;
        unsigned int v12 = *(char **)(a1 + 8);
        if (!v12)
        {
          unsigned int v12 = (char *)operator new(0x28uLL);
          *(void *)unsigned int v12 = off_1018873C8;
          *(_OWORD *)(v12 + 8) = 0u;
          *(_OWORD *)(v12 + 24) = 0u;
          *(void *)(a1 + 8) = v12;
        }

        unsigned int v13 = (char *)*((void *)this + 1);
        if ((unint64_t)v13 >= *((void *)this + 2) || *v13 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v94)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v94 = *v13;
          *((void *)this + 1) = v13 + 1;
        }

        int v14 = *((_DWORD *)this + 14);
        int v15 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v14 + 1;
        if (v14 >= v15) {
          return 0LL;
        }
        int v16 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v94);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v16);
        int v18 = *((_DWORD *)this + 14);
        BOOL v19 = __OFSUB__(v18, 1);
        int v20 = v18 - 1;
        if (v20 < 0 == v19) {
          *((_DWORD *)this + 14) = v20;
        }
        uint64_t v21 = (_BYTE *)*((void *)this + 1);
        goto LABEL_35;
      case 2u:
        int v11 = TagFallback & 7;
        if (v11 != 2) {
          goto LABEL_24;
        }
        break;
      case 3u:
        int v11 = TagFallback & 7;
        if (v11 == 2) {
          goto LABEL_54;
        }
        goto LABEL_24;
      case 4u:
        int v11 = TagFallback & 7;
        if (v11 == 2) {
          goto LABEL_72;
        }
        goto LABEL_24;
      case 5u:
        int v11 = TagFallback & 7;
        if (v11 == 2) {
          goto LABEL_90;
        }
        goto LABEL_24;
      case 6u:
        int v11 = TagFallback & 7;
        if (v11 != 2) {
          goto LABEL_24;
        }
        goto LABEL_108;
      default:
        int v11 = TagFallback & 7;
LABEL_24:
        if (v11 == 4) {
          return 1LL;
        }
        continue;
    }

    break;
  }

  while (1)
  {
    int v22 = *(_DWORD *)(a1 + 28);
    uint64_t v23 = *(int *)(a1 + 24);
    if ((int)v23 >= v22)
    {
      if (v22 == *(_DWORD *)(a1 + 32))
      {
        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v93, v22 + 1);
        int v22 = *(_DWORD *)(a1 + 28);
      }

      *(_DWORD *)(a1 + 28) = v22 + 1;
      unsigned int v25 = operator new(0x20uLL);
      v25[1] = 0LL;
      _OWORD v25[2] = 0LL;
      void *v25 = off_1018875A8;
      *((_DWORD *)v25 + 6) = 0;
      uint64_t v26 = *(void *)(a1 + 16);
      uint64_t v27 = *(int *)(a1 + 24);
      *(_DWORD *)(a1 + 24) = v27 + 1;
      *(void *)(v26 + 8 * v27) = v25;
    }

    else
    {
      uint64_t v24 = *(void *)(a1 + 16);
      *(_DWORD *)(a1 + 24) = v23 + 1;
      unsigned int v25 = *(void **)(v24 + 8 * v23);
    }

    int v28 = (char *)*((void *)this + 1);
    if ((unint64_t)v28 >= *((void *)this + 2) || *v28 < 0)
    {
    }

    else
    {
      unsigned int v94 = *v28;
      *((void *)this + 1) = v28 + 1;
    }

    int v29 = *((_DWORD *)this + 14);
    int v30 = *((_DWORD *)this + 15);
    *((_DWORD *)this + 14) = v29 + 1;
    if (v29 >= v30) {
      return 0LL;
    }
    int v31 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v94);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v31);
    int v33 = *((_DWORD *)this + 14);
    BOOL v19 = __OFSUB__(v33, 1);
    int v34 = v33 - 1;
    if (v34 < 0 == v19) {
      *((_DWORD *)this + 14) = v34;
    }
    uint64_t v21 = (_BYTE *)*((void *)this + 1);
    int v35 = *v21;
    if (v35 != 18)
    {
      if (v35 != 26) {
        goto LABEL_2;
      }
      while (1)
      {
        *((void *)this + 1) = v21 + 1;
LABEL_54:
        int v36 = *(_DWORD *)(a1 + 52);
        uint64_t v37 = *(int *)(a1 + 48);
        if ((int)v37 >= v36)
        {
          if (v36 == *(_DWORD *)(a1 + 56))
          {
            wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v5, v36 + 1);
            int v36 = *(_DWORD *)(a1 + 52);
          }

          *(_DWORD *)(a1 + 52) = v36 + 1;
          uint64_t v39 = operator new(0x20uLL);
          v39[1] = 0LL;
          void v39[2] = 0LL;
          void *v39 = off_1018875A8;
          *((_DWORD *)v39 + 6) = 0;
          uint64_t v40 = *(void *)(a1 + 40);
          uint64_t v41 = *(int *)(a1 + 48);
          *(_DWORD *)(a1 + 48) = v41 + 1;
          *(void *)(v40 + 8 * v41) = v39;
        }

        else
        {
          uint64_t v38 = *(void *)(a1 + 40);
          *(_DWORD *)(a1 + 48) = v37 + 1;
          uint64_t v39 = *(void **)(v38 + 8 * v37);
        }

        uint64_t v42 = (char *)*((void *)this + 1);
        if ((unint64_t)v42 >= *((void *)this + 2) || *v42 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v94)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v94 = *v42;
          *((void *)this + 1) = v42 + 1;
        }

        int v43 = *((_DWORD *)this + 14);
        int v44 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v43 + 1;
        if (v43 >= v44) {
          return 0LL;
        }
        int v45 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v94);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v45);
        int v47 = *((_DWORD *)this + 14);
        BOOL v19 = __OFSUB__(v47, 1);
        int v48 = v47 - 1;
        if (v48 < 0 == v19) {
          *((_DWORD *)this + 14) = v48;
        }
        uint64_t v21 = (_BYTE *)*((void *)this + 1);
        int v49 = *v21;
        if (v49 != 26)
        {
          if (v49 != 34) {
            goto LABEL_2;
          }
          while (1)
          {
            *((void *)this + 1) = v21 + 1;
LABEL_72:
            int v50 = *(_DWORD *)(a1 + 76);
            uint64_t v51 = *(int *)(a1 + 72);
            if ((int)v51 >= v50)
            {
              if (v50 == *(_DWORD *)(a1 + 80))
              {
                wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v6, v50 + 1);
                int v50 = *(_DWORD *)(a1 + 76);
              }

              *(_DWORD *)(a1 + 76) = v50 + 1;
              uint64_t v53 = operator new(0x20uLL);
              v53[1] = 0LL;
              uint64_t v53[2] = 0LL;
              *uint64_t v53 = off_1018875A8;
              *((_DWORD *)v53 + 6) = 0;
              uint64_t v54 = *(void *)(a1 + 64);
              uint64_t v55 = *(int *)(a1 + 72);
              *(_DWORD *)(a1 + 72) = v55 + 1;
              *(void *)(v54 + 8 * v55) = v53;
            }

            else
            {
              uint64_t v52 = *(void *)(a1 + 64);
              *(_DWORD *)(a1 + 72) = v51 + 1;
              uint64_t v53 = *(void **)(v52 + 8 * v51);
            }

            int v56 = (char *)*((void *)this + 1);
            if ((unint64_t)v56 >= *((void *)this + 2) || *v56 < 0)
            {
              if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v94)) {
                return 0LL;
              }
            }

            else
            {
              unsigned int v94 = *v56;
              *((void *)this + 1) = v56 + 1;
            }

            int v57 = *((_DWORD *)this + 14);
            int v58 = *((_DWORD *)this + 15);
            *((_DWORD *)this + 14) = v57 + 1;
            if (v57 >= v58) {
              return 0LL;
            }
            int v59 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v94);
            wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v59);
            int v61 = *((_DWORD *)this + 14);
            BOOL v19 = __OFSUB__(v61, 1);
            int v62 = v61 - 1;
            if (v62 < 0 == v19) {
              *((_DWORD *)this + 14) = v62;
            }
            uint64_t v21 = (_BYTE *)*((void *)this + 1);
            int v63 = *v21;
            if (v63 != 34)
            {
              if (v63 != 42) {
                goto LABEL_2;
              }
              while (1)
              {
                *((void *)this + 1) = v21 + 1;
LABEL_90:
                int v64 = *(_DWORD *)(a1 + 100);
                uint64_t v65 = *(int *)(a1 + 96);
                if ((int)v65 >= v64)
                {
                  if (v64 == *(_DWORD *)(a1 + 104))
                  {
                    wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v7, v64 + 1);
                    int v64 = *(_DWORD *)(a1 + 100);
                  }

                  *(_DWORD *)(a1 + 100) = v64 + 1;
                  int v67 = operator new(0x20uLL);
                  v67[1] = 0LL;
                  v67[2] = 0LL;
                  *int v67 = off_1018875A8;
                  *((_DWORD *)v67 + 6) = 0;
                  uint64_t v68 = *(void *)(a1 + 88);
                  uint64_t v69 = *(int *)(a1 + 96);
                  *(_DWORD *)(a1 + 96) = v69 + 1;
                  *(void *)(v68 + 8 * v69) = v67;
                }

                else
                {
                  uint64_t v66 = *(void *)(a1 + 88);
                  *(_DWORD *)(a1 + 96) = v65 + 1;
                  int v67 = *(void **)(v66 + 8 * v65);
                }

                int v70 = (char *)*((void *)this + 1);
                if ((unint64_t)v70 >= *((void *)this + 2) || *v70 < 0)
                {
                  if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v94)) {
                    return 0LL;
                  }
                }

                else
                {
                  unsigned int v94 = *v70;
                  *((void *)this + 1) = v70 + 1;
                }

                int v71 = *((_DWORD *)this + 14);
                int v72 = *((_DWORD *)this + 15);
                *((_DWORD *)this + 14) = v71 + 1;
                if (v71 >= v72) {
                  return 0LL;
                }
                int v73 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v94);
                wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v73);
                int v75 = *((_DWORD *)this + 14);
                BOOL v19 = __OFSUB__(v75, 1);
                int v76 = v75 - 1;
                if (v76 < 0 == v19) {
                  *((_DWORD *)this + 14) = v76;
                }
                uint64_t v21 = (_BYTE *)*((void *)this + 1);
                int v77 = *v21;
                if (v77 != 42)
                {
                  if (v77 != 50) {
                    goto LABEL_2;
                  }
                  while (1)
                  {
                    *((void *)this + 1) = v21 + 1;
LABEL_108:
                    int v78 = *(_DWORD *)(a1 + 124);
                    uint64_t v79 = *(int *)(a1 + 120);
                    if ((int)v79 >= v78)
                    {
                      if (v78 == *(_DWORD *)(a1 + 128))
                      {
                        wireless_diagnostics::google::protobuf::internal::RepeatedPtrFieldBase::Reserve(v8, v78 + 1);
                        int v78 = *(_DWORD *)(a1 + 124);
                      }

                      *(_DWORD *)(a1 + 124) = v78 + 1;
                      int v81 = operator new(0x20uLL);
                      v81[1] = 0LL;
                      v81[2] = 0LL;
                      *int v81 = off_1018875A8;
                      *((_DWORD *)v81 + 6) = 0;
                      uint64_t v82 = *(void *)(a1 + 112);
                      uint64_t v83 = *(int *)(a1 + 120);
                      *(_DWORD *)(a1 + 120) = v83 + 1;
                      *(void *)(v82 + 8 * v83) = v81;
                    }

                    else
                    {
                      uint64_t v80 = *(void *)(a1 + 112);
                      *(_DWORD *)(a1 + 120) = v79 + 1;
                      int v81 = *(void **)(v80 + 8 * v79);
                    }

                    int v84 = (char *)*((void *)this + 1);
                    if ((unint64_t)v84 >= *((void *)this + 2) || *v84 < 0)
                    {
                      if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v94)) {
                        return 0LL;
                      }
                    }

                    else
                    {
                      unsigned int v94 = *v84;
                      *((void *)this + 1) = v84 + 1;
                    }

                    int v85 = *((_DWORD *)this + 14);
                    int v86 = *((_DWORD *)this + 15);
                    *((_DWORD *)this + 14) = v85 + 1;
                    if (v85 >= v86) {
                      return 0LL;
                    }
                    int v87 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v94);
                    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v87);
                    int v89 = *((_DWORD *)this + 14);
                    BOOL v19 = __OFSUB__(v89, 1);
                    int v90 = v89 - 1;
                    if (v90 < 0 == v19) {
                      *((_DWORD *)this + 14) = v90;
                    }
                    uint64_t v21 = (_BYTE *)*((void *)this + 1);
                    __int128 v91 = (_BYTE *)*((void *)this + 2);
                    if (v21 >= v91 || *v21 != 50)
                    {
                      if (v21 == v91 && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
                      {
                        *((_DWORD *)this + 8) = 0;
                        uint64_t result = 1LL;
                        *((_BYTE *)this + 36) = 1;
                        return result;
                      }

                      goto LABEL_2;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

uint64_t sub_100E3D3EC( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  if ((*(_BYTE *)(result + 140) & 1) != 0)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (!v6) {
      uint64_t v6 = *(void *)(qword_1019A2108 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v6,  a2,  a4);
  }

  if (*(int *)(v5 + 24) >= 1)
  {
    uint64_t v7 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(void *)(*(void *)(v5 + 16) + 8 * v7++),  a2,  a4);
    while (v7 < *(int *)(v5 + 24));
  }

  if (*(int *)(v5 + 48) >= 1)
  {
    uint64_t v8 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)3,  *(void *)(*(void *)(v5 + 40) + 8 * v8++),  a2,  a4);
    while (v8 < *(int *)(v5 + 48));
  }

  if (*(int *)(v5 + 72) >= 1)
  {
    uint64_t v9 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)4,  *(void *)(*(void *)(v5 + 64) + 8 * v9++),  a2,  a4);
    while (v9 < *(int *)(v5 + 72));
  }

  if (*(int *)(v5 + 96) >= 1)
  {
    uint64_t v10 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)5,  *(void *)(*(void *)(v5 + 88) + 8 * v10++),  a2,  a4);
    while (v10 < *(int *)(v5 + 96));
  }

  if (*(int *)(v5 + 120) >= 1)
  {
    uint64_t v11 = 0LL;
    do
      uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)6,  *(void *)(*(void *)(v5 + 112) + 8 * v11++),  a2,  a4);
    while (v11 < *(int *)(v5 + 120));
  }

  return result;
}

uint64_t sub_100E3D540(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 140) & 1) != 0)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (!v2) {
      uint64_t v2 = *(void *)(qword_1019A2108 + 8);
    }
    int v3 = *(unsigned __int8 *)(v2 + 36);
    int v4 = (v3 << 31 >> 31) & 9;
    if ((v3 & 2) != 0) {
      v4 += 9;
    }
    if ((v3 & 4) != 0) {
      v4 += 9;
    }
    if (*(_BYTE *)(v2 + 36)) {
      int v5 = v4;
    }
    else {
      int v5 = 0;
    }
    *(_DWORD *)(v2 + 32) = v5;
    int v1 = v5 + 2;
  }

  else
  {
    int v1 = 0;
  }

  uint64_t v6 = *(unsigned int *)(a1 + 24);
  int v7 = v6 + v1;
  if ((int)v6 >= 1)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    do
    {
      int v9 = *(unsigned __int8 *)(*(void *)v8 + 24LL);
      if (*(_BYTE *)(*(void *)v8 + 24LL))
      {
        int v10 = (v9 << 31 >> 31) & 5;
        if ((v9 & 2) != 0) {
          v10 += 5;
        }
        if ((v9 & 4) != 0) {
          int v9 = v10 + 5;
        }
        else {
          int v9 = v10;
        }
      }

      *(_DWORD *)(*(void *)v8 + 20LL) = v9;
      v7 += v9 + 1;
      v8 += 8LL;
      --v6;
    }

    while (v6);
  }

  uint64_t v11 = *(unsigned int *)(a1 + 48);
  int v12 = v11 + v7;
  if ((int)v11 >= 1)
  {
    uint64_t v13 = *(void *)(a1 + 40);
    do
    {
      int v14 = *(unsigned __int8 *)(*(void *)v13 + 24LL);
      if (*(_BYTE *)(*(void *)v13 + 24LL))
      {
        int v15 = (v14 << 31 >> 31) & 5;
        if ((v14 & 2) != 0) {
          v15 += 5;
        }
        if ((v14 & 4) != 0) {
          int v14 = v15 + 5;
        }
        else {
          int v14 = v15;
        }
      }

      *(_DWORD *)(*(void *)v13 + 20LL) = v14;
      v12 += v14 + 1;
      v13 += 8LL;
      --v11;
    }

    while (v11);
  }

  uint64_t v16 = *(unsigned int *)(a1 + 72);
  int v17 = v16 + v12;
  if ((int)v16 >= 1)
  {
    uint64_t v18 = *(void *)(a1 + 64);
    do
    {
      int v19 = *(unsigned __int8 *)(*(void *)v18 + 24LL);
      if (*(_BYTE *)(*(void *)v18 + 24LL))
      {
        int v20 = (v19 << 31 >> 31) & 5;
        if ((v19 & 2) != 0) {
          v20 += 5;
        }
        if ((v19 & 4) != 0) {
          int v19 = v20 + 5;
        }
        else {
          int v19 = v20;
        }
      }

      *(_DWORD *)(*(void *)v18 + 20LL) = v19;
      v17 += v19 + 1;
      v18 += 8LL;
      --v16;
    }

    while (v16);
  }

  uint64_t v21 = *(unsigned int *)(a1 + 96);
  int v22 = v21 + v17;
  if ((int)v21 >= 1)
  {
    uint64_t v23 = *(void *)(a1 + 88);
    do
    {
      int v24 = *(unsigned __int8 *)(*(void *)v23 + 24LL);
      if (*(_BYTE *)(*(void *)v23 + 24LL))
      {
        int v25 = (v24 << 31 >> 31) & 5;
        if ((v24 & 2) != 0) {
          v25 += 5;
        }
        if ((v24 & 4) != 0) {
          int v24 = v25 + 5;
        }
        else {
          int v24 = v25;
        }
      }

      *(_DWORD *)(*(void *)v23 + 20LL) = v24;
      v22 += v24 + 1;
      v23 += 8LL;
      --v21;
    }

    while (v21);
  }

  uint64_t v26 = *(unsigned int *)(a1 + 120);
  uint64_t v27 = (v26 + v22);
  if ((int)v26 >= 1)
  {
    uint64_t v28 = *(void *)(a1 + 112);
    do
    {
      int v29 = *(unsigned __int8 *)(*(void *)v28 + 24LL);
      if (*(_BYTE *)(*(void *)v28 + 24LL))
      {
        int v30 = (v29 << 31 >> 31) & 5;
        if ((v29 & 2) != 0) {
          v30 += 5;
        }
        if ((v29 & 4) != 0) {
          int v29 = v30 + 5;
        }
        else {
          int v29 = v30;
        }
      }

      *(_DWORD *)(*(void *)v28 + 20LL) = v29;
      uint64_t v27 = (v27 + v29 + 1);
      v28 += 8LL;
      --v26;
    }

    while (v26);
  }

  *(_DWORD *)(a1 + 136) = v27;
  return v27;
}

double sub_100E3D774(uint64_t a1, void *lpsrc)
{
  return sub_100E3A58C(a1, (uint64_t)lpsrc);
}

uint64_t sub_100E3D7C0()
{
  return 1LL;
}

void *sub_100E3D7C8@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.GnssLeechLocationData");
}

void sub_100E3D7D8(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101887698;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A2118 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100E3D82C(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

_DWORD *sub_100E3D840()
{
  uint64_t result = operator new(0x28uLL);
  result[7] = 0;
  result[8] = 0;
  *((void *)result + 1) = 0LL;
  *((void *)result + 2) = 0LL;
  *(void *)uint64_t result = &off_101887698;
  *((_BYTE *)result + 24) = 0;
  return result;
}

uint64_t sub_100E3D870( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (2)
  {
    uint64_t v5 = (char *)*((void *)this + 1);
    if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
    {
      TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    else
    {
      TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
      *((_DWORD *)this + 8) = (_DWORD)TagFallback;
      *((void *)this + 1) = v5 + 1;
      if (!(_DWORD)TagFallback) {
        return 1LL;
      }
    }

    switch(TagFallback >> 3)
    {
      case 1u:
        int v7 = TagFallback & 7;
        if (v7 != 2) {
          goto LABEL_31;
        }
        *(_DWORD *)(a1 + 32) |= 1u;
        uint64_t v8 = *(char **)(a1 + 8);
        if (!v8)
        {
          uint64_t v8 = (char *)operator new(0x28uLL);
          *(void *)uint64_t v8 = off_1018873C8;
          *(_OWORD *)(v8 + 8) = 0u;
          *(_OWORD *)(v8 + 24) = 0u;
          *(void *)(a1 + 8) = v8;
        }

        int v9 = (char *)*((void *)this + 1);
        if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
        {
          if (!wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback( this,  &v47)) {
            return 0LL;
          }
        }

        else
        {
          unsigned int v47 = *v9;
          *((void *)this + 1) = v9 + 1;
        }

        int v20 = *((_DWORD *)this + 14);
        int v21 = *((_DWORD *)this + 15);
        *((_DWORD *)this + 14) = v20 + 1;
        if (v20 >= v21) {
          return 0LL;
        }
        int v22 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v47);
        wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v22);
        int v24 = *((_DWORD *)this + 14);
        BOOL v25 = __OFSUB__(v24, 1);
        int v26 = v24 - 1;
        if (v26 < 0 == v25) {
          *((_DWORD *)this + 14) = v26;
        }
        uint64_t v27 = (_BYTE *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        uint64_t v11 = v27 + 1;
        *((void *)this + 1) = v11;
        goto LABEL_44;
      case 2u:
        int v7 = TagFallback & 7;
        uint64_t v11 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
LABEL_44:
        if ((unint64_t)v11 >= v10 || *v11 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v47);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v28 = v47;
          int v29 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v28 = *v11;
          int v29 = v11 + 1;
          *((void *)this + 1) = v29;
        }

        *(_BYTE *)(a1 + 16) = v28 != 0;
        *(_DWORD *)(a1 + 32) |= 2u;
        int v12 = v29 + 1;
        *((void *)this + 1) = v12;
LABEL_52:
        if ((unint64_t)v12 >= v10 || *v12 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v47);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v31 = v47;
          unsigned int v32 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v31 = *v12;
          unsigned int v32 = v12 + 1;
          *((void *)this + 1) = v32;
        }

        *(_BYTE *)(a1 + 17) = v31 != 0;
        *(_DWORD *)(a1 + 32) |= 4u;
        uint64_t v13 = v32 + 1;
        *((void *)this + 1) = v13;
LABEL_60:
        if ((unint64_t)v13 >= v10 || *v13 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v47);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v33 = v47;
          int v34 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v33 = *v13;
          int v34 = v13 + 1;
          *((void *)this + 1) = v34;
        }

        *(_BYTE *)(a1 + 18) = v33 != 0;
        *(_DWORD *)(a1 + 32) |= 8u;
        int v14 = v34 + 1;
        *((void *)this + 1) = v14;
LABEL_68:
        if ((unint64_t)v14 >= v10 || *v14 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v47);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v35 = v47;
          int v36 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v35 = *v14;
          int v36 = v14 + 1;
          *((void *)this + 1) = v36;
        }

        *(_BYTE *)(a1 + 19) = v35 != 0;
        *(_DWORD *)(a1 + 32) |= 0x10u;
        int v15 = v36 + 1;
        *((void *)this + 1) = v15;
LABEL_76:
        if ((unint64_t)v15 >= v10 || *v15 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v47);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v37 = v47;
          uint64_t v38 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v37 = *v15;
          uint64_t v38 = v15 + 1;
          *((void *)this + 1) = v38;
        }

        *(_BYTE *)(a1 + 20) = v37 != 0;
        *(_DWORD *)(a1 + 32) |= 0x20u;
        uint64_t v16 = v38 + 1;
        *((void *)this + 1) = v16;
LABEL_84:
        if ((unint64_t)v16 >= v10 || *v16 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v47);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v39 = v47;
          uint64_t v40 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v39 = *v16;
          uint64_t v40 = v16 + 1;
          *((void *)this + 1) = v40;
        }

        *(_BYTE *)(a1 + 21) = v39 != 0;
        *(_DWORD *)(a1 + 32) |= 0x40u;
        int v17 = v40 + 1;
        *((void *)this + 1) = v17;
LABEL_92:
        if ((unint64_t)v17 >= v10 || *v17 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v47);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v41 = v47;
          uint64_t v42 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v41 = *v17;
          uint64_t v42 = v17 + 1;
          *((void *)this + 1) = v42;
        }

        *(_BYTE *)(a1 + 22) = v41 != 0;
        *(_DWORD *)(a1 + 32) |= 0x80u;
        uint64_t v18 = v42 + 1;
        *((void *)this + 1) = v18;
LABEL_100:
        if ((unint64_t)v18 >= v10 || *v18 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v47);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v43 = v47;
          int v44 = (_BYTE *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v43 = *v18;
          int v44 = v18 + 1;
          *((void *)this + 1) = v44;
        }

        *(_BYTE *)(a1 + 23) = v43 != 0;
        *(_DWORD *)(a1 + 32) |= 0x100u;
        int v19 = v44 + 1;
        *((void *)this + 1) = v19;
LABEL_108:
        if ((unint64_t)v19 >= v10 || *v19 < 0)
        {
          uint64_t result = wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadVarint32Fallback(this, &v47);
          if (!(_DWORD)result) {
            return result;
          }
          unsigned int v45 = v47;
          unsigned int v46 = (unsigned __int8 *)*((void *)this + 1);
          unint64_t v10 = *((void *)this + 2);
        }

        else
        {
          unsigned int v45 = *v19;
          unsigned int v46 = (unsigned __int8 *)(v19 + 1);
          *((void *)this + 1) = v46;
        }

        *(_BYTE *)(a1 + 24) = v45 != 0;
        *(_DWORD *)(a1 + 32) |= 0x200u;
        *((_DWORD *)this + 8) = 0;
        uint64_t result = 1LL;
        *((_BYTE *)this + 36) = 1;
        break;
      case 3u:
        int v7 = TagFallback & 7;
        int v12 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_52;
      case 4u:
        int v7 = TagFallback & 7;
        uint64_t v13 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_60;
      case 5u:
        int v7 = TagFallback & 7;
        int v14 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_68;
      case 6u:
        int v7 = TagFallback & 7;
        int v15 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_76;
      case 7u:
        int v7 = TagFallback & 7;
        uint64_t v16 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_84;
      case 8u:
        int v7 = TagFallback & 7;
        int v17 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_92;
      case 9u:
        int v7 = TagFallback & 7;
        uint64_t v18 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_100;
      case 0xAu:
        int v7 = TagFallback & 7;
        int v19 = (char *)*((void *)this + 1);
        unint64_t v10 = *((void *)this + 2);
        goto LABEL_108;
      default:
        int v7 = TagFallback & 7;
LABEL_31:
        if (v7 == 4) {
          return 1LL;
        }
        return 0LL;
    }

    return result;
  }

uint64_t sub_100E3DEA4( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 32);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A2118 + 8);
    }
    uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
    int v6 = *(_DWORD *)(v5 + 32);
    if ((v6 & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_16;
    }
  }

  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteBool( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(unsigned __int8 *)(v5 + 16),  (BOOL)a2,  a4);
  int v6 = *(_DWORD *)(v5 + 32);
  if ((v6 & 4) == 0)
  {
LABEL_4:
    if ((v6 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_17;
  }

uint64_t sub_100E3DFF0(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 32);
  if ((_BYTE)v1)
  {
    if ((v1 & 1) != 0)
    {
      uint64_t v3 = *(void *)(a1 + 8);
      if (!v3) {
        uint64_t v3 = *(void *)(qword_1019A2118 + 8);
      }
      int v4 = *(unsigned __int8 *)(v3 + 36);
      if (*(_BYTE *)(v3 + 36))
      {
        int v5 = (v4 << 31 >> 31) & 9;
        if ((v4 & 2) != 0) {
          v5 += 9;
        }
        if ((v4 & 4) != 0) {
          int v4 = v5 + 9;
        }
        else {
          int v4 = v5;
        }
      }

      *(_DWORD *)(v3 + 32) = v4;
      unsigned int v2 = v4 + 2;
      int v1 = *(_DWORD *)(a1 + 32);
    }

    else
    {
      unsigned int v2 = 0;
    }

    if ((v1 & 2) != 0) {
      v2 += 2;
    }
    if ((v1 & 4) != 0) {
      v2 += 2;
    }
    if ((v1 & 8) != 0) {
      v2 += 2;
    }
    if ((v1 & 0x10) != 0) {
      v2 += 2;
    }
    if ((v1 & 0x20) != 0) {
      v2 += 2;
    }
    if ((v1 & 0x40) != 0) {
      v2 += 2;
    }
    if ((v1 & 0x80) != 0) {
      v2 += 2;
    }
  }

  else
  {
    unsigned int v2 = 0;
  }

  unsigned int v6 = v2 + 2;
  if ((v1 & 0x100) == 0) {
    unsigned int v6 = v2;
  }
  if ((v1 & 0x200) != 0) {
    v6 += 2;
  }
  if ((v1 & 0xFF00) != 0) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = v2;
  }
  *(_DWORD *)(a1 + 28) = v7;
  return v7;
}

void sub_100E3E0DC(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100E3E128()
{
  return 1LL;
}

void *sub_100E3E130@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.MapsRouteHintData");
}

void sub_100E3E140(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101887710;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A2120 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100E3E194(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100E3E1A8()
{
  uint64_t result = operator new(0x20uLL);
  result[1] = 0LL;
  result[2] = 0LL;
  *uint64_t result = &off_101887710;
  *((_DWORD *)result + 6) = 0;
  return result;
}

uint64_t sub_100E3E1D4( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      if (TagFallback >> 3 == 2)
      {
        int v7 = TagFallback & 7;
        if ((TagFallback & 7) == 0)
        {
          int v9 = (char *)*((void *)this + 1);
          unint64_t v8 = *((void *)this + 2);
          goto LABEL_29;
        }
      }

      else
      {
        int v7 = TagFallback & 7;
      }

uint64_t sub_100E3E410( uint64_t result, const wireless_diagnostics::google::protobuf::MessageLite *a2, uint64_t a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 24);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  (int)a2,  a4);
  }

  uint64_t v7 = *(void *)(result + 8);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_1019A2120 + 8);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
  if ((*(_DWORD *)(v5 + 24) & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteEnum( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  *(_DWORD *)(v5 + 16),  (int)a2,  a4);
  }
  return result;
}

uint64_t sub_100E3E47C(uint64_t a1, unsigned int a2)
{
  if (!*(_BYTE *)(a1 + 24))
  {
    uint64_t v3 = 0LL;
    goto LABEL_21;
  }

  if ((*(_BYTE *)(a1 + 24) & 1) == 0)
  {
    uint64_t v3 = 0LL;
    if ((*(_BYTE *)(a1 + 24) & 2) == 0) {
      goto LABEL_21;
    }
    goto LABEL_15;
  }

  uint64_t v4 = *(void *)(a1 + 8);
  if (!v4) {
    uint64_t v4 = *(void *)(qword_1019A2120 + 8);
  }
  int v5 = *(unsigned __int8 *)(v4 + 36);
  if (*(_BYTE *)(v4 + 36))
  {
    int v6 = (v5 << 31 >> 31) & 9;
    if ((v5 & 2) != 0) {
      v6 += 9;
    }
    if ((v5 & 4) != 0) {
      int v5 = v6 + 9;
    }
    else {
      int v5 = v6;
    }
  }

  *(_DWORD *)(v4 + 32) = v5;
  uint64_t v3 = (v5 + 2);
  if ((*(_DWORD *)(a1 + 24) & 2) != 0)
  {
LABEL_15:
    uint64_t v7 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 16);
    if ((v7 & 0x80000000) != 0)
    {
      int v8 = 11;
    }

    else if (v7 >= 0x80)
    {
      int v8 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v7, a2) + 1;
    }

    else
    {
      int v8 = 2;
    }

    uint64_t v3 = (v8 + v3);
  }

void sub_100E3E53C(uint64_t a1, void *lpsrc)
{
}

uint64_t sub_100E3E588()
{
  return 1LL;
}

void *sub_100E3E590@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.MotionActivityType");
}

void sub_100E3E5A0(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101887788;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A2128 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100E3E5F4(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100E3E608()
{
  uint64_t result = operator new(0x20uLL);
  *uint64_t result = &off_101887788;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  return result;
}

uint64_t sub_100E3E630( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      if (TagFallback >> 3 != 2)
      {
        int v7 = TagFallback & 7;
        goto LABEL_17;
      }

      int v7 = TagFallback & 7;
      if (v7 == 1)
      {
LABEL_29:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v19) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 16) = v19;
        *(_DWORD *)(a1 + 28) |= 2u;
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }

      else
      {
LABEL_17:
        if (v7 == 4) {
          return 1LL;
        }
      }
    }

    int v7 = TagFallback & 7;
    if (v7 != 2) {
      goto LABEL_17;
    }
    *(_DWORD *)(a1 + 28) |= 1u;
    int v8 = *(char **)(a1 + 8);
    if (!v8)
    {
      int v8 = (char *)operator new(0x28uLL);
      *(void *)int v8 = off_1018873C8;
      *(_OWORD *)(v8 + 8) = 0u;
      *(_OWORD *)(v8 + 24) = 0u;
      *(void *)(a1 + 8) = v8;
    }

    int v9 = (char *)*((void *)this + 1);
    if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
    {
    }

    else
    {
      unsigned int v20 = *v9;
      *((void *)this + 1) = v9 + 1;
    }

    int v10 = *((_DWORD *)this + 14);
    int v11 = *((_DWORD *)this + 15);
    *((_DWORD *)this + 14) = v10 + 1;
    if (v10 >= v11) {
      return 0LL;
    }
    int v12 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v20);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v12);
    int v14 = *((_DWORD *)this + 14);
    BOOL v15 = __OFSUB__(v14, 1);
    int v16 = v14 - 1;
    if (v16 < 0 == v15) {
      *((_DWORD *)this + 14) = v16;
    }
    BOOL v17 = (_BYTE *)*((void *)this + 1);
    if ((unint64_t)v17 < *((void *)this + 2) && *v17 == 17)
    {
      *((void *)this + 1) = v17 + 1;
      goto LABEL_29;
    }
  }

uint64_t sub_100E3E844( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 28);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  (int)a2,  *(double *)(v5 + 16),  a3);
  }

  uint64_t v7 = *(void *)(result + 8);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_1019A2128 + 8);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
  if ((*(_DWORD *)(v5 + 28) & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  (int)a2,  *(double *)(v5 + 16),  a3);
  }
  return result;
}

uint64_t sub_100E3E8B0(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 28);
  if (*(_BYTE *)(a1 + 28))
  {
    if ((v1 & 1) != 0)
    {
      uint64_t v1 = *(void *)(a1 + 8);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_1019A2128 + 8);
      }
      int v3 = *(unsigned __int8 *)(v1 + 36);
      if (*(_BYTE *)(v1 + 36))
      {
        int v4 = (v3 << 31 >> 31) & 9;
        if ((v3 & 2) != 0) {
          v4 += 9;
        }
        if ((v3 & 4) != 0) {
          int v3 = v4 + 9;
        }
        else {
          int v3 = v4;
        }
      }

      *(_DWORD *)(v1 + 32) = v3;
      unsigned int v2 = v3 + 2;
      LODWORD(v1) = *(_DWORD *)(a1 + 28);
    }

    else
    {
      unsigned int v2 = 0;
    }

    if ((v1 & 2) != 0) {
      uint64_t v1 = v2 + 9;
    }
    else {
      uint64_t v1 = v2;
    }
  }

  *(_DWORD *)(a1 + 24) = v1;
  return v1;
}

double sub_100E3E928(uint64_t a1, void *lpsrc)
{
  return sub_100E3AD28(a1, (uint64_t)lpsrc);
}

uint64_t sub_100E3E974()
{
  return 1LL;
}

void *sub_100E3E97C@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.CMGpsModelOutput");
}

void sub_100E3E98C(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101887800;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A2130 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100E3E9E0(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100E3E9F4()
{
  uint64_t result = operator new(0x20uLL);
  *uint64_t result = &off_101887800;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  return result;
}

uint64_t sub_100E3EA1C( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      if (TagFallback >> 3 != 2)
      {
        int v7 = TagFallback & 7;
        goto LABEL_17;
      }

      int v7 = TagFallback & 7;
      if (v7 == 1)
      {
LABEL_29:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v19) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 16) = v19;
        *(_DWORD *)(a1 + 28) |= 2u;
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }

      else
      {
LABEL_17:
        if (v7 == 4) {
          return 1LL;
        }
      }
    }

    int v7 = TagFallback & 7;
    if (v7 != 2) {
      goto LABEL_17;
    }
    *(_DWORD *)(a1 + 28) |= 1u;
    int v8 = *(char **)(a1 + 8);
    if (!v8)
    {
      int v8 = (char *)operator new(0x28uLL);
      *(void *)int v8 = off_1018873C8;
      *(_OWORD *)(v8 + 8) = 0u;
      *(_OWORD *)(v8 + 24) = 0u;
      *(void *)(a1 + 8) = v8;
    }

    int v9 = (char *)*((void *)this + 1);
    if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
    {
    }

    else
    {
      unsigned int v20 = *v9;
      *((void *)this + 1) = v9 + 1;
    }

    int v10 = *((_DWORD *)this + 14);
    int v11 = *((_DWORD *)this + 15);
    *((_DWORD *)this + 14) = v10 + 1;
    if (v10 >= v11) {
      return 0LL;
    }
    int v12 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v20);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v12);
    int v14 = *((_DWORD *)this + 14);
    BOOL v15 = __OFSUB__(v14, 1);
    int v16 = v14 - 1;
    if (v16 < 0 == v15) {
      *((_DWORD *)this + 14) = v16;
    }
    BOOL v17 = (_BYTE *)*((void *)this + 1);
    if ((unint64_t)v17 < *((void *)this + 2) && *v17 == 17)
    {
      *((void *)this + 1) = v17 + 1;
      goto LABEL_29;
    }
  }

uint64_t sub_100E3EC30( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 28);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  (int)a2,  *(double *)(v5 + 16),  a3);
  }

  uint64_t v7 = *(void *)(result + 8);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_1019A2130 + 8);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
  if ((*(_DWORD *)(v5 + 28) & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  (int)a2,  *(double *)(v5 + 16),  a3);
  }
  return result;
}

uint64_t sub_100E3EC9C(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 28);
  if (*(_BYTE *)(a1 + 28))
  {
    if ((v1 & 1) != 0)
    {
      uint64_t v1 = *(void *)(a1 + 8);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_1019A2130 + 8);
      }
      int v3 = *(unsigned __int8 *)(v1 + 36);
      if (*(_BYTE *)(v1 + 36))
      {
        int v4 = (v3 << 31 >> 31) & 9;
        if ((v3 & 2) != 0) {
          v4 += 9;
        }
        if ((v3 & 4) != 0) {
          int v3 = v4 + 9;
        }
        else {
          int v3 = v4;
        }
      }

      *(_DWORD *)(v1 + 32) = v3;
      unsigned int v2 = v3 + 2;
      LODWORD(v1) = *(_DWORD *)(a1 + 28);
    }

    else
    {
      unsigned int v2 = 0;
    }

    if ((v1 & 2) != 0) {
      uint64_t v1 = v2 + 9;
    }
    else {
      uint64_t v1 = v2;
    }
  }

  *(_DWORD *)(a1 + 24) = v1;
  return v1;
}

double sub_100E3ED14(uint64_t a1, void *lpsrc)
{
  return sub_100E3AE24(a1, (uint64_t)lpsrc);
}

uint64_t sub_100E3ED60()
{
  return 1LL;
}

void *sub_100E3ED68@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.CMWiFiModelOutput");
}

void sub_100E3ED78(wireless_diagnostics::google::protobuf::MessageLite *this)
{
  *(void *)this = &off_101887878;
  if ((wireless_diagnostics::google::protobuf::MessageLite *)qword_1019A2138 != this)
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    }
  }

  wireless_diagnostics::google::protobuf::MessageLite::~MessageLite(this);
}

void sub_100E3EDCC(wireless_diagnostics::google::protobuf::MessageLite *a1)
{
}

void *sub_100E3EDE0()
{
  uint64_t result = operator new(0x20uLL);
  *uint64_t result = &off_101887878;
  result[1] = 0LL;
  result[2] = 0LL;
  result[3] = 0LL;
  return result;
}

uint64_t sub_100E3EE08( uint64_t a1, wireless_diagnostics::google::protobuf::internal::WireFormatLite *this, unsigned int a3)
{
  while (1)
  {
    while (1)
    {
      uint64_t v5 = (char *)*((void *)this + 1);
      if ((unint64_t)v5 >= *((void *)this + 2) || *v5 < 0)
      {
        TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadTagFallback(this);
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      else
      {
        TagFallbacuint64_t k = (wireless_diagnostics::google::protobuf::io::CodedInputStream *)*v5;
        *((_DWORD *)this + 8) = (_DWORD)TagFallback;
        *((void *)this + 1) = v5 + 1;
        if (!(_DWORD)TagFallback) {
          return 1LL;
        }
      }

      if (TagFallback >> 3 != 2)
      {
        int v7 = TagFallback & 7;
        goto LABEL_17;
      }

      int v7 = TagFallback & 7;
      if (v7 == 1)
      {
LABEL_29:
        if ((wireless_diagnostics::google::protobuf::io::CodedInputStream::ReadLittleEndian64Fallback(this, &v19) & 1) == 0) {
          return 0LL;
        }
        *(void *)(a1 + 16) = v19;
        *(_DWORD *)(a1 + 28) |= 2u;
        if (*((void *)this + 1) == *((void *)this + 2)
          && (*((_DWORD *)this + 11) || *((_DWORD *)this + 6) == *((_DWORD *)this + 10)))
        {
          *((_DWORD *)this + 8) = 0;
          uint64_t result = 1LL;
          *((_BYTE *)this + 36) = 1;
          return result;
        }
      }

      else
      {
LABEL_17:
        if (v7 == 4) {
          return 1LL;
        }
      }
    }

    int v7 = TagFallback & 7;
    if (v7 != 2) {
      goto LABEL_17;
    }
    *(_DWORD *)(a1 + 28) |= 1u;
    int v8 = *(char **)(a1 + 8);
    if (!v8)
    {
      int v8 = (char *)operator new(0x28uLL);
      *(void *)int v8 = off_1018873C8;
      *(_OWORD *)(v8 + 8) = 0u;
      *(_OWORD *)(v8 + 24) = 0u;
      *(void *)(a1 + 8) = v8;
    }

    int v9 = (char *)*((void *)this + 1);
    if ((unint64_t)v9 >= *((void *)this + 2) || *v9 < 0)
    {
    }

    else
    {
      unsigned int v20 = *v9;
      *((void *)this + 1) = v9 + 1;
    }

    int v10 = *((_DWORD *)this + 14);
    int v11 = *((_DWORD *)this + 15);
    *((_DWORD *)this + 14) = v10 + 1;
    if (v10 >= v11) {
      return 0LL;
    }
    int v12 = wireless_diagnostics::google::protobuf::io::CodedInputStream::PushLimit(this, v20);
    wireless_diagnostics::google::protobuf::io::CodedInputStream::PopLimit(this, v12);
    int v14 = *((_DWORD *)this + 14);
    BOOL v15 = __OFSUB__(v14, 1);
    int v16 = v14 - 1;
    if (v16 < 0 == v15) {
      *((_DWORD *)this + 14) = v16;
    }
    BOOL v17 = (_BYTE *)*((void *)this + 1);
    if ((unint64_t)v17 < *((void *)this + 2) && *v17 == 17)
    {
      *((void *)this + 1) = v17 + 1;
      goto LABEL_29;
    }
  }

uint64_t sub_100E3F01C( uint64_t result, wireless_diagnostics::google::protobuf::MessageLite *a2, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a3, wireless_diagnostics::google::protobuf::io::CodedOutputStream *a4)
{
  uint64_t v5 = result;
  int v6 = *(_DWORD *)(result + 28);
  if ((v6 & 1) == 0)
  {
    if ((v6 & 2) == 0) {
      return result;
    }
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  (int)a2,  *(double *)(v5 + 16),  a3);
  }

  uint64_t v7 = *(void *)(result + 8);
  if (!v7) {
    uint64_t v7 = *(void *)(qword_1019A2138 + 8);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)1,  v7,  a2,  a4);
  if ((*(_DWORD *)(v5 + 28) & 2) != 0) {
    return wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)2,  (int)a2,  *(double *)(v5 + 16),  a3);
  }
  return result;
}

uint64_t sub_100E3F088(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 28);
  if (*(_BYTE *)(a1 + 28))
  {
    if ((v1 & 1) != 0)
    {
      uint64_t v1 = *(void *)(a1 + 8);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_1019A2138 + 8);
      }
      int v3 = *(unsigned __int8 *)(v1 + 36);
      if (*(_BYTE *)(v1 + 36))
      {
        int v4 = (v3 << 31 >> 31) & 9;
        if ((v3 & 2) != 0) {
          v4 += 9;
        }
        if ((v3 & 4) != 0) {
          int v3 = v4 + 9;
        }
        else {
          int v3 = v4;
        }
      }

      *(_DWORD *)(v1 + 32) = v3;
      unsigned int v2 = v3 + 2;
      LODWORD(v1) = *(_DWORD *)(a1 + 28);
    }

    else
    {
      unsigned int v2 = 0;
    }

    if ((v1 & 2) != 0) {
      uint64_t v1 = v2 + 9;
    }
    else {
      uint64_t v1 = v2;
    }
  }

  *(_DWORD *)(a1 + 24) = v1;
  return v1;
}

double sub_100E3F100(uint64_t a1, void *lpsrc)
{
  return sub_100E3AF20(a1, (uint64_t)lpsrc);
}

uint64_t sub_100E3F14C()
{
  return 1LL;
}

void *sub_100E3F154@<X0>(void *a1@<X8>)
{
  return sub_1010DDBC0(a1, "CLP.LogEntry.OutdoorEstimator.CMALSModelOutput");
}

uint64_t sub_100E3F164(uint64_t a1)
{
  return *(unsigned int *)(a1 + 136);
}

uint64_t sub_100E3F170(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100CE83B0();
  sub_1009A22F4(v4 + 496, a2);
  sub_1009AA7B0(a1 + 984, a2);
  sub_100FCCC3C(a1 + 1320, a2);
  return a1;
}

void sub_100E3F1CC(_Unwind_Exception *a1)
{
}

uint64_t sub_100E3F204(void *a1, uint64_t a2)
{
  return sub_1001B3964(a1, a2, 0LL);
}

uint64_t sub_100E3F210(uint64_t a1, uint64_t a2)
{
  return sub_1001B3964((void *)(a1 + 496), a2, 0LL);
}

uint64_t sub_100E3F21C(uint64_t a1, const unsigned __int8 *a2)
{
  return sub_1009A2490(a1 + 496, a2);
}

uint64_t sub_100E3F224(uint64_t a1, char **a2)
{
  return 100LL;
}

uint64_t sub_100E3F268(uint64_t a1, char **a2, double a3, double a4)
{
  return sub_1009A2B3C(a1 + 496, a2, a3, a4);
}

uint64_t sub_100E3F274(uint64_t a1, uint64_t *a2, double a3)
{
  else {
    return 109LL;
  }
}

uint64_t sub_100E3F2D0(uint64_t *a1)
{
  if (qword_1019346E0 != -1) {
    dispatch_once(&qword_1019346E0, &stru_101887A00);
  }
  uint64_t v2 = (os_log_s *)qword_1019346E8;
  if (os_log_type_enabled((os_log_t)qword_1019346E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Beginning aggregation for VO2Max staging data",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346E0 != -1) {
      dispatch_once(&qword_1019346E0, &stru_101887A00);
    }
    v6[0] = 0;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346E8,  0LL,  "Beginning aggregation for VO2Max staging data",  v6,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLVO2MaxStagingOutputStore::aggregateRecords()", "%s\n", v5);
  }

  unsigned __int8 v3 = atomic_load((unsigned __int8 *)&qword_10199EC60);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_10199EC60))
  {
    uint64_t v8 = 0LL;
    *(_OWORD *)__int128 buf = xmmword_101362018;
    sub_100D58C88(qword_10199EC48, buf, 1uLL);
    __cxa_atexit((void (*)(void *))sub_100D58D10, qword_10199EC48, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199EC60);
  }

  sub_100CE83EC(a1, (uint64_t)qword_10199EC48);
  sub_1009A2350(a1 + 62, (uint64_t)qword_10199EC48);
  return sub_1009AA858(a1 + 123, (uint64_t)qword_10199EC48);
}

void sub_100E3F504(_Unwind_Exception *a1)
{
}

uint64_t sub_100E3F524(void *a1)
{
  return sub_100D8BAC8(a1 + 132);
}

uint64_t sub_100E3F554(uint64_t a1, uint64_t a2)
{
  return sub_1001B3964((void *)(a1 + 984), a2, 0LL);
}

uint64_t sub_100E3F560(uint64_t a1, const unsigned __int8 *a2)
{
  return sub_1009AAC58(a1 + 984, a2);
}

uint64_t sub_100E3F568(uint64_t a1, char **a2)
{
  return 100LL;
}

void sub_100E3F5AC(id a1)
{
  qword_1019346E8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "VO2Max");
}

uint64_t sub_100E3F5D8(unsigned __int16 *a1, uint64_t a2, float a3)
{
  if (*(_BYTE *)(a2 + 40))
  {
    float v4 = -999.0;
  }

  else
  {
    double v5 = *(double *)(a2 + 8);
    double v6 = -999.0;
    if (v5 != -999.0)
    {
      double v7 = *(double *)(a2 + 16);
      double v8 = v7 - v5;
      if (v7 == -999.0) {
        double v6 = -999.0;
      }
      else {
        double v6 = v8;
      }
    }

    float v4 = v6;
  }

  uint64_t v9 = a1[1];
  unint64_t v10 = *((unsigned int *)a1 + 1);
  uint64_t v11 = *a1;
  if (v11 + v9 >= v10) {
    uint64_t v12 = *((unsigned int *)a1 + 1);
  }
  else {
    uint64_t v12 = 0LL;
  }
  *(float *)&a1[2 * (v11 + v9 - v12) + 4] = v4;
  if (v10 <= v9)
  {
    unint64_t v13 = v11 + 1;
    if (v13 >= v10) {
      __int16 v14 = v10;
    }
    else {
      __int16 v14 = 0;
    }
    *a1 = v13 - v14;
  }

  else
  {
    LOWORD(v9) = v9 + 1;
    a1[1] = v9;
  }

  int v16 = a1 + 124;
  uint64_t v15 = a1[124];
  uint64_t v17 = a1[125];
  unint64_t v18 = *((unsigned int *)a1 + 63);
  if (v15 + v17 >= v18) {
    uint64_t v19 = *((unsigned int *)a1 + 63);
  }
  else {
    uint64_t v19 = 0LL;
  }
  *(float *)&v16[2 * (v15 + v17 - v19) + 4] = a3;
  if (v18 <= v17)
  {
    unint64_t v20 = v15 + 1;
    if (v20 < v18) {
      LOWORD(v18) = 0;
    }
    *int v16 = v20 - v18;
  }

  else
  {
    LOWORD(v17) = v17 + 1;
    a1[125] = v17;
  }

  float v21 = 0.0;
  if ((_WORD)v17)
  {
    unint64_t v22 = 0LL;
    unint64_t v23 = 0LL;
    float v24 = 0.0;
    do
    {
      if (*(float *)sub_100208A44(a1, v22) != -999.0)
      {
        float v24 = v24 + *(float *)sub_100208A44(a1, v22);
        ++v23;
      }

      ++v22;
    }

    while (v22 < a1[125]);
    LOWORD(v9) = a1[1];
  }

  else
  {
    unint64_t v23 = 0LL;
    float v24 = 0.0;
  }

  float v26 = (float)v23 / (float)(unsigned __int16)v9;
  float v27 = sub_100508094(a1 + 124, (unsigned int (*)(float, float))sub_10095A150, 0LL);
  float v28 = v27 - sub_100508094(a1 + 124, (unsigned int (*)(float, float))sub_100508290, 0LL);
  if (!v23
    || ((float v21 = v24 / (float)v23, v26 > 0.75) ? (v29 = v21 < -20.0) : (v29 = 0),
        v29 ? (BOOL v30 = v28 <= 180.0) : (BOOL v30 = 1),
        v30))
  {
    uint64_t v25 = 0LL;
  }

  else
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101887A20);
    }
    unsigned int v31 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134349312;
      double v44 = v28;
      __int16 v45 = 2050;
      double v46 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "HRHBS StopDetected,%{public}f,%{public}f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101887A20);
      }
      int v37 = 134349312;
      double v38 = v28;
      __int16 v39 = 2050;
      double v40 = v21;
      unsigned int v35 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "HRHBS StopDetected,%{public}f,%{public}f",  &v37,  22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLExerciseMachineHeadingHRBackstop::update(float, const CLWorkoutStopModelHR::Statistics &, int)",  "%s\n",  v35);
    }

    uint64_t v25 = 1LL;
  }

  if (qword_101934680 != -1) {
    dispatch_once(&qword_101934680, &stru_101887A20);
  }
  unsigned int v32 = (os_log_s *)qword_101934688;
  if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 134218496;
    double v44 = v26;
    __int16 v45 = 2048;
    double v46 = v21;
    __int16 v47 = 2048;
    double v48 = v28;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "HRHBS,good,%f,eDiff,%f,degree,%f", buf, 0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101887A20);
    }
    int v37 = 134218496;
    double v38 = v26;
    __int16 v39 = 2048;
    double v40 = v21;
    __int16 v41 = 2048;
    double v42 = v28;
    LODWORD(v36) = 32;
    int v34 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  1LL,  "HRHBS,good,%f,eDiff,%f,degree,%f",  COERCE_DOUBLE(&v37),  v36);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLExerciseMachineHeadingHRBackstop::update(float, const CLWorkoutStopModelHR::Statistics &, int)",  "%s\n",  v34);
  }

  return v25;
}

void sub_100E3FB10(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

id *sub_100E3FBC8(uint64_t a1, uint64_t a2)
{
  if (byte_10199EC7F < 0)
  {
    sub_1010DD48C(__p, (void *)xmmword_10199EC68, *((unint64_t *)&xmmword_10199EC68 + 1));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = xmmword_10199EC68;
    uint64_t v24 = unk_10199EC78;
  }

  int v25 = dword_10199EC80;
  char v4 = sub_100E42A20(a1, (uint64_t)v26, (uint64_t *)__p);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  if (v27 < 0)
  {
    operator delete(v26[0]);
    if ((v4 & 1) == 0) {
      return sub_1001BA1BC(v28);
    }
  }

  else if ((v4 & 1) == 0)
  {
    return sub_1001BA1BC(v28);
  }

  if (*(void *)a2 == *(void *)(a2 + 8))
  {
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    double v5 = (os_log_s *)qword_1019347C8;
    if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_INFO))
    {
      if (byte_10199EC7F >= 0) {
        double v6 = &xmmword_10199EC68;
      }
      else {
        double v6 = (__int128 *)xmmword_10199EC68;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "[subscription-%{public}s] data buffer is empty",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 2)) {
      return sub_1001BA1BC(v28);
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    if (byte_10199EC7F >= 0) {
      double v7 = &xmmword_10199EC68;
    }
    else {
      double v7 = (__int128 *)xmmword_10199EC68;
    }
    int v29 = 136446210;
    BOOL v30 = v7;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347C8,  1LL,  "[subscription-%{public}s] data buffer is empty",  &v29,  12);
    uint64_t v9 = (char *)v8;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLBatchedSensorSubscription::onBatchedAccelerometerData(const CLBatchedAccelerometerClient::Buffer &)",  "%s\n",  v8);
LABEL_49:
    if (v9 != buf) {
      free(v9);
    }
    return sub_1001BA1BC(v28);
  }

  if (byte_10199EC7F < 0)
  {
    sub_1010DD48C(__dst, (void *)xmmword_10199EC68, *((unint64_t *)&xmmword_10199EC68 + 1));
  }

  else
  {
    *(_OWORD *)std::string __dst = xmmword_10199EC68;
    uint64_t v21 = unk_10199EC78;
  }

  int v22 = dword_10199EC80;
  xpc_object_t v10 = sub_100E42CCC((__int128 **)a2, (uint64_t *)__dst);
  uint64_t v11 = v10;
  if (SHIBYTE(v21) < 0)
  {
    operator delete(__dst[0]);
    if (v11) {
      goto LABEL_30;
    }
  }

  else if (v10)
  {
LABEL_30:
    sub_1010DDBC0(v18, "kCLConnectionMessageBatchedAccelerometer");
    xpc_object_t v12 = sub_100E42F48((const char *)v18, v11);
    if (v19 < 0) {
      operator delete(v18[0]);
    }
    *(void *)__int128 buf = v12;
    sub_100E42FE4(a1, buf);
    xpc_release(v11);
    xpc_release(*(xpc_object_t *)buf);
    return sub_1001BA1BC(v28);
  }

  if (qword_1019347C0 != -1) {
    dispatch_once(&qword_1019347C0, &stru_101887AD0);
  }
  unint64_t v13 = (os_log_s *)qword_1019347C8;
  if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_ERROR))
  {
    if (byte_10199EC7F >= 0) {
      __int16 v14 = &xmmword_10199EC68;
    }
    else {
      __int16 v14 = (__int128 *)xmmword_10199EC68;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "[subscription-%{public}s] could not create payload",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    if (byte_10199EC7F >= 0) {
      int v16 = &xmmword_10199EC68;
    }
    else {
      int v16 = (__int128 *)xmmword_10199EC68;
    }
    int v29 = 136446210;
    BOOL v30 = v16;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347C8,  16LL,  "[subscription-%{public}s] could not create payload",  &v29,  12);
    uint64_t v9 = (char *)v17;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLBatchedSensorSubscription::onBatchedAccelerometerData(const CLBatchedAccelerometerClient::Buffer &)",  "%s\n",  v17);
    goto LABEL_49;
  }

  return sub_1001BA1BC(v28);
}

void sub_100E40060( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, int a35, __int16 a36, char a37, char a38, id a39)
{
}

id *sub_100E40118(uint64_t a1, uint64_t a2)
{
  if (byte_10199EC9F < 0)
  {
    sub_1010DD48C(__p, (void *)xmmword_10199EC88, *((unint64_t *)&xmmword_10199EC88 + 1));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = xmmword_10199EC88;
    uint64_t v24 = unk_10199EC98;
  }

  int v25 = dword_10199ECA0;
  char v4 = sub_100E42A20(a1, (uint64_t)v26, (uint64_t *)__p);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  if (v27 < 0)
  {
    operator delete(v26[0]);
    if ((v4 & 1) == 0) {
      return sub_1001BA1BC(v28);
    }
  }

  else if ((v4 & 1) == 0)
  {
    return sub_1001BA1BC(v28);
  }

  if (*(void *)a2 == *(void *)(a2 + 8))
  {
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    double v5 = (os_log_s *)qword_1019347C8;
    if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_INFO))
    {
      if (byte_10199EC9F >= 0) {
        double v6 = &xmmword_10199EC88;
      }
      else {
        double v6 = (__int128 *)xmmword_10199EC88;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "[subscription-%{public}s] data buffer is empty",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 2)) {
      return sub_1001BA1BC(v28);
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    if (byte_10199EC9F >= 0) {
      double v7 = &xmmword_10199EC88;
    }
    else {
      double v7 = (__int128 *)xmmword_10199EC88;
    }
    int v29 = 136446210;
    BOOL v30 = v7;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347C8,  1LL,  "[subscription-%{public}s] data buffer is empty",  &v29,  12);
    uint64_t v9 = (char *)v8;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLBatchedSensorSubscription::onBatchedDeviceMotionData(const CLBatchedDeviceMotionClient::Buffer &)",  "%s\n",  v8);
LABEL_49:
    if (v9 != buf) {
      free(v9);
    }
    return sub_1001BA1BC(v28);
  }

  if (byte_10199EC9F < 0)
  {
    sub_1010DD48C(__dst, (void *)xmmword_10199EC88, *((unint64_t *)&xmmword_10199EC88 + 1));
  }

  else
  {
    *(_OWORD *)std::string __dst = xmmword_10199EC88;
    uint64_t v21 = unk_10199EC98;
  }

  int v22 = dword_10199ECA0;
  xpc_object_t v10 = sub_100E43080((__int128 **)a2, (uint64_t *)__dst);
  uint64_t v11 = v10;
  if (SHIBYTE(v21) < 0)
  {
    operator delete(__dst[0]);
    if (v11) {
      goto LABEL_30;
    }
  }

  else if (v10)
  {
LABEL_30:
    sub_1010DDBC0(v18, "kCLConnectionMessageBatchedDeviceMotion");
    xpc_object_t v12 = sub_100E42F48((const char *)v18, v11);
    if (v19 < 0) {
      operator delete(v18[0]);
    }
    *(void *)__int128 buf = v12;
    sub_100E42FE4(a1, buf);
    xpc_release(v11);
    xpc_release(*(xpc_object_t *)buf);
    return sub_1001BA1BC(v28);
  }

  if (qword_1019347C0 != -1) {
    dispatch_once(&qword_1019347C0, &stru_101887AD0);
  }
  unint64_t v13 = (os_log_s *)qword_1019347C8;
  if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_ERROR))
  {
    if (byte_10199EC9F >= 0) {
      __int16 v14 = &xmmword_10199EC88;
    }
    else {
      __int16 v14 = (__int128 *)xmmword_10199EC88;
    }
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "[subscription-%{public}s] could not create payload",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    if (byte_10199EC9F >= 0) {
      int v16 = &xmmword_10199EC88;
    }
    else {
      int v16 = (__int128 *)xmmword_10199EC88;
    }
    int v29 = 136446210;
    BOOL v30 = v16;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347C8,  16LL,  "[subscription-%{public}s] could not create payload",  &v29,  12);
    uint64_t v9 = (char *)v17;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLBatchedSensorSubscription::onBatchedDeviceMotionData(const CLBatchedDeviceMotionClient::Buffer &)",  "%s\n",  v17);
    goto LABEL_49;
  }

  return sub_1001BA1BC(v28);
}

void sub_100E405B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, int a35, __int16 a36, char a37, char a38, id a39)
{
}

void sub_100E40724(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E40740(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_100BEF698(a2);
  if (qword_1019347C0 != -1) {
    dispatch_once(&qword_1019347C0, &stru_101887AD0);
  }
  double v7 = (os_log_s *)qword_1019347C8;
  if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a2 + 16);
    uint64_t v9 = *(void *)(a2 + 224);
    uint64_t v10 = a3 + 16;
    int v11 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)__int128 buf = 67241218;
    int v48 = v8;
    __int16 v49 = 1026;
    int v50 = v9;
    __int16 v51 = 1026;
    int v52 = v11;
    __int16 v53 = 1026;
    int v54 = v6;
    __int16 v55 = 2082;
    uint64_t v56 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[subscription] received workout event %{public}d, mode %{public}d, previous active state %{public}d, current activ e state %{public}d, appId %{public}s",  buf,  0x24u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    uint64_t v22 = *(void *)(a2 + 16);
    uint64_t v23 = *(void *)(a2 + 224);
    uint64_t v24 = a3 + 16;
    int v25 = *(_DWORD *)(a1 + 80);
    v38[0] = 67241218;
    v38[1] = v22;
    __int16 v39 = 1026;
    int v40 = v23;
    __int16 v41 = 1026;
    int v42 = v25;
    __int16 v43 = 1026;
    int v44 = v6;
    __int16 v45 = 2082;
    uint64_t v46 = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347C8,  0LL,  "[subscription] received workout event %{public}d, mode %{public}d, previous active state %{public}d, current activ e state %{public}d, appId %{public}s",  v38,  36);
    char v27 = (uint8_t *)v26;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLBatchedSensorSubscription::onWorkoutSessionUpdate(CLMotionStateMediator_Type::WorkoutEvent, const CLMotionS tateMediator_Type::WorkoutSessionOverview &)",  "%s\n",  v26);
    if (v27 != buf) {
      free(v27);
    }
  }

  __int128 v12 = *(_OWORD *)(a2 + 64);
  __int128 v13 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 104) = v13;
  *(_OWORD *)(a1 + 88) = v12;
  __int128 v14 = *(_OWORD *)(a2 + 112);
  __int128 v15 = *(_OWORD *)(a2 + 128);
  __int128 v16 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 168) = v16;
  *(_OWORD *)(a1 + 152) = v15;
  *(_OWORD *)(a1 + 136) = v14;
  __int128 v17 = *(_OWORD *)(a2 + 176);
  __int128 v18 = *(_OWORD *)(a2 + 192);
  __int128 v19 = *(_OWORD *)(a2 + 208);
  *(void *)(a1 + 248) = *(void *)(a2 + 224);
  *(_OWORD *)(a1 + 232) = v19;
  *(_OWORD *)(a1 + 216) = v18;
  *(_OWORD *)(a1 + 20sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v17;
  std::string::operator=((std::string *)(a1 + 264), (const std::string *)(a3 + 16));
  BOOL v20 = sub_100E43304(a1);
  if (sub_100BEF698(a2) == 1)
  {
    *(_DWORD *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 1;
    sub_1010DDBC0(v36, "kCLConnectionMessageBatchedAccelerometer");
    if (byte_10199EC7F < 0)
    {
      sub_1010DD48C(__p, (void *)xmmword_10199EC68, *((unint64_t *)&xmmword_10199EC68 + 1));
    }

    else
    {
      *(_OWORD *)std::stringbuf::string_type __p = xmmword_10199EC68;
      uint64_t v34 = unk_10199EC78;
    }

    int v35 = dword_10199EC80;
    sub_100E43400(a1, (uint64_t)v36, __p, *(void **)(a1 + 56));
    if (SHIBYTE(v34) < 0) {
      operator delete(__p[0]);
    }
    if (v37 < 0) {
      operator delete(v36[0]);
    }
    sub_1010DDBC0(v31, "kCLConnectionMessageBatchedDeviceMotion");
    if (byte_10199EC9F < 0)
    {
      sub_1010DD48C(__dst, (void *)xmmword_10199EC88, *((unint64_t *)&xmmword_10199EC88 + 1));
    }

    else
    {
      *(_OWORD *)std::string __dst = xmmword_10199EC88;
      uint64_t v29 = unk_10199EC98;
    }

    int v30 = dword_10199ECA0;
    sub_100E43400(a1, (uint64_t)v31, __dst, *(void **)(a1 + 64));
    if (SHIBYTE(v29) < 0) {
      operator delete(__dst[0]);
    }
    if (v32 < 0) {
      operator delete(v31[0]);
    }
  }

  else if (sub_100BEF698(a2) == 2)
  {
    uint64_t v21 = *(void *)(a1 + 48);
    *(_DWORD *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 2;
    [*(id *)(a1 + 56) unregisterForData:v21];
    [*(id *)(a1 + 64) unregisterForData:*(void *)(a1 + 48)];
  }

  sub_100E438A0(a1, v20);
}

void sub_100E40B74( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, uint64_t a32, char a33, uint64_t a34, int a35, __int16 a36, char a37, char a38)
{
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100E40C04(void *a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t v7 = sub_100C6AAF0((uint64_t)a1, a2, a3, a4, a5);
  *(void *)uint64_t v7 = off_101887A50;
  *(_OWORD *)(v7 + 48) = 0u;
  uint64_t v8 = (CLBatchedSensorSubscriptionAdapter **)(v7 + 48);
  *(_OWORD *)(v7 + 64) = 0u;
  *(_DWORD *)(v7 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 2;
  *(_OWORD *)(v7 + 88) = 0u;
  *(_OWORD *)(v7 + 104) = 0u;
  *(_OWORD *)(v7 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0u;
  *(_OWORD *)(v7 + 136) = 0u;
  *(_OWORD *)(v7 + 152) = 0u;
  *(_OWORD *)(v7 + 168) = 0u;
  *(_OWORD *)(v7 + 184) = 0u;
  *(_OWORD *)(v7 + 20sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0u;
  *(_OWORD *)(v7 + 216) = 0u;
  *(_OWORD *)(v7 + 232) = 0u;
  *(_OWORD *)(v7 + 241) = 0u;
  sub_1010DDBC0((void *)(v7 + 264), "");
  a1[36] = off_10182F180;
  uint64_t v9 = operator new(0x20uLL);
  v9[1] = 0LL;
  _OWORD v9[2] = 0LL;
  void *v9 = off_10182F1B8;
  *((_DWORD *)v9 + 6) = 31337;
  a1[37] = v9 + 3;
  a1[38] = v9;
  uint64_t v10 = -[CLBatchedSensorSubscriptionAdapter initWithBatchedSensorSubscription:]( objc_alloc(&OBJC_CLASS___CLBatchedSensorSubscriptionAdapter),  "initWithBatchedSensorSubscription:",  a1);
  const char *v8 = v10;
  -[CLBatchedSensorSubscriptionAdapter setValid:](v10, "setValid:", 1LL);
  id v11 = objc_msgSend(objc_msgSend(a3, "vendor"), "proxyForService:", @"CLBatchedAccelerometerService");
  a1[7] = v11;
  objc_msgSend(v11, "registerDelegate:inSilo:", a1[6], objc_msgSend(a3, "silo"));
  id v12 = objc_msgSend(objc_msgSend(a3, "vendor"), "proxyForService:", @"CLBatchedDeviceMotionService");
  a1[8] = v12;
  objc_msgSend(v12, "registerDelegate:inSilo:", a1[6], objc_msgSend(a3, "silo"));
  id v13 = objc_msgSend(objc_msgSend(a3, "vendor"), "proxyForService:", @"CLMotionStateMediator");
  a1[9] = v13;
  objc_msgSend(v13, "registerDelegate:inSilo:", a1[6], objc_msgSend(a3, "silo"));
  __int128 v14 = (void *)a1[9];
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = sub_100E40E34;
  void v16[3] = &unk_101887A70;
  _DWORD v16[4] = a1;
  [v14 currentWorkoutActiveStateWithReply:v16];
  return a1;
}

void sub_100E40DF8(_Unwind_Exception *a1)
{
}

void sub_100E40E34(uint64_t a1, int a2, __int128 *a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 32);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(a4 + 16))(&v27, a4);
  if (qword_1019347C0 != -1) {
    dispatch_once(&qword_1019347C0, &stru_101887AD0);
  }
  uint64_t v7 = (os_log_s *)qword_1019347C8;
  if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = &v28;
    if ((v28.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v8 = (std::string *)v28.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 buf = 67240450;
    int v24 = a2;
    __int16 v25 = 2082;
    float v26 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[subscription] received initial workout state of %{public}d, id %{public}s",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    __int128 v17 = &v28;
    if ((v28.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      __int128 v17 = (std::string *)v28.__r_.__value_.__r.__words[0];
    }
    v20[0] = 67240450;
    v20[1] = a2;
    __int16 v21 = 2082;
    uint64_t v22 = v17;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347C8,  0LL,  "[subscription] received initial workout state of %{public}d, id %{public}s",  v20,  18);
    __int128 v19 = (uint8_t *)v18;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLBatchedSensorSubscription::CLBatchedSensorSubscription(Delegate *, id<CLIntersiloUniverse>, CLClientManagerAutho rizationContext *, CLClientKeyPath *)_block_invoke",  "%s\n",  v18);
    if (v19 != buf) {
      free(v19);
    }
  }

  *(_BYTE *)(v6 + 256) = 1;
  *(_DWORD *)(v6 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a2;
  __int128 v9 = *a3;
  __int128 v10 = a3[1];
  *(_OWORD *)(v6 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a3[2];
  *(_OWORD *)(v6 + 104) = v10;
  *(_OWORD *)(v6 + 88) = v9;
  __int128 v11 = a3[3];
  __int128 v12 = a3[4];
  __int128 v13 = a3[5];
  *(_OWORD *)(v6 + 184) = a3[6];
  *(_OWORD *)(v6 + 168) = v13;
  *(_OWORD *)(v6 + 152) = v12;
  *(_OWORD *)(v6 + 136) = v11;
  __int128 v14 = a3[7];
  __int128 v15 = a3[8];
  __int128 v16 = a3[9];
  *(void *)(v6 + 248) = *((void *)a3 + 20);
  *(_OWORD *)(v6 + 232) = v16;
  *(_OWORD *)(v6 + 216) = v15;
  *(_OWORD *)(v6 + 20sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v14;
  std::string::operator=((std::string *)(v6 + 264), &v28);
  sub_100E410F8(v6);
  [*(id *)(v6 + 72) registerForWorkoutSessionUpdates:*(void *)(v6 + 48)];
  sub_10041385C(v29);
}

void sub_100E410D8(_Unwind_Exception *a1)
{
}

void sub_100E410F8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 256))
  {
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    uint64_t v2 = (os_log_s *)qword_1019347C8;
    if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
    {
      unsigned __int8 v3 = (void *)(a1 + 264);
      sub_100E42490(a1, (uint64_t)__p);
      if (v32 >= 0) {
        char v4 = __p;
      }
      else {
        char v4 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = v3;
      __int16 v24 = 2082;
      __int16 v25 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "[subscription] handling first workout with workout app id %{public}s, client id %{public}s",  buf,  0x16u);
      if (v32 < 0) {
        operator delete(__p[0]);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019347C0 != -1) {
        dispatch_once(&qword_1019347C0, &stru_101887AD0);
      }
      uint64_t v8 = (void *)(a1 + 264);
      uint64_t v9 = qword_1019347C8;
      sub_100E42490(a1, (uint64_t)buf);
      if (v26 >= 0) {
        __int128 v10 = buf;
      }
      else {
        __int128 v10 = *(_BYTE **)buf;
      }
      int v27 = 136446466;
      std::string v28 = v8;
      __int16 v29 = 2082;
      int v30 = v10;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v9,  0LL,  "[subscription] handling first workout with workout app id %{public}s, client id %{public}s",  &v27,  22);
      __int128 v12 = v11;
      if (v26 < 0) {
        operator delete(*(void **)buf);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLBatchedSensorSubscription::handleFirstWorkoutNotification()",  "%s\n",  v12);
    }

    sub_1010DDBC0(v21, "kCLConnectionMessageBatchedAccelerometer");
    if (byte_10199EC7F < 0)
    {
      sub_1010DD48C(__dst, (void *)xmmword_10199EC68, *((unint64_t *)&xmmword_10199EC68 + 1));
    }

    else
    {
      *(_OWORD *)std::string __dst = xmmword_10199EC68;
      uint64_t v19 = unk_10199EC78;
    }

    int v20 = dword_10199EC80;
    sub_100E43400(a1, (uint64_t)v21, __dst, *(void **)(a1 + 56));
    if (SHIBYTE(v19) < 0) {
      operator delete(__dst[0]);
    }
    if (v22 < 0) {
      operator delete(v21[0]);
    }
    sub_1010DDBC0(v16, "kCLConnectionMessageBatchedDeviceMotion");
    if (byte_10199EC9F < 0)
    {
      sub_1010DD48C(v13, (void *)xmmword_10199EC88, *((unint64_t *)&xmmword_10199EC88 + 1));
    }

    else
    {
      *(_OWORD *)__int128 v13 = xmmword_10199EC88;
      uint64_t v14 = unk_10199EC98;
    }

    int v15 = dword_10199ECA0;
    sub_100E43400(a1, (uint64_t)v16, v13, *(void **)(a1 + 64));
    if (SHIBYTE(v14) < 0) {
      operator delete(v13[0]);
    }
    if (v17 < 0) {
      operator delete(v16[0]);
    }
  }

  else
  {
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    double v5 = (os_log_s *)qword_1019347C8;
    if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "[subscription] we should know workout state here",  (uint8_t *)__p,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019347C0 != -1) {
        dispatch_once(&qword_1019347C0, &stru_101887AD0);
      }
      *(_WORD *)__int128 buf = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347C8,  16LL,  "[subscription] we should know workout state here",  buf,  2);
      uint64_t v7 = (void **)v6;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLBatchedSensorSubscription::handleFirstWorkoutNotification()",  "%s\n",  v6);
      if (v7 != __p) {
        free(v7);
      }
    }
  }

void sub_100E41590( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, uint64_t a32, char a33, uint64_t a34, int a35, __int16 a36, char a37, char a38)
{
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E41600(uint64_t a1)
{
  *(void *)a1 = off_101887A50;
  [*(id *)(a1 + 56) unregisterForData:*(void *)(a1 + 48)];

  *(void *)(a1 + 56) = 0LL;
  [*(id *)(a1 + 64) unregisterForData:*(void *)(a1 + 48)];

  *(void *)(a1 + 64) = 0LL;
  [*(id *)(a1 + 72) unregisterForWorkoutSessionUpdates:*(void *)(a1 + 48)];

  *(void *)(a1 + 72) = 0LL;
  [*(id *)(a1 + 48) setValid:0];

  *(void *)(a1 + 48) = 0LL;
  sub_1002B729C((void *)(a1 + 288));
  return sub_100C6AB50(a1);
}

void sub_100E416AC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E41600(a1);
  operator delete(v1);
}

void *sub_100E416C0@<X0>(uint64_t a1@<X8>)
{
  v15[0] = &off_101887B00;
  v15[1] = sub_100E419D8;
  v15[2] = 0LL;
  __int128 v16 = v15;
  sub_1010DDBC0(v17, "kCLConnectionMessageBatchedSensorAvailabilityUpdate");
  sub_10089FBA8((uint64_t)&v18, (uint64_t)v15);
  v13[0] = &off_101887B00;
  v13[1] = sub_100E41C38;
  _DWORD v13[2] = 0LL;
  uint64_t v14 = v13;
  sub_1010DDBC0(v19, "kCLConnectionMessageBatchedAccelerometer");
  sub_10089FBA8((uint64_t)&v20, (uint64_t)v13);
  v11[0] = &off_101887B00;
  v11[1] = sub_100E42060;
  _OWORD v11[2] = 0LL;
  __int128 v12 = v11;
  sub_1010DDBC0(v21, "kCLConnectionMessageBatchedDeviceMotion");
  sub_10089FBA8((uint64_t)v22, (uint64_t)v11);
  sub_100E43C80(a1, (unsigned __int8 *)v17, 3LL);
  for (uint64_t i = 0LL; i != -21; i -= 7LL)
  {
    unsigned __int8 v3 = *(_BYTE **)&v22[i * 8 + 24];
    if (&v22[i * 8] == v3)
    {
      unsigned __int8 v3 = &v22[i * 8];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE(v21[i + 2]) < 0) {
      operator delete((void *)v21[i]);
    }
  }

  double v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    double v5 = v11;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v12)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  uint64_t v7 = v14;
  if (v14 == v13)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = v13;
LABEL_19:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  else if (v14)
  {
    uint64_t v8 = 5LL;
    goto LABEL_19;
  }

  uint64_t result = v16;
  if (v16 == v15)
  {
    uint64_t v10 = 4LL;
    uint64_t result = v15;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v10))();
  }

  else if (v16)
  {
    uint64_t v10 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v10))();
  }

  return result;
}

void sub_100E418CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, char a13, uint64_t a14, uint64_t a15, char *a16, char a17, uint64_t a18, uint64_t a19, char *a20, char a21)
{
  for (uint64_t i = 112LL; i != -56; i -= 56LL)
    sub_10026E430((uint64_t)(&a21 + i));
  uint64_t v23 = a12;
  if (a12 == &a9)
  {
    uint64_t v24 = 4LL;
    uint64_t v23 = &a9;
  }

  else
  {
    if (!a12) {
      goto LABEL_8;
    }
    uint64_t v24 = 5LL;
  }

  (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_8:
  __int16 v25 = a16;
  if (a16 == &a13)
  {
    uint64_t v26 = 4LL;
    __int16 v25 = &a13;
  }

  else
  {
    if (!a16) {
      goto LABEL_13;
    }
    uint64_t v26 = 5LL;
  }

  (*(void (**)(void))(*(void *)v25 + 8 * v26))();
LABEL_13:
  int v27 = a20;
  if (a20 == &a17)
  {
    uint64_t v28 = 4LL;
    int v27 = &a17;
  }

  else
  {
    if (!a20) {
      goto LABEL_18;
    }
    uint64_t v28 = 5LL;
  }

  (*(void (**)(void))(*(void *)v27 + 8 * v28))();
LABEL_18:
  _Unwind_Resume(a1);
}

uint64_t sub_100E419D8(uint64_t a1, int a2)
{
  if (qword_1019347C0 != -1) {
    dispatch_once(&qword_1019347C0, &stru_101887AD0);
  }
  uint64_t v4 = (os_log_s *)qword_1019347C8;
  if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
  {
    sub_100E42490(a1, (uint64_t)&__p);
    double v5 = (v17 & 0x80000000LL) == 0 ? &__p : (void **)__p;
    *(_DWORD *)__int128 buf = 67240706;
    int v19 = a2;
    __int16 v20 = 2082;
    __int16 v21 = v5;
    __int16 v22 = 2050;
    uint64_t v23 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "[subscription] subscription changed for availability updates %{public}d, %{public}s, %{public}p",  buf,  0x1Cu);
    if (SBYTE3(v17) < 0) {
      operator delete(__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    uint64_t v7 = qword_1019347C8;
    sub_100E42490(a1, (uint64_t)v11);
    if (v12 >= 0) {
      uint64_t v8 = v11;
    }
    else {
      uint64_t v8 = (void **)v11[0];
    }
    LODWORD(__p) = 67240706;
    HIDWORD(__p) = a2;
    __int16 v14 = 2082;
    int v15 = v8;
    __int16 v16 = 2050;
    uint64_t v17 = a1;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  0LL,  "[subscription] subscription changed for availability updates %{public}d, %{public}s, %{public}p",  &__p,  28);
    uint64_t v10 = v9;
    if (v12 < 0) {
      operator delete(v11[0]);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLBatchedSensorSubscription::handleRequestAvailabilityUpdate(BOOL, NSDictionary *)",  "%s\n",  v10);
  }

  return sub_100C6AC8C(a1);
}

void sub_100E41C38(uint64_t a1, int a2, uint64_t a3)
{
  if (byte_10199EC7F < 0)
  {
    sub_1010DD48C(__p, (void *)xmmword_10199EC68, *((unint64_t *)&xmmword_10199EC68 + 1));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = xmmword_10199EC68;
    uint64_t v22 = unk_10199EC78;
  }

  int v23 = dword_10199EC80;
  uint64_t v5 = sub_100E426B0(a1, 0LL, a3, (uint64_t *)__p);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  if ((_DWORD)v5 == 100)
  {
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    uint64_t v6 = (os_log_s *)qword_1019347C8;
    if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = byte_10199EC7F >= 0 ? &xmmword_10199EC68 : (__int128 *)xmmword_10199EC68;
      sub_100E42490(a1, (uint64_t)v24);
      uint64_t v8 = SBYTE3(v28) >= 0 ? v24 : *(_BYTE **)v24;
      *(_DWORD *)__int128 buf = 136446978;
      *(void *)&uint8_t buf[4] = v7;
      __int16 v32 = 1026;
      int v33 = a2;
      __int16 v34 = 2082;
      int v35 = v8;
      __int16 v36 = 2050;
      uint64_t v37 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[subscription-%{public}s] subscription changed %{public}d, %{public}s, %{public}p",  buf,  0x26u);
      if (SBYTE3(v28) < 0) {
        operator delete(*(void **)v24);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347C0 != -1) {
        dispatch_once(&qword_1019347C0, &stru_101887AD0);
      }
      uint64_t v9 = qword_1019347C8;
      if (byte_10199EC7F >= 0) {
        uint64_t v10 = &xmmword_10199EC68;
      }
      else {
        uint64_t v10 = (__int128 *)xmmword_10199EC68;
      }
      sub_100E42490(a1, (uint64_t)v19);
      if (v20 >= 0) {
        __int128 v11 = v19;
      }
      else {
        __int128 v11 = (void **)v19[0];
      }
      *(_DWORD *)uint64_t v24 = 136446978;
      *(void *)&_DWORD v24[4] = v10;
      __int16 v25 = 1026;
      int v26 = a2;
      __int16 v27 = 2082;
      uint64_t v28 = v11;
      __int16 v29 = 2050;
      uint64_t v30 = a1;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v9,  0LL,  "[subscription-%{public}s] subscription changed %{public}d, %{public}s, %{public}p",  v24,  38);
      __int128 v13 = v12;
      if (v20 < 0) {
        operator delete(v19[0]);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLBatchedSensorSubscription::handleRequestBatchedAccelerometer(BOOL, NSDictionary *)",  "%s\n",  v13);
      if (v13 != buf) {
        free(v13);
      }
    }

    sub_100C6AC8C(a1);
    if (a2)
    {
      sub_1010DDBC0(&v17, "kCLConnectionMessageBatchedAccelerometer");
      if (byte_10199EC7F < 0)
      {
        sub_1010DD48C(__dst, (void *)xmmword_10199EC68, *((unint64_t *)&xmmword_10199EC68 + 1));
      }

      else
      {
        *(_OWORD *)std::string __dst = xmmword_10199EC68;
        uint64_t v15 = unk_10199EC78;
      }

      int v16 = dword_10199EC80;
      if (SHIBYTE(v15) < 0) {
        operator delete(__dst[0]);
      }
      if (v18 < 0) {
        operator delete(v17);
      }
    }

    else
    {
      [*(id *)(a1 + 56) unregisterForData:*(void *)(a1 + 48)];
    }
  }

  else
  {
    sub_100C6AC8C(a1);
    [*(id *)(a1 + 56) unregisterForData:*(void *)(a1 + 48)];
    uint64_t v38 = CMErrorMessage;
    __int16 v39 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v5);
    *(void *)__int128 buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v39,  &v38,  1LL);
    sub_100E42980(a1, buf);
  }

void sub_100E42024( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E42060(uint64_t a1, int a2, uint64_t a3)
{
  if (byte_10199EC9F < 0)
  {
    sub_1010DD48C(__p, (void *)xmmword_10199EC88, *((unint64_t *)&xmmword_10199EC88 + 1));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = xmmword_10199EC88;
    uint64_t v22 = unk_10199EC98;
  }

  int v23 = dword_10199ECA0;
  uint64_t v5 = sub_100E426B0(a1, 0LL, a3, (uint64_t *)__p);
  if (SHIBYTE(v22) < 0) {
    operator delete(__p[0]);
  }
  if ((_DWORD)v5 == 100)
  {
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    uint64_t v6 = (os_log_s *)qword_1019347C8;
    if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = byte_10199EC9F >= 0 ? &xmmword_10199EC88 : (__int128 *)xmmword_10199EC88;
      sub_100E42490(a1, (uint64_t)v24);
      uint64_t v8 = SBYTE3(v28) >= 0 ? v24 : *(_BYTE **)v24;
      *(_DWORD *)__int128 buf = 136446978;
      *(void *)&uint8_t buf[4] = v7;
      __int16 v32 = 1026;
      int v33 = a2;
      __int16 v34 = 2082;
      int v35 = v8;
      __int16 v36 = 2050;
      uint64_t v37 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[subscription-%{public}s] subscription changed %{public}d, %{public}s, %{public}p",  buf,  0x26u);
      if (SBYTE3(v28) < 0) {
        operator delete(*(void **)v24);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347C0 != -1) {
        dispatch_once(&qword_1019347C0, &stru_101887AD0);
      }
      uint64_t v9 = qword_1019347C8;
      if (byte_10199EC9F >= 0) {
        uint64_t v10 = &xmmword_10199EC88;
      }
      else {
        uint64_t v10 = (__int128 *)xmmword_10199EC88;
      }
      sub_100E42490(a1, (uint64_t)v19);
      if (v20 >= 0) {
        __int128 v11 = v19;
      }
      else {
        __int128 v11 = (void **)v19[0];
      }
      *(_DWORD *)uint64_t v24 = 136446978;
      *(void *)&_DWORD v24[4] = v10;
      __int16 v25 = 1026;
      int v26 = a2;
      __int16 v27 = 2082;
      uint64_t v28 = v11;
      __int16 v29 = 2050;
      uint64_t v30 = a1;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v9,  0LL,  "[subscription-%{public}s] subscription changed %{public}d, %{public}s, %{public}p",  v24,  38);
      __int128 v13 = v12;
      if (v20 < 0) {
        operator delete(v19[0]);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLBatchedSensorSubscription::handleRequestBatchedDeviceMotion(BOOL, NSDictionary *)",  "%s\n",  v13);
      if (v13 != buf) {
        free(v13);
      }
    }

    sub_100C6AC8C(a1);
    if (a2)
    {
      sub_1010DDBC0(&v17, "kCLConnectionMessageBatchedDeviceMotion");
      if (byte_10199EC9F < 0)
      {
        sub_1010DD48C(__dst, (void *)xmmword_10199EC88, *((unint64_t *)&xmmword_10199EC88 + 1));
      }

      else
      {
        *(_OWORD *)std::string __dst = xmmword_10199EC88;
        uint64_t v15 = unk_10199EC98;
      }

      int v16 = dword_10199ECA0;
      if (SHIBYTE(v15) < 0) {
        operator delete(__dst[0]);
      }
      if (v18 < 0) {
        operator delete(v17);
      }
    }

    else
    {
      [*(id *)(a1 + 64) unregisterForData:*(void *)(a1 + 48)];
    }
  }

  else
  {
    sub_100C6AC8C(a1);
    [*(id *)(a1 + 64) unregisterForData:*(void *)(a1 + 48)];
    uint64_t v38 = CMErrorMessage;
    __int16 v39 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v5);
    *(void *)__int128 buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v39,  &v38,  1LL);
    sub_100E42980(a1, buf);
  }

void sub_100E42454( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E42490(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void **)(a1 + 24);
  if (v4)
  {
    [v4 clientName];
  }

  else
  {
    uint64_t v18 = 0LL;
    *(_OWORD *)std::stringbuf::string_type __p = 0u;
    __int128 v17 = 0u;
    *(_OWORD *)uint64_t v15 = 0u;
    __int128 v13 = 0u;
    memset(v14, 0, sizeof(v14));
    *(_OWORD *)__int128 v11 = 0u;
    *(_OWORD *)char v12 = 0u;
    *(_OWORD *)uint64_t v9 = 0u;
    __int128 v10 = 0u;
    *(_OWORD *)uint64_t v8 = 0u;
  }

  sub_100FE370C((uint64_t)v8);
  if (SHIBYTE(v14[3]) >= 0) {
    uint64_t v5 = (void *)HIBYTE(v14[3]);
  }
  else {
    uint64_t v5 = v14[2];
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v15[0]);
  }
  if (SHIBYTE(v14[3]) < 0) {
    operator delete(v14[1]);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[1]);
  }
  if (SHIBYTE(v12[0]) < 0) {
    operator delete(v11[0]);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[1]);
  }
  if (SHIBYTE(v9[0]) < 0)
  {
    operator delete(v8[0]);
    if (v5) {
      goto LABEL_21;
    }
LABEL_24:
    if (objc_msgSend(*(id *)(a1 + 24), "executablePath", v8[0], v8[1], v9[0])) {
      uint64_t v7 = (char *)objc_msgSend(objc_msgSend(*(id *)(a1 + 24), "executablePath"), "UTF8String");
    }
    else {
      uint64_t v7 = "";
    }
    sub_1010DDBC0((void *)a2, v7);
    return;
  }

  if (!v5) {
    goto LABEL_24;
  }
LABEL_21:
  uint64_t v6 = *(void **)(a1 + 24);
  if (v6)
  {
    [v6 clientName];
  }

  else
  {
    uint64_t v18 = 0LL;
    *(_OWORD *)std::stringbuf::string_type __p = 0u;
    __int128 v17 = 0u;
    *(_OWORD *)uint64_t v15 = 0u;
    __int128 v13 = 0u;
    memset(v14, 0, sizeof(v14));
    *(_OWORD *)__int128 v11 = 0u;
    *(_OWORD *)char v12 = 0u;
    *(_OWORD *)uint64_t v9 = 0u;
    __int128 v10 = 0u;
    *(_OWORD *)uint64_t v8 = 0u;
  }

  sub_100FE370C((uint64_t)v8);
  if (SHIBYTE(v14[3]) < 0)
  {
    sub_1010DD48C((_BYTE *)a2, v14[1], (unint64_t)v14[2]);
  }

  else
  {
    *(_OWORD *)a2 = *(_OWORD *)&v14[1];
    *(void **)(a2 + 16) = v14[3];
  }

  if (SHIBYTE(v17) < 0) {
    operator delete(__p[1]);
  }
  if (SHIBYTE(__p[0]) < 0) {
    operator delete(v15[0]);
  }
  if (SHIBYTE(v14[3]) < 0) {
    operator delete(v14[1]);
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(v12[1]);
  }
  if (SHIBYTE(v12[0]) < 0) {
    operator delete(v11[0]);
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(v9[1]);
  }
  if (SHIBYTE(v9[0]) < 0) {
    operator delete(v8[0]);
  }
}

void sub_100E42698( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100E426B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if ((sub_100C6ADE0(a1) & 1) != 0) {
    return 100LL;
  }
  if (qword_1019347C0 != -1) {
    dispatch_once(&qword_1019347C0, &stru_101887AD0);
  }
  uint64_t v7 = (os_log_s *)qword_1019347C8;
  if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = a4;
    sub_100E42490(a1, (uint64_t)__p);
    if (v19 >= 0) {
      uint64_t v9 = __p;
    }
    else {
      uint64_t v9 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int128 buf = 136446722;
    uint64_t v22 = v8;
    __int16 v23 = 2082;
    uint64_t v24 = v9;
    __int16 v25 = 2050;
    uint64_t v26 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "[subscription-%{public}s] error, not authorized for motion activity %{public}s, %{public}p",  buf,  0x20u);
    if (SHIBYTE(v19) < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    uint64_t v10 = qword_1019347C8;
    sub_100E42490(a1, (uint64_t)v14);
    if (v15 >= 0) {
      __int128 v11 = v14;
    }
    else {
      __int128 v11 = (void **)v14[0];
    }
    *(_DWORD *)std::stringbuf::string_type __p = 136446722;
    *(void *)&__p[4] = a4;
    __int16 v17 = 2082;
    uint64_t v18 = v11;
    __int16 v19 = 2050;
    uint64_t v20 = a1;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v10,  0LL,  "[subscription-%{public}s] error, not authorized for motion activity %{public}s, %{public}p",  __p,  32);
    __int128 v13 = v12;
    if (v15 < 0) {
      operator delete(v14[0]);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLBatchedSensorSubscription::validateBatchedSensorRequest(BOOL, NSDictionary *, ConnectionInfo)",  "%s\n",  v13);
  }

  return 105LL;
}

void *sub_100E4292C(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }

  *((_DWORD *)__dst + 6) = *((_DWORD *)a2 + 6);
  return __dst;
}

void sub_100E42980(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100272EB8(off_101887B80, a2, &v6);
  (*(void (**)(uint64_t, uint64_t *, void))(*(void *)v2 + 24LL))(v2, &v6, 0LL);
  unsigned __int8 v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100E42A0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100E42A20(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result = sub_100C6ACAC(a1);
  if ((_DWORD)result)
  {
    if (!*(_BYTE *)(a1 + 256)) {
      return 0LL;
    }
    if (sub_100E43304(a1)) {
      return 1LL;
    }
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    uint64_t v6 = (os_log_s *)qword_1019347C8;
    if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = a3;
      uint64_t v8 = (void *)(a1 + 264);
      sub_100E42490(a1, (uint64_t)__p);
      if (v20 >= 0) {
        uint64_t v9 = __p;
      }
      else {
        uint64_t v9 = *(_BYTE **)__p;
      }
      *(_DWORD *)__int128 buf = 136446722;
      __int16 v23 = v7;
      __int16 v24 = 2082;
      __int16 v25 = v8;
      __int16 v26 = 2082;
      __int16 v27 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "[subscription-%{public}s] not in applicable workout, workout id %{public}s, client id %{public}s",  buf,  0x20u);
      if (SHIBYTE(v20) < 0) {
        operator delete(*(void **)__p);
      }
    }

    uint64_t result = sub_1002921D0(115, 0);
    if ((_DWORD)result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347C0 != -1) {
        dispatch_once(&qword_1019347C0, &stru_101887AD0);
      }
      uint64_t v10 = (void *)(a1 + 264);
      uint64_t v11 = qword_1019347C8;
      sub_100E42490(a1, (uint64_t)v15);
      if (v16 >= 0) {
        char v12 = v15;
      }
      else {
        char v12 = (void **)v15[0];
      }
      *(_DWORD *)std::stringbuf::string_type __p = 136446722;
      *(void *)&__p[4] = a3;
      __int16 v18 = 2082;
      __int16 v19 = v10;
      __int16 v20 = 2082;
      __int16 v21 = v12;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v11,  16LL,  "[subscription-%{public}s] not in applicable workout, workout id %{public}s, client id %{public}s",  __p,  32);
      __int16 v14 = v13;
      if (v16 < 0) {
        operator delete(v15[0]);
      }
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLBatchedSensorSubscription::shouldSendBatchedData(std::string, ConnectionInfo)",  "%s\n",  v14);
      return 0LL;
    }
  }

  return result;
}

xpc_object_t sub_100E42CCC(__int128 **a1, uint64_t *a2)
{
  unint64_t v4 = (unint64_t)((char *)a1[1] - (char *)*a1) >> 2;
  unint64_t v5 = malloc(4 * (int)v4);
  uint64_t v6 = dispatch_data_create(v5, 4 * (int)v4, 0LL, _dispatch_data_destructor_free);
  xpc_object_t v7 = xpc_data_create_with_dispatch_data(v6);

  uint64_t v8 = *a1;
  uint64_t v9 = a1[1];
  while (v8 != v9)
  {
    __int128 v10 = *v8;
    v5[4] = *((_DWORD *)v8 + 4);
    *(_OWORD *)unint64_t v5 = v10;
    v5 += 5;
    uint64_t v8 = (__int128 *)((char *)v8 + 20);
  }

  if (qword_1019347C0 != -1) {
    dispatch_once(&qword_1019347C0, &stru_101887AD0);
  }
  uint64_t v11 = (os_log_s *)qword_1019347C8;
  if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
  {
    char v12 = a2;
    *(_DWORD *)__int128 buf = 136446722;
    __int16 v23 = v12;
    __int16 v24 = 1026;
    int v25 = 4 * v4;
    __int16 v26 = 1024;
    int v27 = -858993459 * v4;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "[subscription-%{public}s] created data size %{public}d num %d",  buf,  0x18u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    int v16 = 136446722;
    __int16 v17 = a2;
    __int16 v18 = 1026;
    int v19 = 4 * v4;
    __int16 v20 = 1024;
    int v21 = -858993459 * v4;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347C8,  0LL,  "[subscription-%{public}s] created data size %{public}d num %d",  &v16,  24);
    char v15 = (uint8_t *)v14;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static xpc_object_t CLBatchedSensorSubscription::createXpcPayload(const BufferT &, ConnectionInfo) [T = CMAccel800 , BufferT = std::vector<CMAccel800>]",  "%s\n",  v14);
    if (v15 != buf) {
      free(v15);
    }
  }

  return v7;
}

xpc_object_t sub_100E42F48(const char *a1, void *a2)
{
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  xpc_object_t v3 = xpc_string_create(a1);
  *(_OWORD *)keys = *(_OWORD *)off_101887A90;
  v6[0] = v3;
  v6[1] = a2;
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)keys, v6, 2uLL);
  if (v3) {
    xpc_release(v3);
  }
  return v4;
}

void sub_100E42FE4(uint64_t a1, void *a2)
{
  xpc_object_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100E4306C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

xpc_object_t sub_100E43080(__int128 **a1, uint64_t *a2)
{
  unint64_t v4 = (unint64_t)((char *)a1[1] - (char *)*a1) >> 1;
  unint64_t v5 = malloc(2 * (int)v4);
  uint64_t v6 = dispatch_data_create(v5, 2 * (int)v4, 0LL, _dispatch_data_destructor_free);
  xpc_object_t v7 = xpc_data_create_with_dispatch_data(v6);

  uint64_t v8 = *a1;
  uint64_t v9 = a1[1];
  while (v8 != v9)
  {
    __int128 v10 = *v8;
    __int128 v11 = v8[1];
    __int128 v12 = v8[2];
    *((_WORD *)v5 + 24) = *((_WORD *)v8 + 24);
    v5[1] = v11;
    v5[2] = v12;
    *unint64_t v5 = v10;
    unint64_t v5 = (_OWORD *)((char *)v5 + 50);
    uint64_t v8 = (__int128 *)((char *)v8 + 50);
  }

  if (qword_1019347C0 != -1) {
    dispatch_once(&qword_1019347C0, &stru_101887AD0);
  }
  __int128 v13 = (os_log_s *)qword_1019347C8;
  if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v14 = a2;
    *(_DWORD *)__int128 buf = 136446722;
    int v25 = v14;
    __int16 v26 = 1026;
    int v27 = 2 * v4;
    __int16 v28 = 1024;
    int v29 = -1030792151 * v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "[subscription-%{public}s] created data size %{public}d num %d",  buf,  0x18u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    int v18 = 136446722;
    int v19 = a2;
    __int16 v20 = 1026;
    int v21 = 2 * v4;
    __int16 v22 = 1024;
    int v23 = -1030792151 * v4;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347C8,  0LL,  "[subscription-%{public}s] created data size %{public}d num %d",  &v18,  24);
    __int16 v17 = (uint8_t *)v16;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static xpc_object_t CLBatchedSensorSubscription::createXpcPayload(const BufferT &, ConnectionInfo) [T = CMSPU::Saf ety::DMSample, BufferT = std::vector<CMSPU::Safety::DMSample>]",  "%s\n",  v16);
    if (v17 != buf) {
      free(v17);
    }
  }

  return v7;
}

BOOL sub_100E43304(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int8 *)(a1 + 287);
  if ((v2 & 0x80u) == 0LL) {
    xpc_object_t v3 = (void *)*(unsigned __int8 *)(a1 + 287);
  }
  else {
    xpc_object_t v3 = *(void **)(a1 + 272);
  }
  unint64_t v4 = v18;
  int v5 = (char)v18;
  if ((v18 & 0x80u) != 0) {
    unint64_t v4 = (unint64_t)__p[1];
  }
  if (v3 != (void *)v4)
  {
    BOOL v15 = 0;
    goto LABEL_23;
  }

  uint64_t v6 = (const void **)(a1 + 264);
  if ((v18 & 0x80u) == 0) {
    xpc_object_t v7 = __p;
  }
  else {
    xpc_object_t v7 = (void **)__p[0];
  }
  if ((v2 & 0x80) != 0)
  {
    BOOL v15 = memcmp(*v6, v7, *(void *)(a1 + 272)) == 0;
    goto LABEL_22;
  }

  if (*(_BYTE *)(a1 + 287))
  {
    uint64_t v8 = v2 - 1;
    do
    {
      int v10 = *(unsigned __int8 *)v6;
      uint64_t v6 = (const void **)((char *)v6 + 1);
      int v9 = v10;
      int v12 = *(unsigned __int8 *)v7;
      xpc_object_t v7 = (void **)((char *)v7 + 1);
      int v11 = v12;
      BOOL v14 = v8-- != 0;
      BOOL v15 = v9 == v11;
    }

    while (v9 == v11 && v14);
LABEL_22:
    if ((v5 & 0x80000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }

  BOOL v15 = 1;
  if ((char)v18 < 0) {
LABEL_23:
  }
    operator delete(__p[0]);
LABEL_24:
  if (*(_DWORD *)(a1 + 80) != 1) {
    return 0LL;
  }
  if (*(void *)(a1 + 248)) {
    return 0LL;
  }
  return v15;
}

id sub_100E43400(uint64_t a1, uint64_t a2, void **a3, void *a4)
{
  if (qword_1019347C0 != -1) {
    dispatch_once(&qword_1019347C0, &stru_101887AD0);
  }
  uint64_t v8 = (os_log_s *)qword_1019347C8;
  if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = *((char *)a3 + 23);
    int v10 = a3;
    if (v9 < 0) {
      int v10 = *a3;
    }
    if (*(char *)(a2 + 23) < 0)
    {
      sub_1010DD48C(__dst, *(void **)a2, *(void *)(a2 + 8));
      if ((*((_BYTE *)a3 + 23) & 0x80) == 0) {
        goto LABEL_8;
      }
    }

    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      uint64_t v36 = *(void *)(a2 + 16);
      if ((v9 & 0x80) == 0)
      {
LABEL_8:
        *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a3;
        int v33 = a3[2];
LABEL_11:
        int v34 = *((_DWORD *)a3 + 6);
        int v11 = sub_100E42A20(a1, (uint64_t)__dst, (uint64_t *)__p);
        int v12 = sub_100C6ACAC(a1);
        BOOL v13 = sub_100E43304(a1);
        *(_DWORD *)__int128 buf = 136446978;
        uint64_t v46 = v10;
        __int16 v47 = 1026;
        int v48 = v11;
        __int16 v49 = 1026;
        int v50 = v12;
        __int16 v51 = 1026;
        BOOL v52 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "[subscription-%{public}s] toggling stream, should send data %{public}d, interested, %{public}d, in workout %{public}d",  buf,  0x1Eu);
        if (SHIBYTE(v33) < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v36) < 0) {
          operator delete(__dst[0]);
        }
        goto LABEL_15;
      }
    }

    sub_1010DD48C(__p, *a3, (unint64_t)a3[1]);
    goto LABEL_11;
  }

void sub_100E4380C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, void *__p, uint64_t a33, int a34, __int16 a35, char a36, char a37, uint64_t a38, void *a39, uint64_t a40, int a41, __int16 a42, char a43, char a44, uint64_t a45, uint64_t a46, uint64_t a47, int a48, __int16 a49, char a50,char a51)
{
  if (a37 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E438A0(uint64_t a1, uint64_t a2)
{
  char v4 = sub_100C6ACAC(a1);
  char v5 = v4;
  if (v13 < 0)
  {
    operator delete(__p[0]);
    if ((v5 & 1) == 0) {
      return;
    }
  }

  else if ((v4 & 1) == 0)
  {
    return;
  }

  if (qword_1019347C0 != -1) {
    dispatch_once(&qword_1019347C0, &stru_101887AD0);
  }
  uint64_t v6 = (os_log_s *)qword_1019347C8;
  if (os_log_type_enabled((os_log_t)qword_1019347C8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(__p[0]) = 67240192;
    HIDWORD(__p[0]) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "[subscription] sending availability update %{public}d",  (uint8_t *)__p,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_1019347C0 != -1) {
      dispatch_once(&qword_1019347C0, &stru_101887AD0);
    }
    v11[0] = 67240192;
    v11[1] = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019347C8,  0LL,  "[subscription] sending availability update %{public}d",  v11,  8);
    uint64_t v8 = (void **)v7;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLBatchedSensorSubscription::sendAvailabilityUpdate(BOOL)", "%s\n", v7);
    if (v8 != __p) {
      free(v8);
    }
  }

  uint64_t v9 = CMBatchedSensorAvailable;
  int v10 = +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", a2);
  __p[0] = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v10,  &v9,  1LL);
  sub_100E43AFC(a1, __p);
}

void sub_100E43AD8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E43AFC(uint64_t a1, void *a2)
{
  xpc_object_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100E43B90(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E43BA4(id a1)
{
  qword_1019347C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "BatchedSensor");
}

__n128 sub_100E43BD0(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_101887B00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100E43C0C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101887B00;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100E43C30(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t sub_100E43C38(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100E43C74()
{
}

uint64_t sub_100E43C80(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_100E43CF8(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100E43CE4(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_100E43CF8(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  xpc_object_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    char v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_100E43F78(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  __int16 v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    void *v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_100E43F60(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100E43F78@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  void *v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_100E43FEC(v8 + 2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100E43FD4(_Unwind_Exception *a1)
{
}

void *sub_100E43FEC(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100E44044(_Unwind_Exception *exception_object)
{
}

void *sub_100E44060@<X0>(void *a1@<X1>, void *a2@<X8>)
{
  __int128 v4 = operator new(0x70uLL);
  __n128 result = sub_100E440B8(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100E440A4(_Unwind_Exception *a1)
{
}

void *sub_100E440B8(void *a1, void *a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_10182B4B0;
  CLConnectionMessage::CLConnectionMessage(a1 + 3, *a2);
  return a1;
}

void sub_100E440F4(_Unwind_Exception *a1)
{
}

uint64_t sub_100E44108()
{
  dword_10199EC80 = 800;
  __cxa_atexit((void (*)(void *))sub_100355650, &xmmword_10199EC68, (void *)&_mh_execute_header);
  sub_1010DDBC0(&xmmword_10199EC88, "DmFp");
  dword_10199ECA0 = 200;
  __cxa_atexit((void (*)(void *))sub_100355650, &xmmword_10199EC88, (void *)&_mh_execute_header);
  sub_1010DDBC0(qword_10199ECA8, "VO2MaxPowerBudgetEstimatorLastExtendedBudgetAllotmentReason");
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_10199ECA8, (void *)&_mh_execute_header);
}

void sub_100E44460(_Unwind_Exception *a1)
{
}

uint64_t sub_100E444D0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_100E44A7C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E44BD0(id a1)
{
  qword_1019346A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Altimeter");
}

uint64_t sub_100E44BFC()
{
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_10199ECC0, (void *)&_mh_execute_header);
}

float sub_100E44C40(uint64_t a1)
{
  *(void *)int v42 = 0x10000000000LL;
  sub_100FBFFE8(v39);
  unint64_t v2 = 0LL;
  float v36 = sub_100D54EB8(a1);
  float v37 = v3;
  float v4 = 0.0;
  float v38 = v5;
  do
  {
    float v6 = sub_1002B8AF0((uint64_t)&v36, v2);
    float v4 = v4 + (float)((float)(v6 * 0.25) * (float)(v6 * 0.25));
    ++v2;
  }

  while (v2 != 3);
  unint64_t v7 = 0LL;
  float v8 = sqrtf(v4) * 4.0;
  float v9 = v36 / v8;
  float v10 = v37 / v8;
  float v11 = v38 / v8;
  do
  {
    float v12 = sub_100D54F1C((unsigned __int16 *)a1, v7);
    *(float *)sub_100208A44(v42, v7++) = (float)((float)(v11 * v13) + (float)(v14 * v10)) + (float)(v12 * v9);
  }

  while (v7 != 256);
  sub_100FBFFEC((uint64_t)v39, v41, v42);
  for (unint64_t i = 0LL; i != 256; ++i)
  {
    float v16 = *(float *)sub_100208A44((unsigned __int16 *)(a1 + 1076), i);
    float v17 = *(float *)sub_100208A44(v42, i);
    *(float *)sub_100208A44(v42, i) = v16 - (float)(v17 * v10);
  }

  sub_100FBFFEC((uint64_t)v39, v40, v42);
  int v19 = *(_DWORD *)(a1 + 8);
  BOOL v18 = (int *)(a1 + 8);
  float v20 = sub_1009AF760(v19, 0x80uLL, 15.0);
  int v21 = sub_1009AF58C(v20);
  float v22 = sub_1009AF760(*v18, 0x80uLL, 50.0);
  int v23 = sub_1009AF58C(v22);
  float v24 = sub_1009AF7AC(v21, v23, (uint64_t)v40);
  float v25 = sub_1009AF760(*v18, 0x80uLL, 5.0);
  int v26 = sub_1009AF58C(v25);
  float v27 = sub_1009AF760(*v18, 0x80uLL, 15.0);
  int v28 = sub_1009AF58C(v27);
  sub_1009AF7AC(v26, v28, (uint64_t)v41);
  float v29 = sub_1009AF760(*v18, 0x80uLL, 15.0);
  int v30 = sub_1009AF58C(v29);
  float v31 = sub_1009AF760(*v18, 0x80uLL, 50.0);
  int v32 = sub_1009AF58C(v31);
  sub_1009AF7AC(v30, v32, (uint64_t)v41);
  float v33 = sub_1009AF760(*v18, 0x80uLL, 25.0);
  int v34 = sub_1009AF58C(v33);
  sub_1009AF7AC(v34, v32, (uint64_t)v41);
  return v24;
}

void *sub_100E44F04(void *a1, void *a2)
{
  *a1 = &off_101887BE8;
  a1[1] = 0LL;
  sub_100B73634((uint64_t)sub_100E4503C, (uint64_t)a1, a2, &v7);
  uint64_t v3 = v7;
  uint64_t v7 = 0LL;
  uint64_t v4 = a1[1];
  a1[1] = v3;
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    uint64_t v5 = v7;
    uint64_t v7 = 0LL;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  [*(id *)(a1[1] + 16) register:*(void *)(a1[1] + 8) forNotification:0 registrationInfo:0];
  [*(id *)(a1[1] + 16) register:*(void *)(a1[1] + 8) forNotification:1 registrationInfo:0];
  [*(id *)(a1[1] + 16) register:*(void *)(a1[1] + 8) forNotification:2 registrationInfo:0];
  [*(id *)(a1[1] + 16) register:*(void *)(a1[1] + 8) forNotification:3 registrationInfo:0];
  [*(id *)(a1[1] + 16) register:*(void *)(a1[1] + 8) forNotification:4 registrationInfo:0];
  [*(id *)(a1[1] + 16) register:*(void *)(a1[1] + 8) forNotification:5 registrationInfo:0];
  return a1;
}

void sub_100E45000(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 8);
  *(void *)(v1 + 8) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E4503C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a4 + 64LL))(a4, a1, a2, a3);
}

uint64_t sub_100E4505C(uint64_t result, uint64_t a2, _DWORD *a3, double *a4)
{
  switch(*a3)
  {
    case 0:
      __n128 result = (**(uint64_t (***)(uint64_t, void))result)(result, *(unsigned __int8 *)a4);
      break;
    case 1:
      __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
      break;
    case 2:
      __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16LL))(result);
      break;
    case 3:
      __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
      break;
    case 4:
      __n128 result = (*(uint64_t (**)(uint64_t))(*(void *)result + 32LL))(result);
      break;
    case 5:
      __n128 result = (*(uint64_t (**)(uint64_t, double))(*(void *)result + 40LL))(result, *a4);
      break;
    default:
      return result;
  }

  return result;
}

void *sub_100E450D4(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &off_101887BE8;
  a1[1] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void *sub_100E4511C(void *a1, __int128 *a2)
{
  uint64_t v4 = sub_100C0099C(a1);
  *uint64_t v4 = &off_101887C50;
  __int128 v5 = *a2;
  *(_OWORD *)((char *)v4 + 122) = *(__int128 *)((char *)a2 + 10);
  *((_OWORD *)v4 + 7) = v5;
  sub_100E45198((uint64_t)v4);
  return a1;
}

void sub_100E45164(_Unwind_Exception *a1)
{
}

void sub_100E45180(_DWORD *a1)
{
  uint64_t v1 = sub_100C00A00(a1);
  operator delete(v1);
}

void sub_100E45198(uint64_t a1)
{
  uint64_t v8 = *(void *)(a1 + 126);
  int v9 = *(_DWORD *)(a1 + 134);
  if (qword_101934580 != -1) {
    dispatch_once(&qword_101934580, &stru_101887CB0);
  }
  uint64_t v2 = (os_log_s *)qword_101934588;
  if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_INFO))
  {
    int v3 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)__int128 buf = 67110656;
    int v25 = (__int16)v8;
    __int16 v26 = 1024;
    int v27 = SWORD1(v8);
    __int16 v28 = 1024;
    int v29 = SWORD2(v8);
    __int16 v30 = 1024;
    int v31 = SHIWORD(v8);
    __int16 v32 = 1024;
    int v33 = (__int16)v9;
    __int16 v34 = 1024;
    int v35 = SHIWORD(v9);
    __int16 v36 = 1024;
    int v37 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Setting calibration data %d, %d, %d, %d, %d, %d from sensor mode %d",  buf,  0x2Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934580 != -1) {
      dispatch_once(&qword_101934580, &stru_101887CB0);
    }
    int v4 = *(_DWORD *)(a1 + 64);
    __int16 v12 = 1024;
    int v13 = SWORD1(v8);
    __int16 v14 = 1024;
    int v15 = SWORD2(v8);
    __int16 v16 = 1024;
    int v17 = SHIWORD(v8);
    __int16 v18 = 1024;
    int v19 = (__int16)v9;
    __int16 v20 = 1024;
    int v21 = SHIWORD(v9);
    __int16 v22 = 1024;
    int v23 = v4;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  1LL,  "Setting calibration data %d, %d, %d, %d, %d, %d from sensor mode %d",  &v11,  44,  v7,  v8,  v9,  v10,  67110656);
    float v6 = (uint8_t *)v5;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMagnetometerCoexistenceNotifierCpasV11::chooseOffsetData()",  "%s\n",  v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  sub_100C01740((float32x2_t *)a1, (__int16 *)&v8);
}

void sub_100E45408(id a1)
{
  qword_101934588 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Compass");
}

uint64_t sub_100E45434()
{
  unsigned __int8 v0 = operator new(0x30uLL);
  uint64_t result = sub_1006DC9EC((uint64_t)v0, (uint64_t)"CLPencilDebug", 3);
  *unsigned __int8 v0 = off_101887D00;
  v0[4] = 0LL;
  v0[5] = 0LL;
  qword_1019A2140 = (uint64_t)v0;
  return result;
}

void sub_100E45484(_Unwind_Exception *a1)
{
}

uint64_t sub_100E45498()
{
  if (qword_10199ECD8 != -1) {
    dispatch_once(&qword_10199ECD8, &stru_101887CD0);
  }
  return qword_1019A2140;
}

void *sub_100E454DC(void *a1)
{
  *a1 = off_101887D00;
  sub_10000AE14((uint64_t)(a1 + 4));
  return sub_1006DCAA8(a1);
}

void sub_100E4550C(void *a1)
{
  *a1 = off_101887D00;
  sub_10000AE14((uint64_t)(a1 + 4));
  uint64_t v2 = sub_1006DCAA8(a1);
  operator delete(v2);
}

void sub_100E45540(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 < 3)
  {
    int v10 = (uint64_t **)(a1 + 32);
    int v9 = *(uint64_t **)(a1 + 32);
    if (v9) {
      goto LABEL_18;
    }
    int v11 = (uint64_t *)sub_10071542C();
    uint64_t v15 = 0x320000FF00LL;
    char v16 = 0;
    sub_10121B774(v11, (uint64_t)&v15, (uint64_t *)buf);
    sub_10005F550((uint64_t)v10, (__int128 *)buf);
    __int16 v12 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      int v13 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }

    int v9 = *v10;
    if (*v10)
    {
LABEL_18:
      if (a3) {
        sub_100719D78(v9, (uint64_t)sub_100E45798, a1);
      }
      else {
        sub_100719D78(v9, 0LL, 0LL);
      }
    }
  }

  else
  {
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101887D48);
    }
    int v4 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "Invalid request for data type %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101887D48);
      }
      v17[0] = 67240192;
      v17[1] = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  17LL,  "Invalid request for data type %{public}d",  v17,  8);
      float v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLPencilDebug::numberOfSpectatorsChanged(int, size_t)",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

void sub_100E45798(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v30 = 0LL;
  int v31 = 0LL;
  IOHIDEventGetVendorDefinedData(a4, &v31, &v30);
  float v6 = v31;
  if (v31) {
    BOOL v7 = v30 > 0xF;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    unint64_t v11 = v30 - 15;
    v30 -= 15LL;
    v31 += 15;
    LOBYTE(v36) = 0;
    float32x2_t v37 = 0LL;
    double v39 = (double)*(unint64_t *)(v6 + 5) * 0.000001;
    unsigned int v12 = *v6;
    if (v12 > 0x94)
    {
      if (v12 == 150)
      {
LABEL_28:
        if (v11 < 8 || v6[13] != 192)
        {
          if (qword_1019345C0 != -1) {
            dispatch_once(&qword_1019345C0, &stru_101887D48);
          }
          __int16 v18 = (os_log_s *)qword_1019345C8;
          if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)__int128 buf = 68157954;
            int v41 = v30;
            __int16 v42 = 2096;
            __int16 v43 = v31;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "Unexpected RID_JAKKU_ALGS record %.*P",  buf,  0x12u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019345C0 != -1) {
              dispatch_once(&qword_1019345C0, &stru_101887D48);
            }
            int v32 = 68157954;
            int v33 = v30;
            __int16 v34 = 2096;
            int v35 = v31;
            double v10 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  17LL,  "Unexpected RID_JAKKU_ALGS record %.*P",  &v32,  18);
            goto LABEL_39;
          }

          return;
        }

        float32x2_t v37 = *(float32x2_t *)(v6 + 15);
        uint64_t v16 = a1;
        uint64_t v17 = 0LL;
LABEL_54:
        sub_1006DD65C(v16, v17, (uint64_t)&v36, 24LL);
        return;
      }

      if (v12 != 149) {
        goto LABEL_42;
      }
    }

    else if (v12 != 133)
    {
      if (v12 != 134)
      {
LABEL_42:
        if (qword_1019345C0 != -1) {
          dispatch_once(&qword_1019345C0, &stru_101887D48);
        }
        __int16 v20 = (os_log_s *)qword_1019345C8;
        if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)__int128 buf = 68157954;
          int v41 = v30;
          __int16 v42 = 2096;
          __int16 v43 = v31;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Unexpected RID_JAKKU_ALGS record %.*P",  buf,  0x12u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345C0 != -1) {
            dispatch_once(&qword_1019345C0, &stru_101887D48);
          }
          int v32 = 68157954;
          int v33 = v30;
          __int16 v34 = 2096;
          int v35 = v31;
          double v21 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  1LL,  "Unexpected RID_JAKKU_ALGS record %.*P",  &v32,  18);
          int v19 = v22;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "static void CLPencilDebug::onIohidEventBounce(void *, void *, void *, IOHIDEventRef)",  "%s\n",  v21);
          goto LABEL_40;
        }

        return;
      }

      goto LABEL_28;
    }

    if (v11 > 0xB)
    {
      if (v6[13] == 128)
      {
        LOBYTE(v36) = 2;
        int v27 = *(_DWORD *)(v6 + 23);
        __int16 v26 = v6 + 23;
        float32x2_t v37 = vmul_f32(vcvt_f32_s32(*(int32x2_t *)(v26 - 8)), (float32x2_t)vdup_n_s32(0x37800000u));
        int v31 = v26;
        float v38 = (float)v27 * 0.000015259;
        uint64_t v16 = a1;
        uint64_t v17 = 2LL;
        goto LABEL_54;
      }

      if (!v6[13])
      {
        LOBYTE(v36) = 1;
        int v24 = *(__int16 *)(v6 + 19);
        int v23 = v6 + 19;
        float32_t v25 = (float)*((__int16 *)v23 - 1) * 0.00012207;
        v37.f32[0] = (float)*((__int16 *)v23 - 2) * 0.00012207;
        v37.f32[1] = v25;
        int v31 = v23;
        float v38 = (float)v24 * 0.00012207;
        uint64_t v16 = a1;
        uint64_t v17 = 1LL;
        goto LABEL_54;
      }

      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101887D48);
      }
      __int16 v28 = (os_log_s *)qword_1019345C8;
      if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
      {
        int v29 = v6[13];
        *(_DWORD *)__int128 buf = 67240448;
        int v41 = v29;
        __int16 v42 = 1026;
        LODWORD(v43) = v30;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_FAULT,  "Unexpected RID_JAKKU_DATA record %{public}u, size %{public}d",  buf,  0xEu);
      }

      if (!sub_1002921D0(115, 0)) {
        return;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 == -1)
      {
LABEL_27:
        int v15 = v6[13];
        int v32 = 67240448;
        int v33 = v15;
        __int16 v34 = 1026;
        LODWORD(v35) = v30;
        double v10 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  17LL,  "Unexpected RID_JAKKU_DATA record %{public}u, size %{public}d",  &v32,  14);
LABEL_39:
        int v19 = v9;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "static void CLPencilDebug::onIohidEventBounce(void *, void *, void *, IOHIDEventRef)",  "%s\n",  v10);
LABEL_40:
        if (v19 != buf) {
          free(v19);
        }
        return;
      }
    }

    else
    {
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101887D48);
      }
      int v13 = (os_log_s *)qword_1019345C8;
      if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
      {
        int v14 = v6[13];
        *(_DWORD *)__int128 buf = 67240448;
        int v41 = v14;
        __int16 v42 = 1026;
        LODWORD(v43) = v30;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "Unexpected RID_JAKKU_DATA record %{public}u, size %{public}d",  buf,  0xEu);
      }

      if (!sub_1002921D0(115, 0)) {
        return;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 == -1) {
        goto LABEL_27;
      }
    }

    dispatch_once(&qword_1019345C0, &stru_101887D48);
    goto LABEL_27;
  }

  if (qword_1019345C0 != -1) {
    dispatch_once(&qword_1019345C0, &stru_101887D48);
  }
  uint64_t v8 = (os_log_s *)qword_1019345C8;
  if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)__int128 buf = 67240192;
    int v41 = v30;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "Invalid %{public}dB payload, returning", buf, 8u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101887D48);
    }
    int v36 = 67240192;
    v37.i32[0] = v30;
    double v10 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  17LL,  "Invalid %{public}dB payload, returning",  &v36,  8);
    goto LABEL_39;
  }

void sub_100E45F44(id a1)
{
  qword_1019345C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Accessory");
}

CFDictionaryRef sub_100E45F70(void *a1)
{
  uint64_t result = IOServiceNameMatching((const char *)[a1 UTF8String]);
  if (result) {
    return (const __CFDictionary *)IOServiceGetMatchingService(kIOMainPortDefault, result);
  }
  return result;
}

BOOL sub_100E45FA4(void *a1, io_registry_entry_t entry, CFStringRef key)
{
  CFProperty = (const __CFNumber *)IORegistryEntryCreateCFProperty(entry, key, kCFAllocatorDefault, 0);
  float v6 = CFProperty;
  if (CFProperty)
  {
    CFNumberGetValue(CFProperty, kCFNumberIntType, a1);
    CFRelease(v6);
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101887D68);
    }
    BOOL v7 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138543362;
      CFStringRef v13 = key;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "#warning Key %{public}@ not found!",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101887D68);
      }
      int v10 = 138543362;
      CFStringRef v11 = key;
      int v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#warning Key %{public}@ not found!",  &v10,  12);
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL getIntFromIOService(int *, io_service_t, CFStringRef)", "%s\n", v9);
    }
  }

  return v6 != 0LL;
}

BOOL sub_100E46198(void *a1, io_registry_entry_t entry, __CFString *key, void **p_vtable)
{
  __int128 v5 = key;
  CFProperty = (void *)IORegistryEntryCreateCFProperty(entry, key, kCFAllocatorDefault, 0);
  uint64_t v8 = CFProperty;
  if (CFProperty)
  {
    id v9 = [CFProperty length];
    if (v9 == (id)(int)p_vtable)
    {
      memcpy(a1, [v8 bytes], (size_t)v9);
      CFRelease(v8);
      return v8 != 0LL;
    }

    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101887D68);
    }
    unsigned int v12 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      p_vtable = (void **)-[__CFString UTF8String](v5, "UTF8String");
      *(_DWORD *)__int128 buf = 68290051;
      *(_DWORD *)__int16 v22 = 0;
      *(_WORD *)&v22[4] = 2082;
      *(void *)&v22[6] = "";
      __int16 v23 = 2082;
      int v24 = (__CFString *)p_vtable;
      __int16 v25 = 2050;
      id v26 = [v8 length];
      __int16 v27 = 2082;
      __int16 v28 = "assert";
      __int16 v29 = 2081;
      unint64_t v30 = "[data length] == expected_length";
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected length!, key:%{public, location:escape_only}s, length:%{public}lu,  event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x3Au);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101887D68);
      }
    }

    CFStringRef v13 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      p_vtable = (void **)-[__CFString UTF8String](v5, "UTF8String");
      id v14 = [v8 length];
      *(_DWORD *)__int128 buf = 68290051;
      *(_DWORD *)__int16 v22 = 0;
      *(_WORD *)&v22[4] = 2082;
      *(void *)&v22[6] = "";
      __int16 v23 = 2082;
      int v24 = (__CFString *)p_vtable;
      __int16 v25 = 2050;
      id v26 = v14;
      __int16 v27 = 2082;
      __int16 v28 = "assert";
      __int16 v29 = 2081;
      unint64_t v30 = "[data length] == expected_length";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected length!",  "{msg%{public}.0s:Unexpected length!, key:%{public, location:escape_only}s, length:%{public}lu,  event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x3Au);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101887D68);
      }
    }

    int v15 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
    {
      __int128 v5 = (__CFString *)-[__CFString UTF8String](v5, "UTF8String");
      id v16 = [v8 length];
      *(_DWORD *)__int128 buf = 68290051;
      *(_DWORD *)__int16 v22 = 0;
      *(_WORD *)&v22[4] = 2082;
      *(void *)&v22[6] = "";
      __int16 v23 = 2082;
      int v24 = v5;
      __int16 v25 = 2050;
      id v26 = v16;
      __int16 v27 = 2082;
      __int16 v28 = "assert";
      __int16 v29 = 2081;
      unint64_t v30 = "[data length] == expected_length";
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Unexpected length!, key:%{public, location:escape_only}s, length:%{public}lu,  event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x3Au);
    }

    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Motion/IO/CLIORegistryUtils.mm",  58,  "getBytesFromIOService");
    goto LABEL_20;
  }

  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (qword_1019344B0 != -1) {
LABEL_20:
  }
    dispatch_once(&qword_1019344B0, &stru_101887D68);
  int v10 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138543362;
    *(void *)__int16 v22 = v5;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "#warning Key %{public}@ not found!", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    int v19 = 138543362;
    __int16 v20 = v5;
    LODWORD(v18) = 12;
    uint64_t v17 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#warning Key %{public}@ not found!",  &v19,  v18);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL getBytesFromIOService(void *, io_service_t, CFStringRef, int)",  "%s\n",  v17);
  }

  return v8 != 0LL;
}

void sub_100E46628(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_100E46654(uint64_t a1)
{
  *(void *)a1 = &off_101887D98;
  __asm { FMOV            V0.2S, #1.0 }

  *(void *)(a1 + 8) = _D0;
  *(_DWORD *)(a1 + 16) = 1065353216;
  BOOL v7 = (float *)(a1 + 16);
  uint64_t v8 = sub_1006E27E8();
  sub_100413284(v8, &v13);
  sub_1002A81F8(v13, "RowingModelMetsScale", v7);
  id v9 = v14;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return a1;
}

void sub_100E466F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100E46710(double a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a3 + 48) + 48LL))(*(void *)(a3 + 48));
  if ((_DWORD)result)
  {
    uint64_t result = (*(uint64_t (**)(void, _BYTE *, double))(**(void **)(a3 + 48) + 24LL))( *(void *)(a3 + 48),  v6,  a1);
    if (v6[208]) {
      return sub_100253308(*(void *)(a3 + 88));
    }
  }

  return result;
}

uint64_t sub_100E467A8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(**(void **)(a2 + 88) + 48LL))(*(void *)(a2 + 88));
}

void sub_100E467B8(float *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v5 = *(_DWORD *)(a2 + 1352);
  float v6 = *(float *)(a2 + 308);
  float v7 = *(float *)(a2 + 316);
  float v8 = *(float *)(a2 + 1264);
  HIDWORD(v42) = *(_DWORD *)(a2 + 1268);
  LODWORD(v43) = *(_DWORD *)(a2 + 1256);
  float v9 = *(float *)(a2 + 1272);
  BOOL v10 = v7 > 30.0 && v6 == 0.0;
  float v11 = v6 * 60.0;
  if (v10) {
    float v12 = 46.154;
  }
  else {
    float v12 = v11;
  }
  float v13 = *(float *)(a2 + 312);
  HIDWORD(v43) = *(_DWORD *)(a2 + 1360);
  float v14 = v12;
  float v15 = (float)((float)((float)((float)(v13 * 0.50634) + (float)(v7 * 0.015543)) + (float)(v12 * -0.032764))
  if (v5 == 1) {
    float v15 = v15 * a1[2];
  }
  HIDWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_DWORD *)(a2 + 1364);
  double v41 = *(double *)(a2 + 128);
  HIDWORD(v39) = *(_DWORD *)(a2 + 1260);
  float v16 = cbrtf(*((float *)&v39 + 1));
  LODWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = cbrtf(*(float *)&v43);
  *(float *)&double v42 = v9;
  float v17 = (float)((float)((float)((float)((float)(*(float *)&v40 * 1.1203) + (float)(v16 * 1.4812))
                              + (float)(v8 * -0.082668))
                      + (float)((float)(*((float *)&v43 + 1) * 0.039268) * v8))
  float v18 = v17 + -0.71494;
  else {
    float v19 = 0.0;
  }
  if (v19 <= 15.0) {
    float v20 = v19;
  }
  else {
    float v20 = 15.0;
  }
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101887DD8);
  }
  float v21 = v13;
  __int16 v22 = (os_log_s *)qword_1019344D8;
  float v23 = v14;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 134221312;
    double v67 = v41;
    __int16 v68 = 2048;
    double v69 = v7;
    __int16 v70 = 2048;
    double v71 = v21;
    __int16 v72 = 2048;
    double v73 = v14;
    __int16 v74 = 2048;
    double v75 = *((float *)&v43 + 1);
    __int16 v76 = 1024;
    *(_DWORD *)int v77 = v5;
    *(_WORD *)&v77[4] = 2048;
    *(double *)&v77[6] = v20;
    *(_WORD *)&v77[14] = 2048;
    *(double *)&v77[16] = *((float *)&v39 + 1);
    *(_WORD *)&v77[24] = 2048;
    *(double *)&v77[26] = *(float *)&v43;
    __int16 v78 = 2048;
    double v79 = v8;
    __int16 v80 = 2048;
    double v81 = *(float *)&v42;
    __int16 v82 = 2048;
    double v83 = *((float *)&v42 + 1);
    __int16 v84 = 2048;
    double v85 = v18;
    __int16 v86 = 2048;
    double v87 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "Rowing, Speed Model, timestamp, %f, stroke power, %f, strokes amplitude, %f, stroke rate (spm), %f, height (m), %f , gender, %d, speed, %f, strokePowerDM, %f, strokeAmpDM, %f, strokeRateDM, %f, strokeDriveVelocityDM, %f, strokeLe ngthDM, %f, speedDM, %f, speedLegacy, %f",  buf,  0x8Au);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101887DD8);
    }
    int v44 = 134221312;
    double v45 = v41;
    __int16 v46 = 2048;
    double v47 = v7;
    __int16 v48 = 2048;
    double v49 = v21;
    __int16 v50 = 2048;
    double v51 = v14;
    __int16 v52 = 2048;
    double v53 = *((float *)&v43 + 1);
    __int16 v54 = 1024;
    *(_DWORD *)__int16 v55 = v5;
    *(_WORD *)&v55[4] = 2048;
    *(double *)&v55[6] = v20;
    *(_WORD *)&v55[14] = 2048;
    *(double *)&v55[16] = *((float *)&v39 + 1);
    *(_WORD *)&v55[24] = 2048;
    *(double *)&v55[26] = *(float *)&v43;
    __int16 v56 = 2048;
    double v57 = v8;
    __int16 v58 = 2048;
    double v59 = *(float *)&v42;
    __int16 v60 = 2048;
    double v61 = *((float *)&v42 + 1);
    __int16 v62 = 2048;
    double v63 = v18;
    __int16 v64 = 2048;
    double v65 = v15;
    LODWORD(v39) = 138;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Rowing, Speed Model, timestamp, %f, stroke power, %f, strokes amplitude, %f, stroke rate (spm), %f, height (m), %f , gender, %d, speed, %f, strokePowerDM, %f, strokeAmpDM, %f, strokeRateDM, %f, strokeDriveVelocityDM, %f, strokeLe ngthDM, %f, speedDM, %f, speedLegacy, %f",  COERCE_DOUBLE(&v44),  v39,  v40,  v41,  v42,  LODWORD(v43));
    int v35 = (uint8_t *)v34;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLNatalieRowingModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v34);
    if (v35 != buf) {
      free(v35);
    }
  }

  float v24 = (float)((float)((float)(v15 * (float)(v15 * (float)(v15 * 4.7217))) / *((float *)&v40 + 1))
  if (v5 == 1)
  {
    float v25 = a1[3];
    float v24 = v24 * v25;
    float v26 = (float)((float)(147.22 / *((float *)&v40 + 1)) + 1.8196) * v25;
  }

  else
  {
    float v26 = (float)(147.22 / *((float *)&v40 + 1)) + 1.8196;
  }

  float v27 = powf(*((float *)&v40 + 1), 0.66667);
  float v28 = (float)((float)((float)((float)(*(float *)&v40 * (float)(v20 * 40.751)) / v27)
                      + (float)((float)(v20 * (float)(v20 * (float)(v20 * 0.62095))) / v27))
  if (v8 == 0.0 && *(float *)&v42 == 0.0)
  {
    if (v23 <= 0.0) {
      float v29 = 2.1;
    }
    else {
      float v29 = v24;
    }
  }

  else
  {
    if (v26 >= v28) {
      float v30 = v26;
    }
    else {
      float v30 = (float)((float)((float)((float)(*(float *)&v40 * (float)(v20 * 40.751)) / v27)
    }
                          + (float)((float)(v20 * (float)(v20 * (float)(v20 * 0.62095))) / v27))
    float v31 = fmaxf(v28, 2.1);
    if (v23 <= 0.0) {
      float v29 = v31;
    }
    else {
      float v29 = v30;
    }
    if (v29 < 4.8423 && v29 < v24) {
      float v29 = v24;
    }
  }

  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101887DD8);
  }
  int v32 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEBUG))
  {
    float v33 = a1[4];
    *(_DWORD *)__int128 buf = 134219776;
    double v67 = v41;
    __int16 v68 = 2048;
    double v69 = v20;
    __int16 v70 = 2048;
    double v71 = v21;
    __int16 v72 = 2048;
    double v73 = *((float *)&v40 + 1);
    __int16 v74 = 2048;
    double v75 = v29;
    __int16 v76 = 2048;
    *(double *)int v77 = v33;
    *(_WORD *)&v77[8] = 2048;
    *(double *)&v77[10] = v28;
    *(_WORD *)&v77[18] = 2048;
    *(double *)&v77[20] = v24;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "Rowing, WR Model, timestamp, %f, stroke speed, %f, strokes amplitude, %f, weight (KG), %f, METS, %f, fMetsScaling, %f, METSDM, %f, METSLegacy, %f",  buf,  0x52u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101887DD8);
    }
    float v36 = a1[4];
    int v44 = 134219776;
    double v45 = v41;
    __int16 v46 = 2048;
    double v47 = v20;
    __int16 v48 = 2048;
    double v49 = v21;
    __int16 v50 = 2048;
    double v51 = *((float *)&v40 + 1);
    __int16 v52 = 2048;
    double v53 = v29;
    __int16 v54 = 2048;
    *(double *)__int16 v55 = v36;
    *(_WORD *)&v55[8] = 2048;
    *(double *)&v55[10] = v28;
    *(_WORD *)&v55[18] = 2048;
    *(double *)&v55[20] = v24;
    LODWORD(v39) = 82;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344D8,  2LL,  "Rowing, WR Model, timestamp, %f, stroke speed, %f, strokes amplitude, %f, weight (KG), %f, METS, %f, fMetsScaling, %f, METSDM, %f, METSLegacy, %f",  COERCE_DOUBLE(&v44),  v39,  v40,  v41,  v42,  v43);
    float v38 = (uint8_t *)v37;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMetsInfo CLNatalieRowingModel::computeMETS(const CLNatalieModelInput &)",  "%s\n",  v37);
    if (v38 != buf) {
      free(v38);
    }
  }

  *(_DWORD *)a3 = 0;
  *(float *)(a3 + 4) = v29;
  *(_DWORD *)(a3 + 8) = 0;
  *(float *)(a3 + 12) = v29;
  *(_DWORD *)(a3 + 16) = 0;
  *(float *)(a3 + 2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v29 * a1[4];
  *(void *)(a3 + 24) = 0LL;
  *(void *)(a3 + 32) = 0x800000003LL;
}

void sub_100E46FC0(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

uint64_t sub_100E46FEC(uint64_t a1, _BYTE *a2, const std::string *a3, const std::string *a4)
{
  float v6 = a2;
  float v8 = (std::string *)(a1 + 56);
  char v9 = a2[23];
  if (*(char *)(a1 + 79) < 0)
  {
    float v11 = *(const void **)(a1 + 56);
    size_t v10 = *(void *)(a1 + 64);
  }

  else
  {
    size_t v10 = *(unsigned __int8 *)(a1 + 79);
    float v11 = (const void *)(a1 + 56);
  }

  if (v9 >= 0) {
    size_t v12 = a2[23];
  }
  else {
    size_t v12 = *((void *)a2 + 1);
  }
  if (v9 < 0) {
    a2 = *(_BYTE **)a2;
  }
  if (v12 >= v10) {
    size_t v13 = v10;
  }
  else {
    size_t v13 = v12;
  }
  BOOL v14 = !memcmp(v11, a2, v13) && v12 == v10;
  if (v14
    && *(unsigned __int8 *)(a1 + 80) == v6[24]
    && *(_DWORD *)(a1 + 84) == *((_DWORD *)v6 + 7)
    && *(double *)(a1 + 88) == *((double *)v6 + 7)
    && *(unsigned __int8 *)(a1 + 96) == v6[64]
    && *(double *)(a1 + 104) == *((double *)v6 + 9)
    && *(double *)(a1 + 112) == *((double *)v6 + 10)
    && !sub_1007516E4((const void **)(a1 + 120), v6 + 88)
    && *(unsigned __int8 *)(a1 + 144) == v6[112]
    && (LODWORD(v15) = *((_DWORD *)v6 + 36), *(double *)(a1 + 176) == (double)v15))
  {
    uint64_t v16 = sub_100E47694((unsigned __int8 **)(a1 + 152), (uint64_t)(v6 + 120));
  }

  else
  {
    uint64_t v16 = 1LL;
  }

  std::string::operator=((std::string *)(a1 + 8), a3);
  std::string::operator=((std::string *)(a1 + 32), a4);
  std::string::operator=(v8, (const std::string *)v6);
  char v17 = v6[24];
  *(void *)(a1 + 88) = *((void *)v6 + 7);
  *(_BYTE *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v17;
  *(_DWORD *)(a1 + 84) = *((_DWORD *)v6 + 7);
  *(_BYTE *)(a1 + 96) = v6[64];
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(v6 + 72);
  std::string::operator=((std::string *)(a1 + 120), (const std::string *)(v6 + 88));
  *(_BYTE *)(a1 + 144) = v6[112];
  if ((_BYTE *)(a1 + 152) != v6 + 120) {
    sub_100E51AB4( a1 + 152,  *((std::string **)v6 + 15),  *((__int128 **)v6 + 16),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v6 + 16) - *((void *)v6 + 15)) >> 3));
  }
  LODWORD(v18) = *((_DWORD *)v6 + 36);
  *(double *)(a1 + 176) = (double)v18;
  sub_1002F0B04(buf);
  int v19 = sub_1002A82BC(*(uint64_t *)buf, "AMLFirstFixDelay", (void *)(a1 + 88));
  float v20 = *(std::__shared_weak_count **)v53;
  if (*(void *)v53)
  {
    float v21 = (unint64_t *)(*(void *)v53 + 8LL);
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  if (v19)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    float v23 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      int v24 = *(_DWORD *)a1;
      uint64_t v25 = *(void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 67240448;
      *(_DWORD *)&uint8_t buf[4] = v24;
      *(_WORD *)double v53 = 2050;
      *(void *)&uint64_t v53[2] = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "#Warning #AMLCfg,inst,%{public}d,overriding first fix delay to %{public}f",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v39 = *(_DWORD *)a1;
      uint64_t v40 = *(void *)(a1 + 88);
      int v48 = 67240448;
      int v49 = v39;
      __int16 v50 = 2050;
      uint64_t v51 = v40;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AMLCfg,inst,%{public}d,overriding first fix delay to %{public}f",  &v48,  18);
      double v42 = (uint8_t *)v41;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyAML::SimConfig::updateEmergencySettings(const AugmentedAction::AML &, const std::string &, const std::string &)",  "%s\n",  v41);
      if (v42 != buf) {
        free(v42);
      }
    }
  }

  sub_1002F0B04(buf);
  int v26 = sub_1002A6F64(*(uint64_t *)buf, "AMLMultipleSmsEnabled", (BOOL *)(a1 + 96));
  int v27 = v26;
  float v28 = *(std::__shared_weak_count **)v53;
  if (!*(void *)v53) {
    goto LABEL_44;
  }
  float v29 = (unint64_t *)(*(void *)v53 + 8LL);
  do
    unint64_t v30 = __ldaxr(v29);
  while (__stlxr(v30 - 1, v29));
  if (!v30)
  {
    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
    std::__shared_weak_count::__release_weak(v28);
    if (!v27) {
      goto LABEL_50;
    }
  }

  else
  {
LABEL_44:
    if (!v26) {
      goto LABEL_50;
    }
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  float v31 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    int v32 = *(_DWORD *)a1;
    int v33 = *(unsigned __int8 *)(a1 + 96);
    *(_DWORD *)__int128 buf = 67240448;
    *(_DWORD *)&uint8_t buf[4] = v32;
    *(_WORD *)double v53 = 1026;
    *(_DWORD *)&uint64_t v53[2] = v33;
    _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "#Warning #AMLCfg,inst,%{public}d,overriding enablement of multiple SMS to %{public}d",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    int v43 = *(_DWORD *)a1;
    int v44 = *(unsigned __int8 *)(a1 + 96);
    int v48 = 67240448;
    int v49 = v43;
    __int16 v50 = 1026;
    LODWORD(v51) = v44;
    LODWORD(v47) = 14;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AMLCfg,inst,%{public}d,overriding enablement of multiple SMS to %{public}d",  &v48,  v47);
    __int16 v46 = (uint8_t *)v45;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyAML::SimConfig::updateEmergencySettings(const AugmentedAction::AML &, const std::string &, const std::string &)",  "%s\n",  v45);
    if (v46 != buf) {
      free(v46);
    }
  }

void sub_100E47674( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_100E47694(unsigned __int8 **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  int v3 = a1[1];
  int v4 = *(unsigned __int8 **)a2;
  if (v3 - *a1 == *(void *)(a2 + 8) - *(void *)a2)
  {
    if (v2 == v3)
    {
      int v5 = 1;
    }

    else
    {
      do
      {
        int v5 = sub_100022A24((uint64_t)&v7, v2, v4);
        if (!v5) {
          break;
        }
        v2 += 24;
        v4 += 24;
      }

      while (v2 != v3);
    }
  }

  else
  {
    int v5 = 0;
  }

  return v5 ^ 1u;
}

void sub_100E47714(int *a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  uint64_t v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = a1 + 14;
    int v4 = *a1;
    int v5 = *((unsigned __int8 *)a1 + 80);
    int v6 = a1[21];
    uint64_t v7 = *((void *)a1 + 11);
    int v8 = *((unsigned __int8 *)a1 + 96);
    uint64_t v10 = *((void *)a1 + 13);
    uint64_t v9 = *((void *)a1 + 14);
    float v11 = a1 + 30;
    v12[0] = 68291331;
    __int16 v13 = 2082;
    v12[1] = 0;
    BOOL v14 = "";
    __int16 v15 = 1026;
    int v16 = v4;
    __int16 v17 = 2081;
    unint64_t v18 = v3;
    __int16 v19 = 1025;
    int v20 = v5;
    __int16 v21 = 1025;
    int v22 = v6;
    __int16 v23 = 2050;
    uint64_t v24 = v7;
    __int16 v25 = 1026;
    int v26 = v8;
    __int16 v27 = 2050;
    uint64_t v28 = v10;
    __int16 v29 = 2050;
    uint64_t v30 = v9;
    __int16 v31 = 2081;
    int v32 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AMLCfg,logSettings, sim:%{public}d, smsAddress:%{private, location:escape_only}s , binary:%{private}d, port:%{private}d, firstFixDelay:%{public}f, multipleSmsEnabled:%{public} hhd, maxFixDelay:%{public}f, minFixDelay:%{public}f, sms over NAS Address:%{private, location:escape_only}s}",  (uint8_t *)v12,  0x5Cu);
  }

uint64_t sub_100E4787C(uint64_t a1)
{
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v2 = a1 + 8;
  *(_OWORD *)(a1 + 24) = 0u;
  DWORD1(v4) = 0;
  LOBYTE(v4) = 0;
  *((void *)&v4 + 1) = 0x402E000000000000LL;
  LOBYTE(sub_1012279C0(0LL, v4, v5) = 1;
  *((void *)&v5 + 1) = 0x4072C00000000000LL;
  __int128 v15 = 0u;
  __int128 v17 = 0uLL;
  __int128 v19 = v4;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 1065353216;
  int v10 = 0;
  int v11 = 0;
  size_t v12 = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v16 = 0LL;
  __int128 v20 = v5;
  uint64_t v18 = 0LL;
  uint64_t v21 = 0x4034000000000000LL;
  std::stringbuf::string_type __p = 0LL;
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  char v25 = 1;
  uint64_t v26 = 0LL;
  uint64_t v27 = 0LL;
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  uint64_t v9 = 0x4018000000000000LL;
  uint64_t v28 = 0LL;
  uint64_t v29 = 0x4018000000000000LL;
  sub_100E51D10(a1 + 8, &v10, (uint64_t)&v10);
  uint64_t v30 = (void **)&v26;
  sub_1000129D4(&v30);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v18) < 0) {
    operator delete((void *)v17);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete((void *)v15);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(v12);
  }
  uint64_t v30 = (void **)&v6;
  sub_1000129D4(&v30);
  if (sub_1004FAACC())
  {
    DWORD1(v4) = 0;
    LOBYTE(v4) = 0;
    *((void *)&v4 + 1) = 0x402E000000000000LL;
    LOBYTE(sub_1012279C0(0LL, v4, v5) = 1;
    *((void *)&v5 + 1) = 0x4072C00000000000LL;
    int v10 = 1;
    int v11 = 1;
    size_t v12 = 0LL;
    uint64_t v13 = 0LL;
    __int128 v15 = 0u;
    uint64_t v14 = 0LL;
    uint64_t v16 = 0LL;
    __int128 v17 = 0uLL;
    __int128 v19 = v4;
    __int128 v20 = v5;
    uint64_t v18 = 0LL;
    uint64_t v21 = 0x4034000000000000LL;
    std::stringbuf::string_type __p = 0LL;
    uint64_t v23 = 0LL;
    uint64_t v24 = 0LL;
    char v25 = 1;
    uint64_t v26 = 0LL;
    uint64_t v27 = 0LL;
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    uint64_t v9 = 0x4018000000000000LL;
    uint64_t v28 = 0LL;
    uint64_t v29 = 0x4018000000000000LL;
    sub_100E51D10(v2, &v10, (uint64_t)&v10);
    uint64_t v30 = (void **)&v26;
    sub_1000129D4(&v30);
    if (SHIBYTE(v24) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v18) < 0) {
      operator delete((void *)v17);
    }
    if (SHIBYTE(v16) < 0) {
      operator delete((void *)v15);
    }
    if (SHIBYTE(v14) < 0) {
      operator delete(v12);
    }
    uint64_t v30 = (void **)&v6;
    sub_1000129D4(&v30);
  }

  return a1;
}

void sub_100E47BAC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34)
{
}

uint64_t sub_100E47BDC(uint64_t a1)
{
  int v3 = (void **)(a1 + 160);
  sub_1000129D4(&v3);
  return a1;
}

uint64_t sub_100E47C54(uint64_t a1)
{
  int v3 = (void **)(a1 + 152);
  sub_1000129D4(&v3);
  return a1;
}

uint64_t sub_100E47CCC(uint64_t a1, int a2, _BYTE *a3, const std::string *a4, const std::string *a5)
{
  HIDWORD(v16) = a2;
  *(_DWORD *)__int128 buf = a2;
  uint64_t v9 = (void *)(a1 + 8);
  if (sub_100781F1C((void *)(a1 + 8), (int *)buf))
  {
    int v10 = sub_100781F1C(v9, (int *)&v16 + 1);
    if (!v10) {
      sub_10000C918("unordered_map::at: key not found");
    }
    return sub_100E46FEC((uint64_t)(v10 + 3), a3, a4, a5);
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    size_t v12 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 67240192;
      int v19 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "#AMLCfg ignoring emergency settings for unexpected inst %{public}d",  buf,  8u);
    }

    BOOL v13 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v13)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      v17[0] = 67240192;
      v17[1] = a2;
      LODWORD(v16) = 8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#AMLCfg ignoring emergency settings for unexpected inst %{public}d",  v17,  v16);
      __int128 v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyAML::Config::updateEmergencySettings(const SimInstance, const AugmentedAction &, const std::stri ng &, const std::string &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100E47EDC(int *a1, int a2)
{
  if (a2 == 255 || *a1 == a2)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    __int128 v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      int v5 = *a1;
      *(_DWORD *)__int128 buf = 67240192;
      int v21 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "#AMLCfg keeping previous active inst %{public}d",  buf,  8u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    int v13 = *a1;
    int v18 = 67240192;
    int v19 = v13;
    double v14 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#AMLCfg keeping previous active inst %{public}d",  &v18,  8);
    size_t v12 = v15;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyAML::Config::updateEmergencySim(const SimInstance)",  "%s\n",  v14);
LABEL_27:
    if (v12 != buf) {
      free(v12);
    }
    return 0LL;
  }

  *(_DWORD *)__int128 buf = a2;
  if (sub_100781F1C((void *)a1 + 1, (int *)buf))
  {
    *a1 = a2;
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    uint64_t v7 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 67240192;
      int v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "#AMLCfg active inst changed to %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v18 = 67240192;
      int v19 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#AMLCfg active inst changed to %{public}d",  &v18,  8);
      __int128 v17 = (uint8_t *)v16;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLEmergencyAML::Config::updateEmergencySim(const SimInstance)",  "%s\n",  v16);
      if (v17 != buf) {
        free(v17);
      }
    }

    return 1LL;
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    uint64_t v8 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 67240192;
      int v21 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "#AMLCfg ignoring unexpected inst %{public}d",  buf,  8u);
    }

    BOOL v9 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v9)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v18 = 67240192;
      int v19 = a2;
      double v10 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#AMLCfg ignoring unexpected inst %{public}d",  &v18,  8);
      size_t v12 = v11;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLEmergencyAML::Config::updateEmergencySim(const SimInstance)",  "%s\n",  v10);
      goto LABEL_27;
    }
  }

  return result;
}

BOOL sub_100E4834C(int *a1)
{
  uint64_t v2 = a1 + 2;
  *(_DWORD *)__int128 buf = *a1;
  if (!sub_100781F1C((void *)a1 + 1, (int *)buf))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    int v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)__int128 buf = 67240192;
      int v26 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "#AMLCfg unexpected inst %{public}d is active",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v8 = *a1;
      v12[0] = 67240192;
      v12[1] = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#AMLCfg unexpected inst %{public}d is active",  v12,  8);
      double v10 = (uint8_t *)v9;
      sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLEmergencyAML::Config::isEnabled()", "%s\n", v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    DWORD1(v18) = 0;
    *(_OWORD *)uint64_t v16 = 0u;
    memset(v17, 0, sizeof(v17));
    LOBYTE(v18) = 0;
    *((void *)&v18 + 1) = 0x402E000000000000LL;
    v19[0] = 1;
    *(_OWORD *)&v19[8] = xmmword_10134F780;
    __int128 v31 = 0u;
    __int128 v33 = *(_OWORD *)&v17[1];
    __int128 v35 = v18;
    v12[0] = *a1;
    char v23 = 1;
    *(_DWORD *)__int128 buf = v12[0];
    int v27 = v12[0];
    uint64_t v28 = 0LL;
    uint64_t v29 = 0LL;
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    int v13 = 0LL;
    uint64_t v30 = 0LL;
    uint64_t v32 = 0LL;
    v16[0] = 0LL;
    v16[1] = 0LL;
    memset(v17, 0, sizeof(v17));
    __int128 v36 = *(_OWORD *)v19;
    uint64_t v34 = 0LL;
    uint64_t v37 = 0x4034000000000000LL;
    std::stringbuf::string_type __p = 0LL;
    uint64_t v39 = 0LL;
    uint64_t v40 = 0LL;
    __int128 v20 = 0LL;
    uint64_t v21 = 0LL;
    uint64_t v22 = 0LL;
    char v41 = 1;
    memset(v42, 0, 24);
    memset(v24, 0, 24);
    void v24[3] = 0x4018000000000000LL;
    v42[3] = 0x4018000000000000LL;
    sub_100E51D10((uint64_t)v2, (int *)buf, (uint64_t)buf);
    int v11 = (void **)v42;
    sub_1000129D4(&v11);
    if (SHIBYTE(v40) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v34) < 0) {
      operator delete((void *)v33);
    }
    if (SHIBYTE(v32) < 0) {
      operator delete((void *)v31);
    }
    if (SHIBYTE(v30) < 0) {
      operator delete(v28);
    }
    int v11 = (void **)v24;
    sub_1000129D4(&v11);
    if (SHIBYTE(v22) < 0) {
      operator delete(v20);
    }
    if (SHIBYTE(v17[3]) < 0) {
      operator delete(v17[1]);
    }
    if (SHIBYTE(v17[0]) < 0) {
      operator delete(v16[0]);
    }
    if (SHIBYTE(v15) < 0) {
      operator delete(v13);
    }
  }

  int v5 = sub_100781F1C(v2, a1);
  if (!v5) {
    sub_10000C918("unordered_map::at: key not found");
  }
  else {
    uint64_t v6 = *((unsigned __int8 *)v5 + 103);
  }
  return v6 != 0;
}

void sub_100E486C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

BOOL sub_100E486EC(int *a1)
{
  uint64_t v2 = a1 + 2;
  *(_DWORD *)__int128 buf = *a1;
  if (!sub_100781F1C((void *)a1 + 1, (int *)buf))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    int v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)__int128 buf = 67240192;
      int v26 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "#AMLCfg unexpected inst %{public}d is active",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v8 = *a1;
      v12[0] = 67240192;
      v12[1] = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#AMLCfg unexpected inst %{public}d is active",  v12,  8);
      double v10 = (uint8_t *)v9;
      sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLEmergencyAML::Config::isAmlOverNasEnabled()", "%s\n", v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    DWORD1(v18) = 0;
    *(_OWORD *)uint64_t v16 = 0u;
    memset(v17, 0, sizeof(v17));
    LOBYTE(v18) = 0;
    *((void *)&v18 + 1) = 0x402E000000000000LL;
    v19[0] = 1;
    *(_OWORD *)&v19[8] = xmmword_10134F780;
    __int128 v31 = 0u;
    __int128 v33 = *(_OWORD *)&v17[1];
    __int128 v35 = v18;
    v12[0] = *a1;
    char v23 = 1;
    *(_DWORD *)__int128 buf = v12[0];
    int v27 = v12[0];
    uint64_t v28 = 0LL;
    uint64_t v29 = 0LL;
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    int v13 = 0LL;
    uint64_t v30 = 0LL;
    uint64_t v32 = 0LL;
    v16[0] = 0LL;
    v16[1] = 0LL;
    memset(v17, 0, sizeof(v17));
    __int128 v36 = *(_OWORD *)v19;
    uint64_t v34 = 0LL;
    uint64_t v37 = 0x4034000000000000LL;
    std::stringbuf::string_type __p = 0LL;
    uint64_t v39 = 0LL;
    uint64_t v40 = 0LL;
    __int128 v20 = 0LL;
    uint64_t v21 = 0LL;
    uint64_t v22 = 0LL;
    char v41 = 1;
    memset(v42, 0, 24);
    memset(v24, 0, 24);
    void v24[3] = 0x4018000000000000LL;
    v42[3] = 0x4018000000000000LL;
    sub_100E51D10((uint64_t)v2, (int *)buf, (uint64_t)buf);
    int v11 = (void **)v42;
    sub_1000129D4(&v11);
    if (SHIBYTE(v40) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v34) < 0) {
      operator delete((void *)v33);
    }
    if (SHIBYTE(v32) < 0) {
      operator delete((void *)v31);
    }
    if (SHIBYTE(v30) < 0) {
      operator delete(v28);
    }
    int v11 = (void **)v24;
    sub_1000129D4(&v11);
    if (SHIBYTE(v22) < 0) {
      operator delete(v20);
    }
    if (SHIBYTE(v17[3]) < 0) {
      operator delete(v17[1]);
    }
    if (SHIBYTE(v17[0]) < 0) {
      operator delete(v16[0]);
    }
    if (SHIBYTE(v15) < 0) {
      operator delete(v13);
    }
  }

  int v5 = sub_100781F1C(v2, a1);
  if (!v5) {
    sub_10000C918("unordered_map::at: key not found");
  }
  else {
    uint64_t v6 = *((unsigned __int8 *)v5 + 167);
  }
  return v6 != 0;
}

void sub_100E48A68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

BOOL sub_100E48A8C(int *a1)
{
  uint64_t v2 = a1 + 2;
  *(_DWORD *)__int128 buf = *a1;
  if (!sub_100781F1C((void *)a1 + 1, (int *)buf))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    int v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)__int128 buf = 67240192;
      int v25 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "#AMLCfg unexpected inst %{public}d is active",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v7 = *a1;
      v11[0] = 67240192;
      v11[1] = v7;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#AMLCfg unexpected inst %{public}d is active",  v11,  8);
      BOOL v9 = (uint8_t *)v8;
      sub_10029211C("Generic", 1LL, 0, 0LL, "BOOL CLEmergencyAML::Config::isAmlOverSatDisabled()", "%s\n", v8);
      if (v9 != buf) {
        free(v9);
      }
    }

    DWORD1(v17) = 0;
    *(_OWORD *)uint64_t v15 = 0u;
    memset(v16, 0, sizeof(v16));
    LOBYTE(v17) = 0;
    *((void *)&v17 + 1) = 0x402E000000000000LL;
    v18[0] = 1;
    *(_OWORD *)&v18[8] = xmmword_10134F780;
    __int128 v30 = 0u;
    __int128 v32 = *(_OWORD *)&v16[1];
    __int128 v34 = v17;
    v11[0] = *a1;
    char v22 = 1;
    *(_DWORD *)__int128 buf = v11[0];
    int v26 = v11[0];
    int v27 = 0LL;
    uint64_t v28 = 0LL;
    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    size_t v12 = 0LL;
    uint64_t v29 = 0LL;
    uint64_t v31 = 0LL;
    v15[0] = 0LL;
    v15[1] = 0LL;
    memset(v16, 0, sizeof(v16));
    __int128 v35 = *(_OWORD *)v18;
    uint64_t v33 = 0LL;
    uint64_t v36 = 0x4034000000000000LL;
    std::stringbuf::string_type __p = 0LL;
    uint64_t v38 = 0LL;
    uint64_t v39 = 0LL;
    int v19 = 0LL;
    uint64_t v20 = 0LL;
    uint64_t v21 = 0LL;
    char v40 = 1;
    memset(v41, 0, 24);
    memset(v23, 0, 24);
    double v23[3] = 0x4018000000000000LL;
    v41[3] = 0x4018000000000000LL;
    sub_100E51D10((uint64_t)v2, (int *)buf, (uint64_t)buf);
    double v10 = (void **)v41;
    sub_1000129D4(&v10);
    if (SHIBYTE(v39) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v33) < 0) {
      operator delete((void *)v32);
    }
    if (SHIBYTE(v31) < 0) {
      operator delete((void *)v30);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete(v27);
    }
    double v10 = (void **)v23;
    sub_1000129D4(&v10);
    if (SHIBYTE(v21) < 0) {
      operator delete(v19);
    }
    if (SHIBYTE(v16[3]) < 0) {
      operator delete(v16[1]);
    }
    if (SHIBYTE(v16[0]) < 0) {
      operator delete(v15[0]);
    }
    if (SHIBYTE(v14) < 0) {
      operator delete(v12);
    }
  }

  int v5 = sub_100781F1C(v2, a1);
  if (!v5) {
    sub_10000C918("unordered_map::at: key not found");
  }
  return *((_BYTE *)v5 + 168) == 0;
}

void sub_100E48DF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

uint64_t *sub_100E48E1C(int *a1)
{
  uint64_t v2 = a1 + 2;
  *(_DWORD *)__int128 buf = *a1;
  if (!sub_100781F1C((void *)a1 + 1, (int *)buf))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    int v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      int v4 = *a1;
      *(_DWORD *)__int128 buf = 67240192;
      int v25 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "#AMLCfg AML config for inst %{public}d wasn't created on construction",  buf,  8u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v7 = *a1;
      v11[0] = 67240192;
      v11[1] = v7;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#AMLCfg AML config for inst %{public}d wasn't created on construction",  v11,  8);
      BOOL v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "const CLEmergencyAML::SimConfig &CLEmergencyAML::Config::getSimConfig()",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }

    DWORD1(v17) = 0;
    *(_OWORD *)uint64_t v15 = 0u;
    memset(v16, 0, sizeof(v16));
    LOBYTE(v17) = 0;
    *((void *)&v17 + 1) = 0x402E000000000000LL;
    v18[0] = 1;
    *(_OWORD *)&v18[8] = xmmword_10134F780;
    __int128 v30 = 0u;
    __int128 v32 = *(_OWORD *)&v16[1];
    __int128 v34 = v17;
    v11[0] = *a1;
    char v22 = 1;
    *(_DWORD *)__int128 buf = v11[0];
    int v26 = v11[0];
    int v27 = 0LL;
    uint64_t v28 = 0LL;
    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    size_t v12 = 0LL;
    uint64_t v29 = 0LL;
    uint64_t v31 = 0LL;
    v15[0] = 0LL;
    v15[1] = 0LL;
    memset(v16, 0, sizeof(v16));
    __int128 v35 = *(_OWORD *)v18;
    uint64_t v33 = 0LL;
    uint64_t v36 = 0x4034000000000000LL;
    std::stringbuf::string_type __p = 0LL;
    uint64_t v38 = 0LL;
    uint64_t v39 = 0LL;
    int v19 = 0LL;
    uint64_t v20 = 0LL;
    uint64_t v21 = 0LL;
    char v40 = 1;
    memset(v41, 0, 24);
    memset(v23, 0, 24);
    double v23[3] = 0x4018000000000000LL;
    v41[3] = 0x4018000000000000LL;
    sub_100E51D10((uint64_t)v2, (int *)buf, (uint64_t)buf);
    double v10 = (void **)v41;
    sub_1000129D4(&v10);
    if (SHIBYTE(v39) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v33) < 0) {
      operator delete((void *)v32);
    }
    if (SHIBYTE(v31) < 0) {
      operator delete((void *)v30);
    }
    if (SHIBYTE(v29) < 0) {
      operator delete(v27);
    }
    double v10 = (void **)v23;
    sub_1000129D4(&v10);
    if (SHIBYTE(v21) < 0) {
      operator delete(v19);
    }
    if (SHIBYTE(v16[3]) < 0) {
      operator delete(v16[1]);
    }
    if (SHIBYTE(v16[0]) < 0) {
      operator delete(v15[0]);
    }
    if (SHIBYTE(v14) < 0) {
      operator delete(v12);
    }
  }

  int v5 = sub_100781F1C(v2, a1);
  if (!v5) {
    sub_10000C918("unordered_map::at: key not found");
  }
  return v5 + 3;
}

void sub_100E49180( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

uint64_t sub_100E491A4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  int v11 = (std::__shared_weak_count *)a5[1];
  uint64_t v35 = *a5;
  uint64_t v36 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }

  sub_10001A504((uint64_t)v37, a6);
  sub_100F9E19C(a1, a2, 0, a3, (uint64_t)v39, &v35, (uint64_t)v37);
  uint64_t v14 = v38;
  if (v38 == v37)
  {
    uint64_t v15 = 4LL;
    uint64_t v14 = v37;
    goto LABEL_8;
  }

  if (v38)
  {
    uint64_t v15 = 5LL;
LABEL_8:
    (*(void (**)(void))(*v14 + 8 * v15))();
  }

  uint64_t v16 = v36;
  if (v36)
  {
    __int128 v17 = (unint64_t *)&v36->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  int v19 = v40;
  if (v40 == v39)
  {
    uint64_t v20 = 4LL;
    int v19 = v39;
    goto LABEL_18;
  }

  if (v40)
  {
    uint64_t v20 = 5LL;
LABEL_18:
    (*(void (**)(void))(*v19 + 8 * v20))();
  }

  *(void *)a1 = off_101887E08;
  sub_100E4787C(a1 + 1448);
  sub_1010DDBC0(__p, "#AML state machine");
  uint64_t v31 = a1;
  uint64_t v21 = (std::__shared_weak_count *)operator new(0x20uLL);
  v21->__vftable = (std::__shared_weak_count_vtbl *)&off_101887F10;
  v21->__shared_owners_ = 0LL;
  v21->__shared_weak_owners_ = 0LL;
  v21[1].__vftable = (std::__shared_weak_count_vtbl *)a1;
  __int128 v32 = v21;
  sub_100E520C0(a1 + 1496, (const void **)__p, &v31);
  char v22 = v32;
  if (v32)
  {
    char v23 = (unint64_t *)&v32->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  if (v34 < 0) {
    operator delete(__p[0]);
  }
  *(_OWORD *)(a1 + 1624) = 0u;
  *(_OWORD *)(a1 + 164sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0u;
  *(_DWORD *)(a1 + 1656) = 1065353216;
  *(_WORD *)(a1 + 1664) = 0;
  *(void *)(a1 + 1672) = 0LL;
  *(_DWORD *)(a1 + 168sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0xFFFF;
  *(_OWORD *)(a1 + 1684) = 0u;
  __asm { FMOV            V1.2D, #-1.0 }

  *(_OWORD *)(a1 + 170sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = xmmword_1012E0070;
  *(_OWORD *)(a1 + 1716) = _Q1;
  *(_OWORD *)(a1 + 1732) = _Q1;
  *(_OWORD *)(a1 + 1748) = _Q1;
  *(_DWORD *)(a1 + 1764) = 0;
  *(void *)(a1 + 1768) = 0xBFF0000000000000LL;
  *(_OWORD *)(a1 + 1776) = 0u;
  *(_DWORD *)(a1 + 1792) = 0;
  *(void *)(a1 + 1796) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 1804) = 0x7FFFFFFF;
  *(_BYTE *)(a1 + 1832) = 0;
  *(void *)(a1 + 1824) = 0LL;
  *(_OWORD *)(a1 + 1808) = 0u;
  sub_100869DC8(a1 + 1840);
  *(_OWORD *)(a1 + 248sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0u;
  *(void *)(a1 + 2496) = 0xBF80000000000009LL;
  *(_BYTE *)(a1 + 2504) = 0;
  *(void *)(a1 + 2512) = 0LL;
  *(_BYTE *)(a1 + 1616) = 0;
  sub_100E495FC(a1 + 1496, 0, (uint64_t *)sub_100E498E4, 0LL);
  sub_100E495FC(a1 + 1496, 1, (uint64_t *)sub_100E49EC4, 0LL);
  sub_100E495FC(a1 + 1496, 2, (uint64_t *)sub_100E4A4A4, 0LL);
  sub_100E495FC(a1 + 1496, 3, (uint64_t *)sub_100E4A9AC, 0LL);
  *(void *)(a1 + 1576) = objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "silo", v31), "queue");
  *(_DWORD *)(a1 + 150sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  *(_BYTE *)(a1 + 1544) = 1;
  sub_100E4B444(a1 + 1496, 0LL);
  *(void *)(a1 + 2512) =  objc_msgSend( objc_msgSend(*(id *)(a1 + 8), "vendor"),  "proxyForService:",  @"CLAnalyticsLogger");
  return a1;
}

void sub_100E494E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  sub_100E51C28(v26 + 1456);
  sub_100F9E660(v26);
  _Unwind_Resume(a1);
}

uint64_t **sub_100E495FC(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4)
{
  int v22 = a2;
  if (a4 & 1 | (unint64_t)a3)
  {
    int v4 = a4;
    int v5 = a3;
    unsigned int v7 = a2;
    uint64_t v6 = a1;
    if (qword_101934880 == -1) {
      goto LABEL_3;
    }
  }

  else
  {
    sub_101273974(qword_101934880 == -1);
    __break(1u);
  }

  dispatch_once(&qword_101934880, &stru_101887F60);
LABEL_3:
  int v8 = (os_log_s *)qword_101934888;
  os_log_type_t v9 = *(_BYTE *)(v6 + 120);
  if (os_log_type_enabled((os_log_t)qword_101934888, v9))
  {
    double v10 = (void *)(v6 + 96);
    if (v7 > 3) {
      int v11 = "StateUnknown";
    }
    else {
      int v11 = (&off_101887FD8)[v7];
    }
    sub_1010DDBC0(__p, v11);
    if (SBYTE3(v27) >= 0) {
      size_t v12 = __p;
    }
    else {
      size_t v12 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int128 buf = 136315650;
    *(void *)&uint8_t buf[4] = v10;
    __int16 v29 = 1024;
    unsigned int v30 = v7;
    __int16 v31 = 2080;
    __int128 v32 = v12;
    _os_log_impl((void *)&_mh_execute_header, v8, v9, "%sstate,%d,%s", buf, 0x1Cu);
    if (SBYTE3(v27) < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_101887F60);
    }
    uint64_t v14 = (void *)(v6 + 96);
    uint64_t v15 = qword_101934888;
    uint64_t v16 = *(unsigned __int8 *)(v6 + 120);
    sub_100E4AF14(v7, v20);
    if (v21 >= 0) {
      __int128 v17 = v20;
    }
    else {
      __int128 v17 = (void **)v20[0];
    }
    *(_DWORD *)std::stringbuf::string_type __p = 136315650;
    *(void *)&__p[4] = v14;
    __int16 v24 = 1024;
    unsigned int v25 = v7;
    __int16 v26 = 2080;
    int v27 = v17;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  v16,  "%sstate,%d,%s",  __p,  28,  (const char *)v20[0]);
    int v19 = v18;
    if (v21 < 0) {
      operator delete(v20[0]);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStateMachine<CLEmergencyAML>::setStateHandler(State, StateHandler) [T = CLEmergencyAML]",  "%s\n",  v19);
    if (v19 != buf) {
      free(v19);
    }
  }

  *(void *)__int128 buf = &v22;
  BOOL result = sub_100783544((uint64_t **)(v6 + 8), &v22, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
  result[5] = v5;
  result[6] = v4;
  return result;
}

uint64_t sub_100E498E4(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 2:
    case 3:
    case 9:
    case 10:
      return sub_100E4CC1C(a1);
    case 5:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v4 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#Warning #AML SendFixTimeout fired while Disabled",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 0LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      v17[0] = 0;
      double v5 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML SendFixTimeout fired while Disabled",  v17,  2);
      unsigned int v7 = v6;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyAML::State CLEmergencyAML::handler_Disabled(CLEmergencyAML::Event)",  "%s\n",  v5);
      goto LABEL_43;
    case 6:
      if (!*(void *)(a1 + 1648))
      {
        sub_100F9F0DC(a1);
        sub_100E4D264(a1);
        sub_100E4D614(a1 + 1496, 7);
      }

      return 0LL;
    case 7:
      if (*(void *)(a1 + 1648))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        int v8 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#AML SMS Notification Timeout. Submit AWD report with failure",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101887EC0);
          }
          v17[0] = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML SMS Notification Timeout. Submit AWD report with failure",  v17,  2);
          uint64_t v14 = (uint8_t *)v13;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyAML::State CLEmergencyAML::handler_Disabled(CLEmergencyAML::Event)",  "%s\n",  v13);
          if (v14 != buf) {
            free(v14);
          }
        }

        sub_100F9F0DC(a1);
        sub_100E4D264(a1);
        sub_100E5244C(a1 + 1624);
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        double v10 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "#AML SMS Notification timer timedout when no notifications were expected",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101887EC0);
          }
          v17[0] = 0;
          double v15 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#AML SMS Notification timer timedout when no notifications were expected",  v17,  2);
          unsigned int v7 = v16;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyAML::State CLEmergencyAML::handler_Disabled(CLEmergencyAML::Event)",  "%s\n",  v15);
LABEL_43:
          if (v7 != buf) {
            free(v7);
          }
        }
      }

      return 0LL;
    case 8:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      os_log_type_t v9 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning #AML SessionAssertReleased fired in Disabled state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        v17[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML SessionAssertReleased fired in Disabled state",  v17,  2);
        size_t v12 = (uint8_t *)v11;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyAML::State CLEmergencyAML::handler_Disabled(CLEmergencyAML::Event)",  "%s\n",  v11);
        if (v12 != buf) {
          free(v12);
        }
      }

      sub_100F9E9FC(a1, 0LL);
      return 0LL;
    default:
      return 0LL;
  }

uint64_t sub_100E49EC4(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 2:
    case 3:
    case 9:
    case 10:
      return sub_100E4CC1C(a1);
    case 5:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v4 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#Warning #AML SendFixTimeout fired while Idle",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      v17[0] = 0;
      double v5 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML SendFixTimeout fired while Idle",  v17,  2);
      unsigned int v7 = v6;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyAML::State CLEmergencyAML::handler_Idle(CLEmergencyAML::Event)",  "%s\n",  v5);
      goto LABEL_43;
    case 6:
      if (!*(void *)(a1 + 1648))
      {
        sub_100F9F0DC(a1);
        sub_100E4D264(a1);
        sub_100E4D614(a1 + 1496, 7);
      }

      return 1LL;
    case 7:
      if (*(void *)(a1 + 1648))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        int v8 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#AML SMS Notification Timeout. Submit AWD report with failure",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101887EC0);
          }
          v17[0] = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML SMS Notification Timeout. Submit AWD report with failure",  v17,  2);
          uint64_t v14 = (uint8_t *)v13;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyAML::State CLEmergencyAML::handler_Idle(CLEmergencyAML::Event)",  "%s\n",  v13);
          if (v14 != buf) {
            free(v14);
          }
        }

        sub_100F9F0DC(a1);
        sub_100E4D264(a1);
        sub_100E5244C(a1 + 1624);
      }

      else
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        double v10 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "#AML SMS Notification timer timedout when no notifications were expected",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101887EC0);
          }
          v17[0] = 0;
          double v15 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#AML SMS Notification timer timedout when no notifications were expected",  v17,  2);
          unsigned int v7 = v16;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLEmergencyAML::State CLEmergencyAML::handler_Idle(CLEmergencyAML::Event)",  "%s\n",  v15);
LABEL_43:
          if (v7 != buf) {
            free(v7);
          }
        }
      }

      return 1LL;
    case 8:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      os_log_type_t v9 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning #AML SessionAssertReleased fired in Idle state",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        v17[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML SessionAssertReleased fired in Idle state",  v17,  2);
        size_t v12 = (uint8_t *)v11;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyAML::State CLEmergencyAML::handler_Idle(CLEmergencyAML::Event)",  "%s\n",  v11);
        if (v12 != buf) {
          free(v12);
        }
      }

      sub_100F9E9FC(a1, 0LL);
      return 1LL;
    default:
      return 1LL;
  }

uint64_t sub_100E4A4A4(uint64_t a1, int a2)
{
  uint64_t v2 = 2LL;
  switch(a2)
  {
    case 0:
      sub_100E4DAA4(a1, 0);
      return v2;
    case 1:
      sub_100E4DE2C(a1);
      return v2;
    case 2:
      sub_100E4E01C(a1);
      return v2;
    case 3:
      uint64_t v5 = sub_100E4CC1C(a1);
      uint64_t v2 = v5;
      if (v5 > 1)
      {
        if ((_DWORD)v5 == 3)
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101887EC0);
          }
          unint64_t v13 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "#AML SessionOverNAS transition in emergency state",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_101887EC0);
            }
            LOWORD(v16[0]) = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#AML SessionOverNAS transition in emergency state",  v16,  2);
            double v15 = (uint8_t *)v14;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyAML::State CLEmergencyAML::handler_Session(CLEmergencyAML::Event)",  "%s\n",  v14);
            if (v15 != buf) {
              free(v15);
            }
          }

          return 3LL;
        }
      }

      else if (*(_BYTE *)(a1 + 184))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        uint64_t v6 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#AML delaying Session Exit due to session assertion",  buf,  2u);
        }

        uint64_t v2 = 2LL;
        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101887EC0);
          }
          LOWORD(v16[0]) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML delaying Session Exit due to session assertion",  v16,  2,  v16[0]);
LABEL_26:
          os_log_type_t v9 = (uint8_t *)v7;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyAML::State CLEmergencyAML::handler_Session(CLEmergencyAML::Event)",  "%s\n",  v7);
          if (v9 != buf) {
            free(v9);
          }
          return 2LL;
        }
      }

      else
      {
        sub_100F9F078(a1, (unsigned int *)(a1 + 340), 10LL);
        sub_100E4C88C(a1, (unsigned int *)(a1 + 2496), 7u);
      }

      return v2;
    case 4:
      return v2;
    case 5:
LABEL_5:
      sub_100E4EB40(a1, 0);
      sub_100E4F4E8(a1);
      return v2;
    case 7:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v8 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Warning #AML SMS Timeout while in Session. Ignoring it",  buf,  2u);
      }

      uint64_t v2 = 2LL;
      if (!sub_1002921D0(115, 2)) {
        return v2;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      LOWORD(v16[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML SMS Timeout while in Session. Ignoring it",  v16,  2,  v16[0]);
      goto LABEL_26;
    case 8:
      sub_100F9E9FC(a1, 0LL);
      uint64_t v2 = sub_100E4CC1C(a1);
      if ((_DWORD)v2 != 2)
      {
        uint64_t v10 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 10LL);
        unsigned int v11 = sub_100E5167C(v10, *(_DWORD *)(a1 + 2496));
        int v12 = *(_DWORD *)(a1 + 2496);
        if (v11 >= 0xFFFFFFFD) {
          int v12 = 7;
        }
        *(_DWORD *)(a1 + 2496) = v12;
      }

      return v2;
    case 9:
    case 10:
      return sub_100E4CC1C(a1);
    default:
      return v2;
  }

uint64_t sub_100E4A9AC(uint64_t a1, int a2)
{
  uint64_t v2 = 3LL;
  switch(a2)
  {
    case 0:
      sub_100E4DAA4(a1, 1);
      return v2;
    case 1:
      sub_100E4DE2C(a1);
      return v2;
    case 2:
      sub_100E4E01C(a1);
      return v2;
    case 3:
      uint64_t v5 = sub_100E4CC1C(a1);
      uint64_t v2 = v5;
      if (v5 > 1)
      {
        if ((_DWORD)v5 == 2)
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101887EC0);
          }
          os_log_type_t v9 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "#AML Session transition in emergency state",  buf,  2u);
          }

          uint64_t v2 = 2LL;
          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_101887EC0);
            }
            LOWORD(v13[0]) = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#AML Session transition in emergency state",  v13,  2);
            unsigned int v11 = (uint8_t *)v10;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyAML::State CLEmergencyAML::handler_SessionOverNAS(CLEmergencyAML::Event)",  "%s\n",  v10);
            if (v11 != buf) {
              free(v11);
            }
            return 2LL;
          }
        }
      }

      else if (*(_BYTE *)(a1 + 184))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        uint64_t v6 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#AML delaying Session Exit due to session assertion",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101887EC0);
          }
          LOWORD(v13[0]) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML delaying Session Exit due to session assertion",  v13,  2,  v13[0]);
LABEL_41:
          int v12 = (uint8_t *)v7;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEmergencyAML::State CLEmergencyAML::handler_SessionOverNAS(CLEmergencyAML::Event)",  "%s\n",  v7);
          if (v12 != buf) {
            free(v12);
          }
        }

        return 3LL;
      }

      else
      {
        sub_100F9F078(a1, (unsigned int *)(a1 + 340), 10LL);
        sub_100E4C88C(a1, (unsigned int *)(a1 + 2496), 7u);
      }

      return v2;
    case 4:
      return v2;
    case 5:
LABEL_5:
      sub_100E4EB40(a1, 1);
      sub_100E4F4E8(a1);
      return v2;
    case 7:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v8 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#Warning #AML SMS Timeout while in Session. Ignoring it",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 3LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      LOWORD(v13[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML SMS Timeout while in Session. Ignoring it",  v13,  2,  v13[0]);
      goto LABEL_41;
    case 8:
      sub_100F9E9FC(a1, 0LL);
      return v2;
    case 9:
    case 10:
      return sub_100E4CC1C(a1);
    default:
      return v2;
  }

uint64_t sub_100E4AE74(uint64_t a1)
{
  *(void *)a1 = off_101887E08;

  *(void *)(a1 + 2512) = 0LL;
  sub_10000AE14(a1 + 2360);
  sub_100E52394(a1 + 1624);
  sub_100E522B0(a1 + 1496);
  sub_100E51C28(a1 + 1456);
  return sub_100F9E660(a1);
}

void sub_100E4AED4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E4AE74(a1);
  operator delete(v1);
}

void *sub_100E4AEE8@<X0>(unsigned int a1@<W0>, void *a2@<X8>)
{
  if (a1 > 0xA) {
    uint64_t v2 = "EventUnknown";
  }
  else {
    uint64_t v2 = (&off_101887F80)[a1];
  }
  return sub_1010DDBC0(a2, v2);
}

void *sub_100E4AF14@<X0>(unsigned int a1@<W0>, void *a2@<X8>)
{
  if (a1 > 3) {
    uint64_t v2 = "StateUnknown";
  }
  else {
    uint64_t v2 = (&off_101887FD8)[a1];
  }
  return sub_1010DDBC0(a2, v2);
}

void sub_100E4AF40(uint64_t a1)
{
  uint64_t v1 = (int *)(a1 + 1448);
  uint64_t v2 = sub_100E48E1C((int *)(a1 + 1448));
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  int v3 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v4 = sub_100E4834C(v1);
    int v5 = *(_DWORD *)v2;
    if (*((char *)v2 + 55) < 0)
    {
      sub_1010DD48C(__dst, (void *)v2[4], v2[5]);
    }

    else
    {
      *(_OWORD *)std::string __dst = *((_OWORD *)v2 + 2);
      uint64_t v19 = v2[6];
    }

    if (v19 >= 0) {
      uint64_t v6 = __dst;
    }
    else {
      uint64_t v6 = (void **)__dst[0];
    }
    if (*((char *)v2 + 31) < 0)
    {
      sub_1010DD48C(v16, (void *)v2[1], v2[2]);
    }

    else
    {
      *(_OWORD *)uint64_t v16 = *(_OWORD *)(v2 + 1);
      uint64_t v17 = v2[3];
    }

    if (v17 >= 0) {
      unsigned int v7 = v16;
    }
    else {
      unsigned int v7 = (void **)v16[0];
    }
    if (*((char *)v2 + 79) < 0)
    {
      sub_1010DD48C(v14, (void *)v2[7], v2[8]);
    }

    else
    {
      *(_OWORD *)uint64_t v14 = *(_OWORD *)(v2 + 7);
      uint64_t v15 = v2[9];
    }

    if (v15 >= 0) {
      int v8 = v14;
    }
    else {
      int v8 = (void **)v14[0];
    }
    int v9 = *((unsigned __int8 *)v2 + 80);
    int v10 = *((_DWORD *)v2 + 21);
    if (*((char *)v2 + 143) < 0)
    {
      sub_1010DD48C(__p, (void *)v2[15], v2[16]);
    }

    else
    {
      *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)(v2 + 15);
      uint64_t v13 = v2[17];
    }

    unsigned int v11 = __p;
    if (v13 < 0) {
      unsigned int v11 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 68291075;
    int v21 = 0;
    __int16 v22 = 2082;
    char v23 = "";
    __int16 v24 = 1026;
    BOOL v25 = v4;
    __int16 v26 = 1026;
    int v27 = v5;
    __int16 v28 = 2082;
    __int16 v29 = v6;
    __int16 v30 = 2082;
    __int16 v31 = v7;
    __int16 v32 = 2081;
    uint64_t v33 = v8;
    __int16 v34 = 1025;
    int v35 = v9;
    __int16 v36 = 1025;
    int v37 = v10;
    __int16 v38 = 2081;
    uint64_t v39 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AML logging current settings, enabled:%{public}d, inst:%{public}d, bundle ID :%{public, location:escape_only}s, bundle version:%{public, location:escape_only}s, sms address:%{private, location:escape_only}s, binary:%{private}d, port:%{private}d, SMS over NAS Destination address:%{priv ate, location:escape_only}s}",  buf,  0x52u);
    if (SHIBYTE(v13) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v15) < 0) {
      operator delete(v14[0]);
    }
    if (SHIBYTE(v17) < 0) {
      operator delete(v16[0]);
    }
    if (SHIBYTE(v19) < 0) {
      operator delete(__dst[0]);
    }
  }

void sub_100E4B1EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E4B240(uint64_t a1, __int128 *a2)
{
  int v3 = (unsigned int *)(a1 + 112);
  __int128 v4 = *a2;
  *(_DWORD *)(a1 + 128) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 112) = v4;
  sub_100F9EF4C(a1);
  int v5 = sub_100496E10(v3);
  if (sub_100E47EDC((int *)(a1 + 1448), v5))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    uint64_t v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67240192;
      int v12 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#AML active inst changed to %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      v10[0] = 67240192;
      v10[1] = v5;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML active inst changed to %{public}d",  v10,  8);
      int v9 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLEmergencyAML::handleEmergencyStateChange(CLEmergencyState)",  "%s\n",  v8);
      if (v9 != buf) {
        free(v9);
      }
    }

    (*(void (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
    sub_100E4B444(a1 + 1496, 2LL);
  }

  return sub_100E4B444(a1 + 1496, 3LL);
}

uint64_t sub_100E4B444(uint64_t a1, uint64_t a2)
{
  unsigned int v105 = *(_DWORD *)(a1 + 4);
  if (!*(void *)(a1 + 32))
  {
    sub_101273AE8();
    goto LABEL_169;
  }

  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (!*(_BYTE *)(a1 + 48))
  {
    sub_101273C58(qword_101934880 == -1);
    goto LABEL_169;
  }

  if (qword_101934880 != -1) {
    dispatch_once(&qword_101934880, &stru_101887F60);
  }
  int v5 = (os_log_s *)qword_101934888;
  os_log_type_t v6 = *(_BYTE *)(a1 + 120);
  if (os_log_type_enabled((os_log_t)qword_101934888, v6))
  {
    unsigned int v7 = (void *)(a1 + 96);
    uint64_t v8 = *(int *)(a1 + 4);
    else {
      int v9 = (&off_101887FD8)[v8];
    }
    sub_1010DDBC0(__p, v9);
    int v10 = SHIBYTE(v109);
    unsigned int v11 = *(_BYTE **)__p;
    sub_100E4AEE8(a2, v116);
    int v12 = __p;
    if (v10 < 0) {
      int v12 = v11;
    }
    if (v119 >= 0) {
      uint64_t v13 = v116;
    }
    else {
      uint64_t v13 = *(_BYTE **)v116;
    }
    *(_DWORD *)__int128 buf = 136315650;
    *(void *)&uint8_t buf[4] = v7;
    __int16 v112 = 2080;
    __int128 v113 = v12;
    __int16 v114 = 2080;
    std::string::size_type v115 = v13;
    _os_log_impl((void *)&_mh_execute_header, v5, v6, "%scurrent_state,%s,event,%s", buf, 0x20u);
    if (v119 < 0) {
      operator delete(*(void **)v116);
    }
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (SHIBYTE(v109) < 0) {
      operator delete(*(void **)__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_101887F60);
    }
    double v63 = (void *)(a1 + 96);
    uint64_t v64 = qword_101934888;
    uint64_t v65 = *(unsigned __int8 *)(a1 + 120);
    sub_100E4AF14(*(_DWORD *)(a1 + 4), v116);
    int v66 = v119;
    double v67 = *(_BYTE **)v116;
    sub_100E4AEE8(a2, v103);
    __int16 v68 = v116;
    if (v66 < 0) {
      __int16 v68 = v67;
    }
    if (v104 >= 0) {
      double v69 = v103;
    }
    else {
      double v69 = (void **)v103[0];
    }
    *(_DWORD *)std::stringbuf::string_type __p = 136315650;
    *(void *)&__p[4] = v63;
    __int16 v107 = 2080;
    double v108 = v68;
    __int16 v109 = 2080;
    double v110 = v69;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v64,  v65,  "%scurrent_state,%s,event,%s",  __p,  32,  v101);
    double v71 = v70;
    if (v104 < 0) {
      operator delete(v103[0]);
    }
    p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
    if (v119 < 0) {
      operator delete(*(void **)v116);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "State CLStateMachine<CLEmergencyAML>::handleEvent(Event) [T = CLEmergencyAML]",  "%s\n",  v71);
    if (v71 != buf) {
      free(v71);
    }
  }

  uint64_t v14 = *(void *)(a1 + 16);
  if (!v14) {
    goto LABEL_31;
  }
  uint64_t v15 = (uint64_t **)(a1 + 8);
  int v16 = *(_DWORD *)(a1 + 4);
  uint64_t v17 = a1 + 16;
  do
  {
    int v18 = *(_DWORD *)(v14 + 32);
    BOOL v19 = v18 < v16;
    if (v18 >= v16) {
      uint64_t v20 = (uint64_t *)v14;
    }
    else {
      uint64_t v20 = (uint64_t *)(v14 + 8);
    }
    if (!v19) {
      uint64_t v17 = v14;
    }
    uint64_t v14 = *v20;
  }

  while (*v20);
  if (v17 == a1 + 16 || v16 < *(_DWORD *)(v17 + 32))
  {
LABEL_31:
    sub_101273DCC();
    goto LABEL_169;
  }

  __int16 v22 = *(uint64_t (**)(void *, uint64_t))(v17 + 40);
  uint64_t v21 = *(void *)(v17 + 48);
  char v23 = (void *)(*(void *)(a1 + 32) + (v21 >> 1));
  if ((v21 & 1) != 0) {
    __int16 v22 = *(uint64_t (**)(void *, uint64_t))(*v23 + v22);
  }
  uint64_t v24 = v22(v23, a2);
  uint64_t v25 = v24;
  int v102 = v24;
  if (a2 <= 1 && (_DWORD)v24 != v105)
  {
    sub_10127421C();
    goto LABEL_169;
  }

  if (*(_DWORD *)(a1 + 88) >= 2u)
  {
    __int16 v26 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
    {
      int v27 = (void *)(a1 + 96);
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = v27;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "%sNested invocation of state machine",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      __int16 v78 = (void *)(a1 + 96);
      *(_DWORD *)std::stringbuf::string_type __p = 136315138;
      *(void *)&__p[4] = v78;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "%sNested invocation of state machine",  __p);
      __int16 v80 = (char *)v79;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "State CLStateMachine<CLEmergencyAML>::handleEvent(Event) [T = CLEmergencyAML]",  "%s\n",  v79);
      if (v80 != buf) {
        free(v80);
      }
    }
  }

  __int16 v28 = (os_log_s *)qword_101934888;
  os_log_type_t v29 = *(_BYTE *)(a1 + 120);
  if (os_log_type_enabled((os_log_t)qword_101934888, v29))
  {
    __int16 v30 = (void *)(a1 + 96);
    else {
      __int16 v31 = (&off_101887FD8)[(int)v25];
    }
    sub_1010DDBC0(buf, v31);
    if (v114 >= 0) {
      __int16 v32 = buf;
    }
    else {
      __int16 v32 = *(_BYTE **)buf;
    }
    *(_DWORD *)std::stringbuf::string_type __p = 136315394;
    *(void *)&__p[4] = v30;
    __int16 v107 = 2080;
    double v108 = v32;
    _os_log_impl((void *)&_mh_execute_header, v28, v29, "%snewState,%s", __p, 0x16u);
    if (SHIBYTE(v114) < 0) {
      operator delete(*(void **)buf);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    __int16 v72 = (void *)(a1 + 96);
    uint64_t v73 = qword_101934888;
    uint64_t v74 = *(unsigned __int8 *)(a1 + 120);
    sub_100E4AF14(v25, __p);
    if (v109 >= 0) {
      double v75 = __p;
    }
    else {
      double v75 = *(_BYTE **)__p;
    }
    *(_DWORD *)double v116 = 136315394;
    *(void *)&v116[4] = v72;
    __int16 v117 = 2080;
    __int16 v118 = v75;
    LODWORD(v10sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 22;
    _os_log_send_and_compose_impl(2LL, 0LL, buf, 1628LL, &_mh_execute_header, v73, v74, "%snewState,%s", v116, v100);
    int v77 = v76;
    if (SHIBYTE(v109) < 0) {
      operator delete(*(void **)__p);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "State CLStateMachine<CLEmergencyAML>::handleEvent(Event) [T = CLEmergencyAML]",  "%s\n",  v77);
    if (v77 != buf) {
      free(v77);
    }
  }

  if ((_DWORD)v25 != v105)
  {
    uint64_t v33 = (os_log_s *)qword_101934888;
    os_log_type_t v34 = *(_BYTE *)(a1 + 120);
    if (os_log_type_enabled((os_log_t)qword_101934888, v34))
    {
      int v35 = (void *)(a1 + 96);
      if (v105 > 3) {
        __int16 v36 = "StateUnknown";
      }
      else {
        __int16 v36 = (&off_101887FD8)[v105];
      }
      sub_1010DDBC0(__p, v36);
      int v37 = p_vtable;
      int v38 = SHIBYTE(v109);
      uint64_t v39 = *(_BYTE **)__p;
      sub_1010DDBC0(v116, "Exit");
      char v40 = __p;
      if (v38 < 0) {
        char v40 = v39;
      }
      if (v119 >= 0) {
        char v41 = v116;
      }
      else {
        char v41 = *(_BYTE **)v116;
      }
      *(_DWORD *)__int128 buf = 136315650;
      *(void *)&uint8_t buf[4] = v35;
      __int16 v112 = 2080;
      __int128 v113 = v40;
      __int16 v114 = 2080;
      std::string::size_type v115 = v41;
      _os_log_impl((void *)&_mh_execute_header, v33, v34, "%soldState,%s,event,%s", buf, 0x20u);
      if (v119 < 0) {
        operator delete(*(void **)v116);
      }
      p_vtable = v37;
      if (SHIBYTE(v109) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      double v81 = (void *)(a1 + 96);
      uint64_t v82 = qword_101934888;
      uint64_t v83 = *(unsigned __int8 *)(a1 + 120);
      sub_100E4AF14(v105, v116);
      __int16 v84 = p_vtable;
      int v85 = v119;
      __int16 v86 = *(_BYTE **)v116;
      sub_1010DDBC0(v103, "Exit");
      double v87 = v116;
      if (v85 < 0) {
        double v87 = v86;
      }
      if (v104 >= 0) {
        unsigned int v88 = v103;
      }
      else {
        unsigned int v88 = (void **)v103[0];
      }
      *(_DWORD *)std::stringbuf::string_type __p = 136315650;
      *(void *)&__p[4] = v81;
      __int16 v107 = 2080;
      double v108 = v87;
      __int16 v109 = 2080;
      double v110 = v88;
      LODWORD(v10sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v82,  v83,  "%soldState,%s,event,%s",  __p,  v100,  (const char *)(a1 + 8));
      int v90 = v89;
      if (v104 < 0) {
        operator delete(v103[0]);
      }
      p_vtable = v84;
      uint64_t v15 = (uint64_t **)v101;
      if (v119 < 0) {
        operator delete(*(void **)v116);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "State CLStateMachine<CLEmergencyAML>::handleEvent(Event) [T = CLEmergencyAML]",  "%s\n",  v90);
      if (v90 != buf) {
        free(v90);
      }
    }

    uint64_t v42 = *(void *)(a1 + 32);
    *(void *)__int128 buf = &v105;
    int v43 = sub_100783544(v15, (int *)&v105, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
    int v44 = v43[5];
    uint64_t v45 = (uint64_t)v43[6];
    __int16 v46 = (void *)(v42 + (v45 >> 1));
    if ((v45 & 1) != 0) {
      int v44 = *(uint64_t **)(*v46 + v44);
    }
    int v47 = ((uint64_t (*)(void *, uint64_t))v44)(v46, 1LL);
    if (v47 == v105)
    {
      *(_DWORD *)(a1 + 4) = v25;
      int v48 = (os_log_s *)qword_101934888;
      os_log_type_t v49 = *(_BYTE *)(a1 + 120);
      if (os_log_type_enabled((os_log_t)qword_101934888, v49))
      {
        __int16 v50 = (void *)(a1 + 96);
        else {
          uint64_t v51 = (&off_101887FD8)[(int)v25];
        }
        sub_1010DDBC0(__p, v51);
        __int16 v52 = p_vtable;
        int v53 = SHIBYTE(v109);
        __int16 v54 = *(_BYTE **)__p;
        sub_1010DDBC0(v116, "Enter");
        int v55 = __p;
        if (v53 < 0) {
          int v55 = v54;
        }
        if (v119 >= 0) {
          __int16 v56 = v116;
        }
        else {
          __int16 v56 = *(_BYTE **)v116;
        }
        *(_DWORD *)__int128 buf = 136315650;
        *(void *)&uint8_t buf[4] = v50;
        __int16 v112 = 2080;
        __int128 v113 = v55;
        __int16 v114 = 2080;
        std::string::size_type v115 = v56;
        _os_log_impl((void *)&_mh_execute_header, v48, v49, "%snewState,%s,event,%s", buf, 0x20u);
        if (v119 < 0) {
          operator delete(*(void **)v116);
        }
        p_vtable = v52;
        if (SHIBYTE(v109) < 0) {
          operator delete(*(void **)__p);
        }
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        __int128 v91 = (void *)(a1 + 96);
        uint64_t v92 = qword_101934888;
        uint64_t v93 = *(unsigned __int8 *)(a1 + 120);
        sub_100E4AF14(v25, v116);
        int v94 = v119;
        double v95 = *(_BYTE **)v116;
        sub_1010DDBC0(v103, "Enter");
        __int16 v96 = v116;
        if (v94 < 0) {
          __int16 v96 = v95;
        }
        if (v104 >= 0) {
          int v97 = v103;
        }
        else {
          int v97 = (void **)v103[0];
        }
        *(_DWORD *)std::stringbuf::string_type __p = 136315650;
        *(void *)&__p[4] = v91;
        __int16 v107 = 2080;
        double v108 = v96;
        __int16 v109 = 2080;
        double v110 = v97;
        LODWORD(v10sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 32;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v92,  v93,  "%snewState,%s,event,%s",  __p,  v100,  v101);
        std::string::size_type v99 = v98;
        if (v104 < 0) {
          operator delete(v103[0]);
        }
        if (v119 < 0) {
          operator delete(*(void **)v116);
        }
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "State CLStateMachine<CLEmergencyAML>::handleEvent(Event) [T = CLEmergencyAML]",  "%s\n",  v99);
        if (v99 != buf) {
          free(v99);
        }
      }

      uint64_t v57 = *(void *)(a1 + 32);
      *(void *)__int128 buf = &v102;
      __int16 v58 = sub_100783544(v15, &v102, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
      double v59 = v58[5];
      uint64_t v60 = (uint64_t)v58[6];
      double v61 = (void *)(v57 + (v60 >> 1));
      if ((v60 & 1) != 0) {
        double v59 = *(uint64_t **)(*v61 + v59);
      }
      uint64_t v25 = ((uint64_t (*)(void *, void))v59)(v61, 0LL);
      if ((_DWORD)v25 == v102) {
        goto LABEL_101;
      }
      sub_101273F3C();
    }

    else
    {
      sub_1012740AC();
    }

void sub_100E4C1A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
}

void sub_100E4C204(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = *(_DWORD *)(a1 + 1440);
  if (v4 != a4)
  {
    sub_100F9F12C(a1, v4, a4);
    *(_DWORD *)(a1 + 144sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a4;
  }

uint64_t sub_100E4C23C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_100E47CCC( a1 + 1448,  *(_DWORD *)a2,  (_BYTE *)(a2 + 120),  (const std::string *)(a2 + 1064),  (const std::string *)(a2 + 1088));
  if ((_DWORD)v3) {
    sub_100E4B444(a1 + 1496, 2LL);
  }
  return v3;
}

uint64_t *sub_100E4C288(uint64_t a1, int a2, int a3, unsigned int a4, int a5, int a6)
{
  unsigned int v44 = a4;
  unsigned int v11 = (void *)(a1 + 1624);
  BOOL result = sub_10001A29C((void *)(a1 + 1624), &v44);
  uint64_t v13 = result;
  if (result && *(_DWORD *)(a1 + 1448) == a2)
  {
    if (!a3)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      __int16 v26 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 68290050;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)int v48 = 2082;
        *(void *)&v48[2] = "";
        __int16 v49 = 1026;
        int v50 = a2;
        __int16 v51 = 1026;
        unsigned int v52 = v44;
        __int16 v53 = 1026;
        int v54 = a5;
        __int16 v55 = 1026;
        *(_DWORD *)__int16 v56 = a6;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AML received send failure notification, inst:%{public}d, messageID:%{public} d, sendError:%{public}d, modemError:%{public}d}",  buf,  0x2Au);
      }

      *(_DWORD *)(a1 + 352) = a5;
      *(_DWORD *)(a1 + 356) = a6;
      if (sub_100869780((uint64_t)(v13 + 3)))
      {
        uint64_t v27 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 16LL);
        unsigned int v28 = sub_100E5167C(v27, *(_DWORD *)(a1 + 2496));
        int v29 = *(_DWORD *)(a1 + 2496);
        if (v28 >= 4) {
          int v29 = 5;
        }
        *(_DWORD *)(a1 + 2496) = v29;
        ++*(_DWORD *)(a1 + 424);
        ++*(_DWORD *)(a1 + 2484);
      }

      goto LABEL_30;
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    uint64_t v14 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)int v48 = 2082;
      *(void *)&v48[2] = "";
      __int16 v49 = 1026;
      int v50 = a2;
      __int16 v51 = 1026;
      unsigned int v52 = v44;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#AML received send success notification, inst:%{public}d, messageID:%{public}d}",  buf,  0x1Eu);
    }

    if (sub_100869780((uint64_t)(v13 + 3)))
    {
      uint64_t v15 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 0LL);
      int v16 = sub_100E5167C(v15, *(_DWORD *)(a1 + 2496));
      int v17 = *(_DWORD *)(a1 + 2496);
      if (v16) {
        int v17 = 0;
      }
      *(_DWORD *)(a1 + 2496) = v17;
      ++*(_DWORD *)(a1 + 420);
      ++*(_DWORD *)(a1 + 2480);
      sub_100F993A0((uint64_t)(v13 + 3), &v43, &v42);
      double v18 = *(double *)(a1 + 248);
      if (v18 < 0.0 || v18 >= v43)
      {
        double v19 = v42;
        *(double *)(a1 + 248) = v43;
        *(double *)(a1 + 256) = v19;
        sub_1011BA104(a1 + 192, (uint64_t)(v13 + 3));
      }

      float v20 = *(float *)(a1 + 2500);
      if (v20 < 0.0)
      {
        double v21 = *((double *)v13 + 66) - *(double *)(a1 + 176);
        *(_DWORD *)__int128 buf = 89;
        *(_DWORD *)int v48 = (int)v21;
        int v22 = *((_DWORD *)v13 + 30);
        int v54 = 0;
        *(_DWORD *)&v56[2] = 90;
        int v57 = v22;
        int v58 = 0;
        char v40 = 0LL;
        char v41 = 0LL;
        uint64_t v39 = 0LL;
        uint64_t v45 = (void **)&v39;
        char v46 = 0;
        uint64_t v39 = (char *)operator new(0x50uLL);
        char v40 = v39;
        char v41 = v39 + 80;
        char v40 = (_BYTE *)sub_100783D5C((uint64_t)&v41, (uint64_t)buf, (uint64_t)v59, (uint64_t)v39);
        for (uint64_t i = 48LL; i != -32; i -= 40LL)
          sub_10043AFF4((uint64_t)&buf[i]);
        uint64_t v24 = *(void **)(a1 + 2512);
        memset(v38, 0, sizeof(v38));
        sub_10043BC44(v38, (uint64_t)v39, (uint64_t)v40, 0xCCCCCCCCCCCCCCCDLL * ((v40 - v39) >> 3));
        [v24 setMeasurements:sub_100435878(v38)];
        *(void *)__int128 buf = v38;
        sub_10043B844((void ***)buf);
        *(void *)__int128 buf = &v39;
        sub_10043B844((void ***)buf);
        double v25 = v43;
        goto LABEL_27;
      }

      double v30 = v20;
      double v25 = v43;
      if (v43 <= v30)
      {
LABEL_27:
        float v31 = v25;
        *(float *)(a1 + 250sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v31;
        double v32 = *((double *)v13 + 66) - *(double *)(a1 + 176);
        *(_DWORD *)__int128 buf = 91;
        *(_DWORD *)int v48 = (int)v32;
        int v33 = *((_DWORD *)v13 + 30);
        int v54 = 0;
        *(_DWORD *)&v56[2] = 92;
        int v57 = v33;
        int v58 = 0;
        v59[0] = 93;
        *(float *)&v59[2] = v31;
        float v34 = v42;
        v59[8] = 4;
        v59[10] = 94;
        *(float *)&v59[12] = v34;
        v59[18] = 4;
        char v40 = 0LL;
        char v41 = 0LL;
        uint64_t v39 = 0LL;
        uint64_t v45 = (void **)&v39;
        char v46 = 0;
        uint64_t v39 = (char *)operator new(0xA0uLL);
        char v40 = v39;
        char v41 = v39 + 160;
        char v40 = (_BYTE *)sub_100783D5C((uint64_t)&v41, (uint64_t)buf, (uint64_t)&v60, (uint64_t)v39);
        for (uint64_t j = 128LL; j != -32; j -= 40LL)
          sub_10043AFF4((uint64_t)&buf[j]);
        __int16 v36 = *(void **)(a1 + 2512);
        memset(v37, 0, sizeof(v37));
        sub_10043BC44(v37, (uint64_t)v39, (uint64_t)v40, 0xCCCCCCCCCCCCCCCDLL * ((v40 - v39) >> 3));
        [v36 setMeasurements:sub_100435878(v37)];
        *(void *)__int128 buf = v37;
        sub_10043B844((void ***)buf);
        *(void *)__int128 buf = &v39;
        sub_10043B844((void ***)buf);
      }
    }

void sub_100E4C7DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void **a23)
{
  a23 = (void **)&a15;
  sub_10043B844(&a23);
  _Unwind_Resume(a1);
}

uint64_t sub_100E4C88C(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  uint64_t v5 = sub_100E5167C(a1, *a2);
  unsigned int v6 = v5;
  uint64_t result = sub_100E5167C(v5, a3);
  unsigned int v8 = *a2;
  *a2 = v8;
  return result;
}

uint64_t sub_100E4C8D8(uint64_t a1)
{
  return sub_100E4B444(a1 + 1496, 4LL);
}

uint64_t sub_100E4C8E4(uint64_t a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  uint64_t v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#AML handleImsRegStatusChange", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML handleImsRegStatusChange",  v6,  2);
    uint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLEmergencyAML::handleImsRegStatusChange(SimInstance)",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  return sub_100E4B444(a1 + 1496, 9LL);
}

uint64_t sub_100E4CA80(uint64_t a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  uint64_t v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#AML handleSatRegStatusChange", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML handleSatRegStatusChange",  v6,  2);
    uint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLEmergencyAML::handleSatRegStatusChange(SimInstance)",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  return sub_100E4B444(a1 + 1496, 10LL);
}

uint64_t sub_100E4CC1C(uint64_t a1)
{
  uint64_t v2 = (int *)(a1 + 1448);
  uint64_t v3 = sub_100E4834C((int *)(a1 + 1448));
  BOOL v4 = sub_100E486EC(v2);
  BOOL v5 = v4;
  if ((v3 & 1) == 0 && !v4)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    unsigned int v6 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "#AML expectedState returning #1 Disabled",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      v23[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#AML expectedState returning #1 Disabled",  v23,  2);
      float v20 = (uint8_t *)v19;
      sub_10029211C("Generic", 1LL, 0, 2LL, "CLEmergencyAML::State CLEmergencyAML::expectedState()", "%s\n", v19);
      if (v20 != buf) {
        free(v20);
      }
    }

    return 0LL;
  }

  if (sub_1009830E8(a1 + 112))
  {
    BOOL v7 = 1;
  }

  else
  {
    if (!*(_BYTE *)(a1 + 160))
    {
      sub_100983098(a1 + 112);
LABEL_21:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v10 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "#AML expectedState returning #2 Disabled",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        v23[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#AML expectedState returning #2 Disabled",  v23,  2);
        int v12 = (uint8_t *)v11;
        sub_10029211C("Generic", 1LL, 0, 2LL, "CLEmergencyAML::State CLEmergencyAML::expectedState()", "%s\n", v11);
        if (v12 != buf) {
          free(v12);
        }
      }

      return v3;
    }

    BOOL v7 = sub_1009830C8(a1 + 112);
  }

  if (sub_100983098(a1 + 112) || !v7) {
    goto LABEL_21;
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)(a1 + 1448);
  uint64_t v8 = *(void *)(a1 + 56);
  if (!v8) {
    goto LABEL_61;
  }
  if (*(_BYTE *)((*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v8 + 48LL))(v8, buf) + 5)
    && !sub_100E48A8C(v2))
  {
    BOOL v9 = 1;
    if (!v5)
    {
LABEL_34:
      if ((_DWORD)v3 && !sub_100983088(a1 + 112))
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        uint64_t v14 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "#AML expectedState returning Session",  buf,  2u);
        }

        uint64_t v3 = 2LL;
        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101887EC0);
          }
          v23[0] = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#AML expectedState returning Session",  v23,  2);
          int v16 = (uint8_t *)v15;
          sub_10029211C("Generic", 1LL, 0, 2LL, "CLEmergencyAML::State CLEmergencyAML::expectedState()", "%s\n", v15);
          if (v16 != buf) {
            free(v16);
          }
          return 2LL;
        }
      }

      return v3;
    }
  }

  else
  {
    BOOL v9 = sub_100E4F53C(a1);
    if (!v5) {
      goto LABEL_34;
    }
  }

  if (!sub_1009830B8(a1 + 112) || !v9) {
    goto LABEL_34;
  }
  *(_DWORD *)__int128 buf = *(_DWORD *)(a1 + 1448);
  uint64_t v13 = *(void *)(a1 + 56);
  if (!v13) {
LABEL_61:
  }
    sub_100008BDC();
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  int v17 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "#AML expectedState returning SessionOverNAS",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    v23[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#AML expectedState returning SessionOverNAS",  v23,  2);
    int v22 = (uint8_t *)v21;
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLEmergencyAML::State CLEmergencyAML::expectedState()", "%s\n", v21);
    if (v22 != buf) {
      free(v22);
    }
  }

  return 3LL;
}

void sub_100E4D264(uint64_t a1)
{
  if (qword_101934A40 != -1) {
    dispatch_once(&qword_101934A40, &stru_101887EE0);
  }
  uint64_t v2 = (os_log_s *)qword_101934A48;
  if (os_log_type_enabled((os_log_t)qword_101934A48, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "#ca Submit AML Data to CA", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A40 != -1) {
      dispatch_once(&qword_101934A40, &stru_101887EE0);
    }
    LOWORD(v16) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A48,  0LL,  "#ca Submit AML Data to CA",  &v16,  2);
    int v12 = (uint8_t *)v11;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyAML::submitAMLSessionDatatoCA()", "%s\n", v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  int v3 = *(_DWORD *)(a1 + 2488);
  *(_DWORD *)__int128 buf = 95;
  int v21 = v3;
  int v4 = *(_DWORD *)(a1 + 2492);
  int v22 = 0;
  int v23 = 97;
  int v24 = v4;
  int v25 = 0;
  int v5 = *(_DWORD *)(a1 + 2480);
  int v26 = 98;
  int v27 = v5;
  int v6 = *(_DWORD *)(a1 + 2484);
  int v28 = 0;
  int v29 = 99;
  int v30 = v6;
  int v31 = 0;
  int v7 = *(_DWORD *)(a1 + 2496);
  int v32 = 96;
  int v33 = v7;
  LOBYTE(v7) = *(_BYTE *)(a1 + 2504);
  int v34 = 0;
  int v35 = 100;
  char v36 = v7;
  int v37 = 7;
  int v17 = 0LL;
  v18[0] = 0LL;
  int v16 = 0LL;
  v18[2] = &v16;
  char v19 = 0;
  int v16 = (char *)operator new(0xF0uLL);
  int v17 = v16;
  v18[0] = v16 + 240;
  int v17 = (_BYTE *)sub_100783D5C((uint64_t)v18, (uint64_t)buf, (uint64_t)&v38, (uint64_t)v16);
  for (uint64_t i = 208LL; i != -32; i -= 40LL)
    sub_10043AFF4((uint64_t)&buf[i]);
  BOOL v9 = *(void **)(a1 + 2512);
  memset(v15, 0, sizeof(v15));
  sub_10043BC44(v15, (uint64_t)v16, (uint64_t)v17, 0xCCCCCCCCCCCCCCCDLL * ((v17 - v16) >> 3));
  [v9 setMeasurements:sub_100435878(v15)];
  *(void *)__int128 buf = v15;
  sub_10043B844((void ***)buf);
  int v10 = *(void **)(a1 + 2512);
  if (byte_1019A1687 < 0)
  {
    sub_1010DD48C(__p, (void *)xmmword_1019A1670, *((unint64_t *)&xmmword_1019A1670 + 1));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = xmmword_1019A1670;
    uint64_t v14 = unk_1019A1680;
  }

  [v10 submitEvent:sub_1007793B4((__int128 *)__p)];
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  *(void *)__int128 buf = &v16;
  sub_10043B844((void ***)buf);
}

void sub_100E4D58C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26)
{
}

void sub_100E4D614(uint64_t a1, signed int a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  if (!v4) {
    goto LABEL_33;
  }
  uint64_t v5 = a1 + 64;
  do
  {
    signed int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 < a2;
    if (v6 >= a2) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (!v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }

  while (*v8);
  if (v5 != a1 + 64 && *(_DWORD *)(v5 + 32) <= a2 && (BOOL v9 = *(dispatch_source_s **)(v5 + 40)) != 0LL)
  {
    dispatch_source_set_timer(v9, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_101887F60);
    }
    int v10 = (os_log_s *)qword_101934888;
    os_log_type_t v11 = *(_BYTE *)(a1 + 120);
    if (os_log_type_enabled((os_log_t)qword_101934888, v11))
    {
      int v12 = (void *)(a1 + 96);
      sub_100E4AEE8(a2, __p);
      if (v36 >= 0) {
        uint64_t v13 = __p;
      }
      else {
        uint64_t v13 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136315394;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v28 = 2080;
      int v29 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, v11, "%scancel timer,event,%s", buf, 0x16u);
      if (v36 < 0) {
        operator delete(__p[0]);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_101887F60);
      }
      uint64_t v14 = (void *)(a1 + 96);
      uint64_t v15 = qword_101934888;
      uint64_t v16 = *(unsigned __int8 *)(a1 + 120);
      sub_100E4AEE8(a2, buf);
      if (v30 >= 0) {
        int v17 = buf;
      }
      else {
        int v17 = *(_BYTE **)buf;
      }
      int v31 = 136315394;
      int v32 = v14;
      __int16 v33 = 2080;
      int v34 = v17;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v15,  v16,  "%scancel timer,event,%s",  (const char *)&v31,  22);
      char v19 = v18;
      if (v30 < 0) {
        operator delete(*(void **)buf);
      }
LABEL_54:
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStateMachine<CLEmergencyAML>::cancelTimeoutEvent(Event) [T = CLEmergencyAML]",  "%s\n",  v19);
    }
  }

  else
  {
LABEL_33:
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_101887F60);
    }
    float v20 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = (void *)(a1 + 96);
      sub_100E4AEE8(a2, __p);
      if (v36 >= 0) {
        int v22 = __p;
      }
      else {
        int v22 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136315394;
      *(void *)&uint8_t buf[4] = v21;
      __int16 v28 = 2080;
      int v29 = v22;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "#Warning,%s,cancel timer,notFound, event,%s",  buf,  0x16u);
      if (v36 < 0) {
        operator delete(__p[0]);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_101887F60);
      }
      int v23 = (void *)(a1 + 96);
      uint64_t v24 = qword_101934888;
      sub_100E4AEE8(a2, buf);
      if (v30 >= 0) {
        int v25 = buf;
      }
      else {
        int v25 = *(_BYTE **)buf;
      }
      int v31 = 136315394;
      int v32 = v23;
      __int16 v33 = 2080;
      int v34 = v25;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v24,  0LL,  "#Warning,%s,cancel timer,notFound, event,%s",  (const char *)&v31,  22);
      char v19 = v26;
      if (v30 < 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_54;
    }
  }

void sub_100E4DAA4(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 1648))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    uint64_t v4 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#AML Submitting previous session AWD report before starting new session",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      LOWORD(v12) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML Submitting previous session AWD report before starting new session",  &v12,  2);
      int v10 = (uint8_t *)v9;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyAML::processEnterInSessionStates(BOOL)", "%s\n", v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    sub_100F9F0DC(a1);
    sub_100E4D264(a1);
    sub_100E5244C(a1 + 1624);
    sub_100E4D614(a1 + 1496, 7);
  }

  *(CFAbsoluteTime *)(a1 + 168) = CFAbsoluteTimeGetCurrent();
  *(double *)(a1 + 176) = sub_101171D4C();
  *(_WORD *)(a1 + 1664) = 0;
  *(void *)(a1 + 1672) = 0LL;
  sub_100E51908(a1 + 1680);
  sub_100F9EEE8(a1);
  sub_100E5181C(a1 + 2480);
  uint64_t v5 = sub_100E48E1C((int *)(a1 + 1448));
  if (a2)
  {
    sub_100E4FB84(a1 + 1496, 5, *((double *)v5 + 22));
  }

  else
  {
    sub_100E4FB84(a1 + 1496, 5, *((double *)v5 + 11));
    sub_100F9E9FC(a1, 1LL);
    sub_100E4FB84(a1 + 1496, 8, 60.0);
  }

  *(_BYTE *)(a1 + 2504) = a2;
  signed int v6 = sub_100E48E1C((int *)(a1 + 1448));
  sub_100E47714((int *)v6);
  int v7 = sub_100496E10((unsigned int *)(a1 + 112));
  *(_DWORD *)__int128 buf = 79;
  v17[0] = v7;
  v17[6] = 0;
  uint64_t v13 = 0LL;
  v14[0] = 0LL;
  int v12 = 0LL;
  v14[2] = &v12;
  char v15 = 0;
  int v12 = (char *)operator new(0x28uLL);
  uint64_t v13 = v12;
  v14[0] = v12 + 40;
  uint64_t v13 = (_BYTE *)sub_100783D5C((uint64_t)v14, (uint64_t)buf, (uint64_t)&v18, (uint64_t)v12);
  sub_10043AFF4((uint64_t)v17);
  uint64_t v8 = *(void **)(a1 + 2512);
  memset(v11, 0, sizeof(v11));
  sub_10043BC44(v11, (uint64_t)v12, (uint64_t)v13, 0xCCCCCCCCCCCCCCCDLL * ((v13 - v12) >> 3));
  [v8 setMeasurements:sub_100435878(v11)];
  *(void *)__int128 buf = v11;
  sub_10043B844((void ***)buf);
  *(void *)__int128 buf = &v12;
  sub_10043B844((void ***)buf);
}

void sub_100E4DDCC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void **a21)
{
  a21 = (void **)&a15;
  sub_10043B844(&a21);
  _Unwind_Resume(a1);
}

void sub_100E4DE2C(uint64_t a1)
{
  uint64_t v2 = a1 + 1496;
  sub_100E4D614(a1 + 1496, 5);
  sub_100E4D614(v2, 8);
  if (*(_BYTE *)(a1 + 184))
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    int v3 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "#AML session assertion active during Session Exit,clearing",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      v6[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#AML session assertion active during Session Exit,clearing",  v6,  2);
      uint64_t v5 = (uint8_t *)v4;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyAML::processExitInSessionStates()", "%s\n", v4);
      if (v5 != buf) {
        free(v5);
      }
    }

    sub_100F9E9FC(a1, 0LL);
  }

  if (*(void *)(a1 + 1648))
  {
    sub_100E4FB84(v2, 7, 180.0);
  }

  else
  {
    sub_100F9F0DC(a1);
    sub_100E4D264(a1);
  }

uint64_t sub_100E4E01C(uint64_t a1)
{
  uint64_t result = sub_100E4CC1C(a1);
  if (!(_DWORD)result)
  {
    if (sub_1009830E8(a1 + 112))
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v3 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#Warning #AML unexpectedly disabled during active emergency call",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        v8[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML unexpectedly disabled during active emergency call",  v8,  2);
        int v7 = (uint8_t *)v6;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyAML::processConfigChangeInSessionStates()", "%s\n", v6);
        if (v7 != buf) {
          free(v7);
        }
      }
    }

    sub_100F9E9FC(a1, 0LL);
    uint64_t v4 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 14LL);
    uint64_t result = sub_100E5167C(v4, *(_DWORD *)(a1 + 2496));
    int v5 = *(_DWORD *)(a1 + 2496);
    *(_DWORD *)(a1 + 2496) = v5;
  }

  return result;
}

uint64_t sub_100E4E1F8(uint64_t a1)
{
  uint64_t v2 = (int *)(a1 + 1448);
  uint64_t v3 = *(void *)(a1 + 104);
  if (!v3) {
    sub_100008BDC();
  }
  (*(void (**)(_BYTE *__return_ptr))(*(void *)v3 + 48LL))(v30);
  if ((sub_100869780((uint64_t)v30) & 1) == 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    BOOL v9 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning #AML,shouldSendLocation,cached location is invalid",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_22;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    LOWORD(v35) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML,shouldSendLocation,cached location is invalid",  &v35,  2);
    int v7 = (uint8_t *)v24;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyAML::shouldSendLocation()", "%s\n", v24);
    goto LABEL_66;
  }

  if (*(_BYTE *)(a1 + 1665) || (sub_100869780(a1 + 1680) & 1) == 0)
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    int v10 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#AML,shouldSendLocation,sending,last send attempt had no location",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_28;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    LOWORD(v35) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML,shouldSendLocation,sending,last send attempt had no location",  &v35,  2);
    int v21 = (uint8_t *)v25;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyAML::shouldSendLocation()", "%s\n", v25);
    goto LABEL_71;
  }

  double v4 = sub_101171D4C() - *(double *)(a1 + 1672);
  if (v4 >= *((double *)sub_100E48E1C(v2) + 14))
  {
    sub_100F993A0((uint64_t)v30, &v29, &v28);
    sub_100F993A0(a1 + 1680, &v27, &v26);
    if (v27 - v29 >= 20.0)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      char v19 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134349312;
        double v40 = v27;
        __int16 v41 = 2050;
        double v42 = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "#AML,shouldSendLocation,sending,lower hunc,previous,%{public}f,current,%{public}f",  buf,  0x16u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_28;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v35 = 134349312;
      double v36 = v27;
      __int16 v37 = 2050;
      double v38 = v29;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML,shouldSendLocation,sending,lower hunc,previous,%{public}f,current,%{public}f",  &v35,  22);
      int v21 = (uint8_t *)v20;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyAML::shouldSendLocation()", "%s\n", v20);
    }

    else
    {
      char v15 = (double *)(a1 + 1684);
      double v16 = sub_100D2EC74(*v15, v15[1], v31, v32);
      if (v16 < 20.0 || v16 < v15[2] && v16 < v33)
      {
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        int v17 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "#AML,shouldSendLocation,not sending,no significant changes",  buf,  2u);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_22;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        LOWORD(v35) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML,shouldSendLocation,not sending,no significant changes",  &v35,  2);
        int v7 = (uint8_t *)v18;
        sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyAML::shouldSendLocation()", "%s\n", v18);
        goto LABEL_66;
      }

      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v22 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134349056;
        double v40 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "#AML,shouldSendLocation,sending,location changed significantly,dist,%{public}f",  buf,  0xCu);
      }

      if (!sub_1002921D0(115, 2))
      {
LABEL_28:
        uint64_t v8 = 1LL;
        goto LABEL_29;
      }

      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v35 = 134349056;
      double v36 = v16;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML,shouldSendLocation,sending,location changed significantly,dist,%{public}f",  &v35,  12);
      int v21 = (uint8_t *)v23;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyAML::shouldSendLocation()", "%s\n", v23);
    }

void sub_100E4EAF8(_Unwind_Exception *a1)
{
}

void sub_100E4EB40(uint64_t a1, char a2)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1) & 1) != 0
    || ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 152LL))(a1) & 1) != 0)
  {
    *(_DWORD *)__int128 buf = *(_DWORD *)(a1 + 1448);
    uint64_t v4 = *(void *)(a1 + 56);
    if (!v4) {
      sub_100008BDC();
    }
    uint64_t v5 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v4 + 48LL))(v4, buf);
    sub_100F9F038(a1, v5 + 136, a1 + 136);
    *(_DWORD *)__int128 buf = *(_DWORD *)(a1 + 1448);
    uint64_t v6 = *(void *)(a1 + 56);
    if (!v6) {
      sub_100008BDC();
    }
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v6 + 48LL))(v6, buf);
    sub_100E50654(a1, v7 + 136, a1 + 136);
    if ((a2 & 1) != 0) {
      goto LABEL_8;
    }
    *(_DWORD *)__int128 buf = *(_DWORD *)(a1 + 1448);
    uint64_t v8 = *(void *)(a1 + 56);
    if (!v8) {
      sub_100008BDC();
    }
    if (*(_BYTE *)((*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v8 + 48LL))(v8, buf) + 4))
    {
LABEL_8:
      uint64_t v9 = *(void *)(a1 + 104);
      if (!v9) {
        sub_100008BDC();
      }
      (*(void (**)(_OWORD *__return_ptr))(*(void *)v9 + 48LL))(v55);
      sub_100F9EFB4(a1, (uint64_t)v55);
      if (sub_100869780((uint64_t)v55))
      {
        ++*(_DWORD *)(a1 + 412);
        ++*(_DWORD *)(a1 + 2488);
        *(_BYTE *)(a1 + 1665) = 0;
        int v10 = sub_100E5081C(a1, (uint64_t)v55);
      }

      else
      {
        ++*(_DWORD *)(a1 + 416);
        ++*(_DWORD *)(a1 + 2492);
        *(_BYTE *)(a1 + 1665) = 1;
        uint64_t v11 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 2LL);
        unsigned int v12 = sub_100E5167C(v11, *(_DWORD *)(a1 + 2496));
        int v13 = *(_DWORD *)(a1 + 2496);
        if (v12 >= 5) {
          int v13 = 6;
        }
        *(_DWORD *)(a1 + 2496) = v13;
        if (*(_BYTE *)(a1 + 1664))
        {
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101887EC0);
          }
          uint64_t v14 = (os_log_s *)qword_101934898;
          if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#AML not sending no fix message",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934890 != -1) {
              dispatch_once(&qword_101934890, &stru_101887EC0);
            }
            LOWORD(v66) = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML not sending no fix message",  &v66,  2);
            double v16 = (uint8_t *)v15;
            sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyAML::sendLocation(BOOL)", "%s\n", v15);
            if (v16 != buf) {
              free(v16);
            }
          }

          goto LABEL_53;
        }

        int v10 = sub_100E50CB8(a1);
      }

      double v27 = v10;
      *(_BYTE *)(a1 + 1664) = 1;
      *(double *)(a1 + 1672) = sub_101171D4C();
      __int128 v28 = v55[7];
      *(_OWORD *)(a1 + 1776) = v55[6];
      *(_OWORD *)(a1 + 1792) = v28;
      *(_OWORD *)(a1 + 1808) = v56[0];
      __int128 v29 = v55[3];
      *(_OWORD *)(a1 + 1712) = v55[2];
      *(_OWORD *)(a1 + 1728) = v29;
      __int128 v30 = v55[5];
      *(_OWORD *)(a1 + 1744) = v55[4];
      *(_OWORD *)(a1 + 176sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v30;
      __int128 v31 = v55[1];
      *(_OWORD *)(a1 + 168sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v55[0];
      *(_OWORD *)(a1 + 182sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_OWORD *)((char *)v56 + 12);
      *(_OWORD *)(a1 + 1696) = v31;
      memcpy((void *)(a1 + 1840), v57, 0x201uLL);
      sub_1000F2F30((void *)(a1 + 2360), &v58);
      __int128 v32 = *(_OWORD *)v65;
      *(_OWORD *)(a1 + 244sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v64;
      *(_OWORD *)(a1 + 2456) = v32;
      *(void *)(a1 + 2469) = *(void *)&v65[13];
      __int128 v33 = v61;
      *(_OWORD *)(a1 + 2376) = v60;
      *(_OWORD *)(a1 + 2392) = v33;
      __int128 v34 = v63;
      *(_OWORD *)(a1 + 2408) = v62;
      *(_OWORD *)(a1 + 2424) = v34;
      *(_BYTE *)(a1 + 2504) = a2;
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      int v35 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        double v36 = -[NSString UTF8String](v27, "UTF8String");
        *(_DWORD *)__int128 buf = 136380675;
        double v69 = v36;
        _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "#AML preparing to send SMS message: %{private}s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        uint64_t v44 = qword_101934898;
        uint64_t v45 = -[NSString UTF8String](v27, "UTF8String");
        int v66 = 136380675;
        double v67 = v45;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v44,  0LL,  "#AML preparing to send SMS message: %{private}s",  &v66,  12);
        int v47 = (uint8_t *)v46;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyAML::sendLocation(BOOL)", "%s\n", v46);
        if (v47 != buf) {
          free(v47);
        }
      }

      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      __int16 v37 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "#Warning #AML attempting to send AML SMS on a device without CoreTelephony",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        LOWORD(v66) = 0;
        LODWORD(v54) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML attempting to send AML SMS on a device without CoreTelephony",  &v66,  v54);
        __int16 v49 = (uint8_t *)v48;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyAML::sendLocation(BOOL)", "%s\n", v48);
        if (v49 != buf) {
          free(v49);
        }
      }

      uint64_t v38 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 7LL);
      unsigned int v39 = sub_100E5167C(v38, *(_DWORD *)(a1 + 2496));
      int v40 = *(_DWORD *)(a1 + 2496);
      if (v39 > 1) {
        int v40 = 1;
      }
      *(_DWORD *)(a1 + 2496) = v40;
LABEL_53:
      __int16 v41 = v59;
      if (v59)
      {
        p_shared_owners = (unint64_t *)&v59->__shared_owners_;
        do
          unint64_t v43 = __ldaxr(p_shared_owners);
        while (__stlxr(v43 - 1, p_shared_owners));
        if (!v43)
        {
          ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
          std::__shared_weak_count::__release_weak(v41);
        }
      }

      return;
    }

    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    uint64_t v24 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "#AML,sendLocation,roaming not supported",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      LOWORD(v55[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML,sendLocation,roaming not supported",  v55,  2);
      __int16 v53 = (uint8_t *)v52;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLEmergencyAML::sendLocation(BOOL)", "%s\n", v52);
      if (v53 != buf) {
        free(v53);
      }
    }

    uint64_t v25 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 29LL);
    unsigned int v26 = sub_100E5167C(v25, *(_DWORD *)(a1 + 2496));
    float v20 = (int *)(a1 + 2496);
    int v21 = *(_DWORD *)(a1 + 2496);
    BOOL v22 = v26 >= 3;
    int v23 = 4;
  }

  else
  {
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    int v17 = (os_log_s *)qword_101934898;
    if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "#AML attempted to send location when not enabled",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      LOWORD(v55[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  17LL,  "#AML attempted to send location when not enabled",  v55,  2);
      __int16 v51 = (uint8_t *)v50;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyAML::sendLocation(BOOL)", "%s\n", v50);
      if (v51 != buf) {
        free(v51);
      }
    }

    uint64_t v18 = sub_100F9F078(a1, (unsigned int *)(a1 + 340), 12LL);
    unsigned int v19 = sub_100E5167C(v18, *(_DWORD *)(a1 + 2496));
    float v20 = (int *)(a1 + 2496);
    int v21 = *(_DWORD *)(a1 + 2496);
    BOOL v22 = v19 >= 2;
    int v23 = 2;
  }

  if (v22) {
    int v21 = v23;
  }
  int *v20 = v21;
}

void sub_100E4F4B0(_Unwind_Exception *a1)
{
}

void sub_100E4F4E8(uint64_t a1)
{
  uint64_t v2 = (int *)(a1 + 1448);
  if (*((_BYTE *)sub_100E48E1C((int *)(a1 + 1448)) + 96))
  {
    double v3 = *((double *)sub_100E48E1C(v2) + 13);
    sub_100E4FB84(a1 + 1496, 5, v3);
  }

BOOL sub_100E4F53C(uint64_t a1)
{
  LODWORD(v47.__r_.__value_.__l.__data_) = *(_DWORD *)(a1 + 1448);
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    sub_100008BDC();
  }
  uint64_t v3 = (*(uint64_t (**)(uint64_t, std::string *))(*(void *)v2 + 48LL))(v2, &v47);
  uint64_t v4 = sub_100E48E1C((int *)(a1 + 1448));
  uint64_t v42 = 0LL;
  uint64_t v43 = 0LL;
  uint64_t v44 = 0LL;
  sub_10010DEE0((char *)&v42, (__int128 *)v4[19], (__int128 *)v4[20], 0xAAAAAAAAAAAAAAABLL * ((v4[20] - v4[19]) >> 3));
  std::to_string(&v47, *(_DWORD *)(v3 + 8));
  std::to_string(&v39, *(_DWORD *)(v3 + 12));
  if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v5 = &v39;
  }
  else {
    uint64_t v5 = (std::string *)v39.__r_.__value_.__r.__words[0];
  }
  if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type size = v39.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type size = v39.__r_.__value_.__l.__size_;
  }
  uint64_t v7 = std::string::append(&v47, (const std::string::value_type *)v5, size);
  __int128 v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  int64_t cap = v7->__r_.__value_.__l.__cap_;
  *(_OWORD *)std::stringbuf::string_type __p = v8;
  v7->__r_.__value_.__l.__size_ = 0LL;
  v7->__r_.__value_.__l.__cap_ = 0LL;
  v7->__r_.__value_.__r.__words[0] = 0LL;
  std::to_string(&v39, *(_DWORD *)(v3 + 8));
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  uint64_t v9 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    int v10 = __p;
    if (cap < 0) {
      int v10 = (void **)__p[0];
    }
    LODWORD(v47.__r_.__value_.__l.__data_) = 136380675;
    *(std::string::size_type *)((char *)v47.__r_.__value_.__r.__words + 4) = (std::string::size_type)v10;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "#AML current Camped PLMN %{private}s",  (uint8_t *)&v47,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v47, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    __int128 v31 = __p;
    if (cap < 0) {
      __int128 v31 = (void **)__p[0];
    }
    int v45 = 136380675;
    char v46 = v31;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v47,  1628LL,  &_mh_execute_header,  qword_101934898,  2LL,  "#AML current Camped PLMN %{private}s",  &v45,  12);
    __int128 v33 = (std::string *)v32;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLEmergencyAML::isCampedMCCorPLMNMatchWithBundleKey()", "%s\n", v32);
    if (v33 != &v47) {
      free(v33);
    }
  }

  uint64_t v11 = v42;
  if (v43 == v42)
  {
LABEL_56:
    BOOL v19 = 0;
    goto LABEL_64;
  }

  uint64_t v12 = 0LL;
  unint64_t v13 = (v43 - v42) / 24;
  if (cap >= 0) {
    uint64_t v14 = (void *)HIBYTE(cap);
  }
  else {
    uint64_t v14 = __p[1];
  }
  if (cap >= 0) {
    char v15 = __p;
  }
  else {
    char v15 = (void **)__p[0];
  }
  if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type v16 = v39.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type v16 = v39.__r_.__value_.__l.__size_;
  }
  int v17 = &v39;
  if ((v39.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    int v17 = (std::string *)v39.__r_.__value_.__r.__words[0];
  }
  __s2 = v17;
  if (v13 <= 1) {
    uint64_t v18 = 1LL;
  }
  else {
    uint64_t v18 = (v43 - v42) / 24;
  }
  BOOL v19 = 1;
  while (1)
  {
    float v20 = (unsigned __int8 *)(v11 + 24 * v12);
    uint64_t v21 = v20[23];
    size_t v22 = *((void *)v20 + 1);
    if ((v21 & 0x80u) == 0LL) {
      int v23 = (void *)v20[23];
    }
    else {
      int v23 = (void *)*((void *)v20 + 1);
    }
    if (v23 != v14) {
      goto LABEL_45;
    }
    if ((v21 & 0x80) != 0) {
      break;
    }
    if (!v20[23]) {
      goto LABEL_57;
    }
    uint64_t v24 = v15;
    uint64_t v25 = (unsigned __int8 *)(v11 + 24 * v12);
    uint64_t v26 = v20[23];
    while (*v25 == *(unsigned __int8 *)v24)
    {
      ++v25;
      uint64_t v24 = (void **)((char *)v24 + 1);
      if (!--v26) {
        goto LABEL_57;
      }
    }

void sub_100E4FAF8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char *a29, uint64_t a30, int a31, __int16 a32, char a33, char a34)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  a29 = &a24;
  sub_1000129D4((void ***)&a29);
  _Unwind_Resume(a1);
}

void sub_100E4FB84(uint64_t a1, signed int a2, double a3)
{
  unsigned int v50 = a2;
  uint64_t v4 = *(dispatch_queue_s **)(a1 + 80);
  if (!v4)
  {
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_101887F60);
    }
    std::string v39 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_ERROR))
    {
      int v40 = (void *)(a1 + 96);
      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = v40;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "%sInvoking timers without callback queue set",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_101887F60);
      }
      uint64_t v44 = (void *)(a1 + 96);
      *(_DWORD *)std::stringbuf::string_type __p = 136315138;
      *(void *)&__p[4] = v44;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934888,  16LL,  "%sInvoking timers without callback queue set",  __p);
      char v46 = (char *)v45;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLStateMachine<CLEmergencyAML>::setTimeoutEvent(Event, double) [T = CLEmergencyAML]",  "%s\n",  v45);
      if (v46 != buf) {
        free(v46);
      }
    }

    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_101887F60);
    }
    __int16 v41 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = "assert";
      *(_WORD *)&_BYTE buf[28] = 2081;
      *(void *)&buf[30] = "false";
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Assertion failed, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x26u);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_101887F60);
      }
    }

    uint64_t v42 = (os_log_s *)qword_101934888;
    if (os_signpost_enabled((os_log_t)qword_101934888))
    {
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = "assert";
      *(_WORD *)&_BYTE buf[28] = 2081;
      *(void *)&buf[30] = "false";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v42,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Assertion failed",  "{msg%{public}.0s:Assertion failed, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x26u);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_101887F60);
      }
    }

    uint64_t v43 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = "assert";
      *(_WORD *)&_BYTE buf[28] = 2081;
      *(void *)&buf[30] = "false";
      _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Assertion failed, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x26u);
    }

    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/GPS/CLStateMachine.h",  173,  "setTimeoutEvent");
    __break(1u);
  }

  if (a3 < 0.0)
  {
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_101887F60);
    }
    uint64_t v7 = (os_log_s *)qword_101934888;
    if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_FAULT))
    {
      __int128 v8 = (void *)(a1 + 96);
      sub_100E4AEE8(a2, __p);
      if (v58 >= 0) {
        uint64_t v9 = __p;
      }
      else {
        uint64_t v9 = *(_BYTE **)__p;
      }
      *(_DWORD *)__int128 buf = 136315650;
      *(void *)&uint8_t buf[4] = v8;
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = v9;
      *(_WORD *)&buf[22] = 2050;
      *(double *)&_BYTE buf[24] = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "%sCannot start timer, event, %{public}s, timeOutSec, %{public}.2f",  buf,  0x20u);
      if (SHIBYTE(v58) < 0) {
        operator delete(*(void **)__p);
      }
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934880 != -1) {
        dispatch_once(&qword_101934880, &stru_101887F60);
      }
      int v10 = (void *)(a1 + 96);
      uint64_t v11 = qword_101934888;
      sub_100E4AEE8(a2, v51);
      if (v54 >= 0) {
        uint64_t v12 = v51;
      }
      else {
        uint64_t v12 = *(_BYTE **)v51;
      }
      *(_DWORD *)std::stringbuf::string_type __p = 136315650;
      *(void *)&__p[4] = v10;
      __int16 v56 = 2082;
      int v57 = v12;
      __int16 v58 = 2050;
      double v59 = a3;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v11,  17LL,  "%sCannot start timer, event, %{public}s, timeOutSec, %{public}.2f",  __p,  32);
      uint64_t v14 = v13;
      if (v54 < 0) {
        operator delete(*(void **)v51);
      }
LABEL_79:
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLStateMachine<CLEmergencyAML>::setTimeoutEvent(Event, double) [T = CLEmergencyAML]",  "%s\n",  v14);
LABEL_80:
      if (v14 != buf) {
        free(v14);
      }
      return;
    }

    return;
  }

  uint64_t v15 = *(void *)(a1 + 64);
  if (v15)
  {
    uint64_t v16 = a1 + 64;
    do
    {
      signed int v17 = *(_DWORD *)(v15 + 32);
      BOOL v18 = v17 < a2;
      if (v17 >= a2) {
        BOOL v19 = (uint64_t *)v15;
      }
      else {
        BOOL v19 = (uint64_t *)(v15 + 8);
      }
      if (!v18) {
        uint64_t v16 = v15;
      }
      uint64_t v15 = *v19;
    }

    while (*v19);
    if (v16 != a1 + 64 && *(_DWORD *)(v16 + 32) <= a2)
    {
      float v20 = *(dispatch_source_s **)(v16 + 40);
      if (v20)
      {
LABEL_37:
        dispatch_time_t v22 = dispatch_time(0LL, (uint64_t)(a3 * 1000000000.0));
        dispatch_source_set_timer(v20, v22, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
        if (qword_101934880 != -1) {
          dispatch_once(&qword_101934880, &stru_101887F60);
        }
        int v23 = (os_log_s *)qword_101934888;
        os_log_type_t v24 = *(_BYTE *)(a1 + 120);
        if (os_log_type_enabled((os_log_t)qword_101934888, v24))
        {
          uint64_t v25 = (void *)(a1 + 96);
          sub_100E4AEE8(v50, __p);
          if (v58 >= 0) {
            uint64_t v26 = __p;
          }
          else {
            uint64_t v26 = *(_BYTE **)__p;
          }
          *(_DWORD *)__int128 buf = 136315650;
          *(void *)&uint8_t buf[4] = v25;
          *(_WORD *)&_BYTE buf[12] = 2080;
          *(void *)&buf[14] = v26;
          *(_WORD *)&buf[22] = 2048;
          *(double *)&_BYTE buf[24] = a3;
          _os_log_impl((void *)&_mh_execute_header, v23, v24, "%sevent,%s,timeout,%.2f", buf, 0x20u);
          if (SHIBYTE(v58) < 0) {
            operator delete(*(void **)__p);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934880 != -1) {
            dispatch_once(&qword_101934880, &stru_101887F60);
          }
          double v27 = (void *)(a1 + 96);
          uint64_t v28 = qword_101934888;
          uint64_t v29 = *(unsigned __int8 *)(a1 + 120);
          sub_100E4AEE8(v50, v51);
          if (v54 >= 0) {
            __int128 v30 = v51;
          }
          else {
            __int128 v30 = *(_BYTE **)v51;
          }
          *(_DWORD *)std::stringbuf::string_type __p = 136315650;
          *(void *)&__p[4] = v27;
          __int16 v56 = 2080;
          int v57 = v30;
          __int16 v58 = 2048;
          double v59 = a3;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v28,  v29,  "%sevent,%s,timeout,%.2f",  __p,  32,  v47);
          uint64_t v14 = v31;
          if (v54 < 0) {
            operator delete(*(void **)v51);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLStateMachine<CLEmergencyAML>::setTimeoutEvent(Event, double) [T = CLEmergencyAML]",  "%s\n",  v14);
          goto LABEL_80;
        }

        return;
      }
    }
  }

  uint64_t v21 = (uint64_t *)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v4);
  if (v21)
  {
    float v20 = (dispatch_source_s *)v21;
    *(void *)__int128 buf = &v50;
    sub_10000C858((uint64_t **)(a1 + 56), (int *)&v50, (uint64_t)&unk_1012CF090, (_DWORD **)buf)[5] = v21;
    dispatch_source_set_timer(v20, 0xFFFFFFFFFFFFFFFFLL, 0xFFFFFFFFFFFFFFFFLL, 0x1DCD6500uLL);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100E524A0;
    handler[3] = &unk_10182B540;
    handler[4] = a1;
    unsigned int v49 = v50;
    dispatch_source_set_event_handler(v20, handler);
    dispatch_resume(v20);
    goto LABEL_37;
  }

  if (qword_101934880 != -1) {
    dispatch_once(&qword_101934880, &stru_101887F60);
  }
  __int128 v32 = (os_log_s *)qword_101934888;
  if (os_log_type_enabled((os_log_t)qword_101934888, OS_LOG_TYPE_FAULT))
  {
    __int128 v33 = (void *)(a1 + 96);
    sub_100E4AEE8(a2, buf);
    if (buf[23] >= 0) {
      __int128 v34 = buf;
    }
    else {
      __int128 v34 = *(_BYTE **)buf;
    }
    *(_DWORD *)std::stringbuf::string_type __p = 136315394;
    *(void *)&__p[4] = v33;
    __int16 v56 = 2082;
    int v57 = v34;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_FAULT,  "%scannot create timer, event, %{public}s",  __p,  0x16u);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934880 != -1) {
      dispatch_once(&qword_101934880, &stru_101887F60);
    }
    int v35 = (void *)(a1 + 96);
    uint64_t v36 = qword_101934888;
    sub_100E4AEE8(a2, __p);
    if (v58 >= 0) {
      uint64_t v37 = __p;
    }
    else {
      uint64_t v37 = *(_BYTE **)__p;
    }
    *(_DWORD *)__int16 v51 = 136315394;
    *(void *)&v51[4] = v35;
    __int16 v52 = 2082;
    __int16 v53 = v37;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v36,  17LL,  "%scannot create timer, event, %{public}s",  v51,  22);
    uint64_t v14 = v38;
    if (SHIBYTE(v58) < 0) {
      operator delete(*(void **)__p);
    }
    goto LABEL_79;
  }

void sub_100E50654(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(unsigned __int8 *)(a2 + 23);
  if ((v4 & 0x80u) != 0LL) {
    uint64_t v4 = *(void *)(a2 + 8);
  }
  uint64_t v5 = *(unsigned __int8 *)(a3 + 23);
  if ((v5 & 0x80u) != 0LL) {
    uint64_t v5 = *(void *)(a3 + 8);
  }
  BOOL v6 = v5 == 0;
  if (v5) {
    int v7 = 3;
  }
  else {
    int v7 = 1;
  }
  if (v6 || v4 == 0) {
    int v9 = 2;
  }
  else {
    int v9 = 4;
  }
  if (v4) {
    int v10 = v9;
  }
  else {
    int v10 = v7;
  }
  LODWORD(v17) = 31;
  v18[0] = v10;
  v18[6] = 0;
  uint64_t v14 = 0LL;
  v15[0] = 0LL;
  unint64_t v13 = 0LL;
  v15[1] = &v13;
  char v16 = 0;
  unint64_t v13 = (char *)operator new(0x28uLL);
  uint64_t v14 = v13;
  v15[0] = v13 + 40;
  uint64_t v14 = (_BYTE *)sub_100783D5C((uint64_t)v15, (uint64_t)&v17, (uint64_t)&v19, (uint64_t)v13);
  sub_10043AFF4((uint64_t)v18);
  uint64_t v11 = *(void **)(a1 + 2512);
  memset(v12, 0, sizeof(v12));
  sub_10043BC44(v12, (uint64_t)v13, (uint64_t)v14, 0xCCCCCCCCCCCCCCCDLL * ((v14 - v13) >> 3));
  [v11 setMeasurements:sub_100435878(v12)];
  signed int v17 = (void **)v12;
  sub_10043B844(&v17);
  signed int v17 = (void **)&v13;
  sub_10043B844(&v17);
}

void sub_100E507C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void **a17)
{
  a17 = (void **)&a12;
  sub_10043B844(&a17);
  _Unwind_Resume(a1);
}

NSString *sub_100E5081C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)__int128 buf = *(_DWORD *)(a1 + 1448);
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    sub_100008BDC();
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v2 + 48LL))(v2, buf);
  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  -[NSDateFormatter setTimeZone:]( v5,  "setTimeZone:",  +[NSTimeZone timeZoneWithAbbreviation:](&OBJC_CLASS___NSTimeZone, "timeZoneWithAbbreviation:", @"UTC"));
  -[NSDateFormatter setDateFormat:](v5, "setDateFormat:", @"yyyyMMddHHmmss");
  double v6 = *(double *)(a2 + 184);
  int v7 = (double *)sub_100869D50();
  __int128 v8 = (double *)(a2 + 76);
  if (v6 != v7[3]) {
    __int128 v8 = (double *)(a2 + 184);
  }
  int v9 = -[NSDateFormatter stringFromDate:]( v5,  "stringFromDate:",  +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  *v8));
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  int v10 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = -[NSString UTF8String](v9, "UTF8String");
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)uint64_t v42 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#AML sending valid fix from time %{public}s",  buf,  0xCu);
  }

  uint64_t v12 = sub_1002921D0(115, 2);
  if ((_DWORD)v12)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    uint64_t v25 = qword_101934898;
    int v35 = 136446210;
    *(void *)uint64_t v36 = -[NSString UTF8String](v9, "UTF8String");
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v25,  0LL,  "#AML sending valid fix from time %{public}s",  &v35,  12);
    double v27 = (uint8_t *)v26;
    uint64_t v12 = sub_10029211C( "Generic",  1LL,  0,  2LL,  "NSString *CLEmergencyAML::createSmsWithLocation(const GNSS::DaemonLocation &)",  "%s\n",  v26);
    if (v27 != buf) {
      free(v27);
    }
  }

  uint64_t v13 = sub_100E50F54(v12, *(_DWORD *)(a2 + 96));
  sub_100F993A0(a2, &v34, &v33);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  uint64_t v14 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(void *)(a2 + 4);
    uint64_t v16 = *(void *)(a2 + 12);
    *(_DWORD *)__int128 buf = 67240961;
    *(_DWORD *)uint64_t v42 = v13;
    *(_WORD *)&v42[4] = 2049;
    *(void *)&v42[6] = v15;
    __int16 v43 = 2049;
    uint64_t v44 = v16;
    __int16 v45 = 2050;
    double v46 = v34;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#AML method,%{public}c,lat,%{private}f,lon,%{private}f,acc,%{public}f",  buf,  0x26u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    uint64_t v28 = *(void *)(a2 + 4);
    uint64_t v29 = *(void *)(a2 + 12);
    int v35 = 67240961;
    *(_DWORD *)uint64_t v36 = v13;
    *(_WORD *)&v36[4] = 2049;
    *(void *)&v36[6] = v28;
    __int16 v37 = 2049;
    uint64_t v38 = v29;
    __int16 v39 = 2050;
    double v40 = v34;
    LODWORD(v32) = 38;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML method,%{public}c,lat,%{private}f,lon,%{private}f,acc,%{public}f",  &v35,  v32);
    __int128 v31 = (uint8_t *)v30;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "NSString *CLEmergencyAML::createSmsWithLocation(const GNSS::DaemonLocation &)",  "%s\n",  v30);
    if (v31 != buf) {
      free(v31);
    }
  }

  signed int v17 = &CMOnBodyStatusManagerManufacturer_ptr;
  LODWORD(v17) = vcvtad_u64_f64(v34);
  uint64_t v20 = *(void *)(v4 + 64);
  uint64_t v19 = v4 + 64;
  uint64_t v18 = v20;
  else {
    uint64_t v21 = *(void *)(v19 + 48);
  }
  dispatch_time_t v22 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AML=1;lt=%+.5f;lg=%+.5f;rd=%u;top=%@;lc=95;pm=%c;si=%s;ei=%s;mcc=%d;mnc=%d;ml=",
          *(void *)(a2 + 4),
          *(void *)(a2 + 12),
          v17,
          v9,
          v13,
          v18,
          v21,
          *(unsigned int *)(v19 - 56),
          *(unsigned int *)(v19 - 52));

  return sub_100E51120(v23, v22);
}

NSString *sub_100E50CB8(uint64_t a1)
{
  *(_DWORD *)__int128 buf = *(_DWORD *)(a1 + 1448);
  uint64_t v1 = *(void *)(a1 + 56);
  if (!v1) {
    sub_100008BDC();
  }
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v1 + 48LL))(v1, buf);
  uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  -[NSDateFormatter setTimeZone:]( v3,  "setTimeZone:",  +[NSTimeZone timeZoneWithAbbreviation:](&OBJC_CLASS___NSTimeZone, "timeZoneWithAbbreviation:", @"UTC"));
  -[NSDateFormatter setDateFormat:](v3, "setDateFormat:", @"yyyyMMddHHmmss");
  uint64_t v4 = -[NSDateFormatter stringFromDate:](v3, "stringFromDate:", +[NSDate now](&OBJC_CLASS___NSDate, "now"));
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  uint64_t v5 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    double v6 = -[NSString UTF8String](v4, "UTF8String");
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v21 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#AML sending no fix message at time %{public}s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    uint64_t v15 = qword_101934898;
    int v18 = 136446210;
    uint64_t v19 = -[NSString UTF8String](v4, "UTF8String");
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v15,  0LL,  "#AML sending no fix message at time %{public}s",  &v18,  12);
    signed int v17 = (uint8_t *)v16;
    sub_10029211C("Generic", 1LL, 0, 2LL, "NSString *CLEmergencyAML::createSmsWithoutLocation()", "%s\n", v16);
    if (v17 != buf) {
      free(v17);
    }
  }

  uint64_t v9 = *(void *)(v2 + 64);
  uint64_t v8 = v2 + 64;
  uint64_t v7 = v9;
  else {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v11 = *(void *)(v8 + 48);
  }
  uint64_t v12 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"AML=1;lt=+00.00000;lg=+000.00000;rd=N;top=%@;lc=0;pm=N;si=%s;ei=%s;mcc=%d;mnc=%d;ml=",
          v4,
          v10,
          v11,
          *(unsigned int *)(v8 - 56),
          *(unsigned int *)(v8 - 52));

  return sub_100E51120(v13, v12);
}

uint64_t sub_100E50F54(uint64_t a1, unsigned int a2)
{
  uint64_t result = 67LL;
  if (a2 <= 0xE)
  {
    int v3 = 1 << a2;
    if (((1 << a2) & 0x5025) != 0)
    {
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101887EC0);
      }
      uint64_t v5 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "#Warning #AML Valid location with unknown or obsolete type",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        v8[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML Valid location with unknown or obsolete type",  v8,  2);
        uint64_t v7 = (uint8_t *)v6;
        sub_10029211C("Generic", 1LL, 0, 2LL, "char CLEmergencyAML::positioningMethod(CLLocationType)", "%s\n", v6);
        if (v7 != buf) {
          free(v7);
        }
      }

      return 67LL;
    }

    else
    {
      if ((v3 & 0x20A) != 0) {
        unsigned int v4 = 71;
      }
      else {
        unsigned int v4 = 67;
      }
      if ((v3 & 0x2C10) != 0) {
        return 87LL;
      }
      else {
        return v4;
      }
    }
  }

  return result;
}

NSString *sub_100E51120(uint64_t a1, void *a2)
{
  unsigned int v3 = [a2 length];
  int v4 = 0;
  do
  {
    uint64_t v5 = v4 + v3;
    unsigned int v6 = -[NSString length]( +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%d", v5),  "length");
    BOOL v7 = v4 == v6;
    int v4 = v6;
  }

  while (!v7);
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  uint64_t v8 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 67240192;
    int v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "#AML total message length,%{public}d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    v12[0] = 67240192;
    v12[1] = v5;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#AML total message length,%{public}d",  v12,  8);
    uint64_t v11 = (uint8_t *)v10;
    sub_10029211C("Generic", 1LL, 0, 2LL, "NSString *CLEmergencyAML::stringWithAppendedLength(NSString *)", "%s\n", v10);
    if (v11 != buf) {
      free(v11);
    }
  }

  return +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@%d", a2, v5);
}

uint64_t *sub_100E51324(uint64_t a1)
{
  uint64_t v2 = (int *)(a1 + 1448);
  unsigned int v3 = sub_100E48E1C((int *)(a1 + 1448));
  if (*((char *)v3 + 31) < 0)
  {
    sub_1010DD48C(&v9, (void *)v3[1], v3[2]);
  }

  else
  {
    __int128 v9 = *(_OWORD *)(v3 + 1);
    uint64_t v10 = v3[3];
  }

  int v4 = (void **)(a1 + 1152);
  *(_OWORD *)int v4 = v9;
  *(void *)(a1 + 1168) = v10;
  uint64_t v5 = sub_100E48E1C(v2);
  if (*((char *)v5 + 55) < 0)
  {
    sub_1010DD48C(&v9, (void *)v5[4], v5[5]);
  }

  else
  {
    __int128 v9 = *((_OWORD *)v5 + 2);
    uint64_t v10 = v5[6];
  }

  unsigned int v6 = (void **)(a1 + 1176);
  *(_OWORD *)unsigned int v6 = v9;
  *(void *)(a1 + 1192) = v10;
  *(_DWORD *)(a1 + 28sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 4;
  uint64_t result = sub_100E48E1C(v2);
  if (*((_BYTE *)result + 80)) {
    int v8 = 7;
  }
  else {
    int v8 = 6;
  }
  *(_DWORD *)(a1 + 284) = v8;
  *(_DWORD *)(a1 + 276) = 3;
  *(_DWORD *)(a1 + 328) = 2;
  return result;
}

uint64_t sub_100E51438(uint64_t a1, int a2)
{
  if (a2 > 25)
  {
    switch(a2)
    {
      case 26:
        return 4294967294LL;
      case 29:
        return 3LL;
      case 28:
        return 2LL;
      default:
LABEL_12:
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101887EC0);
        }
        unsigned int v3 = (os_log_s *)qword_101934898;
        if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#Warning #AML unexpected error code",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934890 != -1) {
            dispatch_once(&qword_101934890, &stru_101887EC0);
          }
          v6[0] = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML unexpected error code",  v6,  2);
          uint64_t v5 = (uint8_t *)v4;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual uint32_t CLEmergencyAML::getErrorCodePriority(Emergency::SessionErrorCode)",  "%s\n",  v4);
          if (v5 != buf) {
            free(v5);
          }
        }

        return 0xFFFFFFFFLL;
    }
  }

  else
  {
    uint64_t result = 1LL;
    switch(a2)
    {
      case 0:
        return result;
      case 2:
        uint64_t result = 5LL;
        break;
      case 7:
      case 12:
        return 2LL;
      case 10:
      case 14:
        uint64_t result = 4294967293LL;
        break;
      case 16:
        uint64_t result = 4LL;
        break;
      default:
        goto LABEL_12;
    }
  }

  return result;
}

uint64_t sub_100E5167C(uint64_t a1, unsigned int a2)
{
  if (a2 < 0xA) {
    return dword_101362620[a2];
  }
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  unsigned int v3 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "#Warning #AML unexpected error code", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934890 != -1) {
      dispatch_once(&qword_101934890, &stru_101887EC0);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "#Warning #AML unexpected error code",  v6,  2);
    uint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "uint32_t CLEmergencyAML::getAMLErrorCodePriority(CLEmergencyAML::AMLSessionErrorCode)",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  return 0xFFFFFFFFLL;
}

void sub_100E5181C(uint64_t a1)
{
  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_101887EC0);
  }
  uint64_t v2 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEBUG))
  {
    v3[0] = 68289026;
    v3[1] = 0;
    __int16 v4 = 2082;
    uint64_t v5 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:#awd CLEmergencySessionReport::reset}",  (uint8_t *)v3,  0x12u);
  }

  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0xBF80000000000009LL;
  *(_BYTE *)(a1 + 24) = 0;
}

void sub_100E51908(uint64_t a1)
{
  *(_DWORD *)a1 = 0xFFFF;
  *(void *)(a1 + 12) = 0LL;
  *(void *)(a1 + 4) = 0LL;
  *(_OWORD *)(a1 + 2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = xmmword_1012E0070;
  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)(a1 + 36) = _Q0;
  *(_OWORD *)(a1 + 52) = _Q0;
  *(_OWORD *)(a1 + 68) = _Q0;
  *(_DWORD *)(a1 + 84) = 0;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 88) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 116) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 124) = 0x7FFFFFFF;
  *(void *)(a1 + 136) = 0LL;
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 128) = 0LL;
  *(_BYTE *)(a1 + 152) = 0;
  sub_100869DC8(v13);
  memcpy((void *)(a1 + 160), v13, 0x201uLL);
  sub_10005F550(a1 + 680, v14);
  __int128 v7 = *(_OWORD *)v15;
  *(_OWORD *)(a1 + 76sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v14[5];
  *(_OWORD *)(a1 + 776) = v7;
  *(void *)(a1 + 789) = *(void *)&v15[13];
  __int128 v8 = v14[2];
  *(_OWORD *)(a1 + 696) = v14[1];
  *(_OWORD *)(a1 + 712) = v8;
  __int128 v9 = v14[4];
  *(_OWORD *)(a1 + 728) = v14[3];
  *(_OWORD *)(a1 + 744) = v9;
  uint64_t v10 = (std::__shared_weak_count *)*((void *)&v14[0] + 1);
  if (*((void *)&v14[0] + 1))
  {
    uint64_t v11 = (unint64_t *)(*((void *)&v14[0] + 1) + 8LL);
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

BOOL sub_100E51A14(uint64_t a1)
{
  return sub_100E4834C((int *)(a1 + 1448)) || sub_100E4CC1C(a1) == 3;
}

BOOL sub_100E51A54(uint64_t a1)
{
  return sub_100E486EC((int *)(a1 + 1448));
}

void sub_100E51A5C(id a1)
{
  qword_101934898 = (uint64_t)os_log_create("com.apple.locationd.Position", "Emergency");
}

void sub_100E51A88(id a1)
{
  qword_101934A48 = (uint64_t)os_log_create("com.apple.locationd.Utility", "Utility");
}

void sub_100E51AB4(uint64_t a1, std::string *__str, __int128 *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  __int128 v9 = *(std::string **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    sub_10012EC68((uint64_t *)a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      sub_100007008();
    }
    unint64_t v10 = 0x5555555555555556LL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    else {
      unint64_t v11 = v10;
    }
    sub_100006E1C((void *)a1, v11);
    unint64_t v12 = sub_100037B94(v8, (__int128 *)__str, a3, *(char **)(a1 + 8));
    goto LABEL_11;
  }

  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) < a4)
  {
    uint64_t v13 = (std::string *)((char *)__str + 8 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3));
    sub_100037CD4(__str, v13, v9);
    unint64_t v12 = sub_100037B94(v8, (__int128 *)v13, a3, *(char **)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }

  sub_100037CD4(__str, (std::string *)a3, v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    do
    {
      v16 -= 24LL;
    }

    while (v16 != v15);
  }

  *(void *)(a1 + 8) = v15;
}

void sub_100E51C18(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_100E51C20(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_100E51C28(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100E51C60(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      unsigned int v3 = (void *)*v2;
      sub_100E51C9C((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

void sub_100E51C9C(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 160);
  sub_1000129D4(&v2);
}

uint64_t *sub_100E51D10(uint64_t a1, int *a2, uint64_t a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }

    __int128 v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (*((_DWORD *)i + 4) == (_DWORD)v6) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t v12 = a1 + 16;
  uint64_t v13 = operator new(0xD0uLL);
  v23[0] = v13;
  v23[1] = a1 + 16;
  void *v13 = 0LL;
  v13[1] = v6;
  sub_100E51F64((uint64_t)(v13 + 2), a3);
  char v24 = 1;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1LL;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    sub_100019E10(a1, v19);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }

  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    *(void *)v23[0] = *v20;
    void *v20 = v23[0];
  }

  else
  {
    *(void *)v23[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v23[0];
    *(void *)(*(void *)a1 + 8 * v3) = v12;
    if (*(void *)v23[0])
    {
      unint64_t v21 = *(void *)(*(void *)v23[0] + 8LL);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v21 >= v7) {
          v21 %= v7;
        }
      }

      else
      {
        v21 &= v7 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v21) = v23[0];
    }
  }

  uint64_t i = (uint64_t *)v23[0];
  v23[0] = 0LL;
  ++*(void *)(a1 + 24);
  sub_100E52020((uint64_t)v23, 0LL);
  return i;
}

void sub_100E51F4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

double sub_100E51F64(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  __int128 v2 = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = v2;
  *(void *)(a2 + 24) = 0LL;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  __int128 v3 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v3;
  *(void *)(a2 + 48) = 0LL;
  *(void *)(a2 + 56) = 0LL;
  *(void *)(a2 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  __int128 v4 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(void *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = v4;
  *(void *)(a2 + 72) = 0LL;
  *(void *)(a2 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  __int128 v5 = *(_OWORD *)(a2 + 88);
  __int128 v6 = *(_OWORD *)(a2 + 104);
  *(void *)(a1 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(void *)(a2 + 120);
  *(_OWORD *)(a1 + 104) = v6;
  *(_OWORD *)(a1 + 88) = v5;
  __int128 v7 = *(_OWORD *)(a2 + 128);
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(_OWORD *)(a1 + 128) = v7;
  *(void *)(a2 + 128) = 0LL;
  *(void *)(a2 + 136) = 0LL;
  *(void *)(a2 + 144) = 0LL;
  *(_BYTE *)(a1 + 152) = *(_BYTE *)(a2 + 152);
  *(void *)(a1 + 168) = 0LL;
  *(void *)(a1 + 176) = 0LL;
  *(void *)(a1 + 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  *(_OWORD *)(a1 + 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_OWORD *)(a2 + 160);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(void *)(a2 + 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  *(void *)(a2 + 168) = 0LL;
  *(void *)(a2 + 176) = 0LL;
  double result = *(double *)(a2 + 184);
  *(double *)(a1 + 184) = result;
  return result;
}

void sub_100E52020(uint64_t a1, uint64_t a2)
{
  __int128 v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_100E51C9C((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }

void sub_100E52068(std::__shared_weak_count *a1)
{
}

uint64_t sub_100E52080(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void sub_100E520C0(uint64_t a1, const void **a2, void *a3)
{
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 8) = a1 + 16;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = *a3;
  uint64_t v5 = a3[1];
  *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v5;
  if (v5)
  {
    __int128 v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(_BYTE *)(a1 + 48) = 0;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  *(_DWORD *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0LL;
  uint8x8_t v8 = (void **)(a1 + 96);
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 112) = 0LL;
  *(_BYTE *)(a1 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 2;
  if (*((char *)a2 + 23) < 0)
  {
    if (a2[1]) {
      goto LABEL_6;
    }
LABEL_21:
    sub_10127438C();
    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/GPS/CLStateMachine.h",  60,  "CLStateMachine");
    __break(1u);
    return;
  }

  if (!*((_BYTE *)a2 + 23)) {
    goto LABEL_21;
  }
LABEL_6:
  else {
    size_t v9 = (size_t)a2[1];
  }
  sub_1000392EC((uint64_t)&v12, v9 + 1);
  if (v13 >= 0) {
    unint64_t v10 = &v12;
  }
  else {
    unint64_t v10 = (__int128 *)v12;
  }
  if (v9)
  {
    else {
      unint64_t v11 = *a2;
    }
    memmove(v10, v11, v9);
  }

  *(_WORD *)((char *)v10 + v9) = 44;
  *(_OWORD *)uint8x8_t v8 = v12;
  *(void *)(a1 + 112) = v13;
}

void sub_100E52244(_Unwind_Exception *a1)
{
}

void sub_100E52284(id a1)
{
  qword_101934888 = (uint64_t)os_log_create("com.apple.locationd.Position", "Gnss");
}

uint64_t sub_100E522B0(uint64_t a1)
{
  uint64_t v2 = a1 + 56;
  sub_100E52318(*(void **)(a1 + 56), (void *)(a1 + 64), a1);
  sub_100008390(v2, *(void **)(a1 + 64));
  sub_10000AE14(a1 + 32);
  sub_100008390(a1 + 8, *(void **)(a1 + 16));
  return a1;
}

uint64_t sub_100E52318(void *a1, void *a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      sub_100E4D614(a3, *((_DWORD *)v5 + 8));
      __int128 v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          unint64_t v7 = v6;
          __int128 v6 = (void *)*v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          unint64_t v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }

        while (!v8);
      }

      uint64_t v5 = v7;
    }

    while (v7 != a2);
  }

  return a3;
}

uint64_t sub_100E52394(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100E523CC(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_10000AE14((uint64_t)(v2 + 88));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

void sub_100E52408(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_10000AE14((uint64_t)v2 + 704);
    }
    operator delete(v2);
  }

void sub_100E5244C(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_100E523CC(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0LL;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0LL; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0LL;
    }

    *(void *)(a1 + 24) = 0LL;
  }

uint64_t sub_100E524A0(uint64_t a1)
{
  return sub_100E4B444(*(void *)(a1 + 32), *(unsigned int *)(a1 + 40));
}

id sub_100E538F8(void *a1, int a2)
{
  uint64_t v4 = sub_1005D44DC(a1);
  if ((_DWORD)v4 != -1)
  {
    int v5 = v4;
    id v6 = -[NSData _cl_initWithFileDescriptor:](objc_alloc(&OBJC_CLASS___NSData), "_cl_initWithFileDescriptor:", v4);
    close(v5);
    if (!a2) {
      return v6;
    }
    goto LABEL_9;
  }

  if (qword_1019349B0 != -1) {
    dispatch_once(&qword_1019349B0, &stru_101888098);
  }
  unint64_t v7 = (os_log_s *)qword_1019349B8;
  if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_INFO))
  {
    v10[0] = 68289283;
    v10[1] = 0;
    __int16 v11 = 2082;
    __int128 v12 = "";
    __int16 v13 = 2113;
    float v14 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#Warning could not open file, path:%{private, location:escape_only}@}",  (uint8_t *)v10,  0x1Cu);
  }

  id v6 = 0LL;
  if (a2)
  {
LABEL_9:
    BOOL v8 = +[NSURL fileURLWithPath:](&OBJC_CLASS___NSURL, "fileURLWithPath:", a1);
    if (v8) {
      sub_100E53DB4(v8);
    }
  }

  return v6;
}

BOOL sub_100E53DB4(void *a1)
{
  if (-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](NSFileManager, "defaultManager"),  "fileExistsAtPath:",  [a1 path]))
  {
    *(void *)unint64_t v10 = 0LL;
    -[NSFileManager removeItemAtURL:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtURL:error:",  a1,  v10);
    if (*(void *)v10)
    {
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_101888098);
      }
      uint64_t v2 = (os_log_s *)qword_1019349B8;
      if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 68289539;
        *(_DWORD *)__int128 v12 = 0;
        *(_WORD *)&_DWORD v12[4] = 2082;
        *(void *)&v12[6] = "";
        __int16 v13 = 2114;
        float v14 = a1;
        __int16 v15 = 2113;
        uint64_t v16 = *(void *)v10;
        _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:failed to remove fs item, URL:%{public, location:escape_only}@, error:%{priva te, location:escape_only}@}",  buf,  0x26u);
        if (qword_1019349B0 != -1) {
          dispatch_once(&qword_1019349B0, &stru_101888098);
        }
      }

      uint64_t v3 = (os_log_s *)qword_1019349B8;
      if (os_signpost_enabled((os_log_t)qword_1019349B8))
      {
        *(_DWORD *)__int128 buf = 68289539;
        *(_DWORD *)__int128 v12 = 0;
        *(_WORD *)&_DWORD v12[4] = 2082;
        *(void *)&v12[6] = "";
        __int16 v13 = 2114;
        float v14 = a1;
        __int16 v15 = 2113;
        uint64_t v16 = *(void *)v10;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v3,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "failed to remove fs item",  "{msg%{public}.0s:failed to remove fs item, URL:%{public, location:escape_only}@, error:%{priva te, location:escape_only}@}",  buf,  0x26u);
      }
    }

    else
    {
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_101888098);
      }
      id v6 = (os_log_s *)qword_1019349B8;
      if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 68289283;
        *(_DWORD *)__int128 v12 = 0;
        *(_WORD *)&_DWORD v12[4] = 2082;
        *(void *)&v12[6] = "";
        __int16 v13 = 2113;
        float v14 = a1;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:removed fs item, URL:%{private, location:escape_only}@}",  buf,  0x1Cu);
      }
    }

    return *(void *)v10 == 0LL;
  }

  else
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_101888098);
    }
    uint64_t v4 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)__int128 v12 = [a1 path];
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "file does not exists. CheckAndRemoveItemAtPath : %@",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_101888098);
      }
      uint64_t v7 = qword_1019349B8;
      *(_DWORD *)unint64_t v10 = 138412290;
      *(void *)&_DWORD v10[4] = [a1 path];
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  2LL,  "file does not exists. CheckAndRemoveItemAtPath : %@",  v10,  12);
      size_t v9 = (uint8_t *)v8;
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL _CLHRemoveItemAtURL(NSURL *)", "%s\n", v8);
      if (v9 != buf) {
        free(v9);
      }
    }

    return 1LL;
  }

NSArray *sub_100E55740(uint64_t a1)
{
  uint64_t v5 = 0LL;
  double result = -[NSFileManager contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:",  +[NSURL fileURLWithPath:](&OBJC_CLASS___NSURL, "fileURLWithPath:", a1),  0LL,  0LL,  &v5);
  if (v5)
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_101888098);
    }
    uint64_t v3 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v7 = 0;
      __int16 v8 = 2082;
      size_t v9 = "";
      __int16 v10 = 2114;
      uint64_t v11 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Error finding contents of directory, directory:%{public, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_101888098);
      }
    }

    uint64_t v4 = (os_log_s *)qword_1019349B8;
    if (os_signpost_enabled((os_log_t)qword_1019349B8))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v7 = 0;
      __int16 v8 = 2082;
      size_t v9 = "";
      __int16 v10 = 2114;
      uint64_t v11 = a1;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Error finding contents of directory",  "{msg%{public}.0s:Error finding contents of directory, directory:%{public, location:escape_only}@}",  buf,  0x1Cu);
    }

    return 0LL;
  }

  return result;
}

int64_t sub_100E55AA4(id a1, NSURL *a2, NSURL *a3)
{
  uint64_t v5 = objc_autoreleasePoolPush();
  id v6 = -[NSString componentsSeparatedByString:]( -[NSString lastPathComponent](-[NSURL path](a2, "path"), "lastPathComponent"),  "componentsSeparatedByString:",  @"-");
  int v7 = -[NSString componentsSeparatedByString:]( -[NSString lastPathComponent](-[NSURL path](a3, "path"), "lastPathComponent"),  "componentsSeparatedByString:",  @"-");
  objc_msgSend(-[NSArray objectAtIndexedSubscript:](v6, "objectAtIndexedSubscript:", 1), "doubleValue");
  double v9 = v8;
  objc_msgSend(-[NSArray objectAtIndexedSubscript:](v7, "objectAtIndexedSubscript:", 1), "doubleValue");
  if (v9 >= v10) {
    uint64_t v11 = 0LL;
  }
  else {
    uint64_t v11 = -1LL;
  }
  if (v9 > v10) {
    int64_t v12 = 1LL;
  }
  else {
    int64_t v12 = v11;
  }
  objc_autoreleasePoolPop(v5);
  return v12;
}

id sub_100E56384(uint64_t a1, void *a2)
{
  return [a2 pruneSecondaryDataOlderThan:*(double *)(a1 + 32)];
}

void sub_100E56578(id a1, CLHRequestArchive *a2)
{
  uint64_t v3 = +[NSURL fileURLWithPath:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:",  -[CLHRequestArchive directory](a2, "directory"));
  if (v3) {
    sub_100E53DB4(v3);
  }
}

void sub_100E57074(id a1)
{
  qword_1019349B8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Harvester");
}

BOOL sub_100E570A0(id a1, NSURL *a2, NSError *a3)
{
  if (a3)
  {
    if (qword_1019349B0 != -1) {
      dispatch_once(&qword_1019349B0, &stru_101888098);
    }
    uint64_t v5 = (os_log_s *)qword_1019349B8;
    if (os_log_type_enabled((os_log_t)qword_1019349B8, OS_LOG_TYPE_ERROR))
    {
      int v8 = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2114;
      __int16 v13 = a2;
      __int16 v14 = 2114;
      __int16 v15 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CLHRequestArchive auto clean-up. Enumeration error, Item:%{public, location:escape_ only}@, Error:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x26u);
      if (qword_1019349B0 != -1) {
        dispatch_once(&qword_1019349B0, &stru_101888098);
      }
    }

    id v6 = (os_log_s *)qword_1019349B8;
    if (os_signpost_enabled((os_log_t)qword_1019349B8))
    {
      int v8 = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2114;
      __int16 v13 = a2;
      __int16 v14 = 2114;
      __int16 v15 = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CLHRequestArchive auto clean-up. Enumeration error",  "{msg%{public}.0s:CLHRequestArchive auto clean-up. Enumeration error, Item:%{public, location:escape_ only}@, Error:%{public, location:escape_only}@}",  (uint8_t *)&v8,  0x26u);
    }
  }

  return 1;
}

void sub_100E57248()
{
  unsigned __int8 v0 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v2 = __ldaxr(p_shared_owners);
    while (__stlxr(v2 - 1, p_shared_owners));
    if (!v2)
    {
      ((void (*)(std::__shared_weak_count *))v0->__on_zero_shared)(v0);
      std::__shared_weak_count::__release_weak(v0);
    }
  }

  sub_1004F2598();
  if (sub_1004F7694())
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_1018880F8);
    }
    uint64_t v3 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Power Log not supported on Base System",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_1018880F8);
      }
      LOWORD(v9[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Power Log not supported on Base System",  v9,  2);
      int v8 = (uint8_t *)v7;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLPowerLogInit()", "%s\n", v7);
      if (v8 != buf) {
        free(v8);
      }
    }

    byte_1019912B8 = 0;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888118);
  }
  uint64_t v4 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = byte_1019912B8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "PowerLog: g_enableLocPowerLog, %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888118);
    }
    v9[0] = 67109120;
    v9[1] = byte_1019912B8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "PowerLog: g_enableLocPowerLog, %d",  v9);
    id v6 = (uint8_t *)v5;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLPowerLogInit()", "%s\n", v5);
    if (v6 != buf) {
      free(v6);
    }
  }

void sub_100E57594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_100E575B0()
{
  return byte_1019912B8;
}

uint64_t sub_100E575BC(uint64_t result, uint64_t a2)
{
  if (byte_1019912B8) {
    return PLLogTimeSensitiveRegisteredEvent( 4LL,  +[NSString stringWithCString:encoding:](&OBJC_CLASS___NSString, "stringWithCString:encoding:", a2, 4LL),  result,  0LL);
  }
  return result;
}

uint64_t sub_100E57614(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1002A59CC(a1);
  return sub_100E575BC(v3, a2);
}

uint64_t sub_100E57638(uint64_t result, uint64_t a2)
{
  if (byte_1019912B8) {
    return PLLogRegisteredEvent( 4LL,  +[NSString stringWithCString:encoding:](&OBJC_CLASS___NSString, "stringWithCString:encoding:", a2, 4LL),  result,  0LL);
  }
  return result;
}

void sub_100E57690(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_100E576BC(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_100E576F4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 77);
}

BOOL sub_100E57700(uint64_t a1)
{
  return *(_BYTE *)(a1 + 76) && *(_DWORD *)(a1 + 80) && *(_BYTE *)(a1 + 77) == 0;
}

BOOL sub_100E5772C(uint64_t a1)
{
  return *(int *)(a1 + 72) >= 1 && *(_DWORD *)(a1 + 80) && *(_BYTE *)(a1 + 77) == 0;
}

BOOL sub_100E5775C(uint64_t a1)
{
  return *(int *)(a1 + 72) >= 1 && *(_BYTE *)(a1 + 76) && *(_BYTE *)(a1 + 77) == 0;
}

uint64_t sub_100E57794(uint64_t a1, void *a2, void *a3, void *a4)
{
  *(void *)a1 = &unk_101888138;
  *(void *)(a1 + 8) = 12LL;
  *(_WORD *)(a1 + 16) = 512;
  id v8 = objc_msgSend(objc_msgSend(a2, "silo"), "newTimer");
  *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *a3;
  *(void *)(a1 + 24) = v8;
  *(void *)(a1 + 32) = 0x402E000000000000LL;
  uint64_t v9 = a3[1];
  *(void *)(a1 + 48) = v9;
  if (v9)
  {
    __int16 v10 = (unint64_t *)(v9 + 8);
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  *(void *)(a1 + 56) = *a4;
  uint64_t v12 = a4[1];
  *(void *)(a1 + 64) = v12;
  if (v12)
  {
    __int16 v13 = (unint64_t *)(v12 + 8);
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  *(_DWORD *)(a1 + 72) = 0;
  *(_WORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  sub_1010DDBC0(v33, "WorkoutSignificantElevation");
  sub_1005FCFDC(a1 + 88, v33);
  if (v34 < 0) {
    operator delete(v33[0]);
  }
  sub_1010DDBC0(__p, "AWD_PhoneSignificantElevation");
  sub_1005FCFDC(a1 + 784, __p);
  if (v32 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(v29, "AWD_WatchSignificantElevation");
  sub_1005FCFDC(a1 + 1480, v29);
  if (v30 < 0) {
    operator delete(v29[0]);
  }
  *(_OWORD *)(a1 + 2224) = 0u;
  *(_OWORD *)(a1 + 2208) = 0u;
  *(_OWORD *)(a1 + 2192) = 0u;
  *(_OWORD *)(a1 + 2176) = 0u;
  *(void *)(a1 + 2256) = 0LL;
  sub_1005E4F48(a1 + 2272);
  *(void *)(a1 + 236sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  *(void *)(a1 + 2368) = a2;
  __int16 v15 = operator new(0x338uLL);
  sub_100DE5594((uint64_t)v15);
  *(void *)(a1 + 2376) = v15;
  uint64_t v16 = *(void **)(a1 + 2368);
  if (v16)
  {
    sub_100DAA9F8((uint64_t)sub_100E57B9C, a1, v16, &v27);
    uint64_t v17 = v27;
    uint64_t v27 = 0LL;
    uint64_t v18 = *(void *)(a1 + 2360);
    *(void *)(a1 + 236sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v17;
    if (v18)
    {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
      uint64_t v19 = v27;
      uint64_t v27 = 0LL;
      if (v19) {
        (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
      }
    }

    [*(id *)(*(void *)(a1 + 2360) + 16) register:*(void *)(*(void *)(a1 + 2360) + 8) forNotification:0 registrationInfo:0];
    uint64_t v20 = sub_1006E27E8();
    sub_100413284(v20, &v27);
    sub_1002A82BC(v27, "ElevationSourceTimeoutInterval", (void *)(a1 + 32));
    unint64_t v21 = v28;
    if (v28)
    {
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        unint64_t v23 = __ldaxr(p_shared_owners);
      while (__stlxr(v23 - 1, p_shared_owners));
      if (!v23)
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }

    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472LL;
    _OWORD v26[2] = sub_100E57D6C;
    void v26[3] = &unk_10181D3D0;
    v26[4] = a1;
    [*(id *)(a1 + 24) setHandler:v26];
    LOBYTE(v25) = 0;
    sub_1012049AC((unsigned __int8 *)&v27, "ElevationVerbose", (unsigned __int8 *)&v25, 0);
    *(_BYTE *)(a1 + 224sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = BYTE1(v27);
    *(void *)(a1 + 2248) = 0x7FEFFFFFFFFFFFFFLL;
    int v25 = 1097712271;
    sub_101206C88((unsigned __int8 *)&v27, "ElevationProfileDataDecimationPeriod", &v25, 0);
    *(double *)(a1 + 2264) = *((float *)&v27 + 1);
  }

  return a1;
}

void sub_100E57A8C(_Unwind_Exception *a1)
{
  uint64_t v5 = *(void *)(v2 + 2376);
  *(void *)(v2 + 2376) = 0LL;
  if (v5) {
    sub_100E5A46C(v2 + 2376, v5);
  }
  uint64_t v6 = *(void *)(v2 + 2360);
  *(void *)(v2 + 236sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  sub_10000AE14(v3);
  sub_10000AE14(v1);
  _Unwind_Resume(a1);
}

void sub_100E57B9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101888258);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    id v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLElevationController::onMotionStateObserverNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101888258);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      __int16 v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLElevationController::onMotionStateObserverNotification, event:%{public, location: escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100E59280(a4, v6, v7, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E57D4C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E57D6C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  *(_BYTE *)(v1 + 76) = 0;
  return sub_100CCCC8C(v1, 5, (uint64_t)&v3);
}

uint64_t sub_100E57D9C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 2360);
  *(void *)(a1 + 236sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 2376);
  *(void *)(a1 + 2376) = 0LL;
  if (v3) {
    sub_100E5A46C(a1 + 2376, v3);
  }
  uint64_t v4 = *(void *)(a1 + 2360);
  *(void *)(a1 + 236sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_10000AE14(a1 + 56);
  sub_10000AE14(a1 + 40);
  return a1;
}

void sub_100E57E44(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 1000;
  *(_DWORD *)(a3 + 48) = -1082130432;
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101888278);
  }
  uint64_t v6 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v7 = *(void *)(a2 + 8);
    int v8 = *(_DWORD *)(a2 + 16);
    int v9 = *(_DWORD *)(a2 + 20);
    *(_DWORD *)__int128 buf = 134349568;
    *(void *)&uint8_t buf[4] = v7;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&buf[14] = v8;
    *(_WORD *)&buf[18] = 1026;
    *(_DWORD *)&buf[20] = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "WorkoutElevation,onElevationPhone,fusionInput,startTime,%{public}.3lf,ascended,%{public}d,descended,%{public}d",  buf,  0x18u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    double v34 = *(double *)(a2 + 8);
    unsigned int v35 = *(_DWORD *)(a2 + 16);
    unsigned int v36 = *(_DWORD *)(a2 + 20);
    int v47 = 134349568;
    double v48 = v34;
    __int16 v49 = 1026;
    unsigned int v50 = v35;
    __int16 v51 = 1026;
    unsigned int v52 = v36;
    __int16 v37 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  2LL,  "WorkoutElevation,onElevationPhone,fusionInput,startTime,%{public}.3lf,ascended,%{public}d,descended,%{public}d",  &v47,  24);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLElevationChangeEntry CLElevationController::elevationUpdatePhone(CLElevationChangeEntry)",  "%s\n",  v37);
    if (v37 != buf) {
      free(v37);
    }
  }

  if (*(_DWORD *)(a1 + 80))
  {
    if (*(_DWORD *)(a2 + 16) || *(_DWORD *)(a2 + 20))
    {
      double v10 = sub_100DE5744(*(void *)(a1 + 2376));
      double v11 = sub_100DE574C(*(void *)(a1 + 2376));
      sub_100DE5754(*(void *)(a1 + 2376), a2, buf);
      __int128 v12 = *(_OWORD *)&buf[16];
      *(_OWORD *)a3 = *(_OWORD *)buf;
      *(_OWORD *)(a3 + 16) = v12;
      __int128 v13 = *(_OWORD *)&v60[16];
      *(_OWORD *)(a3 + 32) = *(_OWORD *)v60;
      *(_OWORD *)(a3 + 48) = v13;
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101888278);
      }
      __int16 v14 = (os_log_s *)qword_1019345B8;
      if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v15 = *(void *)(a3 + 8);
        int v16 = *(_DWORD *)(a3 + 16);
        int v17 = *(_DWORD *)(a3 + 20);
        int v18 = *(_DWORD *)(a3 + 40);
        *(_DWORD *)__int128 buf = 134350337;
        *(void *)&uint8_t buf[4] = v15;
        *(_WORD *)&_BYTE buf[12] = 1026;
        *(_DWORD *)&buf[14] = v16;
        *(_WORD *)&buf[18] = 1026;
        *(_DWORD *)&buf[20] = v17;
        *(_WORD *)&_BYTE buf[24] = 1026;
        *(_DWORD *)&buf[26] = v18;
        *(_WORD *)&buf[30] = 2049;
        *(double *)__int128 v60 = v10;
        *(_WORD *)&v60[8] = 2049;
        *(double *)&v60[10] = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "WorkoutElevation,onElevationPhone,fusionOutput,startTime,%{public}.3lf,ascended,%{public}d,descended,%{public} d,source,%{public}d,minGpsAltitudeInMeter,%{private}.3lf,maxGpsAltitudeInMeter,%{private}.3lf",  buf,  0x32u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345B0 != -1) {
          dispatch_once(&qword_1019345B0, &stru_101888278);
        }
        double v38 = *(double *)(a3 + 8);
        unsigned int v20 = *(_DWORD *)(a3 + 16);
        unsigned int v21 = *(_DWORD *)(a3 + 20);
        int v22 = *(_DWORD *)(a3 + 40);
        int v47 = 134350337;
        double v48 = v38;
        __int16 v49 = 1026;
        unsigned int v50 = v20;
        __int16 v51 = 1026;
        unsigned int v52 = v21;
        __int16 v53 = 1026;
        int v54 = v22;
        __int16 v55 = 2049;
        double v56 = v10;
        __int16 v57 = 2049;
        double v58 = v11;
        LODWORD(v46) = 50;
        __int16 v39 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  2LL,  "WorkoutElevation,onElevationPhone,fusionOutput,startTime,%{public}.3lf,ascended,%{public}d,desce nded,%{public}d,source,%{public}d,minGpsAltitudeInMeter,%{private}.3lf,maxGpsAltitudeInMeter,%{private}.3lf",  &v47,  v46);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLElevationChangeEntry CLElevationController::elevationUpdatePhone(CLElevationChangeEntry)",  "%s\n",  v39);
        double v19 = v38;
        if (v39 != buf) {
          free(v39);
        }
      }

      else
      {
        double v19 = *(double *)(a3 + 8);
        unsigned int v20 = *(_DWORD *)(a3 + 16);
        unsigned int v21 = *(_DWORD *)(a3 + 20);
        int v22 = *(_DWORD *)(a3 + 40);
      }

      sub_1005FD5AC((unsigned __int16 *)(a1 + 88), v20, v21, v22, v19);
      *(void *)(a1 + 2216) = *(void *)(a1 + 632);
      sub_1005FE308(v19, a1 + 88, a1 + 2176);
      double v23 = sub_100DE7560(*(void *)(a1 + 2376), a2);
      *(double *)(a1 + 2224) = v23;
      *(_BYTE *)(a1 + 2232) = 1;
      if (v23 > 0.0)
      {
        sub_1005F8E14(*(void *)(a1 + 56), a1 + 2176);
        *(void *)(a1 + 2248) = *(void *)(a1 + 2200);
        double Current = CFAbsoluteTimeGetCurrent();
        double v25 = Current;
        if (*(_BYTE *)(a1 + 2240) || *(_BYTE *)(a1 + 2232) && Current - *(double *)(a1 + 2256) > 15.0)
        {
          if (qword_1019345B0 != -1) {
            dispatch_once(&qword_1019345B0, &stru_101888278);
          }
          uint64_t v26 = (os_log_s *)qword_1019345B8;
          if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v27 = *(void *)(a1 + 2200);
            int v28 = *(_DWORD *)(a1 + 2216);
            int v29 = *(_DWORD *)(a1 + 2220);
            int v30 = *(unsigned __int8 *)(a1 + 2232);
            uint64_t v31 = *(void *)(a1 + 2224);
            *(_DWORD *)__int128 buf = 134350080;
            *(void *)&uint8_t buf[4] = v27;
            *(_WORD *)&_BYTE buf[12] = 1026;
            *(_DWORD *)&buf[14] = v28;
            *(_WORD *)&buf[18] = 1026;
            *(_DWORD *)&buf[20] = v29;
            *(_WORD *)&_BYTE buf[24] = 1026;
            *(_DWORD *)&buf[26] = v30;
            *(_WORD *)&buf[30] = 2050;
            *(void *)__int128 v60 = v31;
            _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "writing data to elevationDB for watch with companion phone during workout,startTime,%{public}.3lf,ascend,% {public}d,descend,%{public}d,workout,%{public}d,pressure,%{public}.5lf",  buf,  0x28u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019345B0 != -1) {
              dispatch_once(&qword_1019345B0, &stru_101888278);
            }
            double v40 = *(double *)(a1 + 2200);
            unsigned int v41 = *(_DWORD *)(a1 + 2216);
            unsigned int v42 = *(_DWORD *)(a1 + 2220);
            int v43 = *(unsigned __int8 *)(a1 + 2232);
            double v44 = *(double *)(a1 + 2224);
            int v47 = 134350080;
            double v48 = v40;
            __int16 v49 = 1026;
            unsigned int v50 = v41;
            __int16 v51 = 1026;
            unsigned int v52 = v42;
            __int16 v53 = 1026;
            int v54 = v43;
            __int16 v55 = 2050;
            double v56 = v44;
            LODWORD(v46) = 40;
            __int16 v45 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "writing data to elevationDB for watch with companion phone during workout,startTime,%{public }.3lf,ascend,%{public}d,descend,%{public}d,workout,%{public}d,pressure,%{public}.5lf",  &v47,  v46);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLElevationChangeEntry CLElevationController::elevationUpdatePhone(CLElevationChangeEntry)",  "%s\n",  v45);
            if (v45 != buf) {
              free(v45);
            }
          }

          *(double *)(a1 + 2256) = v25;
        }
      }
    }

    else
    {
      unsigned int v21 = 0;
      unsigned int v20 = 0;
      double v19 = 0.0;
    }

    sub_1005FD5AC((unsigned __int16 *)(a1 + 784), v20, v21, 0, v19);
    uint64_t v32 = sub_100F5A080();
    sub_100F5D5E4(v32, *(_DWORD *)(a1 + 1328));
    double v33 = (dispatch_queue_t *)sub_100B354EC();
    sub_100B37070(v33, *(_DWORD *)(a1 + 1328));
  }

void sub_100E58510(uint64_t a1, __int128 *a2, void **a3)
{
  if ((sub_1004F97F4() & 0x1000000000LL) != 0) {
    sub_1005E4FC4(a1 + 2272, *((_DWORD *)a2 + 11), *(_DWORD *)(a1 + 80), *((_WORD *)a2 + 27), *((float *)a2 + 12));
  }
  if (!*(_BYTE *)(a1 + 16) && (*((_DWORD *)a2 + 4) || *((_DWORD *)a2 + 5)))
  {
    __int128 v6 = *a2;
    __int128 v7 = a2[1];
    __int128 v8 = a2[3];
    *(_OWORD *)&v63[16] = a2[2];
    *(_OWORD *)&v63[32] = v8;
    __int128 v62 = v6;
    *(_OWORD *)__int128 v63 = v7;
    if ((sub_1004F97F4() & 0x1000000000LL) != 0 && *(_DWORD *)(a1 + 80)) {
      v63[36] = *(_DWORD *)(a1 + 2332);
    }
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    int v9 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 134350336;
      *(void *)&uint8_t buf[4] = *((void *)&v62 + 1);
      *(_WORD *)&_BYTE buf[12] = 1026;
      *(_DWORD *)&buf[14] = *(_DWORD *)v63;
      *(_WORD *)&buf[18] = 1026;
      unsigned int v79 = *(_DWORD *)&v63[4];
      LOWORD(v8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 2050;
      *(double *)((char *)&v80 + 2) = *(float *)&v63[32];
      WORD5(v8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 1026;
      HIDWORD(v8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v63[36];
      *(_WORD *)double v81 = 1026;
      *(_DWORD *)&v81[2] = *(_DWORD *)&v63[28];
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "WorkoutElevation,onElevationWatch,fusionInput,startTime,%{public}.3lf,ascended,%{public}d,descended,%{public}d,p ressureAmplitude,%{public}f,pressureQuality,%{public}d,deltaSteps,%{public}d",  buf,  0x2Eu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101888278);
      }
      int v64 = 134350336;
      double v65 = *((double *)&v62 + 1);
      __int16 v66 = 1026;
      unsigned int v67 = *(_DWORD *)v63;
      __int16 v68 = 1026;
      unsigned int v69 = *(_DWORD *)&v63[4];
      __int16 v70 = 2050;
      *(double *)double v71 = *(float *)&v63[32];
      *(_WORD *)&v71[8] = 1026;
      *(_DWORD *)&v71[10] = v63[36];
      __int16 v72 = 1026;
      LODWORD(v73) = *(_DWORD *)&v63[28];
      __int16 v51 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  2LL,  "WorkoutElevation,onElevationWatch,fusionInput,startTime,%{public}.3lf,ascended,%{public}d,descende d,%{public}d,pressureAmplitude,%{public}f,pressureQuality,%{public}d,deltaSteps,%{public}d",  &v64,  46);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::elevationUpdateWatch(std::vector<CLElevationChangeEntry>::const_iterator, std::vecto r<CLElevationChangeEntry> &)",  "%s\n",  v51);
      if (v51 != buf) {
        free(v51);
      }
    }

    int v10 = 1;
    *(_DWORD *)&v63[24] = 1;
    double v11 = *((double *)&v62 + 1);
    uint64_t v12 = v62;
    unsigned int v13 = *(_DWORD *)v63;
    unsigned int v14 = *(_DWORD *)&v63[4];
    __int128 v61 = *(_OWORD *)&v63[8];
    __int128 v76 = *(_OWORD *)&v63[28];
    char v77 = v63[44];
    if (*(_DWORD *)(a1 + 80))
    {
      double v15 = sub_100DE5744(*(void *)(a1 + 2376));
      double v16 = sub_100DE574C(*(void *)(a1 + 2376));
      sub_100DE5F78(*(void *)(a1 + 2376), (uint64_t)&v62, buf);
      uint64_t v12 = *(void *)buf;
      double v11 = *(double *)&buf[8];
      unsigned int v13 = *(_DWORD *)&buf[16];
      unsigned int v14 = v79;
      __int128 v61 = v80;
      int v10 = *(_DWORD *)v81;
      __int128 v76 = *(_OWORD *)&v81[4];
      char v77 = v82;
      __int16 v17 = v83;
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101888278);
      }
      int v18 = (os_log_s *)qword_1019345B8;
      if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 134350337;
        *(double *)&uint8_t buf[4] = v11;
        *(_WORD *)&_BYTE buf[12] = 1026;
        *(_DWORD *)&buf[14] = v13;
        *(_WORD *)&buf[18] = 1026;
        unsigned int v79 = v14;
        LOWORD(v8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 1026;
        *(_DWORD *)((char *)&v80 + 2) = v10;
        WORD3(v8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 2049;
        *((double *)&v80 + 1) = v15;
        *(_WORD *)double v81 = 2049;
        *(double *)&v81[2] = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "WorkoutElevation,onElevationWatch,fusionOutput,startTime,%{public}.3lf,ascended,%{public}d,descended,%{public} d,source,%{public}d,minGpsAltitudeInMeter,%{private}.3lf,maxGpsAltitudeInMeter,%{private}.3lf",  buf,  0x32u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345B0 != -1) {
          dispatch_once(&qword_1019345B0, &stru_101888278);
        }
        int v64 = 134350337;
        double v65 = v11;
        __int16 v66 = 1026;
        unsigned int v67 = v13;
        __int16 v68 = 1026;
        unsigned int v69 = v14;
        __int16 v70 = 1026;
        *(_DWORD *)double v71 = v10;
        *(_WORD *)&v71[4] = 2049;
        *(double *)&void v71[6] = v15;
        __int16 v72 = 2049;
        double v73 = v16;
        LODWORD(v6sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 50;
        double v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  2LL,  "WorkoutElevation,onElevationWatch,fusionOutput,startTime,%{public}.3lf,ascended,%{public}d,desce nded,%{public}d,source,%{public}d,minGpsAltitudeInMeter,%{private}.3lf,maxGpsAltitudeInMeter,%{private}.3lf",  &v64,  v60);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::elevationUpdateWatch(std::vector<CLElevationChangeEntry>::const_iterator, std::vec tor<CLElevationChangeEntry> &)",  "%s\n",  v19);
        if (v19 != buf) {
          free(v19);
        }
      }
    }

    else
    {
      __int16 v17 = *(_WORD *)&v63[46];
    }

    char v20 = v63[45];
    unsigned int v21 = (char *)a3[2];
    int v22 = (char *)a3[1];
    if (v22 >= v21)
    {
      uint64_t v24 = (v22 - (_BYTE *)*a3) >> 6;
      unint64_t v25 = v24 + 1;
      uint64_t v26 = v21 - (_BYTE *)*a3;
      if (v26 >> 5 > v25) {
        unint64_t v25 = v26 >> 5;
      }
      else {
        unint64_t v27 = v25;
      }
      if (v27) {
        int v28 = (char *)sub_10001275C((uint64_t)(a3 + 2), v27);
      }
      else {
        int v28 = 0LL;
      }
      int v29 = &v28[64 * v24];
      int v30 = &v28[64 * v27];
      *(void *)int v29 = v12;
      *((double *)v29 + 1) = v11;
      *((_DWORD *)v29 + 4) = v13;
      *((_DWORD *)v29 + 5) = v14;
      *(_OWORD *)(v29 + 24) = v61;
      *((_DWORD *)v29 + 1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v10;
      v29[60] = v77;
      *(_OWORD *)(v29 + 44) = v76;
      v29[61] = v20;
      *((_WORD *)v29 + 31) = v17;
      double v23 = v29 + 64;
      uint64_t v32 = (char *)*a3;
      uint64_t v31 = (char *)a3[1];
      if (v31 != *a3)
      {
        do
        {
          __int128 v33 = *((_OWORD *)v31 - 4);
          __int128 v34 = *((_OWORD *)v31 - 3);
          __int128 v35 = *((_OWORD *)v31 - 1);
          *((_OWORD *)v29 - 2) = *((_OWORD *)v31 - 2);
          *((_OWORD *)v29 - 1) = v35;
          *((_OWORD *)v29 - 4) = v33;
          *((_OWORD *)v29 - 3) = v34;
          v29 -= 64;
          v31 -= 64;
        }

        while (v31 != v32);
        uint64_t v31 = (char *)*a3;
      }

      *a3 = v29;
      a3[1] = v23;
      a3[2] = v30;
      if (v31) {
        operator delete(v31);
      }
    }

    else
    {
      *(void *)int v22 = v12;
      *((double *)v22 + 1) = v11;
      *((_DWORD *)v22 + 4) = v13;
      *((_DWORD *)v22 + 5) = v14;
      *(_OWORD *)(v22 + 24) = v61;
      *((_DWORD *)v22 + 1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v10;
      *(_OWORD *)(v22 + 44) = v76;
      v22[60] = v77;
      v22[61] = v20;
      double v23 = v22 + 64;
      *((_WORD *)v22 + 31) = v17;
    }

    a3[1] = v23;
    if ((sub_1004F97F4() & 0x1000000000LL) != 0)
    {
      int v36 = *(_DWORD *)(a1 + 80);
      if (v36)
      {
        sub_1005FD5AC((unsigned __int16 *)(a1 + 88), v13, v14, v10, v11);
        uint64_t v37 = *(void *)(a1 + 632);
        LOBYTE(v36) = 1;
      }

      else
      {
        uint64_t v37 = 0LL;
      }

      *(void *)(a1 + 2216) = v37;
      *(_BYTE *)(a1 + 2232) = v36;
      sub_1005FE308(v11, a1 + 88, a1 + 2176);
      *(double *)(a1 + 2224) = *(float *)&v63[40];
      sub_100DE7558(*(void *)(a1 + 2376));
      if (*(double *)(a1 + 2224) > 0.0)
      {
        double v38 = *(double *)(a1 + 2248);
        if (v38 == 1.79769313e308
          || *(_BYTE *)(a1 + 2232)
          || vabdd_f64(*(double *)(a1 + 2200), v38) > *(double *)(a1 + 2264))
        {
          sub_1005F8E14(*(void *)(a1 + 56), a1 + 2176);
          *(void *)(a1 + 2248) = *(void *)(a1 + 2200);
          double Current = CFAbsoluteTimeGetCurrent();
          double v40 = Current;
          if (*(_BYTE *)(a1 + 2240) || *(_BYTE *)(a1 + 2232) && Current - *(double *)(a1 + 2256) > 15.0)
          {
            if (qword_1019345B0 != -1) {
              dispatch_once(&qword_1019345B0, &stru_101888278);
            }
            unsigned int v41 = (os_log_s *)qword_1019345B8;
            if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v42 = *(void *)(a1 + 2200);
              int v43 = *(_DWORD *)(a1 + 2216);
              unsigned int v44 = *(_DWORD *)(a1 + 2220);
              int v45 = *(unsigned __int8 *)(a1 + 2232);
              uint64_t v46 = *(void *)(a1 + 2224);
              double v47 = *((float *)a2 + 12);
              unsigned __int8 v48 = v63[36];
              if (!*(_BYTE *)(a1 + 2232)) {
                unsigned __int8 v48 = 0;
              }
              *(_DWORD *)__int128 buf = 134350592;
              *(void *)&uint8_t buf[4] = v42;
              *(_WORD *)&_BYTE buf[12] = 1026;
              *(_DWORD *)&buf[14] = v43;
              *(_WORD *)&buf[18] = 1026;
              unsigned int v79 = v44;
              LOWORD(v8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 1026;
              *(_DWORD *)((char *)&v80 + 2) = v45;
              WORD3(v8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 2050;
              *((void *)&v80 + 1) = v46;
              *(_WORD *)double v81 = 2050;
              *(double *)&v81[2] = v47;
              *(_WORD *)&v81[10] = 1026;
              *(_DWORD *)&v81[12] = v48;
              _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "writing data to elevationDB for watch,startTime,%{public}.3lf,ascend,%{public}d,descend,%{public}d,worko ut,%{public}d,pressure,%{public}.5lf,pressureAmplitude,%{public}f,pressureQuality,%{public}d",  buf,  0x38u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019345B0 != -1) {
                dispatch_once(&qword_1019345B0, &stru_101888278);
              }
              double v52 = *(double *)(a1 + 2200);
              unsigned int v53 = *(_DWORD *)(a1 + 2216);
              unsigned int v54 = *(_DWORD *)(a1 + 2220);
              int v55 = *(unsigned __int8 *)(a1 + 2232);
              uint64_t v56 = *(void *)(a1 + 2224);
              double v57 = *((float *)a2 + 12);
              unsigned __int8 v58 = v63[36];
              if (!*(_BYTE *)(a1 + 2232)) {
                unsigned __int8 v58 = 0;
              }
              int v64 = 134350592;
              double v65 = v52;
              __int16 v66 = 1026;
              unsigned int v67 = v53;
              __int16 v68 = 1026;
              unsigned int v69 = v54;
              __int16 v70 = 1026;
              *(_DWORD *)double v71 = v55;
              *(_WORD *)&v71[4] = 2050;
              *(void *)&void v71[6] = v56;
              __int16 v72 = 2050;
              double v73 = v57;
              __int16 v74 = 1026;
              int v75 = v58;
              LODWORD(v6sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 56;
              double v59 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "writing data to elevationDB for watch,startTime,%{public}.3lf,ascend,%{public}d,descend,%{ public}d,workout,%{public}d,pressure,%{public}.5lf,pressureAmplitude,%{public}f,pressureQu ality,%{public}d",  &v64,  v60);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::elevationUpdateWatch(std::vector<CLElevationChangeEntry>::const_iterator, st d::vector<CLElevationChangeEntry> &)",  "%s\n",  v59);
              if (v59 != buf) {
                free(v59);
              }
            }

            *(double *)(a1 + 2256) = v40;
          }
        }
      }
    }
  }

  if (*(_DWORD *)(a1 + 80))
  {
    sub_1005FD5AC((unsigned __int16 *)(a1 + 1480), *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), 1, *((double *)a2 + 1));
    uint64_t v49 = sub_100F5A080();
    sub_100F5D664(v49, *(_DWORD *)(a1 + 2024));
    unsigned int v50 = (dispatch_queue_t *)sub_100B354EC();
    sub_100B36FE8(v50, *(_DWORD *)(a1 + 2024));
  }

uint64_t sub_100E58E74(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 72) != a2)
  {
    uint64_t v2 = result;
    *(_DWORD *)(result + 72) = a2;
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    uint64_t v3 = (os_log_s *)qword_1019345B8;
    if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
    {
      int v4 = *(_DWORD *)(v2 + 72);
      *(_DWORD *)__int128 buf = 67109120;
      int v10 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "WorkoutElevation,clients,%d", buf, 8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345B0 != -1) {
        dispatch_once(&qword_1019345B0, &stru_101888278);
      }
      int v6 = *(_DWORD *)(v2 + 72);
      v8[0] = 67109120;
      v8[1] = v6;
      __int128 v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "WorkoutElevation,clients,%d",  v8);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::updateElevationSubscriptionClient(int)",  "%s\n",  v7);
    }

    else {
      int v5 = 1;
    }
    return sub_100CCCC8C(v2, v5, (uint64_t)buf);
  }

  return result;
}

uint64_t sub_100E59058(uint64_t a1, int a2, int a3)
{
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101888278);
  }
  int v6 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(unsigned __int8 *)(a1 + 76);
    *(_DWORD *)__int128 buf = 67109632;
    int v19 = v7;
    __int16 v20 = 1024;
    int v21 = a2;
    __int16 v22 = 1024;
    int v23 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "WorkoutElevation,phone connection,prev,%d,curr,%d,elev,%d",  buf,  0x14u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    __int16 v14 = 1024;
    int v15 = a2;
    __int16 v16 = 1024;
    int v17 = a3;
    uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  0LL,  "WorkoutElevation,phone connection,prev,%d,curr,%d,elev,%d",  &v13,  20,  67109632);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::updatePhoneConnectionStatus(BOOL, BOOL)",  "%s\n",  v12);
  }

  int v8 = a2 & a3;
  if (*(_DWORD *)(a1 + 80) && (v8 & 1) == 0 && *(_BYTE *)(a1 + 76) || (*(_BYTE *)(a1 + 76) = v8, !v8))
  {
    uint64_t v9 = a1;
    int v10 = 4;
  }

  else
  {
    uint64_t v9 = a1;
    int v10 = 3;
  }

  return sub_100CCCC8C(v9, v10, (uint64_t)buf);
}

uint64_t sub_100E59280(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = *(_DWORD *)(a1 + 80);
  if (v6) {
    sub_100DE86C0(*(_DWORD **)(a1 + 2376), v6);
  }
  *(_DWORD *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_DWORD *)(a4 + 8);
  sub_1005FCDD0(a1 + 88);
  sub_100CF54A0(*(void *)(a1 + 40));
  sub_100DE5A08(*(void *)(a1 + 2376));
  sub_1005FCDD0(a1 + 784);
  sub_1005FCDD0(a1 + 1480);
  if (*(_DWORD *)(a1 + 80))
  {
    int v7 = &v12;
    uint64_t v8 = a1;
    int v9 = 6;
  }

  else
  {
    int v7 = &v11;
    uint64_t v8 = a1;
    int v9 = 7;
  }

  return sub_100CCCC8C(v8, v9, (uint64_t)v7);
}

void sub_100E59310(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100E59318(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 77) != a2)
  {
    *(_BYTE *)(result + 77) = a2;
    return sub_100CCCC8C(result, 8, (uint64_t)&v2);
  }

  return result;
}

void sub_100E5934C(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100E59378(id a1)
{
  qword_1019345B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pressure");
}

id sub_100E593A4(uint64_t a1)
{
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101888278);
  }
  char v2 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "WorkoutElevation,subs,phone,0", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "WorkoutElevation,subs,phone,0",  v6,  2);
    int v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::doUnsubscribe(const T *) [T = CLElevationController::ENoActiveClients]",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  if ((sub_1004F97F4() & 0x1000000000LL) != 0) {
    sub_100E59580(*(void *)(a1 + 2376), 0);
  }
  else {
    sub_1005FCFE0(a1 + 88);
  }
  [*(id *)(a1 + 24) setNextFireDelay:1.79769313e308];
  return objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 2368), "vendor"), "proxyForService:", @"CLOdometerNotifier"),  "updatePhoneWorkoutElevationSubscription:",  0);
}

void sub_100E59580(uint64_t a1, char a2)
{
  *(_BYTE *)(a1 + 64sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a2;
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = *(void ***)(a1 + 152);
    uint64_t v4 = *(void *)(a1 + 160);
    *(void *)(a1 + 184) = 0LL;
    unint64_t v5 = v4 - (void)v3;
    if (v5 >= 0x11)
    {
      do
      {
        operator delete(*v3);
        uint64_t v6 = *(void *)(a1 + 160);
        uint64_t v3 = (void **)(*(void *)(a1 + 152) + 8LL);
        *(void *)(a1 + 152) = v3;
        unint64_t v5 = v6 - (void)v3;
      }

      while (v5 > 0x10);
    }

    if (v5 >> 3 == 1)
    {
      uint64_t v7 = 32LL;
    }

    else
    {
      if (v5 >> 3 != 2) {
        return;
      }
      uint64_t v7 = 64LL;
    }

    *(void *)(a1 + 176) = v7;
  }

id sub_100E595FC(uint64_t a1)
{
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101888278);
  }
  char v2 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "WorkoutElevation,subs,phone,waitingToUnsubscribe",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  2LL,  "WorkoutElevation,subs,phone,waitingToUnsubscribe",  v6,  2);
    unint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::doWaitToUnsubscribe(const T *) [T = CLElevationController::ESourceUnavailable]",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  return [*(id *)(a1 + 24) setNextFireDelay:*(double *)(a1 + 32)];
}

id sub_100E59798(uint64_t a1)
{
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101888278);
  }
  char v2 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "WorkoutElevation,subs,phone,0", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "WorkoutElevation,subs,phone,0",  v6,  2);
    unint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::doUnsubscribe(const T *) [T = CLElevationController::EWorkoutStop]",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  if ((sub_1004F97F4() & 0x1000000000LL) != 0) {
    sub_100E59580(*(void *)(a1 + 2376), 0);
  }
  else {
    sub_1005FCFE0(a1 + 88);
  }
  [*(id *)(a1 + 24) setNextFireDelay:1.79769313e308];
  return objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 2368), "vendor"), "proxyForService:", @"CLOdometerNotifier"),  "updatePhoneWorkoutElevationSubscription:",  0);
}

id sub_100E59974(uint64_t a1)
{
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101888278);
  }
  char v2 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "WorkoutElevation,subs,phone,0", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "WorkoutElevation,subs,phone,0",  v6,  2);
    unint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::doUnsubscribe(const T *) [T = CLElevationController::EPowerSaveModeChanged]",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  if ((sub_1004F97F4() & 0x1000000000LL) != 0) {
    sub_100E59580(*(void *)(a1 + 2376), 0);
  }
  else {
    sub_1005FCFE0(a1 + 88);
  }
  [*(id *)(a1 + 24) setNextFireDelay:1.79769313e308];
  return objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 2368), "vendor"), "proxyForService:", @"CLOdometerNotifier"),  "updatePhoneWorkoutElevationSubscription:",  0);
}

id sub_100E59B50(uint64_t a1)
{
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101888278);
  }
  char v2 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "WorkoutElevation,subs,phone,1", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "WorkoutElevation,subs,phone,1",  v6,  2);
    unint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::doSubscribe(const T *) [T = CLElevationController::EClientActive]",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  if ((sub_1004F97F4() & 0x1000000000LL) != 0) {
    *(_BYTE *)(*(void *)(a1 + 2376) + 64sub_100E52020((uint64_t)va, 0LL) = 1;
  }
  else {
    sub_1005FCFE0(a1 + 88);
  }
  [*(id *)(a1 + 24) setNextFireDelay:1.79769313e308];
  return objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 2368), "vendor"), "proxyForService:", @"CLOdometerNotifier"),  "updatePhoneWorkoutElevationSubscription:",  1);
}

id sub_100E59D30(uint64_t a1)
{
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101888278);
  }
  char v2 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "WorkoutElevation,subs,phone,1", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "WorkoutElevation,subs,phone,1",  v6,  2);
    unint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::doSubscribe(const T *) [T = CLElevationController::ESourceAvailable]",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  if ((sub_1004F97F4() & 0x1000000000LL) != 0) {
    *(_BYTE *)(*(void *)(a1 + 2376) + 64sub_100E52020((uint64_t)va, 0LL) = 1;
  }
  else {
    sub_1005FCFE0(a1 + 88);
  }
  [*(id *)(a1 + 24) setNextFireDelay:1.79769313e308];
  return objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 2368), "vendor"), "proxyForService:", @"CLOdometerNotifier"),  "updatePhoneWorkoutElevationSubscription:",  1);
}

id sub_100E59F10(uint64_t a1)
{
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101888278);
  }
  char v2 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "WorkoutElevation,subs,phone,1", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "WorkoutElevation,subs,phone,1",  v6,  2);
    unint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::doSubscribe(const T *) [T = CLElevationController::EWorkoutStart]",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  if ((sub_1004F97F4() & 0x1000000000LL) != 0) {
    *(_BYTE *)(*(void *)(a1 + 2376) + 64sub_100E52020((uint64_t)va, 0LL) = 1;
  }
  else {
    sub_1005FCFE0(a1 + 88);
  }
  [*(id *)(a1 + 24) setNextFireDelay:1.79769313e308];
  return objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 2368), "vendor"), "proxyForService:", @"CLOdometerNotifier"),  "updatePhoneWorkoutElevationSubscription:",  1);
}

id sub_100E5A0F0(uint64_t a1)
{
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101888278);
  }
  char v2 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "WorkoutElevation,subs,phone,cancelWaitingToUnsubscribe",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  2LL,  "WorkoutElevation,subs,phone,cancelWaitingToUnsubscribe",  v6,  2);
    unint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::doCancelWaitToUnsubscribe(const T *) [T = CLElevationController::ESourceAvailable]",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  return [*(id *)(a1 + 24) setNextFireDelay:1.79769313e308];
}

id sub_100E5A290(uint64_t a1)
{
  if (qword_1019345B0 != -1) {
    dispatch_once(&qword_1019345B0, &stru_101888278);
  }
  char v2 = (os_log_s *)qword_1019345B8;
  if (os_log_type_enabled((os_log_t)qword_1019345B8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "WorkoutElevation,subs,phone,0", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345B0 != -1) {
      dispatch_once(&qword_1019345B0, &stru_101888278);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345B8,  1LL,  "WorkoutElevation,subs,phone,0",  v6,  2);
    unint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLElevationController::doUnsubscribe(const T *) [T = CLElevationController::ETimerExpires]",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  if ((sub_1004F97F4() & 0x1000000000LL) != 0) {
    sub_100E59580(*(void *)(a1 + 2376), 0);
  }
  else {
    sub_1005FCFE0(a1 + 88);
  }
  [*(id *)(a1 + 24) setNextFireDelay:1.79769313e308];
  return objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a1 + 2368), "vendor"), "proxyForService:", @"CLOdometerNotifier"),  "updatePhoneWorkoutElevationSubscription:",  0);
}

void sub_100E5A46C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_100210578((void *)(a2 + 344));
    sub_100210578((void *)(a2 + 296));
    *(void *)(a2 + 192) = off_10182B230;
    sub_100008390(a2 + 256, *(void **)(a2 + 264));
    sub_100210578((void *)(a2 + 208));
    sub_1002D62D8((void *)(a2 + 144));
    sub_10046D318((void *)(a2 + 96));
    sub_1002D62D8((void *)(a2 + 48));
    uint64_t v3 = (void *)sub_10046D318((void *)a2);
    operator delete(v3);
  }

uint64_t sub_100E5A4E4()
{
  dword_10199ECF8 = 800;
  __cxa_atexit((void (*)(void *))sub_100355650, qword_10199ECE0, (void *)&_mh_execute_header);
  sub_1010DDBC0(qword_10199ED00, "DmFp");
  dword_10199ED18 = 200;
  __cxa_atexit((void (*)(void *))sub_100355650, qword_10199ED00, (void *)&_mh_execute_header);
  sub_1010DDBC0(qword_10199ED20, "VO2MaxPowerBudgetEstimatorLastExtendedBudgetAllotmentReason");
  return __cxa_atexit((void (*)(void *))&std::string::~string, qword_10199ED20, (void *)&_mh_execute_header);
}

_BYTE *sub_100E5A59C(_BYTE *__dst, unsigned __int8 *a2, size_t a3)
{
  else {
    *std::string __dst = -1;
  }
  return __dst;
}

unsigned __int8 *sub_100E5A608(unsigned __int8 *result, void *a2)
{
  unsigned int v2 = *result - 1;
  if (v2 <= 8) {
    return (unsigned __int8 *)(*(uint64_t (**)(void *, unsigned __int8 *))(*a2
  }
                                                                                     + 8LL * v2
                                                                                     + 16))( a2,  result);
  return result;
}

uint64_t sub_100E5A638(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t v7 = (void *)sub_100C6AAF0(a1, a2, a3, a4, a5);
  void *v7 = off_1018882B8;
  v7[6] = 0LL;
  v7[7] = 0LL;
  _WORD v7[8] = 0LL;
  sub_10036B3B4((uint64_t)sub_100E5A718, a1, a3, &v12);
  uint64_t v8 = v12;
  uint64_t v12 = 0LL;
  uint64_t v9 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
    uint64_t v10 = v12;
    uint64_t v12 = 0LL;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
    }
  }

  return a1;
}

void sub_100E5A6E0(_Unwind_Exception *a1)
{
  uint64_t v5 = *(void *)(v1 + 64);
  *(void *)(v1 + 64) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  sub_1012746E0(v3, v2);
  sub_100C6AB50(v1);
  _Unwind_Resume(a1);
}

void sub_100E5A718(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101888308);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    uint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLMotionStateSubscription::onMotionStateNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101888308);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      int v15 = "";
      __int16 v16 = 2082;
      int v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLMotionStateSubscription::onMotionStateNotification, event:%{public, location:esca pe_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100E5B4BC(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E5A8D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E5A8F4(void *a1)
{
  *a1 = off_1018882B8;
  uint64_t v2 = a1[8];
  a1[8] = 0LL;
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
    uint64_t v3 = a1[8];
    a1[8] = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  uint64_t v4 = a1[7];
  a1[7] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = a1[6];
  a1[6] = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return sub_100C6AB50((uint64_t)a1);
}

void sub_100E5A984(void *a1)
{
  uint64_t v1 = (void *)sub_100E5A8F4(a1);
  operator delete(v1);
}

void *sub_100E5A998@<X0>(uint64_t a1@<X8>)
{
  v15[0] = &off_101888378;
  v15[1] = sub_100E5ACB8;
  void v15[2] = 0LL;
  __int16 v16 = v15;
  sub_1010DDBC0(v17, "kCLConnectionMessageMotionState");
  sub_10089A0CC((uint64_t)&v18, (uint64_t)v15);
  v13[0] = &off_101888408;
  v13[1] = sub_100E5AF0C;
  void v13[2] = 0LL;
  __int16 v14 = v13;
  sub_1010DDBC0(v19, "kCLConnectionMessageMotionStateSim");
  sub_10089A0CC((uint64_t)&v20, (uint64_t)v13);
  v11[0] = &off_101888408;
  v11[1] = sub_100E5B224;
  _DWORD v11[2] = 0LL;
  uint64_t v12 = v11;
  sub_1010DDBC0(v21, "kCLConnectionMessageMotionStateYouthSim");
  sub_10089A0CC((uint64_t)v22, (uint64_t)v11);
  sub_100E5C024(a1, (unsigned __int8 *)v17, 3LL);
  for (uint64_t i = 0LL; i != -21; i -= 7LL)
  {
    uint64_t v3 = *(_BYTE **)&v22[i * 8 + 24];
    if (&v22[i * 8] == v3)
    {
      uint64_t v3 = &v22[i * 8];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE(v21[i + 2]) < 0) {
      operator delete((void *)v21[i]);
    }
  }

  uint64_t v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v11;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v12)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  uint64_t v7 = v14;
  if (v14 == v13)
  {
    uint64_t v8 = 4LL;
    uint64_t v7 = v13;
LABEL_19:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  else if (v14)
  {
    uint64_t v8 = 5LL;
    goto LABEL_19;
  }

  double result = v16;
  if (v16 == v15)
  {
    uint64_t v10 = 4LL;
    double result = v15;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v10))();
  }

  else if (v16)
  {
    uint64_t v10 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v10))();
  }

  return result;
}

void sub_100E5ABAC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, char a13, uint64_t a14, uint64_t a15, char *a16, char a17, uint64_t a18, uint64_t a19, char *a20, char a21)
{
  for (uint64_t i = 112LL; i != -56; i -= 56LL)
    sub_10026E430((uint64_t)(&a21 + i));
  int v23 = a12;
  if (a12 == &a9)
  {
    uint64_t v24 = 4LL;
    int v23 = &a9;
  }

  else
  {
    if (!a12) {
      goto LABEL_8;
    }
    uint64_t v24 = 5LL;
  }

  (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_8:
  unint64_t v25 = a16;
  if (a16 == &a13)
  {
    uint64_t v26 = 4LL;
    unint64_t v25 = &a13;
  }

  else
  {
    if (!a16) {
      goto LABEL_13;
    }
    uint64_t v26 = 5LL;
  }

  (*(void (**)(void))(*(void *)v25 + 8 * v26))();
LABEL_13:
  unint64_t v27 = a20;
  if (a20 == &a17)
  {
    uint64_t v28 = 4LL;
    unint64_t v27 = &a17;
  }

  else
  {
    if (!a20) {
      goto LABEL_18;
    }
    uint64_t v28 = 5LL;
  }

  (*(void (**)(void))(*(void *)v27 + 8 * v28))();
LABEL_18:
  _Unwind_Resume(a1);
}

void sub_100E5ACB8(uint64_t a1, int a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  if (qword_1019344F0 != -1) {
    dispatch_once(&qword_1019344F0, &stru_101888328);
  }
  uint64_t v5 = (os_log_s *)qword_1019344F8;
  if (os_log_type_enabled((os_log_t)qword_1019344F8, OS_LOG_TYPE_INFO))
  {
    uint64_t v6 = *(void *)(a1 + 24);
    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v18 = v6;
    __int16 v19 = 1024;
    int v20 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Received MotionState request,client,%@,subscribe,%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344F0 != -1) {
      dispatch_once(&qword_1019344F0, &stru_101888328);
    }
    uint64_t v10 = *(void *)(a1 + 24);
    int v13 = 138412546;
    uint64_t v14 = v10;
    __int16 v15 = 1024;
    int v16 = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344F8,  1LL,  "Received MotionState request,client,%@,subscribe,%d",  &v13,  18);
    uint64_t v12 = (uint8_t *)v11;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMotionStateSubscription::handleRequestMotionState(BOOL, const CLNameValuePair &)",  "%s\n",  v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  sub_100C6AC8C(a1);
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(v7 + 8);
  uint64_t v8 = *(void **)(v7 + 16);
  if (a2) {
    [v8 register:v9 forNotification:1 registrationInfo:0];
  }
  else {
    [v8 unregister:v9 forNotification:1];
  }
}

void sub_100E5AED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E5AF0C(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  sub_100C6AC8C(a1);
  Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
  id v6 = [Dictionary objectForKeyedSubscript:CMMotionStateSim];
  id v7 = [Dictionary objectForKeyedSubscript:CMMotionStateSimState];
  uint64_t v8 = v7;
  if (v6) {
    BOOL v9 = v7 == 0LL;
  }
  else {
    BOOL v9 = 1;
  }
  if (v9)
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101888348);
    }
    uint64_t v10 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "Invalid message recieved from framework.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_101888348);
      }
      v18[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934978,  17LL,  "Invalid message recieved from framework.",  v18,  2);
      int v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMotionStateSubscription::handleMessageMotionStateSim(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }
  }

  uint64_t v11 = sub_1008FA854(0);
  uint64_t v12 = v11;
  if (v11 && ((*(uint64_t (**)(uint64_t))(*(void *)v11 + 96LL))(v11) & 1) != 0)
  {
    unsigned __int8 v13 = [v6 BOOLValue];
    uint64_t v14 = *(void *)(a1 + 48);
    if ((v13 & 1) != 0)
    {
      if (!v14)
      {
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 3221225472LL;
        void v17[2] = sub_100E5B80C;
        void v17[3] = &unk_10184D848;
        _DWORD v17[4] = v8;
        v17[5] = a1;
        (*(void (**)(uint64_t, void *))(*(void *)v12 + 112LL))(v12, v17);
        goto LABEL_20;
      }

      (*(void (**)(uint64_t, id))(*(void *)v14 + 16))(v14, [v8 unsignedIntValue]);
    }

    else
    {
      *(void *)(a1 + 48) = 0LL;
      if (v14) {
        (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
      }
    }

    sub_100E5B644(a1, 0LL);
  }

  else
  {
    sub_100E5B644(a1, 2LL);
  }

void sub_100E5B1E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E5B224(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  sub_100C6AC8C(a1);
  id v5 = [(id)CLConnectionMessage::getDictionary(*a2) objectForKeyedSubscript:CMMotionStateSimState];
  if (!v5)
  {
    if (qword_1019344F0 != -1) {
      dispatch_once(&qword_1019344F0, &stru_101888328);
    }
    id v6 = (os_log_s *)qword_1019344F8;
    if (os_log_type_enabled((os_log_t)qword_1019344F8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Failed to override motion state youth. Invalid message received from framework.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344F0 != -1) {
        dispatch_once(&qword_1019344F0, &stru_101888328);
      }
      v12[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344F8,  17LL,  "Failed to override motion state youth. Invalid message received from framework.",  v12,  2);
      uint64_t v10 = (uint8_t *)v9;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMotionStateSubscription::handleMessageMotionStateYouthSim(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v9);
      if (v10 != buf) {
        free(v10);
      }
    }
  }

  uint64_t v7 = sub_1008FA854(0);
  uint64_t v8 = *(void *)(a1 + 56);
  if (v8)
  {
    (*(void (**)(uint64_t, id))(*(void *)v8 + 16))(v8, [v5 unsignedIntValue]);
    sub_100E5B888(a1, 0LL);
  }

  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    _DWORD v11[2] = sub_100E5BA50;
    void v11[3] = &unk_10184D848;
    _DWORD v11[4] = v5;
    v11[5] = a1;
    (*(void (**)(uint64_t, void *))(*(void *)v7 + 120LL))(v7, v11);
  }
}

void sub_100E5B484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E5B4BC(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (*a3 == 1)
  {
    id v6 = objc_alloc(&OBJC_CLASS___CMActivity);
    __int128 v7 = *(_OWORD *)(a4 + 112);
    v13[6] = *(_OWORD *)(a4 + 96);
    v13[7] = v7;
    uint64_t v14 = *(void *)(a4 + 128);
    __int128 v8 = *(_OWORD *)(a4 + 48);
    void v13[2] = *(_OWORD *)(a4 + 32);
    void v13[3] = v8;
    __int128 v9 = *(_OWORD *)(a4 + 80);
    v13[4] = *(_OWORD *)(a4 + 64);
    v13[5] = v9;
    __int128 v10 = *(_OWORD *)(a4 + 16);
    v13[0] = *(_OWORD *)a4;
    v13[1] = v10;
    id v11 = [v6 initWithMotionActivity:v13];
    uint64_t v15 = CMActivityData;
    id v16 = v11;
    uint64_t v12 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v16,  &v15,  1LL);

    sub_100E5B59C(a1, &v12);
  }

void sub_100E5B59C(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100E5B630(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E5B644(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (dispatch_queue_s *)objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "silo"), "queue");
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100E5B6B0;
  v5[3] = &unk_101830538;
  v5[4] = a1;
  v5[5] = a2;
  dispatch_async(v4, v5);
}

uint64_t sub_100E5B6B0(uint64_t a1)
{
  uint64_t v4 = CMMotionStateSimResult;
  uint64_t v1 = *(void *)(a1 + 32);
  unint64_t v5 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", *(void *)(a1 + 40));
  uint64_t v3 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v5,  &v4,  1LL);
  sub_100E5B764(v1, &v3);
  return sub_100C6AC8C(v1);
}

void sub_100E5B764(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100E5B7F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E5B80C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *a2;
  *a2 = 0LL;
  uint64_t v5 = *(void *)(v3 + 48);
  *(void *)(v3 + 48) = v4;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    uint64_t v4 = *(void *)(v3 + 48);
  }

  if (v4)
  {
    (*(void (**)(uint64_t, id))(*(void *)v4 + 16))(v4, [*(id *)(a1 + 32) unsignedIntValue]);
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = 1LL;
  }

  sub_100E5B644(v3, v6);
}

void sub_100E5B888(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (dispatch_queue_s *)objc_msgSend(objc_msgSend(*(id *)(a1 + 8), "silo"), "queue");
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100E5B8F4;
  v5[3] = &unk_101830538;
  v5[4] = a1;
  v5[5] = a2;
  dispatch_async(v4, v5);
}

uint64_t sub_100E5B8F4(uint64_t a1)
{
  uint64_t v4 = CMMotionStateSimResult;
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v5 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", *(void *)(a1 + 40));
  uint64_t v3 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v5,  &v4,  1LL);
  sub_100E5B9A8(v1, &v3);
  return sub_100C6AC8C(v1);
}

void sub_100E5B9A8(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100E5BA3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E5BA50(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *a2;
  *a2 = 0LL;
  uint64_t v5 = *(void *)(v3 + 56);
  *(void *)(v3 + 56) = v4;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    uint64_t v4 = *(void *)(v3 + 56);
  }

  if (v4)
  {
    (*(void (**)(uint64_t, id))(*(void *)v4 + 16))(v4, [*(id *)(a1 + 32) unsignedIntValue]);
    uint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v6 = 1LL;
  }

  sub_100E5B888(v3, v6);
}

void sub_100E5BACC(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100E5BAF8(id a1)
{
  qword_1019344F8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Activity");
}

void sub_100E5BB24(id a1)
{
  qword_101934978 = (uint64_t)os_log_create("com.apple.locationd.Core", "Client");
}

__n128 sub_100E5BB50(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_101888378;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100E5BB8C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101888378;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100E5BBB0(uint64_t a1, uint64_t a2, __int128 *a3)
{
}

uint64_t sub_100E5BBB8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100E5BBF4()
{
}

void sub_100E5BC00(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v6 = *a3;
  *(void *)a3 = 0LL;
  *((void *)a3 + 1) = 0LL;
  sub_100E5BC84(a1, a2, (CLConnectionMessage **)&v6);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)&v6 + 1);
  if (*((void *)&v6 + 1))
  {
    uint64_t v4 = (unint64_t *)(*((void *)&v6 + 1) + 8LL);
    do
      unint64_t v5 = __ldaxr(v4);
    while (__stlxr(v5 - 1, v4));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100E5BC6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    sub_1012310A8(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E5BC84(uint64_t a1, uint64_t a2, CLConnectionMessage **a3)
{
  __int128 v6 = (NSSet *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  DictionaryOfClasses = (const __CFDictionary *)CLConnectionMessage::getDictionaryOfClasses(*a3, v6);
  sub_1002A5550((int)v15, DictionaryOfClasses);
  if ((sub_1002A6F64((uint64_t)v15, "kCLConnectionMessageSubscribeKey", &v14) & 1) != 0)
  {
    __int128 v8 = *(void (**)(void *, BOOL, uint8_t *))a1;
    uint64_t v9 = *(void *)(a1 + 8);
    __int128 v10 = (void *)(a2 + (v9 >> 1));
    if ((v9 & 1) != 0) {
      __int128 v8 = *(void (**)(void *, BOOL, uint8_t *))(*v10 + v8);
    }
    v8(v10, v14, v15);
  }

  else
  {
    if (qword_101934970 != -1) {
      dispatch_once(&qword_101934970, &stru_101888348);
    }
    id v11 = (os_log_s *)qword_101934978;
    if (os_log_type_enabled((os_log_t)qword_101934978, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      __int16 v19 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
      if (qword_101934970 != -1) {
        dispatch_once(&qword_101934970, &stru_101888348);
      }
    }

    uint64_t v12 = (os_log_s *)qword_101934978;
    if (os_signpost_enabled((os_log_t)qword_101934978))
    {
      *(_DWORD *)__int128 buf = 68289026;
      int v17 = 0;
      __int16 v18 = 2082;
      __int16 v19 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Couldn't get value for kCLConnectionMessageSubscribeKey key",  "{msg%{public}.0s:Couldn't get value for kCLConnectionMessageSubscribeKey key}",  buf,  0x12u);
    }
  }

  return sub_1002A5590(v15);
}

void sub_100E5BE68( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

__n128 sub_100E5BE84(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_101888408;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100E5BEC0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101888408;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100E5BEE4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_100E5BEEC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100E5BF28()
{
}

void sub_100E5BF34(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  uint64_t v15 = v3;
  *a3 = 0LL;
  a3[1] = 0LL;
  unint64_t v5 = *(void (**)(void *, uint64_t *))a1;
  uint64_t v6 = *(void *)(a1 + 8);
  __int128 v7 = (void *)(a2 + (v6 >> 1));
  if ((v6 & 1) != 0) {
    unint64_t v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
  }
  uint64_t v16 = v4;
  int v17 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  v5(v7, &v16);
  __int128 v10 = v17;
  if (v17)
  {
    id v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (v15)
  {
    unsigned __int8 v13 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_100E5C008( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100E5C024(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_100E5C09C(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100E5C088(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_100E5C09C(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  __int128 v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    unsigned __int8 v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_100E5C31C(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  __int16 v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    void *v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_100E5C304(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100E5C31C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  void *v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_100E5C390(v8 + 2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100E5C378(_Unwind_Exception *a1)
{
}

void *sub_100E5C390(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100E5C3E8(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100E5C404(uint64_t a1)
{
  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)(a1 + 8) = _Q0;
  *(void *)(a1 + 24) = 0xBFF0000000000000LL;
  *(_BYTE *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  *(void *)a1 = sub_1002F8DDC();
  return a1;
}

void sub_100E5C448(uint64_t a1, uint64_t a2, char a3)
{
  if (sub_100BEF640(a2) == 1)
  {
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 32);
    if (!*(_BYTE *)(a1 + 32))
    {
      *(_BYTE *)(a1 + 32) = 1;
      *(double *)(a1 + 8) = sub_100295E8C();
      sub_1002A82BC(*(void *)a1, "CLVO2MaxPreconditionCheckerTimeOfLastEstimate", (void *)(a1 + 16));
      sub_1002A82BC(*(void *)a1, "CLVO2MaxPreconditionCheckerTimeOfLastWorkout", (void *)(a1 + 24));
    }

    *(_BYTE *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a3;
    sub_100E5C4F0(a1, 1u);
  }

void sub_100E5C4F0(uint64_t a1, unsigned int a2)
{
  if (qword_1019344D0 != -1) {
    dispatch_once(&qword_1019344D0, &stru_101888490);
  }
  __int128 v4 = (os_log_s *)qword_1019344D8;
  if (os_log_type_enabled((os_log_t)qword_1019344D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(void *)(a1 + 16);
    *(_DWORD *)__int128 buf = 67109888;
    unsigned int v21 = a2;
    __int16 v22 = 2048;
    uint64_t v23 = v5;
    __int16 v24 = 2048;
    uint64_t v25 = v6;
    __int16 v26 = 1024;
    int v27 = sub_100E5C7EC(a1);
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "VO2MaxPrecondition,sessionStart,%d,sessionStartTime,%f,lastEstimateTime,%f,status,%d",  buf,  0x22u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344D0 != -1) {
      dispatch_once(&qword_1019344D0, &stru_101888490);
    }
    uint64_t v7 = qword_1019344D8;
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = *(void *)(a1 + 16);
    int v10 = sub_100E5C7EC(a1);
    *(_WORD *)unint64_t v15 = 2048;
    *(void *)&void v15[2] = v8;
    __int16 v16 = 2048;
    uint64_t v17 = v9;
    __int16 v18 = 1024;
    int v19 = v10;
    LODWORD(v13) = 34;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v7,  0LL,  "VO2MaxPrecondition,sessionStart,%d,sessionStartTime,%f,lastEstimateTime,%f,status,%d",  &v14,  v13,  COERCE_DOUBLE(__PAIR64__(a2, 67109888)),  *(_DWORD *)v15);
    unint64_t v12 = (uint8_t *)v11;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLVO2MaxPreconditionChecker::log(BOOL) const", "%s\n", v11);
    if (v12 != buf) {
      free(v12);
    }
  }

uint64_t sub_100E5C6F8(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_100BEF640(a2);
  if ((_DWORD)result == 2)
  {
    double v13 = sub_100295E8C();
    double v7 = *(double *)(a3 + 16);
    if (v7 != -1.0) {
      sub_1002AC7B8(*a1, "CLVO2MaxPreconditionCheckerTimeOfLastEstimate", &v13);
    }
    if (*((_BYTE *)a1 + 32) && (*(_DWORD *)(a2 + 32) - 1) <= 1)
    {
      sub_1002AC7B8(*a1, "CLVO2MaxPreconditionCheckerTimeOfLastWorkout", &v13);
    }

    else if (v7 == -1.0)
    {
LABEL_9:
      sub_100E5C4F0((uint64_t)a1, 0);
      uint64_t result = sub_1002F8DDC();
      *a1 = result;
      __asm { FMOV            V0.2D, #-1.0 }

      *(_OWORD *)(a1 + 1) = _Q0;
      a1[3] = 0xBFF0000000000000LL;
      *((_BYTE *)a1 + 32) = 0;
      *((_DWORD *)a1 + 9) = 0;
      *((_BYTE *)a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
      return result;
    }

    (*(void (**)(uint64_t))(*(void *)*a1 + 944LL))(*a1);
    goto LABEL_9;
  }

  return result;
}

uint64_t sub_100E5C7EC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 36) == 3)
  {
    double v2 = *(double *)(a1 + 16);
    if (v2 >= 0.0)
    {
      double v4 = *(double *)(a1 + 8) - v2;
      BOOL v3 = v4 < sub_100AD3518();
    }

    else
    {
      BOOL v3 = 0;
    }

    double v5 = *(double *)(a1 + 24);
    if (v5 >= 0.0)
    {
      double v7 = *(double *)(a1 + 8) - v5;
      if (v7 >= sub_100AD35AC()) {
        unsigned int v6 = 0;
      }
      else {
        unsigned int v6 = -12;
      }
      goto LABEL_11;
    }
  }

  else
  {
    BOOL v3 = 0;
  }

  unsigned int v6 = 0;
LABEL_11:
  if (*(_BYTE *)(a1 + 32)) {
    uint64_t result = 4294967286LL;
  }
  else {
    uint64_t result = 0LL;
  }
  if (*(_BYTE *)(a1 + 32) && !v3)
  {
    if (*(_BYTE *)(a1 + 40)) {
      return 4294967285LL;
    }
    else {
      return v6;
    }
  }

  return result;
}

void sub_100E5C8A0(id a1)
{
  qword_1019344D8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Calorimetry");
}

double sub_100E5C8CC(uint64_t a1)
{
  *(_OWORD *)a1 = xmmword_101362AF0;
  *(_OWORD *)(a1 + 16) = xmmword_101362AF0;
  *(void *)(a1 + 32) = *((void *)sub_100F4BF20() + 3);
  *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *((void *)sub_100F4BF20() + 4);
  *(void *)(a1 + 48) = *((void *)sub_100F4BF20() + 5);
  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)(a1 + 56) = _Q0;
  *(_OWORD *)(a1 + 72) = _Q0;
  *(_BYTE *)(a1 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  return result;
}

uint64_t sub_100E5C934(uint64_t a1)
{
  return a1;
}

__n128 sub_100E5C958@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(a2 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(a2 + 112) = v2;
  *(void *)(a2 + 128) = *(void *)(a1 + 128);
  __int128 v3 = *(_OWORD *)(a1 + 48);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a1 + 32);
  *(_OWORD *)(a2 + 48) = v3;
  __int128 v4 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 64);
  *(_OWORD *)(a2 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v4;
  __n128 result = *(__n128 *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(__n128 *)(a2 + 16) = result;
  return result;
}

void sub_100E5C984(uint64_t a1, double *a2, double *a3, double *a4, uint64_t a5, double *a6, double *a7)
{
  BOOL v14 = sub_100E5D040(a3, a4);
  if (v14)
  {
    if (*(_BYTE *)(a1 + 120))
    {
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_1018884B0);
      }
      unint64_t v15 = (os_log_s *)qword_101934858;
      if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, already initialized",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_1018884B0);
        }
        LOWORD(v3sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
        __int16 v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, already initialized",  &v30,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWifiAltitudeKalmanFilter::initializeKalmanFilter(const CFAbsoluteTime &, const double &, const double & , const CL::Wifi1::Types::ElevationHistory *, const double &, const double &)",  "%s\n",  v16);
LABEL_11:
      }
    }

    else
    {
      if (!sub_100E5D334(v14, a2, a5, a4, a6, a7)) {
        return;
      }
      uint64_t v17 = (void *)(a5 + 8);
      sub_10068C294((uint64_t)buf, v17);
      uint64_t v18 = *(void *)(*(void *)(*(void *)&v39[4]
      sub_100231C10(buf);
      sub_10068C294((uint64_t)buf, v17);
      double v19 = *(double *)(*(void *)(*(void *)&v39[4]
                                  + (((unint64_t)(*((void *)&v42 + 1) + v42 - 1) >> 5) & 0x7FFFFFFFFFFFFF8LL))
      sub_100231C10(buf);
      if (*a2 >= 0.0)
      {
        if (v19 >= 0.0)
        {
          *(double *)(a1 + 64) = *a2;
          *(double *)(a1 + 72) = *a2;
          *(double *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v19;
          *(double *)a1 = *a3;
          double v24 = *((double *)sub_100F4BF20() + 7) * *a4;
          *(double *)(a1 + 8) = v24 * v24;
          *(void *)(a1 + 112) = v18;
          *(_BYTE *)(a1 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 1;
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_1018884B0);
          }
          uint64_t v25 = (os_log_s *)qword_101934858;
          if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
          {
            double v26 = *a2;
            double v27 = *a3;
            *(_DWORD *)__int128 buf = 134284289;
            *(double *)__int16 v39 = v26;
            *(_WORD *)&v39[8] = 2049;
            *(double *)&v39[10] = v19;
            __int16 v40 = 2049;
            double v41 = v27;
            LOWORD(v42) = 2050;
            *(double *)((char *)&v42 + 2) = v24;
            _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, initialized, wifi timestamp, %{private}0.3f, relative altitude timestamp, % {private}0.3f, initial altitude, %{private}0.3f, initial uncertainty, %{public}0.3f.",  buf,  0x2Au);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934850 != -1) {
              dispatch_once(&qword_101934850, &stru_1018884B0);
            }
            double v28 = *a2;
            double v29 = *a3;
            int v30 = 134284289;
            double v31 = v28;
            __int16 v32 = 2049;
            double v33 = v19;
            __int16 v34 = 2049;
            double v35 = v29;
            __int16 v36 = 2050;
            double v37 = v24;
            __int16 v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, initialized, wifi timestamp, %{private}0.3f, relative altitud e timestamp, %{private}0.3f, initial altitude, %{private}0.3f, initial uncertainty, %{public}0.3f.",  &v30,  42);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWifiAltitudeKalmanFilter::initializeKalmanFilter(const CFAbsoluteTime &, const double &, const doub le &, const CL::Wifi1::Types::ElevationHistory *, const double &, const double &)",  "%s\n",  v16);
            goto LABEL_11;
          }
        }

        else
        {
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_1018884B0);
          }
          uint64_t v23 = (os_log_s *)qword_101934858;
          if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 134283521;
            *(double *)__int16 v39 = v19;
            _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, did not initialize, relative altitude timestamp %{private}0.3f was negative.",  buf,  0xCu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934850 != -1) {
              dispatch_once(&qword_101934850, &stru_1018884B0);
            }
            int v30 = 134283521;
            double v31 = v19;
            __int16 v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, did not initialize, relative altitude timestamp %{private}0.3f was negative.",  &v30,  12);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWifiAltitudeKalmanFilter::initializeKalmanFilter(const CFAbsoluteTime &, const double &, const doub le &, const CL::Wifi1::Types::ElevationHistory *, const double &, const double &)",  "%s\n",  v16);
            goto LABEL_11;
          }
        }
      }

      else
      {
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_1018884B0);
        }
        unint64_t v20 = (os_log_s *)qword_101934858;
        if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
        {
          double v21 = *a2;
          *(_DWORD *)__int128 buf = 134283521;
          *(double *)__int16 v39 = v21;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, did not initialize, wifi measurement timestamp %{private}0.3f was negative.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934850 != -1) {
            dispatch_once(&qword_101934850, &stru_1018884B0);
          }
          double v22 = *a2;
          int v30 = 134283521;
          double v31 = v22;
          __int16 v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, did not initialize, wifi measurement timestamp %{private}0.3f was negative.",  &v30,  12);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWifiAltitudeKalmanFilter::initializeKalmanFilter(const CFAbsoluteTime &, const double &, const double &, const CL::Wifi1::Types::ElevationHistory *, const double &, const double &)",  "%s\n",  v16);
          goto LABEL_11;
        }
      }
    }
  }

BOOL sub_100E5D040(double *a1, double *a2)
{
  if (*a2 < 0.0 || (*(void *)a2 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000LL)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    __int128 v4 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      double v5 = *a2;
      *(_DWORD *)__int128 buf = 134349056;
      double v16 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, invalid uncertainty, %{public}0.3f",  buf,  0xCu);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    double v12 = *a2;
    LODWORD(v14) = 134349056;
    *(double *)((char *)&v14 + 4) = v12;
    uint8x8_t v11 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, invalid uncertainty, %{public}0.3f",  &v14,  12,  v14);
LABEL_25:
    double v13 = (uint8_t *)v11;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "static BOOL CLWifiAltitudeKalmanFilter::validAltitudeAndUncertainty(const double &, const double &)",  "%s\n",  v11);
    if (v13 != buf) {
      free(v13);
    }
    return 0LL;
  }

  if (*a1 >= -450.0 && *a1 <= 8850.0) {
    return 1LL;
  }
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_1018884B0);
  }
  uint64_t v8 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    double v9 = *a1;
    *(_DWORD *)__int128 buf = 134283521;
    double v16 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, invalid altitude, %{private}0.3f",  buf,  0xCu);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    double v10 = *a1;
    LODWORD(v14) = 134283521;
    *(double *)((char *)&v14 + 4) = v10;
    uint8x8_t v11 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, invalid altitude, %{private}0.3f",  &v14,  12,  v14);
    goto LABEL_25;
  }

  return result;
}

BOOL sub_100E5D334(uint64_t a1, double *a2, uint64_t a3, double *a4, double *a5, double *a6)
{
  double v10 = (void *)(a3 + 8);
  sub_10068C294((uint64_t)v19, (void *)(a3 + 8));
  uint64_t v11 = v21;
  sub_100231C10(v19);
  if (!v11) {
    return 0LL;
  }
  sub_10068C294((uint64_t)v19, v10);
  double v12 = *(double *)(*(void *)(v19[1] + (((unint64_t)(v21 + v20 - 1) >> 5) & 0x7FFFFFFFFFFFFF8LL))
  sub_100231C10(v19);
  double v13 = *a4;
  double v14 = *a5;
  double v15 = vabdd_f64(*a2, v12);
  double v17 = *a5 - *a6;
  double v18 = *a6;
  return v18 >= *((double *)sub_100F4BF20() + 18);
}

BOOL sub_100E5D454(uint64_t a1, double *a2, void *a3, double *a4, double *a5, _BYTE *a6)
{
  if (!*(_BYTE *)(a1 + 120))
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    double v17 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, did not propagate and update, not initialized",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_1018884B0);
      }
      LOWORD(v31) = 0;
      double v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, did not propagate and update, not initialized",  &v31,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAltitudeKalmanFilter::propagateAndUpdate(const CFAbsoluteTime &, const CL::Wifi1::Types::ElevationHis tory *, const double &, const double &, const BOOL &)",  "%s\n",  v19);
      return 0LL;
    }

    return result;
  }

  double v12 = *a2 - *(double *)(a1 + 64);
  if (v12 >= *((double *)sub_100F4BF20() + 12))
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    uint64_t v20 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      double v21 = *a2 - *(double *)(a1 + 64);
      *(_DWORD *)__int128 buf = 134283521;
      double v33 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, stopping, did not propagate for, %{private}0.3f, seconds",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_55;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    double v22 = *a2 - *(double *)(a1 + 64);
    LODWORD(v31) = 134283521;
    *(double *)((char *)&v31 + 4) = v22;
    double v16 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, stopping, did not propagate for, %{private}0.3f, seconds",  &v31,  12,  v31);
LABEL_48:
    double v27 = (uint8_t *)v16;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAltitudeKalmanFilter::propagateAndUpdate(const CFAbsoluteTime &, const CL::Wifi1::Types::ElevationHisto ry *, const double &, const double &, const BOOL &)",  "%s\n",  v16);
    if (v27 != buf) {
      free(v27);
    }
    goto LABEL_55;
  }

  double v13 = *a2 - *(double *)(a1 + 72);
  if (v13 >= *((double *)sub_100F4BF20() + 13))
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    uint64_t v23 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      double v24 = *a2 - *(double *)(a1 + 72);
      *(_DWORD *)__int128 buf = 134283521;
      double v33 = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, stopping, did not update for, %{private}0.3f, seconds",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_55;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    double v25 = *a2 - *(double *)(a1 + 72);
    LODWORD(v31) = 134283521;
    *(double *)((char *)&v31 + 4) = v25;
    double v16 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, stopping, did not update for, %{private}0.3f, seconds",  &v31,  12,  v31);
    goto LABEL_48;
  }

  if (!sub_100E5DAE8(a1, a2, a3))
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    double v26 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, stopping, unable to propagate",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_55;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    LOWORD(v31) = 0;
    double v16 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, stopping, unable to propagate",  &v31,  2,  v31);
    goto LABEL_48;
  }

  if ((sub_100E5E3E0((double *)a1, a4, a5, v14, a6) & 1) != 0)
  {
    if (!sub_100E5E468(a1, a4, a5))
    {
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_1018884B0);
      }
      double v15 = (os_log_s *)qword_101934858;
      if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, stopping, unable to update",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_55;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_1018884B0);
      }
      LOWORD(v31) = 0;
      double v16 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, stopping, unable to update",  &v31,  2,  v31);
      goto LABEL_48;
    }
  }

  else
  {
    *(_OWORD *)a1 = *(_OWORD *)(a1 + 16);
  }

  double v28 = (double *)(a1 + 8);
  if (!sub_100E5D040((double *)a1, (double *)(a1 + 8)))
  {
LABEL_55:
    sub_100E5C8CC(a1);
    return 0LL;
  }

  double v29 = *((double *)sub_100F4BF20() + 28);
  double v30 = v29 * *((double *)sub_100F4BF20() + 28);
  if (v30 >= *v28) {
    double v30 = *v28;
  }
  double *v28 = v30;
  return 1LL;
}

BOOL sub_100E5DAE8(uint64_t a1, double *a2, void *a3)
{
  double v5 = *(double *)(a1 + 64);
  *(double *)(a1 + 96) = *a2 - v5;
  if (*a2 < v5)
  {
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    unsigned int v6 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = *(void *)(a1 + 64);
      double v8 = *a2;
      *(_DWORD *)__int128 buf = 134283777;
      *(void *)__int16 v51 = v7;
      *(_WORD *)&v51[8] = 2049;
      *(double *)&v51[10] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, did not propagate, filter's propagation timestamp, %{private}0.3f, is larger than current wifi timestamp, %{private}0.3f",  buf,  0x16u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_1018884B0);
      }
      uint64_t v10 = *(void *)(a1 + 64);
      double v11 = *a2;
      int v46 = 134283777;
      uint64_t v47 = v10;
      __int16 v48 = 2049;
      double v49 = v11;
      double v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, did not propagate, filter's propagation timestamp, %{private}0.3f, is larger than current wifi timestamp, %{private}0.3f",  &v46,  22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAltitudeKalmanFilter::propagate(const CFAbsoluteTime &, const CL::Wifi1::Types::ElevationHistory *)",  "%s\n",  v12);
LABEL_34:
      return 0LL;
    }

    return result;
  }

  *(double *)(a1 + 64) = *a2;
  uint64_t v14 = a3 + 1;
  sub_10068C294((uint64_t)buf, a3 + 1);
  uint64_t v15 = v53;
  sub_100231C10(buf);
  if (!v15)
  {
    double v27 = *(double *)(a1 + 8) + *(double *)(a1 + 96) * *(double *)(a1 + 96) * *(double *)(a1 + 48);
    *(void *)(a1 + 16) = *(void *)a1;
    *(double *)(a1 + 24) = v27;
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    double v28 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v29 = *(void *)(a1 + 64);
      *(_DWORD *)__int128 buf = 134283521;
      *(void *)__int16 v51 = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, propagated, timestamp, %{private}0.3f",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 2)) {
      return 1LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    goto LABEL_58;
  }

  sub_10068C294((uint64_t)buf, v14);
  double v16 = *(double *)(*(void *)(*(void *)&v51[4] + (((unint64_t)(v53 + v52 - 1) >> 5) & 0x7FFFFFFFFFFFFF8LL))
  sub_100231C10(buf);
  sub_10068C294((uint64_t)buf, v14);
  sub_100231C10(buf);
  int v18 = (*(uint64_t (**)(void *, double *))(*a3 + 16LL))(a3, a2);
  double v19 = *(double *)(a1 + 80);
  if (v16 >= v19)
  {
    int v20 = v18;
    double v21 = *(double *)(a1 + 112);
    *(double *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v16;
    *(double *)(a1 + 88) = v16 - v19;
    if (v16 - v19 <= *((double *)sub_100F4BF20() + 15))
    {
      double v25 = v17 - v21;
      double v26 = *(double *)(a1 + 88);
      if (v26 != 0.0) {
        *(void *)(a1 + 104) = 0LL;
      }
    }

    else
    {
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_1018884B0);
      }
      double v22 = (os_log_s *)qword_101934858;
      if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v23 = *(void *)(a1 + 88);
        uint64_t v24 = *(void *)(a1 + 104);
        *(_DWORD *)__int128 buf = 134283777;
        *(void *)__int16 v51 = v23;
        *(_WORD *)&v51[8] = 2049;
        *(void *)&v51[10] = v24;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, baro outage time interval, %{private}0.3f, altitude change over outage, %{private}0.3f",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_1018884B0);
        }
        uint64_t v42 = *(void *)(a1 + 88);
        double v43 = *(double *)(a1 + 104);
        int v46 = 134283777;
        uint64_t v47 = v42;
        __int16 v48 = 2049;
        double v49 = v43;
        unsigned int v44 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, baro outage time interval, %{private}0.3f, altitude change over o utage, %{private}0.3f",  &v46,  22);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAltitudeKalmanFilter::propagate(const CFAbsoluteTime &, const CL::Wifi1::Types::ElevationHistory *)",  "%s\n",  v44);
      }

      double v25 = v17 - *(double *)(a1 + 112) - *(double *)(a1 + 104);
      *(void *)(a1 + 104) = 0LL;
      double v26 = *(double *)(a1 + 88);
    }

    *(double *)(a1 + 112) = v17;
    double v33 = fabs(v25);
    if (v33 >= 2.5) {
      int v20 = 0;
    }
    if (v26 == 0.0)
    {
      if (v20)
      {
LABEL_46:
        double v35 = *(double *)(a1 + 8);
        *(void *)(a1 + 16) = *(void *)a1;
        double v36 = *(double *)(a1 + 96) * *(double *)(a1 + 96);
        double v37 = *(double *)(a1 + 32);
LABEL_49:
        *(double *)(a1 + 24) = v35 + v36 * v37;
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_1018884B0);
        }
        double v38 = (os_log_s *)qword_101934858;
        if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v39 = *(void *)(a1 + 64);
          *(_DWORD *)__int128 buf = 134283521;
          *(void *)__int16 v51 = v39;
          _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, propagated, timestamp, %{private}0.3f",  buf,  0xCu);
        }

        if (!sub_1002921D0(115, 2)) {
          return 1LL;
        }
        bzero(buf, 0x65CuLL);
        if (qword_101934850 != -1) {
          dispatch_once(&qword_101934850, &stru_1018884B0);
        }
LABEL_58:
        uint64_t v40 = *(void *)(a1 + 64);
        int v46 = 134283521;
        uint64_t v47 = v40;
        LODWORD(v45) = 12;
        double v41 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, propagated, timestamp, %{private}0.3f",  &v46,  v45);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAltitudeKalmanFilter::propagate(const CFAbsoluteTime &, const CL::Wifi1::Types::ElevationHistory *)",  "%s\n",  v41);
        return 1LL;
      }
    }

    else
    {
      else {
        char v34 = v20;
      }
      if ((v34 & 1) != 0) {
        goto LABEL_46;
      }
    }

    double v35 = *(double *)(a1 + 8);
    *(double *)(a1 + 16) = v25 + *(double *)a1;
    double v36 = *(double *)(a1 + 96) * *(double *)(a1 + 96);
    double v37 = *(double *)(a1 + 40);
    goto LABEL_49;
  }

  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_1018884B0);
  }
  double v30 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v31 = *(void *)(a1 + 80);
    *(_DWORD *)__int128 buf = 134283777;
    *(void *)__int16 v51 = v31;
    *(_WORD *)&v51[8] = 2049;
    *(double *)&v51[10] = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, did not propagate, filter's relative altitude timestamp, %{private}0.3f, is larger than current relative altitude timestamp, %{private}0.3f",  buf,  0x16u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    uint64_t v32 = *(void *)(a1 + 80);
    int v46 = 134283777;
    uint64_t v47 = v32;
    __int16 v48 = 2049;
    double v49 = v16;
    double v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, did not propagate, filter's relative altitude timestamp, %{private}0. 3f, is larger than current relative altitude timestamp, %{private}0.3f",  &v46,  22);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAltitudeKalmanFilter::propagate(const CFAbsoluteTime &, const CL::Wifi1::Types::ElevationHistory *)",  "%s\n",  v12);
    goto LABEL_34;
  }

  return result;
}

uint64_t sub_100E5E3E0(double *a1, double *a2, double *a3, uint64_t a4, _BYTE *a5)
{
  BOOL v8 = sub_100E5D040(a2, a3);
  double v9 = a1[12];
  if (v9 <= 0.0)
  {
    BOOL v11 = 1;
  }

  else
  {
    double v10 = vabdd_f64(*a2, *a1) / v9;
    BOOL v11 = v10 < *((double *)sub_100F4BF20() + 16);
  }

  if (*a5) {
    BOOL v12 = v8;
  }
  else {
    BOOL v12 = 0;
  }
  return v12 & v11;
}

BOOL sub_100E5E468(uint64_t a1, double *a2, double *a3)
{
  unsigned int v6 = (double *)sub_100F4BF20();
  double v7 = v6[7] * *a3 * (v6[7] * *a3);
  *(double *)(a1 + 56) = v7;
  double v8 = v7 + *(double *)(a1 + 24);
  if (v8 > 0.0)
  {
    double v9 = *a2 - *(double *)(a1 + 16);
    double v10 = v7 + *(double *)(a1 + 24);
    if (v9 * v9 / v8 > *((double *)sub_100F4BF20() + 20))
    {
      double v11 = 1.0;
      do
      {
        double v11 = v11 * *((double *)sub_100F4BF20() + 21);
        double v12 = *(double *)(a1 + 8) + *(double *)(a1 + 96) * (v11 * *(double *)(a1 + 96)) * *(double *)(a1 + 32);
        *(double *)(a1 + 24) = v12;
        double v10 = v12 + *(double *)(a1 + 56);
      }

      while (v9 * v9 / v10 > *((double *)sub_100F4BF20() + 20));
    }

    double v13 = *(double *)(a1 + 24);
    double v14 = *(double *)(a1 + 16) + v13 / v10 * v9;
    *(double *)(a1 + 8) = v13 * (1.0 - v13 / v10);
    *(void *)(a1 + 72) = *(void *)(a1 + 64);
    *(double *)a1 = v14;
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    uint64_t v15 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v16 = *(void *)(a1 + 72);
      *(_DWORD *)__int128 buf = 134283521;
      uint64_t v23 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, updated, timestamp, %{private}0.3f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_1018884B0);
      }
      uint64_t v18 = *(void *)(a1 + 72);
      int v20 = 134283521;
      uint64_t v21 = v18;
      double v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, updated, timestamp, %{private}0.3f",  &v20,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAltitudeKalmanFilter::update(const double &, const double &)",  "%s\n",  v19);
    }
  }

  return v8 > 0.0;
}

BOOL sub_100E5E720(uint64_t a1, uint64_t *a2, double *a3)
{
  if (!*(_BYTE *)(a1 + 120)) {
    return 0LL;
  }
  BOOL result = sub_100E5D040((double *)a1, (double *)(a1 + 8));
  if (result)
  {
    *a2 = *(void *)a1;
    double v7 = *((double *)sub_100F4BF20() + 8) * sqrt(*(double *)(a1 + 8));
    double v8 = *((double *)sub_100F4BF20() + 9);
    if (v7 >= v8) {
      double v8 = v7;
    }
    *a3 = v8;
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_1018884B0);
    }
    double v9 = (os_log_s *)qword_101934858;
    if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v10 = *a2;
      double v11 = *a3;
      *(_DWORD *)__int128 buf = 134283777;
      uint64_t v20 = v10;
      __int16 v21 = 2049;
      double v22 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "WifiCalc, zaxis, kalmanFilter, estimated altitude, %{private}0.3f, uncertainty, %{private}0.3f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934850 != -1) {
        dispatch_once(&qword_101934850, &stru_1018884B0);
      }
      uint64_t v12 = *a2;
      double v13 = *a3;
      int v15 = 134283777;
      uint64_t v16 = v12;
      __int16 v17 = 2049;
      double v18 = v13;
      double v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "WifiCalc, zaxis, kalmanFilter, estimated altitude, %{private}0.3f, uncertainty, %{private}0.3f",  &v15,  22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLWifiAltitudeKalmanFilter::getResults(double &, double &) const",  "%s\n",  v14);
    }

    return 1LL;
  }

  return result;
}

void sub_100E5E950(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

void sub_100E5E97C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361B8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361B8))
    {
      qword_1019361A0 = 0LL;
      qword_1019361A8 = 0LL;
      qword_1019361B0 = 0LL;
      uint64_t v1 = operator new(6uLL);
      qword_1019361A8 = (uint64_t)(v1 + 3);
      qword_1019361B0 = (uint64_t)(v1 + 3);
      *(_DWORD *)uint64_t v1 = 151521030;
      v1[2] = 3082;
      qword_1019361A0 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1001CDCD0, &qword_1019361A0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361B8);
    }
  }

void sub_100E5EA18(_Unwind_Exception *a1)
{
}

void sub_100E5EA30()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361D8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361D8))
    {
      qword_1019361C0 = 0LL;
      qword_1019361C8 = 0LL;
      qword_1019361D0 = 0LL;
      uint64_t v1 = operator new(2uLL);
      qword_1019361C0 = (uint64_t)v1;
      _WORD *v1 = 256;
      qword_1019361C8 = (uint64_t)(v1 + 1);
      qword_1019361D0 = (uint64_t)(v1 + 1);
      __cxa_atexit((void (*)(void *))sub_1001CDD00, &qword_1019361C0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361D8);
    }
  }

void sub_100E5EABC(_Unwind_Exception *a1)
{
}

uint64_t sub_100E5EAD4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(_BYTE *)(a2 + 3616) |= 1u;
  *(void *)(a2 + 616) = v4;
  double v5 = (char *)operator new(0xB8uLL);
  sub_1011861DC((uint64_t)v5);
  double v7 = (void **)(v6 + 128);
  sub_100139A60((void **)(v6 + 128), 0x18uLL);
  double v8 = (int *)(a1 + 20);
  double v9 = (int *)(a1 + 116);
  uint64_t v10 = v5 + 144;
  double v11 = (char *)*((void *)v5 + 17);
  do
  {
    if ((unint64_t)v11 >= *v10)
    {
      double v13 = (char *)*v7;
      uint64_t v14 = (v11 - (_BYTE *)*v7) >> 2;
      unint64_t v15 = v14 + 1;
      uint64_t v16 = *v10 - (void)v13;
      if (v16 >> 1 > v15) {
        unint64_t v15 = v16 >> 1;
      }
      else {
        unint64_t v17 = v15;
      }
      if (v17)
      {
        double v18 = (char *)sub_10000956C((uint64_t)(v5 + 144), v17);
        double v13 = (char *)*((void *)v5 + 16);
        double v11 = (char *)*((void *)v5 + 17);
      }

      else
      {
        double v18 = 0LL;
      }

      double v19 = &v18[4 * v14];
      *(_DWORD *)double v19 = *v8;
      uint64_t v12 = v19 + 4;
      while (v11 != v13)
      {
        int v20 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v19 - 1) = v20;
        v19 -= 4;
      }

      *((void *)v5 + 16) = v19;
      *((void *)v5 + 17) = v12;
      *((void *)v5 + 18) = &v18[4 * v17];
      if (v13) {
        operator delete(v13);
      }
    }

    else
    {
      *(_DWORD *)double v11 = *v8;
      uint64_t v12 = v11 + 4;
    }

    *((void *)v5 + 17) = v12;
    ++v8;
    double v11 = v12;
  }

  while (v8 != v9);
  __int16 v21 = (void **)(v5 + 104);
  sub_100139A60((void **)v5 + 13, 0x18uLL);
  double v22 = (int *)(a1 + 212);
  uint64_t v23 = v5 + 120;
  uint64_t v24 = (char *)*((void *)v5 + 14);
  do
  {
    if ((unint64_t)v24 >= *v23)
    {
      double v26 = (char *)*v21;
      uint64_t v27 = (v24 - (_BYTE *)*v21) >> 2;
      unint64_t v28 = v27 + 1;
      uint64_t v29 = *v23 - (void)v26;
      if (v29 >> 1 > v28) {
        unint64_t v28 = v29 >> 1;
      }
      else {
        unint64_t v30 = v28;
      }
      if (v30)
      {
        uint64_t v31 = (char *)sub_10000956C((uint64_t)(v5 + 120), v30);
        double v26 = (char *)*((void *)v5 + 13);
        uint64_t v24 = (char *)*((void *)v5 + 14);
      }

      else
      {
        uint64_t v31 = 0LL;
      }

      uint64_t v32 = &v31[4 * v27];
      *(_DWORD *)uint64_t v32 = *v9;
      double v25 = v32 + 4;
      while (v24 != v26)
      {
        int v33 = *((_DWORD *)v24 - 1);
        v24 -= 4;
        *((_DWORD *)v32 - 1) = v33;
        v32 -= 4;
      }

      *((void *)v5 + 13) = v32;
      *((void *)v5 + 14) = v25;
      *((void *)v5 + 15) = &v31[4 * v30];
      if (v26) {
        operator delete(v26);
      }
    }

    else
    {
      *(_DWORD *)uint64_t v24 = *v9;
      double v25 = v24 + 4;
    }

    *((void *)v5 + 14) = v25;
    ++v9;
    uint64_t v24 = v25;
  }

  while (v9 != v22);
  char v34 = (void **)(v5 + 152);
  sub_100139A60((void **)v5 + 19, 7uLL);
  double v35 = (int *)(a1 + 240);
  double v36 = v5 + 168;
  double v37 = (char *)*((void *)v5 + 20);
  do
  {
    if ((unint64_t)v37 >= *v36)
    {
      uint64_t v39 = (char *)*v34;
      uint64_t v40 = (v37 - (_BYTE *)*v34) >> 2;
      unint64_t v41 = v40 + 1;
      uint64_t v42 = *v36 - (void)v39;
      if (v42 >> 1 > v41) {
        unint64_t v41 = v42 >> 1;
      }
      else {
        unint64_t v43 = v41;
      }
      if (v43)
      {
        unsigned int v44 = (char *)sub_10000956C((uint64_t)(v5 + 168), v43);
        uint64_t v39 = (char *)*((void *)v5 + 19);
        double v37 = (char *)*((void *)v5 + 20);
      }

      else
      {
        unsigned int v44 = 0LL;
      }

      uint64_t v45 = &v44[4 * v40];
      *(_DWORD *)uint64_t v45 = *v22;
      double v38 = v45 + 4;
      while (v37 != v39)
      {
        int v46 = *((_DWORD *)v37 - 1);
        v37 -= 4;
        *((_DWORD *)v45 - 1) = v46;
        v45 -= 4;
      }

      *((void *)v5 + 19) = v45;
      *((void *)v5 + 2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v38;
      *((void *)v5 + 21) = &v44[4 * v43];
      if (v39) {
        operator delete(v39);
      }
    }

    else
    {
      *(_DWORD *)double v37 = *v22;
      double v38 = v37 + 4;
    }

    *((void *)v5 + 2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v38;
    ++v22;
    double v37 = v38;
  }

  while (v22 != v35);
  int v47 = *v35;
  v5[180] |= 1u;
  *((_DWORD *)v5 + 44) = v47;
  __int16 v48 = (void **)(v5 + 80);
  sub_1000210A0((void **)v5 + 10, 0xDuLL);
  double v49 = (unsigned __int8 *)(a1 + 244);
  unsigned int v50 = (unsigned __int8 *)(a1 + 257);
  __int16 v51 = v5 + 96;
  uint64_t v52 = (char *)*((void *)v5 + 11);
  do
  {
    int v53 = *v49;
    if ((unint64_t)v52 >= *v51)
    {
      int v55 = (char *)*v48;
      uint64_t v56 = (v52 - (_BYTE *)*v48) >> 2;
      unint64_t v57 = v56 + 1;
      uint64_t v58 = *v51 - (void)v55;
      if (v58 >> 1 > v57) {
        unint64_t v57 = v58 >> 1;
      }
      else {
        unint64_t v59 = v57;
      }
      if (v59)
      {
        uint64_t v60 = (char *)sub_10000956C((uint64_t)(v5 + 96), v59);
        int v55 = (char *)*((void *)v5 + 10);
        uint64_t v52 = (char *)*((void *)v5 + 11);
      }

      else
      {
        uint64_t v60 = 0LL;
      }

      __int128 v61 = &v60[4 * v56];
      *(_DWORD *)__int128 v61 = v53;
      unsigned int v54 = v61 + 4;
      while (v52 != v55)
      {
        int v62 = *((_DWORD *)v52 - 1);
        v52 -= 4;
        *((_DWORD *)v61 - 1) = v62;
        v61 -= 4;
      }

      *((void *)v5 + 1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v61;
      *((void *)v5 + 11) = v54;
      *((void *)v5 + 12) = &v60[4 * v59];
      if (v55) {
        operator delete(v55);
      }
    }

    else
    {
      *(_DWORD *)uint64_t v52 = v53;
      unsigned int v54 = v52 + 4;
    }

    *((void *)v5 + 11) = v54;
    ++v49;
    uint64_t v52 = v54;
  }

  while (v49 != v50);
  uint64_t result = *(void *)(a2 + 2104);
  *(void *)(a2 + 2104) = v5;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_100E5EF18(_Unwind_Exception *a1)
{
}

void sub_100E5F008(id a1)
{
  qword_10199ED38 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLSuggestedActionManagerSilo");
}

id sub_100E5F288(uint64_t a1)
{
  id result = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "activeRequests"), "count");
  if (result)
  {
    id v3 = +[NSMutableIndexSet indexSet](&OBJC_CLASS___NSMutableIndexSet, "indexSet");
    double Current = CFAbsoluteTimeGetCurrent();
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    uint64_t v31 = a1;
    id v5 = [*(id *)(a1 + 32) activeRequests];
    id v6 = [v5 countByEnumeratingWithState:&v32 objects:v48 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = 0LL;
      uint64_t v9 = *(void *)v33;
      do
      {
        uint64_t v10 = 0LL;
        do
        {
          if (*(void *)v33 != v9) {
            objc_enumerationMutation(v5);
          }
          double v11 = *(void **)(*((void *)&v32 + 1) + 8LL * (void)v10);
          [v11 timestamp];
          if (Current > v12 + 5.0)
          {
            [v3 addIndex:(char *)v10 + v8];
            if (qword_101934A70 != -1) {
              dispatch_once(&qword_101934A70, &stru_1018884F0);
            }
            double v13 = (os_log_s *)qword_101934A78;
            if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
            {
              [v11 lat];
              uint64_t v15 = v14;
              [v11 lon];
              uint64_t v17 = v16;
              [v11 radiusMeters];
              *(_DWORD *)__int128 buf = 134218496;
              uint64_t v43 = v15;
              __int16 v44 = 2048;
              uint64_t v45 = v17;
              __int16 v46 = 2048;
              double v47 = v18;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "TILE_APP: Removing request since it timed out, lat, %f, lon, %f, radius, %f.",  buf,  0x20u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_101934A70 != -1) {
                dispatch_once(&qword_101934A70, &stru_1018884F0);
              }
              uint64_t v20 = qword_101934A78;
              [v11 lat];
              uint64_t v22 = v21;
              [v11 lon];
              uint64_t v24 = v23;
              [v11 radiusMeters];
              int v36 = 134218496;
              uint64_t v37 = v22;
              __int16 v38 = 2048;
              uint64_t v39 = v24;
              __int16 v40 = 2048;
              double v41 = v25;
              LODWORD(v29) = 32;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v20,  2LL,  "TILE_APP: Removing request since it timed out, lat, %f, lon, %f, radius, %f.",  COERCE_DOUBLE(&v36),  v29,  v30);
              uint64_t v27 = (uint8_t *)v26;
              sub_10029211C("Generic", 1LL, 0, 2LL, "-[CLAppTileDataProvider beginService]_block_invoke", "%s\n", v26);
              if (v27 != buf) {
                free(v27);
              }
            }

            double v19 = (void (**)(id, void, NSError *))[v11 handler];
            v19[2]( v19,  0LL,  +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"CLAppTileDataProviderErrorDomain",  0LL,  0LL));
          }

          uint64_t v10 = (char *)v10 + 1;
        }

        while (v7 != v10);
        id v28 = [v5 countByEnumeratingWithState:&v32 objects:v48 count:16];
        id v7 = v28;
        v8 += (uint64_t)v10;
      }

      while (v28);
    }

    objc_msgSend(objc_msgSend(*(id *)(v31 + 32), "activeRequests"), "removeObjectsAtIndexes:", v3);
    id result = objc_msgSend(objc_msgSend(*(id *)(v31 + 32), "activeRequests"), "count");
    if (result) {
      return objc_msgSend(objc_msgSend(*(id *)(v31 + 32), "activeRequestCleanupTimer"), "setNextFireDelay:", 5.0);
    }
  }

  return result;
}

void sub_100E6007C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char *a55)
{
}

void sub_100E60908(uint64_t a1, unsigned int *a2, uint64_t *a3, void *a4)
{
  uint64_t v6 = *a2;
  uint64_t v7 = *a3;
  if (*((char *)a3 + 31) < 0)
  {
    sub_1010DD48C(&v8, (void *)a3[1], a3[2]);
  }

  else
  {
    __int128 v8 = *(_OWORD *)(a3 + 1);
    uint64_t v9 = a3[3];
  }

  if (*((char *)a3 + 55) < 0)
  {
    sub_1010DD48C(&v10, (void *)a3[4], a3[5]);
  }

  else
  {
    __int128 v10 = *((_OWORD *)a3 + 2);
    uint64_t v11 = a3[6];
  }

  if (*((char *)a3 + 79) < 0)
  {
    sub_1010DD48C(&__p, (void *)a3[7], a3[8]);
  }

  else
  {
    __int128 __p = *(_OWORD *)(a3 + 7);
    uint64_t v13 = a3[9];
  }

  [a4 onTileWasDownloadedNotification:v6 data:&v7];
  if (SHIBYTE(v13) < 0) {
    operator delete((void *)__p);
  }
  if (SHIBYTE(v11) < 0) {
    operator delete((void *)v10);
  }
  if (SHIBYTE(v9) < 0) {
    operator delete((void *)v8);
  }
}

void sub_100E60A14( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E61440(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_100E6146C()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936068);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936068))
    {
      qword_101936050 = 0LL;
      *(void *)algn_101936058 = 0LL;
      qword_101936060 = 0LL;
      __cxa_atexit((void (*)(void *))sub_1001BA3E4, &qword_101936050, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936068);
    }
  }

void sub_100E614D0()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936118);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936118))
    {
      std::__shared_mutex_base::__shared_mutex_base(&stru_101936070);
      __cxa_atexit((void (*)(void *))sub_1001BA414, &stru_101936070, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936118);
    }
  }

void sub_100E61544(_Unwind_Exception *a1)
{
}

void sub_100E617E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v3 = *(void **)(a1 + 32);
  if (v3)
  {
    if (objc_opt_respondsToSelector([*(id *)(a1 + 32) delegate], "eventUpdateForDevice:event:"))
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_100E61878;
      block[3] = &unk_10181A2D8;
      block[4] = v3;
      void block[5] = a2;
      block[6] = a3;
      dispatch_async((dispatch_queue_t)[v3 delegateQueue], block);
    }
  }

id sub_100E61878(uint64_t a1)
{
  return _objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "delegate"),  "eventUpdateForDevice:event:",  *(void *)(a1 + 40),  *(void *)(a1 + 48));
}

void sub_100E619F0(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

uint64_t sub_100E61A1C(uint64_t a1)
{
  uint64_t v2 = sub_100957944(a1) + 560;
  sub_10040A15C(v2, 0);
  sub_100E61D6C(a1 + 1424, v2);
  *(_DWORD *)(a1 + 1472) = 0;
  *(_OWORD *)(a1 + 1476) = xmmword_101362B00;
  int64x2_t v3 = vdupq_n_s64(1uLL);
  *(int64x2_t *)(a1 + 1496) = v3;
  *(_DWORD *)(a1 + 1512) = 0;
  *(_OWORD *)(a1 + 1516) = xmmword_101362B00;
  *(int64x2_t *)(a1 + 1536) = v3;
  *(void *)(a1 + 1584) = 0LL;
  *(_BYTE *)(a1 + 1592) = 0;
  *(_DWORD *)(a1 + 1596) = 2139095039;
  sub_10040B314(v2, (uint64_t)sub_100E61AF8, a1);
  *(_DWORD *)(a1 + 1472) = 0;
  *(_OWORD *)(a1 + 1476) = xmmword_101362B10;
  int64x2_t v4 = vdupq_n_s64(2uLL);
  *(int64x2_t *)(a1 + 1496) = v4;
  *(_DWORD *)(a1 + 1512) = 0;
  *(_OWORD *)(a1 + 1516) = xmmword_101362B20;
  *(int64x2_t *)(a1 + 1536) = v4;
  return a1;
}

void sub_100E61AE4(_Unwind_Exception *a1)
{
  void *v1 = &off_101837718;
  _Unwind_Resume(a1);
}

float sub_100E61AF8(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_1009583E8(a4, a1, a2);
}

BOOL sub_100E61B0C(uint64_t a1, float32x2_t *a2, double *a3)
{
  unint64_t v4 = (unint64_t)(*a3 * 1000000.0);
  unint64_t v16 = v4;
  float v5 = a2[1].f32[0];
  float32x2_t v14 = vmul_f32(*a2, (float32x2_t)vdup_n_s32(0x3C8EFA35u));
  float v15 = v5 * 0.017453;
  sub_100808DFC((float32x2_t *)(a1 + 1472), &v14);
  uint64_t v6 = *(void *)(a1 + 1504) - 1LL;
  *(void *)(a1 + 1504) = v6;
  if (!v6)
  {
    *(void *)(a1 + 1504) = *(void *)(a1 + 1496);
    unint64_t v7 = v4 - *(void *)(a1 + 1584);
    if (v7 >= 0xF4241)
    {
      sub_100957948(a1);
      sub_10040A1F4(a1 + 560, v7);
      if (*(_BYTE *)(a1 + 1592)) {
        sub_1007951AC((uint64_t *)(a1 + 1424), a1 + 1552);
      }
      float v8 = *(float *)(a1 + 1596);
      if (v8 != 3.4028e38) {
        sub_100795364(a1 + 1424, v8);
      }
    }

    *(void *)(a1 + 1584) = v4;
    int v9 = *(_DWORD *)(a1 + 1488);
    uint64_t v12 = *(void *)(a1 + 1480);
    int v13 = v9;
    sub_10040A7B0(a1 + 560, (uint64_t)&v12, &v16);
  }

  int v10 = *(unsigned __int8 *)(a1 + 1304);
  if (*(_BYTE *)(a1 + 1304)) {
    sub_100958424(a1, (uint64_t)&v14, v16);
  }
  return v10 != 0;
}

float32x2_t *sub_100E61C40(uint64_t a1, float32x2_t *a2, double *a3)
{
  __int32 v4 = a2[1].i32[0];
  float32x2_t v13 = *a2;
  __int32 v14 = v4;
  uint64_t v5 = (unint64_t)(*a3 * 1000000.0);
  uint64_t v12 = v5;
  id result = sub_100808DFC((float32x2_t *)(a1 + 1512), &v13);
  uint64_t v7 = *(void *)(a1 + 1544) - 1LL;
  *(void *)(a1 + 1544) = v7;
  if (!v7)
  {
    *(void *)(a1 + 1544) = *(void *)(a1 + 1536);
    int v8 = *(_DWORD *)(a1 + 1528);
    uint64_t v10 = *(void *)(a1 + 1520);
    int v11 = v8;
    sub_100958AB8((float32x4_t *)a1, (uint64_t)&v10, v5);
    int v9 = *(_DWORD *)(a1 + 1528);
    uint64_t v10 = *(void *)(a1 + 1520);
    int v11 = v9;
    return (float32x2_t *)sub_10040A77C(a1 + 560, (uint64_t)&v10);
  }

  return result;
}

void *sub_100E61CF0(uint64_t a1, float a2)
{
  id result = sub_100795364(a1 + 1424, a2);
  *(float *)(a1 + 1596) = a2;
  return result;
}

void *sub_100E61D24(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + 1592) = 1;
  *(_DWORD *)(a1 + 1552) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 1556) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 156sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 1564) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a1 + 1568) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 1572) = *(_DWORD *)(a2 + 20);
  *(_BYTE *)(a1 + 1576) = *(_BYTE *)(a2 + 24);
  return sub_1007951AC((uint64_t *)(a1 + 1424), a2);
}

uint64_t sub_100E61D6C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(_BYTE *)(a1 + 8) &= 0xFCu;
  if (!a2)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888578);
    }
    __int32 v4 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "Assertion failed: receiver, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMLinearTemperatureFit .h, line 27,receiver must not be null..",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888578);
      }
      v7[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Assertion failed: receiver, file /Library/Caches/com.apple.xbs/Sources/CoreLocation/Oscar/CMLinearTemperatureFit .h, line 27,receiver must not be null..",  v7,  2);
      uint64_t v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMLinearTemperatureFit::CMLinearTemperatureFit(CMTemperatureFitReceiver *)",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  return a1;
}

void sub_100E61F14(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

double sub_100E61F40(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v7 = sub_1006DC9EC(a1, a2, a3);
  *(void *)uint64_t v7 = off_1018885A8;
  *(_WORD *)(v7 + 28) = 256;
  *(_BYTE *)(v7 + 3sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  *(void *)(v7 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  *(void *)(v7 + 48) = 0LL;
  *(void *)(v7 + 32) = 0LL;
  *(_DWORD *)(v7 + 56) = a4;
  *(_DWORD *)(v7 + 6sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a5;
  double result = 0.0;
  *(_OWORD *)(v7 + 64) = 0u;
  *(_OWORD *)(v7 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0u;
  return result;
}

void *sub_100E61F94(void *a1)
{
  *a1 = off_1018885A8;
  uint64_t v2 = (uint64_t)(a1 + 4);
  sub_10000AE14((uint64_t)(a1 + 8));
  sub_10000AE14(v2);
  return sub_1006DCAA8(a1);
}

CFStringRef sub_100E61FDC(int a1)
{
  else {
    return *(&off_1018886B8 + a1 - 1);
  }
}

CFStringRef sub_100E62004(unsigned int a1)
{
  if (a1 > 4) {
    return @"?";
  }
  else {
    return *(&off_1018886F8 + (int)a1);
  }
}

CFStringRef sub_100E62028(int a1)
{
  uint64_t v1 = @"?";
  if (a1 == 1) {
    uint64_t v1 = @"Disconnected";
  }
  if (a1) {
    return v1;
  }
  else {
    return @"Connected";
  }
}

CFStringRef sub_100E62054(unsigned int a1)
{
  if (a1 > 2) {
    return @"?";
  }
  else {
    return *(&off_101888720 + (int)a1);
  }
}

BOOL sub_100E62078(uint64_t a1)
{
  if (!*(void *)(a1 + 80)) {
    return 1LL;
  }
  sub_1002E6920();
  return !sub_1002E90CC();
}

uint64_t sub_100E620A4()
{
  uint64_t v0 = sub_1002E6920();
  sub_1002E8818(v0, (int *)&v6 + 1, (int *)&v6);
  if (v6) {
    unsigned int v1 = 2;
  }
  else {
    unsigned int v1 = 4;
  }
  BOOL v3 = HIDWORD(v6) != 3 || (_DWORD)v6 != 3;
  if ((_DWORD)v6) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 3;
  }
  if (HIDWORD(v6)) {
    return v4;
  }
  else {
    return v1;
  }
}

void sub_100E62108(uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  if (!*(void *)(a1 + 32))
  {
    sub_1002E6920();
    int v4 = *(_DWORD *)(a1 + 56);
    int v3 = *(_DWORD *)(a1 + 60);
    if (*(_BYTE *)(a1 + 29))
    {
      uint64_t v5 = (uint64_t *)sub_10071542C();
      v14[0] = v4;
      v14[1] = v3;
      char v15 = 1;
      sub_10121B774(v5, (uint64_t)v14, (uint64_t *)&v16);
      sub_10005F550(v1, &v16);
      uint64_t v6 = (std::__shared_weak_count *)*((void *)&v16 + 1);
      if (*((void *)&v16 + 1))
      {
        uint64_t v7 = (unint64_t *)(*((void *)&v16 + 1) + 8LL);
        do
          unint64_t v8 = __ldaxr(v7);
        while (__stlxr(v8 - 1, v7));
LABEL_10:
        if (!v8)
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
      }
    }

    else
    {
      int v9 = (CFRunLoopTimerRef *)operator new(0x40uLL);
      sub_10052CE08(v9);
      sub_100E62CDC((void *)(a1 + 64), (uint64_t)v9);
      uint64_t v10 = *(uint64_t **)(a1 + 64);
      v12[0] = v4;
      v12[1] = v3;
      char v13 = 1;
      sub_10121B774(v10, (uint64_t)v12, (uint64_t *)&v16);
      sub_10005F550(v1, &v16);
      uint64_t v6 = (std::__shared_weak_count *)*((void *)&v16 + 1);
      if (*((void *)&v16 + 1))
      {
        int v11 = (unint64_t *)(*((void *)&v16 + 1) + 8LL);
        do
          unint64_t v8 = __ldaxr(v11);
        while (__stlxr(v8 - 1, v11));
        goto LABEL_10;
      }
    }

    sub_100719E00(*(void *)(a1 + 32), (uint64_t)sub_100E62844, a1);
    sub_100719E50(*(void **)(a1 + 32), (uint64_t)sub_100E62C9C, a1);
    sub_100719D78(*(uint64_t **)(a1 + 32), (uint64_t)sub_100E62838, a1);
  }

void sub_100E62258(_Unwind_Exception *a1)
{
}

BOOL sub_100E62278(uint64_t a1, uint64_t a2)
{
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_1006E27E8();
  if (Current != (CFRunLoopRef)sub_1006E2AB4()) {
    sub_1012748EC();
  }
  uint64_t v5 = (__IOHIDServiceClient *)sub_100719C6C(*(void *)(a1 + 32));
  if (v5)
  {
    sub_100FAD5AC((std::string *)(a2 + 8), v5, @"CFG#");
    sub_100FAD5AC((std::string *)(a2 + 32), v5, @"SerialNumber");
    sub_100E62338(a1);
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 48);
  }

  return v5 != 0LL;
}

void sub_100E62338(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 48))
  {
    int v2 = *(_DWORD *)(sub_1002E6920() + 24);
    switch(v2)
    {
      case 8202:
      case 8223:
        int v3 = 2;
        goto LABEL_23;
      case 8203:
      case 8204:
      case 8205:
      case 8207:
      case 8208:
      case 8209:
      case 8213:
      case 8214:
      case 8216:
      case 8218:
      case 8220:
      case 8221:
      case 8222:
        goto LABEL_6;
      case 8206:
        int v3 = 1;
        goto LABEL_23;
      case 8210:
        int v3 = 4;
        goto LABEL_23;
      case 8211:
        int v3 = 3;
        goto LABEL_23;
      case 8212:
        goto LABEL_5;
      case 8215:
        int v3 = 6;
        goto LABEL_23;
      case 8217:
        int v3 = 7;
        goto LABEL_23;
      case 8219:
        int v3 = 8;
        goto LABEL_23;
      default:
        if (v2 == 8228)
        {
LABEL_5:
          int v3 = 5;
LABEL_23:
          *(_DWORD *)(a1 + 48) = v3;
        }

        else
        {
LABEL_6:
          if (!*(void *)(a1 + 80))
          {
            int v4 = (void *)sub_1002E6920();
            if ((sub_1002E7ED0(v4, *(void *)(a1 + 80)) & 1) == 0)
            {
              if (qword_1019345C0 != -1) {
                dispatch_once(&qword_1019345C0, &stru_101888600);
              }
              uint64_t v5 = (os_log_s *)qword_1019345C8;
              if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__int128 buf = 67174657;
                int v9 = v2;
                _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "[CLAccessoryNotifier] Warning! The connected device %{private}d might not be supported",  buf,  8u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019345C0 != -1) {
                  dispatch_once(&qword_1019345C0, &stru_101888600);
                }
                v7[0] = 67174657;
                v7[1] = v2;
                uint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  16LL,  "[CLAccessoryNotifier] Warning! The connected device %{private}d might not be supported",  v7,  8);
                sub_10029211C("Generic", 1LL, 0, 0LL, "void CLAccessoryNotifier::refreshHardwareModel()", "%s\n", v6);
              }
            }
          }
        }

        break;
    }
  }

void sub_100E625D4(uint64_t a1, int a2)
{
  uint64_t v4 = sub_1002E6920();
  sub_1002E8368(v4, a1, a2);
}

void sub_100E62600(uint64_t a1)
{
  uint64_t v2 = sub_1002E6920();
  sub_1002E8448(v2, a1);
}

id sub_100E62624(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1002E6920();
  return sub_1002E8550(v3, a2);
}

void sub_100E62648(uint64_t a1, int a2, unint64_t a3, unint64_t a4)
{
  if (qword_1019345C0 != -1) {
    dispatch_once(&qword_1019345C0, &stru_101888600);
  }
  unint64_t v8 = (os_log_s *)qword_1019345C8;
  if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)__int128 buf = 67240704;
    int v17 = a2;
    __int16 v18 = 2050;
    unint64_t v19 = a3;
    __int16 v20 = 2050;
    unint64_t v21 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_INFO,  "[AccessoryNotifier] numberOfClientsChanged notification:%{public}d, from:%{public}zu, to:%{public}zu",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101888600);
    }
    v11[0] = 67240704;
    v11[1] = a2;
    __int16 v12 = 2050;
    unint64_t v13 = a3;
    __int16 v14 = 2050;
    unint64_t v15 = a4;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  1LL,  "[AccessoryNotifier] numberOfClientsChanged notification:%{public}d, from:%{public}zu, to:%{public}zu",  v11,  28);
    uint64_t v10 = (uint8_t *)v9;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLAccessoryNotifier::numberOfClientsChanged(int, size_t, size_t)",  "%s\n",  v9);
    if (v10 != buf) {
      free(v10);
    }
  }

  if (a3 < a4) {
    *(_BYTE *)(a1 + 3sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  }
}

uint64_t sub_100E62838(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56LL))(a1);
}

void sub_100E62844(uint64_t a1)
{
  uint64_t v21 = 0LL;
  uint64_t v2 = (__IOHIDServiceClient *)sub_100719C6C(*(void *)(a1 + 32));
  if (!v2 || (uint64_t v3 = v2, !sub_100FAD980(&v21, v2, @"BT_ADDR", (id)6)))
  {
LABEL_24:
    *(_DWORD *)(a1 + 48) = 0;
    uint64_t v4 = (_BYTE *)(a1 + 30);
    goto LABEL_25;
  }

  if (v21 != *(void *)(a1 + 80))
  {
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101888600);
    }
    unint64_t v13 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = *(void *)(a1 + 80);
      *(_DWORD *)__int128 buf = 134284033;
      double v30 = v3;
      __int16 v31 = 2049;
      *(void *)__int128 v32 = v14;
      *(_WORD *)&v32[8] = 2049;
      uint64_t v33 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "[AccessoryNotifier] onNewHidService for service %{private}p. Updating BT address from %{private}llx to %{private}llx",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101888600);
      }
      uint64_t v19 = *(void *)(a1 + 80);
      int v24 = 134284033;
      float v25 = v3;
      __int16 v26 = 2049;
      *(void *)uint64_t v27 = v19;
      *(_WORD *)&v27[8] = 2049;
      uint64_t v28 = v21;
      __int16 v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  0LL,  "[AccessoryNotifier] onNewHidService for service %{private}p. Updating BT address from %{private}ll x to %{private}llx",  &v24,  32);
      sub_10029211C("Generic", 1LL, 0, 2LL, "static void CLAccessoryNotifier::onNewHidService(void *)", "%s\n", v20);
    }

    if (*(void *)(a1 + 80))
    {
      *(void *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
      (*(void (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
    }

    *(void *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v21;
    uint64_t v15 = sub_1002E6920();
    sub_1002E6C9C(v15, *(void *)(a1 + 80));
    (*(void (**)(uint64_t))(*(void *)a1 + 48LL))(a1);
    uint64_t v16 = *(void *)(a1 + 88);
    if (!v16 || *(void *)(a1 + 80) == v16)
    {
      int v17 = +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", &v21, 6LL);
      uint64_t v18 = *(void *)(a1 + 32);
      uint64_t v22 = @"BT_ADDR";
      uint64_t v23 = v17;
      sub_10071A850( v18,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v23,  &v22,  1LL));
    }

    goto LABEL_24;
  }

  uint64_t v4 = (_BYTE *)(a1 + 30);
  if (*(_BYTE *)(a1 + 30))
  {
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101888600);
    }
    uint64_t v5 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(__IOHIDServiceClient **)(a1 + 80);
      int v7 = *(_DWORD *)(a1 + 56);
      int v8 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)__int128 buf = 134284033;
      double v30 = v6;
      __int16 v31 = 1026;
      *(_DWORD *)__int128 v32 = v7;
      *(_WORD *)&_DWORD v32[4] = 1026;
      *(_DWORD *)&v32[6] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "[AccessoryNotifier] Duplicate service with the same BT address %{private}llx for usage page %{public}d usage %{public}d",  buf,  0x18u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101888600);
      }
      int v9 = *(__IOHIDServiceClient **)(a1 + 80);
      int v10 = *(_DWORD *)(a1 + 56);
      int v11 = *(_DWORD *)(a1 + 60);
      int v24 = 134284033;
      float v25 = v9;
      __int16 v26 = 1026;
      *(_DWORD *)uint64_t v27 = v10;
      *(_WORD *)&v27[4] = 1026;
      *(_DWORD *)&v27[6] = v11;
      __int16 v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  16LL,  "[AccessoryNotifier] Duplicate service with the same BT address %{private}llx for usage page %{publ ic}d usage %{public}d",  &v24,  24);
      sub_10029211C("Generic", 1LL, 0, 0LL, "static void CLAccessoryNotifier::onNewHidService(void *)", "%s\n", v12);
    }
  }

void sub_100E62C9C(uint64_t *a1)
{
  a1[10] = 0LL;
  (*(void (**)(uint64_t *))(*a1 + 48))(a1);
  uint64_t v2 = sub_1002E6920();
  sub_1002E6C9C(v2, 0LL);
}

void sub_100E62CDC(void *a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)a1[1];
  __int128 v4 = v7;
  *(void *)&__int128 v7 = *a1;
  *((void *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100E62D4C(id a1)
{
  qword_1019345C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Accessory");
}

void sub_100E62D78(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void *sub_100E62DA4(void *a1, uint64_t a2)
{
  *a1 = a2;
  __int128 v4 = operator new(0x20uLL);
  *__int128 v4 = &off_101888650;
  v4[1] = 0LL;
  v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100E62DEC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E62E0C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_100E62E24(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

uint64_t sub_100E62E64@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X8>)
{
  return sub_1002DC708((uint64_t)(a2 + 754), a1 + 3016);
}

void sub_100E62EB0(_Unwind_Exception *a1)
{
}

_DWORD *sub_100E62EC4(_DWORD *a1, uint64_t a2)
{
  __int128 v4 = sub_1002E0454(a1);
  sub_1002DCA80((uint64_t)v4, a2);
  sub_1002DC4C4((uint64_t)(a1 + 202), a2 + 808);
  sub_1002DC708((uint64_t)(a1 + 754), a2 + 3016);
  return a1;
}

void sub_100E62F0C(_Unwind_Exception *a1)
{
}

_DWORD *sub_100E62F20(_DWORD *a1, uint64_t a2)
{
  __int128 v4 = sub_1002E0454(a1);
  sub_1002DCA80((uint64_t)v4, a2);
  sub_1002DC4C4((uint64_t)(a1 + 202), a2 + 808);
  sub_1002DC708((uint64_t)(a1 + 754), a2 + 3016);
  return a1;
}

void sub_100E62F68(_Unwind_Exception *a1)
{
}

void sub_100E62F7C(_BYTE *a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = sub_1002A6F64(*(uint64_t *)buf, "EmergencyWifiToggleAllowed", v11);
  if (v11[0]) {
    int v5 = 0;
  }
  else {
    int v5 = v4;
  }
  unint64_t v6 = v13;
  if (!v13) {
    goto LABEL_8;
  }
  p_shared_owners = (unint64_t *)&v13->__shared_owners_;
  do
    unint64_t v8 = __ldaxr(p_shared_owners);
  while (__stlxr(v8 - 1, p_shared_owners));
  if (!v8)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (v5) {
      goto LABEL_9;
    }
  }

  else
  {
LABEL_8:
    if (v5)
    {
LABEL_9:
      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_101888738);
      }
      int v9 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "emergency wifi toggle not allowed so skipping check",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_101888738);
        }
        *(_WORD *)int v11 = 0;
        int v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934898,  0LL,  "emergency wifi toggle not allowed so skipping check",  v11,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "Output CL::Wifi1::Policies::ScanRequest::HandleEvent::operator()(const Events::Client::EmergencyState &) const",  "%s\n",  v10);
      }

      return;
    }
  }

  if (a1[6172])
  {
    if (!a1[964] && !a1[6379])
    {
      if (!*(_BYTE *)(a2 + 1940)) {
        *(_BYTE *)(a2 + 194sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 1;
      }
      *(_DWORD *)(a2 + 1936) = 0;
    }
  }

  else if (a1[1064])
  {
    if (!*(_BYTE *)(a2 + 1940)) {
      *(_BYTE *)(a2 + 194sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 1;
    }
    *(_DWORD *)(a2 + 1936) = 1;
  }

void sub_100E631E0(_Unwind_Exception *a1)
{
}

void sub_100E6320C(int *a1@<X1>, _DWORD *a2@<X8>)
{
}

void sub_100E632B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100E632D0(id a1)
{
  qword_101934898 = (uint64_t)os_log_create("com.apple.locationd.Position", "Emergency");
}

void sub_100E632FC(int *a1@<X0>, _BYTE *a2@<X1>, _DWORD *a3@<X8>)
{
  switch(*a1 ^ (*a1 >> 31))
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x11:
    case 0x12:
    case 0x13:
    case 0x14:
    case 0x15:
    case 0x16:
    case 0x18:
    case 0x19:
    case 0x1A:
    case 0x1B:
    case 0x1C:
    case 0x1D:
      sub_100E62EC4(a3, (uint64_t)a2);
      break;
    case 0x17:
      sub_100E62F7C(a2, (uint64_t)a3);
      break;
    default:
      sub_1002DDAB0();
  }

void sub_100E63348()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361B8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361B8))
    {
      qword_1019361A0 = 0LL;
      qword_1019361A8 = 0LL;
      qword_1019361B0 = 0LL;
      uint64_t v1 = operator new(6uLL);
      qword_1019361A8 = (uint64_t)(v1 + 3);
      qword_1019361B0 = (uint64_t)(v1 + 3);
      *(_DWORD *)uint64_t v1 = 151521030;
      v1[2] = 3082;
      qword_1019361A0 = (uint64_t)v1;
      __cxa_atexit((void (*)(void *))sub_1001CDCD0, &qword_1019361A0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361B8);
    }
  }

void sub_100E633E4(_Unwind_Exception *a1)
{
}

void sub_100E633FC()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1019361D8);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_1019361D8))
    {
      qword_1019361C0 = 0LL;
      qword_1019361C8 = 0LL;
      qword_1019361D0 = 0LL;
      uint64_t v1 = operator new(2uLL);
      qword_1019361C0 = (uint64_t)v1;
      _WORD *v1 = 256;
      qword_1019361C8 = (uint64_t)(v1 + 1);
      qword_1019361D0 = (uint64_t)(v1 + 1);
      __cxa_atexit((void (*)(void *))sub_1001CDD00, &qword_1019361C0, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_1019361D8);
    }
  }

void sub_100E63488(_Unwind_Exception *a1)
{
}

id *sub_100E634A0(id *a1, void *a2, void *a3)
{
  *a1 = 0LL;
  a1[1] = a2;
  a1[2] = a3;
  *((_BYTE *)a1 + 24) = sub_1002958AC() == 1;
  *((_DWORD *)a1 + 7) = 0xFFFF;
  a1[4] = 0LL;
  a1[5] = 0LL;
  __asm { FMOV            V1.2D, #-1.0 }

  *((_OWORD *)a1 + 3) = xmmword_1012E0070;
  *((_OWORD *)a1 + 4) = _Q1;
  *((_OWORD *)a1 + 5) = _Q1;
  *((_OWORD *)a1 + 6) = _Q1;
  *((_DWORD *)a1 + 28) = 0;
  *(id *)((char *)a1 + 116) = (id)0xBFF0000000000000LL;
  *(id *)((char *)a1 + 132) = 0LL;
  *(id *)((char *)a1 + 124) = 0LL;
  *((_DWORD *)a1 + 35) = 0;
  a1[18] = (id)0xBFF0000000000000LL;
  *((_DWORD *)a1 + 38) = 0x7FFFFFFF;
  *(id *)((char *)a1 + 156) = 0LL;
  *(id *)((char *)a1 + 172) = 0LL;
  *(id *)((char *)a1 + 164) = 0LL;
  *((_BYTE *)a1 + 18sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  *(void *)&double v9 = sub_100869DC8(a1 + 23).n128_u64[0];
  *((_DWORD *)a1 + 206) = 0;
  if (objc_msgSend( objc_msgSend(a1[1], "vendor", v9),  "isServiceEnabled:",  @"CLCachedLocationController"))
  {
    sub_1005DD0E4((uint64_t)sub_100E635F8, (uint64_t)a1, a1[1], &v14);
    int v10 = v14;
    uint64_t v14 = 0LL;
    id v11 = *a1;
    *a1 = v10;
    if (v11)
    {
      (*(void (**)(id))(*(void *)v11 + 8LL))(v11);
      __int16 v12 = v14;
      uint64_t v14 = 0LL;
      if (v12) {
        (*(void (**)(void *))(*(void *)v12 + 8LL))(v12);
      }
    }

    [*((id *)*a1 + 2) register:*((void *)*a1 + 1) forNotification:1 registrationInfo:0];
  }

  return a1;
}

void sub_100E635BC(_Unwind_Exception *a1)
{
  uint64_t v3 = *v1;
  uint64_t *v1 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  _Unwind_Resume(a1);
}

void sub_100E635F8(uint64_t a1, int *a2, int *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101888758);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    unint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLLastConfidentLocation::onCachedLocationControllerNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101888758);
    }
    double v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      int v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLLastConfidentLocation::onCachedLocationControllerNotification, event:%{public, lo cation:escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100E65100(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E637B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

id *sub_100E637D4(id *a1)
{
  id v2 = *a1;
  *a1 = 0LL;
  if (v2) {
    (*(void (**)(id))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

uint64_t sub_100E63834(uint64_t a1)
{
  *(_BYTE *)(a1 + 24) = 1;
  [*(id *)(a1 + 8) silo];
  *(_DWORD *)(a1 + 824) = 0;
  return sub_100E63870(a1);
}

uint64_t sub_100E63870(uint64_t a1)
{
  uint64_t result = (uint64_t)[*(id *)(a1 + 8) silo];
  unsigned int v3 = *(_DWORD *)(a1 + 824);
  if (v3 <= 1)
  {
    *(_DWORD *)(a1 + 824) = v3 + 1;
    uint64_t result = sub_100E64B34(a1);
    if ((_DWORD)result)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888778);
      }
      int v4 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        int v5 = *(_DWORD *)(a1 + 824);
        uint64_t v6 = *(void *)(a1 + 48);
        uint64_t v7 = *(void *)(a1 + 104);
        uint64_t v8 = *(void *)(a1 + 116);
        *(_DWORD *)__int128 buf = 67109888;
        int v21 = v5;
        __int16 v22 = 2048;
        uint64_t v23 = v6;
        __int16 v24 = 2048;
        uint64_t v25 = v7;
        __int16 v26 = 2048;
        uint64_t v27 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Notifying cached location,num,%u,accuracy,%.01lf,timestamp,%.03lf,lifespan,%.04lf",  buf,  0x26u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888778);
        }
        uint64_t v9 = *(void *)(a1 + 48);
        uint64_t v10 = *(void *)(a1 + 104);
        uint64_t v11 = *(void *)(a1 + 116);
        double v14 = COERCE_DOUBLE(__PAIR64__(*(_DWORD *)(a1 + 824), 67109888));
        *(_WORD *)uint64_t v15 = 2048;
        *(void *)&void v15[2] = v9;
        __int16 v16 = 2048;
        uint64_t v17 = v10;
        __int16 v18 = 2048;
        uint64_t v19 = v11;
        LODWORD(v13) = 38;
        __int16 v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Notifying cached location,num,%u,accuracy,%.01lf,timestamp,%.03lf,lifespan,%.04lf",  &v14,  v13,  v14,  *(double *)v15);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLLastConfidentLocation::notifyConfidentLocationIfNecessary()",  "%s\n",  v12);
      }

      return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 16) + 16LL))( *(void *)(a1 + 16),  a1 + 28,  a1 + 184);
    }
  }

  return result;
}

void sub_100E63AA8(uint64_t a1)
{
  *(_DWORD *)(a1 + 824) = 2;
  *(_BYTE *)(a1 + 24) = 0;
  sub_100E63AE4(a1);
}

void sub_100E63AE4(uint64_t a1)
{
  *(_DWORD *)(a1 + 28) = 0xFFFF;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  __asm { FMOV            V1.2D, #-1.0 }

  *(_OWORD *)(a1 + 48) = xmmword_1012E0070;
  *(_OWORD *)(a1 + 64) = _Q1;
  *(_OWORD *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = _Q1;
  *(_OWORD *)(a1 + 96) = _Q1;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 116) = 0xBFF0000000000000LL;
  *(void *)(a1 + 132) = 0LL;
  *(void *)(a1 + 124) = 0LL;
  *(_DWORD *)(a1 + 14sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  *(void *)(a1 + 144) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 152) = 0x7FFFFFFF;
  *(void *)(a1 + 156) = 0LL;
  *(void *)(a1 + 172) = 0LL;
  *(void *)(a1 + 164) = 0LL;
  *(_BYTE *)(a1 + 18sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  sub_100869DC8(v13);
  memcpy((void *)(a1 + 184), v13, 0x201uLL);
  sub_10005F550(a1 + 704, v14);
  __int128 v7 = *(_OWORD *)v15;
  *(_OWORD *)(a1 + 784) = v14[5];
  *(_OWORD *)(a1 + 80sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v7;
  *(void *)(a1 + 813) = *(void *)&v15[13];
  __int128 v8 = v14[2];
  *(_OWORD *)(a1 + 72sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v14[1];
  *(_OWORD *)(a1 + 736) = v8;
  __int128 v9 = v14[4];
  *(_OWORD *)(a1 + 752) = v14[3];
  *(_OWORD *)(a1 + 768) = v9;
  uint64_t v10 = (std::__shared_weak_count *)*((void *)&v14[0] + 1);
  if (*((void *)&v14[0] + 1))
  {
    uint64_t v11 = (unint64_t *)(*((void *)&v14[0] + 1) + 8LL);
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

void sub_100E63BF4(uint64_t a1, int *a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 24))
  {
    if (*a2 >= 6)
    {
      if (*a2 == 22)
      {
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888778);
        }
        uint64_t v6 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          int v7 = *(_DWORD *)(a1 + 824);
          uint64_t v8 = sub_100CBED60(*(int **)(a3 + 800));
          *(_DWORD *)__int128 buf = 67109376;
          int v29 = v7;
          __int16 v30 = 2048;
          uint64_t v31 = v8;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Received kNotificationWifiLocationBatched, num,%u,Size, %lu",  buf,  0x12u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888778);
          }
          uint64_t v17 = qword_101934A78;
          int v18 = *(_DWORD *)(a1 + 824);
          uint64_t v19 = sub_100CBED60(*(int **)(a3 + 800));
          int v24 = 67109376;
          int v25 = v18;
          __int16 v26 = 2048;
          uint64_t v27 = v19;
          LODWORD(v23) = 18;
          __int16 v20 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v17,  2LL,  "Received kNotificationWifiLocationBatched, num,%u,Size, %lu",  &v24,  v23);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLLastConfidentLocation::onNewLocations(const CLLocationProvider_Type::Notification &, const CLLocation Provider_Type::NotificationData &)",  "%s\n",  v20);
        }

        if (sub_100CBED60(*(int **)(a3 + 800)))
        {
          unint64_t v9 = sub_100CBED60(*(int **)(a3 + 800));
          while (v9)
          {
            sub_100CBE5DC(*(void *)(a3 + 800), --v9, (uint64_t)&v24);
            sub_100CBEAEC(*(void *)(a3 + 800), v9, (uint64_t)buf);
            char v10 = sub_100E64064(a1, (__int128 *)&v24, (uint64_t)buf, 1);
            char v11 = v10;
            unint64_t v12 = v32;
            if (!v32) {
              goto LABEL_17;
            }
            p_shared_owners = (unint64_t *)&v32->__shared_owners_;
            do
              unint64_t v14 = __ldaxr(p_shared_owners);
            while (__stlxr(v14 - 1, p_shared_owners));
            if (!v14)
            {
              ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
              std::__shared_weak_count::__release_weak(v12);
              if ((v11 & 1) != 0) {
                break;
              }
            }

            else
            {
LABEL_17:
              if ((v10 & 1) != 0) {
                break;
              }
            }
          }
        }

        sub_100E63870(a1);
      }

      else
      {
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888778);
        }
        uint64_t v15 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          int v16 = *a2;
          *(_DWORD *)__int128 buf = 67109120;
          int v29 = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Received unknown notification %d", buf, 8u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888778);
          }
          int v21 = *a2;
          int v24 = 67109120;
          int v25 = v21;
          __int16 v22 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Received unknown notification %d",  &v24);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLLastConfidentLocation::onNewLocations(const CLLocationProvider_Type::Notification &, const CLLocation Provider_Type::NotificationData &)",  "%s\n",  v22);
        }
      }
    }

    else
    {
      sub_100E64064(a1, (__int128 *)a3, a3 + 160, 0);
    }
  }

void sub_100E64044(_Unwind_Exception *a1)
{
}

uint64_t sub_100E64064(uint64_t a1, __int128 *a2, uint64_t a3, int a4)
{
  uint64_t result = sub_100E64158(a1, (uint64_t)a2);
  if ((_DWORD)result)
  {
    if ((sub_100E645EC(a1, (uint64_t)a2, a4) & 1) != 0)
    {
      return 0LL;
    }

    else
    {
      __int128 v9 = *a2;
      *(_OWORD *)(a1 + 44) = a2[1];
      *(_OWORD *)(a1 + 28) = v9;
      __int128 v10 = a2[2];
      __int128 v11 = a2[3];
      __int128 v12 = a2[4];
      *(_OWORD *)(a1 + 108) = a2[5];
      *(_OWORD *)(a1 + 92) = v12;
      *(_OWORD *)(a1 + 76) = v11;
      *(_OWORD *)(a1 + 6sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v10;
      __int128 v13 = a2[6];
      __int128 v14 = a2[7];
      __int128 v15 = a2[8];
      *(_OWORD *)(a1 + 168) = *(__int128 *)((char *)a2 + 140);
      *(_OWORD *)(a1 + 156) = v15;
      *(_OWORD *)(a1 + 14sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v14;
      *(_OWORD *)(a1 + 124) = v13;
      memcpy((void *)(a1 + 184), (const void *)a3, 0x201uLL);
      sub_1000F2F30((void *)(a1 + 704), (uint64_t *)(a3 + 520));
      __int128 v17 = *(_OWORD *)(a3 + 552);
      __int128 v16 = *(_OWORD *)(a3 + 568);
      *(_OWORD *)(a1 + 72sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_OWORD *)(a3 + 536);
      *(_OWORD *)(a1 + 736) = v17;
      *(_OWORD *)(a1 + 752) = v16;
      __int128 v19 = *(_OWORD *)(a3 + 600);
      __int128 v18 = *(_OWORD *)(a3 + 616);
      __int128 v20 = *(_OWORD *)(a3 + 584);
      *(void *)(a1 + 813) = *(void *)(a3 + 629);
      *(_OWORD *)(a1 + 784) = v19;
      *(_OWORD *)(a1 + 80sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v18;
      *(_OWORD *)(a1 + 768) = v20;
      return 1LL;
    }
  }

  return result;
}

uint64_t sub_100E64158(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0LL;
  double v4 = *(double *)(a2 + 20);
  if (v4 > 100.0 || v4 < 0.0) {
    return result;
  }
  if (sub_1002954D0(*(double *)(a2 + 4), *(double *)(a2 + 12)))
  {
    if (sub_1002954D0(*(double *)(a2 + 100), *(double *)(a2 + 108)))
    {
      if (sub_10029286C(*(double *)(a2 + 4), *(double *)(a2 + 12)))
      {
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888778);
        }
        int v5 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "Skipping new location with coordinate in null-island",  buf,  2u);
        }

        BOOL v6 = sub_1002921D0(115, 0);
        uint64_t result = 0LL;
        if (v6)
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888778);
          }
          LOWORD(v15[0]) = 0;
          int v7 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Skipping new location with coordinate in null-island",  v15,  2,  v15[0]);
LABEL_39:
          __int128 v14 = (uint8_t *)v7;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLLastConfidentLocation::isQualifiedAsConfident(const CLDaemonLocation &)",  "%s\n",  v7);
          if (v14 != buf) {
            free(v14);
          }
          return 0LL;
        }
      }

      else
      {
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888778);
        }
        __int128 v12 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "Skipping new location with rawCoordinate in null-island",  buf,  2u);
        }

        BOOL v13 = sub_1002921D0(115, 0);
        uint64_t result = 0LL;
        if (v13)
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888778);
          }
          LOWORD(v15[0]) = 0;
          int v7 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Skipping new location with rawCoordinate in null-island",  v15,  2,  v15[0]);
          goto LABEL_39;
        }
      }
    }

    else
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888778);
      }
      __int128 v10 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "Skipping new location with invalid rawCoordinate",  buf,  2u);
      }

      BOOL v11 = sub_1002921D0(115, 0);
      uint64_t result = 0LL;
      if (v11)
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888778);
        }
        LOWORD(v15[0]) = 0;
        int v7 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Skipping new location with invalid rawCoordinate",  v15,  2,  v15[0]);
        goto LABEL_39;
      }
    }
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888778);
    }
    uint64_t v8 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "Skipping new location with invalid coordinate",  buf,  2u);
    }

    BOOL v9 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (v9)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888778);
      }
      LOWORD(v15[0]) = 0;
      int v7 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Skipping new location with invalid coordinate",  v15,  2,  v15[0]);
      goto LABEL_39;
    }
  }

  return result;
}

uint64_t sub_100E645EC(uint64_t a1, uint64_t a2, int a3)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  double v7 = *(double *)(a1 + 104);
  if (Current < v7)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888778);
    }
    uint64_t v8 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = *(void *)(a1 + 104);
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "#Warning Last confident location is in future, timestamp,%.03lf",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888778);
      }
      uint64_t v29 = *(void *)(a1 + 104);
      int v32 = 134217984;
      uint64_t v33 = v29;
      __int16 v30 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "#Warning Last confident location is in future, timestamp,%.03lf",  COERCE_DOUBLE(&v32));
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLLastConfidentLocation::isPreviousLocationPreferred(const CLDaemonLocation &, BOOL)",  "%s\n",  v30);
    }

    *(_DWORD *)(a1 + 28) = 0xFFFF;
    *(void *)(a1 + 32) = 0LL;
    *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
    __asm { FMOV            V1.2D, #-1.0 }

    *(_OWORD *)(a1 + 48) = xmmword_1012E0070;
    *(_OWORD *)(a1 + 64) = _Q1;
    *(_OWORD *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = _Q1;
    *(_OWORD *)(a1 + 96) = _Q1;
    *(_DWORD *)(a1 + 112) = 0;
    *(void *)(a1 + 116) = 0xBFF0000000000000LL;
    *(void *)(a1 + 132) = 0LL;
    *(void *)(a1 + 124) = 0LL;
    *(_DWORD *)(a1 + 14sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
    *(void *)(a1 + 144) = 0xBFF0000000000000LL;
    *(_DWORD *)(a1 + 152) = 0x7FFFFFFF;
    *(void *)(a1 + 156) = 0LL;
    *(void *)(a1 + 172) = 0LL;
    *(void *)(a1 + 164) = 0LL;
    *(_BYTE *)(a1 + 18sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
    sub_100869DC8(buf);
    memcpy((void *)(a1 + 184), buf, 0x201uLL);
    sub_10005F550(a1 + 704, v35);
    __int128 v14 = v36[0];
    *(_OWORD *)(a1 + 784) = v35[5];
    *(_OWORD *)(a1 + 80sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v14;
    *(void *)(a1 + 813) = *(void *)((char *)v36 + 13);
    __int128 v15 = v35[2];
    *(_OWORD *)(a1 + 72sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v35[1];
    *(_OWORD *)(a1 + 736) = v15;
    __int128 v16 = v35[4];
    *(_OWORD *)(a1 + 752) = v35[3];
    *(_OWORD *)(a1 + 768) = v16;
    __int128 v17 = (std::__shared_weak_count *)*((void *)&v35[0] + 1);
    if (*((void *)&v35[0] + 1))
    {
      __int128 v18 = (unint64_t *)(*((void *)&v35[0] + 1) + 8LL);
      do
        unint64_t v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }

    double v7 = *(double *)(a1 + 104);
  }

  double v20 = *(double *)(a2 + 76);
  if (v20 < v7)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888778);
    }
    int v21 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v22 = *(void *)(a2 + 76);
      uint64_t v23 = *(void *)(a1 + 104);
      *(_DWORD *)__int128 buf = 134218240;
      *(void *)&uint8_t buf[4] = v22;
      *(_WORD *)&_BYTE buf[12] = 2048;
      *(void *)&buf[14] = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "Skipping new location with an older timestamp,%.03lf,cached,%.03lf",  buf,  0x16u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 1LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888778);
    }
    uint64_t v28 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Skipping new location with an older timestamp,%.03lf,cached,%.03lf");
LABEL_45:
    uint64_t v31 = (uint8_t *)v28;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLLastConfidentLocation::isPreviousLocationPreferred(const CLDaemonLocation &, BOOL)",  "%s\n",  v28);
    if (v31 != buf) {
      free(v31);
    }
    return 1LL;
  }

  if (*(double *)(a1 + 48) < 65.0)
  {
    int v25 = *(double *)(a2 + 20) >= 65.0 ? 1 : a3;
    if (v20 < v7 + 10.0 && v25 != 0)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888778);
      }
      uint64_t v27 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEBUG,  "Skipping new location, since having recent more confident location",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        return 1LL;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888778);
      }
      uint64_t v28 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Skipping new location, since having recent more confident location");
      goto LABEL_45;
    }
  }

  return 0LL;
}

BOOL sub_100E64B34(uint64_t a1)
{
  if (*(double *)(a1 + 48) <= 0.0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888778);
    }
    __int128 v18 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "Last confident location not available",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888778);
    }
    unint64_t v19 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Last confident location not available");
LABEL_31:
    int v21 = (uint8_t *)v19;
    sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLLastConfidentLocation::isLastConfidentLocationValid()", "%s\n", v19);
    if (v21 != buf) {
      free(v21);
    }
    return 0LL;
  }

  double Current = CFAbsoluteTimeGetCurrent();
  double v3 = *(double *)(a1 + 104);
  if (Current >= v3 + 1800.0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888778);
    }
    double v20 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = 0x409C200000000000LL;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "Last confident location too old, maxAge = %.1lf",  buf,  0xCu);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (!result) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888778);
    }
    unint64_t v19 = (const char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Last confident location too old, maxAge = %.1lf");
    goto LABEL_31;
  }

  if (Current < v3)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888778);
    }
    double v4 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v5 = *(void *)(a1 + 104);
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "#Warning Last confident location is in future, timestamp,%.03lf",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888778);
      }
      uint64_t v22 = *(void *)(a1 + 104);
      int v24 = 134217984;
      uint64_t v25 = v22;
      uint64_t v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "#Warning Last confident location is in future, timestamp,%.03lf",  COERCE_DOUBLE(&v24));
      sub_10029211C("Generic", 1LL, 0, 2LL, "BOOL CLLastConfidentLocation::isLastConfidentLocationValid()", "%s\n", v23);
    }

    *(_DWORD *)(a1 + 28) = 0xFFFF;
    *(void *)(a1 + 32) = 0LL;
    *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
    __asm { FMOV            V1.2D, #-1.0 }

    *(_OWORD *)(a1 + 48) = xmmword_1012E0070;
    *(_OWORD *)(a1 + 64) = _Q1;
    *(_OWORD *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = _Q1;
    *(_OWORD *)(a1 + 96) = _Q1;
    *(_DWORD *)(a1 + 112) = 0;
    *(void *)(a1 + 116) = 0xBFF0000000000000LL;
    *(void *)(a1 + 132) = 0LL;
    *(void *)(a1 + 124) = 0LL;
    *(_DWORD *)(a1 + 14sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
    *(void *)(a1 + 144) = 0xBFF0000000000000LL;
    *(_DWORD *)(a1 + 152) = 0x7FFFFFFF;
    *(void *)(a1 + 156) = 0LL;
    *(void *)(a1 + 172) = 0LL;
    *(void *)(a1 + 164) = 0LL;
    *(_BYTE *)(a1 + 18sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
    sub_100869DC8(buf);
    memcpy((void *)(a1 + 184), buf, 0x201uLL);
    sub_10005F550(a1 + 704, v27);
    __int128 v11 = v28[0];
    *(_OWORD *)(a1 + 784) = v27[5];
    *(_OWORD *)(a1 + 80sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v11;
    *(void *)(a1 + 813) = *(void *)((char *)v28 + 13);
    __int128 v12 = v27[2];
    *(_OWORD *)(a1 + 72sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v27[1];
    *(_OWORD *)(a1 + 736) = v12;
    __int128 v13 = v27[4];
    *(_OWORD *)(a1 + 752) = v27[3];
    *(_OWORD *)(a1 + 768) = v13;
    __int128 v14 = (std::__shared_weak_count *)*((void *)&v27[0] + 1);
    if (*((void *)&v27[0] + 1))
    {
      __int128 v15 = (unint64_t *)(*((void *)&v27[0] + 1) + 8LL);
      do
        unint64_t v16 = __ldaxr(v15);
      while (__stlxr(v16 - 1, v15));
      if (!v16)
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }

    return 0LL;
  }

  return 1LL;
}

BOOL sub_100E65028(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 824) = 1;
  BOOL v4 = sub_100E64B34(a1);
  if (v4)
  {
    __int128 v5 = *(_OWORD *)(a1 + 44);
    *(_OWORD *)a2 = *(_OWORD *)(a1 + 28);
    *(_OWORD *)(a2 + 16) = v5;
    __int128 v6 = *(_OWORD *)(a1 + 60);
    __int128 v7 = *(_OWORD *)(a1 + 76);
    __int128 v8 = *(_OWORD *)(a1 + 108);
    *(_OWORD *)(a2 + 64) = *(_OWORD *)(a1 + 92);
    *(_OWORD *)(a2 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v8;
    *(_OWORD *)(a2 + 32) = v6;
    *(_OWORD *)(a2 + 48) = v7;
    __int128 v9 = *(_OWORD *)(a1 + 124);
    __int128 v10 = *(_OWORD *)(a1 + 140);
    __int128 v11 = *(_OWORD *)(a1 + 156);
    *(_OWORD *)(a2 + 14sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_OWORD *)(a1 + 168);
    *(_OWORD *)(a2 + 112) = v10;
    *(_OWORD *)(a2 + 128) = v11;
    *(_OWORD *)(a2 + 96) = v9;
    memcpy((void *)(a2 + 160), (const void *)(a1 + 184), 0x201uLL);
    sub_1000F2F30((void *)(a2 + 680), (uint64_t *)(a1 + 704));
    __int128 v13 = *(_OWORD *)(a1 + 736);
    __int128 v12 = *(_OWORD *)(a1 + 752);
    *(_OWORD *)(a2 + 696) = *(_OWORD *)(a1 + 720);
    *(_OWORD *)(a2 + 712) = v13;
    *(_OWORD *)(a2 + 728) = v12;
    __int128 v15 = *(_OWORD *)(a1 + 784);
    __int128 v14 = *(_OWORD *)(a1 + 800);
    __int128 v16 = *(_OWORD *)(a1 + 768);
    *(void *)(a2 + 789) = *(void *)(a1 + 813);
    *(_OWORD *)(a2 + 76sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v15;
    *(_OWORD *)(a2 + 776) = v14;
    *(_OWORD *)(a2 + 744) = v16;
  }

  return v4;
}

void sub_100E65100(uint64_t a1, uint64_t a2, int *a3, int *a4)
{
  if (*a3 == 1)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888778);
    }
    __int128 v6 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      int v7 = *a4;
      *(_DWORD *)__int128 buf = 67109120;
      int v14 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Received a kNotificationCachedLocationControllerStateUpdate notification, state, %d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888778);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Received a kNotificationCachedLocationControllerStateUpdate notification, state, %d",  &v12);
LABEL_19:
      __int128 v11 = (uint8_t *)v8;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLLastConfidentLocation::onCachedLocationControllerNotification(int, const CLCachedLocationController_Type: :Notification &, const CLCachedLocationController_Type::NotificationData &)",  "%s\n",  v8);
      if (v11 != buf) {
        free(v11);
      }
    }
  }

  else
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101888798);
    }
    __int128 v9 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      int v10 = *a3;
      *(_DWORD *)__int128 buf = 67109120;
      int v14 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Received unknown notification %d", buf, 8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101888798);
      }
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "Received unknown notification %d",  &v12);
      goto LABEL_19;
    }
  }

void sub_100E653BC(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100E653E8(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_100E65414(id a1)
{
  qword_101934838 = (uint64_t)os_log_create("com.apple.locationd.Position", "Position");
}

char *sub_100E65440(char *a1)
{
  *(void *)a1 = off_1018887D8;
  *((_WORD *)a1 + 4) = 0;
  *(void *)(a1 + 12) = 0xFFFFFFFF00000000LL;
  *((void *)a1 + 3) = 0LL;
  *((void *)a1 + 4) = 0LL;
  *((void *)a1 + 5) = 0LL;
  sub_1002E4C3C(a1 + 48, "CLLogBase", 1LL, 0LL);
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterAddObserver( LocalCenter,  a1,  (CFNotificationCallback)sub_100E6556C,  @"com.apple.locationd.DumpDiagnostics",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
  return a1;
}

void sub_100E654F0(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void *)(v2 + 40);
  *(void *)(v2 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  sub_10000AE14(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E6556C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
}

void *sub_100E6557C(void *a1)
{
  *a1 = off_1018887D8;
  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveEveryObserver(LocalCenter, a1);
  sub_1002E4CB0(a1 + 6);
  uint64_t v3 = a1[5];
  a1[5] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  sub_10000AE14((uint64_t)(a1 + 3));
  return a1;
}

uint64_t sub_100E65628(void *a1, uint64_t *a2)
{
  __int128 v5 = a1 + 6;
  uint64_t v4 = a1[6];
  __int128 v16 = a1 + 6;
  (*(void (**)(void *))(v4 + 16))(a1 + 6);
  __int16 v18 = 256;
  uint64_t v6 = *(v5 - 1);
  *(v5 - 1) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  int v7 = operator new(0x88uLL);
  sub_100E66848((uint64_t)v7, *a2);
  void *v7 = off_10184FBA8;
  sub_1006E31E4(&v15, (uint64_t)v7);
  sub_10005F550((uint64_t)(a1 + 3), &v15);
  __int128 v8 = (std::__shared_weak_count *)*((void *)&v15 + 1);
  if (*((void *)&v15 + 1))
  {
    __int128 v9 = (unint64_t *)(*((void *)&v15 + 1) + 8LL);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  if (a1[3])
  {
    sub_100EE2800( (uint64_t)sub_100E65800,  (uint64_t)a1,   +[CLIntersiloUniverse newSharedVendorUniverseWithSilo:]( &OBJC_CLASS___CLIntersiloUniverse,  "newSharedVendorUniverseWithSilo:",  +[CLSilo main](&OBJC_CLASS___CLSilo, "main")),  &v15);
    uint64_t v11 = v15;
    *(void *)&__int128 v15 = 0LL;
    uint64_t v12 = a1[5];
    a1[5] = v11;
    if (v12)
    {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
      uint64_t v13 = v15;
      *(void *)&__int128 v15 = 0LL;
      if (v13) {
        (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
      }
    }

    [*(id *)(a1[5] + 16) register:*(void *)(a1[5] + 8) forNotification:0 registrationInfo:0];
  }

  uint64_t result = sub_100E659DC((uint64_t)a1);
  if (HIBYTE(v18))
  {
    if ((_BYTE)v18) {
      return pthread_mutex_unlock(v17);
    }
    else {
      return (*(uint64_t (**)(void *))(*v16 + 24LL))(v16);
    }
  }

  return result;
}

void sub_100E657D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

void sub_100E65800(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (*a2)
  {
    if (qword_101934980 != -1) {
      dispatch_once(&qword_101934980, &stru_1018888A0);
    }
    uint64_t v4 = (os_log_s *)qword_101934988;
    if (os_log_type_enabled((os_log_t)qword_101934988, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "received unexpected darwin notification",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934980 != -1) {
        dispatch_once(&qword_101934980, &stru_1018888A0);
      }
      v9[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934988,  16LL,  "received unexpected darwin notification",  v9,  2);
      __int128 v8 = (uint8_t *)v7;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "static void CLLogBase::onSettingsNotification(int, const CLDarwinNotifier_Type::Notification &, const CLDarwinNo tifier_Type::NotificationData &, void *)",  "%s\n",  v7);
      if (v8 != buf) {
        free(v8);
      }
    }
  }

  else
  {
    uint64_t v6 = *(void *)(a4 + 24);
    if (v6)
    {
      sub_1002F13B4(v6);
      sub_100E659DC(a4);
      sub_1002F13B4(*(void *)(a4 + 24));
      sub_100E659DC(a4);
    }
  }

uint64_t sub_100E659DC(uint64_t a1)
{
  uint64_t v3 = a1 + 48;
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v10 = a1 + 48;
  (*(void (**)(uint64_t))(v2 + 16))(a1 + 48);
  __int16 v11 = 256;
  BOOL v9 = 0;
  sub_1002A6F64(*(void *)(v3 - 24), "LogDumpOnUnload", &v9);
  BOOL v4 = v9;
  if (*(_BYTE *)(a1 + 9)) {
    BOOL v5 = !v9;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
    BOOL v4 = v9;
  }

  *(_BYTE *)(a1 + 9) = v4;
  sub_1002A7CB0(*(void *)(a1 + 24), "LogFileRotationSize", (_DWORD *)(a1 + 12));
  sub_1002A7CB0(*(void *)(a1 + 24), "LogFileStorageCount", (_DWORD *)(a1 + 16));
  (*(void (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  BOOL v8 = 0;
  sub_1002A6F64(*(void *)(a1 + 24), "LogDumpOnLoad", &v8);
  BOOL v6 = v8;
  if (!*(_BYTE *)(a1 + 8) && v8)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
    BOOL v6 = v8;
  }

  *(_BYTE *)(a1 + 8) = v6;
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 48) + 24LL))(v3);
}

void sub_100E65B00(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100E65B18@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (qword_10199ED50 != -1) {
    dispatch_once(&qword_10199ED50, &stru_1018887F8);
  }
  return sub_1010DDBC0(a2, (char *)objc_msgSend(objc_msgSend((id)qword_10199ED48, "stringFromDate:", a1), "UTF8String"));
}

void sub_100E65B7C(id a1)
{
  qword_10199ED48 = objc_opt_new(&OBJC_CLASS___NSDateFormatter);
  [(id)qword_10199ED48 setDateFormat:@"yyyy-MM-dd_HH-mm-ss"];
}

void sub_100E65BA8(uint64_t a1@<X8>)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_10199ED70);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_10199ED70))
  {
    xmmword_10199ED58 = 0uLL;
    unk_10199ED68 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_10199ED58, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199ED70);
  }

  if (qword_10199ED78 != -1) {
    dispatch_once(&qword_10199ED78, &stru_101888818);
  }
  if (byte_10199ED6F < 0)
  {
    sub_1010DD48C((_BYTE *)a1, (void *)xmmword_10199ED58, *((unint64_t *)&xmmword_10199ED58 + 1));
  }

  else
  {
    *(_OWORD *)a1 = xmmword_10199ED58;
    *(void *)(a1 + 16) = unk_10199ED68;
  }

void sub_100E65C80(id a1)
{
}

void sub_100E65C94(uint64_t a1@<X8>)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_10199ED98);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_10199ED98))
  {
    xmmword_10199ED80 = 0uLL;
    unk_10199ED90 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_10199ED80, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199ED98);
  }

  if (qword_10199EDA0 != -1) {
    dispatch_once(&qword_10199EDA0, &stru_101888838);
  }
  if (byte_10199ED97 < 0)
  {
    sub_1010DD48C((_BYTE *)a1, (void *)xmmword_10199ED80, *((unint64_t *)&xmmword_10199ED80 + 1));
  }

  else
  {
    *(_OWORD *)a1 = xmmword_10199ED80;
    *(void *)(a1 + 16) = unk_10199ED90;
  }

void sub_100E65D6C(id a1)
{
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  std::string::assign( (std::string *)&xmmword_10199ED80,  -[NSString UTF8String]( -[NSString stringByAppendingPathComponent:]( +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", p_p),  "stringByAppendingPathComponent:",  [&off_1018D71F8 componentsJoinedByString:@"/"]),  "UTF8String"));
  if (v3 < 0) {
    operator delete(v2[0]);
  }
}

void sub_100E65E24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E65E58(uint64_t a1@<X8>)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_10199EDC0);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_10199EDC0))
  {
    xmmword_10199EDA8 = 0uLL;
    unk_10199EDB8 = 0LL;
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_10199EDA8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_10199EDC0);
  }

  if (qword_10199EDC8 != -1) {
    dispatch_once(&qword_10199EDC8, &stru_101888858);
  }
  if (byte_10199EDBF < 0)
  {
    sub_1010DD48C((_BYTE *)a1, (void *)xmmword_10199EDA8, *((unint64_t *)&xmmword_10199EDA8 + 1));
  }

  else
  {
    *(_OWORD *)a1 = xmmword_10199EDA8;
    *(void *)(a1 + 16) = unk_10199EDB8;
  }

void sub_100E65F30(id a1)
{
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  std::string::assign( (std::string *)&xmmword_10199EDA8,  -[NSString UTF8String]( -[NSString stringByAppendingPathComponent:]( +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", p_p),  "stringByAppendingPathComponent:",  [&off_1018D7210 componentsJoinedByString:@"/"]),  "UTF8String"));
  if (v3 < 0) {
    operator delete(v2[0]);
  }
}

void sub_100E65FE8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E6601C( const void **a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, std::string *a5@<X8>)
{
  else {
    size_t v10 = (size_t)a1[1];
  }
  __int16 v11 = &v30;
  sub_1000392EC((uint64_t)&v30, v10 + 1);
  if ((v30.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    __int16 v11 = (std::string *)v30.__r_.__value_.__r.__words[0];
  }
  if (v10)
  {
    else {
      uint64_t v12 = *a1;
    }
    memmove(v11, v12, v10);
  }

  *(_WORD *)((char *)&v11->__r_.__value_.__l.__data_ + v1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 47;
  int v13 = *(char *)(a2 + 23);
  if (v13 >= 0) {
    int v14 = (const std::string::value_type *)a2;
  }
  else {
    int v14 = *(const std::string::value_type **)a2;
  }
  if (v13 >= 0) {
    std::string::size_type v15 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v15 = *(void *)(a2 + 8);
  }
  __int128 v16 = std::string::append(&v30, v14, v15);
  __int128 v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v31.__r_.__value_.__l.__cap_ = v16->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0LL;
  v16->__r_.__value_.__l.__cap_ = 0LL;
  v16->__r_.__value_.__r.__words[0] = 0LL;
  __int16 v18 = std::string::append(&v31, "_");
  __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v32.__r_.__value_.__l.__cap_ = v18->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0LL;
  v18->__r_.__value_.__l.__cap_ = 0LL;
  v18->__r_.__value_.__r.__words[0] = 0LL;
  sub_100E65B18(a4, __p);
  if ((v29 & 0x80u) == 0) {
    double v20 = __p;
  }
  else {
    double v20 = (void **)__p[0];
  }
  if ((v29 & 0x80u) == 0) {
    std::string::size_type v21 = v29;
  }
  else {
    std::string::size_type v21 = (std::string::size_type)__p[1];
  }
  uint64_t v22 = std::string::append(&v32, (const std::string::value_type *)v20, v21);
  __int128 v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v33.__r_.__value_.__l.__cap_ = v22->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v33.__r_.__value_.__l.__data_ = v23;
  v22->__r_.__value_.__l.__size_ = 0LL;
  v22->__r_.__value_.__l.__cap_ = 0LL;
  v22->__r_.__value_.__r.__words[0] = 0LL;
  int v24 = *(char *)(a3 + 23);
  if (v24 >= 0) {
    uint64_t v25 = (const std::string::value_type *)a3;
  }
  else {
    uint64_t v25 = *(const std::string::value_type **)a3;
  }
  if (v24 >= 0) {
    std::string::size_type v26 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v26 = *(void *)(a3 + 8);
  }
  uint64_t v27 = std::string::append(&v33, v25, v26);
  *a5 = *v27;
  v27->__r_.__value_.__l.__size_ = 0LL;
  v27->__r_.__value_.__l.__cap_ = 0LL;
  v27->__r_.__value_.__r.__words[0] = 0LL;
}

void sub_100E661F8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E66274(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X8>)
{
  if (v10 >= 0) {
    BOOL v8 = (char *)v9;
  }
  else {
    BOOL v8 = (char *)v9[0];
  }
  sub_1010DDBC0(__p, v8);
  sub_100E6601C((const void **)__p, a2, a1 + 112, a3, a4);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (v10 < 0) {
    operator delete(v9[0]);
  }
}

void sub_100E66310( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E66344(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (v6 >= 0) {
    BOOL v4 = (char *)v5;
  }
  else {
    BOOL v4 = (char *)v5[0];
  }
  sub_1010DDBC0(__p, v4);
  sub_100E6601C((const void **)__p, a1 + 88, a1 + 112, (uint64_t)+[NSDate date](&OBJC_CLASS___NSDate, "date"), a2);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_100E663DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

NSDate *sub_100E66410()
{
  return +[NSDate date](&OBJC_CLASS___NSDate, "date");
}

uint64_t sub_100E6641C(uint64_t a1, char **a2, char *a3)
{
  char v3 = (char *)*((unsigned __int8 *)a2 + 23);
  else {
    BOOL v4 = *a2;
  }
  int v5 = a3[23];
  if (v5 >= 0) {
    char v6 = a3;
  }
  else {
    char v6 = *(char **)a3;
  }
  if (v5 >= 0) {
    int64_t v7 = a3[23];
  }
  else {
    int64_t v7 = *((void *)a3 + 1);
  }
  if (!v7) {
    return 1LL;
  }
  char v8 = &v3[(void)v4];
  if ((uint64_t)v3 >= v7)
  {
    int v12 = *v6;
    int v13 = v4;
    do
    {
      int v14 = &v3[-v7];
      std::string::size_type v15 = (char *)memchr(v13, v12, (size_t)(v14 + 1));
      if (!v15) {
        break;
      }
      BOOL v9 = v15;
      if (!memcmp(v15, v6, v7)) {
        return v9 != v8 && v9 == v4;
      }
      int v13 = v9 + 1;
      char v3 = (char *)(v8 - (v9 + 1));
    }

    while ((uint64_t)v3 >= v7);
  }

  BOOL v9 = v8;
  return v9 != v8 && v9 == v4;
}

unint64_t sub_100E664F0(uint64_t a1, void **a2, char *a3)
{
  unint64_t v3 = *((unsigned __int8 *)a2 + 23);
  char v4 = a3[23];
  if (v4 >= 0) {
    int64_t v5 = a3[23];
  }
  else {
    int64_t v5 = *((void *)a3 + 1);
  }
  if (v4 >= 0) {
    char v6 = a3;
  }
  else {
    char v6 = *(char **)a3;
  }
  if ((v3 & 0x80u) == 0LL)
  {
    int64_t v7 = (char *)a2;
  }

  else
  {
    unint64_t v3 = (unint64_t)a2[1];
    int64_t v7 = (char *)*a2;
  }

  unint64_t result = v3 == v5;
  if (v3 < result) {
    return 1LL;
  }
  if (v5)
  {
    BOOL v9 = &v7[result];
    char v10 = &v7[v3];
    int64_t v11 = &v7[v3] - v9;
    if (v11 >= v5)
    {
      int v14 = *v6;
      do
      {
        int64_t v15 = v11 - v5;
        if (v15 == -1) {
          break;
        }
        __int128 v16 = (char *)memchr(v9, v14, v15 + 1);
        if (!v16) {
          break;
        }
        int v12 = v16;
        if (!memcmp(v16, v6, v5)) {
          return v12 != v7 || v12 == v10;
        }
        BOOL v9 = v12 + 1;
        int64_t v11 = v10 - (v12 + 1);
      }

      while (v11 >= v5);
    }

    int v12 = v10;
    return v12 != v7 || v12 == v10;
  }

  return result;
}

BOOL sub_100E665CC(uint64_t a1)
{
  unint64_t v3 = (char *)(a1 + 48);
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v19 = a1 + 48;
  (*(void (**)(uint64_t))(v2 + 16))(a1 + 48);
  __int16 v20 = 256;
  char v4 = v3 + 88;
  int64_t v5 = v3 + 88;
  if (v3[111] < 0) {
    int64_t v5 = *(const char **)v4;
  }
  if (stat(v5, &v18) == -1)
  {
    BOOL v14 = 1LL;
  }

  else
  {
    char v6 = v3 + 88;
    st_std::string::size_type size = v18.st_size;
    char v8 = fopen(v6, "r");
    if (v8)
    {
      sub_100E66344(a1, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      char v10 = fopen((const char *)p_p, "w");
      if (v10)
      {
        uint64_t v11 = 0LL;
        if (!feof(v8))
        {
          while (1)
          {
            size_t v13 = fread(__ptr, 1uLL, 0x400uLL, v8);
            if (!v13) {
              break;
            }
            size_t v12 = fwrite(__ptr, 1uLL, v13, v10);
            v11 += v12;
            if (feof(v8) || !v12) {
              goto LABEL_17;
            }
          }

          feof(v8);
        }

void sub_100E66800( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, char a36)
{
}

uint64_t sub_100E66848(uint64_t a1, uint64_t a2)
{
  char v4 = sub_1002A55A8((void *)a1, a2);
  *char v4 = off_101830C38;
  *((_BYTE *)v4 + 16) = *(_BYTE *)(a2 + 16);
  if (*(char *)(a2 + 47) < 0)
  {
    sub_1010DD48C((_BYTE *)v4 + 24, *(void **)(a2 + 24), *(void *)(a2 + 32));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(a2 + 24);
    void v4[5] = *(void *)(a2 + 40);
    *(_OWORD *)(v4 + 3) = v5;
  }

  if (*(char *)(a2 + 71) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 48), *(void **)(a2 + 48), *(void *)(a2 + 56));
  }

  else
  {
    __int128 v6 = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(_OWORD *)(a1 + 48) = v6;
  }

  __int128 v7 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 81) = *(_OWORD *)(a2 + 81);
  *(_OWORD *)(a1 + 72) = v7;
  sub_1002A55A8((void *)(a1 + 104), a2 + 104);
  *(void *)(a1 + 104) = &off_101831000;
  sub_1002A55A8((void *)(a1 + 120), a2 + 120);
  *(void *)(a1 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = &off_101831000;
  return a1;
}

void sub_100E66938(_Unwind_Exception *a1)
{
}

void sub_100E6698C(id a1)
{
  qword_101934988 = (uint64_t)os_log_create("com.apple.locationd.Core", "Core");
}

double sub_100E669B8(uint64_t a1, void *a2)
{
  *(void *)a1 = *a2;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0u;
  *(void *)(a1 + 56) = 0LL;
  return result;
}

uint64_t sub_100E669D8(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100869780(a2);
  if ((_DWORD)result)
  {
    int v5 = *(_DWORD *)(a2 + 96);
    BOOL v6 = v5 == 10 || v5 == 1;
    uint64_t v7 = *(void *)(a1 + 48);
    if (v7
      && ((double v8 = *(double *)(a2 + 76),
           double v9 = *(double *)(*(void *)(*(void *)(a1 + 16) + 8 * ((v7 + *(void *)(a1 + 40) - 1) / 0x1AuLL))
                          + 156 * ((v7 + *(void *)(a1 + 40) - 1) % 0x1AuLL)
                          + 76),
           v8 >= v9)
        ? (BOOL v10 = v8 - v9 < 1.0)
        : (BOOL v10 = 1),
          v10))
    {
      return 0LL;
    }

    else
    {
      sub_100E66FF8((void *)(a1 + 8), a2);
      while (*(void *)(a1 + 48))
      {
        if (sub_1008698D0( *(void *)(*(void *)(a1 + 16) + 8 * (*(void *)(a1 + 40) / 0x1AuLL)) {
        *(int64x2_t *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = vaddq_s64(*(int64x2_t *)(a1 + 40), (int64x2_t)xmmword_1012CE4D0);
        }
        sub_100210CB8(a1 + 8, 1);
      }

      double v11 = sub_101171D4C();
      if (v11 - *(double *)(a1 + 56) >= 10.0)
      {
        if (qword_101934830 != -1) {
          dispatch_once(&qword_101934830, &stru_1018888C0);
        }
        size_t v12 = (os_log_s *)qword_101934838;
        if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
        {
          std::string::size_type v13 = *(void *)(a1 + 48);
          sub_100869A44( *(void *)(*(void *)(a1 + 16) + 8 * ((v13 + *(void *)(a1 + 40) - 1) / 0x1A))
          + 156 * ((v13 + *(void *)(a1 + 40) - 1) % 0x1A),
            __p);
          BOOL v14 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0
              ? __p
              : (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 134349315;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v13;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2081;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v14;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "CLReferenceLocations, size %{public}zu, latest ref location %{private}s",  (uint8_t *)&buf,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_101934830 != -1) {
            dispatch_once(&qword_101934830, &stru_1018888C0);
          }
          uint64_t v18 = qword_101934838;
          uint64_t v19 = *(void *)(a1 + 48);
          sub_100869A44( *(void *)(*(void *)(a1 + 16) + 8 * ((v19 + *(void *)(a1 + 40) - 1) / 0x1AuLL))
          + 156 * ((v19 + *(void *)(a1 + 40) - 1) % 0x1AuLL),
            &buf);
          if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_std::stringbuf::string_type buf = &buf;
          }
          else {
            p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
          }
          int v28 = 134349315;
          uint64_t v29 = v19;
          __int16 v30 = 2081;
          std::string v31 = p_buf;
          std::string::size_type v21 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v18,  2LL,  "CLReferenceLocations, size %{public}zu, latest ref location %{private}s",  &v28,  22);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLReferenceLocations::receiveLocation(const CLDaemonLocation &)",  "%s\n",  (const char *)v21);
          if (v21 != __p) {
            free(v21);
          }
        }

        if (qword_101934830 != -1) {
          dispatch_once(&qword_101934830, &stru_1018888C0);
        }
        int64_t v15 = (os_log_s *)qword_101934838;
        if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
        {
          std::string::size_type v16 = *(void *)(a1 + 48);
          sub_100869A44( *(void *)(*(void *)(a1 + 16) + 8 * (*(void *)(a1 + 40) / 0x1AuLL))
          + 156 * (*(void *)(a1 + 40) % 0x1AuLL),
            __p);
          __int128 v17 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0
              ? __p
              : (std::stringbuf::string_type *)__p[0].__r_.__value_.__r.__words[0];
          LODWORD(buf.__r_.__value_.__l.__data_) = 134349315;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v16;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2081;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v17;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "CLReferenceLocations, size %{public}zu, oldest ref location %{private}s",  (uint8_t *)&buf,  0x16u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(__p, 0x65CuLL);
          if (qword_101934830 != -1) {
            dispatch_once(&qword_101934830, &stru_1018888C0);
          }
          uint64_t v22 = qword_101934838;
          uint64_t v23 = *(void *)(a1 + 48);
          sub_100869A44( *(void *)(*(void *)(a1 + 16) + 8 * (*(void *)(a1 + 40) / 0x1AuLL))
          + 156 * (*(void *)(a1 + 40) % 0x1AuLL),
            &buf);
          if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            int v24 = &buf;
          }
          else {
            int v24 = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
          }
          int v28 = 134349315;
          uint64_t v29 = v23;
          __int16 v30 = 2081;
          std::string v31 = v24;
          LODWORD(v26) = 22;
          uint64_t v25 = (std::stringbuf::string_type *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v22,  2LL,  "CLReferenceLocations, size %{public}zu, oldest ref location %{private}s",  &v28,  v26);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLReferenceLocations::receiveLocation(const CLDaemonLocation &)",  "%s\n",  (const char *)v25);
          if (v25 != __p) {
            free(v25);
          }
        }

        *(double *)(a1 + 56) = v11;
      }

      return 1LL;
    }
  }

  return result;
}

__n128 sub_100E66FF8(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 26 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100E67404(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x1A)) + 156 * (v7 % 0x1A);
  __int128 v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  __int128 v10 = *(_OWORD *)(a2 + 32);
  __int128 v11 = *(_OWORD *)(a2 + 48);
  __int128 v12 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v8 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v8 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v12;
  *(_OWORD *)(v8 + 32) = v10;
  *(_OWORD *)(v8 + 48) = v11;
  __n128 result = *(__n128 *)(a2 + 96);
  __int128 v14 = *(_OWORD *)(a2 + 112);
  __int128 v15 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(v8 + 14sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_OWORD *)(a2 + 140);
  *(_OWORD *)(v8 + 112) = v14;
  *(_OWORD *)(v8 + 128) = v15;
  *(__n128 *)(v8 + 96) = result;
  ++a1[5];
  return result;
}

void sub_100E670CC(void *a1@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3 = a1[6];
  *(_DWORD *)a3 = 0xFFFF;
  *(void *)(a3 + 12) = 0LL;
  *(void *)(a3 + 4) = 0LL;
  *(_OWORD *)(a3 + 2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = xmmword_1012E0070;
  __asm { FMOV            V0.2D, #-1.0 }

  *(_OWORD *)(a3 + 36) = _Q0;
  *(_OWORD *)(a3 + 52) = _Q0;
  *(_OWORD *)(a3 + 68) = _Q0;
  *(_DWORD *)(a3 + 84) = 0;
  *(void *)(a3 + 96) = 0LL;
  *(void *)(a3 + 104) = 0LL;
  *(void *)(a3 + 88) = 0xBFF0000000000000LL;
  *(_DWORD *)(a3 + 112) = 0;
  *(void *)(a3 + 116) = 0xBFF0000000000000LL;
  *(_DWORD *)(a3 + 124) = 0x7FFFFFFF;
  *(void *)(a3 + 136) = 0LL;
  *(void *)(a3 + 144) = 0LL;
  *(void *)(a3 + 128) = 0LL;
  *(_BYTE *)(a3 + 152) = 0;
  if (v3)
  {
    uint64_t v10 = a1[2];
    if (a1[3] == v10
      || (unint64_t v11 = a1[5],
          unint64_t v12 = *(void *)(v10 + 8 * (v11 / 0x1A)) + 156 * (v11 % 0x1A),
          unint64_t v13 = *(void *)(v10 + 8 * ((v3 + v11) / 0x1A)) + 156 * ((v3 + v11) % 0x1A),
          v12 == v13))
    {
      double v16 = 1.79769313e308;
    }

    else
    {
      __int128 v14 = (void *)(v10 + 8 * (v11 / 0x1A));
      double v15 = *a2;
      double v16 = 1.79769313e308;
      do
      {
        double v17 = vabdd_f64(v15, *(double *)(v12 + 76));
        if (v16 > v17)
        {
          __int128 v18 = *(_OWORD *)(v12 + 16);
          *(_OWORD *)a3 = *(_OWORD *)v12;
          *(_OWORD *)(a3 + 16) = v18;
          __int128 v19 = *(_OWORD *)(v12 + 32);
          __int128 v20 = *(_OWORD *)(v12 + 48);
          __int128 v21 = *(_OWORD *)(v12 + 80);
          *(_OWORD *)(a3 + 64) = *(_OWORD *)(v12 + 64);
          *(_OWORD *)(a3 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v21;
          *(_OWORD *)(a3 + 32) = v19;
          *(_OWORD *)(a3 + 48) = v20;
          __int128 v22 = *(_OWORD *)(v12 + 96);
          __int128 v23 = *(_OWORD *)(v12 + 112);
          __int128 v24 = *(_OWORD *)(v12 + 128);
          *(_OWORD *)(a3 + 14sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_OWORD *)(v12 + 140);
          *(_OWORD *)(a3 + 112) = v23;
          *(_OWORD *)(a3 + 128) = v24;
          *(_OWORD *)(a3 + 96) = v22;
          double v16 = v17;
        }

        v12 += 156LL;
        if (v12 - *v14 == 4056)
        {
          unint64_t v25 = v14[1];
          ++v14;
          unint64_t v12 = v25;
        }
      }

      while (v12 != v13);
    }

    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_1018888C0);
    }
    uint64_t v26 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v27 = a1[6];
      *(_DWORD *)std::stringbuf::string_type buf = 134349312;
      uint64_t v35 = v27;
      __int16 v36 = 2050;
      double v37 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "CLReferenceLocations, size %{public}zu, found closest reference location with timestamp delta %{public}.1f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_1018888C0);
      }
      uint64_t v28 = a1[6];
      int v30 = 134349312;
      uint64_t v31 = v28;
      __int16 v32 = 2050;
      double v33 = v16;
      uint64_t v29 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  2LL,  "CLReferenceLocations, size %{public}zu, found closest reference location with timestamp delta %{public}.1f",  &v30,  22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLDaemonLocation CLReferenceLocations::getClosestReferenceLocation(const CFAbsoluteTime &) const",  "%s\n",  v29);
    }
  }

void sub_100E673D8(id a1)
{
  qword_101934838 = (uint64_t)os_log_create("com.apple.locationd.Position", "Position");
}

void sub_100E67404(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x1A;
  unint64_t v4 = v2 - 26;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    __int128 v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int128 v34 = (char *)sub_1000071BC(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      double v37 = &v34[8 * v36];
      __int16 v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100E676CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100E67718(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v7 = a2;
  uint64_t v5 = (void *)sub_100595C90(a1, &v7, a3, a4);
  *uint64_t v5 = off_101888C08;
  v5[41] = 0LL;
  *(void *)((char *)v5 + 334) = 0LL;
  v5[43] = 0LL;
  v5[44] = 0LL;
  v5[47] = 0LL;
  v5[48] = 0LL;
  v5[45] = 0LL;
  v5[46] = v5 + 47;
  sub_1004F2598();
  *(_BYTE *)(a1 + 392) = sub_1004F8A40();
  return a1;
}

void sub_100E6779C(_Unwind_Exception *a1)
{
  uint64_t v5 = v3;
  sub_100008390(v2, *v4);
  int v7 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 352) = v7;
    operator delete(v7);
  }

  sub_100C0CB28(v1);
  _Unwind_Resume(a1);
}

void *sub_100E677D0(uint64_t a1, uint64_t a2)
{
  __n128 result = (void *)sub_100E67718(a1, 3, qword_10199EDD0, a2);
  *__n128 result = off_1018888F0;
  return result;
}

uint64_t sub_100E67804(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v7 = a2;
  uint64_t v5 = (void *)sub_100595C90(a1, &v7, a3, a4);
  *uint64_t v5 = off_101888CE0;
  v5[41] = 0LL;
  *(void *)((char *)v5 + 334) = 0LL;
  v5[43] = 0LL;
  v5[44] = 0LL;
  v5[47] = 0LL;
  v5[48] = 0LL;
  v5[45] = 0LL;
  v5[46] = v5 + 47;
  sub_1004F2598();
  *(_BYTE *)(a1 + 392) = sub_1004F8A40();
  return a1;
}

void sub_100E67888(_Unwind_Exception *a1)
{
  uint64_t v5 = v3;
  sub_100008390(v2, *v4);
  int v7 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 352) = v7;
    operator delete(v7);
  }

  sub_100C0CB28(v1);
  _Unwind_Resume(a1);
}

void *sub_100E678BC(uint64_t a1, uint64_t a2)
{
  __n128 result = (void *)sub_100E67804(a1, 5, qword_10199EDD0, a2);
  *__n128 result = off_1018889C8;
  return result;
}

uint64_t sub_100E678F0(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v7 = a2;
  uint64_t v5 = (void *)sub_100595C90(a1, &v7, a3, a4);
  *uint64_t v5 = &off_101888DB8;
  v5[41] = 0LL;
  *(void *)((char *)v5 + 334) = 0LL;
  v5[43] = 0LL;
  v5[44] = 0LL;
  v5[47] = 0LL;
  v5[48] = 0LL;
  v5[45] = 0LL;
  v5[46] = v5 + 47;
  sub_1004F2598();
  *(_BYTE *)(a1 + 392) = sub_1004F8A40();
  return a1;
}

void sub_100E67974(_Unwind_Exception *a1)
{
  uint64_t v5 = v3;
  sub_100008390(v2, *v4);
  int v7 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 352) = v7;
    operator delete(v7);
  }

  sub_100C0CB28(v1);
  _Unwind_Resume(a1);
}

void *sub_100E679A8(uint64_t a1, uint64_t a2)
{
  __n128 result = (void *)sub_100E678F0(a1, 4, qword_10199EDD0, a2);
  *__n128 result = off_101888AA0;
  return result;
}

void sub_100E679E0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E71D9C(a1);
  operator delete(v1);
}

uint64_t sub_100E679F4()
{
  return 350LL;
}

double sub_100E679FC()
{
  return 2.0;
}

uint64_t sub_100E67A04()
{
  return 0x10000LL;
}

uint64_t sub_100E67A0C(uint64_t a1, std::string::value_type *a2)
{
  double Current = CFAbsoluteTimeGetCurrent();
  sub_100C0FAA0(a1, a2);
  sub_100C124C8((uint64_t *)a1, "", a2, *(_DWORD *)(a1 + 48), 0, Current);
  sub_100E71E80((uint64_t *)&v50, a1 + 368);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  uint64_t v5 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 134218242;
    *(void *)__int128 v61 = v52;
    *(_WORD *)&v61[8] = 2080;
    *(void *)&v61[10] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "TILE: result: tilestool: TEST_testBinarySearch, entries, %lu, file, %s",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    *(_DWORD *)std::string __p = 134218242;
    *(void *)&__p[4] = v52;
    *(_WORD *)&_BYTE __p[12] = 2080;
    *(void *)&__p[14] = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: result: tilestool: TEST_testBinarySearch, entries, %lu, file, %s",  __p,  22);
    double v37 = (uint8_t *)v36;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonE ntry_GSM>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_GSM, DataE ntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v36);
    if (v37 != buf) {
      free(v37);
    }
  }

  uint64_t v6 = a1 + 376;
  sub_100008390(a1 + 368, *(void **)(a1 + 376));
  *(void *)(a1 + 376) = 0LL;
  *(void *)(a1 + 384) = 0LL;
  *(void *)(a1 + 368) = a1 + 376;
  unint64_t v8 = v50;
  uint64_t v43 = (const char *)&v51;
  if (v50 != (const char *)&v51)
  {
    uint64_t v9 = 0LL;
    *(void *)&__int128 v7 = 134219266LL;
    __int128 v41 = v7;
    while (1)
    {
      *(void *)uint64_t v49 = *(void *)(v8 + 25);
      *(void *)((char *)&v49[1] + 2) = *(void *)(v8 + 31);
      memset(v48, 0, 14);
      uint64_t v46 = 0LL;
      memset(v47, 0, 14);
      uint64_t v45 = 0LL;
      sub_100008390(a1 + 368, *(void **)(a1 + 376));
      *(void *)(a1 + 376) = 0LL;
      *(void *)(a1 + 384) = 0LL;
      *(void *)(a1 + 368) = v6;
      clock_t v10 = clock();
      int v11 = (*(uint64_t (**)(uint64_t, unsigned int *, void *))(*(void *)a1 + 192LL))(a1, v49, v48);
      clock_t v12 = clock();
      sub_100008390(a1 + 368, *(void **)(a1 + 376));
      *(void *)(a1 + 376) = 0LL;
      *(void *)(a1 + 384) = 0LL;
      *(void *)(a1 + 368) = v6;
      clock_t v13 = clock();
      int v14 = (*(uint64_t (**)(uint64_t, unsigned int *, _WORD *))(*(void *)a1 + 184LL))(a1, v49, v47);
      clock_t v15 = clock();
      printf("tilestool: mmap, %lu, file, %lu\n", v15 - v13, v12 - v10);
      if (v11 != v14) {
        break;
      }
      int v16 = (*(uint64_t (**)(uint64_t, unsigned int *, void *))(*(void *)a1 + 176LL))(a1, v49, v48);
      if (v16) {
        sub_100C13C70(a1, LOWORD(v48[1]), WORD1(v48[1]), (double *)&v46, (double *)&v45);
      }
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v17 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v18 = v52;
        uint64_t v19 = v45;
        uint64_t v20 = v46;
        sub_100C0BA54(v49, (std::stringbuf::string_type *)__p);
        uint64_t v21 = __p;
        if (__p[23] < 0) {
          uint64_t v21 = *(_BYTE **)__p;
        }
        *(_DWORD *)std::stringbuf::string_type buf = v41;
        *(void *)__int128 v61 = v9;
        *(_WORD *)&v61[8] = 2048;
        *(void *)&v61[10] = v18;
        *(_WORD *)&v61[18] = 1024;
        *(_DWORD *)&v61[20] = v16;
        __int16 v62 = 2048;
        uint64_t v63 = v20;
        __int16 v64 = 2048;
        uint64_t v65 = v19;
        __int16 v66 = 2080;
        unsigned int v67 = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "TILE: result: tilestool: prog, %3lu, %3lu, ===============> isFound, %d, location, %14.8lf, %14.8lf, entry, %s",  buf,  0x3Au);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888E80);
        }
        uint64_t v25 = qword_101934A78;
        uint64_t v26 = v52;
        uint64_t v27 = v45;
        uint64_t v28 = v46;
        sub_100C0BA54(v49, &v44);
        uint64_t v29 = &v44;
        if ((v44.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v29 = (std::stringbuf::string_type *)v44.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string __p = v41;
        *(void *)&__p[4] = v9;
        *(_WORD *)&_BYTE __p[12] = 2048;
        *(void *)&__p[14] = v26;
        *(_WORD *)&__p[22] = 1024;
        *(_DWORD *)&__p[24] = v16;
        __int16 v54 = 2048;
        uint64_t v55 = v28;
        __int16 v56 = 2048;
        uint64_t v57 = v27;
        __int16 v58 = 2080;
        unint64_t v59 = v29;
        LODWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 58;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v25,  2LL,  "TILE: result: tilestool: prog, %3lu, %3lu, ===============> isFound, %d, location, %14.8lf, %14.8lf, entry, %s",  __p,  v40,  (_DWORD)v41,  *((double *)&v41 + 1),  v42,  v43);
        __int128 v31 = v30;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLat LonEntry_GSM>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_GS M, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v31);
      }

      if (!v16)
      {
        int v34 = 759;
        uint64_t v35 = "isFound";
LABEL_44:
        __assert_rtn("TEST_testBinarySearch", "CLKeyLatLonTileTemplate.h", v34, v35);
      }

      unint64_t v22 = (const char *)*((void *)v8 + 1);
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          unint64_t v22 = *(const char **)v22;
        }

        while (v22);
      }

      else
      {
        do
        {
          uint64_t v23 = (const char *)*((void *)v8 + 2);
          BOOL v24 = *(void *)v23 == (void)v8;
          unint64_t v8 = v23;
        }

        while (!v24);
      }

      ++v9;
      unint64_t v8 = v23;
      if (v23 == v43) {
        goto LABEL_36;
      }
    }

    int v34 = 742;
    uint64_t v35 = "isFound == isFoundMmap";
    goto LABEL_44;
  }

  uint64_t v9 = 0LL;
LABEL_36:
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  __int128 v32 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 67109632;
    *(_DWORD *)__int128 v61 = 1;
    *(_WORD *)&v61[4] = 2048;
    *(void *)&v61[6] = v9;
    *(_WORD *)&v61[14] = 2048;
    *(void *)&v61[16] = v52;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "TILE: result: tilestool: pass, %d, tests, %lu, %lu",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    *(void *)std::string __p = 0x104000300LL;
    *(_WORD *)&__p[8] = 2048;
    *(void *)&__p[10] = v9;
    *(_WORD *)&__p[18] = 2048;
    *(void *)&__p[20] = v52;
    LODWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: result: tilestool: pass, %d, tests, %lu, %lu",  __p,  v40,  (void)v41);
    uint64_t v39 = (uint8_t *)v38;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonE ntry_GSM>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_GSM, DataE ntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v38);
    if (v39 != buf) {
      free(v39);
    }
  }

  sub_100008390((uint64_t)&v50, v51);
  return 1LL;
}

void sub_100E681C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, void *a27)
{
}

void sub_100E68218(uint64_t a1)
{
  *(void *)(a1 + 376) = 0LL;
  *(void *)(a1 + 384) = 0LL;
  *(void *)(a1 + 368) = a1 + 376;
  *(void *)(a1 + 352) = *(void *)(a1 + 344);
}

void sub_100E68258(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = a1;
  sub_10059826C(a1, (uint64_t)a2, a3);
  uint64_t v98 = 0LL;
  int v10 = *(unsigned __int16 *)(a3 + 2);
  if (v10 != 7)
  {
    if (v10 == 6)
    {
      *(void *)std::string::size_type v99 = 0x200006ABBALL;
      memset(&v99[8], 0, 32);
      LODWORD(v10sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
      sub_100C0C158(a4, (uint64_t)v99);
      int v11 = (void *)(v9 + 344);
      *(void *)(v9 + 352) = *(void *)(v9 + 344);
      sub_100E72208((char **)(v9 + 344), *(unsigned int *)&v99[12]);
      clock_t v12 = (char *)sub_100599BF4(v9, a2, a3, 0, *(int *)&v99[12], *(int *)&v99[16]);
      if (v12)
      {
        v96[0] = 0LL;
        v96[1].i32[0] = 0;
        if (*(_DWORD *)&v99[12])
        {
          unint64_t v13 = 0LL;
          do
          {
            sub_100C0BB90((int8x8_t *)&v12[v13 * *(unsigned int *)&v99[16]], v96);
            clock_t v15 = *(int8x8_t **)(v9 + 352);
            unint64_t v14 = *(void *)(v9 + 360);
            if ((unint64_t)v15 >= v14)
            {
              unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v15 - *v11) >> 2);
              unint64_t v19 = v18 + 1;
              if (v18 + 1 > 0x1555555555555555LL) {
                sub_100007008();
              }
              unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - *v11) >> 2);
              if (2 * v20 > v19) {
                unint64_t v19 = 2 * v20;
              }
              if (v20 >= 0xAAAAAAAAAAAAAAALL) {
                unint64_t v21 = 0x1555555555555555LL;
              }
              else {
                unint64_t v21 = v19;
              }
              if (v21) {
                unint64_t v22 = (char *)sub_1005AADE4(v9 + 360, v21);
              }
              else {
                unint64_t v22 = 0LL;
              }
              uint64_t v23 = (int8x8_t *)&v22[12 * v18];
              int8x8_t v24 = v96[0];
              v23[1].i32[0] = v96[1].i32[0];
              int8x8_t *v23 = v24;
              uint64_t v26 = *(_DWORD **)(v9 + 344);
              uint64_t v25 = *(_DWORD **)(v9 + 352);
              uint64_t v27 = v23;
              if (v25 != v26)
              {
                do
                {
                  int8x8_t v28 = *(int8x8_t *)(v25 - 3);
                  v25 -= 3;
                  __int32 v29 = v25[2];
                  *(int8x8_t *)((char *)v27 - 12) = v28;
                  uint64_t v27 = (int8x8_t *)((char *)v27 - 12);
                  v27[1].i32[0] = v29;
                }

                while (v25 != v26);
                uint64_t v25 = (_DWORD *)*v11;
              }

              uint64_t v17 = (char *)&v23[1] + 4;
              *(void *)(v9 + 344) = v27;
              *(void *)(v9 + 352) = (char *)v23 + 12;
              *(void *)(v9 + 36sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = &v22[12 * v21];
              if (v25) {
                operator delete(v25);
              }
            }

            else
            {
              int8x8_t v16 = v96[0];
              v15[1].i32[0] = v96[1].i32[0];
              int8x8_t *v15 = v16;
              uint64_t v17 = (char *)&v15[1] + 4;
            }

            *(void *)(v9 + 352) = v17;
            if (!*(_BYTE *)(a5 + 9))
            {
              if (qword_101934A70 != -1) {
                dispatch_once(&qword_101934A70, &stru_101888E80);
              }
              __int128 v30 = (os_log_s *)qword_101934A78;
              if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
              {
                int v31 = *(_DWORD *)&v99[12];
                sub_100C0BBAC((unsigned int *)v96, (std::stringbuf::string_type *)__p);
                __int128 v32 = __p;
                if (SBYTE3(v112) < 0) {
                  __int128 v32 = *(_BYTE **)__p;
                }
                *(_DWORD *)std::stringbuf::string_type buf = 134218498;
                *(void *)double v116 = v13;
                *(_WORD *)&v116[8] = 1024;
                *(_DWORD *)__int16 v117 = v31;
                *(_WORD *)&v117[4] = 2080;
                *(void *)&v117[6] = v32;
                _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "TILE: index entry, %3lu, %3u, %s",  buf,  0x1Cu);
                if (SBYTE3(v112) < 0) {
                  operator delete(*(void **)__p);
                }
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934A70 != -1) {
                  dispatch_once(&qword_101934A70, &stru_101888E80);
                }
                uint64_t v33 = qword_101934A78;
                int v34 = *(_DWORD *)&v99[12];
                sub_100C0BBAC((unsigned int *)v96, &v97);
                uint64_t v35 = &v97;
                if ((v97.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  uint64_t v35 = (std::stringbuf::string_type *)v97.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)std::string __p = 134218498;
                *(void *)&__p[4] = v13;
                *(_WORD *)&_BYTE __p[12] = 1024;
                *(_DWORD *)&__p[14] = v34;
                *(_WORD *)&__p[18] = 2080;
                __int16 v112 = v35;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v33,  2LL,  "TILE: index entry, %3lu, %3u, %s",  __p,  28,  v88);
                double v37 = v36;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type ::KeyLatLonEntry_GSM>::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const v oid *, const CLTileFile::TraverseDetails &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_G SM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v37);
              }
            }

            ++v13;
          }

          while (v13 < *(unsigned int *)&v99[12]);
        }
      }

      goto LABEL_82;
    }

    unsigned int v47 = 0;
    goto LABEL_57;
  }

  *(_DWORD *)std::string __p = 502714;
  *(_OWORD *)&__p[4] = xmmword_101362CA0;
  __int16 v112 = 0LL;
  uint64_t v114 = 0LL;
  uint64_t v113 = 0LL;
  sub_100C0C158(a4, (uint64_t)__p);
  __int16 v38 = (uint64_t **)(v9 + 368);
  sub_100008390(v9 + 368, *(void **)(v9 + 376));
  *(void *)(v9 + 376) = 0LL;
  *(void *)(v9 + 384) = 0LL;
  *(void *)(v9 + 368) = v9 + 376;
  double v93 = *(double *)&v9;
  if (!*(_BYTE *)(a5 + 9))
  {
    memset(v96, 0, 14);
    __int16 v48 = (const char *)sub_100599BF4(v9, a2, a3, 0, *(int *)&__p[12], *(int *)&__p[16]);
    clock_t v12 = (char *)v48;
    if (!v48)
    {
LABEL_82:
      unsigned int v47 = 0;
      goto LABEL_83;
    }

    if (*(_DWORD *)&__p[12])
    {
      unint64_t v50 = 0LL;
      *(void *)&__int128 v49 = 134220290LL;
      __int128 v91 = v49;
      int v90 = v48;
      do
      {
        sub_100C0BA1C((int8x8_t *)&v12[v50 * *(unsigned int *)&__p[16]], v96);
        sub_100E72BC0(v38, (int *)v96, (uint64_t *)v96);
        uint64_t v94 = 0LL;
        uint64_t v95 = 0LL;
        sub_100C13C70(v9, v96[1].u16[0], v96[1].u16[1], (double *)&v95, (double *)&v94);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888E80);
        }
        __int16 v51 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          int v52 = *(_DWORD *)&__p[12];
          uint64_t v53 = *(void *)(v9 + 384);
          sub_100C0BA54((unsigned int *)v96, (std::stringbuf::string_type *)v99);
          __int16 v54 = v38;
          if (v99[23] >= 0) {
            uint64_t v55 = v99;
          }
          else {
            uint64_t v55 = *(_BYTE **)v99;
          }
          uint64_t v56 = v94;
          uint64_t v57 = v95;
          double v58 = (*(double (**)(uint64_t))(*(void *)v9 + 56LL))(v9);
          double v59 = (*(double (**)(uint64_t))(*(void *)v9 + 64LL))(v9);
          int v60 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 80LL))(v9);
          int v61 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 72LL))(v9);
          *(_DWORD *)std::stringbuf::string_type buf = v91;
          *(void *)double v116 = v50;
          *(_WORD *)&v116[8] = 1024;
          *(_DWORD *)__int16 v117 = v52;
          *(_WORD *)&v117[4] = 2048;
          *(void *)&v117[6] = v53;
          __int16 v118 = 2080;
          char v119 = v55;
          __int16 v120 = 2048;
          uint64_t v121 = v57;
          __int16 v122 = 2048;
          uint64_t v123 = v56;
          __int16 v124 = 2048;
          double v125 = v58;
          __int16 v126 = 2048;
          double v127 = v59;
          __int16 v128 = 1024;
          int v129 = v60;
          __int16 v130 = 1024;
          int v131 = v61;
          _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEBUG,  "TILE: entry, %3lu, %3u, %3lu, %s, loc, %.8lf, %.8lf, delta, %.5lf, %.5lf, grid, %u, %u",  buf,  0x5Au);
          if ((v99[23] & 0x80000000) != 0) {
            operator delete(*(void **)v99);
          }
          __int16 v38 = v54;
          clock_t v12 = (char *)v90;
          *(double *)&uint64_t v9 = v93;
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v62 = qword_101934A78;
          int v63 = *(_DWORD *)&__p[12];
          uint64_t v64 = *(void *)(v9 + 384);
          sub_100C0BA54((unsigned int *)v96, &v97);
          int v89 = v38;
          if ((v97.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v65 = &v97;
          }
          else {
            uint64_t v65 = (std::stringbuf::string_type *)v97.__r_.__value_.__r.__words[0];
          }
          uint64_t v66 = v94;
          uint64_t v67 = v95;
          double v68 = (*(double (**)(uint64_t))(*(void *)v9 + 56LL))(v9);
          double v69 = (*(double (**)(uint64_t))(*(void *)v9 + 64LL))(v9);
          int v70 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 80LL))(v9);
          int v71 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 72LL))(v9);
          *(_DWORD *)std::string::size_type v99 = v91;
          *(void *)&v99[4] = v50;
          *(_WORD *)&v99[12] = 1024;
          *(_DWORD *)&v99[14] = v63;
          *(_WORD *)&v99[18] = 2048;
          *(void *)&v99[20] = v64;
          *(_WORD *)&v99[28] = 2080;
          *(void *)&v99[30] = v65;
          *(_WORD *)&v99[38] = 2048;
          uint64_t v100 = v67;
          __int16 v101 = 2048;
          uint64_t v102 = v66;
          __int16 v103 = 2048;
          double v104 = v68;
          __int16 v105 = 2048;
          double v106 = v69;
          __int16 v107 = 1024;
          int v108 = v70;
          __int16 v109 = 1024;
          int v110 = v71;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v62,  2LL,  "TILE: entry, %3lu, %3u, %3lu, %s, loc, %.8lf, %.8lf, delta, %.5lf, %.5lf, grid, %u, %u",  v99,  90,  v89,  v90,  *(double *)&v91,  *((double *)&v91 + 1),  v92,  v93,  v94,  v95);
          double v73 = v72;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyL atLonEntry_GSM>::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const void *, const CLTileFile::TraverseDetails &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v73);
          __int16 v38 = (uint64_t **)v88;
        }

        ++v50;
      }

      while (v50 < *(unsigned int *)&__p[12]);
    }

void sub_100E69058( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E69090(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 184LL))(a1);
}

uint64_t sub_100E6909C(uint64_t a1, int *a2, void *a3)
{
  uint64_t v6 = (uint64_t **)(a1 + 368);
  uint64_t v7 = sub_100E72F04(a1 + 368, a2);
  unint64_t v8 = (void **)v7;
  if (a1 + 376 != v7)
  {
    uint64_t v9 = *(void *)(v7 + 25);
    *(void *)((char *)a3 + 6) = *(void *)(v7 + 31);
    *a3 = v9;
    return 1LL;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  int v11 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BA54((unsigned int *)a2, (std::stringbuf::string_type *)__p);
    clock_t v12 = v144[9] >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)std::stringbuf::string_type buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "TILE:  getLocationByKey_mmap, key, %s",  buf,  0xCu);
    if ((v144[9] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v85 = qword_101934A78;
    sub_100C0BA54((unsigned int *)a2, (std::stringbuf::string_type *)buf);
    if ((SBYTE7(v138) & 0x80u) == 0) {
      __int16 v86 = buf;
    }
    else {
      __int16 v86 = *(_BYTE **)buf;
    }
    *(_DWORD *)int v132 = 136315138;
    *(void *)&v132[4] = v86;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v85,  2LL,  "TILE:  getLocationByKey_mmap, key, %s",  v132);
    unsigned int v88 = v87;
    if (SBYTE7(v138) < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonE ntry_GSM>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLo nIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v88);
    if (v88 != __p) {
      free(v88);
    }
  }

  *(void *)(a1 + 352) = *(void *)(a1 + 344);
  sub_1010DDBC0(v126, "");
  uint64_t v128 = 0LL;
  int v129 = -1;
  uint64_t v130 = 0LL;
  uint64_t v131 = 0LL;
  if ((sub_100596978(a1, (uint64_t)v126) & 1) == 0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v17 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string __p = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "TILE: getLocationByKey_mmap, failed to mmap, #CloneMe",  __p,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934A78,  16LL,  "TILE: getLocationByKey_mmap, failed to mmap, #CloneMe",  buf,  2);
      int v90 = (char *)v89;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLo nEntry_GSM>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyL atLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v89);
      if (v90 != __p) {
        free(v90);
      }
    }

    BOOL v10 = 0LL;
    goto LABEL_179;
  }

  unint64_t v13 = 0LL;
  unsigned int v108 = 0;
  uint64_t v125 = 0LL;
  int v123 = 0;
  int v124 = 43962;
  uint64_t v120 = 0x200006ABBALL;
  __int128 v121 = 0u;
  __int128 v122 = 0u;
  *(void *)&uint8_t buf[4] = 184LL;
  *(_DWORD *)std::stringbuf::string_type buf = 371642;
  int v137 = 381;
  __int128 v138 = 0u;
  __int128 v139 = 0u;
  uint64_t v141 = 0LL;
  uint64_t v140 = 0LL;
  int v142 = 0;
  int v115 = 502714;
  __int128 v116 = xmmword_101362CA0;
  uint64_t v117 = 0LL;
  uint64_t v118 = 0LL;
  uint64_t v119 = 0LL;
  while (1)
  {
    while (1)
    {
      uint64_t v14 = v131;
      if (HIWORD(v124) == 7) {
        break;
      }
      if (HIWORD(v124) == 6)
      {
        sub_100C0C158(v130 + v14, (uint64_t)&v120);
        unint64_t v13 = (int8x8_t *)(v14 + v130 + v125 + 12);
        if ((unint64_t)v13 + (DWORD2(v121) * DWORD1(v121)) > v128 + v130)
        {
          if (!*(_BYTE *)(a1 + 392)) {
            goto LABEL_162;
          }
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v53 = (os_log_s *)qword_101934A78;
          if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
          {
            int v54 = DWORD1(v121);
            double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
            LODWORD(v107) = v54;
            sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
            int v55 = v133[9];
            uint64_t v56 = *(_BYTE **)v132;
            sub_100C0BA54((unsigned int *)a2, &v135);
            uint64_t v57 = v132;
            if (v55 < 0) {
              uint64_t v57 = v56;
            }
            double v58 = &v135;
            if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              double v58 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)std::string __p = 134284803;
            *(void *)&__p[4] = v13;
            *(_WORD *)&_BYTE __p[12] = 1025;
            *(_DWORD *)uint64_t v144 = (_DWORD)v107;
            *(_WORD *)&v144[4] = 2049;
            *(void *)&v144[6] = v14;
            *(_WORD *)&v144[14] = 2081;
            *(void *)&v144[16] = v106;
            *(_WORD *)&v144[24] = 2081;
            *(void *)&v144[26] = v57;
            *(_WORD *)&v144[34] = 2081;
            v145[0] = v58;
            _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_FAULT,  "TILE: pIndexEntries passes valid mmapped region, pIndexEntries:%{private}lu, numOfEntries:%{private}u, atO ffset:%{private}lld, %{private}s, %{private}s, %{private}s",  __p,  0x3Au);
            if ((v133[9] & 0x80000000) != 0) {
              operator delete(*(void **)v132);
            }
          }

          if (!sub_1002921D0(115, 0)) {
            goto LABEL_162;
          }
          bzero(__p, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v59 = qword_101934A78;
          LODWORD(v107) = DWORD1(v121);
          double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
          sub_100E72C48((uint64_t)buf, &v135);
          int size = (char)v135.__r_.__value_.__s.__size_;
          std::string::size_type v61 = v135.__r_.__value_.__r.__words[0];
          sub_100C0BA54((unsigned int *)a2, &v114);
          uint64_t v62 = &v135;
          if (size < 0) {
            uint64_t v62 = (std::stringbuf::string_type *)v61;
          }
          int v63 = &v114;
          if ((v114.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            int v63 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)int v132 = 134284803;
          *(void *)&v132[4] = v13;
          *(_WORD *)&v132[12] = 1025;
          *(_DWORD *)int v133 = (_DWORD)v107;
          *(_WORD *)&v133[4] = 2049;
          *(void *)&v133[6] = v14;
          *(_WORD *)&v133[14] = 2081;
          *(void *)&v133[16] = v106;
          *(_WORD *)&v133[24] = 2081;
          *(void *)&v133[26] = v62;
          *(_WORD *)&v133[34] = 2081;
          *(void *)int v134 = v63;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v59,  17LL,  "TILE: pIndexEntries passes valid mmapped region, pIndexEntries:%{private}lu, numOfEntries:%{private}u, atOff set:%{private}lld, %{private}s, %{private}s, %{private}s",  v132,  58);
          uint64_t v33 = v64;
          goto LABEL_147;
        }
      }

      else
      {
        if (HIWORD(v124) != 5)
        {
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          int v34 = (os_log_s *)qword_101934A78;
          if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_ERROR))
          {
            uint64_t v35 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
            sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
            uint64_t v36 = v133[9] >= 0 ? v132 : *(_BYTE **)v132;
            *(_DWORD *)std::string __p = 134218498;
            *(void *)&__p[4] = v14;
            *(_WORD *)&_BYTE __p[12] = 2080;
            *(void *)uint64_t v144 = v35;
            *(_WORD *)&v144[8] = 2080;
            *(void *)&v144[10] = v36;
            _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "TILE: unregconized sectionId, %lld, %s, %s",  __p,  0x20u);
            if ((v133[9] & 0x80000000) != 0) {
              operator delete(*(void **)v132);
            }
          }

          if (!sub_1002921D0(115, 0)) {
            goto LABEL_162;
          }
          bzero(__p, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v37 = qword_101934A78;
          __int16 v38 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
          sub_100E72C48((uint64_t)buf, &v135);
          if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            BOOL v39 = &v135;
          }
          else {
            BOOL v39 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)int v132 = 134218498;
          *(void *)&v132[4] = v14;
          *(_WORD *)&v132[12] = 2080;
          *(void *)int v133 = v38;
          *(_WORD *)&v133[8] = 2080;
          *(void *)&v133[10] = v39;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v37,  16LL,  "TILE: unregconized sectionId, %lld, %s, %s",  v132,  32,  v106);
          uint64_t v33 = v40;
LABEL_147:
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyL atLonEntry_GSM>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Ty pe::KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v33);
          goto LABEL_221;
        }

        sub_100C0B658(v130 + v14, (uint64_t)buf);
      }
    }

    sub_100C0C158(v130 + v14, (uint64_t)&v115);
    uint64_t v15 = v14 + v130 + v125 + 12;
    if (v15 + (unint64_t)(HIDWORD(v116) * DWORD2(v116)) > v128 + v130)
    {
      if (!*(_BYTE *)(a1 + 392)) {
        goto LABEL_162;
      }
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      int v41 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        int v42 = DWORD2(v116);
        double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
        LODWORD(v107) = v42;
        sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
        int v43 = v133[9];
        uint64_t v44 = *(_BYTE **)v132;
        sub_100C0BA54((unsigned int *)a2, &v135);
        uint64_t v45 = v132;
        if (v43 < 0) {
          uint64_t v45 = v44;
        }
        uint64_t v46 = &v135;
        if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v46 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string __p = 134284803;
        *(void *)&__p[4] = v15;
        *(_WORD *)&_BYTE __p[12] = 1025;
        *(_DWORD *)uint64_t v144 = (_DWORD)v107;
        *(_WORD *)&v144[4] = 2049;
        *(void *)&v144[6] = v14;
        *(_WORD *)&v144[14] = 2081;
        *(void *)&v144[16] = v106;
        *(_WORD *)&v144[24] = 2080;
        *(void *)&v144[26] = v45;
        *(_WORD *)&v144[34] = 2081;
        v145[0] = v46;
        _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "TILE: pDataEntries passes valid mmapped region, pDataEntries:%{private}lu, numOfEntries:%{private}u, atOffset: %{private}lld, %{private}s, %{privat}s, %{private}s",  __p,  0x3Au);
        if ((v133[9] & 0x80000000) != 0) {
          operator delete(*(void **)v132);
        }
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_162;
      }
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v47 = qword_101934A78;
      LODWORD(v107) = DWORD2(v116);
      double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v135);
      int v48 = (char)v135.__r_.__value_.__s.__size_;
      std::string::size_type v49 = v135.__r_.__value_.__r.__words[0];
      sub_100C0BA54((unsigned int *)a2, &v114);
      unint64_t v50 = &v135;
      if (v48 < 0) {
        unint64_t v50 = (std::stringbuf::string_type *)v49;
      }
      __int16 v51 = &v114;
      if ((v114.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int16 v51 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int v132 = 134284803;
      *(void *)&v132[4] = v15;
      *(_WORD *)&v132[12] = 1025;
      *(_DWORD *)int v133 = (_DWORD)v107;
      *(_WORD *)&v133[4] = 2049;
      *(void *)&v133[6] = v14;
      *(_WORD *)&v133[14] = 2081;
      *(void *)&v133[16] = v106;
      *(_WORD *)&v133[24] = 2080;
      *(void *)&v133[26] = v50;
      *(_WORD *)&v133[34] = 2081;
      *(void *)int v134 = v51;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v47,  17LL,  "TILE: pDataEntries passes valid mmapped region, pDataEntries:%{private}lu, numOfEntries:%{private}u, atOffset:%{ private}lld, %{private}s, %{privat}s, %{private}s",  v132,  58);
      uint64_t v33 = v52;
      goto LABEL_147;
    }

    sub_100008390((uint64_t)v6, *v8);
    *(void *)(a1 + 384) = 0LL;
    *(void *)(a1 + 368) = v8;
    const char *v8 = 0LL;
    uint64_t v112 = 0LL;
    int v113 = 0;
    sub_100C0BCB8(&v112, a2);
    unsigned int v110 = DWORD2(v116);
    unsigned int v111 = 0;
    if (!v13)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v65 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_ERROR))
      {
        uint64_t v66 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
        sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)__p);
        uint64_t v67 = v144[9] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)int v132 = 136380931;
        *(void *)&v132[4] = v66;
        *(_WORD *)&v132[12] = 2081;
        *(void *)int v133 = v67;
        _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_ERROR,  "TILE: no index section before entries section, %{private}s, %{private}s",  v132,  0x16u);
        if ((v144[9] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_162;
      }
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v68 = qword_101934A78;
      double v69 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
      if (v133[9] >= 0) {
        int v70 = v132;
      }
      else {
        int v70 = *(_BYTE **)v132;
      }
      LODWORD(v135.__r_.__value_.__l.__data_) = 136380931;
      *(std::string::size_type *)((char *)v135.__r_.__value_.__r.__words + 4) = (std::string::size_type)v69;
      WORD2(v135.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&v135.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v70;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v68,  16LL,  "TILE: no index section before entries section, %{private}s, %{private}s",  &v135,  22);
      uint64_t v33 = v71;
      if ((v133[9] & 0x80000000) != 0) {
        operator delete(*(void **)v132);
      }
      goto LABEL_147;
    }

    BOOL v16 = sub_100E72D94(a1, v13, DWORD1(v121), SDWORD2(v121), &v112, &v111, &v110);
    if (v111 >= DWORD2(v116) || v110 >= DWORD2(v116)) {
      break;
    }
    if (!v16)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      __int16 v72 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(v106) = v111;
        LODWORD(v107) = v110;
        sub_100C0BBAC((unsigned int *)&v112, (std::stringbuf::string_type *)v132);
        if (v133[9] >= 0) {
          double v73 = v132;
        }
        else {
          double v73 = *(_BYTE **)v132;
        }
        BOOL v74 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
        sub_100E72C48((uint64_t)buf, &v135);
        if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v75 = &v135;
        }
        else {
          int v75 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::string __p = 67175683;
        *(_DWORD *)&__p[4] = (_DWORD)v106;
        *(_WORD *)&__p[8] = 1025;
        *(_DWORD *)&__p[10] = (_DWORD)v107;
        *(_WORD *)uint64_t v144 = 2081;
        *(void *)&v144[2] = v73;
        *(_WORD *)&v144[10] = 2081;
        *(void *)&v144[12] = v74;
        *(_WORD *)&v144[20] = 2081;
        *(void *)&v144[22] = v75;
        _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_DEBUG,  "TILE: not found in index, a, %{private}u, b, %{private}u, %{private}s, %{private}s, %{private}s",  __p,  0x2Cu);
        if ((v133[9] & 0x80000000) != 0) {
          operator delete(*(void **)v132);
        }
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_162;
      }
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      __int16 v107 = (const char *)qword_101934A78;
      unsigned int v99 = v111;
      LODWORD(v106) = v110;
      sub_100C0BBAC((unsigned int *)&v112, &v135);
      if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v100 = &v135;
      }
      else {
        uint64_t v100 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
      }
      __int16 v101 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v114);
      if ((v114.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v102 = &v114;
      }
      else {
        uint64_t v102 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int v132 = 67175683;
      *(_DWORD *)&v132[4] = v99;
      *(_WORD *)&v132[8] = 1025;
      *(_DWORD *)&v132[10] = (_DWORD)v106;
      *(_WORD *)int v133 = 2081;
      *(void *)&v133[2] = v100;
      *(_WORD *)&v133[10] = 2081;
      *(void *)&v133[12] = v101;
      *(_WORD *)&v133[20] = 2081;
      *(void *)&v133[22] = v102;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v107,  2LL,  "TILE: not found in index, a, %{private}u, b, %{private}u, %{private}s, %{private}s, %{private}s",  v132,  44);
      uint64_t v33 = v103;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLo nEntry_GSM>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyL atLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v33);
LABEL_221:
      if (v33 != __p) {
        free(v33);
      }
      goto LABEL_162;
    }

    unsigned int v108 = v110 - v111 + 1;
    sub_100E72BC0(v6, (int *)a3, a3);
  }

  if (*(_BYTE *)(a1 + 392))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    unint64_t v18 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      unint64_t v19 = v132;
      sub_100C0BBAC((unsigned int *)&v112, (std::stringbuf::string_type *)v132);
      if (v133[9] < 0) {
        unint64_t v19 = *(_BYTE **)v132;
      }
      __int16 v107 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v135);
      int v20 = (char)v135.__r_.__value_.__s.__size_;
      std::string::size_type v21 = v135.__r_.__value_.__r.__words[0];
      unsigned int v22 = v111;
      unsigned int v105 = v110;
      LODWORD(v106) = DWORD2(v116);
      sub_100C0BA54((unsigned int *)a2, &v114);
      uint64_t v23 = &v135;
      if (v20 < 0) {
        uint64_t v23 = (std::stringbuf::string_type *)v21;
      }
      int8x8_t v24 = &v114;
      if ((v114.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int8x8_t v24 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string __p = 136382211;
      *(void *)&__p[4] = v19;
      *(_WORD *)&_BYTE __p[12] = 2081;
      *(void *)uint64_t v144 = v107;
      *(_WORD *)&v144[8] = 2081;
      *(void *)&v144[10] = v23;
      *(_WORD *)&v144[18] = 1025;
      *(_DWORD *)&v144[20] = v22;
      *(_WORD *)&v144[24] = 1025;
      *(_DWORD *)&v144[26] = v105;
      *(_WORD *)&v144[30] = 1025;
      *(_DWORD *)&v144[32] = (_DWORD)v106;
      LOWORD(v145[0]) = 2081;
      *(void *)((char *)v145 + 2) = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "TILE: invalid binary search %{private}s in %{private}s, %{private}s, a:%{private}u, b:%{private}u, max:%{private}u, %{private}s",  __p,  0x3Cu);
      if ((v133[9] & 0x80000000) != 0) {
        operator delete(*(void **)v132);
      }
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      __int16 v107 = (const char *)qword_101934A78;
      uint64_t v25 = &v135;
      sub_100C0BBAC((unsigned int *)&v112, &v135);
      if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v25 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
      }
      double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v114);
      int v26 = (char)v114.__r_.__value_.__s.__size_;
      std::string::size_type v27 = v114.__r_.__value_.__r.__words[0];
      unsigned int v28 = v110;
      unsigned int v29 = v111;
      HIDWORD(v104) = DWORD2(v116);
      sub_100C0BA54((unsigned int *)a2, &v109);
      __int128 v30 = &v114;
      if (v26 < 0) {
        __int128 v30 = (std::stringbuf::string_type *)v27;
      }
      int v31 = &v109;
      if ((v109.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v31 = (std::stringbuf::string_type *)v109.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int v132 = 136382211;
      *(void *)&v132[4] = v25;
      *(_WORD *)&v132[12] = 2081;
      *(void *)int v133 = v106;
      *(_WORD *)&v133[8] = 2081;
      *(void *)&v133[10] = v30;
      *(_WORD *)&v133[18] = 1025;
      *(_DWORD *)&v133[20] = v29;
      *(_WORD *)&v133[24] = 1025;
      *(_DWORD *)&v133[26] = v28;
      *(_WORD *)&v133[30] = 1025;
      *(_DWORD *)&v133[32] = HIDWORD(v104);
      *(_WORD *)int v134 = 2081;
      *(void *)&v134[2] = v31;
      LODWORD(v104) = 60;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v107,  17LL,  "TILE: invalid binary search %{private}s in %{private}s, %{private}s, a:%{private}u, b:%{private}u, max:%{private}u, %{private}s",  v132,  v104);
      uint64_t v33 = v32;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLo nEntry_GSM>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyL atLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v33);
      goto LABEL_221;
    }
  }

void sub_100E6A84C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, void *__p, uint64_t a37, int a38, __int16 a39, char a40, char a41)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100E6A994(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  *(void *)(a1 + 334) = *(uint64_t *)((char *)a2 + 6);
  *(void *)(a1 + 328) = v6;
  char v42 = 0;
  nullsub_10(0LL);
  uint64_t v44 = v7;
  int v41 = "search";
  char v43 = 1;
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  unint64_t v8 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BA54((unsigned int *)a2, &__p);
    uint64_t v9 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
       ? &__p
       : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "TILE: getLocationByKey_traverse, key, %s",  (uint8_t *)&buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v24 = qword_101934A78;
    sub_100C0BA54((unsigned int *)a2, &buf);
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_std::stringbuf::string_type buf = &buf;
    }
    else {
      p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v48.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_buf;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v24,  2LL,  "TILE: getLocationByKey_traverse, key, %s",  (const char *)&v48);
    std::string::size_type v27 = v26;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonE ntry_GSM>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyL atLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  (const char *)v27);
    if (v27 != &__p) {
      free(v27);
    }
  }

  sub_100C0FCEC(a1, &v48);
  BOOL v10 = (const char **)(a1 + 8);
  int v11 = (const char *)(a1 + 8);
  if (sub_100292D28(v11))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    clock_t v12 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      std::string::size_type v13 = a1 + 8;
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "TILE: getLocationByKey_traverse, prefer local file name because it exists, %s",  (uint8_t *)&__p,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      std::string::size_type v35 = a1 + 8;
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v35;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: getLocationByKey_traverse, prefer local file name because it exists, %s",  (const char *)&buf);
      uint64_t v37 = (std::stringbuf::string_type *)v36;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLo nEntry_GSM>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type:: KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v36);
      if (v37 != &__p) {
        free(v37);
      }
    }

    std::string::operator=(&v48, (const std::string *)(a1 + 8));
  }

  sub_100C1145C((void *)a1, (uint64_t)&v48, (uint64_t)&v41);
  uint64_t v14 = sub_100E72F04(a1 + 368, (int *)a2);
  uint64_t v15 = v14;
  uint64_t v16 = a1 + 376;
  if (a1 + 376 != v14)
  {
    uint64_t v17 = *(void *)(v14 + 25);
    *(void *)(a3 + 6) = *(void *)(v14 + 31);
    *(void *)a3 = v17;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  unint64_t v18 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BA54((unsigned int *)a2, &buf);
    int size = (char)buf.__r_.__value_.__s.__size_;
    std::string::size_type v20 = buf.__r_.__value_.__r.__words[0];
    sub_100C0BA54((unsigned int *)a3, &v40);
    std::string::size_type v21 = &buf;
    if (size < 0) {
      std::string::size_type v21 = (std::stringbuf::string_type *)v20;
    }
    if ((v40.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unsigned int v22 = &v40;
    }
    else {
      unsigned int v22 = (std::stringbuf::string_type *)v40.__r_.__value_.__r.__words[0];
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 67109890;
    HIDWORD(__p.__r_.__value_.__r.__words[0]) = v16 != v15;
    __p.__r_.__value_.__l.__size_ = 0x820000000000400LL;
    __p.__r_.__value_.__l.__cap_ = (std::string::size_type)v21;
    __int16 v50 = 2080;
    __int16 v51 = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "TILE: getLocationByKey_traverse, isFound, %d, searchedArea, %u, key, %s, entry, %s",  (uint8_t *)&__p,  0x22u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v28 = qword_101934A78;
    sub_100C0BA54((unsigned int *)a2, &v40);
    int v29 = (char)v40.__r_.__value_.__s.__size_;
    std::string::size_type v30 = v40.__r_.__value_.__r.__words[0];
    sub_100C0BA54((unsigned int *)a3, &v39);
    int v31 = &v40;
    if (v29 < 0) {
      int v31 = (std::stringbuf::string_type *)v30;
    }
    if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v32 = &v39;
    }
    else {
      __int128 v32 = (std::stringbuf::string_type *)v39.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109890;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v16 != v15;
    buf.__r_.__value_.__l.__size_ = 0x820000000000400LL;
    buf.__r_.__value_.__l.__cap_ = (std::string::size_type)v31;
    __int16 v46 = 2080;
    uint64_t v47 = v32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v28,  2LL,  "TILE: getLocationByKey_traverse, isFound, %d, searchedArea, %u, key, %s, entry, %s",  &buf,  34,  v38,  v39.__r_.__value_.__l.__data_);
    int v34 = v33;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonE ntry_GSM>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyL atLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  (const char *)v34);
    if (v34 != &__p) {
      free(v34);
    }
  }

  (*(void (**)(uint64_t))(*(void *)a1 + 104LL))(a1);
  return v16 != v15;
}

void sub_100E6B04C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, void *__p, uint64_t a34, int a35, __int16 a36, char a37, char a38)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E6B0B8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E71DE8(a1);
  operator delete(v1);
}

uint64_t sub_100E6B0CC(uint64_t a1, std::string::value_type *a2)
{
  double Current = CFAbsoluteTimeGetCurrent();
  sub_100C0FAA0(a1, a2);
  sub_100C124C8((uint64_t *)a1, "", a2, *(_DWORD *)(a1 + 48), 0, Current);
  sub_100E72F80((uint64_t *)&v50, a1 + 368);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  uint64_t v5 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 134218242;
    *(void *)std::string::size_type v61 = v52;
    *(_WORD *)&v61[8] = 2080;
    *(void *)&v61[10] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "TILE: result: tilestool: TEST_testBinarySearch, entries, %lu, file, %s",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    *(_DWORD *)std::stringbuf::string_type __p = 134218242;
    *(void *)&__p[4] = v52;
    *(_WORD *)&_BYTE __p[12] = 2080;
    *(void *)&_BYTE __p[14] = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: result: tilestool: TEST_testBinarySearch, entries, %lu, file, %s",  __p,  22);
    uint64_t v37 = (uint8_t *)v36;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLon Entry_CDMA>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, Da taEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v36);
    if (v37 != buf) {
      free(v37);
    }
  }

  uint64_t v6 = a1 + 376;
  sub_100008390(a1 + 368, *(void **)(a1 + 376));
  *(void *)(a1 + 376) = 0LL;
  *(void *)(a1 + 384) = 0LL;
  *(void *)(a1 + 368) = a1 + 376;
  unint64_t v8 = v50;
  char v43 = (const char *)&v51;
  if (v50 != (const char *)&v51)
  {
    uint64_t v9 = 0LL;
    *(void *)&__int128 v7 = 134219266LL;
    __int128 v41 = v7;
    while (1)
    {
      *(void *)std::string::size_type v49 = *(void *)(v8 + 25);
      *(void *)((char *)&v49[1] + 2) = *(void *)(v8 + 31);
      memset(v48, 0, 14);
      uint64_t v46 = 0LL;
      memset(v47, 0, 14);
      uint64_t v45 = 0LL;
      sub_100008390(a1 + 368, *(void **)(a1 + 376));
      *(void *)(a1 + 376) = 0LL;
      *(void *)(a1 + 384) = 0LL;
      *(void *)(a1 + 368) = v6;
      clock_t v10 = clock();
      int v11 = (*(uint64_t (**)(uint64_t, unsigned int *, void *))(*(void *)a1 + 192LL))(a1, v49, v48);
      clock_t v12 = clock();
      sub_100008390(a1 + 368, *(void **)(a1 + 376));
      *(void *)(a1 + 376) = 0LL;
      *(void *)(a1 + 384) = 0LL;
      *(void *)(a1 + 368) = v6;
      clock_t v13 = clock();
      int v14 = (*(uint64_t (**)(uint64_t, unsigned int *, _WORD *))(*(void *)a1 + 184LL))(a1, v49, v47);
      clock_t v15 = clock();
      printf("tilestool: mmap, %lu, file, %lu\n", v15 - v13, v12 - v10);
      if (v11 != v14) {
        break;
      }
      int v16 = (*(uint64_t (**)(uint64_t, unsigned int *, void *))(*(void *)a1 + 176LL))(a1, v49, v48);
      if (v16) {
        sub_100C13C70(a1, LOWORD(v48[1]), WORD1(v48[1]), (double *)&v46, (double *)&v45);
      }
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v17 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v18 = v52;
        uint64_t v19 = v45;
        uint64_t v20 = v46;
        sub_100C0BF10(v49, (std::stringbuf::string_type *)__p);
        std::string::size_type v21 = __p;
        if (__p[23] < 0) {
          std::string::size_type v21 = *(_BYTE **)__p;
        }
        *(_DWORD *)std::stringbuf::string_type buf = v41;
        *(void *)std::string::size_type v61 = v9;
        *(_WORD *)&v61[8] = 2048;
        *(void *)&v61[10] = v18;
        *(_WORD *)&v61[18] = 1024;
        *(_DWORD *)&v61[20] = v16;
        __int16 v62 = 2048;
        uint64_t v63 = v20;
        __int16 v64 = 2048;
        uint64_t v65 = v19;
        __int16 v66 = 2080;
        uint64_t v67 = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "TILE: result: tilestool: prog, %3lu, %3lu, ===============> isFound, %d, location, %14.8lf, %14.8lf, entry, %s",  buf,  0x3Au);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888E80);
        }
        uint64_t v25 = qword_101934A78;
        uint64_t v26 = v52;
        uint64_t v27 = v45;
        uint64_t v28 = v46;
        sub_100C0BF10(v49, &v44);
        int v29 = &v44;
        if ((v44.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          int v29 = (std::stringbuf::string_type *)v44.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::stringbuf::string_type __p = v41;
        *(void *)&__p[4] = v9;
        *(_WORD *)&_BYTE __p[12] = 2048;
        *(void *)&_BYTE __p[14] = v26;
        *(_WORD *)&__p[22] = 1024;
        *(_DWORD *)&__p[24] = v16;
        __int16 v54 = 2048;
        uint64_t v55 = v28;
        __int16 v56 = 2048;
        uint64_t v57 = v27;
        __int16 v58 = 2080;
        uint64_t v59 = v29;
        LODWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 58;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v25,  2LL,  "TILE: result: tilestool: prog, %3lu, %3lu, ===============> isFound, %d, location, %14.8lf, %14.8lf, entry, %s",  __p,  v40,  (_DWORD)v41,  *((double *)&v41 + 1),  v42,  v43);
        int v31 = v30;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLa tLonEntry_CDMA>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_ CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v31);
      }

      if (!v16)
      {
        int v34 = 759;
        std::string::size_type v35 = "isFound";
LABEL_44:
        __assert_rtn("TEST_testBinarySearch", "CLKeyLatLonTileTemplate.h", v34, v35);
      }

      unsigned int v22 = (const char *)*((void *)v8 + 1);
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          unsigned int v22 = *(const char **)v22;
        }

        while (v22);
      }

      else
      {
        do
        {
          uint64_t v23 = (const char *)*((void *)v8 + 2);
          BOOL v24 = *(void *)v23 == (void)v8;
          unint64_t v8 = v23;
        }

        while (!v24);
      }

      ++v9;
      unint64_t v8 = v23;
      if (v23 == v43) {
        goto LABEL_36;
      }
    }

    int v34 = 742;
    std::string::size_type v35 = "isFound == isFoundMmap";
    goto LABEL_44;
  }

  uint64_t v9 = 0LL;
LABEL_36:
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  __int128 v32 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 67109632;
    *(_DWORD *)std::string::size_type v61 = 1;
    *(_WORD *)&v61[4] = 2048;
    *(void *)&v61[6] = v9;
    *(_WORD *)&v61[14] = 2048;
    *(void *)&v61[16] = v52;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "TILE: result: tilestool: pass, %d, tests, %lu, %lu",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    *(void *)std::stringbuf::string_type __p = 0x104000300LL;
    *(_WORD *)&__p[8] = 2048;
    *(void *)&__p[10] = v9;
    *(_WORD *)&__p[18] = 2048;
    *(void *)&_BYTE __p[20] = v52;
    LODWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: result: tilestool: pass, %d, tests, %lu, %lu",  __p,  v40,  (void)v41);
    std::stringbuf::string_type v39 = (uint8_t *)v38;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLon Entry_CDMA>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, Da taEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v38);
    if (v39 != buf) {
      free(v39);
    }
  }

  sub_100008390((uint64_t)&v50, v51);
  return 1LL;
}

void sub_100E6B884( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, void *a27)
{
}

void sub_100E6B8D8(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = a1;
  sub_10059826C(a1, (uint64_t)a2, a3);
  uint64_t v98 = 0LL;
  int v10 = *(unsigned __int16 *)(a3 + 2);
  if (v10 != 7)
  {
    if (v10 == 6)
    {
      *(void *)unsigned int v99 = 0x200006ABBALL;
      memset(&v99[8], 0, 32);
      LODWORD(v10sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
      sub_100C0C158(a4, (uint64_t)v99);
      int v11 = (void *)(v9 + 344);
      *(void *)(v9 + 352) = *(void *)(v9 + 344);
      sub_100E72208((char **)(v9 + 344), *(unsigned int *)&v99[12]);
      clock_t v12 = (char *)sub_100599BF4(v9, a2, a3, 0, *(int *)&v99[12], *(int *)&v99[16]);
      if (v12)
      {
        v96[0] = 0LL;
        v96[1].i32[0] = 0;
        if (*(_DWORD *)&v99[12])
        {
          unint64_t v13 = 0LL;
          do
          {
            sub_100C0BB90((int8x8_t *)&v12[v13 * *(unsigned int *)&v99[16]], v96);
            clock_t v15 = *(int8x8_t **)(v9 + 352);
            unint64_t v14 = *(void *)(v9 + 360);
            if ((unint64_t)v15 >= v14)
            {
              unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v15 - *v11) >> 2);
              unint64_t v19 = v18 + 1;
              if (v18 + 1 > 0x1555555555555555LL) {
                sub_100007008();
              }
              unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - *v11) >> 2);
              if (2 * v20 > v19) {
                unint64_t v19 = 2 * v20;
              }
              if (v20 >= 0xAAAAAAAAAAAAAAALL) {
                unint64_t v21 = 0x1555555555555555LL;
              }
              else {
                unint64_t v21 = v19;
              }
              if (v21) {
                unsigned int v22 = (char *)sub_1005AADE4(v9 + 360, v21);
              }
              else {
                unsigned int v22 = 0LL;
              }
              uint64_t v23 = (int8x8_t *)&v22[12 * v18];
              int8x8_t v24 = v96[0];
              v23[1].i32[0] = v96[1].i32[0];
              int8x8_t *v23 = v24;
              uint64_t v26 = *(_DWORD **)(v9 + 344);
              uint64_t v25 = *(_DWORD **)(v9 + 352);
              uint64_t v27 = v23;
              if (v25 != v26)
              {
                do
                {
                  int8x8_t v28 = *(int8x8_t *)(v25 - 3);
                  v25 -= 3;
                  __int32 v29 = v25[2];
                  *(int8x8_t *)((char *)v27 - 12) = v28;
                  uint64_t v27 = (int8x8_t *)((char *)v27 - 12);
                  v27[1].i32[0] = v29;
                }

                while (v25 != v26);
                uint64_t v25 = (_DWORD *)*v11;
              }

              uint64_t v17 = (char *)&v23[1] + 4;
              *(void *)(v9 + 344) = v27;
              *(void *)(v9 + 352) = (char *)v23 + 12;
              *(void *)(v9 + 36sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = &v22[12 * v21];
              if (v25) {
                operator delete(v25);
              }
            }

            else
            {
              int8x8_t v16 = v96[0];
              v15[1].i32[0] = v96[1].i32[0];
              int8x8_t *v15 = v16;
              uint64_t v17 = (char *)&v15[1] + 4;
            }

            *(void *)(v9 + 352) = v17;
            if (!*(_BYTE *)(a5 + 9))
            {
              if (qword_101934A70 != -1) {
                dispatch_once(&qword_101934A70, &stru_101888E80);
              }
              std::string::size_type v30 = (os_log_s *)qword_101934A78;
              if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
              {
                int v31 = *(_DWORD *)&v99[12];
                sub_100C0C04C((unsigned int *)v96, (std::stringbuf::string_type *)__p);
                __int128 v32 = __p;
                if (SBYTE3(v112) < 0) {
                  __int128 v32 = *(_BYTE **)__p;
                }
                *(_DWORD *)std::stringbuf::string_type buf = 134218498;
                *(void *)__int128 v116 = v13;
                *(_WORD *)&v116[8] = 1024;
                *(_DWORD *)uint64_t v117 = v31;
                *(_WORD *)&v117[4] = 2080;
                *(void *)&v117[6] = v32;
                _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "TILE: index entry, %3lu, %3u, %s",  buf,  0x1Cu);
                if (SBYTE3(v112) < 0) {
                  operator delete(*(void **)__p);
                }
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934A70 != -1) {
                  dispatch_once(&qword_101934A70, &stru_101888E80);
                }
                uint64_t v33 = qword_101934A78;
                int v34 = *(_DWORD *)&v99[12];
                sub_100C0C04C((unsigned int *)v96, &v97);
                std::string::size_type v35 = &v97;
                if ((v97.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  std::string::size_type v35 = (std::stringbuf::string_type *)v97.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)std::stringbuf::string_type __p = 134218498;
                *(void *)&__p[4] = v13;
                *(_WORD *)&_BYTE __p[12] = 1024;
                *(_DWORD *)&_BYTE __p[14] = v34;
                *(_WORD *)&__p[18] = 2080;
                uint64_t v112 = v35;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v33,  2LL,  "TILE: index entry, %3lu, %3u, %s",  __p,  28,  v88);
                uint64_t v37 = v36;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Typ e::KeyLatLonEntry_CDMA>::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const void *, const CLTileFile::TraverseDetails &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry _CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v37);
              }
            }

            ++v13;
          }

          while (v13 < *(unsigned int *)&v99[12]);
        }
      }

      goto LABEL_82;
    }

    unsigned int v47 = 0;
    goto LABEL_57;
  }

  *(_DWORD *)std::stringbuf::string_type __p = 502714;
  *(_OWORD *)&__p[4] = xmmword_101362CA0;
  uint64_t v112 = 0LL;
  uint64_t v114 = 0LL;
  uint64_t v113 = 0LL;
  sub_100C0C158(a4, (uint64_t)__p);
  __int16 v38 = (uint64_t **)(v9 + 368);
  sub_100008390(v9 + 368, *(void **)(v9 + 376));
  *(void *)(v9 + 376) = 0LL;
  *(void *)(v9 + 384) = 0LL;
  *(void *)(v9 + 368) = v9 + 376;
  double v93 = *(double *)&v9;
  if (!*(_BYTE *)(a5 + 9))
  {
    memset(v96, 0, 14);
    std::string v48 = (const char *)sub_100599BF4(v9, a2, a3, 0, *(int *)&__p[12], *(int *)&__p[16]);
    clock_t v12 = (char *)v48;
    if (!v48)
    {
LABEL_82:
      unsigned int v47 = 0;
      goto LABEL_83;
    }

    if (*(_DWORD *)&__p[12])
    {
      unint64_t v50 = 0LL;
      *(void *)&__int128 v49 = 134220290LL;
      __int128 v91 = v49;
      int v90 = v48;
      do
      {
        sub_100C0BA1C((int8x8_t *)&v12[v50 * *(unsigned int *)&__p[16]], v96);
        sub_100E72BC0(v38, (int *)v96, (uint64_t *)v96);
        uint64_t v94 = 0LL;
        uint64_t v95 = 0LL;
        sub_100C13C70(v9, v96[1].u16[0], v96[1].u16[1], (double *)&v95, (double *)&v94);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888E80);
        }
        __int16 v51 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          int v52 = *(_DWORD *)&__p[12];
          uint64_t v53 = *(void *)(v9 + 384);
          sub_100C0BF10((unsigned int *)v96, (std::stringbuf::string_type *)v99);
          __int16 v54 = v38;
          if (v99[23] >= 0) {
            uint64_t v55 = v99;
          }
          else {
            uint64_t v55 = *(_BYTE **)v99;
          }
          uint64_t v56 = v94;
          uint64_t v57 = v95;
          double v58 = (*(double (**)(uint64_t))(*(void *)v9 + 56LL))(v9);
          double v59 = (*(double (**)(uint64_t))(*(void *)v9 + 64LL))(v9);
          int v60 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 80LL))(v9);
          int v61 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 72LL))(v9);
          *(_DWORD *)std::stringbuf::string_type buf = v91;
          *(void *)__int128 v116 = v50;
          *(_WORD *)&v116[8] = 1024;
          *(_DWORD *)uint64_t v117 = v52;
          *(_WORD *)&v117[4] = 2048;
          *(void *)&v117[6] = v53;
          __int16 v118 = 2080;
          uint64_t v119 = v55;
          __int16 v120 = 2048;
          uint64_t v121 = v57;
          __int16 v122 = 2048;
          uint64_t v123 = v56;
          __int16 v124 = 2048;
          double v125 = v58;
          __int16 v126 = 2048;
          double v127 = v59;
          __int16 v128 = 1024;
          int v129 = v60;
          __int16 v130 = 1024;
          int v131 = v61;
          _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEBUG,  "TILE: entry, %3lu, %3u, %3lu, %s, loc, %.8lf, %.8lf, delta, %.5lf, %.5lf, grid, %u, %u",  buf,  0x5Au);
          if ((v99[23] & 0x80000000) != 0) {
            operator delete(*(void **)v99);
          }
          __int16 v38 = v54;
          clock_t v12 = (char *)v90;
          *(double *)&uint64_t v9 = v93;
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v62 = qword_101934A78;
          int v63 = *(_DWORD *)&__p[12];
          uint64_t v64 = *(void *)(v9 + 384);
          sub_100C0BF10((unsigned int *)v96, &v97);
          int v89 = v38;
          if ((v97.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v65 = &v97;
          }
          else {
            uint64_t v65 = (std::stringbuf::string_type *)v97.__r_.__value_.__r.__words[0];
          }
          uint64_t v66 = v94;
          uint64_t v67 = v95;
          double v68 = (*(double (**)(uint64_t))(*(void *)v9 + 56LL))(v9);
          double v69 = (*(double (**)(uint64_t))(*(void *)v9 + 64LL))(v9);
          int v70 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 80LL))(v9);
          int v71 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 72LL))(v9);
          *(_DWORD *)unsigned int v99 = v91;
          *(void *)&v99[4] = v50;
          *(_WORD *)&v99[12] = 1024;
          *(_DWORD *)&v99[14] = v63;
          *(_WORD *)&v99[18] = 2048;
          *(void *)&v99[20] = v64;
          *(_WORD *)&v99[28] = 2080;
          *(void *)&v99[30] = v65;
          *(_WORD *)&v99[38] = 2048;
          uint64_t v100 = v67;
          __int16 v101 = 2048;
          uint64_t v102 = v66;
          __int16 v103 = 2048;
          double v104 = v68;
          __int16 v105 = 2048;
          double v106 = v69;
          __int16 v107 = 1024;
          int v108 = v70;
          __int16 v109 = 1024;
          int v110 = v71;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v62,  2LL,  "TILE: entry, %3lu, %3u, %3lu, %s, loc, %.8lf, %.8lf, delta, %.5lf, %.5lf, grid, %u, %u",  v99,  90,  v89,  v90,  *(double *)&v91,  *((double *)&v91 + 1),  v92,  v93,  v94,  v95);
          double v73 = v72;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::Key LatLonEntry_CDMA>::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const void *, con st CLTileFile::TraverseDetails &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v73);
          __int16 v38 = (uint64_t **)v88;
        }

        ++v50;
      }

      while (v50 < *(unsigned int *)&__p[12]);
    }

void sub_100E6C6D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E6C710(uint64_t a1, int *a2, void *a3)
{
  uint64_t v6 = (uint64_t **)(a1 + 368);
  uint64_t v7 = sub_100E72F04(a1 + 368, a2);
  unint64_t v8 = (void **)v7;
  if (a1 + 376 != v7)
  {
    uint64_t v9 = *(void *)(v7 + 25);
    *(void *)((char *)a3 + 6) = *(void *)(v7 + 31);
    *a3 = v9;
    return 1LL;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  int v11 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BF10((unsigned int *)a2, (std::stringbuf::string_type *)__p);
    clock_t v12 = v144[9] >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)std::stringbuf::string_type buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "TILE:  getLocationByKey_mmap, key, %s",  buf,  0xCu);
    if ((v144[9] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v85 = qword_101934A78;
    sub_100C0BF10((unsigned int *)a2, (std::stringbuf::string_type *)buf);
    if ((SBYTE7(v138) & 0x80u) == 0) {
      __int16 v86 = buf;
    }
    else {
      __int16 v86 = *(_BYTE **)buf;
    }
    *(_DWORD *)int v132 = 136315138;
    *(void *)&v132[4] = v86;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v85,  2LL,  "TILE:  getLocationByKey_mmap, key, %s",  v132);
    unsigned int v88 = v87;
    if (SBYTE7(v138) < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLon Entry_CDMA>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLat LonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v88);
    if (v88 != __p) {
      free(v88);
    }
  }

  *(void *)(a1 + 352) = *(void *)(a1 + 344);
  sub_1010DDBC0(v126, "");
  uint64_t v128 = 0LL;
  int v129 = -1;
  uint64_t v130 = 0LL;
  uint64_t v131 = 0LL;
  if ((sub_100596978(a1, (uint64_t)v126) & 1) == 0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v17 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::stringbuf::string_type __p = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "TILE: getLocationByKey_mmap, failed to mmap, #CloneMe",  __p,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934A78,  16LL,  "TILE: getLocationByKey_mmap, failed to mmap, #CloneMe",  buf,  2);
      int v90 = (char *)v89;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatL onEntry_CDMA>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::Ke yLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v89);
      if (v90 != __p) {
        free(v90);
      }
    }

    BOOL v10 = 0LL;
    goto LABEL_179;
  }

  unint64_t v13 = 0LL;
  unsigned int v108 = 0;
  uint64_t v125 = 0LL;
  int v123 = 0;
  int v124 = 43962;
  uint64_t v120 = 0x200006ABBALL;
  __int128 v121 = 0u;
  __int128 v122 = 0u;
  *(void *)&uint8_t buf[4] = 184LL;
  *(_DWORD *)std::stringbuf::string_type buf = 371642;
  int v137 = 381;
  __int128 v138 = 0u;
  __int128 v139 = 0u;
  uint64_t v141 = 0LL;
  uint64_t v140 = 0LL;
  int v142 = 0;
  int v115 = 502714;
  __int128 v116 = xmmword_101362CA0;
  uint64_t v117 = 0LL;
  uint64_t v118 = 0LL;
  uint64_t v119 = 0LL;
  while (1)
  {
    while (1)
    {
      uint64_t v14 = v131;
      if (HIWORD(v124) == 7) {
        break;
      }
      if (HIWORD(v124) == 6)
      {
        sub_100C0C158(v130 + v14, (uint64_t)&v120);
        unint64_t v13 = (int8x8_t *)(v14 + v130 + v125 + 12);
        if ((unint64_t)v13 + (DWORD2(v121) * DWORD1(v121)) > v128 + v130)
        {
          if (!*(_BYTE *)(a1 + 392)) {
            goto LABEL_162;
          }
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v53 = (os_log_s *)qword_101934A78;
          if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
          {
            int v54 = DWORD1(v121);
            double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
            LODWORD(v107) = v54;
            sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
            int v55 = v133[9];
            uint64_t v56 = *(_BYTE **)v132;
            sub_100C0BF10((unsigned int *)a2, &v135);
            uint64_t v57 = v132;
            if (v55 < 0) {
              uint64_t v57 = v56;
            }
            double v58 = &v135;
            if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              double v58 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)std::stringbuf::string_type __p = 134284803;
            *(void *)&__p[4] = v13;
            *(_WORD *)&_BYTE __p[12] = 1025;
            *(_DWORD *)uint64_t v144 = (_DWORD)v107;
            *(_WORD *)&v144[4] = 2049;
            *(void *)&v144[6] = v14;
            *(_WORD *)&v144[14] = 2081;
            *(void *)&v144[16] = v106;
            *(_WORD *)&v144[24] = 2081;
            *(void *)&v144[26] = v57;
            *(_WORD *)&v144[34] = 2081;
            v145[0] = v58;
            _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_FAULT,  "TILE: pIndexEntries passes valid mmapped region, pIndexEntries:%{private}lu, numOfEntries:%{private}u, atO ffset:%{private}lld, %{private}s, %{private}s, %{private}s",  __p,  0x3Au);
            if ((v133[9] & 0x80000000) != 0) {
              operator delete(*(void **)v132);
            }
          }

          if (!sub_1002921D0(115, 0)) {
            goto LABEL_162;
          }
          bzero(__p, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v59 = qword_101934A78;
          LODWORD(v107) = DWORD1(v121);
          double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
          sub_100E72C48((uint64_t)buf, &v135);
          int size = (char)v135.__r_.__value_.__s.__size_;
          std::string::size_type v61 = v135.__r_.__value_.__r.__words[0];
          sub_100C0BF10((unsigned int *)a2, &v114);
          uint64_t v62 = &v135;
          if (size < 0) {
            uint64_t v62 = (std::stringbuf::string_type *)v61;
          }
          int v63 = &v114;
          if ((v114.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            int v63 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)int v132 = 134284803;
          *(void *)&v132[4] = v13;
          *(_WORD *)&v132[12] = 1025;
          *(_DWORD *)int v133 = (_DWORD)v107;
          *(_WORD *)&v133[4] = 2049;
          *(void *)&v133[6] = v14;
          *(_WORD *)&v133[14] = 2081;
          *(void *)&v133[16] = v106;
          *(_WORD *)&v133[24] = 2081;
          *(void *)&v133[26] = v62;
          *(_WORD *)&v133[34] = 2081;
          *(void *)int v134 = v63;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v59,  17LL,  "TILE: pIndexEntries passes valid mmapped region, pIndexEntries:%{private}lu, numOfEntries:%{private}u, atOff set:%{private}lld, %{private}s, %{private}s, %{private}s",  v132,  58);
          uint64_t v33 = v64;
          goto LABEL_147;
        }
      }

      else
      {
        if (HIWORD(v124) != 5)
        {
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          int v34 = (os_log_s *)qword_101934A78;
          if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_ERROR))
          {
            std::string::size_type v35 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
            sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
            uint64_t v36 = v133[9] >= 0 ? v132 : *(_BYTE **)v132;
            *(_DWORD *)std::stringbuf::string_type __p = 134218498;
            *(void *)&__p[4] = v14;
            *(_WORD *)&_BYTE __p[12] = 2080;
            *(void *)uint64_t v144 = v35;
            *(_WORD *)&v144[8] = 2080;
            *(void *)&v144[10] = v36;
            _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "TILE: unregconized sectionId, %lld, %s, %s",  __p,  0x20u);
            if ((v133[9] & 0x80000000) != 0) {
              operator delete(*(void **)v132);
            }
          }

          if (!sub_1002921D0(115, 0)) {
            goto LABEL_162;
          }
          bzero(__p, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v37 = qword_101934A78;
          __int16 v38 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
          sub_100E72C48((uint64_t)buf, &v135);
          if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            BOOL v39 = &v135;
          }
          else {
            BOOL v39 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)int v132 = 134218498;
          *(void *)&v132[4] = v14;
          *(_WORD *)&v132[12] = 2080;
          *(void *)int v133 = v38;
          *(_WORD *)&v133[8] = 2080;
          *(void *)&v133[10] = v39;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v37,  16LL,  "TILE: unregconized sectionId, %lld, %s, %s",  v132,  32,  v106);
          uint64_t v33 = v40;
LABEL_147:
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::Key LatLonEntry_CDMA>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_ Type::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v33);
          goto LABEL_221;
        }

        sub_100C0B658(v130 + v14, (uint64_t)buf);
      }
    }

    sub_100C0C158(v130 + v14, (uint64_t)&v115);
    uint64_t v15 = v14 + v130 + v125 + 12;
    if (v15 + (unint64_t)(HIDWORD(v116) * DWORD2(v116)) > v128 + v130)
    {
      if (!*(_BYTE *)(a1 + 392)) {
        goto LABEL_162;
      }
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      int v41 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        int v42 = DWORD2(v116);
        double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
        LODWORD(v107) = v42;
        sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
        int v43 = v133[9];
        uint64_t v44 = *(_BYTE **)v132;
        sub_100C0BF10((unsigned int *)a2, &v135);
        uint64_t v45 = v132;
        if (v43 < 0) {
          uint64_t v45 = v44;
        }
        uint64_t v46 = &v135;
        if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v46 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::stringbuf::string_type __p = 134284803;
        *(void *)&__p[4] = v15;
        *(_WORD *)&_BYTE __p[12] = 1025;
        *(_DWORD *)uint64_t v144 = (_DWORD)v107;
        *(_WORD *)&v144[4] = 2049;
        *(void *)&v144[6] = v14;
        *(_WORD *)&v144[14] = 2081;
        *(void *)&v144[16] = v106;
        *(_WORD *)&v144[24] = 2080;
        *(void *)&v144[26] = v45;
        *(_WORD *)&v144[34] = 2081;
        v145[0] = v46;
        _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "TILE: pDataEntries passes valid mmapped region, pDataEntries:%{private}lu, numOfEntries:%{private}u, atOffset: %{private}lld, %{private}s, %{privat}s, %{private}s",  __p,  0x3Au);
        if ((v133[9] & 0x80000000) != 0) {
          operator delete(*(void **)v132);
        }
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_162;
      }
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v47 = qword_101934A78;
      LODWORD(v107) = DWORD2(v116);
      double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v135);
      int v48 = (char)v135.__r_.__value_.__s.__size_;
      std::string::size_type v49 = v135.__r_.__value_.__r.__words[0];
      sub_100C0BF10((unsigned int *)a2, &v114);
      unint64_t v50 = &v135;
      if (v48 < 0) {
        unint64_t v50 = (std::stringbuf::string_type *)v49;
      }
      __int16 v51 = &v114;
      if ((v114.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int16 v51 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int v132 = 134284803;
      *(void *)&v132[4] = v15;
      *(_WORD *)&v132[12] = 1025;
      *(_DWORD *)int v133 = (_DWORD)v107;
      *(_WORD *)&v133[4] = 2049;
      *(void *)&v133[6] = v14;
      *(_WORD *)&v133[14] = 2081;
      *(void *)&v133[16] = v106;
      *(_WORD *)&v133[24] = 2080;
      *(void *)&v133[26] = v50;
      *(_WORD *)&v133[34] = 2081;
      *(void *)int v134 = v51;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v47,  17LL,  "TILE: pDataEntries passes valid mmapped region, pDataEntries:%{private}lu, numOfEntries:%{private}u, atOffset:%{ private}lld, %{private}s, %{privat}s, %{private}s",  v132,  58);
      uint64_t v33 = v52;
      goto LABEL_147;
    }

    sub_100008390((uint64_t)v6, *v8);
    *(void *)(a1 + 384) = 0LL;
    *(void *)(a1 + 368) = v8;
    const char *v8 = 0LL;
    uint64_t v112 = 0LL;
    int v113 = 0;
    sub_100C0BCB8(&v112, a2);
    unsigned int v110 = DWORD2(v116);
    unsigned int v111 = 0;
    if (!v13)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v65 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_ERROR))
      {
        uint64_t v66 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
        sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)__p);
        uint64_t v67 = v144[9] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)int v132 = 136380931;
        *(void *)&v132[4] = v66;
        *(_WORD *)&v132[12] = 2081;
        *(void *)int v133 = v67;
        _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_ERROR,  "TILE: no index section before entries section, %{private}s, %{private}s",  v132,  0x16u);
        if ((v144[9] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_162;
      }
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v68 = qword_101934A78;
      double v69 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
      if (v133[9] >= 0) {
        int v70 = v132;
      }
      else {
        int v70 = *(_BYTE **)v132;
      }
      LODWORD(v135.__r_.__value_.__l.__data_) = 136380931;
      *(std::string::size_type *)((char *)v135.__r_.__value_.__r.__words + 4) = (std::string::size_type)v69;
      WORD2(v135.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&v135.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v70;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v68,  16LL,  "TILE: no index section before entries section, %{private}s, %{private}s",  &v135,  22);
      uint64_t v33 = v71;
      if ((v133[9] & 0x80000000) != 0) {
        operator delete(*(void **)v132);
      }
      goto LABEL_147;
    }

    BOOL v16 = sub_100E738AC(a1, v13, DWORD1(v121), SDWORD2(v121), &v112, &v111, &v110);
    if (v111 >= DWORD2(v116) || v110 >= DWORD2(v116)) {
      break;
    }
    if (!v16)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      __int16 v72 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(v106) = v111;
        LODWORD(v107) = v110;
        sub_100C0C04C((unsigned int *)&v112, (std::stringbuf::string_type *)v132);
        if (v133[9] >= 0) {
          double v73 = v132;
        }
        else {
          double v73 = *(_BYTE **)v132;
        }
        BOOL v74 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
        sub_100E72C48((uint64_t)buf, &v135);
        if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v75 = &v135;
        }
        else {
          int v75 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::stringbuf::string_type __p = 67175683;
        *(_DWORD *)&__p[4] = (_DWORD)v106;
        *(_WORD *)&__p[8] = 1025;
        *(_DWORD *)&__p[10] = (_DWORD)v107;
        *(_WORD *)uint64_t v144 = 2081;
        *(void *)&v144[2] = v73;
        *(_WORD *)&v144[10] = 2081;
        *(void *)&v144[12] = v74;
        *(_WORD *)&v144[20] = 2081;
        *(void *)&v144[22] = v75;
        _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_DEBUG,  "TILE: not found in index, a, %{private}u, b, %{private}u, %{private}s, %{private}s, %{private}s",  __p,  0x2Cu);
        if ((v133[9] & 0x80000000) != 0) {
          operator delete(*(void **)v132);
        }
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_162;
      }
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      __int16 v107 = (const char *)qword_101934A78;
      unsigned int v99 = v111;
      LODWORD(v106) = v110;
      sub_100C0C04C((unsigned int *)&v112, &v135);
      if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v100 = &v135;
      }
      else {
        uint64_t v100 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
      }
      __int16 v101 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v114);
      if ((v114.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v102 = &v114;
      }
      else {
        uint64_t v102 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int v132 = 67175683;
      *(_DWORD *)&v132[4] = v99;
      *(_WORD *)&v132[8] = 1025;
      *(_DWORD *)&v132[10] = (_DWORD)v106;
      *(_WORD *)int v133 = 2081;
      *(void *)&v133[2] = v100;
      *(_WORD *)&v133[10] = 2081;
      *(void *)&v133[12] = v101;
      *(_WORD *)&v133[20] = 2081;
      *(void *)&v133[22] = v102;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v107,  2LL,  "TILE: not found in index, a, %{private}u, b, %{private}u, %{private}s, %{private}s, %{private}s",  v132,  44);
      uint64_t v33 = v103;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatL onEntry_CDMA>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::Ke yLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v33);
LABEL_221:
      if (v33 != __p) {
        free(v33);
      }
      goto LABEL_162;
    }

    unsigned int v108 = v110 - v111 + 1;
    sub_100E72BC0(v6, (int *)a3, a3);
  }

  if (*(_BYTE *)(a1 + 392))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    unint64_t v18 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      unint64_t v19 = v132;
      sub_100C0C04C((unsigned int *)&v112, (std::stringbuf::string_type *)v132);
      if (v133[9] < 0) {
        unint64_t v19 = *(_BYTE **)v132;
      }
      __int16 v107 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v135);
      int v20 = (char)v135.__r_.__value_.__s.__size_;
      std::string::size_type v21 = v135.__r_.__value_.__r.__words[0];
      unsigned int v22 = v111;
      unsigned int v105 = v110;
      LODWORD(v106) = DWORD2(v116);
      sub_100C0BF10((unsigned int *)a2, &v114);
      uint64_t v23 = &v135;
      if (v20 < 0) {
        uint64_t v23 = (std::stringbuf::string_type *)v21;
      }
      int8x8_t v24 = &v114;
      if ((v114.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int8x8_t v24 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::stringbuf::string_type __p = 136382211;
      *(void *)&__p[4] = v19;
      *(_WORD *)&_BYTE __p[12] = 2081;
      *(void *)uint64_t v144 = v107;
      *(_WORD *)&v144[8] = 2081;
      *(void *)&v144[10] = v23;
      *(_WORD *)&v144[18] = 1025;
      *(_DWORD *)&v144[20] = v22;
      *(_WORD *)&v144[24] = 1025;
      *(_DWORD *)&v144[26] = v105;
      *(_WORD *)&v144[30] = 1025;
      *(_DWORD *)&v144[32] = (_DWORD)v106;
      LOWORD(v145[0]) = 2081;
      *(void *)((char *)v145 + 2) = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "TILE: invalid binary search %{private}s in %{private}s, %{private}s, a:%{private}u, b:%{private}u, max:%{private}u, %{private}s",  __p,  0x3Cu);
      if ((v133[9] & 0x80000000) != 0) {
        operator delete(*(void **)v132);
      }
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      __int16 v107 = (const char *)qword_101934A78;
      uint64_t v25 = &v135;
      sub_100C0C04C((unsigned int *)&v112, &v135);
      if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v25 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
      }
      double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v114);
      int v26 = (char)v114.__r_.__value_.__s.__size_;
      std::string::size_type v27 = v114.__r_.__value_.__r.__words[0];
      unsigned int v28 = v110;
      unsigned int v29 = v111;
      HIDWORD(v104) = DWORD2(v116);
      sub_100C0BF10((unsigned int *)a2, &v109);
      std::string::size_type v30 = &v114;
      if (v26 < 0) {
        std::string::size_type v30 = (std::stringbuf::string_type *)v27;
      }
      int v31 = &v109;
      if ((v109.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v31 = (std::stringbuf::string_type *)v109.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int v132 = 136382211;
      *(void *)&v132[4] = v25;
      *(_WORD *)&v132[12] = 2081;
      *(void *)int v133 = v106;
      *(_WORD *)&v133[8] = 2081;
      *(void *)&v133[10] = v30;
      *(_WORD *)&v133[18] = 1025;
      *(_DWORD *)&v133[20] = v29;
      *(_WORD *)&v133[24] = 1025;
      *(_DWORD *)&v133[26] = v28;
      *(_WORD *)&v133[30] = 1025;
      *(_DWORD *)&v133[32] = HIDWORD(v104);
      *(_WORD *)int v134 = 2081;
      *(void *)&v134[2] = v31;
      LODWORD(v104) = 60;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v107,  17LL,  "TILE: invalid binary search %{private}s in %{private}s, %{private}s, a:%{private}u, b:%{private}u, max:%{private}u, %{private}s",  v132,  v104);
      uint64_t v33 = v32;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatL onEntry_CDMA>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::Ke yLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v33);
      goto LABEL_221;
    }
  }

void sub_100E6DEC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, void *__p, uint64_t a37, int a38, __int16 a39, char a40, char a41)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100E6E008(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  *(void *)(a1 + 334) = *(uint64_t *)((char *)a2 + 6);
  *(void *)(a1 + 328) = v6;
  char v42 = 0;
  nullsub_10(0LL);
  uint64_t v44 = v7;
  int v41 = "search";
  char v43 = 1;
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  unint64_t v8 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BF10((unsigned int *)a2, &__p);
    uint64_t v9 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
       ? &__p
       : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "TILE: getLocationByKey_traverse, key, %s",  (uint8_t *)&buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v24 = qword_101934A78;
    sub_100C0BF10((unsigned int *)a2, &buf);
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_std::stringbuf::string_type buf = &buf;
    }
    else {
      p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v48.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_buf;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v24,  2LL,  "TILE: getLocationByKey_traverse, key, %s",  (const char *)&v48);
    std::string::size_type v27 = v26;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLon Entry_CDMA>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::Ke yLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  (const char *)v27);
    if (v27 != &__p) {
      free(v27);
    }
  }

  sub_100C0FCEC(a1, &v48);
  BOOL v10 = (const char **)(a1 + 8);
  int v11 = (const char *)(a1 + 8);
  if (sub_100292D28(v11))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    clock_t v12 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      std::string::size_type v13 = a1 + 8;
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "TILE: getLocationByKey_traverse, prefer local file name because it exists, %s",  (uint8_t *)&__p,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      std::string::size_type v35 = a1 + 8;
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v35;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: getLocationByKey_traverse, prefer local file name because it exists, %s",  (const char *)&buf);
      uint64_t v37 = (std::stringbuf::string_type *)v36;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatL onEntry_CDMA>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type ::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v36);
      if (v37 != &__p) {
        free(v37);
      }
    }

    std::string::operator=(&v48, (const std::string *)(a1 + 8));
  }

  sub_100C1145C((void *)a1, (uint64_t)&v48, (uint64_t)&v41);
  uint64_t v14 = sub_100E72F04(a1 + 368, (int *)a2);
  uint64_t v15 = v14;
  uint64_t v16 = a1 + 376;
  if (a1 + 376 != v14)
  {
    uint64_t v17 = *(void *)(v14 + 25);
    *(void *)(a3 + 6) = *(void *)(v14 + 31);
    *(void *)a3 = v17;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  unint64_t v18 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BF10((unsigned int *)a2, &buf);
    int size = (char)buf.__r_.__value_.__s.__size_;
    std::string::size_type v20 = buf.__r_.__value_.__r.__words[0];
    sub_100C0BF10((unsigned int *)a3, &v40);
    std::string::size_type v21 = &buf;
    if (size < 0) {
      std::string::size_type v21 = (std::stringbuf::string_type *)v20;
    }
    if ((v40.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unsigned int v22 = &v40;
    }
    else {
      unsigned int v22 = (std::stringbuf::string_type *)v40.__r_.__value_.__r.__words[0];
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 67109890;
    HIDWORD(__p.__r_.__value_.__r.__words[0]) = v16 != v15;
    __p.__r_.__value_.__l.__size_ = 0x820000000000400LL;
    __p.__r_.__value_.__l.__cap_ = (std::string::size_type)v21;
    __int16 v50 = 2080;
    __int16 v51 = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "TILE: getLocationByKey_traverse, isFound, %d, searchedArea, %u, key, %s, entry, %s",  (uint8_t *)&__p,  0x22u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v28 = qword_101934A78;
    sub_100C0BF10((unsigned int *)a2, &v40);
    int v29 = (char)v40.__r_.__value_.__s.__size_;
    std::string::size_type v30 = v40.__r_.__value_.__r.__words[0];
    sub_100C0BF10((unsigned int *)a3, &v39);
    int v31 = &v40;
    if (v29 < 0) {
      int v31 = (std::stringbuf::string_type *)v30;
    }
    if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v32 = &v39;
    }
    else {
      __int128 v32 = (std::stringbuf::string_type *)v39.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109890;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v16 != v15;
    buf.__r_.__value_.__l.__size_ = 0x820000000000400LL;
    buf.__r_.__value_.__l.__cap_ = (std::string::size_type)v31;
    __int16 v46 = 2080;
    uint64_t v47 = v32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v28,  2LL,  "TILE: getLocationByKey_traverse, isFound, %d, searchedArea, %u, key, %s, entry, %s",  &buf,  34,  v38,  v39.__r_.__value_.__l.__data_);
    int v34 = v33;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLon Entry_CDMA>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::Ke yLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  (const char *)v34);
    if (v34 != &__p) {
      free(v34);
    }
  }

  (*(void (**)(uint64_t))(*(void *)a1 + 104LL))(a1);
  return v16 != v15;
}

void sub_100E6E6C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, void *__p, uint64_t a34, int a35, __int16 a36, char a37, char a38)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E6E72C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E71E34(a1);
  operator delete(v1);
}

uint64_t sub_100E6E740(uint64_t a1, std::string::value_type *a2)
{
  double Current = CFAbsoluteTimeGetCurrent();
  sub_100C0FAA0(a1, a2);
  sub_100C124C8((uint64_t *)a1, "", a2, *(_DWORD *)(a1 + 48), 0, Current);
  sub_100E73A1C((uint64_t *)&v50, a1 + 368);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  uint64_t v5 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 134218242;
    *(void *)std::string::size_type v61 = v52;
    *(_WORD *)&v61[8] = 2080;
    *(void *)&v61[10] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "TILE: result: tilestool: TEST_testBinarySearch, entries, %lu, file, %s",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    *(_DWORD *)std::stringbuf::string_type __p = 134218242;
    *(void *)&__p[4] = v52;
    *(_WORD *)&_BYTE __p[12] = 2080;
    *(void *)&_BYTE __p[14] = a2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: result: tilestool: TEST_testBinarySearch, entries, %lu, file, %s",  __p,  22);
    uint64_t v37 = (uint8_t *)v36;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonE ntry_LTE>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_LTE, DataE ntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v36);
    if (v37 != buf) {
      free(v37);
    }
  }

  uint64_t v6 = a1 + 376;
  sub_100008390(a1 + 368, *(void **)(a1 + 376));
  *(void *)(a1 + 376) = 0LL;
  *(void *)(a1 + 384) = 0LL;
  *(void *)(a1 + 368) = a1 + 376;
  unint64_t v8 = v50;
  char v43 = (const char *)&v51;
  if (v50 != (const char *)&v51)
  {
    uint64_t v9 = 0LL;
    *(void *)&__int128 v7 = 134219266LL;
    __int128 v41 = v7;
    while (1)
    {
      *(void *)std::string::size_type v49 = *(void *)(v8 + 25);
      *(void *)((char *)&v49[1] + 2) = *(void *)(v8 + 31);
      memset(v48, 0, 14);
      uint64_t v46 = 0LL;
      memset(v47, 0, 14);
      uint64_t v45 = 0LL;
      sub_100008390(a1 + 368, *(void **)(a1 + 376));
      *(void *)(a1 + 376) = 0LL;
      *(void *)(a1 + 384) = 0LL;
      *(void *)(a1 + 368) = v6;
      clock_t v10 = clock();
      int v11 = (*(uint64_t (**)(uint64_t, unsigned int *, void *))(*(void *)a1 + 192LL))(a1, v49, v48);
      clock_t v12 = clock();
      sub_100008390(a1 + 368, *(void **)(a1 + 376));
      *(void *)(a1 + 376) = 0LL;
      *(void *)(a1 + 384) = 0LL;
      *(void *)(a1 + 368) = v6;
      clock_t v13 = clock();
      int v14 = (*(uint64_t (**)(uint64_t, unsigned int *, _WORD *))(*(void *)a1 + 184LL))(a1, v49, v47);
      clock_t v15 = clock();
      printf("tilestool: mmap, %lu, file, %lu\n", v15 - v13, v12 - v10);
      if (v11 != v14) {
        break;
      }
      int v16 = (*(uint64_t (**)(uint64_t, unsigned int *, void *))(*(void *)a1 + 176LL))(a1, v49, v48);
      if (v16) {
        sub_100C13C70(a1, LOWORD(v48[1]), WORD1(v48[1]), (double *)&v46, (double *)&v45);
      }
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v17 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v18 = v52;
        uint64_t v19 = v45;
        uint64_t v20 = v46;
        sub_100C0BCC8(v49, (std::stringbuf::string_type *)__p);
        std::string::size_type v21 = __p;
        if (__p[23] < 0) {
          std::string::size_type v21 = *(_BYTE **)__p;
        }
        *(_DWORD *)std::stringbuf::string_type buf = v41;
        *(void *)std::string::size_type v61 = v9;
        *(_WORD *)&v61[8] = 2048;
        *(void *)&v61[10] = v18;
        *(_WORD *)&v61[18] = 1024;
        *(_DWORD *)&v61[20] = v16;
        __int16 v62 = 2048;
        uint64_t v63 = v20;
        __int16 v64 = 2048;
        uint64_t v65 = v19;
        __int16 v66 = 2080;
        uint64_t v67 = v21;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEBUG,  "TILE: result: tilestool: prog, %3lu, %3lu, ===============> isFound, %d, location, %14.8lf, %14.8lf, entry, %s",  buf,  0x3Au);
        if ((__p[23] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888E80);
        }
        uint64_t v25 = qword_101934A78;
        uint64_t v26 = v52;
        uint64_t v27 = v45;
        uint64_t v28 = v46;
        sub_100C0BCC8(v49, &v44);
        int v29 = &v44;
        if ((v44.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          int v29 = (std::stringbuf::string_type *)v44.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::stringbuf::string_type __p = v41;
        *(void *)&__p[4] = v9;
        *(_WORD *)&_BYTE __p[12] = 2048;
        *(void *)&_BYTE __p[14] = v26;
        *(_WORD *)&__p[22] = 1024;
        *(_DWORD *)&__p[24] = v16;
        __int16 v54 = 2048;
        uint64_t v55 = v28;
        __int16 v56 = 2048;
        uint64_t v57 = v27;
        __int16 v58 = 2080;
        uint64_t v59 = v29;
        LODWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 58;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v25,  2LL,  "TILE: result: tilestool: prog, %3lu, %3lu, ===============> isFound, %d, location, %14.8lf, %14.8lf, entry, %s",  __p,  v40,  (_DWORD)v41,  *((double *)&v41 + 1),  v42,  v43);
        int v31 = v30;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLat LonEntry_LTE>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_LT E, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v31);
      }

      if (!v16)
      {
        int v34 = 759;
        std::string::size_type v35 = "isFound";
LABEL_44:
        __assert_rtn("TEST_testBinarySearch", "CLKeyLatLonTileTemplate.h", v34, v35);
      }

      unsigned int v22 = (const char *)*((void *)v8 + 1);
      if (v22)
      {
        do
        {
          uint64_t v23 = v22;
          unsigned int v22 = *(const char **)v22;
        }

        while (v22);
      }

      else
      {
        do
        {
          uint64_t v23 = (const char *)*((void *)v8 + 2);
          BOOL v24 = *(void *)v23 == (void)v8;
          unint64_t v8 = v23;
        }

        while (!v24);
      }

      ++v9;
      unint64_t v8 = v23;
      if (v23 == v43) {
        goto LABEL_36;
      }
    }

    int v34 = 742;
    std::string::size_type v35 = "isFound == isFoundMmap";
    goto LABEL_44;
  }

  uint64_t v9 = 0LL;
LABEL_36:
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  __int128 v32 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 67109632;
    *(_DWORD *)std::string::size_type v61 = 1;
    *(_WORD *)&v61[4] = 2048;
    *(void *)&v61[6] = v9;
    *(_WORD *)&v61[14] = 2048;
    *(void *)&v61[16] = v52;
    _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEBUG,  "TILE: result: tilestool: pass, %d, tests, %lu, %lu",  buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    *(void *)std::stringbuf::string_type __p = 0x104000300LL;
    *(_WORD *)&__p[8] = 2048;
    *(void *)&__p[10] = v9;
    *(_WORD *)&__p[18] = 2048;
    *(void *)&_BYTE __p[20] = v52;
    LODWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: result: tilestool: pass, %d, tests, %lu, %lu",  __p,  v40,  (void)v41);
    std::stringbuf::string_type v39 = (uint8_t *)v38;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonE ntry_LTE>::TEST_testBinarySearch(const char *) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_LTE, DataE ntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v38);
    if (v39 != buf) {
      free(v39);
    }
  }

  sub_100008390((uint64_t)&v50, v51);
  return 1LL;
}

void sub_100E6EEF8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, void *a27)
{
}

void sub_100E6EF4C(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = a1;
  sub_10059826C(a1, (uint64_t)a2, a3);
  uint64_t v98 = 0LL;
  int v10 = *(unsigned __int16 *)(a3 + 2);
  if (v10 != 7)
  {
    if (v10 == 6)
    {
      *(void *)unsigned int v99 = 0x200006ABBALL;
      memset(&v99[8], 0, 32);
      LODWORD(v10sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
      sub_100C0C158(a4, (uint64_t)v99);
      int v11 = (void *)(v9 + 344);
      *(void *)(v9 + 352) = *(void *)(v9 + 344);
      sub_100E72208((char **)(v9 + 344), *(unsigned int *)&v99[12]);
      clock_t v12 = (char *)sub_100599BF4(v9, a2, a3, 0, *(int *)&v99[12], *(int *)&v99[16]);
      if (v12)
      {
        v96[0] = 0LL;
        v96[1].i32[0] = 0;
        if (*(_DWORD *)&v99[12])
        {
          unint64_t v13 = 0LL;
          do
          {
            sub_100C0BB90((int8x8_t *)&v12[v13 * *(unsigned int *)&v99[16]], v96);
            clock_t v15 = *(int8x8_t **)(v9 + 352);
            unint64_t v14 = *(void *)(v9 + 360);
            if ((unint64_t)v15 >= v14)
            {
              unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v15 - *v11) >> 2);
              unint64_t v19 = v18 + 1;
              if (v18 + 1 > 0x1555555555555555LL) {
                sub_100007008();
              }
              unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - *v11) >> 2);
              if (2 * v20 > v19) {
                unint64_t v19 = 2 * v20;
              }
              if (v20 >= 0xAAAAAAAAAAAAAAALL) {
                unint64_t v21 = 0x1555555555555555LL;
              }
              else {
                unint64_t v21 = v19;
              }
              if (v21) {
                unsigned int v22 = (char *)sub_1005AADE4(v9 + 360, v21);
              }
              else {
                unsigned int v22 = 0LL;
              }
              uint64_t v23 = (int8x8_t *)&v22[12 * v18];
              int8x8_t v24 = v96[0];
              v23[1].i32[0] = v96[1].i32[0];
              int8x8_t *v23 = v24;
              uint64_t v26 = *(_DWORD **)(v9 + 344);
              uint64_t v25 = *(_DWORD **)(v9 + 352);
              uint64_t v27 = v23;
              if (v25 != v26)
              {
                do
                {
                  int8x8_t v28 = *(int8x8_t *)(v25 - 3);
                  v25 -= 3;
                  __int32 v29 = v25[2];
                  *(int8x8_t *)((char *)v27 - 12) = v28;
                  uint64_t v27 = (int8x8_t *)((char *)v27 - 12);
                  v27[1].i32[0] = v29;
                }

                while (v25 != v26);
                uint64_t v25 = (_DWORD *)*v11;
              }

              uint64_t v17 = (char *)&v23[1] + 4;
              *(void *)(v9 + 344) = v27;
              *(void *)(v9 + 352) = (char *)v23 + 12;
              *(void *)(v9 + 36sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = &v22[12 * v21];
              if (v25) {
                operator delete(v25);
              }
            }

            else
            {
              int8x8_t v16 = v96[0];
              v15[1].i32[0] = v96[1].i32[0];
              int8x8_t *v15 = v16;
              uint64_t v17 = (char *)&v15[1] + 4;
            }

            *(void *)(v9 + 352) = v17;
            if (!*(_BYTE *)(a5 + 9))
            {
              if (qword_101934A70 != -1) {
                dispatch_once(&qword_101934A70, &stru_101888E80);
              }
              std::string::size_type v30 = (os_log_s *)qword_101934A78;
              if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
              {
                int v31 = *(_DWORD *)&v99[12];
                sub_100C0BE04((unsigned int *)v96, (std::stringbuf::string_type *)__p);
                __int128 v32 = __p;
                if (SBYTE3(v112) < 0) {
                  __int128 v32 = *(_BYTE **)__p;
                }
                *(_DWORD *)std::stringbuf::string_type buf = 134218498;
                *(void *)__int128 v116 = v13;
                *(_WORD *)&v116[8] = 1024;
                *(_DWORD *)uint64_t v117 = v31;
                *(_WORD *)&v117[4] = 2080;
                *(void *)&v117[6] = v32;
                _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEBUG,  "TILE: index entry, %3lu, %3u, %s",  buf,  0x1Cu);
                if (SBYTE3(v112) < 0) {
                  operator delete(*(void **)__p);
                }
              }

              if (sub_1002921D0(115, 2))
              {
                bzero(buf, 0x65CuLL);
                if (qword_101934A70 != -1) {
                  dispatch_once(&qword_101934A70, &stru_101888E80);
                }
                uint64_t v33 = qword_101934A78;
                int v34 = *(_DWORD *)&v99[12];
                sub_100C0BE04((unsigned int *)v96, &v97);
                std::string::size_type v35 = &v97;
                if ((v97.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  std::string::size_type v35 = (std::stringbuf::string_type *)v97.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)std::stringbuf::string_type __p = 134218498;
                *(void *)&__p[4] = v13;
                *(_WORD *)&_BYTE __p[12] = 1024;
                *(_DWORD *)&_BYTE __p[14] = v34;
                *(_WORD *)&__p[18] = 2080;
                uint64_t v112 = v35;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v33,  2LL,  "TILE: index entry, %3lu, %3u, %s",  __p,  28,  v88);
                uint64_t v37 = v36;
                sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type ::KeyLatLonEntry_LTE>::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const v oid *, const CLTileFile::TraverseDetails &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_L TE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v37);
              }
            }

            ++v13;
          }

          while (v13 < *(unsigned int *)&v99[12]);
        }
      }

      goto LABEL_82;
    }

    unsigned int v47 = 0;
    goto LABEL_57;
  }

  *(_DWORD *)std::stringbuf::string_type __p = 502714;
  *(_OWORD *)&__p[4] = xmmword_101362CA0;
  uint64_t v112 = 0LL;
  uint64_t v114 = 0LL;
  uint64_t v113 = 0LL;
  sub_100C0C158(a4, (uint64_t)__p);
  __int16 v38 = (uint64_t **)(v9 + 368);
  sub_100008390(v9 + 368, *(void **)(v9 + 376));
  *(void *)(v9 + 376) = 0LL;
  *(void *)(v9 + 384) = 0LL;
  *(void *)(v9 + 368) = v9 + 376;
  double v93 = *(double *)&v9;
  if (!*(_BYTE *)(a5 + 9))
  {
    memset(v96, 0, 14);
    std::string v48 = (const char *)sub_100599BF4(v9, a2, a3, 0, *(int *)&__p[12], *(int *)&__p[16]);
    clock_t v12 = (char *)v48;
    if (!v48)
    {
LABEL_82:
      unsigned int v47 = 0;
      goto LABEL_83;
    }

    if (*(_DWORD *)&__p[12])
    {
      unint64_t v50 = 0LL;
      *(void *)&__int128 v49 = 134220290LL;
      __int128 v91 = v49;
      int v90 = v48;
      do
      {
        sub_100C0BA1C((int8x8_t *)&v12[v50 * *(unsigned int *)&__p[16]], v96);
        sub_100E72BC0(v38, (int *)v96, (uint64_t *)v96);
        uint64_t v94 = 0LL;
        uint64_t v95 = 0LL;
        sub_100C13C70(v9, v96[1].u16[0], v96[1].u16[1], (double *)&v95, (double *)&v94);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_101888E80);
        }
        __int16 v51 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          int v52 = *(_DWORD *)&__p[12];
          uint64_t v53 = *(void *)(v9 + 384);
          sub_100C0BCC8((unsigned int *)v96, (std::stringbuf::string_type *)v99);
          __int16 v54 = v38;
          if (v99[23] >= 0) {
            uint64_t v55 = v99;
          }
          else {
            uint64_t v55 = *(_BYTE **)v99;
          }
          uint64_t v56 = v94;
          uint64_t v57 = v95;
          double v58 = (*(double (**)(uint64_t))(*(void *)v9 + 56LL))(v9);
          double v59 = (*(double (**)(uint64_t))(*(void *)v9 + 64LL))(v9);
          int v60 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 80LL))(v9);
          int v61 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 72LL))(v9);
          *(_DWORD *)std::stringbuf::string_type buf = v91;
          *(void *)__int128 v116 = v50;
          *(_WORD *)&v116[8] = 1024;
          *(_DWORD *)uint64_t v117 = v52;
          *(_WORD *)&v117[4] = 2048;
          *(void *)&v117[6] = v53;
          __int16 v118 = 2080;
          uint64_t v119 = v55;
          __int16 v120 = 2048;
          uint64_t v121 = v57;
          __int16 v122 = 2048;
          uint64_t v123 = v56;
          __int16 v124 = 2048;
          double v125 = v58;
          __int16 v126 = 2048;
          double v127 = v59;
          __int16 v128 = 1024;
          int v129 = v60;
          __int16 v130 = 1024;
          int v131 = v61;
          _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEBUG,  "TILE: entry, %3lu, %3u, %3lu, %s, loc, %.8lf, %.8lf, delta, %.5lf, %.5lf, grid, %u, %u",  buf,  0x5Au);
          if ((v99[23] & 0x80000000) != 0) {
            operator delete(*(void **)v99);
          }
          __int16 v38 = v54;
          clock_t v12 = (char *)v90;
          *(double *)&uint64_t v9 = v93;
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v62 = qword_101934A78;
          int v63 = *(_DWORD *)&__p[12];
          uint64_t v64 = *(void *)(v9 + 384);
          sub_100C0BCC8((unsigned int *)v96, &v97);
          int v89 = v38;
          if ((v97.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            uint64_t v65 = &v97;
          }
          else {
            uint64_t v65 = (std::stringbuf::string_type *)v97.__r_.__value_.__r.__words[0];
          }
          uint64_t v66 = v94;
          uint64_t v67 = v95;
          double v68 = (*(double (**)(uint64_t))(*(void *)v9 + 56LL))(v9);
          double v69 = (*(double (**)(uint64_t))(*(void *)v9 + 64LL))(v9);
          int v70 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 80LL))(v9);
          int v71 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 72LL))(v9);
          *(_DWORD *)unsigned int v99 = v91;
          *(void *)&v99[4] = v50;
          *(_WORD *)&v99[12] = 1024;
          *(_DWORD *)&v99[14] = v63;
          *(_WORD *)&v99[18] = 2048;
          *(void *)&v99[20] = v64;
          *(_WORD *)&v99[28] = 2080;
          *(void *)&v99[30] = v65;
          *(_WORD *)&v99[38] = 2048;
          uint64_t v100 = v67;
          __int16 v101 = 2048;
          uint64_t v102 = v66;
          __int16 v103 = 2048;
          double v104 = v68;
          __int16 v105 = 2048;
          double v106 = v69;
          __int16 v107 = 1024;
          int v108 = v70;
          __int16 v109 = 1024;
          int v110 = v71;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v62,  2LL,  "TILE: entry, %3lu, %3u, %3lu, %s, loc, %.8lf, %.8lf, delta, %.5lf, %.5lf, grid, %u, %u",  v99,  90,  v89,  v90,  *(double *)&v91,  *((double *)&v91 + 1),  v92,  v93,  v94,  v95);
          double v73 = v72;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyL atLonEntry_LTE>::onTraversingSection(FILE *, const CLTilesManager_Type::SectionHeader &, const void *, const CLTileFile::TraverseDetails &) [IndexEntry_T = CLTilesManager_Type::KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v73);
          __int16 v38 = (uint64_t **)v88;
        }

        ++v50;
      }

      while (v50 < *(unsigned int *)&__p[12]);
    }

void sub_100E6FD4C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E6FD84(uint64_t a1, int *a2, void *a3)
{
  uint64_t v6 = (uint64_t **)(a1 + 368);
  uint64_t v7 = sub_100E72F04(a1 + 368, a2);
  unint64_t v8 = (void **)v7;
  if (a1 + 376 != v7)
  {
    uint64_t v9 = *(void *)(v7 + 25);
    *(void *)((char *)a3 + 6) = *(void *)(v7 + 31);
    *a3 = v9;
    return 1LL;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  int v11 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BCC8((unsigned int *)a2, (std::stringbuf::string_type *)__p);
    clock_t v12 = v144[9] >= 0 ? __p : *(_BYTE **)__p;
    *(_DWORD *)std::stringbuf::string_type buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "TILE:  getLocationByKey_mmap, key, %s",  buf,  0xCu);
    if ((v144[9] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v85 = qword_101934A78;
    sub_100C0BCC8((unsigned int *)a2, (std::stringbuf::string_type *)buf);
    if ((SBYTE7(v138) & 0x80u) == 0) {
      __int16 v86 = buf;
    }
    else {
      __int16 v86 = *(_BYTE **)buf;
    }
    *(_DWORD *)int v132 = 136315138;
    *(void *)&v132[4] = v86;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v85,  2LL,  "TILE:  getLocationByKey_mmap, key, %s",  v132);
    unsigned int v88 = v87;
    if (SBYTE7(v138) < 0) {
      operator delete(*(void **)buf);
    }
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonE ntry_LTE>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLo nIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v88);
    if (v88 != __p) {
      free(v88);
    }
  }

  *(void *)(a1 + 352) = *(void *)(a1 + 344);
  sub_1010DDBC0(v126, "");
  uint64_t v128 = 0LL;
  int v129 = -1;
  uint64_t v130 = 0LL;
  uint64_t v131 = 0LL;
  if ((sub_100596978(a1, (uint64_t)v126) & 1) == 0)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v17 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::stringbuf::string_type __p = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "TILE: getLocationByKey_mmap, failed to mmap, #CloneMe",  __p,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_101934A78,  16LL,  "TILE: getLocationByKey_mmap, failed to mmap, #CloneMe",  buf,  2);
      int v90 = (char *)v89;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLo nEntry_LTE>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyL atLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v89);
      if (v90 != __p) {
        free(v90);
      }
    }

    BOOL v10 = 0LL;
    goto LABEL_179;
  }

  unint64_t v13 = 0LL;
  unsigned int v108 = 0;
  uint64_t v125 = 0LL;
  int v123 = 0;
  int v124 = 43962;
  uint64_t v120 = 0x200006ABBALL;
  __int128 v121 = 0u;
  __int128 v122 = 0u;
  *(void *)&uint8_t buf[4] = 184LL;
  *(_DWORD *)std::stringbuf::string_type buf = 371642;
  int v137 = 381;
  __int128 v138 = 0u;
  __int128 v139 = 0u;
  uint64_t v141 = 0LL;
  uint64_t v140 = 0LL;
  int v142 = 0;
  int v115 = 502714;
  __int128 v116 = xmmword_101362CA0;
  uint64_t v117 = 0LL;
  uint64_t v118 = 0LL;
  uint64_t v119 = 0LL;
  while (1)
  {
    while (1)
    {
      uint64_t v14 = v131;
      if (HIWORD(v124) == 7) {
        break;
      }
      if (HIWORD(v124) == 6)
      {
        sub_100C0C158(v130 + v14, (uint64_t)&v120);
        unint64_t v13 = (int8x8_t *)(v14 + v130 + v125 + 12);
        if ((unint64_t)v13 + (DWORD2(v121) * DWORD1(v121)) > v128 + v130)
        {
          if (!*(_BYTE *)(a1 + 392)) {
            goto LABEL_162;
          }
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v53 = (os_log_s *)qword_101934A78;
          if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
          {
            int v54 = DWORD1(v121);
            double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
            LODWORD(v107) = v54;
            sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
            int v55 = v133[9];
            uint64_t v56 = *(_BYTE **)v132;
            sub_100C0BCC8((unsigned int *)a2, &v135);
            uint64_t v57 = v132;
            if (v55 < 0) {
              uint64_t v57 = v56;
            }
            double v58 = &v135;
            if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              double v58 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
            }
            *(_DWORD *)std::stringbuf::string_type __p = 134284803;
            *(void *)&__p[4] = v13;
            *(_WORD *)&_BYTE __p[12] = 1025;
            *(_DWORD *)uint64_t v144 = (_DWORD)v107;
            *(_WORD *)&v144[4] = 2049;
            *(void *)&v144[6] = v14;
            *(_WORD *)&v144[14] = 2081;
            *(void *)&v144[16] = v106;
            *(_WORD *)&v144[24] = 2081;
            *(void *)&v144[26] = v57;
            *(_WORD *)&v144[34] = 2081;
            v145[0] = v58;
            _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_FAULT,  "TILE: pIndexEntries passes valid mmapped region, pIndexEntries:%{private}lu, numOfEntries:%{private}u, atO ffset:%{private}lld, %{private}s, %{private}s, %{private}s",  __p,  0x3Au);
            if ((v133[9] & 0x80000000) != 0) {
              operator delete(*(void **)v132);
            }
          }

          if (!sub_1002921D0(115, 0)) {
            goto LABEL_162;
          }
          bzero(__p, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v59 = qword_101934A78;
          LODWORD(v107) = DWORD1(v121);
          double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
          sub_100E72C48((uint64_t)buf, &v135);
          int size = (char)v135.__r_.__value_.__s.__size_;
          std::string::size_type v61 = v135.__r_.__value_.__r.__words[0];
          sub_100C0BCC8((unsigned int *)a2, &v114);
          uint64_t v62 = &v135;
          if (size < 0) {
            uint64_t v62 = (std::stringbuf::string_type *)v61;
          }
          int v63 = &v114;
          if ((v114.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            int v63 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)int v132 = 134284803;
          *(void *)&v132[4] = v13;
          *(_WORD *)&v132[12] = 1025;
          *(_DWORD *)int v133 = (_DWORD)v107;
          *(_WORD *)&v133[4] = 2049;
          *(void *)&v133[6] = v14;
          *(_WORD *)&v133[14] = 2081;
          *(void *)&v133[16] = v106;
          *(_WORD *)&v133[24] = 2081;
          *(void *)&v133[26] = v62;
          *(_WORD *)&v133[34] = 2081;
          *(void *)int v134 = v63;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v59,  17LL,  "TILE: pIndexEntries passes valid mmapped region, pIndexEntries:%{private}lu, numOfEntries:%{private}u, atOff set:%{private}lld, %{private}s, %{private}s, %{private}s",  v132,  58);
          uint64_t v33 = v64;
          goto LABEL_147;
        }
      }

      else
      {
        if (HIWORD(v124) != 5)
        {
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          int v34 = (os_log_s *)qword_101934A78;
          if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_ERROR))
          {
            std::string::size_type v35 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
            sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
            uint64_t v36 = v133[9] >= 0 ? v132 : *(_BYTE **)v132;
            *(_DWORD *)std::stringbuf::string_type __p = 134218498;
            *(void *)&__p[4] = v14;
            *(_WORD *)&_BYTE __p[12] = 2080;
            *(void *)uint64_t v144 = v35;
            *(_WORD *)&v144[8] = 2080;
            *(void *)&v144[10] = v36;
            _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "TILE: unregconized sectionId, %lld, %s, %s",  __p,  0x20u);
            if ((v133[9] & 0x80000000) != 0) {
              operator delete(*(void **)v132);
            }
          }

          if (!sub_1002921D0(115, 0)) {
            goto LABEL_162;
          }
          bzero(__p, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_101888E80);
          }
          uint64_t v37 = qword_101934A78;
          __int16 v38 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
          sub_100E72C48((uint64_t)buf, &v135);
          if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            BOOL v39 = &v135;
          }
          else {
            BOOL v39 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
          }
          *(_DWORD *)int v132 = 134218498;
          *(void *)&v132[4] = v14;
          *(_WORD *)&v132[12] = 2080;
          *(void *)int v133 = v38;
          *(_WORD *)&v133[8] = 2080;
          *(void *)&v133[10] = v39;
          _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v37,  16LL,  "TILE: unregconized sectionId, %lld, %s, %s",  v132,  32,  v106);
          uint64_t v33 = v40;
LABEL_147:
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyL atLonEntry_LTE>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Ty pe::KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v33);
          goto LABEL_221;
        }

        sub_100C0B658(v130 + v14, (uint64_t)buf);
      }
    }

    sub_100C0C158(v130 + v14, (uint64_t)&v115);
    uint64_t v15 = v14 + v130 + v125 + 12;
    if (v15 + (unint64_t)(HIDWORD(v116) * DWORD2(v116)) > v128 + v130)
    {
      if (!*(_BYTE *)(a1 + 392)) {
        goto LABEL_162;
      }
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      int v41 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
      {
        int v42 = DWORD2(v116);
        double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
        LODWORD(v107) = v42;
        sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
        int v43 = v133[9];
        uint64_t v44 = *(_BYTE **)v132;
        sub_100C0BCC8((unsigned int *)a2, &v135);
        uint64_t v45 = v132;
        if (v43 < 0) {
          uint64_t v45 = v44;
        }
        uint64_t v46 = &v135;
        if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          uint64_t v46 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::stringbuf::string_type __p = 134284803;
        *(void *)&__p[4] = v15;
        *(_WORD *)&_BYTE __p[12] = 1025;
        *(_DWORD *)uint64_t v144 = (_DWORD)v107;
        *(_WORD *)&v144[4] = 2049;
        *(void *)&v144[6] = v14;
        *(_WORD *)&v144[14] = 2081;
        *(void *)&v144[16] = v106;
        *(_WORD *)&v144[24] = 2080;
        *(void *)&v144[26] = v45;
        *(_WORD *)&v144[34] = 2081;
        v145[0] = v46;
        _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_FAULT,  "TILE: pDataEntries passes valid mmapped region, pDataEntries:%{private}lu, numOfEntries:%{private}u, atOffset: %{private}lld, %{private}s, %{privat}s, %{private}s",  __p,  0x3Au);
        if ((v133[9] & 0x80000000) != 0) {
          operator delete(*(void **)v132);
        }
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_162;
      }
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v47 = qword_101934A78;
      LODWORD(v107) = DWORD2(v116);
      double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v135);
      int v48 = (char)v135.__r_.__value_.__s.__size_;
      std::string::size_type v49 = v135.__r_.__value_.__r.__words[0];
      sub_100C0BCC8((unsigned int *)a2, &v114);
      unint64_t v50 = &v135;
      if (v48 < 0) {
        unint64_t v50 = (std::stringbuf::string_type *)v49;
      }
      __int16 v51 = &v114;
      if ((v114.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int16 v51 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int v132 = 134284803;
      *(void *)&v132[4] = v15;
      *(_WORD *)&v132[12] = 1025;
      *(_DWORD *)int v133 = (_DWORD)v107;
      *(_WORD *)&v133[4] = 2049;
      *(void *)&v133[6] = v14;
      *(_WORD *)&v133[14] = 2081;
      *(void *)&v133[16] = v106;
      *(_WORD *)&v133[24] = 2080;
      *(void *)&v133[26] = v50;
      *(_WORD *)&v133[34] = 2081;
      *(void *)int v134 = v51;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v47,  17LL,  "TILE: pDataEntries passes valid mmapped region, pDataEntries:%{private}lu, numOfEntries:%{private}u, atOffset:%{ private}lld, %{private}s, %{privat}s, %{private}s",  v132,  58);
      uint64_t v33 = v52;
      goto LABEL_147;
    }

    sub_100008390((uint64_t)v6, *v8);
    *(void *)(a1 + 384) = 0LL;
    *(void *)(a1 + 368) = v8;
    const char *v8 = 0LL;
    uint64_t v112 = 0LL;
    int v113 = 0;
    sub_100C0BCB8(&v112, a2);
    unsigned int v110 = DWORD2(v116);
    unsigned int v111 = 0;
    if (!v13)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v65 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_ERROR))
      {
        uint64_t v66 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
        sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)__p);
        uint64_t v67 = v144[9] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)int v132 = 136380931;
        *(void *)&v132[4] = v66;
        *(_WORD *)&v132[12] = 2081;
        *(void *)int v133 = v67;
        _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_ERROR,  "TILE: no index section before entries section, %{private}s, %{private}s",  v132,  0x16u);
        if ((v144[9] & 0x80000000) != 0) {
          operator delete(*(void **)__p);
        }
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_162;
      }
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v68 = qword_101934A78;
      double v69 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, (std::stringbuf::string_type *)v132);
      if (v133[9] >= 0) {
        int v70 = v132;
      }
      else {
        int v70 = *(_BYTE **)v132;
      }
      LODWORD(v135.__r_.__value_.__l.__data_) = 136380931;
      *(std::string::size_type *)((char *)v135.__r_.__value_.__r.__words + 4) = (std::string::size_type)v69;
      WORD2(v135.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&v135.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v70;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v68,  16LL,  "TILE: no index section before entries section, %{private}s, %{private}s",  &v135,  22);
      uint64_t v33 = v71;
      if ((v133[9] & 0x80000000) != 0) {
        operator delete(*(void **)v132);
      }
      goto LABEL_147;
    }

    BOOL v16 = sub_100E738AC(a1, v13, DWORD1(v121), SDWORD2(v121), &v112, &v111, &v110);
    if (v111 >= DWORD2(v116) || v110 >= DWORD2(v116)) {
      break;
    }
    if (!v16)
    {
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      __int16 v72 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(v106) = v111;
        LODWORD(v107) = v110;
        sub_100C0BE04((unsigned int *)&v112, (std::stringbuf::string_type *)v132);
        if (v133[9] >= 0) {
          double v73 = v132;
        }
        else {
          double v73 = *(_BYTE **)v132;
        }
        BOOL v74 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
        sub_100E72C48((uint64_t)buf, &v135);
        if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          int v75 = &v135;
        }
        else {
          int v75 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)std::stringbuf::string_type __p = 67175683;
        *(_DWORD *)&__p[4] = (_DWORD)v106;
        *(_WORD *)&__p[8] = 1025;
        *(_DWORD *)&__p[10] = (_DWORD)v107;
        *(_WORD *)uint64_t v144 = 2081;
        *(void *)&v144[2] = v73;
        *(_WORD *)&v144[10] = 2081;
        *(void *)&v144[12] = v74;
        *(_WORD *)&v144[20] = 2081;
        *(void *)&v144[22] = v75;
        _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_DEBUG,  "TILE: not found in index, a, %{private}u, b, %{private}u, %{private}s, %{private}s, %{private}s",  __p,  0x2Cu);
        if ((v133[9] & 0x80000000) != 0) {
          operator delete(*(void **)v132);
        }
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_162;
      }
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      __int16 v107 = (const char *)qword_101934A78;
      unsigned int v99 = v111;
      LODWORD(v106) = v110;
      sub_100C0BE04((unsigned int *)&v112, &v135);
      if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v100 = &v135;
      }
      else {
        uint64_t v100 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
      }
      __int16 v101 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v114);
      if ((v114.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v102 = &v114;
      }
      else {
        uint64_t v102 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int v132 = 67175683;
      *(_DWORD *)&v132[4] = v99;
      *(_WORD *)&v132[8] = 1025;
      *(_DWORD *)&v132[10] = (_DWORD)v106;
      *(_WORD *)int v133 = 2081;
      *(void *)&v133[2] = v100;
      *(_WORD *)&v133[10] = 2081;
      *(void *)&v133[12] = v101;
      *(_WORD *)&v133[20] = 2081;
      *(void *)&v133[22] = v102;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v107,  2LL,  "TILE: not found in index, a, %{private}u, b, %{private}u, %{private}s, %{private}s, %{private}s",  v132,  44);
      uint64_t v33 = v103;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLo nEntry_LTE>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyL atLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v33);
LABEL_221:
      if (v33 != __p) {
        free(v33);
      }
      goto LABEL_162;
    }

    unsigned int v108 = v110 - v111 + 1;
    sub_100E72BC0(v6, (int *)a3, a3);
  }

  if (*(_BYTE *)(a1 + 392))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    unint64_t v18 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      unint64_t v19 = v132;
      sub_100C0BE04((unsigned int *)&v112, (std::stringbuf::string_type *)v132);
      if (v133[9] < 0) {
        unint64_t v19 = *(_BYTE **)v132;
      }
      __int16 v107 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v135);
      int v20 = (char)v135.__r_.__value_.__s.__size_;
      std::string::size_type v21 = v135.__r_.__value_.__r.__words[0];
      unsigned int v22 = v111;
      unsigned int v105 = v110;
      LODWORD(v106) = DWORD2(v116);
      sub_100C0BCC8((unsigned int *)a2, &v114);
      uint64_t v23 = &v135;
      if (v20 < 0) {
        uint64_t v23 = (std::stringbuf::string_type *)v21;
      }
      int8x8_t v24 = &v114;
      if ((v114.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int8x8_t v24 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::stringbuf::string_type __p = 136382211;
      *(void *)&__p[4] = v19;
      *(_WORD *)&_BYTE __p[12] = 2081;
      *(void *)uint64_t v144 = v107;
      *(_WORD *)&v144[8] = 2081;
      *(void *)&v144[10] = v23;
      *(_WORD *)&v144[18] = 1025;
      *(_DWORD *)&v144[20] = v22;
      *(_WORD *)&v144[24] = 1025;
      *(_DWORD *)&v144[26] = v105;
      *(_WORD *)&v144[30] = 1025;
      *(_DWORD *)&v144[32] = (_DWORD)v106;
      LOWORD(v145[0]) = 2081;
      *(void *)((char *)v145 + 2) = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "TILE: invalid binary search %{private}s in %{private}s, %{private}s, a:%{private}u, b:%{private}u, max:%{private}u, %{private}s",  __p,  0x3Cu);
      if ((v133[9] & 0x80000000) != 0) {
        operator delete(*(void **)v132);
      }
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      __int16 v107 = (const char *)qword_101934A78;
      uint64_t v25 = &v135;
      sub_100C0BE04((unsigned int *)&v112, &v135);
      if ((v135.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v25 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
      }
      double v106 = sub_100DD8CC8(*(_DWORD *)(a1 + 48));
      sub_100E72C48((uint64_t)buf, &v114);
      int v26 = (char)v114.__r_.__value_.__s.__size_;
      std::string::size_type v27 = v114.__r_.__value_.__r.__words[0];
      unsigned int v28 = v110;
      unsigned int v29 = v111;
      HIDWORD(v104) = DWORD2(v116);
      sub_100C0BCC8((unsigned int *)a2, &v109);
      std::string::size_type v30 = &v114;
      if (v26 < 0) {
        std::string::size_type v30 = (std::stringbuf::string_type *)v27;
      }
      int v31 = &v109;
      if ((v109.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v31 = (std::stringbuf::string_type *)v109.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)int v132 = 136382211;
      *(void *)&v132[4] = v25;
      *(_WORD *)&v132[12] = 2081;
      *(void *)int v133 = v106;
      *(_WORD *)&v133[8] = 2081;
      *(void *)&v133[10] = v30;
      *(_WORD *)&v133[18] = 1025;
      *(_DWORD *)&v133[20] = v29;
      *(_WORD *)&v133[24] = 1025;
      *(_DWORD *)&v133[26] = v28;
      *(_WORD *)&v133[30] = 1025;
      *(_DWORD *)&v133[32] = HIDWORD(v104);
      *(_WORD *)int v134 = 2081;
      *(void *)&v134[2] = v31;
      LODWORD(v104) = 60;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v107,  17LL,  "TILE: invalid binary search %{private}s in %{private}s, %{private}s, a:%{private}u, b:%{private}u, max:%{private}u, %{private}s",  v132,  v104);
      uint64_t v33 = v32;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLo nEntry_LTE>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyL atLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v33);
      goto LABEL_221;
    }
  }

void sub_100E71534( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, void *__p, uint64_t a37, int a38, __int16 a39, char a40, char a41)
{
  if (a41 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100E7167C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  *(void *)(a1 + 334) = *(uint64_t *)((char *)a2 + 6);
  *(void *)(a1 + 328) = v6;
  char v42 = 0;
  nullsub_10(0LL);
  uint64_t v44 = v7;
  int v41 = "search";
  char v43 = 1;
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  unint64_t v8 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BCC8((unsigned int *)a2, &__p);
    uint64_t v9 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
       ? &__p
       : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "TILE: getLocationByKey_traverse, key, %s",  (uint8_t *)&buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v24 = qword_101934A78;
    sub_100C0BCC8((unsigned int *)a2, &buf);
    if ((buf.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_std::stringbuf::string_type buf = &buf;
    }
    else {
      p_std::stringbuf::string_type buf = (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
    }
    LODWORD(v48.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_buf;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v24,  2LL,  "TILE: getLocationByKey_traverse, key, %s",  (const char *)&v48);
    std::string::size_type v27 = v26;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonE ntry_LTE>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyL atLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  (const char *)v27);
    if (v27 != &__p) {
      free(v27);
    }
  }

  sub_100C0FCEC(a1, &v48);
  BOOL v10 = (const char **)(a1 + 8);
  int v11 = (const char *)(a1 + 8);
  if (sub_100292D28(v11))
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    clock_t v12 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      std::string::size_type v13 = a1 + 8;
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "TILE: getLocationByKey_traverse, prefer local file name because it exists, %s",  (uint8_t *)&__p,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&__p, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      std::string::size_type v35 = a1 + 8;
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v35;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: getLocationByKey_traverse, prefer local file name because it exists, %s",  (const char *)&buf);
      uint64_t v37 = (std::stringbuf::string_type *)v36;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLo nEntry_LTE>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type:: KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v36);
      if (v37 != &__p) {
        free(v37);
      }
    }

    std::string::operator=(&v48, (const std::string *)(a1 + 8));
  }

  sub_100C1145C((void *)a1, (uint64_t)&v48, (uint64_t)&v41);
  uint64_t v14 = sub_100E72F04(a1 + 368, (int *)a2);
  uint64_t v15 = v14;
  uint64_t v16 = a1 + 376;
  if (a1 + 376 != v14)
  {
    uint64_t v17 = *(void *)(v14 + 25);
    *(void *)(a3 + 6) = *(void *)(v14 + 31);
    *(void *)a3 = v17;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  unint64_t v18 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BCC8((unsigned int *)a2, &buf);
    int size = (char)buf.__r_.__value_.__s.__size_;
    std::string::size_type v20 = buf.__r_.__value_.__r.__words[0];
    sub_100C0BCC8((unsigned int *)a3, &v40);
    std::string::size_type v21 = &buf;
    if (size < 0) {
      std::string::size_type v21 = (std::stringbuf::string_type *)v20;
    }
    if ((v40.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unsigned int v22 = &v40;
    }
    else {
      unsigned int v22 = (std::stringbuf::string_type *)v40.__r_.__value_.__r.__words[0];
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 67109890;
    HIDWORD(__p.__r_.__value_.__r.__words[0]) = v16 != v15;
    __p.__r_.__value_.__l.__size_ = 0x820000000000400LL;
    __p.__r_.__value_.__l.__cap_ = (std::string::size_type)v21;
    __int16 v50 = 2080;
    __int16 v51 = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEBUG,  "TILE: getLocationByKey_traverse, isFound, %d, searchedArea, %u, key, %s, entry, %s",  (uint8_t *)&__p,  0x22u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v28 = qword_101934A78;
    sub_100C0BCC8((unsigned int *)a2, &v40);
    int v29 = (char)v40.__r_.__value_.__s.__size_;
    std::string::size_type v30 = v40.__r_.__value_.__r.__words[0];
    sub_100C0BCC8((unsigned int *)a3, &v39);
    int v31 = &v40;
    if (v29 < 0) {
      int v31 = (std::stringbuf::string_type *)v30;
    }
    if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v32 = &v39;
    }
    else {
      __int128 v32 = (std::stringbuf::string_type *)v39.__r_.__value_.__r.__words[0];
    }
    LODWORD(buf.__r_.__value_.__l.__data_) = 67109890;
    HIDWORD(buf.__r_.__value_.__r.__words[0]) = v16 != v15;
    buf.__r_.__value_.__l.__size_ = 0x820000000000400LL;
    buf.__r_.__value_.__l.__cap_ = (std::string::size_type)v31;
    __int16 v46 = 2080;
    uint64_t v47 = v32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &__p,  1628LL,  &_mh_execute_header,  v28,  2LL,  "TILE: getLocationByKey_traverse, isFound, %d, searchedArea, %u, key, %s, entry, %s",  &buf,  34,  v38,  v39.__r_.__value_.__l.__data_);
    int v34 = v33;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonE ntry_LTE>::getLocationByKey_traverse(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyL atLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  (const char *)v34);
    if (v34 != &__p) {
      free(v34);
    }
  }

  (*(void (**)(uint64_t))(*(void *)a1 + 104LL))(a1);
  return v16 != v15;
}

void sub_100E71D34( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, void *__p, uint64_t a34, int a35, __int16 a36, char a37, char a38)
{
  if (a38 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E71D9C(uint64_t a1)
{
  *(void *)a1 = off_101888C08;
  sub_100008390(a1 + 368, *(void **)(a1 + 376));
  uint64_t v2 = *(void **)(a1 + 344);
  if (v2)
  {
    *(void *)(a1 + 352) = v2;
    operator delete(v2);
  }

  return sub_100C0CB28(a1);
}

uint64_t sub_100E71DE8(uint64_t a1)
{
  *(void *)a1 = off_101888CE0;
  sub_100008390(a1 + 368, *(void **)(a1 + 376));
  uint64_t v2 = *(void **)(a1 + 344);
  if (v2)
  {
    *(void *)(a1 + 352) = v2;
    operator delete(v2);
  }

  return sub_100C0CB28(a1);
}

uint64_t sub_100E71E34(uint64_t a1)
{
  *(void *)a1 = &off_101888DB8;
  sub_100008390(a1 + 368, *(void **)(a1 + 376));
  uint64_t v2 = *(void **)(a1 + 344);
  if (v2)
  {
    *(void *)(a1 + 352) = v2;
    operator delete(v2);
  }

  return sub_100C0CB28(a1);
}

uint64_t *sub_100E71E80(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_100E71ED4(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100E71EBC(_Unwind_Exception *a1)
{
}

uint64_t *sub_100E71ED4(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    unint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      __n128 result = sub_100E71F58(v5, v6, (int *)((char *)v4 + 25), (void *)((char *)v4 + 25));
      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          unint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          unint64_t v4 = v8;
        }

        while (!v9);
      }

      unint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_100E71F58(uint64_t **a1, uint64_t *a2, int *a3, uint64_t *a4)
{
  uint64_t v6 = sub_100E71FE4(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    unint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v7 + 25) = *a4;
    *(uint64_t *)((char *)v7 + 31) = *(uint64_t *)((char *)a4 + 6);
    sub_1000085FC(a1, (uint64_t)v11, v8, v7);
  }

  return v7;
}

uint64_t *sub_100E71FE4(uint64_t **a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, int *a5)
{
  int v5 = *(_DWORD *)((char *)a2 + 25);
  int v6 = *a5;
  int v7 = a5[1];
  int v8 = *(_DWORD *)((char *)a2 + 29);
  BOOL v9 = v7 < v8;
  if (*a5 != v5) {
    BOOL v9 = *a5 < v5;
  }
  if (v9)
  {
LABEL_5:
    BOOL v10 = (uint64_t *)*a2;
    if (*a1 == a2)
    {
      clock_t v12 = a2;
LABEL_24:
      if (v10)
      {
        *a3 = v12;
        return v12 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v10)
    {
      int v11 = (uint64_t *)*a2;
      do
      {
        clock_t v12 = v11;
        int v11 = (uint64_t *)v11[1];
      }

      while (v11);
    }

    else
    {
      uint64_t v17 = a2;
      do
      {
        clock_t v12 = (uint64_t *)v17[2];
        BOOL v18 = *v12 == (void)v17;
        uint64_t v17 = v12;
      }

      while (v18);
    }

    int v19 = *(_DWORD *)((char *)v12 + 25);
    BOOL v18 = v19 == *a5;
    BOOL v20 = v19 < *a5;
    if (v18) {
      BOOL v20 = *(_DWORD *)((char *)v12 + 29) < a5[1];
    }
    if (v20) {
      goto LABEL_24;
    }
    return sub_100E7215C((uint64_t)a1, a3, a5);
  }

  BOOL v13 = v8 < v7;
  if (v6 == v5) {
    BOOL v14 = v13;
  }
  else {
    BOOL v14 = v5 < v6;
  }
  if (v14)
  {
    uint64_t v15 = a2[1];
    if (v15)
    {
      uint64_t v16 = (uint64_t *)a2[1];
      do
      {
        a4 = (uint64_t **)v16;
        uint64_t v16 = (uint64_t *)*v16;
      }

      while (v16);
    }

    else
    {
      std::string::size_type v21 = a2;
      do
      {
        a4 = (uint64_t **)v21[2];
        BOOL v18 = *a4 == v21;
        std::string::size_type v21 = (uint64_t *)a4;
      }

      while (!v18);
    }

    if (a4 == a1 + 1) {
      goto LABEL_35;
    }
    int v22 = *(_DWORD *)((char *)a4 + 25);
    BOOL v23 = v7 < *(_DWORD *)((char *)a4 + 29);
    BOOL v18 = v6 == v22;
    BOOL v24 = v6 < v22;
    if (v18) {
      BOOL v24 = v23;
    }
    if (v24)
    {
LABEL_35:
      if (v15)
      {
        *a3 = (uint64_t *)a4;
      }

      else
      {
        *a3 = a2;
        return a2 + 1;
      }

      return (uint64_t *)a4;
    }

    return sub_100E7215C((uint64_t)a1, a3, a5);
  }

  *a3 = a2;
  *a4 = a2;
  return (uint64_t *)a4;
}

uint64_t *sub_100E7215C(uint64_t a1, void *a2, int *a3)
{
  int v5 = *(uint64_t **)(a1 + 8);
  __n128 result = (uint64_t *)(a1 + 8);
  unint64_t v4 = v5;
  if (v5)
  {
    int v6 = *a3;
    int v7 = a3[1];
    do
    {
      while (1)
      {
        int v8 = v4;
        int v9 = *(_DWORD *)((char *)v4 + 25);
        int v10 = *(_DWORD *)((char *)v8 + 29);
        BOOL v11 = v7 < v10;
        if (v6 != v9) {
          BOOL v11 = v6 < v9;
        }
        if (!v11) {
          break;
        }
        unint64_t v4 = (uint64_t *)*v8;
        __n128 result = v8;
        if (!*v8) {
          goto LABEL_15;
        }
      }

      BOOL v12 = v10 < v7;
      if (v6 == v9) {
        BOOL v13 = v12;
      }
      else {
        BOOL v13 = v9 < v6;
      }
      if (!v13) {
        break;
      }
      __n128 result = v8 + 1;
      unint64_t v4 = (uint64_t *)v8[1];
    }

    while (v4);
  }

  else
  {
    int v8 = result;
  }

void sub_100E721DC(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_100E72208(char **a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 2) < a2)
  {
    if (a2 >= 0x1555555555555556LL) {
      sub_100007008();
    }
    uint64_t v5 = (a1[1] - *a1) / 12;
    int v6 = (char *)sub_1005AADE4(v3, a2);
    int v7 = &v6[12 * v5];
    int v9 = &v6[12 * v8];
    BOOL v11 = *a1;
    int v10 = a1[1];
    BOOL v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *(void *)(v10 - 12);
        v10 -= 12;
        int v14 = *((_DWORD *)v10 + 2);
        *(void *)(v12 - 12) = v13;
        v12 -= 12;
        *((_DWORD *)v12 + 2) = v14;
      }

      while (v10 != v11);
      int v10 = *a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

BOOL sub_100E722D8(uint64_t a1, unsigned int **a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v44 = 0LL;
  int v45 = 0;
  sub_100C0BCB8(&v44, (void *)(a1 + 328));
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  int v7 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    int v9 = *a2;
    uint64_t v8 = a2[1];
    sub_100C0BBAC((unsigned int *)&v44, &__p);
    int v10 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
        ? &__p
        : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    unsigned int v11 = **a2;
    BOOL v12 = (_DWORD)v44 == v11 ? SHIDWORD(v44) < (int)(*a2)[1] : v44 < v11;
    LODWORD(buf.__r_.__value_.__l.__data_) = 134218498;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = 0xAAAAAAAAAAAAAAABLL * (v8 - v9);
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v10;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
    BOOL v50 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TILE: binarySearchIndex, size, %lu, searchedIndexEntry, %s, %d",  (uint8_t *)&buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v31 = qword_101934A78;
    uint64_t v33 = *a2;
    __int128 v32 = a2[1];
    sub_100C0BBAC((unsigned int *)&v44, &v46);
    if ((v46.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v34 = &v46;
    }
    else {
      int v34 = (std::stringbuf::string_type *)v46.__r_.__value_.__r.__words[0];
    }
    unsigned int v35 = **a2;
    if ((_DWORD)v44 == v35) {
      BOOL v36 = SHIDWORD(v44) < (int)(*a2)[1];
    }
    else {
      BOOL v36 = v44 < v35;
    }
    LODWORD(__p.__r_.__value_.__l.__data_) = 134218498;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = 0xAAAAAAAAAAAAAAABLL * (v32 - v33);
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v34;
    HIWORD(__p.__r_.__value_.__r.__words[2]) = 1024;
    BOOL v48 = v36;
    LODWORD(v43) = 28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v31,  2LL,  "TILE: binarySearchIndex, size, %lu, searchedIndexEntry, %s, %d",  &__p,  v43,  v44);
    char v42 = v41;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonEntry_GSM >::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManager_T ype::KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  (const char *)v42);
    if (v42 != &buf) {
      free(v42);
    }
  }

  *a4 = 0;
  *a3 = 0;
  int v14 = *a2;
  uint64_t v13 = a2[1];
  if (v13 == *a2) {
    goto LABEL_24;
  }
  unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (v13 - *a2);
  uint64_t v16 = *a2;
  do
  {
    unint64_t v17 = v15 >> 1;
    BOOL v18 = &v16[3 * (v15 >> 1)];
    unsigned int v21 = *v18;
    signed int v19 = v18[1];
    BOOL v20 = v18 + 3;
    BOOL v22 = v19 < SHIDWORD(v44);
    BOOL v23 = v21 == (_DWORD)v44;
    BOOL v24 = v21 < v44;
    if (v23) {
      BOOL v24 = v22;
    }
    v15 += ~(v15 >> 1);
    if (v24) {
      uint64_t v16 = v20;
    }
    else {
      unint64_t v15 = v17;
    }
  }

  while (v15);
  if (v16 == v14)
  {
LABEL_24:
    *a3 = v14[2];
    *a4 = v14[2] + 1;
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v25 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      sub_100C0BBAC(v14, &buf);
      int v26 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &buf
          : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v26;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEBUG,  "TILE: index search, match, %s",  (uint8_t *)&__p,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v37 = qword_101934A78;
      sub_100C0BBAC(v14, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(v46.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v46.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v37,  2LL,  "TILE: index search, match, %s",  (const char *)&v46);
      std::stringbuf::string_type v40 = v39;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonEntry_G SM>::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManag er_Type::KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  (const char *)v40);
      if (v40 != &buf) {
        free(v40);
      }
    }

    return 1LL;
  }

  if (v16 != v13)
  {
    *a3 = *(v16 - 1);
    *a4 = v16[2];
    return 1LL;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  uint64_t v28 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "TILE: index search, not found",  (uint8_t *)&buf,  2u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    LODWORD(v43) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: index search, not found",  &__p,  v43);
    std::string::size_type v30 = (std::stringbuf::string_type *)v29;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonEntry_GSM >::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManager_T ype::KeyLatLonIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v29);
    if (v30 != &buf) {
      free(v30);
    }
    return 0LL;
  }

  return result;
}

uint64_t sub_100E72944(uint64_t a1, uint64_t a2, unsigned int a3, int a4, _DWORD *a5, void *a6)
{
  if (a3)
  {
    unsigned int v9 = a3;
    int v11 = 0;
    int v12 = 1;
    while (1)
    {
      int v13 = v12;
      *(void *)&buf[6] = 0LL;
      *(void *)std::stringbuf::string_type buf = 0LL;
      sub_100C0BA1C((int8x8_t *)((v11 + (v9 >> 1)) * a4 + a2), (int8x8_t *)buf);
      BOOL v14 = *(_DWORD *)buf < *a5;
      if (*(_DWORD *)buf == *a5)
      {
        int v15 = a5[1];
        BOOL v14 = *(_DWORD *)&buf[4] < v15;
        if (*(_DWORD *)&buf[4] == v15) {
          break;
        }
      }

      int v16 = v14;
      BOOL v17 = v16 == 0;
      if (v16) {
        int v18 = (v9 >> 1) + 1;
      }
      else {
        int v18 = 0;
      }
      v11 += v18;
      if (v17) {
        v9 >>= 1;
      }
      else {
        v9 -= (v9 >> 1) + 1;
      }
      int v12 = v13 + 1;
      if (!v9)
      {
        uint64_t v19 = 0LL;
        goto LABEL_18;
      }
    }

    *a6 = *(void *)buf;
    *(void *)((char *)a6 + 6) = *(void *)&buf[6];
    uint64_t v19 = 1LL;
  }

  else
  {
    uint64_t v19 = 0LL;
    int v13 = 0;
  }

uint64_t *sub_100E72BC0(uint64_t **a1, int *a2, uint64_t *a3)
{
  uint64_t v5 = sub_100E7215C((uint64_t)a1, &v9, a2);
  int v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    int v7 = (uint64_t **)v5;
    int v6 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v6 + 25) = *a3;
    *(uint64_t *)((char *)v6 + 31) = *(uint64_t *)((char *)a3 + 6);
    sub_1000085FC(a1, v9, v7, v6);
  }

  return v6;
}

uint64_t sub_100E72C48@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  unint64_t v4 = sub_10000CF44(&v16, (uint64_t)"TileHeader(", 11LL);
  uint64_t v5 = sub_10000CF44(v4, (uint64_t)"tileY=", 6LL);
  int v6 = (void *)std::ostream::operator<<(v5, *(unsigned int *)(a1 + 16));
  int v7 = sub_10000CF44(v6, (uint64_t)", ", 2LL);
  uint64_t v8 = sub_10000CF44(v7, (uint64_t)"tileX=", 6LL);
  uint64_t v9 = (void *)std::ostream::operator<<(v8, *(unsigned int *)(a1 + 20));
  int v10 = sub_10000CF44(v9, (uint64_t)",", 1LL);
  int v11 = sub_10000CF44(v10, (uint64_t)"genTime=", 8LL);
  int v12 = (void *)std::ostream::operator<<(v11, *(void *)(a1 + 40));
  sub_10000CF44(v12, (uint64_t)")", 1LL);
  std::stringbuf::str(a2, &v17);
  *(void *)((char *)v15
  uint64_t v16 = v13;
  std::streambuf::~streambuf(&v17);
  return std::ios::~ios(&v18);
}

void sub_100E72D80(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

BOOL sub_100E72D94(uint64_t a1, int8x8_t *a2, unsigned int a3, int a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  int8x8_t v22 = 0LL;
  int v23 = 0;
  if (!a3) {
    goto LABEL_18;
  }
  unsigned int v13 = 0;
  unsigned int v14 = a3;
  do
  {
    unsigned int v15 = v14 >> 1;
    sub_100C0BB90((int8x8_t *)((char *)a2 + (v13 + (v14 >> 1)) * a4), &v22);
    BOOL v16 = v22.i32[0] < *a5;
    if (v22.i32[0] == *a5) {
      BOOL v16 = v22.i32[1] < a5[1];
    }
    if (v16) {
      v14 -= v15 + 1;
    }
    else {
      v14 >>= 1;
    }
    if (v16) {
      unsigned int v17 = v15 + 1;
    }
    else {
      unsigned int v17 = 0;
    }
    v13 += v17;
  }

  while (v14);
  if (v13) {
    BOOL v18 = v13 >= a3;
  }
  else {
    BOOL v18 = 1;
  }
  if (!v18)
  {
    sub_100C0BB90((int8x8_t *)((char *)a2 + v13 * a4), &v22);
    *a7 = v23;
    sub_100C0BB90((int8x8_t *)((char *)a2 + (v13 - 1) * a4), &v22);
    BOOL v19 = 1;
    int v20 = v23;
    goto LABEL_25;
  }

  if (v13)
  {
LABEL_18:
    int v20 = 0;
    BOOL v19 = 0;
    *a7 = 0;
    goto LABEL_25;
  }

  sub_100C0BB90(a2, &v22);
  if (v22.i32[0] == *a5)
  {
    BOOL v19 = v22.i32[1] == a5[1];
    if (v22.i32[1] == a5[1]) {
      int v20 = v23;
    }
    else {
      int v20 = 0;
    }
  }

  else
  {
    BOOL v19 = 0;
    int v20 = 0;
  }

  *a7 = v20;
LABEL_25:
  *a6 = v20;
  return v19;
}

uint64_t sub_100E72F04(uint64_t a1, int *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  int v5 = *a2;
  int v6 = a2[1];
  uint64_t v7 = v2;
  do
  {
    int v8 = *(_DWORD *)(v3 + 25);
    BOOL v10 = v8 == v5;
    BOOL v9 = v8 < v5;
    if (v10) {
      BOOL v9 = *(_DWORD *)(v3 + 29) < v6;
    }
    BOOL v10 = !v9;
    if (v9) {
      int v11 = (uint64_t *)(v3 + 8);
    }
    else {
      int v11 = (uint64_t *)v3;
    }
    if (v10) {
      uint64_t v7 = v3;
    }
    uint64_t v3 = *v11;
  }

  while (*v11);
  if (v7 == v2) {
    return v2;
  }
  int v12 = *(_DWORD *)(v7 + 25);
  BOOL v13 = v6 < *(_DWORD *)(v7 + 29);
  BOOL v10 = v5 == v12;
  BOOL v14 = v5 < v12;
  if (v10) {
    BOOL v14 = v13;
  }
  if (v14) {
    return v2;
  }
  return v7;
}

uint64_t *sub_100E72F80(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_100E71ED4(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100E72FBC(_Unwind_Exception *a1)
{
}

BOOL sub_100E72FD4(uint64_t a1, int **a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v46 = 0LL;
  int v47 = 0;
  sub_100C0BCB8(&v46, (void *)(a1 + 328));
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  uint64_t v7 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    BOOL v9 = *a2;
    int v8 = a2[1];
    sub_100C0C04C((unsigned int *)&v46, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    int v11 = **a2;
    BOOL v12 = (int)v46 < v11;
    if ((_DWORD)v46 == v11) {
      BOOL v12 = SHIDWORD(v46) < (*a2)[1];
    }
    int v13 = v12;
    LODWORD(buf.__r_.__value_.__l.__data_) = 134218498;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = 0xAAAAAAAAAAAAAAABLL * (v8 - v9);
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_p;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
    int v52 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TILE: binarySearchIndex, size, %lu, searchedIndexEntry, %s, %d",  (uint8_t *)&buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v32 = qword_101934A78;
    int v34 = *a2;
    uint64_t v33 = a2[1];
    sub_100C0C04C((unsigned int *)&v46, &v48);
    if ((v48.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unsigned int v35 = &v48;
    }
    else {
      unsigned int v35 = (std::stringbuf::string_type *)v48.__r_.__value_.__r.__words[0];
    }
    int v36 = **a2;
    BOOL v37 = (int)v46 < v36;
    if ((_DWORD)v46 == v36) {
      BOOL v37 = SHIDWORD(v46) < (*a2)[1];
    }
    int v38 = v37;
    LODWORD(__p.__r_.__value_.__l.__data_) = 134218498;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = 0xAAAAAAAAAAAAAAABLL * (v33 - v34);
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v35;
    HIWORD(__p.__r_.__value_.__r.__words[2]) = 1024;
    int v50 = v38;
    LODWORD(v45) = 28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v32,  2LL,  "TILE: binarySearchIndex, size, %lu, searchedIndexEntry, %s, %d",  &__p,  v45,  v46);
    std::stringbuf::string_type v40 = v39;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLonEntry_CD MA>::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManager _Type::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  (const char *)v40);
    if (v40 != &buf) {
      free(v40);
    }
  }

  *a4 = 0;
  *a3 = 0;
  unsigned int v15 = (unsigned int *)*a2;
  BOOL v14 = a2[1];
  if (v14 == *a2) {
    goto LABEL_26;
  }
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (v14 - *a2);
  unsigned int v17 = *a2;
  do
  {
    unint64_t v18 = v16 >> 1;
    BOOL v19 = &v17[3 * (v16 >> 1)];
    int v22 = *v19;
    int v20 = v19[1];
    unsigned int v21 = v19 + 3;
    BOOL v23 = v20 < SHIDWORD(v46);
    BOOL v24 = v22 == (_DWORD)v46;
    BOOL v25 = v22 < (int)v46;
    if (v24) {
      BOOL v25 = v23;
    }
    v16 += ~(v16 >> 1);
    if (v25) {
      unsigned int v17 = v21;
    }
    else {
      unint64_t v16 = v18;
    }
  }

  while (v16);
  if (v17 == (int *)v15)
  {
LABEL_26:
    *a3 = v15[2];
    *a4 = v15[2] + 1;
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    int v26 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      sub_100C0C04C(v15, &buf);
      std::string::size_type v27 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &buf
          : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "TILE: index search, match, %s",  (uint8_t *)&__p,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v41 = qword_101934A78;
      sub_100C0C04C(v15, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        char v42 = &__p;
      }
      else {
        char v42 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(v48.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words + 4) = (std::string::size_type)v42;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v41,  2LL,  "TILE: index search, match, %s",  (const char *)&v48);
      uint64_t v44 = v43;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLonEntry_ CDMA>::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesMan ager_Type::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  (const char *)v44);
      if (v44 != &buf) {
        free(v44);
      }
    }

    return 1LL;
  }

  if (v17 != v14)
  {
    *a3 = *(v17 - 1);
    *a4 = v17[2];
    return 1LL;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  int v29 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEBUG,  "TILE: index search, not found",  (uint8_t *)&buf,  2u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    LODWORD(v45) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: index search, not found",  &__p,  v45);
    uint64_t v31 = (std::stringbuf::string_type *)v30;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLonEntry_CD MA>::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManager _Type::KeyLatLonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v30);
    if (v31 != &buf) {
      free(v31);
    }
    return 0LL;
  }

  return result;
}

uint64_t sub_100E73630(uint64_t a1, uint64_t a2, unsigned int a3, int a4, _DWORD *a5, void *a6)
{
  if (a3)
  {
    unsigned int v9 = a3;
    int v11 = 0;
    int v12 = 1;
    while (1)
    {
      int v13 = v12;
      *(void *)&buf[6] = 0LL;
      *(void *)std::stringbuf::string_type buf = 0LL;
      sub_100C0BA1C((int8x8_t *)((v11 + (v9 >> 1)) * a4 + a2), (int8x8_t *)buf);
      BOOL v14 = *(_DWORD *)buf < *a5;
      if (*(_DWORD *)buf == *a5)
      {
        int v15 = a5[1];
        BOOL v14 = *(_DWORD *)&buf[4] < v15;
        if (*(_DWORD *)&buf[4] == v15) {
          break;
        }
      }

      int v16 = v14;
      BOOL v17 = v16 == 0;
      if (v16) {
        int v18 = (v9 >> 1) + 1;
      }
      else {
        int v18 = 0;
      }
      v11 += v18;
      if (v17) {
        v9 >>= 1;
      }
      else {
        v9 -= (v9 >> 1) + 1;
      }
      int v12 = v13 + 1;
      if (!v9)
      {
        uint64_t v19 = 0LL;
        goto LABEL_18;
      }
    }

    *a6 = *(void *)buf;
    *(void *)((char *)a6 + 6) = *(void *)&buf[6];
    uint64_t v19 = 1LL;
  }

  else
  {
    uint64_t v19 = 0LL;
    int v13 = 0;
  }

BOOL sub_100E738AC(uint64_t a1, int8x8_t *a2, unsigned int a3, int a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  int8x8_t v22 = 0LL;
  int v23 = 0;
  if (!a3) {
    goto LABEL_18;
  }
  unsigned int v13 = 0;
  unsigned int v14 = a3;
  do
  {
    unsigned int v15 = v14 >> 1;
    sub_100C0BB90((int8x8_t *)((char *)a2 + (v13 + (v14 >> 1)) * a4), &v22);
    BOOL v16 = v22.i32[0] < *a5;
    if (v22.i32[0] == *a5) {
      BOOL v16 = v22.i32[1] < a5[1];
    }
    if (v16) {
      v14 -= v15 + 1;
    }
    else {
      v14 >>= 1;
    }
    if (v16) {
      unsigned int v17 = v15 + 1;
    }
    else {
      unsigned int v17 = 0;
    }
    v13 += v17;
  }

  while (v14);
  if (v13) {
    BOOL v18 = v13 >= a3;
  }
  else {
    BOOL v18 = 1;
  }
  if (!v18)
  {
    sub_100C0BB90((int8x8_t *)((char *)a2 + v13 * a4), &v22);
    *a7 = v23;
    sub_100C0BB90((int8x8_t *)((char *)a2 + (v13 - 1) * a4), &v22);
    BOOL v19 = 1;
    int v20 = v23;
    goto LABEL_25;
  }

  if (v13)
  {
LABEL_18:
    int v20 = 0;
    BOOL v19 = 0;
    *a7 = 0;
    goto LABEL_25;
  }

  sub_100C0BB90(a2, &v22);
  if (v22.i32[0] == *a5)
  {
    BOOL v19 = v22.i32[1] == a5[1];
    if (v22.i32[1] == a5[1]) {
      int v20 = v23;
    }
    else {
      int v20 = 0;
    }
  }

  else
  {
    BOOL v19 = 0;
    int v20 = 0;
  }

  *a7 = v20;
LABEL_25:
  *a6 = v20;
  return v19;
}

uint64_t *sub_100E73A1C(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_100E71ED4(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_100E73A58(_Unwind_Exception *a1)
{
}

BOOL sub_100E73A70(uint64_t a1, int **a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v46 = 0LL;
  int v47 = 0;
  sub_100C0BCB8(&v46, (void *)(a1 + 328));
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  uint64_t v7 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    unsigned int v9 = *a2;
    int v8 = a2[1];
    sub_100C0BE04((unsigned int *)&v46, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    int v11 = **a2;
    BOOL v12 = (int)v46 < v11;
    if ((_DWORD)v46 == v11) {
      BOOL v12 = SHIDWORD(v46) < (*a2)[1];
    }
    int v13 = v12;
    LODWORD(buf.__r_.__value_.__l.__data_) = 134218498;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = 0xAAAAAAAAAAAAAAABLL * (v8 - v9);
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_p;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
    int v52 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "TILE: binarySearchIndex, size, %lu, searchedIndexEntry, %s, %d",  (uint8_t *)&buf,  0x1Cu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    uint64_t v32 = qword_101934A78;
    int v34 = *a2;
    uint64_t v33 = a2[1];
    sub_100C0BE04((unsigned int *)&v46, &v48);
    if ((v48.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      unsigned int v35 = &v48;
    }
    else {
      unsigned int v35 = (std::stringbuf::string_type *)v48.__r_.__value_.__r.__words[0];
    }
    int v36 = **a2;
    BOOL v37 = (int)v46 < v36;
    if ((_DWORD)v46 == v36) {
      BOOL v37 = SHIDWORD(v46) < (*a2)[1];
    }
    int v38 = v37;
    LODWORD(__p.__r_.__value_.__l.__data_) = 134218498;
    *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = 0xAAAAAAAAAAAAAAABLL * (v33 - v34);
    WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v35;
    HIWORD(__p.__r_.__value_.__r.__words[2]) = 1024;
    int v50 = v38;
    LODWORD(v45) = 28;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v32,  2LL,  "TILE: binarySearchIndex, size, %lu, searchedIndexEntry, %s, %d",  &__p,  v45,  v46);
    std::stringbuf::string_type v40 = v39;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonEntry_LTE >::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManager_T ype::KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  (const char *)v40);
    if (v40 != &buf) {
      free(v40);
    }
  }

  *a4 = 0;
  *a3 = 0;
  unsigned int v15 = (unsigned int *)*a2;
  unsigned int v14 = a2[1];
  if (v14 == *a2) {
    goto LABEL_26;
  }
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * (v14 - *a2);
  unsigned int v17 = *a2;
  do
  {
    unint64_t v18 = v16 >> 1;
    BOOL v19 = &v17[3 * (v16 >> 1)];
    int v22 = *v19;
    int v20 = v19[1];
    unsigned int v21 = v19 + 3;
    BOOL v23 = v20 < SHIDWORD(v46);
    BOOL v24 = v22 == (_DWORD)v46;
    BOOL v25 = v22 < (int)v46;
    if (v24) {
      BOOL v25 = v23;
    }
    v16 += ~(v16 >> 1);
    if (v25) {
      unsigned int v17 = v21;
    }
    else {
      unint64_t v16 = v18;
    }
  }

  while (v16);
  if (v17 == (int *)v15)
  {
LABEL_26:
    *a3 = v15[2];
    *a4 = v15[2] + 1;
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    int v26 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      sub_100C0BE04(v15, &buf);
      std::string::size_type v27 = (buf.__r_.__value_.__s.__size_ & 0x80u) == 0
          ? &buf
          : (std::stringbuf::string_type *)buf.__r_.__value_.__r.__words[0];
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "TILE: index search, match, %s",  (uint8_t *)&__p,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_101888E80);
      }
      uint64_t v41 = qword_101934A78;
      sub_100C0BE04(v15, &__p);
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        char v42 = &__p;
      }
      else {
        char v42 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(v48.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words + 4) = (std::string::size_type)v42;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v41,  2LL,  "TILE: index search, match, %s",  (const char *)&v48);
      uint64_t v44 = v43;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonEntry_L TE>::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManag er_Type::KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  (const char *)v44);
      if (v44 != &buf) {
        free(v44);
      }
    }

    return 1LL;
  }

  if (v17 != v14)
  {
    *a3 = *(v17 - 1);
    *a4 = v17[2];
    return 1LL;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  int v29 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEBUG,  "TILE: index search, not found",  (uint8_t *)&buf,  2u);
  }

  BOOL result = sub_1002921D0(115, 2);
  if (result)
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    LOWORD(__p.__r_.__value_.__l.__data_) = 0;
    LODWORD(v45) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: index search, not found",  &__p,  v45);
    uint64_t v31 = (std::stringbuf::string_type *)v30;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonEntry_LTE >::binarySearchIndex(std::vector<IndexEntry_T> &, unsigned int &, unsigned int &) [IndexEntry_T = CLTilesManager_T ype::KeyLatLonIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v30);
    if (v31 != &buf) {
      free(v31);
    }
    return 0LL;
  }

  return result;
}

uint64_t sub_100E740CC(uint64_t a1, uint64_t a2, unsigned int a3, int a4, _DWORD *a5, void *a6)
{
  if (a3)
  {
    unsigned int v9 = a3;
    int v11 = 0;
    int v12 = 1;
    while (1)
    {
      int v13 = v12;
      *(void *)&buf[6] = 0LL;
      *(void *)std::stringbuf::string_type buf = 0LL;
      sub_100C0BA1C((int8x8_t *)((v11 + (v9 >> 1)) * a4 + a2), (int8x8_t *)buf);
      BOOL v14 = *(_DWORD *)buf < *a5;
      if (*(_DWORD *)buf == *a5)
      {
        int v15 = a5[1];
        BOOL v14 = *(_DWORD *)&buf[4] < v15;
        if (*(_DWORD *)&buf[4] == v15) {
          break;
        }
      }

      int v16 = v14;
      BOOL v17 = v16 == 0;
      if (v16) {
        int v18 = (v9 >> 1) + 1;
      }
      else {
        int v18 = 0;
      }
      v11 += v18;
      if (v17) {
        v9 >>= 1;
      }
      else {
        v9 -= (v9 >> 1) + 1;
      }
      int v12 = v13 + 1;
      if (!v9)
      {
        uint64_t v19 = 0LL;
        goto LABEL_18;
      }
    }

    *a6 = *(void *)buf;
    *(void *)((char *)a6 + 6) = *(void *)&buf[6];
    uint64_t v19 = 1LL;
  }

  else
  {
    uint64_t v19 = 0LL;
    int v13 = 0;
  }

void sub_100E74348(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
}

uint64_t sub_100E74350()
{
  unsigned __int8 v0 = operator new(0x10uLL);
  uint64_t result = sub_1002E4C3C(v0, "CLCellTile-Mutex", 1LL, 1LL);
  qword_10199EDD0 = (uint64_t)v0;
  return result;
}

void sub_100E74390(_Unwind_Exception *a1)
{
}

uint64_t sub_100E743A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)sub_1002B5C60(a1, a2, a3, a4) = off_101888EB0;
  int v5 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLTileFileDownload(ctor)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v5, &v8);

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101888F08);
  }
  int v6 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 68289538;
    int v10 = 0;
    __int16 v11 = 2082;
    int v12 = "";
    __int16 v13 = 2082;
    BOOL v14 = "activity";
    __int16 v15 = 2050;
    uint64_t v16 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLTileFileDownload(ctor), event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
  }

  *(void *)(a1 + 112) = 0LL;
  os_activity_scope_leave(&v8);
  return a1;
}

void sub_100E744E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

uint64_t sub_100E74508(uint64_t a1)
{
  *(void *)a1 = off_101888EB0;
  uint64_t v2 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLTileFileDownload(dtor)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v2, &v5);

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101888F08);
  }
  uint64_t v3 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 68289538;
    int v7 = 0;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 2082;
    __int16 v11 = "activity";
    __int16 v12 = 2050;
    uint64_t v13 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLTileFileDownload(dtor), event:%{public, location:escape_only}s, this:%{public}p}",  buf,  0x26u);
  }

  (*(void (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  os_activity_scope_leave(&v5);
  sub_1002B5CF0(a1);
  return a1;
}

void sub_100E7465C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

void sub_100E7466C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E74508(a1);
  operator delete(v1);
}

id sub_100E74680(uint64_t a1, uint64_t a2, uint64_t a3, double *a4)
{
  __int16 v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLTileFileDownload::download",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v8, &state);

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101888F08);
  }
  uint64_t v9 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 68289282;
    int v24 = 0;
    __int16 v25 = 2082;
    int v26 = "";
    __int16 v27 = 2082;
    uint64_t v28 = "activity";
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLTileFileDownload::download, event:%{public, location:escape_only}s}",  buf,  0x1Cu);
  }

  if (*(_BYTE *)(a1 + 81))
  {
    double v10 = *a4;
    __int16 v11 = operator new(0x30uLL);
    sub_100AD558C((uint64_t)v11, (uint64_t)"CLTileFileRequest", a1, v10 * 3.0);
    uint64_t v12 = *(void *)(a1 + 88);
    *(void *)(a1 + 88) = v11;
    if (v12)
    {
      (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
      __int16 v11 = *(void **)(a1 + 88);
    }

    sub_1010DDBC0(__p, "download");
    sub_100AD5668((uint64_t)v11, (uint64_t *)__p);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
  }

  if (!*(void *)(a1 + 104)) {
    *(void *)(a1 + 104) = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "CLTileFileDownload");
  }
  if (*(void *)(a1 + 112))
  {
    if (qword_101934A30 != -1) {
      dispatch_once(&qword_101934A30, &stru_101888F28);
    }
    uint64_t v13 = (os_log_s *)qword_101934A38;
    if (os_log_type_enabled((os_log_t)qword_101934A38, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289026;
      int v24 = 0;
      __int16 v25 = 2082;
      int v26 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Dropping uncancelled #TileRemoteDownloader to service new request}",  buf,  0x12u);
      if (qword_101934A30 != -1) {
        dispatch_once(&qword_101934A30, &stru_101888F28);
      }
    }

    BOOL v14 = (os_log_s *)qword_101934A38;
    if (os_signpost_enabled((os_log_t)qword_101934A38))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289026;
      int v24 = 0;
      __int16 v25 = 2082;
      int v26 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v14,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Dropping uncancelled #TileRemoteDownloader to service new request",  "{msg%{public}.0s:Dropping uncancelled #TileRemoteDownloader to service new request}",  buf,  0x12u);
    }

    (*(void (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
  }

  id v15 = objc_msgSend( [CLTileRemoteDownloader alloc],  "initWithQueue:canDownloadOverCellular:",  objc_msgSend(*(id *)(a1 + 32), "queue"),  *(unsigned __int8 *)(a1 + 80));
  *(void *)(a1 + 112) = v15;
  double v16 = *a4;
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472LL;
  float32x2_t v19[2] = sub_100E74A58;
  void v19[3] = &unk_101888ED0;
  void v19[4] = a1;
  id v17 = [v15 downloadAndDecompressFrom:a2 toDecompressedDestination:a3 withTimeout:v19 withCompletionHandler:v16];
  os_activity_scope_leave(&state);
  return v17;
}

void sub_100E74A18( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, os_activity_scope_state_s state)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

uint64_t sub_100E74A58(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v6 = *(void *)(a1 + 32);
  if (a4) {
    id v7 = [a4 code];
  }
  else {
    id v7 = (id)sub_1002B7140(a3);
  }
  *(void *)(v6 + 96) = v7;
  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101888F08);
  }
  __int16 v8 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(v6 + 96);
    v11[0] = 68290051;
    v11[1] = 0;
    __int16 v12 = 2082;
    uint64_t v13 = "";
    __int16 v14 = 2113;
    uint64_t v15 = a2;
    __int16 v16 = 1025;
    int v17 = v9;
    __int16 v18 = 2113;
    uint64_t v19 = a4;
    __int16 v20 = 2050;
    uint64_t v21 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#TileFileDownload completion, DecompressedFile:%{private, location:escape_only}@, R esultCode:%{private}d, Error:%{private, location:escape_only}@, this:%{public}p}",  (uint8_t *)v11,  0x36u);
  }

  (*(void (**)(uint64_t, BOOL, void))(v6 + 64))(v6, *(void *)(v6 + 96) == 0LL, *(void *)(v6 + 72));
  return (*(uint64_t (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
}

void sub_100E74BB4(uint64_t a1)
{
  uint64_t v2 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLTileFileDownload::cancel",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_enter(v2, &v5);

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101888F08);
  }
  uint64_t v3 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 68289282;
    int v7 = 0;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 2082;
    __int16 v11 = "activity";
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLTileFileDownload::cancel, event:%{public, location:escape_only}s}",  buf,  0x1Cu);
  }

  [*(id *)(a1 + 112) cancel];

  *(void *)(a1 + 112) = 0LL;
  uint64_t v4 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }

  *(void *)(a1 + 104) = 0LL;
  os_activity_scope_leave(&v5);
}

void sub_100E74D0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
}

void sub_100E74D20(id a1)
{
  qword_101934838 = (uint64_t)os_log_create("com.apple.locationd.Position", "Position");
}

void sub_100E74D4C(id a1)
{
  qword_101934A38 = (uint64_t)os_log_create("com.apple.locationd.Utility", "Network");
}

void *sub_100E74D78(void *result, uint64_t a2, uint64_t a3)
{
  result[1] = a2;
  result[2] = a3;
  *uint64_t result = &off_101888F58;
  return result;
}

void sub_100E74D90(void *a1)
{
  uint64_t v1 = sub_100213E60(a1);
  operator delete(v1);
}

uint64_t sub_100E7513C()
{
  if (v2 < 0) {
    operator delete(__p[0]);
  }
  __cxa_atexit((void (*)(void *))sub_100E75130, &qword_1019A2AF0, (void *)&_mh_execute_header);
  sub_100B150C4(qword_1019A2AF0, &xmmword_1019A21D8, &qword_1019A2B00);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2B00, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2B00, qword_1019A2208, 0, (uint64_t *)&unk_1019A2B10);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2B10, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2B00, qword_1019A2238, 0, (uint64_t *)&unk_1019A2B20);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2B20, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2B00, qword_1019A2268, 0, (uint64_t *)&unk_1019A2B30);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2B30, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2B00, qword_1019A2298, 0, (uint64_t *)&unk_1019A2B40);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2B40, (void *)&_mh_execute_header);
  sub_100B150C4(qword_1019A2AF0, &xmmword_1019A2148, &qword_1019A2B50);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2B50, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2B50, qword_1019A2178, 0, (uint64_t *)&unk_1019A2B60);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2B60, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2B50, qword_1019A2190, 1, (uint64_t *)&unk_1019A2B70);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2B70, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2B50, qword_1019A21A8, 1, (uint64_t *)&unk_1019A2B80);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2B80, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2B50, qword_1019A21C0, 0, (uint64_t *)&unk_1019A2B90);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2B90, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2B50, qword_1019A22E0, 0, (uint64_t *)&unk_1019A2BA0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2BA0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2B50, qword_1019A2598, 0, (uint64_t *)&unk_1019A2BB0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2BB0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2B50, qword_1019A22F8, &qword_1019A2BC0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2BC0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2BC0, qword_1019A2310, 1, (uint64_t *)&unk_1019A2BD0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2BD0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2BC0, qword_1019A2328, 1, (uint64_t *)&unk_1019A2BE0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2BE0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2BC0, qword_1019A2340, 1, (uint64_t *)&unk_1019A2BF0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2BF0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2BC0, qword_1019A2358, 1, (uint64_t *)&unk_1019A2C00);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2C00, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2BC0, qword_1019A2370, 1, (uint64_t *)&unk_1019A2C10);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2C10, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2B50, qword_1019A25B0, &qword_1019A2C20);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2C20, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2C20, qword_1019A25C8, 0, (uint64_t *)&unk_1019A2C30);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2C30, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2C20, qword_1019A25E0, 1, (uint64_t *)&unk_1019A2C40);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2C40, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2C20, qword_1019A25F8, 0, (uint64_t *)&unk_1019A2C50);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2C50, (void *)&_mh_execute_header);
  sub_100B150C4(qword_1019A2AF0, &xmmword_1019A22C8, &qword_1019A2C60);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2C60, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2C60, qword_1019A22E0, 0, (uint64_t *)&unk_1019A2C70);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2C70, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2C60, qword_1019A2598, 0, (uint64_t *)&unk_1019A2C80);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2C80, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2C60, qword_1019A22F8, &qword_1019A2C90);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2C90, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2C90, qword_1019A2310, 1, (uint64_t *)&unk_1019A2CA0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2CA0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2C90, qword_1019A2328, 1, (uint64_t *)&unk_1019A2CB0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2CB0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2C90, qword_1019A2340, 1, (uint64_t *)&unk_1019A2CC0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2CC0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2C90, qword_1019A2358, 1, (uint64_t *)&unk_1019A2CD0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2CD0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2C90, qword_1019A2370, 1, (uint64_t *)&unk_1019A2CE0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2CE0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2C60, qword_1019A2550, &qword_1019A2CF0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2CF0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2CF0, qword_1019A2568, 0, (uint64_t *)&unk_1019A2D00);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2D00, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2CF0, qword_1019A2580, 1, (uint64_t *)&unk_1019A2D10);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2D10, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2C60, qword_1019A25B0, &qword_1019A2D20);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2D20, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D20, qword_1019A25C8, 0, (uint64_t *)&unk_1019A2D30);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2D30, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D20, qword_1019A25E0, 1, (uint64_t *)&unk_1019A2D40);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2D40, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D20, qword_1019A25F8, 0, (uint64_t *)&unk_1019A2D50);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2D50, (void *)&_mh_execute_header);
  sub_100B150C4(qword_1019A2AF0, &xmmword_1019A2388, &qword_1019A2D60);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2D60, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D60, qword_1019A23E8, 0, (uint64_t *)&unk_1019A2D70);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2D70, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D60, qword_1019A2418, 1, (uint64_t *)&unk_1019A2D80);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2D80, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D60, qword_1019A2538, 0, (uint64_t *)&unk_1019A2D90);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2D90, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D60, qword_1019A2448, 0, (uint64_t *)&unk_1019A2DA0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2DA0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D60, qword_1019A2490, 1, (uint64_t *)&unk_1019A2DB0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2DB0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D60, qword_1019A24A8, 0, (uint64_t *)&unk_1019A2DC0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2DC0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D60, qword_1019A24C0, 0, (uint64_t *)&unk_1019A2DD0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2DD0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D60, qword_1019A24D8, 0, (uint64_t *)&unk_1019A2DE0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2DE0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2D60, qword_1019A24F0, 0, (uint64_t *)&unk_1019A2DF0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2DF0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2D60, qword_1019A2A78, &qword_1019A2E00);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2E00, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E00, qword_1019A2A90, 1, (uint64_t *)&unk_1019A2E10);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2E10, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E00, qword_1019A2AA8, 1, (uint64_t *)&unk_1019A2E20);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2E20, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E00, qword_1019A2AC0, 2, (uint64_t *)&unk_1019A2E30);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2E30, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E00, qword_1019A2AD8, 0, (uint64_t *)&unk_1019A2E40);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2E40, (void *)&_mh_execute_header);
  sub_100B150C4(qword_1019A2AF0, &xmmword_1019A2730, &qword_1019A2E50);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2E50, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A25C8, 0, (uint64_t *)&unk_1019A2E60);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2E60, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A2748, 0, (uint64_t *)&unk_1019A2E70);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2E70, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A2760, 0, (uint64_t *)&unk_1019A2E80);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2E80, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A2778, 1, (uint64_t *)&unk_1019A2E90);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2E90, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A2790, 1, (uint64_t *)&unk_1019A2EA0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2EA0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A27A8, 1, (uint64_t *)&unk_1019A2EB0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2EB0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A27C0, 0, (uint64_t *)&unk_1019A2EC0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2EC0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A27D8, 0, (uint64_t *)&unk_1019A2ED0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2ED0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A27F0, 0, (uint64_t *)&unk_1019A2EE0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2EE0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A2808, 1, (uint64_t *)&unk_1019A2EF0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2EF0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A2820, 2, (uint64_t *)&unk_1019A2F00);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2F00, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A2838, 0, (uint64_t *)&unk_1019A2F10);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2F10, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2E50, qword_1019A2850, 0, (uint64_t *)&unk_1019A2F20);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2F20, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2E50, qword_1019A2868, &qword_1019A2F30);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2F30, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2F30, qword_1019A2988, 0, (uint64_t *)&unk_1019A2F40);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2F40, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2F30, qword_1019A29A0, 0, (uint64_t *)&unk_1019A2F50);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2F50, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2F30, qword_1019A29B8, 0, (uint64_t *)&unk_1019A2F60);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2F60, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2F30, qword_1019A29D0, 0, (uint64_t *)&unk_1019A2F70);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2F70, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2E50, qword_1019A28B0, &qword_1019A2F80);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2F80, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2F80, qword_1019A25C8, 0, (uint64_t *)&unk_1019A2F90);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2F90, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2F80, qword_1019A28C8, 0, (uint64_t *)&unk_1019A2FA0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2FA0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2F80, qword_1019A28E0, 0, (uint64_t *)&unk_1019A2FB0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2FB0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2F80, qword_1019A28F8, 0, (uint64_t *)&unk_1019A2FC0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2FC0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2F80, qword_1019A2910, 0, (uint64_t *)&unk_1019A2FD0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2FD0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2F80, qword_1019A2928, &qword_1019A2FE0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A2FE0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2FE0, qword_1019A2988, 0, (uint64_t *)&unk_1019A2FF0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A2FF0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2FE0, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3000);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3000, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2FE0, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3010);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3010, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2FE0, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3020);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3020, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2FE0, qword_1019A29E8, 0, (uint64_t *)&unk_1019A3030);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3030, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A2FE0, qword_1019A2A00, 0, (uint64_t *)&unk_1019A3040);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3040, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2E50, qword_1019A2898, &qword_1019A3050);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3050, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3050, qword_1019A25C8, 0, (uint64_t *)&unk_1019A3060);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3060, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3050, qword_1019A2940, &qword_1019A3070);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3070, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3070, qword_1019A2988, 0, (uint64_t *)&unk_1019A3080);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3080, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3070, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3090);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3090, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3070, qword_1019A29B8, 0, (uint64_t *)&unk_1019A30A0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A30A0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3070, qword_1019A29D0, 0, (uint64_t *)&unk_1019A30B0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A30B0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3070, qword_1019A29E8, 0, (uint64_t *)&unk_1019A30C0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A30C0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3070, qword_1019A2A00, 0, (uint64_t *)&unk_1019A30D0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A30D0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3050, qword_1019A2958, &qword_1019A30E0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A30E0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A30E0, qword_1019A2988, 0, (uint64_t *)&unk_1019A30F0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A30F0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A30E0, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3100);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3100, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A30E0, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3110);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3110, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A30E0, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3120);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3120, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A30E0, qword_1019A29E8, 0, (uint64_t *)&unk_1019A3130);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3130, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A30E0, qword_1019A2A00, 0, (uint64_t *)&unk_1019A3140);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3140, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3050, qword_1019A2970, &qword_1019A3150);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3150, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3150, qword_1019A2988, 0, (uint64_t *)&unk_1019A3160);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3160, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3150, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3170);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3170, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3150, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3180);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3180, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3150, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3190);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3190, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3150, qword_1019A29E8, 0, (uint64_t *)&unk_1019A31A0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A31A0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3150, qword_1019A2A00, 0, (uint64_t *)&unk_1019A31B0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A31B0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2E50, qword_1019A2880, &qword_1019A31C0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A31C0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A31C0, qword_1019A25C8, 0, (uint64_t *)&unk_1019A31D0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A31D0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A31C0, qword_1019A2940, &qword_1019A31E0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A31E0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A31E0, qword_1019A2988, 0, (uint64_t *)&unk_1019A31F0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A31F0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A31E0, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3200);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3200, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A31E0, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3210);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3210, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A31E0, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3220);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3220, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A31E0, qword_1019A29E8, 0, (uint64_t *)&unk_1019A3230);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3230, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A31E0, qword_1019A2A00, 0, (uint64_t *)&unk_1019A3240);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3240, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A31C0, qword_1019A2958, &qword_1019A3250);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3250, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3250, qword_1019A2988, 0, (uint64_t *)&unk_1019A3260);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3260, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3250, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3270);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3270, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3250, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3280);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3280, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3250, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3290);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3290, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3250, qword_1019A29E8, 0, (uint64_t *)&unk_1019A32A0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A32A0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3250, qword_1019A2A00, 0, (uint64_t *)&unk_1019A32B0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A32B0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A31C0, qword_1019A2970, &qword_1019A32C0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A32C0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A32C0, qword_1019A2988, 0, (uint64_t *)&unk_1019A32D0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A32D0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A32C0, qword_1019A29A0, 0, (uint64_t *)&unk_1019A32E0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A32E0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A32C0, qword_1019A29B8, 0, (uint64_t *)&unk_1019A32F0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A32F0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A32C0, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3300);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3300, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A32C0, qword_1019A29E8, 0, (uint64_t *)&unk_1019A3310);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3310, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A32C0, qword_1019A2A00, 0, (uint64_t *)&unk_1019A3320);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3320, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A2E50, qword_1019A2A18, &qword_1019A3330);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3330, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3330, qword_1019A2A30, 0, (uint64_t *)&unk_1019A3340);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3340, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3330, qword_1019A2A48, 0, (uint64_t *)&unk_1019A3350);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3350, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3330, qword_1019A2A60, 0, (uint64_t *)&unk_1019A3360);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3360, (void *)&_mh_execute_header);
  sub_100B150C4(qword_1019A2AF0, &xmmword_1019A2670, &qword_1019A3370);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3370, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3370, qword_1019A23D0, 0, (uint64_t *)&unk_1019A3380);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3380, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3370, qword_1019A2688, 0, (uint64_t *)&unk_1019A3390);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3390, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3370, qword_1019A26A0, 0, (uint64_t *)&unk_1019A33A0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A33A0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3370, qword_1019A26B8, 0, (uint64_t *)&unk_1019A33B0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A33B0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3370, qword_1019A26D0, 0, (uint64_t *)&unk_1019A33C0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A33C0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3370, qword_1019A26E8, 0, (uint64_t *)&unk_1019A33D0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A33D0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3370, qword_1019A2700, 0, (uint64_t *)&unk_1019A33E0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A33E0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3370, qword_1019A2718, 0, (uint64_t *)&unk_1019A33F0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A33F0, (void *)&_mh_execute_header);
  sub_1010DDBC0(__p, "CarrierBundle");
  sub_100B14EBC((__int128 *)__p, &qword_1019A3400);
  if (v2 < 0) {
    operator delete(__p[0]);
  }
  __cxa_atexit((void (*)(void *))sub_100E75130, &qword_1019A3400, (void *)&_mh_execute_header);
  sub_100B150C4(qword_1019A3400, &xmmword_1019A2160, &qword_1019A3410);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3410, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3410, qword_1019A2178, 0, (uint64_t *)&unk_1019A3420);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3420, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3410, qword_1019A2190, 1, (uint64_t *)&unk_1019A3430);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3430, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3410, qword_1019A21A8, 1, (uint64_t *)&unk_1019A3440);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3440, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3410, qword_1019A21C0, 0, (uint64_t *)&unk_1019A3450);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3450, (void *)&_mh_execute_header);
  sub_100B150C4(qword_1019A3400, &xmmword_1019A21F0, &qword_1019A3460);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3460, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3460, qword_1019A2220, 0, (uint64_t *)&unk_1019A3470);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3470, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3460, qword_1019A2250, 0, (uint64_t *)&unk_1019A3480);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3480, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3460, qword_1019A2280, 0, (uint64_t *)&unk_1019A3490);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3490, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3460, qword_1019A2298, 0, (uint64_t *)&unk_1019A34A0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A34A0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3460, qword_1019A22B0, &qword_1019A34B0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A34B0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A34B0, (uint64_t *)&xmmword_1019A2148, &qword_1019A34C0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A34C0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A34C0, qword_1019A22E0, 0, (uint64_t *)&unk_1019A34D0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A34D0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A34C0, qword_1019A2598, 0, (uint64_t *)&unk_1019A34E0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A34E0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A34C0, qword_1019A22F8, &qword_1019A34F0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A34F0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A34F0, qword_1019A2310, 1, (uint64_t *)&unk_1019A3500);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3500, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A34F0, qword_1019A2328, 1, (uint64_t *)&unk_1019A3510);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3510, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A34F0, qword_1019A2340, 1, (uint64_t *)&unk_1019A3520);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3520, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A34F0, qword_1019A2358, 1, (uint64_t *)&unk_1019A3530);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3530, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A34F0, qword_1019A2370, 1, (uint64_t *)&unk_1019A3540);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3540, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A34C0, qword_1019A25B0, &qword_1019A3550);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3550, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3550, qword_1019A25C8, 0, (uint64_t *)&unk_1019A3560);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3560, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3550, qword_1019A25E0, 1, (uint64_t *)&unk_1019A3570);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3570, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3550, qword_1019A25F8, 0, (uint64_t *)&unk_1019A3580);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3580, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A34B0, (uint64_t *)&xmmword_1019A22C8, &qword_1019A3590);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3590, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3590, qword_1019A22E0, 0, (uint64_t *)&unk_1019A35A0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A35A0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3590, qword_1019A2598, 0, (uint64_t *)&unk_1019A35B0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A35B0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3590, qword_1019A22F8, &qword_1019A35C0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A35C0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A35C0, qword_1019A2310, 1, (uint64_t *)&unk_1019A35D0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A35D0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A35C0, qword_1019A2328, 1, (uint64_t *)&unk_1019A35E0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A35E0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A35C0, qword_1019A2340, 1, (uint64_t *)&unk_1019A35F0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A35F0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A35C0, qword_1019A2358, 1, (uint64_t *)&unk_1019A3600);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3600, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A35C0, qword_1019A2370, 1, (uint64_t *)&unk_1019A3610);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3610, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3590, qword_1019A2550, &qword_1019A3620);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3620, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3620, qword_1019A2568, 0, (uint64_t *)&unk_1019A3630);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3630, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3620, qword_1019A2580, 1, (uint64_t *)&unk_1019A3640);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3640, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3590, qword_1019A25B0, &qword_1019A3650);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3650, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3650, qword_1019A25C8, 0, (uint64_t *)&unk_1019A3660);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3660, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3650, qword_1019A25E0, 1, (uint64_t *)&unk_1019A3670);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3670, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3650, qword_1019A25F8, 0, (uint64_t *)&unk_1019A3680);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3680, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A34B0, qword_1019A23A0, &qword_1019A3690);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3690, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3690, (uint64_t *)&xmmword_1019A2388, &qword_1019A36A0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A36A0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A36A0, qword_1019A23E8, 0, (uint64_t *)&unk_1019A36B0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A36B0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A36A0, qword_1019A24A8, 0, (uint64_t *)&unk_1019A36C0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A36C0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A36A0, qword_1019A24C0, 0, (uint64_t *)&unk_1019A36D0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A36D0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A36A0, qword_1019A24D8, 0, (uint64_t *)&unk_1019A36E0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A36E0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A36A0, qword_1019A24F0, 0, (uint64_t *)&unk_1019A36F0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A36F0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A36A0, qword_1019A23B8, &qword_1019A3700);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3700, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3700, qword_1019A2430, 1, (uint64_t *)&unk_1019A3710);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3710, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A36A0, qword_1019A2A78, &qword_1019A3720);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3720, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3720, qword_1019A2A90, 1, (uint64_t *)&unk_1019A3730);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3730, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3720, qword_1019A2AA8, 1, (uint64_t *)&unk_1019A3740);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3740, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3720, qword_1019A2AC0, 2, (uint64_t *)&unk_1019A3750);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3750, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3720, qword_1019A2AD8, 0, (uint64_t *)&unk_1019A3760);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3760, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3700, qword_1019A2460, &qword_1019A3770);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3770, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3770, qword_1019A23D0, 0, (uint64_t *)&unk_1019A3780);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3780, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3770, qword_1019A2478, 0, (uint64_t *)&unk_1019A3790);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3790, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A36A0, qword_1019A2400, &qword_1019A37A0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A37A0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37A0, qword_1019A2508, 1, (uint64_t *)&unk_1019A37B0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A37B0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3690, (uint64_t *)&xmmword_1019A2730, &qword_1019A37C0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A37C0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A25C8, 0, (uint64_t *)&unk_1019A37D0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A37D0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A2748, 0, (uint64_t *)&unk_1019A37E0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A37E0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A2760, 0, (uint64_t *)&unk_1019A37F0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A37F0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A2778, 1, (uint64_t *)&unk_1019A3800);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3800, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A2790, 1, (uint64_t *)&unk_1019A3810);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3810, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A27A8, 1, (uint64_t *)&unk_1019A3820);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3820, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A27C0, 0, (uint64_t *)&unk_1019A3830);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3830, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A27D8, 0, (uint64_t *)&unk_1019A3840);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3840, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A27F0, 0, (uint64_t *)&unk_1019A3850);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3850, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A2808, 1, (uint64_t *)&unk_1019A3860);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3860, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A2820, 2, (uint64_t *)&unk_1019A3870);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3870, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A2838, 0, (uint64_t *)&unk_1019A3880);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3880, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A37C0, qword_1019A2850, 0, (uint64_t *)&unk_1019A3890);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3890, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A37C0, qword_1019A2868, &qword_1019A38A0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A38A0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A38A0, qword_1019A2988, 0, (uint64_t *)&unk_1019A38B0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A38B0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A38A0, qword_1019A29A0, 0, (uint64_t *)&unk_1019A38C0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A38C0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A38A0, qword_1019A29B8, 0, (uint64_t *)&unk_1019A38D0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A38D0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A38A0, qword_1019A29D0, 0, (uint64_t *)&unk_1019A38E0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A38E0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A37C0, qword_1019A28B0, &qword_1019A38F0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A38F0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A38F0, qword_1019A25C8, 0, (uint64_t *)&unk_1019A3900);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3900, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A38F0, qword_1019A28C8, 0, (uint64_t *)&unk_1019A3910);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3910, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A38F0, qword_1019A28E0, 0, (uint64_t *)&unk_1019A3920);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3920, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A38F0, qword_1019A28F8, 0, (uint64_t *)&unk_1019A3930);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3930, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A38F0, qword_1019A2910, 0, (uint64_t *)&unk_1019A3940);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3940, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A38F0, qword_1019A2928, &qword_1019A3950);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3950, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3950, qword_1019A2988, 0, (uint64_t *)&unk_1019A3960);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3960, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3950, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3970);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3970, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3950, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3980);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3980, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3950, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3990);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3990, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3950, qword_1019A29E8, 0, (uint64_t *)&unk_1019A39A0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A39A0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3950, qword_1019A2A00, 0, (uint64_t *)&unk_1019A39B0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A39B0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A37C0, qword_1019A2898, &qword_1019A39C0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A39C0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A39C0, qword_1019A25C8, 0, (uint64_t *)&unk_1019A39D0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A39D0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A39C0, qword_1019A2940, &qword_1019A39E0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A39E0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A39E0, qword_1019A2988, 0, (uint64_t *)&unk_1019A39F0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A39F0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A39E0, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3A00);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3A00, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A39E0, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3A10);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3A10, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A39E0, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3A20);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3A20, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A39E0, qword_1019A29E8, 0, (uint64_t *)&unk_1019A3A30);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3A30, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A39E0, qword_1019A2A00, 0, (uint64_t *)&unk_1019A3A40);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3A40, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A39C0, qword_1019A2958, &qword_1019A3A50);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3A50, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3A50, qword_1019A2988, 0, (uint64_t *)&unk_1019A3A60);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3A60, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3A50, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3A70);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3A70, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3A50, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3A80);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3A80, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3A50, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3A90);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3A90, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3A50, qword_1019A29E8, 0, (uint64_t *)&unk_1019A3AA0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3AA0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3A50, qword_1019A2A00, 0, (uint64_t *)&unk_1019A3AB0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3AB0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A39C0, qword_1019A2970, &qword_1019A3AC0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3AC0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3AC0, qword_1019A2988, 0, (uint64_t *)&unk_1019A3AD0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3AD0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3AC0, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3AE0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3AE0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3AC0, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3AF0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3AF0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3AC0, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3B00);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3B00, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3AC0, qword_1019A29E8, 0, (uint64_t *)&unk_1019A3B10);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3B10, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3AC0, qword_1019A2A00, 0, (uint64_t *)&unk_1019A3B20);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3B20, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A37C0, qword_1019A2880, &qword_1019A3B30);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3B30, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3B30, qword_1019A25C8, 0, (uint64_t *)&unk_1019A3B40);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3B40, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3B30, qword_1019A2940, &qword_1019A3B50);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3B50, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3B50, qword_1019A2988, 0, (uint64_t *)&unk_1019A3B60);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3B60, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3B50, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3B70);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3B70, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3B50, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3B80);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3B80, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3B50, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3B90);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3B90, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3B50, qword_1019A29E8, 0, (uint64_t *)&unk_1019A3BA0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3BA0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3B50, qword_1019A2A00, 0, (uint64_t *)&unk_1019A3BB0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3BB0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3B30, qword_1019A2958, &qword_1019A3BC0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3BC0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3BC0, qword_1019A2988, 0, (uint64_t *)&unk_1019A3BD0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3BD0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3BC0, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3BE0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3BE0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3BC0, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3BF0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3BF0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3BC0, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3C00);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3C00, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3BC0, qword_1019A29E8, 0, (uint64_t *)&unk_1019A3C10);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3C10, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3BC0, qword_1019A2A00, 0, (uint64_t *)&unk_1019A3C20);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3C20, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3B30, qword_1019A2970, &qword_1019A3C30);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3C30, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3C30, qword_1019A2988, 0, (uint64_t *)&unk_1019A3C40);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3C40, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3C30, qword_1019A29A0, 0, (uint64_t *)&unk_1019A3C50);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3C50, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3C30, qword_1019A29B8, 0, (uint64_t *)&unk_1019A3C60);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3C60, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3C30, qword_1019A29D0, 0, (uint64_t *)&unk_1019A3C70);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3C70, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3C30, qword_1019A29E8, 0, (uint64_t *)&unk_1019A3C80);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3C80, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3C30, qword_1019A2A00, 0, (uint64_t *)&unk_1019A3C90);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3C90, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A37C0, qword_1019A2A18, &qword_1019A3CA0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3CA0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3CA0, qword_1019A2A30, 0, (uint64_t *)&unk_1019A3CB0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3CB0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3CA0, qword_1019A2A48, 0, (uint64_t *)&unk_1019A3CC0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3CC0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3CA0, qword_1019A2A60, 0, (uint64_t *)&unk_1019A3CD0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3CD0, (void *)&_mh_execute_header);
  sub_100B162CC(qword_1019A3460, (uint64_t *)&xmmword_1019A2670, &qword_1019A3CE0);
  __cxa_atexit((void (*)(void *))sub_100E75134, &qword_1019A3CE0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3CE0, qword_1019A23D0, 0, (uint64_t *)&unk_1019A3CF0);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3CF0, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3CE0, qword_1019A2688, 0, (uint64_t *)&unk_1019A3D00);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3D00, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3CE0, qword_1019A26A0, 0, (uint64_t *)&unk_1019A3D10);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3D10, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3CE0, qword_1019A26B8, 0, (uint64_t *)&unk_1019A3D20);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3D20, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3CE0, qword_1019A26D0, 0, (uint64_t *)&unk_1019A3D30);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3D30, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3CE0, qword_1019A26E8, 0, (uint64_t *)&unk_1019A3D40);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3D40, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3CE0, qword_1019A2700, 0, (uint64_t *)&unk_1019A3D50);
  __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3D50, (void *)&_mh_execute_header);
  sub_100B16C88(qword_1019A3CE0, qword_1019A2718, 0, (uint64_t *)&unk_1019A3D60);
  return __cxa_atexit((void (*)(void *))sub_100E75138, &unk_1019A3D60, (void *)&_mh_execute_header);
}

void sub_100E798F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E79910(uint64_t a1, unsigned int a2, const std::string *a3, __int128 *a4, __int128 *a5)
{
  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 4) = a2;
  __int16 v10 = (void *)(a1 + 8);
  __int16 v11 = (char *)sub_100DD8CC8(a2);
  sub_1010DDBC0(v10, v11);
  __int16 v12 = (_OWORD *)(a1 + 32);
  if ((char)a3->__r_.__value_.__s.__size_ < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 32), a3->__r_.__value_.__l.__data_, a3->__r_.__value_.__l.__size_);
  }

  else
  {
    __int128 v13 = *(_OWORD *)&a3->__r_.__value_.__l.__data_;
    *(void *)(a1 + 48) = a3->__r_.__value_.__l.__cap_;
    *__int16 v12 = v13;
  }

  if (*((char *)a4 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 56), *(void **)a4, *((void *)a4 + 1));
  }

  else
  {
    __int128 v14 = *a4;
    *(void *)(a1 + 72) = *((void *)a4 + 2);
    *(_OWORD *)(a1 + 56) = v14;
  }

  *(_BYTE *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  if (*((char *)a5 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 88), *(void **)a5, *((void *)a5 + 1));
  }

  else
  {
    __int128 v15 = *a5;
    *(void *)(a1 + 104) = *((void *)a5 + 2);
    *(_OWORD *)(a1 + 88) = v15;
  }

  *(void *)(a1 + 192) = 0LL;
  *(void *)(a1 + 184) = a1 + 192;
  *(_OWORD *)(a1 + 112) = xmmword_101350110;
  *(void *)(a1 + 128) = 0x643F000000LL;
  *(void *)(a1 + 136) = 0x40C5180000000000LL;
  *(_DWORD *)(a1 + 144) = 1181376512;
  *(void *)(a1 + 156) = 0LL;
  *(void *)(a1 + 148) = 0LL;
  *(_DWORD *)(a1 + 164) = 0;
  *(void *)(a1 + 168) = 0x10000000100LL;
  *(_WORD *)(a1 + 176) = 256;
  *(_BYTE *)(a1 + 178) = 1;
  *(void *)(a1 + 224) = 0LL;
  *(void *)(a1 + 216) = 0LL;
  *(void *)(a1 + 20sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  *(void *)(a1 + 208) = a1 + 216;
  __int16 v16 = sub_100DD8CC8(a2);
  sub_100987184(a1 + 232, v16);
  *(void *)(a1 + 288) = 0LL;
  *(void *)(a1 + 296) = 0LL;
  *(void *)(a1 + 304) = 0LL;
  int v17 = (const char *)(a1 + 32);
  int v18 = mkdir(v17, 0x1C0u);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888F98);
  }
  uint64_t v19 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v20 = a1 + 32;
    *(_DWORD *)std::stringbuf::string_type buf = 136315394;
    uint64_t v30 = v20;
    __int16 v31 = 1024;
    int v32 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "TILE: creating directory, %s, ret, %d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888F98);
    }
    uint64_t v22 = a1 + 32;
    int v25 = 136315394;
    uint64_t v26 = v22;
    __int16 v27 = 1024;
    int v28 = v18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: creating directory, %s, ret, %d",  (const char *)&v25,  18);
    int v24 = (uint8_t *)v23;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLTilesSet::CLTilesSet(CLTilesManager_Type::TileType, const std::string &, const std::string &, const std::string &)",  "%s\n",  v23);
    if (v24 != buf) {
      free(v24);
    }
  }

  sub_100C3A7F4(a2, a3);
  return a1;
}

void sub_100E79C7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, void **a14)
{
  uint64_t v19 = *(void *)(v14 + 304);
  *(void *)(v14 + 304) = 0LL;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  uint64_t v20 = *(void *)(v14 + 296);
  *(void *)(v14 + 296) = 0LL;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  }
  sub_1003E281C(a12);
  sub_100E79D34(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_100E79D34(uint64_t a1)
{
  return a1;
}

void *sub_100E79D70(void *a1)
{
  if (qword_101934850 != -1) {
    dispatch_once(&qword_101934850, &stru_101888FB8);
  }
  char v2 = (os_log_s *)qword_101934858;
  if (os_log_type_enabled((os_log_t)qword_101934858, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "TilesSet, Initialize CLTilesSetCollection",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934850 != -1) {
      dispatch_once(&qword_101934850, &stru_101888FB8);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934858,  2LL,  "TilesSet, Initialize CLTilesSetCollection",  v6,  2);
    os_activity_scope_state_s v5 = (uint8_t *)v4;
    sub_10029211C("Generic", 1LL, 0, 2LL, "CLTilesSetCollection::CLTilesSetCollection()", "%s\n", v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  return a1;
}

void sub_100E79F0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

__int128 *sub_100E79F2C(__int128 *a1, __int128 *a2)
{
  uint64_t v3 = *((void *)a2 + 2);
  __int128 v4 = *a2;
  *((void *)a2 + 1) = 0LL;
  *((void *)a2 + 2) = 0LL;
  *(void *)a2 = 0LL;
  __int128 v5 = *a1;
  *a1 = v4;
  __int128 v8 = v5;
  uint64_t v6 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v3;
  uint64_t v9 = v6;
  __int16 v10 = (void **)&v8;
  sub_1009708B4(&v10);
  return a1;
}

uint64_t sub_100E79F88(void *a1, unsigned int a2)
{
  if (a2 >= 0xD) {
    sub_101274ADC();
  }
  if (a2 >= (unint64_t)((uint64_t)(a1[1] - *a1) >> 3))
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101888FD8);
    }
    __int128 v5 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_FAULT))
    {
      uint64_t v6 = (uint64_t)(a1[1] - *a1) >> 3;
      *(_DWORD *)std::stringbuf::string_type buf = 68290051;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 1025;
      unsigned int v16 = a2;
      __int16 v17 = 2049;
      uint64_t v18 = v6;
      __int16 v19 = 2082;
      uint64_t v20 = "assert";
      __int16 v21 = 2081;
      uint64_t v22 = "index < fTileSets.size()";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Index out of bounds, index:%{private}d, size:%{private}lu, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x36u);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101888FD8);
      }
    }

    int v7 = (os_log_s *)qword_101934838;
    if (os_signpost_enabled((os_log_t)qword_101934838))
    {
      uint64_t v8 = (uint64_t)(a1[1] - *a1) >> 3;
      *(_DWORD *)std::stringbuf::string_type buf = 68290051;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 1025;
      unsigned int v16 = a2;
      __int16 v17 = 2049;
      uint64_t v18 = v8;
      __int16 v19 = 2082;
      uint64_t v20 = "assert";
      __int16 v21 = 2081;
      uint64_t v22 = "index < fTileSets.size()";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Index out of bounds",  "{msg%{public}.0s:Index out of bounds, index:%{private}d, size:%{private}lu, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x36u);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101888FD8);
      }
    }

    uint64_t v9 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_INFO))
    {
      uint64_t v10 = (uint64_t)(a1[1] - *a1) >> 3;
      *(_DWORD *)std::stringbuf::string_type buf = 68290051;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 1025;
      unsigned int v16 = a2;
      __int16 v17 = 2049;
      uint64_t v18 = v10;
      __int16 v19 = 2082;
      uint64_t v20 = "assert";
      __int16 v21 = 2081;
      uint64_t v22 = "index < fTileSets.size()";
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Index out of bounds, index:%{private}d, size:%{private}lu, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x36u);
    }

    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/Tiles/CLTilesSet.mm",  122,  "getTilesSet");
  }

  return *(void *)(*a1 + 8LL * a2);
}

uint64_t sub_100E7A284(void *a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  if (*(_DWORD *)(*a3 + 4) != a2)
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101888FD8);
    }
    uint64_t v8 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_FAULT))
    {
      unsigned int v9 = *(_DWORD *)(*a3 + 4);
      *(_DWORD *)std::stringbuf::string_type buf = 67109376;
      unsigned int v17 = v9;
      __int16 v18 = 1024;
      unsigned int v19 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "Mismatch of tile type inserting CLTilesSet. fTileType: %d, tileType: %d",  buf,  0xEu);
    }

    BOOL v10 = sub_1002921D0(115, 0);
    uint64_t result = 0LL;
    if (!v10) {
      return result;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101888FD8);
    }
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  17LL,  "Mismatch of tile type inserting CLTilesSet. fTileType: %d, tileType: %d",  &v15);
LABEL_21:
    uint64_t v14 = (uint8_t *)v11;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLTilesSetCollection::addTilesSet(CLTilesManager_Type::TileType, std::unique_ptr<CLTilesSet>)",  "%s\n",  v11);
    if (v14 != buf) {
      free(v14);
    }
    return 0LL;
  }

  if (a2 < 0xD)
  {
    uint64_t v6 = (uint64_t *)(*a1 + 8LL * a2);
    *a3 = 0LL;
    sub_100966394(v6, v5);
    return 1LL;
  }

  if (qword_101934830 != -1) {
    dispatch_once(&qword_101934830, &stru_101888FD8);
  }
  int v12 = (os_log_s *)qword_101934838;
  if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 67109376;
    unsigned int v17 = a2;
    __int16 v18 = 1024;
    unsigned int v19 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "Invalid TileType value. tileType %d, index: %d",  buf,  0xEu);
  }

  BOOL v13 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v13)
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101888FD8);
    }
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934838,  17LL,  "Invalid TileType value. tileType %d, index: %d",  &v15);
    goto LABEL_21;
  }

  return result;
}

void sub_100E7A5A0(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

void sub_100E7A5CC(id a1)
{
  qword_101934858 = (uint64_t)os_log_create("com.apple.locationd.Position", "GeneralCLX");
}

void sub_100E7A5F8(id a1)
{
  qword_101934838 = (uint64_t)os_log_create("com.apple.locationd.Position", "Position");
}

void *sub_100E7A624(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_10000717C(a1, a2);
    __int128 v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }

  return a1;
}

void sub_100E7A68C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

  ;
}

uint64_t sub_100E7A6D8(uint64_t a1, void *a2)
{
  *(void *)a1 = 0LL;
  uint64_t v4 = a1 + 8;
  sub_1010DDBC0((void *)(a1 + 8), "ff:ff:ff:ff:ff:ff");
  *(int64x2_t *)(a1 + 32) = vdupq_n_s64(0xC076800000000000LL);
  *(_OWORD *)(a1 + 48) = xmmword_10130B6C0;
  *(void *)(a1 + 64) = 0xBFF0000000000000LL;
  *(_DWORD *)(a1 + 72) = -1;
  *(void *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0xBFF0000000000000LL;
  uint64_t v5 = (void **)(a1 + 88);
  sub_1010DDBC0((void *)(a1 + 88), "Unknown");
  *(void *)(a1 + 112) = 0xBFF0000000000000LL;
  *(void *)a1 = a2;
  sub_1010DDBC0(&v14, (char *)objc_msgSend(objc_msgSend(a2, "objectForKey:", @"mac"), "UTF8String"));
  *(_OWORD *)uint64_t v4 = v14;
  *(void *)(v4 + 16) = v15;
  objc_msgSend(objc_msgSend(a2, "objectForKey:", @"latitude"), "doubleValue");
  *(void *)(a1 + 32) = v6;
  objc_msgSend(objc_msgSend(a2, "objectForKey:", @"longitude"), "doubleValue");
  *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v7;
  objc_msgSend(objc_msgSend(a2, "objectForKey:", @"altitude"), "doubleValue");
  *(void *)(a1 + 48) = v8;
  objc_msgSend(objc_msgSend(a2, "objectForKey:", @"horizontalAccuracy"), "doubleValue");
  *(void *)(a1 + 56) = v9;
  objc_msgSend(objc_msgSend(a2, "objectForKey:", @"verticalAccuracy"), "doubleValue");
  *(void *)(a1 + 64) = v10;
  *(_DWORD *)(a1 + 72) = objc_msgSend(objc_msgSend(a2, "objectForKey:", @"reach"), "intValue");
  objc_msgSend(objc_msgSend(a2, "objectForKey:", @"stationaryTimeInSeconds"), "doubleValue");
  *(void *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v11;
  sub_1010DDBC0(&v14, (char *)objc_msgSend(objc_msgSend(a2, "objectForKey:", @"loiType"), "UTF8String"));
  *(_OWORD *)uint64_t v5 = v14;
  *(void *)(a1 + 104) = v15;
  objc_msgSend(objc_msgSend(a2, "objectForKey:", @"lastUpdated"), "doubleValue");
  *(void *)(a1 + 112) = v12;
  return a1;
}

void sub_100E7A8B4(_Unwind_Exception *exception_object)
{
}

double sub_100E7A8F4(uint64_t a1)
{
  return vabdd_f64(CFAbsoluteTimeGetCurrent(), *(double *)(a1 + 112));
}

uint64_t sub_100E7A91C@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  int v4 = *(char *)(a1 + 31);
  if (v4 >= 0) {
    uint64_t v5 = a1 + 8;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  if (v4 >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    uint64_t v6 = *(void *)(a1 + 16);
  }
  sub_10000CF44(&v34, v5, v6);
  uint64_t v7 = sub_10000CF44(&v34, (uint64_t)", ", 2LL);
  uint64_t v8 = *v7;
  *(uint64_t *)((char *)v7 + *(void *)(*v7 - 24) + 16) = 8LL;
  *(_DWORD *)((char *)v7 + *(void *)(v8 - 24) + 8) = *(_DWORD *)((_BYTE *)v7 + *(void *)(v8 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(*(double *)(a1 + 32));
  uint64_t v9 = sub_10000CF44(&v34, (uint64_t)", ", 2LL);
  uint64_t v10 = *v9;
  *(uint64_t *)((char *)v9 + *(void *)(*v9 - 24) + 16) = 8LL;
  *(_DWORD *)((char *)v9 + *(void *)(v10 - 24) + 8) = *(_DWORD *)((_BYTE *)v9 + *(void *)(v10 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(*(double *)(a1 + 40));
  uint64_t v11 = sub_10000CF44(&v34, (uint64_t)", alt, ", 7LL);
  uint64_t v12 = *v11;
  *(uint64_t *)((char *)v11 + *(void *)(*v11 - 24) + 16) = 1LL;
  *(_DWORD *)((char *)v11 + *(void *)(v12 - 24) + 8) = *(_DWORD *)((_BYTE *)v11 + *(void *)(v12 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(*(double *)(a1 + 48));
  BOOL v13 = sub_10000CF44(&v34, (uint64_t)", hacc, ", 8LL);
  uint64_t v14 = *v13;
  *(uint64_t *)((char *)v13 + *(void *)(*v13 - 24) + 16) = 1LL;
  *(_DWORD *)((char *)v13 + *(void *)(v14 - 24) + 8) = *(_DWORD *)((_BYTE *)v13 + *(void *)(v14 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(*(double *)(a1 + 56));
  uint64_t v15 = sub_10000CF44(&v34, (uint64_t)", vacc, ", 8LL);
  uint64_t v16 = *v15;
  *(uint64_t *)((char *)v15 + *(void *)(*v15 - 24) + 16) = 1LL;
  *(_DWORD *)((char *)v15 + *(void *)(v16 - 24) + 8) = *(_DWORD *)((_BYTE *)v15 + *(void *)(v16 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(*(double *)(a1 + 64));
  unsigned int v17 = sub_10000CF44(&v34, (uint64_t)", reach, ", 9LL);
  uint64_t v18 = *v17;
  *(uint64_t *)((char *)v17 + *(void *)(*v17 - 24) + 16) = 0LL;
  *(_DWORD *)((char *)v17 + *(void *)(v18 - 24) + 8) = *(_DWORD *)((_BYTE *)v17 + *(void *)(v18 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(v17, *(unsigned int *)(a1 + 72));
  unsigned int v19 = sub_10000CF44(&v34, (uint64_t)", stationaryTime, ", 18LL);
  uint64_t v20 = *v19;
  *(uint64_t *)((char *)v19 + *(void *)(*v19 - 24) + 16) = 1LL;
  *(_DWORD *)((char *)v19 + *(void *)(v20 - 24) + 8) = *(_DWORD *)((_BYTE *)v19 + *(void *)(v20 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(*(double *)(a1 + 80));
  __int16 v21 = sub_10000CF44(&v34, (uint64_t)", loiType, ", 11LL);
  int v22 = *(char *)(a1 + 111);
  if (v22 >= 0) {
    uint64_t v23 = a1 + 88;
  }
  else {
    uint64_t v23 = *(void *)(a1 + 88);
  }
  if (v22 >= 0) {
    uint64_t v24 = *(unsigned __int8 *)(a1 + 111);
  }
  else {
    uint64_t v24 = *(void *)(a1 + 96);
  }
  sub_10000CF44(v21, v23, v24);
  int v25 = sub_10000CF44(&v34, (uint64_t)", lastUpdated, ", 15LL);
  uint64_t v26 = *v25;
  *(uint64_t *)((char *)v25 + *(void *)(*v25 - 24) + 16) = 1LL;
  *(_DWORD *)((char *)v25 + *(void *)(v26 - 24) + 8) = *(_DWORD *)((_BYTE *)v25 + *(void *)(v26 - 24) + 8) & 0xFFFFFEFB | 4;
  std::ostream::operator<<(*(double *)(a1 + 112));
  __int16 v27 = sub_10000CF44(&v34, (uint64_t)", age, ", 7LL);
  uint64_t v28 = *v27;
  *(uint64_t *)((char *)v27 + *(void *)(*v27 - 24) + 16) = 1LL;
  *(_DWORD *)((char *)v27 + *(void *)(v28 - 24) + 8) = *(_DWORD *)((_BYTE *)v27 + *(void *)(v28 - 24) + 8) & 0xFFFFFEFB | 4;
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v30 = (void *)std::ostream::operator<<(vabdd_f64(Current, *(double *)(a1 + 112)));
  sub_10000CF44(v30, (uint64_t)"s", 1LL);
  std::stringbuf::str(a2, &v35);
  *(void *)((char *)v33
  uint64_t v34 = v31;
  std::streambuf::~streambuf(&v35);
  return std::ios::~ios(&v36);
}

void sub_100E7ACD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100E7AF70(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v10 = v5++ >= 9;
      if (v10)
      {
        unint64_t v6 = 0LL;
        uint64_t v11 = OBJC_IVAR___PBDataReader__error;
        int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    uint64_t v11 = OBJC_IVAR___PBDataReader__error;
    int v12 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v12 || (v6 & 7) == 4) {
      break;
    }
    if ((v6 >> 3) == 2)
    {
      char v16 = 0;
      unsigned int v17 = 0;
      uint64_t v18 = 0LL;
      *(_BYTE *)(a1 + 20) |= 1u;
      while (1)
      {
        uint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        unint64_t v20 = v19 + 1;
        if (v19 == -1 || v20 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v21 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v20;
        v18 |= (unint64_t)(v21 & 0x7F) << v16;
        if ((v21 & 0x80) == 0) {
          goto LABEL_32;
        }
        v16 += 7;
        BOOL v10 = v17++ >= 9;
        if (v10)
        {
          LODWORD(v18) = 0;
          goto LABEL_34;
        }
      }

      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_32:
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v18) = 0;
      }
LABEL_34:
      *(_DWORD *)(a1 + 16) = v18;
    }

    else if ((v6 >> 3) == 1)
    {
      unint64_t v14 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v14 <= 0xFFFFFFFFFFFFFFF7LL && v14 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
      {
        uint64_t v15 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v14);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v14 + 8;
      }

      else
      {
        *(_BYTE *)(a2 + v11) = 1;
        uint64_t v15 = 0LL;
      }

      *(void *)(a1 + 8) = v15;
    }

    else
    {
      uint64_t result = PBReaderSkipValueWithTag(a2);
      if (!(_DWORD)result) {
        return result;
      }
    }
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_100E7B5F0(id a1)
{
  qword_10199EE18 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLBatchedDeviceMotionServiceSilo");
}

void sub_100E7B710( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E7BB2C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
}

void sub_100E7BF88(id a1)
{
  qword_1019347C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "BatchedSensor");
}

void *sub_100E7BFBC(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &off_101889060;
  result[1] = v3;
  return result;
}

uint64_t sub_100E7BFF0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_101889060;
  a2[1] = v2;
  return result;
}

id sub_100E7C00C(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  return _[*(id *)(a1 + 8) onBatchedData:a2 N:*a3];
}

uint64_t sub_100E7C01C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100E7C058()
{
  return &off_1018890D0;
}

uint64_t sub_100E7C064()
{
  dword_10199EDF0 = 800;
  __cxa_atexit((void (*)(void *))sub_100355650, qword_10199EDD8, (void *)&_mh_execute_header);
  sub_1010DDBC0(&xmmword_10199EDF8, "DmFp");
  dword_10199EE10 = 200;
  return __cxa_atexit((void (*)(void *))sub_100355650, &xmmword_10199EDF8, (void *)&_mh_execute_header);
}

void sub_100E7C0F0()
{
  if (sub_100231608())
  {
    unsigned __int8 v0 = operator new(0x68uLL);
    sub_100E61F40((uint64_t)v0, (uint64_t)"CLAccessoryMonitor", 1, 65280, 53);
    *unsigned __int8 v0 = &off_101889110;
    qword_1019A3D70 = (uint64_t)v0;
  }

void sub_100E7C148(_Unwind_Exception *a1)
{
}

uint64_t sub_100E7C15C()
{
  if (qword_10199EE28 != -1) {
    dispatch_once(&qword_10199EE28, &stru_1018890E0);
  }
  return qword_1019A3D70;
}

void sub_100E7C1A4(void *a1)
{
  uint64_t v1 = sub_100E61F94(a1);
  operator delete(v1);
}

double sub_100E7C1B8(uint64_t a1, int a2, double *a3)
{
  if (a2)
  {
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    char v4 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67240192;
      LODWORD(v22) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "[AccessoryMonitor] Unrecognized update interval notification %{public}d",  buf,  8u);
    }

    double v5 = 0.0;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101889168);
      }
      int v17 = 67240192;
      LODWORD(v18) = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  17LL,  "[AccessoryMonitor] Unrecognized update interval notification %{public}d",  &v17,  8);
      uint64_t v7 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CFTimeInterval CLAccessoryMonitor::minimumUpdateIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

  else
  {
    sub_100E62108(a1);
    if (*a3 <= 0.0) {
      BOOL v10 = &off_1018D4730;
    }
    else {
      BOOL v10 = &off_1018D4718;
    }
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    uint64_t v11 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_INFO))
    {
      double v12 = *a3;
      *(_DWORD *)std::stringbuf::string_type buf = 134349314;
      double v22 = v12;
      __int16 v23 = 2114;
      uint64_t v24 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "[AccessoryMonitor] Setting update interval to %{public}f, reportInterval %{public}@",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101889168);
      }
      double v14 = *a3;
      int v17 = 134349314;
      double v18 = v14;
      __int16 v19 = 2114;
      unint64_t v20 = v10;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  1LL,  "[AccessoryMonitor] Setting update interval to %{public}f, reportInterval %{public}@",  &v17,  22);
      char v16 = (uint8_t *)v15;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CFTimeInterval CLAccessoryMonitor::minimumUpdateIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v15);
      if (v16 != buf) {
        free(v16);
      }
    }

    (*(void (**)(void, const __CFString *, _UNKNOWN **))(**(void **)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  @"ReportInterval",  v10);
    return *a3;
  }

  return v5;
}

void sub_100E7C52C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (IOHIDEventGetType(a4) != 1)
  {
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    double v12 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67240192;
      LODWORD(v24) = IOHIDEventGetType(a4);
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_FAULT,  "[AccessoryMonitor] unexpected event type %{public}u",  buf,  8u);
    }

    if (!sub_1002921D0(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    uint64_t v13 = qword_1019345C8;
    int v19 = 67240192;
    LODWORD(v2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = IOHIDEventGetType(a4);
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  17LL,  "[AccessoryMonitor] unexpected event type %{public}u",  &v19,  8);
    uint64_t v11 = (uint8_t *)v14;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLAccessoryMonitor::onEventData(void *, void *, IOHIDEventRef)",  "%s\n",  v14);
    if (v11 == buf) {
      return;
    }
LABEL_24:
    free(v11);
    return;
  }

  int64_t v17 = 0LL;
  double v18 = 0LL;
  IOHIDEventGetVendorDefinedData(a4, &v18, &v17);
  unint64_t v7 = v17;
  unint64_t v6 = v18;
  if (v18) {
    BOOL v8 = v17 <= 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    unint64_t TimeStamp = IOHIDEventGetTimeStamp(a4);
    double v16 = sub_101171C7C(TimeStamp);
    sub_100E7C89C(a1, v6, v7, v16);
    return;
  }

  if (qword_1019345C0 != -1) {
    dispatch_once(&qword_1019345C0, &stru_101889168);
  }
  char v9 = (os_log_s *)qword_1019345C8;
  if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)std::stringbuf::string_type buf = 134349312;
    uint64_t v24 = v18;
    __int16 v25 = 2048;
    int64_t v26 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "[AccessoryMonitor] invalid message: empty message %{public}p (%zd)",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    int v19 = 134349312;
    unint64_t v20 = v18;
    __int16 v21 = 2048;
    int64_t v22 = v17;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  17LL,  "[AccessoryMonitor] invalid message: empty message %{public}p (%zd)",  &v19,  22);
    uint64_t v11 = (uint8_t *)v10;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLAccessoryMonitor::onEventData(void *, void *, IOHIDEventRef)",  "%s\n",  v10);
    if (v11 != buf) {
      goto LABEL_24;
    }
  }

void sub_100E7C89C(uint64_t a1, unsigned __int8 *a2, unint64_t a3, double a4)
{
  if (a3 <= 7)
  {
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    double v5 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134349312;
      *(void *)&uint8_t buf[4] = a3;
      *(_WORD *)&_BYTE buf[12] = 2050;
      *(void *)&buf[14] = 8LL;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_FAULT,  "[AccessoryMonitor] invalid message: length (%{public}zd) is smaller than header (%{public}zd)",  buf,  0x16u);
    }

    if (!sub_1002921D0(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    int v36 = 134349312;
    *(void *)BOOL v37 = a3;
    *(_WORD *)&v37[8] = 2050;
    uint64_t v38 = 8LL;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  17LL,  "[AccessoryMonitor] invalid message: length (%{public}zd) is smaller than header (%{public}zd)",  &v36,  22);
LABEL_19:
    BOOL v10 = (char *)v6;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLAccessoryMonitor::onMonitorEvent(const uint8_t *const, const size_t, const CFTimeInterval)",  "%s\n",  v6);
    if (v10 != buf)
    {
LABEL_20:
      free(v10);
      return;
    }

    return;
  }

  unint64_t v8 = *((unsigned __int16 *)a2 + 1);
  if (v8 < a3)
  {
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    char v9 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134349312;
      *(void *)&uint8_t buf[4] = a3;
      *(_WORD *)&_BYTE buf[12] = 1026;
      *(_DWORD *)&buf[14] = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "[AccessoryMonitor] invalid message: length (%{public}zd) is smaller than reported message size (%{public}d)",  buf,  0x12u);
    }

    if (!sub_1002921D0(115, 0)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    int v36 = 134349312;
    *(void *)BOOL v37 = a3;
    *(_WORD *)&v37[8] = 1026;
    LODWORD(v38) = v8;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  17LL,  "[AccessoryMonitor] invalid message: length (%{public}zd) is smaller than reported message size (%{public}d)",  &v36,  18);
    goto LABEL_19;
  }

  if (*a2 - 18 > 0xFFFFFFFB)
  {
    if (a2[1] < 0x10u)
    {
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101889168);
      }
      uint64_t v28 = (os_log_s *)qword_1019345C8;
      if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_DEBUG))
      {
        int v29 = a2[1];
        int v30 = a2[4];
        *(_DWORD *)std::stringbuf::string_type buf = 67240962;
        *(_DWORD *)&uint8_t buf[4] = v29;
        *(_WORD *)&uint8_t buf[8] = 1026;
        *(_DWORD *)&buf[10] = v30;
        *(_WORD *)&buf[14] = 1040;
        *(_DWORD *)&uint8_t buf[16] = v8 - 8;
        *(_WORD *)&_BYTE buf[20] = 2098;
        *(void *)&buf[22] = a2 + 8;
        _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEBUG,  "[AccessoryMonitor] event type %{public}d, seq %{public}u, payload bytes %{public}.*P",  buf,  0x1Eu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345C0 != -1) {
          dispatch_once(&qword_1019345C0, &stru_101889168);
        }
        int v32 = a2[1];
        int v33 = a2[4];
        int v36 = 67240962;
        *(_DWORD *)BOOL v37 = v32;
        *(_WORD *)&v37[4] = 1026;
        *(_DWORD *)&v37[6] = v33;
        LOWORD(v38) = 1040;
        *(_DWORD *)((char *)&v38 + 2) = v8 - 8;
        HIWORD(v38) = 2098;
        std::stringbuf::string_type v39 = a2 + 8;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  2LL,  "[AccessoryMonitor] event type %{public}d, seq %{public}u, payload bytes %{public}.*P",  &v36,  30);
        std::stringbuf v35 = (char *)v34;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLAccessoryMonitor::onMonitorEvent(const uint8_t *const, const size_t, const CFTimeInterval)",  "%s\n",  v34);
        if (v35 != buf) {
          free(v35);
        }
      }

      uint64_t v50 = 0LL;
      __int128 v49 = 0u;
      __int128 v48 = 0u;
      __int128 v47 = 0u;
      __int128 v46 = 0u;
      __int128 v45 = 0u;
      __int128 v44 = 0u;
      __int128 v43 = 0u;
      __int128 v42 = 0u;
      __int128 v41 = 0u;
      memset(&buf[8], 0, 32);
      *(double *)std::stringbuf::string_type buf = a4;
      bzero(&buf[8], 0xB1uLL);
      if (a3 >= 0xB1) {
        size_t v31 = 177LL;
      }
      else {
        size_t v31 = a3;
      }
      memcpy(&buf[8], a2, v31);
      sub_1006DD528(a1, 0LL, (uint64_t)buf, 192LL);
      return;
    }

    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    int v19 = (os_log_s *)qword_1019345C8;
    sub_1004F2598();
    else {
      os_log_type_t v20 = OS_LOG_TYPE_DEFAULT;
    }
    if (os_log_type_enabled(v19, v20))
    {
      int v21 = a2[1];
      *(_DWORD *)std::stringbuf::string_type buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  v20,  "[AccessoryMonitor] invalid message: unknown type (%{public}d), dropping",  buf,  8u);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    uint64_t v22 = qword_1019345C8;
    sub_1004F2598();
    int v23 = sub_1004F8A40();
    int v24 = a2[1];
    int v36 = 67240192;
    *(_DWORD *)BOOL v37 = v24;
    if (v23) {
      uint64_t v25 = 17LL;
    }
    else {
      uint64_t v25 = 0LL;
    }
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v22,  v25,  "[AccessoryMonitor] invalid message: unknown type (%{public}d), dropping",  &v36,  8);
  }

  else
  {
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    uint64_t v11 = (os_log_s *)qword_1019345C8;
    sub_1004F2598();
    else {
      os_log_type_t v12 = OS_LOG_TYPE_DEFAULT;
    }
    if (os_log_type_enabled(v11, v12))
    {
      int v13 = *a2;
      *(_DWORD *)std::stringbuf::string_type buf = 67240448;
      *(_DWORD *)&uint8_t buf[4] = 17;
      *(_WORD *)&uint8_t buf[8] = 1026;
      *(_DWORD *)&buf[10] = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  v12,  "[AccessoryMonitor] invalid message: mismatched version (local:%{public}d remote:%{public}d), dropping",  buf,  0xEu);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889168);
    }
    uint64_t v14 = qword_1019345C8;
    sub_1004F2598();
    int v15 = sub_1004F8A40();
    int v16 = *a2;
    int v36 = 67240448;
    *(_DWORD *)BOOL v37 = 17;
    *(_WORD *)&v37[4] = 1026;
    *(_DWORD *)&v37[6] = v16;
    if (v15) {
      uint64_t v17 = 17LL;
    }
    else {
      uint64_t v17 = 0LL;
    }
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  v17,  "[AccessoryMonitor] invalid message: mismatched version (local:%{public}d remote:%{public}d), dropping",  &v36,  14);
  }

  BOOL v10 = (char *)v18;
  sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLAccessoryMonitor::onMonitorEvent(const uint8_t *const, const size_t, const CFTimeInterval)",  "%s\n",  v18);
  if (v10 != buf) {
    goto LABEL_20;
  }
}

void sub_100E7D08C(id a1)
{
  qword_1019345C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Accessory");
}

void sub_100E7D15C(id a1)
{
  qword_10199EE38 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLSensorRecorderNotifierSilo");
}

uint64_t sub_100E7D210(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100E7D9D4;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_10199EE58 != -1) {
    dispatch_once(&qword_10199EE58, block);
  }
  return qword_1019A3D78;
}

uint64_t sub_100E7D3E4(uint64_t a1)
{
  uint64_t result = sub_100E7D40C(*(_DWORD *)(a1 + 32));
  if ((_DWORD)result) {
    byte_10199EE48 = 1;
  }
  return result;
}

uint64_t sub_100E7D40C(unsigned int a1)
{
  unint64_t v2 = sub_1004F97F4();
  uint64_t result = sub_1000641E0(a1);
  if ((_DWORD)result)
  {
    if (a1 == 2)
    {
      if ((v2 & 0x10000000) != 0) {
        return (sub_1004FAB40() >> 4) & 1;
      }
      else {
        return 0LL;
      }
    }

    else if (a1 == 1)
    {
      return (~(_DWORD)v2 & 0x10040000) == 0LL;
    }

    else
    {
      return (v2 >> 28) & 1;
    }
  }

  return result;
}

uint64_t sub_100E7D4EC(uint64_t a1, unsigned int a2, unsigned int a3)
{
  HIDWORD(v19) = a3;
  if (a3 >= 0x65)
  {
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_101889328);
    }
    char v4 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67240448;
      unsigned int v23 = a3;
      __int16 v24 = 1026;
      int v25 = 100;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "requested sampling rate of %{public}d is greater than the max allowed of %{public}d",  buf,  0xEu);
    }

    uint64_t v5 = 0LL;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_101889328);
      }
      LODWORD(v2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 67240448;
      HIDWORD(v2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a3;
      LOWORD(v21) = 1026;
      *(_DWORD *)((char *)&v21 + 2) = 100;
      LODWORD(v19) = 14;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  17LL,  "requested sampling rate of %{public}d is greater than the max allowed of %{public}d",  &v20,  v19,  v20,  v21);
LABEL_37:
      double v18 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLSensorRecorderNotifier::setSensorSampleRate(CLSensorRecorder_Types::DataType, unsigned int)",  "%s\n",  v6);
      if (v18 != buf) {
        free(v18);
      }
      return 0LL;
    }

    return v5;
  }

  switch(a2)
  {
    case 2u:
      char v9 = (unsigned int *)(a1 + 320);
      BOOL v10 = @"kPressureSampleRate";
      goto LABEL_16;
    case 1u:
      char v9 = (unsigned int *)(a1 + 308);
      BOOL v10 = @"kGyroSampleRate";
      goto LABEL_16;
    case 0u:
      char v9 = (unsigned int *)(a1 + 300);
      BOOL v10 = @"kAccelSampleRate";
LABEL_16:
      qword_10199EE60 = (uint64_t)v10;
      if (*v9 != a3)
      {
        if (qword_1019345F0 != -1) {
          dispatch_once(&qword_1019345F0, &stru_101889328);
        }
        uint64_t v11 = (os_log_s *)qword_1019345F8;
        if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::stringbuf::string_type buf = 67109120;
          unsigned int v23 = a3;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "setting desired accel sampling rate to %dhz",  buf,  8u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019345F0 != -1) {
            dispatch_once(&qword_1019345F0, &stru_101889328);
          }
          LODWORD(v2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 67109120;
          HIDWORD(v2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a3;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  0LL,  "setting desired accel sampling rate to %dhz",  &v20);
          uint64_t v17 = (uint8_t *)v16;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLSensorRecorderNotifier::setSensorSampleRate(CLSensorRecorder_Types::DataType, unsigned int)",  "%s\n",  v16);
          if (v17 != buf) {
            free(v17);
          }
        }

        unsigned int *v9 = a3;
        uint64_t v12 = sub_1002F8DDC();
        sub_1002ABCE4(v12, (const __CFString *)qword_10199EE60, (unsigned int *)&v19 + 1);
        uint64_t v13 = sub_1002F8DDC();
        (*(void (**)(uint64_t))(*(void *)v13 + 944LL))(v13);
      }

      uint64_t v5 = 1LL;
      sub_100E7F450(a1, a2, 1, 129600.0);
      return v5;
  }

  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101889348);
  }
  uint64_t v14 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Invalid data type.", buf, 2u);
  }

  uint64_t v5 = 0LL;
  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101889348);
    }
    LOWORD(v2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
    LODWORD(v19) = 2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "Invalid data type.",  &v20,  v19,  v20,  v21);
    goto LABEL_37;
  }

  return v5;
}

uint64_t sub_100E7D9D4(uint64_t a1)
{
  unint64_t v2 = operator new(0x168uLL);
  uint64_t result = sub_100E7DA20((uint64_t)v2, *(void **)(a1 + 32));
  qword_1019A3D78 = (uint64_t)v2;
  return result;
}

void sub_100E7DA0C(_Unwind_Exception *a1)
{
}

uint64_t sub_100E7DA20(uint64_t a1, void *a2)
{
  uint64_t v3 = sub_100E7E384(a1, "CLSensorRecorderNotifier", a2);
  *(void *)uint64_t v3 = off_1018891D8;
  *(void *)(v3 + 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  char v4 = (void *)(v3 + 160);
  *(void *)(v3 + 168) = 0LL;
  *(void *)(v3 + 176) = 0LL;
  *(void *)(a1 + 184) = [*(id *)(v3 + 40) newTimer];
  *(void *)(a1 + 192) = [*(id *)(a1 + 40) newTimer];
  *(void *)(a1 + 20sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = [*(id *)(a1 + 40) newTimer];
  id v5 = [*(id *)(a1 + 40) newTimer];
  *(void *)(a1 + 216) = 0LL;
  *(void *)(a1 + 208) = v5;
  *(void *)(a1 + 224) = 0LL;
  *(void *)(a1 + 232) = 0LL;
  *(int64x2_t *)(a1 + 24sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  *(_OWORD *)(a1 + 264) = xmmword_101362FA0;
  *(_OWORD *)(a1 + 28sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = xmmword_101362FA0;
  *(_OWORD *)(a1 + 296) = xmmword_101362FB0;
  *(_DWORD *)(a1 + 312) = -1;
  else {
    int v6 = 25;
  }
  *(_DWORD *)(a1 + 316) = v6;
  *(_DWORD *)(a1 + 32sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v6;
  *(void *)(a1 + 324) = 0LL;
  uint64_t v7 = a1 + 344;
  *(void *)(a1 + 329) = 0LL;
  *(void *)(a1 + 344) = 0LL;
  *(void *)(a1 + 352) = 0LL;
  unint64_t v8 = operator new(0x1C8uLL);
  sub_1010DDBC0(v69, "");
  sub_1006F5458((uint64_t)v8, 0, (uint64_t)v69, 0);
  *char v4 = v8;
  char v9 = operator new(0x1C8uLL);
  sub_1010DDBC0(v67, "");
  sub_1006F5458((uint64_t)v9, 0, (uint64_t)v67, 1u);
  *(void *)(a1 + 168) = v9;
  BOOL v10 = operator new(0x1C8uLL);
  sub_1010DDBC0(v65, "");
  sub_1006F5458((uint64_t)v10, 0, (uint64_t)v65, 2u);
  *(void *)(a1 + 176) = v10;
  uint64_t v11 = sub_1006E27E8();
  sub_100413284(v11, &v63);
  sub_1002A82BC(v63, "SensorRecorderAggregationInterval", (void *)(a1 + 264));
  uint64_t v12 = v64;
  if (v64)
  {
    p_shared_owners = (unint64_t *)&v64->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  if (v66 < 0) {
    operator delete(v65[0]);
  }
  if (v68 < 0) {
    operator delete(v67[0]);
  }
  if (v70 < 0) {
    operator delete(v69[0]);
  }
  uint64_t v15 = sub_1006E27E8();
  sub_100413284(v15, &v63);
  sub_1002A82BC(v63, "SensorRecorderAggregationExpiration", (void *)(a1 + 272));
  int v16 = v64;
  if (v64)
  {
    uint64_t v17 = (unint64_t *)&v64->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  uint64_t v19 = sub_1006E27E8();
  sub_100413284(v19, &v63);
  sub_1002A775C(v63, "SensorRecorderAccelSamplingRate", (_DWORD *)(a1 + 300));
  uint64_t v20 = v64;
  if (v64)
  {
    uint64_t v21 = (unint64_t *)&v64->__shared_owners_;
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  uint64_t v23 = sub_1006E27E8();
  sub_100413284(v23, &v63);
  sub_1002A775C(v63, "SensorRecorderGyroSamplingRate", (_DWORD *)(a1 + 308));
  __int16 v24 = v64;
  if (v64)
  {
    int v25 = (unint64_t *)&v64->__shared_owners_;
    do
      unint64_t v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }

  uint64_t v27 = sub_1006E27E8();
  sub_100413284(v27, &v63);
  sub_1002A775C(v63, "SensorRecorderPressureSamplingRate", (_DWORD *)(a1 + 320));
  uint64_t v28 = v64;
  if (v64)
  {
    int v29 = (unint64_t *)&v64->__shared_owners_;
    do
      unint64_t v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }

  uint64_t v31 = sub_1006E27E8();
  sub_100413284(v31, &v63);
  sub_1002A6F64(v63, "SensorRecorderAccelAlwaysSubscribed", (BOOL *)(a1 + 325));
  int v32 = v64;
  if (v64)
  {
    int v33 = (unint64_t *)&v64->__shared_owners_;
    do
      unint64_t v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }

  uint64_t v35 = sub_1006E27E8();
  sub_100413284(v35, &v63);
  sub_1002A6F64(v63, "SensorRecorderGyroAlwaysSubscribed", (BOOL *)(a1 + 326));
  int v36 = v64;
  if (v64)
  {
    BOOL v37 = (unint64_t *)&v64->__shared_owners_;
    do
      unint64_t v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }

  uint64_t v39 = sub_1006E27E8();
  sub_100413284(v39, &v63);
  sub_1002A6F64(v63, "SensorRecorderPressureAlwaysSubscribed", (BOOL *)(a1 + 327));
  std::stringbuf::string_type v40 = v64;
  if (v64)
  {
    __int128 v41 = (unint64_t *)&v64->__shared_owners_;
    do
      unint64_t v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }

  uint64_t v43 = sub_1002F8DDC();
  sub_1002A77CC(v43, (uint64_t)@"kAccelSampleRate", (_DWORD *)(a1 + 300));
  uint64_t v44 = sub_1002F8DDC();
  sub_1002A77CC(v44, (uint64_t)@"kGyroSampleRate", (_DWORD *)(a1 + 308));
  uint64_t v45 = sub_1002F8DDC();
  sub_1002A77CC(v45, (uint64_t)@"kPressureSampleRate", (_DWORD *)(a1 + 320));
  *(_OWORD *)(a1 + 28sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_OWORD *)(a1 + 264);
  if ((sub_1004F97F4() & 0x10000000) != 0)
  {
    __int128 v46 = (const void *)sub_1008FA854(0);
    if (v46)
    {
      if (v47)
      {
        aBlock[0] = _NSConcreteStackBlock;
        aBlock[1] = 3221225472LL;
        aBlock[2] = sub_100E7E420;
        aBlock[3] = &unk_10184D430;
        aBlock[4] = a1;
        sub_10035C6B8((uint64_t)v47, aBlock);
        v61[0] = _NSConcreteStackBlock;
        v61[1] = 3221225472LL;
        v61[2] = sub_100E7E620;
        _DWORD v61[3] = &unk_10181D3D0;
        v61[4] = a1;
        [*(id *)(a1 + 184) setHandler:v61];
        v60[0] = _NSConcreteStackBlock;
        v60[1] = 3221225472LL;
        v60[2] = sub_100E7E86C;
        _DWORD v60[3] = &unk_10181D3D0;
        v60[4] = a1;
        [*(id *)(a1 + 192) setHandler:v60];
        v59[0] = _NSConcreteStackBlock;
        v59[1] = 3221225472LL;
        v59[2] = sub_100E7EAB8;
        _DWORD v59[3] = &unk_10181D3D0;
        v59[4] = a1;
        [*(id *)(a1 + 200) setHandler:v59];
        v58[0] = _NSConcreteStackBlock;
        v58[1] = 3221225472LL;
        v58[2] = sub_100E7ED00;
        _DWORD v58[3] = &unk_10181D3D0;
        v58[4] = a1;
        [*(id *)(a1 + 208) setHandler:v58];
        [*(id *)(a1 + 184) setNextFireDelay:60.0 interval:60.0];
        [*(id *)(a1 + 192) setNextFireDelay:75.0 interval:60.0];
        [*(id *)(a1 + 200) setNextFireDelay:90.0 interval:60.0];
        [*(id *)(a1 + 208) setNextFireDelay:105.0 interval:60.0];
      }
    }
  }

  sub_10060B0A4((uint64_t)sub_100E7ED40, a1, *(void **)(a1 + 32), &v63);
  uint64_t v48 = v63;
  uint64_t v63 = 0LL;
  uint64_t v49 = *(void *)(a1 + 328);
  *(void *)(a1 + 328) = v48;
  if (v49)
  {
    (*(void (**)(uint64_t))(*(void *)v49 + 8LL))(v49);
    uint64_t v50 = v63;
    uint64_t v63 = 0LL;
    if (v50) {
      (*(void (**)(uint64_t))(*(void *)v50 + 8LL))(v50);
    }
  }

  [*(id *)(*(void *)(a1 + 328) + 16) register:*(void *)(*(void *)(a1 + 328) + 8) forNotification:0 registrationInfo:0];
  [*(id *)(*(void *)(a1 + 328) + 16) register:*(void *)(*(void *)(a1 + 328) + 8) forNotification:3 registrationInfo:0];
  sub_100EE2800((uint64_t)sub_100E7EF28, a1, *(void **)(a1 + 32), &v63);
  uint64_t v51 = v63;
  uint64_t v63 = 0LL;
  uint64_t v52 = *(void *)v7;
  *(void *)uint64_t v7 = v51;
  if (v52)
  {
    (*(void (**)(uint64_t))(*(void *)v52 + 8LL))(v52);
    uint64_t v53 = v63;
    uint64_t v63 = 0LL;
    if (v53) {
      (*(void (**)(uint64_t))(*(void *)v53 + 8LL))(v53);
    }
  }

  [*(id *)(*(void *)v7 + 16) register:*(void *)(*(void *)v7 + 8) forNotification:9 registrationInfo:0];
  sub_100583844((uint64_t)sub_100E7F108, a1, *(void **)(a1 + 32), &v63);
  uint64_t v54 = v63;
  uint64_t v63 = 0LL;
  uint64_t v55 = *(void *)(a1 + 352);
  *(void *)(a1 + 352) = v54;
  if (v55)
  {
    (*(void (**)(uint64_t))(*(void *)v55 + 8LL))(v55);
    uint64_t v56 = v63;
    uint64_t v63 = 0LL;
    if (v56) {
      (*(void (**)(uint64_t))(*(void *)v56 + 8LL))(v56);
    }
  }

  [*(id *)(*(void *)(a1 + 352) + 16) register:*(void *)(*(void *)(a1 + 352) + 8) forNotification:6 registrationInfo:0];
  return a1;
}

void sub_100E7E1E8(_Unwind_Exception *a1)
{
  uint64_t v6 = *(void *)(v1 + 352);
  *(void *)(v1 + 352) = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  uint64_t v7 = *v3;
  *uint64_t v3 = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  uint64_t v8 = *(void *)(v1 + 328);
  *(void *)(v1 + 328) = 0LL;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  *(void *)(v4 - 184) = v2;
  sub_100006BC8((void ***)(v4 - 184));
  sub_100E7F2D8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E7E384(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_101889378;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = [a3 silo];
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 108) = 0;
  return a1;
}

void sub_100E7E404(_Unwind_Exception *exception_object)
{
}

void sub_100E7E420(uint64_t a1, char a2, uint64_t a3, const void *a4, size_t __sz, double a6)
{
  uint64_t v8 = *(void *)(a1 + 32);
  *(double *)&__int128 v26 = a6;
  *((void *)&v26 + 1) = a3;
  int v27 = __sz;
  size_t v9 = __sz;
  BOOL v10 = operator new[](__sz);
  sub_100E829B4(&__dst, (uint64_t)v10);
  memcpy(__dst, a4, v9);
  uint64_t v11 = *(void **)(v8 + 40);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3321888768LL;
  _DWORD v20[2] = sub_100E7E59C;
  void v20[3] = &unk_1018892A8;
  v20[4] = v8;
  char v25 = a2;
  int v22 = v27;
  __int128 v21 = v26;
  uint64_t v23 = __dst;
  __int16 v24 = v29;
  if (v29)
  {
    p_shared_owners = (unint64_t *)&v29->__shared_owners_;
    do
      unint64_t v13 = __ldxr(p_shared_owners);
    while (__stxr(v13 + 1, p_shared_owners));
  }

  [v11 async:v20];
  unint64_t v14 = v24;
  if (v24)
  {
    uint64_t v15 = (unint64_t *)&v24->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  uint64_t v17 = v29;
  if (v29)
  {
    unint64_t v18 = (unint64_t *)&v29->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

void sub_100E7E580(_Unwind_Exception *a1)
{
}

uint64_t sub_100E7E59C(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(result + 32);
  int v2 = *(unsigned __int8 *)(result + 80);
  switch(v2)
  {
    case 5:
      uint64_t v3 = v1 + 22;
      break;
    case 2:
      uint64_t v3 = v1 + 21;
      break;
    case 1:
      uint64_t v3 = v1 + 20;
      break;
    default:
      return result;
  }

  return sub_1006F5D78(*v3, result + 40);
}

uint64_t sub_100E7E5E4(uint64_t result, uint64_t a2)
{
  __int128 v2 = *(_OWORD *)(a2 + 40);
  *(_DWORD *)(result + 56) = *(_DWORD *)(a2 + 56);
  *(_OWORD *)(result + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v2;
  uint64_t v3 = *(void *)(a2 + 72);
  *(void *)(result + 64) = *(void *)(a2 + 64);
  *(void *)(result + 72) = v3;
  if (v3)
  {
    uint64_t v4 = (unint64_t *)(v3 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  return result;
}

uint64_t sub_100E7E618(uint64_t a1)
{
  return sub_10000AE14(a1 + 64);
}

void sub_100E7E620(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (sub_100D8A92C(*(void *)(v1 + 160) + 72LL))
  {
    double Current = CFAbsoluteTimeGetCurrent();
    sub_100E7F71C(v1, 0);
    if (vabdd_f64(Current, *(double *)(v1 + 240)) > *(double *)(v1 + 280))
    {
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_101889328);
      }
      uint64_t v3 = (os_log_s *)qword_1019345F8;
      if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "Aggregating accel sensor recorder samples.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345F0 != -1) {
          dispatch_once(&qword_1019345F0, &stru_101889328);
        }
        v8[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  2LL,  "Aggregating accel sensor recorder samples.",  v8,  2);
        uint64_t v7 = (uint8_t *)v6;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLSensorRecorderNotifier::CLSensorRecorderNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v6);
        if (v7 != buf) {
          free(v7);
        }
      }

      uint64_t v4 = *(void *)(v1 + 288);
      unint64_t v5 = operator new(0x18uLL);
      *(void *)std::stringbuf::string_type buf = v5;
      uint64_t v11 = (char *)(v5 + 3);
      *unint64_t v5 = v4;
      v5[1] = 0x7FEFFFFFFFFFFFFFLL;
      *((_BYTE *)v5 + 16) = 0;
      BOOL v10 = v5 + 3;
      (*(void (**)(void, uint8_t *))(**(void **)(v1 + 160) + 32LL))(*(void *)(v1 + 160), buf);
      *(double *)(v1 + 24sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = Current;
      if (*(void *)buf)
      {
        BOOL v10 = *(void **)buf;
        operator delete(*(void **)buf);
      }
    }
  }

void sub_100E7E848( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E7E86C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (sub_100D8A92C(*(void *)(v1 + 168) + 72LL))
  {
    double Current = CFAbsoluteTimeGetCurrent();
    sub_100E7F71C(v1, 1u);
    if (vabdd_f64(Current, *(double *)(v1 + 248)) > *(double *)(v1 + 264))
    {
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_101889328);
      }
      uint64_t v3 = (os_log_s *)qword_1019345F8;
      if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "Aggregating gyro sensor recorder samples.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345F0 != -1) {
          dispatch_once(&qword_1019345F0, &stru_101889328);
        }
        v8[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  2LL,  "Aggregating gyro sensor recorder samples.",  v8,  2);
        uint64_t v7 = (uint8_t *)v6;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLSensorRecorderNotifier::CLSensorRecorderNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v6);
        if (v7 != buf) {
          free(v7);
        }
      }

      uint64_t v4 = *(void *)(v1 + 272);
      unint64_t v5 = operator new(0x18uLL);
      *(void *)std::stringbuf::string_type buf = v5;
      uint64_t v11 = (char *)(v5 + 3);
      *unint64_t v5 = v4;
      v5[1] = 0x7FEFFFFFFFFFFFFFLL;
      *((_BYTE *)v5 + 16) = 0;
      BOOL v10 = v5 + 3;
      (*(void (**)(void, uint8_t *))(**(void **)(v1 + 168) + 32LL))(*(void *)(v1 + 168), buf);
      *(double *)(v1 + 248) = Current;
      if (*(void *)buf)
      {
        BOOL v10 = *(void **)buf;
        operator delete(*(void **)buf);
      }
    }
  }

void sub_100E7EA94( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E7EAB8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (sub_100D8A92C(*(void *)(v1 + 176) + 72LL))
  {
    double Current = CFAbsoluteTimeGetCurrent();
    sub_100E7F71C(v1, 2u);
    if (vabdd_f64(Current, *(double *)(v1 + 256)) > *(double *)(v1 + 264))
    {
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_101889328);
      }
      uint64_t v3 = (os_log_s *)qword_1019345F8;
      if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)std::stringbuf::string_type buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "Aggregating pressure sensor recorder samples.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345F0 != -1) {
          dispatch_once(&qword_1019345F0, &stru_101889328);
        }
        v8[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  2LL,  "Aggregating pressure sensor recorder samples.",  v8,  2);
        uint64_t v7 = (uint8_t *)v6;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLSensorRecorderNotifier::CLSensorRecorderNotifier(id<CLIntersiloUniverse>)_block_invoke",  "%s\n",  v6);
        if (v7 != buf) {
          free(v7);
        }
      }

      uint64_t v4 = *(void *)(v1 + 272);
      unint64_t v5 = operator new(0x18uLL);
      *(void *)std::stringbuf::string_type buf = v5;
      uint64_t v11 = (char *)(v5 + 3);
      *unint64_t v5 = v4;
      v5[1] = 0x7FEFFFFFFFFFFFFFLL;
      *((_BYTE *)v5 + 16) = 0;
      BOOL v10 = v5 + 3;
      (*(void (**)(void, uint8_t *))(**(void **)(v1 + 176) + 32LL))(*(void *)(v1 + 176), buf);
      *(double *)(v1 + 256) = Current;
      if (*(void *)buf)
      {
        BOOL v10 = *(void **)buf;
        operator delete(*(void **)buf);
      }
    }
  }

void sub_100E7ECDC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E7ED00(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = sub_100D8A92C(*(void *)(v1 + 160) + 72LL);
  if ((_DWORD)result) {
    return sub_1006F8C54(*(void *)(v1 + 160), 1000LL);
  }
  return result;
}

void sub_100E7ED40(uint64_t a1, _DWORD *a2, _BYTE *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101889308);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v10 = 1;
    uint64_t v7 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLSensorRecorderNotifier::onFitnessTrackingNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889308);
    }
    uint64_t v8 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v12 = 0;
      __int16 v13 = 2082;
      unint64_t v14 = "";
      __int16 v15 = 2082;
      unint64_t v16 = "activity";
      __int16 v17 = 2050;
      uint64_t v18 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLSensorRecorderNotifier::onFitnessTrackingNotification, event:%{public, location:e scape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v10 = 0;
  }

  if (*a2 == 3)
  {
    *(_BYTE *)(a4 + 336) = *a3;
  }

  else if (!*a2)
  {
    *(_BYTE *)(a4 + 324) = a3[3];
  }

  if (v10) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E7EF0C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E7EF28(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101889308);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v9 = 1;
    uint64_t v6 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLSensorRecorderNotifier::onSysdiagnoseStarted",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v6, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889308);
    }
    uint64_t v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v11 = 0;
      __int16 v12 = 2082;
      __int16 v13 = "";
      __int16 v14 = 2082;
      __int16 v15 = "activity";
      __int16 v16 = 2050;
      uint64_t v17 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLSensorRecorderNotifier::onSysdiagnoseStarted, event:%{public, location:escape_onl y}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v9 = 0;
  }

  if (*(_BYTE *)(a4 + 336) && *a2 == 9) {
    sub_100E80954(a4);
  }
  if (v9) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E7F0E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E7F108(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101889308);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v10 = 1;
    uint64_t v7 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLSensorRecorderNotifier::onSoftwareUpdateStorageRecovery",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v7, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889308);
    }
    uint64_t v8 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v12 = 0;
      __int16 v13 = 2082;
      __int16 v14 = "";
      __int16 v15 = 2082;
      __int16 v16 = "activity";
      __int16 v17 = 2050;
      uint64_t v18 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLSensorRecorderNotifier::onSoftwareUpdateStorageRecovery, event:%{public, location :escape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v10 = 0;
  }

  sub_100E80C0C((uint64_t *)a4, v6, a2);
  if (v10) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E7F2B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E7F2D8(uint64_t a1)
{
  *(void *)a1 = off_101889378;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

uint64_t sub_100E7F34C(uint64_t *a1, int a2, sqlite3_int64 a3, void *a4)
{
  switch(a2)
  {
    case 2:
      uint64_t v4 = a1 + 22;
      return sub_1006F6D20(*v4, a3, a4);
    case 1:
      uint64_t v4 = a1 + 21;
      return sub_1006F6D20(*v4, a3, a4);
    case 0:
      uint64_t v4 = a1 + 20;
      return sub_1006F6D20(*v4, a3, a4);
  }

  return 0LL;
}

uint64_t sub_100E7F38C(uint64_t *a1, int a2, sqlite3_int64 a3, void *a4)
{
  switch(a2)
  {
    case 2:
      uint64_t v4 = a1 + 22;
      return sub_1006F785C(*v4, a3, a4);
    case 1:
      uint64_t v4 = a1 + 21;
      return sub_1006F785C(*v4, a3, a4);
    case 0:
      uint64_t v4 = a1 + 20;
      return sub_1006F785C(*v4, a3, a4);
  }

  return 0LL;
}

BOOL sub_100E7F3CC(uint64_t *a1, int a2, void *a3, double a4, double a5)
{
  switch(a2)
  {
    case 2:
      unint64_t v5 = a1 + 22;
      return sub_1006F80C4(*v5, a3, a4, a5);
    case 1:
      unint64_t v5 = a1 + 21;
      return sub_1006F80C4(*v5, a3, a4, a5);
    case 0:
      unint64_t v5 = a1 + 20;
      return sub_1006F80C4(*v5, a3, a4, a5);
  }

  return 0LL;
}

uint64_t sub_100E7F408(uint64_t *a1, int a2, uint64_t a3, sqlite3_int64 a4)
{
  switch(a2)
  {
    case 2:
      uint64_t v4 = a1 + 22;
      return sub_1006F7338(*v4, a3, a4);
    case 1:
      uint64_t v4 = a1 + 21;
      return sub_1006F7338(*v4, a3, a4);
    case 0:
      uint64_t v4 = a1 + 20;
      return sub_1006F7338(*v4, a3, a4);
  }

  return 0LL;
}

BOOL sub_100E7F448(uint64_t a1, unsigned int a2, double a3)
{
  return sub_100E7F450(a1, a2, 0, a3);
}

BOOL sub_100E7F450(uint64_t a1, unsigned int a2, int a3, double a4)
{
  BOOL v8 = sub_1000641E0(a2);
  if (v8)
  {
    *(double *)&unint64_t v21 = -1.79769313e308;
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_101889328);
    }
    char v9 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 67240448;
      *(_DWORD *)&uint8_t buf[4] = a2;
      __int16 v26 = 2050;
      double v27 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Record %{location:CLSensorRecorder_Types::DataType,public}d data for %{public}f",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_101889328);
      }
      v22[0] = 67240448;
      v22[1] = a2;
      __int16 v23 = 2050;
      double v24 = a4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  0LL,  "Record %{location:CLSensorRecorder_Types::DataType,public}d data for %{public}f",  v22,  18);
      uint64_t v20 = (uint8_t *)v19;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLSensorRecorderNotifier::recordSensorData(CLSensorRecorder_Types::DataType, CFTimeInterval, BOOL)",  "%s\n",  v19);
      if (v20 != buf) {
        free(v20);
      }
    }

    char v10 = @"kPressureBufferSubscription";
    if (a3) {
      char v10 = @"kPressureBufferSubscriptionOverride";
    }
    int v11 = @"kGyroBufferSubscription";
    if (a3) {
      int v11 = @"kGyroBufferSubscriptionOverride";
    }
    int v12 = @"kAccelBufferSubscription";
    if (a3) {
      int v12 = @"kAccelBufferSubscriptionOverride";
    }
    if (a2) {
      int v12 = 0LL;
    }
    if (a2 != 1) {
      int v11 = v12;
    }
    if (a2 == 2) {
      __int16 v13 = v10;
    }
    else {
      __int16 v13 = v11;
    }
    uint64_t v14 = sub_1002F8DDC();
    sub_1002A832C(v14, (uint64_t)v13, &v21);
    if (a4 >= 129600.0) {
      a4 = 129600.0;
    }
    double v15 = *(double *)&v21;
    if (v15 < a4 + CFAbsoluteTimeGetCurrent())
    {
      uint64_t v16 = sub_1002F8DDC();
      *(double *)std::stringbuf::string_type buf = a4 + CFAbsoluteTimeGetCurrent();
      sub_1002AC820(v16, v13, buf);
      uint64_t v17 = sub_1002F8DDC();
      (*(void (**)(uint64_t))(*(void *)v17 + 944LL))(v17);
      sub_100E7F71C(a1, a2);
    }
  }

  return v8;
}

void sub_100E7F71C(uint64_t a1, unsigned int a2)
{
  if (!sub_1000641E0(a2)) {
    return;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  double v49 = -1.79769313e308;
  double v50 = -1.79769313e308;
  switch(a2)
  {
    case 0u:
      unint64_t v5 = (int *)(a1 + 296);
      uint64_t v6 = (int *)(a1 + 300);
      uint64_t v7 = (unsigned __int8 *)(a1 + 325);
      BOOL v8 = @"kAccelBufferSubscription";
      char v9 = @"kAccelBufferSubscriptionOverride";
      goto LABEL_8;
    case 2u:
      unint64_t v5 = (int *)(a1 + 312);
      uint64_t v6 = (int *)(a1 + 320);
      uint64_t v7 = (unsigned __int8 *)(a1 + 327);
      BOOL v8 = @"kPressureBufferSubscription";
      char v9 = @"kPressureBufferSubscriptionOverride";
LABEL_8:
      int v10 = *v5;
      int v11 = *v6;
      uint64_t v12 = sub_1002F8DDC();
      sub_1002A832C(v12, (uint64_t)v9, &v49);
      BOOL v13 = Current < v49 && vabdd_f64(v49, Current) < *(double *)(a1 + 272);
      if (*v7 | v13)
      {
        if (a2)
        {
LABEL_15:
          char v15 = 1;
LABEL_16:
          else {
            int v16 = 0;
          }
          if (v16 != v10)
          {
            if (qword_1019345F0 != -1) {
              dispatch_once(&qword_1019345F0, &stru_101889328);
            }
            uint64_t v17 = (os_log_s *)qword_1019345F8;
            if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
            {
              int v18 = *(unsigned __int8 *)(a1 + 324);
              *(_DWORD *)std::stringbuf::string_type buf = 67240704;
              *(_DWORD *)&uint8_t buf[4] = a2;
              __int16 v58 = 1026;
              int v59 = v16;
              __int16 v60 = 1026;
              int v61 = v18;
              _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Updating %{location:CLSensorRecorder_Types::DataType,public}d sampling rate %{public}d, fitness tracking enabled, %{public}d",  buf,  0x14u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019345F0 != -1) {
                dispatch_once(&qword_1019345F0, &stru_101889328);
              }
              int v38 = *(unsigned __int8 *)(a1 + 324);
              int v51 = 67240704;
              unsigned int v52 = a2;
              __int16 v53 = 1026;
              int v54 = v16;
              __int16 v55 = 1026;
              int v56 = v38;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  0LL,  "Updating %{location:CLSensorRecorder_Types::DataType,public}d sampling rate %{public}d, fitness tracking enabled, %{public}d",  &v51,  20);
              std::stringbuf::string_type v40 = (uint8_t *)v39;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSensorRecorderNotifier::updateSubscriptionType(CLSensorRecorder_Types::DataType)",  "%s\n",  v39);
              if (v40 != buf) {
                free(v40);
              }
            }

            uint64_t v19 = sub_1006E27E8();
            v46[0] = _NSConcreteStackBlock;
            v46[1] = 3221225472LL;
            v46[2] = sub_100E806B4;
            v46[3] = &unk_10181D3D0;
            unsigned int v47 = a2;
            int v48 = v16;
            sub_1006E2970(v19, (uint64_t)v46);
            if (a2)
            {
              if (a2 == 2)
              {
                if (v10 >= 1) {
                  sub_1006F6CA8(*(void *)(a1 + 176));
                }
                uint64_t v20 = (int *)(a1 + 312);
              }

              else
              {
                if (v10 >= 1) {
                  sub_1006F6CA8(*(void *)(a1 + 168));
                }
                uint64_t v20 = (int *)(a1 + 304);
              }
            }

            else
            {
              if (v10 >= 1) {
                sub_1006F6CA8(*(void *)(a1 + 160));
              }
              uint64_t v20 = (int *)(a1 + 296);
            }

            int *v20 = v16;
          }

          double v26 = Current + 129600.0;
          if (v50 > v26)
          {
            if (qword_1019345F0 != -1) {
              dispatch_once(&qword_1019345F0, &stru_101889328);
            }
            double v27 = (os_log_s *)qword_1019345F8;
            if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::stringbuf::string_type buf = 67240192;
              *(_DWORD *)&uint8_t buf[4] = a2;
              _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Updated %{location:CLSensorRecorder_Types::DataType,public}d subscription due to invalid time.",  buf,  8u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019345F0 != -1) {
                dispatch_once(&qword_1019345F0, &stru_101889328);
              }
              int v51 = 67240192;
              unsigned int v52 = a2;
              LODWORD(v45) = 8;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  0LL,  "Updated %{location:CLSensorRecorder_Types::DataType,public}d subscription due to invalid time.",  &v51,  v45);
              unint64_t v42 = (uint8_t *)v41;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSensorRecorderNotifier::updateSubscriptionType(CLSensorRecorder_Types::DataType)",  "%s\n",  v41);
              if (v42 != buf) {
                free(v42);
              }
            }

            uint64_t v28 = sub_1002F8DDC();
            *(double *)std::stringbuf::string_type buf = v26;
            sub_1002AC820(v28, v8, buf);
            uint64_t v29 = sub_1002F8DDC();
            (*(void (**)(uint64_t))(*(void *)v29 + 944LL))(v29);
          }

          if (v49 > v26)
          {
            if (qword_1019345F0 != -1) {
              dispatch_once(&qword_1019345F0, &stru_101889328);
            }
            unint64_t v30 = (os_log_s *)qword_1019345F8;
            if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::stringbuf::string_type buf = 67240192;
              *(_DWORD *)&uint8_t buf[4] = a2;
              _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Updated %{location:CLSensorRecorder_Types::DataType,public}d subscription override due to invalid time.",  buf,  8u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019345F0 != -1) {
                dispatch_once(&qword_1019345F0, &stru_101889328);
              }
              int v51 = 67240192;
              unsigned int v52 = a2;
              LODWORD(v45) = 8;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  0LL,  "Updated %{location:CLSensorRecorder_Types::DataType,public}d subscription override due to invalid time.",  &v51,  v45);
              uint64_t v44 = (uint8_t *)v43;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSensorRecorderNotifier::updateSubscriptionType(CLSensorRecorder_Types::DataType)",  "%s\n",  v43);
              if (v44 != buf) {
                free(v44);
              }
            }

            uint64_t v31 = sub_1002F8DDC();
            *(double *)std::stringbuf::string_type buf = v26;
            sub_1002AC820(v31, v9, buf);
            uint64_t v32 = sub_1002F8DDC();
            (*(void (**)(uint64_t))(*(void *)v32 + 944LL))(v32);
          }

          return;
        }

        goto LABEL_13;
      }

      if (a2 || *(_DWORD *)(a1 + 300) == 50)
      {
        if (a2 != 1 || *(_DWORD *)(a1 + 308) == 50)
        {
          if (a2 != 2 || *(_DWORD *)(a1 + 320) == *(_DWORD *)(a1 + 316))
          {
LABEL_71:
            uint64_t v35 = sub_1002F8DDC();
            sub_1002A832C(v35, (uint64_t)v8, &v50);
            if (Current >= v50)
            {
              if (a2)
              {
                char v15 = 0;
                goto LABEL_16;
              }
            }

            else
            {
              double v36 = vabdd_f64(v50, Current);
              double v37 = *(double *)(a1 + 272);
              char v15 = v36 < v37;
              if (a2) {
                goto LABEL_16;
              }
              if (v36 < v37)
              {
LABEL_13:
                uint64_t v14 = *(void *)(a1 + 272);
                *(void *)(a1 + 28sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(void *)(a1 + 264);
LABEL_14:
                *(void *)(a1 + 288) = v14;
                goto LABEL_15;
              }
            }

            char v15 = *(_BYTE *)(a1 + 336);
            if (!v15) {
              goto LABEL_16;
            }
            *(void *)(a1 + 28sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0x40AF400000000000LL;
            int v11 = 100;
            uint64_t v14 = 0x40AC200000000000LL;
            goto LABEL_14;
          }

          uint64_t v33 = sub_1002F8DDC();
          sub_1002A66DC(v33);
          int v11 = *(_DWORD *)(a1 + 316);
          *(_DWORD *)(a1 + 32sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v11;
        }

        else
        {
          uint64_t v25 = sub_1002F8DDC();
          sub_1002A66DC(v25);
          int v11 = 50;
          *(_DWORD *)(a1 + 308) = 50;
        }
      }

      else
      {
        uint64_t v21 = sub_1002F8DDC();
        sub_1002A66DC(v21);
        int v11 = 50;
        *(_DWORD *)(a1 + 30sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 50;
      }

      uint64_t v34 = sub_1002F8DDC();
      (*(void (**)(uint64_t))(*(void *)v34 + 944LL))(v34);
      goto LABEL_71;
    case 1u:
      unint64_t v5 = (int *)(a1 + 304);
      uint64_t v6 = (int *)(a1 + 308);
      uint64_t v7 = (unsigned __int8 *)(a1 + 326);
      BOOL v8 = @"kGyroBufferSubscription";
      char v9 = @"kGyroBufferSubscriptionOverride";
      goto LABEL_8;
  }

  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_101889348);
  }
  int v22 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)std::stringbuf::string_type buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Invalid data type.", buf, 2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101889348);
    }
    LOWORD(v51) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  16LL,  "Invalid data type.",  &v51,  2);
    double v24 = (uint8_t *)v23;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSensorRecorderNotifier::updateSubscriptionType(CLSensorRecorder_Types::DataType)",  "%s\n",  v23);
    if (v24 != buf) {
      free(v24);
    }
  }

uint64_t sub_100E7FFE0(uint64_t a1)
{
  double v3 = __chkstk_darwin(a1);
  double v5 = v4;
  double v6 = v3;
  BOOL v8 = v7;
  if (v2 == 2)
  {
    char v9 = v1 + 22;
  }

  else if (v2 == 1)
  {
    char v9 = v1 + 21;
  }

  else
  {
    if (v2) {
      return 0LL;
    }
    char v9 = v1 + 20;
  }

  uint64_t v10 = *v9;
  int v11 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (!sub_1006F80C4(v10, v11, v6, v5))
  {
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_101889328);
    }
    uint64_t v19 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134283777;
      double v58 = v6;
      __int16 v59 = 2049;
      double v60 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Error accessing sensor recorder data from %{private}f, %{private}f",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_101889328);
      }
      *(_DWORD *)unsigned int v52 = 134283777;
      double v53 = v6;
      __int16 v54 = 2049;
      *(double *)__int16 v55 = v5;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  0LL,  "Error accessing sensor recorder data from %{private}f, %{private}f",  v52,  22);
      uint64_t v31 = (uint8_t *)v30;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLSensorRecorderNotifier::writeSensorRecordDataToFile(CLSensorRecorder_Types::DataType, NSFileHandle *, CFA bsoluteTime, CFAbsoluteTime)",  "%s\n",  v30);
      if (v31 != buf) {
        free(v31);
      }
    }

    return 0LL;
  }

  v42[0] = 0LL;
  v42[1] = buf;
  int v43 = 147456;
  obuint64_t j = v11;
  double v37 = objc_alloc_init(&OBJC_CLASS___CLSensorRecorderSensorMetaSerializer);
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  id v12 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v38,  v56,  16LL);
  if (v12)
  {
    id v13 = v12;
    int v14 = 0;
    uint64_t v15 = *(void *)v39;
    while (2)
    {
      for (uint64_t i = 0LL; i != v13; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v39 != v15) {
          objc_enumerationMutation(obj);
        }
        uint64_t v17 = *(void **)(*((void *)&v38 + 1) + 8LL * (void)i);
        if (!v42[0]
          || (id v18 = [*(id *)(*((void *)&v38 + 1) + 8 * (void)i) dataIdentifier], v18 != (id)v42[0]))
        {
          ++v14;
          v42[0] = [v17 dataIdentifier];
          int v43 = 147456;
          if ((sub_1006F7338(v10, (uint64_t)v42, (sqlite3_int64)[v17 identifier]) & 1) == 0)
          {
            if (qword_1019345F0 != -1) {
              dispatch_once(&qword_1019345F0, &stru_101889328);
            }
            uint64_t v21 = (os_log_s *)qword_1019345F8;
            if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_DEFAULT))
            {
              id v22 = [v17 dataIdentifier];
              *(_DWORD *)unsigned int v52 = 134283521;
              double v53 = *(double *)&v22;
              _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Error occurred while retrieving data record %{private}llu",  v52,  0xCu);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(v52, 0x65CuLL);
              if (qword_1019345F0 != -1) {
                dispatch_once(&qword_1019345F0, &stru_101889328);
              }
              uint64_t v23 = qword_1019345F8;
              id v24 = [v17 dataIdentifier];
              int v50 = 134283521;
              id v51 = v24;
              _os_log_send_and_compose_impl( 2LL,  0LL,  v52,  1628LL,  &_mh_execute_header,  v23,  0LL,  "Error occurred while retrieving data record %{private}llu",  &v50,  12);
              double v26 = (uint8_t *)v25;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLSensorRecorderNotifier::writeSensorRecordDataToFile(CLSensorRecorder_Types::DataType, NSFileHandl e *, CFAbsoluteTime, CFAbsoluteTime)",  "%s\n",  v25);
              if (v26 != v52) {
                free(v26);
              }
            }

            goto LABEL_36;
          }
        }

        -[CLSensorRecorderSensorMetaSerializer writeMeta:toHandle:](v37, "writeMeta:toHandle:", v17, v8);
        objc_msgSend( v8,  "writeData:",  +[NSData dataWithBytes:length:]( NSData,  "dataWithBytes:length:",  &buf[objc_msgSend(v17, "offset")],  objc_msgSend(v17, "dataSize")));
      }

      id v13 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v38,  v56,  16LL);
      if (v13) {
        continue;
      }
      break;
    }
  }

  else
  {
    int v14 = 0;
  }

void sub_100E806B4(uint64_t a1)
{
  int v2 = (const void *)sub_1008FA854(0);
  if (v2)
  {
    if (v3)
    {
      int v4 = *(_DWORD *)(a1 + 32);
      switch(v4)
      {
        case 2:
          sub_10035CB14((uint64_t)v3, *(_DWORD *)(a1 + 36));
          break;
        case 1:
          sub_10035C938((uint64_t)v3, *(_DWORD *)(a1 + 36));
          break;
        case 0:
          sub_10035C75C((uint64_t)v3, *(_DWORD *)(a1 + 36));
          break;
      }
    }
  }

uint64_t sub_100E80740(uint64_t a1)
{
  *(void *)a1 = off_1018891D8;
  sub_100E80898(a1);

  uint64_t v2 = *(void *)(a1 + 352);
  *(void *)(a1 + 352) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 344);
  *(void *)(a1 + 344) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 328);
  *(void *)(a1 + 328) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  double v6 = (void **)(a1 + 216);
  sub_100006BC8(&v6);
  return sub_100E7F2D8(a1);
}

void sub_100E8080C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E80740(a1);
  operator delete(v1);
}

void *sub_100E80820@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

uint64_t sub_100E80898(uint64_t a1)
{
  *(_BYTE *)(a1 + 108) = 1;
  [*(id *)(a1 + 184) invalidate];

  *(void *)(a1 + 184) = 0LL;
  [*(id *)(a1 + 192) invalidate];

  *(void *)(a1 + 192) = 0LL;
  [*(id *)(a1 + 200) invalidate];

  *(void *)(a1 + 20sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  [*(id *)(a1 + 208) invalidate];

  *(void *)(a1 + 208) = 0LL;
  uint64_t v2 = *(void *)(a1 + 160);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24LL))(v2);
  }
  *(void *)(a1 + 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0LL;
  uint64_t v3 = *(void *)(a1 + 168);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 24LL))(v3);
  }
  *(void *)(a1 + 168) = 0LL;
  uint64_t result = *(void *)(a1 + 176);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  *(void *)(a1 + 176) = 0LL;
  return result;
}

void sub_100E80954(uint64_t a1)
{
  uint64_t v2 = +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:");
  uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSDateFormatter);
  -[NSDateFormatter setDateFormat:](v3, "setDateFormat:", @"yyyyMMdd_HH-mm-ss");
  uint64_t v4 = -[NSDateFormatter stringFromDate:](v3, "stringFromDate:", v2);
  sub_100E65E58((uint64_t)__p);
  if (v13 >= 0) {
    double v5 = __p;
  }
  else {
    double v5 = (void **)__p[0];
  }
  double v6 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%s/CoreMotionDebug_SensorRecorder_%@_accel.dat",  v5,  v4);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  if (!-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  v6)) {
    -[NSFileManager createFileAtPath:contents:attributes:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "createFileAtPath:contents:attributes:",  v6,  0LL,  0LL);
  }
  if (+[NSFileHandle fileHandleForWritingAtPath:](&OBJC_CLASS___NSFileHandle, "fileHandleForWritingAtPath:", v6))
  {
    sub_100E7FFE0(a1);
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_101889348);
    }
    uint64_t v7 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "Failed to dump sensor recorder (accel) to disk because fileHandle is nil.",  (uint8_t *)__p,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_101889348);
      }
      v11[0] = 0;
      LODWORD(v1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to dump sensor recorder (accel) to disk because fileHandle is nil.",  v11,  v10);
      char v9 = (void **)v8;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLSensorRecorderNotifier::writeAccelToDiskTriggeredBySysdiagnose()",  "%s\n",  v8);
      if (v9 != __p) {
        free(v9);
      }
    }
  }

void sub_100E80BE8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E80C0C(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  if (*a3 == 6)
  {
    if (qword_1019345F0 != -1) {
      dispatch_once(&qword_1019345F0, &stru_101889328);
    }
    uint64_t v4 = (os_log_s *)qword_1019345F8;
    if (os_log_type_enabled((os_log_t)qword_1019345F8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::stringbuf::string_type buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "#CacheDelete - onSoftwareUpdateStorageRecovery - Flushing SensorRecorderDB",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345F0 != -1) {
        dispatch_once(&qword_1019345F0, &stru_101889328);
      }
      v19[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345F8,  1LL,  "#CacheDelete - onSoftwareUpdateStorageRecovery - Flushing SensorRecorderDB",  v19,  2);
      id v12 = (uint8_t *)v11;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSensorRecorderNotifier::onSoftwareUpdateStorageRecovery(int, const CLClientManager_Type::Notification &, const CLClientManager_Type::NotificationData &)",  "%s\n",  v11);
      if (v12 != buf) {
        free(v12);
      }
    }

    sub_1006F6C1C(a1[20]);
    sub_1006F6C1C(a1[21]);
    sub_1006F6C1C(a1[22]);
    uint64_t v5 = a1[20];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 24LL))(v5);
    }
    uint64_t v6 = a1[21];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 24LL))(v6);
    }
    uint64_t v7 = a1[22];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 24LL))(v7);
    }
    BOOL v8 = operator new(0x1C8uLL);
    sub_1010DDBC0(__p, "");
    sub_1006F5458((uint64_t)v8, 0, (uint64_t)__p, 0);
    a1[20] = (uint64_t)v8;
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    char v9 = operator new(0x1C8uLL);
    sub_1010DDBC0(v15, "");
    sub_1006F5458((uint64_t)v9, 0, (uint64_t)v15, 1u);
    a1[21] = (uint64_t)v9;
    if (v16 < 0) {
      operator delete(v15[0]);
    }
    uint64_t v10 = operator new(0x1C8uLL);
    sub_1010DDBC0(v13, "");
    sub_1006F5458((uint64_t)v10, 0, (uint64_t)v13, 2u);
    a1[22] = (uint64_t)v10;
    if (v14 < 0) {
      operator delete(v13[0]);
    }
  }

void sub_100E80ECC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  operator delete(v29);
  _Unwind_Resume(a1);
}

void sub_100E80F30(uint64_t a1, uint64_t a2)
{
  HIDWORD(v15) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        char v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)std::stringbuf::string_type buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v15 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101889308);
      }
      uint64_t v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        int v11 = (void *)(a1 + 8);
        *(_DWORD *)std::stringbuf::string_type buf = 136446466;
        uint64_t v21 = v11;
        __int16 v22 = 1026;
        int v23 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101889308);
        }
        id v12 = (void *)(a1 + 8);
        int v16 = 136446466;
        uint64_t v17 = v12;
        __int16 v18 = 1026;
        int v19 = a2;
        LODWORD(v15) = 18;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
          &v16,
          v15);
        char v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::Notificati onData>::removeClient(int) [Notification_T = CLSensorRecorderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }
  }

uint64_t sub_100E811A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_1019913E0);
}

uint64_t sub_100E811B8(uint64_t a1, int a2, int *a3, char *a4)
{
  int v42 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        char v13 = (uint64_t *)v7;
      }
      else {
        char v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)int v43 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          id v24 = (uint64_t *)v18;
        }
        else {
          id v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }

      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          id v29 = (uint64_t *)v25;
        }
        else {
          id v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }

      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v41 = v26;
        uint64_t v34 = *(void *)(v26 + 56);
        char v35 = *a4;
        *(void *)std::stringbuf::string_type buf = &v42;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v26 + 40), &v42, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v35;
        *(void *)std::stringbuf::string_type buf = 0LL;
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, _BYTE *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          double v36 = sub_100E82AA4(buf);
          sub_100E82B24((_BYTE *)a1, (uint64_t)v43, (uint64_t)&v41, v36);
        }

        if (v34) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        uint64_t v41 = a1 + 64;
        char v30 = byte_1019913E1;
        HIDWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v17;
        *(void *)std::stringbuf::string_type buf = (char *)&v40 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v30;
        HIDWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *a3;
        *(void *)std::stringbuf::string_type buf = (char *)&v40 + 4;
        uint64_t v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v31 + 8);
        char v32 = *a4;
        HIDWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *a3;
        *(void *)std::stringbuf::string_type buf = (char *)&v40 + 4;
        id v33 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)std::stringbuf::string_type buf = &v42;
        *((_BYTE *)sub_1004EF3D4(v33 + 5, &v42, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v32;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v21 == v19)
      {
        *(_DWORD *)std::stringbuf::string_type buf = *a3;
        sub_10004A8FC((uint64_t **)(*(void *)v43 + 40LL), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101889308);
  }
  char v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    uint64_t v15 = (void *)(a1 + 8);
    *(_DWORD *)std::stringbuf::string_type buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    __int16 v47 = 1026;
    int v48 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL v16 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889308);
    }
    double v37 = (void *)(a1 + 8);
    *(_DWORD *)int v43 = 136446466;
    *(void *)&v43[4] = v37;
    __int16 v44 = 1026;
    int v45 = a2;
    LODWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
      v43,
      v40);
    __int128 v39 = (char *)v38;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::NotificationDa ta>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLSensorRe corderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData, Notificat ionInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v38);
    if (v39 != buf) {
      free(v39);
    }
    return 0LL;
  }

  return result;
}

BOOL sub_100E81614(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      char v9 = (uint64_t *)v5;
    }
    else {
      char v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        uint64_t v21 = (uint64_t *)v15;
      }
      else {
        uint64_t v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889308);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)std::stringbuf::string_type buf = 136446466;
      char v30 = v11;
      __int16 v31 = 1026;
      int v32 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101889308);
      }
      int v22 = (void *)(a1 + 8);
      int v25 = 136446466;
      uint64_t v26 = v22;
      __int16 v27 = 1026;
      int v28 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
        &v25,
        18);
      id v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::Notification Data>::clientRegistered(int, const Notification_T &) [Notification_T = CLSensorRecorderNotifier_Type::Notificati on, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100E81894(char *a1, int a2, int *a3)
{
  HIDWORD(v34) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        char v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            char v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            int v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                int v25 = (uint64_t *)v20;
              }
              else {
                int v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                int v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v34 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101889308);
              }
              uint64_t v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                __int16 v27 = a1 + 8;
                if (a1[31] < 0) {
                  __int16 v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v44 >= 0) {
                  int v28 = __p;
                }
                else {
                  int v28 = (void **)__p[0];
                }
                *(_DWORD *)std::stringbuf::string_type buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v36 = 2082;
                double v37 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v44 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101889308);
                }
                id v29 = a1 + 8;
                if (a1[31] < 0) {
                  id v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v38 >= 0) {
                  __int16 v31 = buf;
                }
                else {
                  __int16 v31 = *(_BYTE **)buf;
                }
                int v39 = 136446466;
                uint64_t v40 = v29;
                __int16 v41 = 2082;
                int v42 = v31;
                LODWORD(v34) = 22;
                _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                  &v39,
                  v34);
                id v33 = v32;
                if (v38 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::No tificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLSensorReco rderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v33);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_100E81C1C(uint64_t a1, int *a2, uint64_t *a3)
{
  uint64_t v6 = operator new(0x20uLL);
  xpc_object_t v6[2] = 0LL;
  void *v6 = off_1018894D8;
  v6[1] = 0LL;
  uint64_t v7 = *a3;
  *((void *)&v14 + 1) = v6;
  v6[3] = v7;
  *(void *)&__int128 v14 = v6 + 3;
  int v13 = *a2;
  int v15 = &v13;
  BOOL v8 = sub_10023347C((uint64_t **)(a1 + 56), &v13, (uint64_t)&unk_1012CF090, &v15);
  sub_10005F550((uint64_t)(v8 + 8), &v14);
  int v9 = (std::__shared_weak_count *)*((void *)&v14 + 1);
  if (*((void *)&v14 + 1))
  {
    BOOL v10 = (unint64_t *)(*((void *)&v14 + 1) + 8LL);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return 1LL;
}

void sub_100E81CF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100E81D04(uint64_t a1, unsigned int *a2, void *a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    BOOL v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889308);
    }
    unint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      BOOL v12 = (void *)(a1 + 8);
      int v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)std::stringbuf::string_type buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&_BYTE buf[20] = "activity";
      __int16 v67 = 2082;
      char v68 = v12;
      __int16 v69 = 2050;
      char v70 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    __int128 v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      __int128 v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)int v71 = &v71[8];
      memset(&v71[8], 0, 24);
      __int16 v72 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v71);
      int v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v70;
      if (v70)
      {
        p_shared_owners = (unint64_t *)&v70->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&buf[8], *(void **)&buf[16]);
      BOOL v24 = v72;
      if (v72)
      {
        int v25 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v71, *(void **)&v71[8]);
    }

    if (a4)
    {
      __int16 v27 = operator new(0x20uLL);
      unsigned int v27[2] = 0LL;
      *__int16 v27 = off_1018894D8;
      v27[1] = 0LL;
      v27[3] = *a3;
      *(void *)std::stringbuf::string_type buf = v27 + 3;
      *(void *)&uint8_t buf[8] = v27;
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      int v28 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        id v29 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v30 = __ldaxr(v29);
        while (__stlxr(v30 - 1, v29));
        if (!v30)
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    __int16 v31 = sub_100E83470(a3);
    if (a5 == -1)
    {
      sub_100E834F0((void *)a1, (int *)a2, v31);
    }

    else
    {
      uint64_t v32 = a1 + 88;
      uint64_t v33 = *(void *)(a1 + 88);
      if (!v33) {
        goto LABEL_48;
      }
      uint64_t v34 = a1 + 88;
      do
      {
        int v35 = *(_DWORD *)(v33 + 32);
        BOOL v36 = v35 < a5;
        if (v35 >= a5) {
          double v37 = (uint64_t *)v33;
        }
        else {
          double v37 = (uint64_t *)(v33 + 8);
        }
        if (!v36) {
          uint64_t v34 = v33;
        }
        uint64_t v33 = *v37;
      }

      while (*v37);
      if (v34 == v32 || *(_DWORD *)(v34 + 32) > a5) {
LABEL_48:
      }
        uint64_t v34 = a1 + 88;
      uint64_t v64 = v34;
      unint64_t v38 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v39 = *a2;
      uint64_t v40 = (__n128 *)(a1 + 64);
      do
      {
        int v41 = *(_DWORD *)(v38 + 32);
        BOOL v42 = v41 < v39;
        if (v41 >= v39) {
          int v43 = (unint64_t *)v38;
        }
        else {
          int v43 = (unint64_t *)(v38 + 8);
        }
        if (!v42) {
          uint64_t v40 = (__n128 *)v38;
        }
        unint64_t v38 = *v43;
      }

      while (*v43);
      if (v40 == v15 || v39 < (signed __int32)v40[2].n128_u32[0])
      {
LABEL_59:
        uint64_t v63 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101889308);
        }
        char v44 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          int v45 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v71, a1, a2);
          if (v71[23] >= 0) {
            __int16 v46 = v71;
          }
          else {
            __int16 v46 = *(_BYTE **)v71;
          }
          *(_DWORD *)std::stringbuf::string_type buf = 136315650;
          *(void *)&uint8_t buf[4] = v45;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a5;
          *(_WORD *)&buf[18] = 2080;
          *(void *)&_BYTE buf[20] = v46;
          _os_log_impl( (void *)&_mh_execute_header,  v44,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v71[23] & 0x80000000) != 0) {
            operator delete(*(void **)v71);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_101889308);
          }
          __int16 v47 = (void *)(a1 + 8);
          uint64_t v48 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v62 >= 0) {
            double v49 = __p;
          }
          else {
            double v49 = (void **)__p[0];
          }
          *(_DWORD *)int v71 = 136315650;
          *(void *)&v71[4] = v47;
          *(_WORD *)&v71[12] = 1024;
          *(_DWORD *)&_BYTE v71[14] = a5;
          *(_WORD *)&v71[18] = 2080;
          *(void *)&v71[20] = v49;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v48,  2LL,  "%s; client %d has deregistered, not notifying %s",
            v71,
            28,
            v60);
          id v51 = v50;
          if (v62 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::Notifica tionData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Notif ication_T = CLSensorRecorderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type: :NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v51);
          if (v51 != buf) {
            free(v51);
          }
        }

        goto LABEL_83;
      }

      uint64_t v63 = v40;
      if (v34 == v32) {
        goto LABEL_60;
      }
      uint64_t v54 = v40[3].n128_i64[0];
      unsigned int v52 = v40 + 3;
      double v53 = (__n128 *)v54;
      if (!v54) {
        goto LABEL_60;
      }
      int v55 = *(_DWORD *)(v34 + 32);
      int v56 = v52;
      do
      {
        int v57 = v53[1].n128_i32[3];
        BOOL v58 = v57 < v55;
        if (v57 >= v55) {
          __int16 v59 = v53;
        }
        else {
          __int16 v59 = (__n128 *)&v53->n128_i8[8];
        }
        if (!v58) {
          int v56 = v53;
        }
        double v53 = (__n128 *)v59->n128_u64[0];
      }

      while (v59->n128_u64[0]);
      sub_100E82B24((_BYTE *)a1, (uint64_t)&v64, (uint64_t)&v63, v31);
    }

void sub_100E8233C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_100E82388(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889308);
    }
    uint64_t v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      int v3 = (void *)(a1 + 8);
      *(_DWORD *)std::stringbuf::string_type buf = 136315138;
      double v37 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101889308);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v32 = 136315138;
      uint64_t v33 = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
        (const char *)&v32);
      uint64_t v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::Notification Data>::listClients() [Notification_T = CLSensorRecorderNotifier_Type::Notification, NotificationData_T = CLSenso rRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889308);
    }
    uint64_t v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      BOOL v8 = (void *)(a1 + 8);
      uint64_t v9 = *(void *)(a1 + 96);
      *(_DWORD *)std::stringbuf::string_type buf = 136315394;
      double v37 = v8;
      __int16 v38 = 2048;
      v39[0] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101889308);
      }
      __int16 v27 = (void *)(a1 + 8);
      uint64_t v28 = *(void *)(a1 + 96);
      int v32 = 136315394;
      uint64_t v33 = v27;
      __int16 v34 = 2048;
      v35[0] = v28;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
        (const char *)&v32,
        22);
      unint64_t v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::Notification Data>::listClients() [Notification_T = CLSensorRecorderNotifier_Type::Notification, NotificationData_T = CLSenso rRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }

    BOOL v10 = *(void **)(a1 + 80);
    if (v10 != (void *)(a1 + 88))
    {
      unint64_t v11 = (void *)(a1 + 8);
      do
      {
        BOOL v12 = (void *)v10[5];
        if (v12 != v10 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_101889308);
            }
            int v13 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              __int128 v14 = (void *)(a1 + 8);
              int v15 = *((_DWORD *)v10 + 8);
              int v16 = *((_DWORD *)v12 + 7);
              *(_DWORD *)std::stringbuf::string_type buf = 136315650;
              double v37 = v14;
              __int16 v38 = 1024;
              LODWORD(v39[0]) = v15;
              WORD2(v39[0]) = 1024;
              *(_DWORD *)((char *)v39 + 6) = v16;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101889308);
              }
              uint64_t v20 = (void *)(a1 + 8);
              int v21 = *((_DWORD *)v10 + 8);
              int v22 = *((_DWORD *)v12 + 7);
              int v32 = 136315650;
              uint64_t v33 = v20;
              __int16 v34 = 1024;
              LODWORD(v35[0]) = v21;
              WORD2(v35[0]) = 1024;
              *(_DWORD *)((char *)v35 + 6) = v22;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                (const char *)&v32,
                24,
                v31);
              BOOL v24 = (uint8_t *)v23;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::Noti ficationData>::listClients() [Notification_T = CLSensorRecorderNotifier_Type::Notification, Notification Data_T = CLSensorRecorderNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
              if (v24 != buf) {
                free(v24);
              }
            }

            int v17 = (void *)v12[1];
            if (v17)
            {
              do
              {
                signed __int32 v18 = v17;
                int v17 = (void *)*v17;
              }

              while (v17);
            }

            else
            {
              do
              {
                signed __int32 v18 = (void *)v12[2];
                BOOL v19 = *v18 == (void)v12;
                BOOL v12 = v18;
              }

              while (!v19);
            }

            BOOL v12 = v18;
          }

          while (v18 != v10 + 6);
        }

        int v25 = (void *)v10[1];
        if (v25)
        {
          do
          {
            unint64_t v26 = v25;
            int v25 = (void *)*v25;
          }

          while (v25);
        }

        else
        {
          do
          {
            unint64_t v26 = (void *)v10[2];
            BOOL v19 = *v26 == (void)v10;
            BOOL v10 = v26;
          }

          while (!v19);
        }

        BOOL v10 = v26;
      }

      while (v26 != (void *)(a1 + 88));
    }
  }

void sub_100E82930(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100E8295C(id a1)
{
  qword_1019345F8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "SensorRecorder");
}

void sub_100E82988(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void *sub_100E829B4(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &off_101889458;
  v4[1] = 0LL;
  v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100E829FC(void *a1)
{
  if (v1) {
    operator delete[](v1);
  }
  __cxa_rethrow();
}

void sub_100E82A14(_Unwind_Exception *a1)
{
}

void sub_100E82A28(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 24);
  if (v1) {
    operator delete[](v1);
  }
}

uint64_t sub_100E82A38(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

void sub_100E82A78(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

CLCppContainer *sub_100E82AA4(void *a1)
{
  uint64_t v2 = operator new(8uLL);
  *uint64_t v2 = *a1;
  uint64_t v4 = _NSConcreteStackBlock;
  uint64_t v5 = 3221225472LL;
  uint64_t v6 = sub_100E82C00;
  uint64_t v7 = &unk_10181D3D0;
  BOOL v8 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

_BYTE *sub_100E82B24(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    uint64_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_100E82C10(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    unint64_t v11 = (uint64_t **)(*(void *)a3 + 40LL);
    __int128 v14 = (int *)(*(void *)a2 + 32LL);
    BOOL v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    BOOL result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

void sub_100E82C00(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

id sub_100E82C10(void *a1)
{
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_100E82C88(a1);
  }
  objc_opt_class(&OBJC_CLASS___CLCppContainer);
  if ((objc_opt_isKindOfClass(a1, v4) & 1) != 0) {
    return sub_100E83010(a1);
  }
  else {
    return 0LL;
  }
}

id sub_100E82C88(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return sub_100E833BC((uint64_t)&v8 + 7, a1);
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018894A8);
    }
    int v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x80000001013631FBLL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018894A8);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(v8) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018894A8);
    }
    uint64_t v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218498;
      id v11 = v2;
      __int16 v12 = 2048;
      uint64_t v13 = 0LL;
      __int16 v14 = 2080;
      unint64_t v15 = 0x80000001013631FBLL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018894A8);
    }
    LODWORD(v9) = 134218498;
    HIDWORD(v9) = (_DWORD)v2;
    LODWORD(v8) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v9,  v8,  v9);
  }

  uint64_t v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLSensorRecorderNotifier_Type::NotificationData, Callbacuint64_t k = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:241:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_100E83010(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018894A8);
    }
    int v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001013631FBLL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018894A8);
    }
    LODWORD(v8) = 134218498;
    HIDWORD(v8) = (_DWORD)v2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018894A8);
    }
    uint64_t v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x80000001013631FBLL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_1018894A8);
    }
    LODWORD(v8) = 134218498;
    HIDWORD(v8) = (_DWORD)v2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  uint64_t v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLSensorRecorderNotifier_Type::NotificationData, Callbacuint64_t k = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:250:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

id sub_100E833BC(uint64_t a1, void *a2)
{
  if (![a2 cppObjectPtr]
    && objc_msgSend(objc_msgSend(a2, "compatibilityInfo"), "isEqual:", &off_1018D4778))
  {
    if (objc_msgSend(objc_msgSend(a2, "serialized"), "length") != (id)8) {
      sub_101274E34();
    }
    objc_msgSend(a2, "setCppObjectPtr:", objc_msgSend(objc_msgSend(a2, "serialized"), "bytes"));
  }

  return [a2 cppObjectPtr];
}

void sub_100E83430(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1018894D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E83444(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1018894D8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

CLCppContainer *sub_100E83470(void *a1)
{
  id v2 = operator new(8uLL);
  *id v2 = *a1;
  uint64_t v4 = _NSConcreteStackBlock;
  uint64_t v5 = 3221225472LL;
  uint64_t v6 = sub_100E838C4;
  uint64_t v7 = &unk_10181D3D0;
  uint64_t v8 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_100E834F0(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    uint64_t v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      uint64_t v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v4;
        }
        else {
          uint64_t v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          uint64_t v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        id v51 = v9;
        id v13 = sub_100E82C10(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        unint64_t v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          unint64_t v15 = a1 + 11;
          int v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            BOOL v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                int v22 = (uint64_t *)v17;
              }
              else {
                int v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                BOOL v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              int v50 = v19;
              sub_100E82B24(a1, (uint64_t)&v50, (uint64_t)&v51, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              id v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  int v32 = (uint64_t *)v27;
                }
                else {
                  int v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  id v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              id v51 = v29;
              uint64_t v34 = v29[6];
              unint64_t v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                int v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    int v39 = (uint64_t *)v36;
                  }
                  else {
                    int v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    int v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      BOOL v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      BOOL v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      unint64_t v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  int v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      unint64_t v14 = v43;
                      int v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      unint64_t v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      int v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              int v50 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101889308);
              }
              BOOL v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)std::stringbuf::string_type buf = 136446466;
                int v57 = v25;
                __int16 v58 = 1026;
                int v59 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101889308);
                }
                int v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v52 = 136446466;
                double v53 = v45;
                __int16 v54 = 1026;
                int v55 = v46;
                LODWORD(v49) = 18;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                  &v52,
                  v49);
                uint64_t v48 = (uint8_t *)v47;
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLSensorRecorderNotifier_Type::Notification, CLSensorRecorderNotifier_Type::Notificati onData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLSensorRec orderNotifier_Type::Notification, NotificationData_T = CLSensorRecorderNotifier_Type::NotificationData , NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
                if (v48 != buf) {
                  free(v48);
                }
              }
            }
          }

          while (v14 != v51 + 6);
        }
      }
    }
  }

void sub_100E838C4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

NSDictionary *sub_100E838D4()
{
  v1[0] = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "VO2MaxPowerBudgetEstimatorQueryLookbackInterval");
  v2[0] = &off_1018D7228;
  v1[1] = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "SensitiveEscalationExtendedBudgetRefreshInterval");
  v2[1] = &off_1018D7240;
  v1[2] = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "VO2MaxDeescalatorExtendAfterHighExertionTimeSeconds");
  v2[2] = &off_1018D7258;
  v1[3] = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "SensitiveEscalationBudgetAllowanceSeconds");
  v2[3] = &off_1018D7270;
  v1[4] = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "SensitiveEscalationExtendedBudgetAllowanceSeconds");
  v2[4] = &off_1018D7288;
  _OWORD v1[5] = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "SensitiveEscalationGeneralStairsBudgetAllowanceSeconds");
  v2[5] = &off_1018D72A0;
  v1[6] = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "SensitiveEscalationGeneralStairsBudgetRefreshInterval");
  v2[6] = &off_1018D72B8;
  BOOL result = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v2,  v1,  7LL);
  qword_10199EE30 = (uint64_t)result;
  return result;
}

void sub_100E83AC8(id a1)
{
  qword_10199EE68 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLBTLEBeaconProviderMockSilo");
}

uint64_t sub_100E83B7C(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100E85108;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_10199EE80 != -1) {
    dispatch_once(&qword_10199EE80, block);
  }
  return qword_10199EE78;
}

void sub_100E83D58(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E83D6C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 136;
  uint64_t v4 = sub_100E87698(a1 + 136, 0LL, 0LL, a2);
  uint64_t v5 = *(void *)(a1 + 136);
  *uint64_t v4 = v5;
  v4[1] = v3;
  *(void *)(v5 + 8) = v4;
  *(void *)(a1 + 136) = v4;
  ++*(void *)(a1 + 152);
  if (*(_BYTE *)(a1 + 110))
  {
    CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 216));
    uint64_t v6 = (__CFRunLoop *)sub_10029228C();
    CFRunLoopWakeUp(v6);
  }

uint64_t sub_100E83DDC(uint64_t a1)
{
  *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = &off_10182CE18;
  *(void *)a1 = &off_10182CE18;
  return a1;
}

void sub_100E83E80(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E83E94(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 112;
  uint64_t v4 = sub_100E875AC(a1 + 112, 0LL, 0LL, a2);
  uint64_t v5 = *(void *)(a1 + 112);
  *uint64_t v4 = v5;
  v4[1] = v3;
  *(void *)(v5 + 8) = v4;
  *(void *)(a1 + 112) = v4;
  ++*(void *)(a1 + 128);
  if (*(_BYTE *)(a1 + 110))
  {
    CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 216));
    uint64_t v6 = (__CFRunLoop *)sub_10029228C();
    CFRunLoopWakeUp(v6);
  }

uint64_t sub_100E83F30(uint64_t a1, void *a2)
{
  uint64_t v3 = (char *)sub_100E86D4C(a1, "CLBTLEBeaconProviderMock-Notifier", a2);
  *(void *)uint64_t v3 = off_101889548;
  *(_WORD *)(v3 + 109) = 1;
  *((void *)v3 + 14) = v3 + 112;
  *((void *)v3 + 15) = v3 + 112;
  *((void *)v3 + 16) = 0LL;
  *((void *)v3 + 17) = v3 + 136;
  *((void *)v3 + 18) = v3 + 136;
  *((void *)v3 + 19) = 0LL;
  *((void *)v3 + 2sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v3 + 160;
  *((void *)v3 + 21) = v3 + 160;
  *((void *)v3 + 25) = 0LL;
  *((void *)v3 + 22) = 0LL;
  *((void *)v3 + 24) = v3 + 200;
  *((void *)v3 + 26) = 0LL;
  v6.version = 0LL;
  v6.info = v3;
  memset(&v6.retain, 0, 56);
  v6.perform = (void (__cdecl *)(void *))sub_100E84060;
  *(void *)(a1 + 216) = CFRunLoopSourceCreate(kCFAllocatorDefault, 0LL, &v6);
  uint64_t v4 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, 0LL);
  *(void *)(a1 + 184) = v4;
  dispatch_source_set_timer(v4, 0LL, 0x3B9ACA00uLL, 0LL);
  return a1;
}

void sub_100E84028(_Unwind_Exception *a1)
{
}

void sub_100E84060(uint64_t a1)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_1018896A0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v7 = 1;
    id v2 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLBTLEBeaconProviderMock::onEventSource",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v2, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018896A0);
    }
    uint64_t v3 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)std::stringbuf::string_type buf = 68289538;
      int v9 = 0;
      __int16 v10 = 2082;
      BOOL v11 = "";
      __int16 v12 = 2082;
      id v13 = "activity";
      __int16 v14 = 2050;
      uint64_t v15 = a1;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLBTLEBeaconProviderMock::onEventSource, event:%{public, location:escape_only}s,  this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v7 = 0;
  }

  id v4 = [*(id *)(a1 + 32) silo];
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100E86DE8;
  v5[3] = &unk_10181D3D0;
  v5[4] = a1;
  [v4 sync:v5];
  if (v7) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E84238( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, os_activity_scope_state_s state, char a15)
{
  if (a15) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E84258(uint64_t a1)
{
  *(void *)a1 = off_101889548;
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 184));
  dispatch_release(*(dispatch_object_t *)(a1 + 184));
  sub_100E842D4(a1);
  id v2 = *(const void **)(a1 + 216);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 216) = 0LL;
  }

  sub_100E87324(a1 + 192, *(char **)(a1 + 200));
  sub_1001B4C40((void *)(a1 + 160));
  sub_100E86DF0((uint64_t *)(a1 + 136));
  sub_100E86EB8((uint64_t *)(a1 + 112));
  return sub_100E86F28(a1);
}

void sub_100E842D4(uint64_t a1)
{
  id v2 = (__CFRunLoop *)sub_10029228C();
  if (CFRunLoopContainsSource(v2, *(CFRunLoopSourceRef *)(a1 + 216), kCFRunLoopCommonModes))
  {
    uint64_t v3 = (__CFRunLoop *)sub_10029228C();
    CFRunLoopRemoveSource(v3, *(CFRunLoopSourceRef *)(a1 + 216), kCFRunLoopCommonModes);
  }

  *(_BYTE *)(a1 + 11sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
}

void sub_100E84328(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E84258(a1);
  operator delete(v1);
}

uint64_t sub_100E84340(uint64_t a1, uint64_t a2)
{
  id v4 = (uint64_t **)(a1 + 192);
  uint64_t v5 = sub_100528D38(a1 + 192, a2);
  if ((void *)(a1 + 200) == v5)
  {
    uint64_t v9 = a2;
    uint64_t v5 = sub_100E87384(v4, a2, (uint64_t)&unk_1012CF090, &v9);
    int v6 = 1;
  }

  else
  {
    int v6 = *((_DWORD *)v5 + 18) + 1;
  }

  *((_DWORD *)v5 + 18) = v6;
  if (*(_BYTE *)(a1 + 110))
  {
    CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 216));
    char v7 = (__CFRunLoop *)sub_10029228C();
    CFRunLoopWakeUp(v7);
  }

  return 1LL;
}

uint64_t sub_100E843D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t **)(a1 + 192);
  id v4 = sub_100528D38(a1 + 192, a2);
  if ((void *)(a1 + 200) != v4)
  {
    int v5 = *((_DWORD *)v4 + 18);
    BOOL v6 = v5 != 0;
    int v7 = v5 - 1;
    if (v7 != 0 && v6) {
      *((_DWORD *)v4 + 18) = v7;
    }
    else {
      sub_100E8755C(v3, (uint64_t)v4);
    }
  }

  return 1LL;
}

void sub_100E84430(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 200);
  sub_100E87324(a1 + 192, *(char **)(a1 + 200));
  *(v1 - 1) = v1;
  void *v1 = 0LL;
  v1[1] = 0LL;
}

void sub_100E84460(uint64_t a1, double a2)
{
  id v4 = (double *)operator new(0x18uLL);
  v4[2] = a2;
  uint64_t v5 = *(void *)(a1 + 160);
  *(void *)id v4 = v5;
  *((void *)v4 + 1) = a1 + 160;
  *(void *)(v5 + 8) = v4;
  *(void *)(a1 + 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v4;
  ++*(void *)(a1 + 176);
  if (*(_BYTE *)(a1 + 110))
  {
    CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 216));
    BOOL v6 = (__CFRunLoop *)sub_10029228C();
    CFRunLoopWakeUp(v6);
  }

void sub_100E844D8(uint64_t a1)
{
  id v2 = *(dispatch_source_s **)(a1 + 184);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_100E84540;
  handler[3] = &unk_10181D3D0;
  handler[4] = a1;
  dispatch_source_set_event_handler(v2, handler);
  dispatch_resume(*(dispatch_object_t *)(a1 + 184));
}

uint64_t sub_100E84540(uint64_t a1)
{
  return (*(uint64_t (**)(void, double))(**(void **)(a1 + 32) + 232LL))(*(void *)(a1 + 32), 1.0);
}

void sub_100E84554(uint64_t a1)
{
}

void sub_100E8455C(uint64_t a1)
{
  id v2 = (__CFRunLoop *)sub_10029228C();
  if (!CFRunLoopContainsSource(v2, *(CFRunLoopSourceRef *)(a1 + 216), kCFRunLoopCommonModes))
  {
    uint64_t v3 = (__CFRunLoop *)sub_10029228C();
    CFRunLoopAddSource(v3, *(CFRunLoopSourceRef *)(a1 + 216), kCFRunLoopCommonModes);
    CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(a1 + 216));
    id v4 = (__CFRunLoop *)sub_10029228C();
    CFRunLoopWakeUp(v4);
  }

  *(_BYTE *)(a1 + 11sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 1;
}

void sub_100E845C0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 109))
  {
    uint64_t v1 = (void *)a1;
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018897A0);
    }
    id v2 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = v1[22];
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Attempting to fulfill scan requests,%lu.",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018897A0);
      }
      uint64_t v27 = v1[22];
      int v39 = 134217984;
      uint64_t v40 = v27;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Attempting to fulfill scan requests,%lu.",  &v39);
      id v29 = (char *)v28;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLBTLEBeaconProviderMock::onEventSource()", "%s\n", v28);
    }

    id v4 = v1 + 20;
    uint64_t v5 = (uint64_t *)v1[21];
    int v37 = v1;
    int v6 = 0;
    if (v5 != v1 + 20)
    {
      uint64_t v7 = (uint64_t)(v1 + 14);
      do
      {
        if (v1[16])
        {
          *(void *)&__int128 buf = &buf;
          *((void *)&buf + 1) = &buf;
          uint64_t v42 = 0LL;
          int v43 = &off_10182CE18;
          __int128 v44 = 0u;
          __int128 v45 = 0u;
          int v46 = &off_10182CE18;
          __int128 __p = 0u;
          __int128 v48 = 0u;
          LODWORD(v49) = 1;
          char v50 = 1;
          uint64_t v8 = v1[15];
          int v39 = 0;
          (*(void (**)(void *, int *, __int128 *, void, uint64_t, void))(*v1 + 152LL))( v1,  &v39,  &buf,  0LL,  0xFFFFFFFFLL,  0LL);
          sub_100E84FC0(v7);
          int v46 = &off_10182CE18;
          if (SBYTE7(v48) < 0) {
            operator delete((void *)__p);
          }
          int v43 = &off_10182CE18;
          if (SBYTE7(v45) < 0) {
            operator delete((void *)v44);
          }
          sub_100527BBC((uint64_t *)&buf);
        }

        uint64_t v9 = *v5;
        __int16 v10 = (uint64_t *)v5[1];
        *(void *)(v9 + 8) = v10;
        *(void *)v5[1] = v9;
        --v37[22];
        operator delete(v5);
        ++v6;
        uint64_t v5 = v10;
        BOOL v11 = v10 == v4;
        uint64_t v1 = v37;
      }

      while (!v11);
    }

    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018897A0);
    }
    __int16 v12 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "Fulfilled scan requests,%d.",  (uint8_t *)&buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018897A0);
      }
      int v39 = 67109120;
      LODWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v6;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Fulfilled scan requests,%d.",  &v39);
      BOOL v31 = (char *)v30;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLBTLEBeaconProviderMock::onEventSource()", "%s\n", v30);
    }

    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018897A0);
    }
    id v13 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v14 = v1[26];
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "Processing events for %lu proximity zones.",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_1018897A0);
      }
      uint64_t v32 = v1[26];
      int v39 = 134217984;
      uint64_t v40 = v32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Processing events for %lu proximity zones.",  &v39);
      uint64_t v34 = (char *)v33;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLBTLEBeaconProviderMock::onEventSource()", "%s\n", v33);
    }

    uint64_t v15 = (void *)v1[24];
    uint64_t v36 = v1 + 25;
    if (v15 == v1 + 25)
    {
      int v38 = 0;
    }

    else
    {
      int v38 = 0;
      int v16 = v1 + 17;
      do
      {
        uint64_t v17 = (uint64_t *)v1[18];
        while (v17 != v16)
        {
          if (v15 + 4 == v17 + 2
            || *((_DWORD *)v15 + 17) == *((_DWORD *)v17 + 13)
            && sub_10091D194((uint64_t)(v15 + 4), (uint64_t)(v17 + 2)))
          {
            *(void *)&__int128 buf = &buf;
            *((void *)&buf + 1) = &buf;
            uint64_t v42 = 0LL;
            int v43 = &off_10182CE18;
            __int128 v44 = 0u;
            __int128 v45 = 0u;
            int v46 = &off_10182CE18;
            __int128 __p = 0u;
            __int128 v48 = 0u;
            LODWORD(v49) = 1;
            char v50 = 1;
            std::string::operator=((std::string *)&v44, (const std::string *)v17 + 1);
            *((void *)&v45 + 1) = v17[6];
            std::string::operator=((std::string *)&__p, (const std::string *)(v17 + 8));
            *((void *)&v48 + 1) = v17[11];
            uint64_t v49 = v17[12];
            int v39 = 1;
            (*(void (**)(void *, int *, __int128 *, void, uint64_t, void))(*v1 + 152LL))( v1,  &v39,  &buf,  0LL,  0xFFFFFFFFLL,  0LL);
            int v18 = v1;
            uint64_t v19 = *v17;
            int v20 = (uint64_t *)v17[1];
            *(void *)(v19 + 8) = v20;
            *(void *)v17[1] = v19;
            --v18[19];
            sub_100E86E60((uint64_t)(v17 + 2));
            operator delete(v17);
            int v46 = &off_10182CE18;
            if (SBYTE7(v48) < 0) {
              operator delete((void *)__p);
            }
            int v43 = &off_10182CE18;
            if (SBYTE7(v45) < 0) {
              operator delete((void *)v44);
            }
            ++v38;
            sub_100527BBC((uint64_t *)&buf);
            uint64_t v17 = v20;
            uint64_t v1 = v37;
          }

          else
          {
            uint64_t v17 = (uint64_t *)v17[1];
          }
        }

        BOOL v21 = (void *)v15[1];
        if (v21)
        {
          do
          {
            int v22 = v21;
            BOOL v21 = (void *)*v21;
          }

          while (v21);
        }

        else
        {
          do
          {
            int v22 = (void *)v15[2];
            BOOL v11 = *v22 == (void)v15;
            uint64_t v15 = v22;
          }

          while (!v11);
        }

        uint64_t v15 = v22;
      }

      while (v22 != v36);
    }

    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018897A0);
    }
    int v26 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v38;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "Processed %d proximity zone events.",  (uint8_t *)&buf,  8u);
    }

    if (!sub_1002921D0(115, 2)) {
      return;
    }
    bzero(&buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018897A0);
    }
    int v39 = 67109120;
    LODWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v38;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Processed %d proximity zone events.",  &v39);
    int v25 = (char *)v35;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLBTLEBeaconProviderMock::onEventSource()", "%s\n", v35);
LABEL_79:
    return;
  }

  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_1018897A0);
  }
  int v23 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(buf) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEBUG,  "Bluetooth is powered off, no events will be processed.",  (uint8_t *)&buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_1018897A0);
    }
    LOWORD(v39) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "Bluetooth is powered off, no events will be processed.",  &v39,  2);
    int v25 = (char *)v24;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLBTLEBeaconProviderMock::onEventSource()", "%s\n", v24);
    goto LABEL_79;
  }

void sub_100E84F98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100E84FC0(uint64_t a1)
{
  id v2 = *(uint64_t **)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v3 = *v2;
  *(void *)(v3 + 8) = v2[1];
  *(void *)v2[1] = v3;
  *(void *)(a1 + 16) = v1 - 1;
  sub_100527BBC(v2 + 2);
  operator delete(v2);
}

void *sub_100E85000@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

uint64_t sub_100E85078(uint64_t a1, _DWORD *a2)
{
  if (*a2 <= 1u) {
    sub_100E8455C(a1);
  }
  return 1LL;
}

uint64_t sub_100E8509C(uint64_t a1, _DWORD *a2)
{
  if (*a2 <= 1u)
  {
    int v4 = 0;
    if (!sub_100247620(a1, &v4, 1LL))
    {
      int v5 = 1;
    }
  }

  return 1LL;
}

uint64_t sub_100E85108(uint64_t a1)
{
  id v2 = operator new(0xE0uLL);
  uint64_t result = sub_100E83F30((uint64_t)v2, *(void **)(a1 + 32));
  qword_10199EE78 = (uint64_t)v2;
  return result;
}

void sub_100E85140(_Unwind_Exception *a1)
{
}

void sub_100E85154(uint64_t a1, uint64_t a2)
{
  HIDWORD(v15) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)__int128 buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v15 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_1018896A0);
      }
      __int16 v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        BOOL v11 = (void *)(a1 + 8);
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v21 = v11;
        __int16 v22 = 1026;
        int v23 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_1018896A0);
        }
        __int16 v12 = (void *)(a1 + 8);
        int v16 = 136446466;
        uint64_t v17 = v12;
        __int16 v18 = 1026;
        int v19 = a2;
        LODWORD(v15) = 18;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
          &v16,
          v15);
        uint64_t v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, char, char>::removeClient(int) [Notification_T = CLBTLEBeaconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }
  }

uint64_t sub_100E853C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_101991568);
}

BOOL sub_100E853DC(uint64_t a1, int a2, int *a3, char *a4)
{
  int v41 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        id v13 = (uint64_t *)v7;
      }
      else {
        id v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      uint64_t v40 = v10;
      int v16 = *a3;
      uint64_t v19 = *(void *)(v10 + 48);
      uint64_t v18 = v10 + 48;
      uint64_t v17 = v19;
      if (!v19) {
        goto LABEL_31;
      }
      uint64_t v20 = v18;
      do
      {
        int v21 = *(_DWORD *)(v17 + 28);
        BOOL v22 = v21 < v16;
        if (v21 >= v16) {
          int v23 = (uint64_t *)v17;
        }
        else {
          int v23 = (uint64_t *)(v17 + 8);
        }
        if (!v22) {
          uint64_t v20 = v17;
        }
        uint64_t v17 = *v23;
      }

      while (*v23);
      if (v20 == v18 || v16 < *(_DWORD *)(v20 + 28)) {
LABEL_31:
      }
        uint64_t v20 = v18;
      uint64_t v24 = *(void *)(a1 + 64);
      if (!v24) {
        goto LABEL_42;
      }
      uint64_t v25 = a1 + 64;
      do
      {
        int v26 = *(_DWORD *)(v24 + 32);
        BOOL v27 = v26 < v16;
        if (v26 >= v16) {
          int v28 = (uint64_t *)v24;
        }
        else {
          int v28 = (uint64_t *)(v24 + 8);
        }
        if (!v27) {
          uint64_t v25 = v24;
        }
        uint64_t v24 = *v28;
      }

      while (*v28);
      if (v25 != a1 + 64 && v16 >= *(_DWORD *)(v25 + 32))
      {
        *(void *)uint64_t v42 = v25;
        uint64_t v33 = *(void *)(v25 + 56);
        char v34 = *a4;
        *(void *)__int128 buf = &v41;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v25 + 40), &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v34;
        *(void *)__int128 buf = buf;
        *(_OWORD *)&uint8_t buf[8] = (unint64_t)buf;
        int v46 = &off_10182CE18;
        *(_OWORD *)__int16 v47 = 0u;
        __int128 v48 = 0u;
        uint64_t v49 = &off_10182CE18;
        *(_OWORD *)__int128 __p = 0u;
        __int128 v51 = 0u;
        int v52 = 1;
        char v53 = 1;
        if (v20 == v18
          && (*(unsigned int (**)(uint64_t, int *, _BYTE *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          int v35 = sub_100E884D8((uint64_t)buf);
          sub_100E87D08((_BYTE *)a1, (uint64_t)&v40, (uint64_t)v42, v35);
        }

        uint64_t v49 = &off_10182CE18;
        if (SBYTE7(v51) < 0) {
          operator delete(__p[0]);
        }
        int v46 = &off_10182CE18;
        if (SBYTE7(v48) < 0) {
          operator delete(v47[0]);
        }
        sub_100527BBC((uint64_t *)buf);
        if (v33) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        *(void *)uint64_t v42 = a1 + 64;
        char v29 = byte_101991569;
        HIDWORD(v39) = v16;
        *(void *)__int128 buf = (char *)&v39 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v29;
        HIDWORD(v39) = *a3;
        *(void *)__int128 buf = (char *)&v39 + 4;
        int v30 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v30 + 8);
        char v31 = *a4;
        HIDWORD(v39) = *a3;
        *(void *)__int128 buf = (char *)&v39 + 4;
        uint64_t v32 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v39 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)__int128 buf = &v41;
        *((_BYTE *)sub_1004EF3D4(v32 + 5, &v41, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v31;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v20 == v18)
      {
        *(_DWORD *)__int128 buf = *a3;
        sub_10004A8FC((uint64_t **)(v40 + 40), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_1018896A0);
  }
  uint64_t v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    uint64_t v15 = (void *)(a1 + 8);
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = v15;
    *(_WORD *)&_BYTE buf[12] = 1026;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      buf,
      0x12u);
  }

  BOOL result = sub_1002921D0(115, 0);
  if (result)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018896A0);
    }
    uint64_t v36 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t v42 = 136446466;
    *(void *)&v42[4] = v36;
    __int16 v43 = 1026;
    int v44 = a2;
    LODWORD(v39) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
      v42,
      v39);
    int v38 = (char *)v37;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, char , char>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLBTLE BeaconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, NotificationI nfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v37);
    if (v38 != buf) {
      free(v38);
    }
    return 0LL;
  }

  return result;
}

void sub_100E858AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

BOOL sub_100E858CC(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        int v21 = (uint64_t *)v15;
      }
      else {
        int v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018896A0);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136446466;
      int v30 = v11;
      __int16 v31 = 1026;
      int v32 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_1018896A0);
      }
      BOOL v22 = (void *)(a1 + 8);
      int v25 = 136446466;
      int v26 = v22;
      __int16 v27 = 1026;
      int v28 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
        &v25,
        18);
      uint64_t v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, ch ar, char>::clientRegistered(int, const Notification_T &) [Notification_T = CLBTLEBeaconProvider_Type::Notificati on, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100E85B4C(char *a1, int a2, int *a3)
{
  HIDWORD(v34) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        id v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            id v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            BOOL v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                int v25 = (uint64_t *)v20;
              }
              else {
                int v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                BOOL v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v34 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_1018896A0);
              }
              int v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                __int16 v27 = a1 + 8;
                if (a1[31] < 0) {
                  __int16 v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v44 >= 0) {
                  int v28 = __p;
                }
                else {
                  int v28 = (void **)__p[0];
                }
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v36 = 2082;
                int v37 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v44 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_1018896A0);
                }
                char v29 = a1 + 8;
                if (a1[31] < 0) {
                  char v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v38 >= 0) {
                  __int16 v31 = buf;
                }
                else {
                  __int16 v31 = *(_BYTE **)buf;
                }
                int v39 = 136446466;
                uint64_t v40 = v29;
                __int16 v41 = 2082;
                uint64_t v42 = v31;
                LODWORD(v34) = 22;
                _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                  &v39,
                  v34);
                uint64_t v33 = v32;
                if (v38 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::Notificati onData, char, char>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLBTLEBe aconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, Not ificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v33);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_100E85ED4(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 64);
  uint64_t v3 = a1 + 64;
  uint64_t v4 = v5;
  if (!v5) {
    return 0LL;
  }
  int v7 = *a2;
  uint64_t v8 = v3;
  do
  {
    int v9 = *(_DWORD *)(v4 + 32);
    BOOL v10 = v9 < v7;
    if (v9 >= v7) {
      int v11 = (uint64_t *)v4;
    }
    else {
      int v11 = (uint64_t *)(v4 + 8);
    }
    if (!v10) {
      uint64_t v8 = v4;
    }
    uint64_t v4 = *v11;
  }

  while (*v11);
  if (v8 == v3) {
    return 0LL;
  }
  if (v7 < *(_DWORD *)(v8 + 32)) {
    return 0LL;
  }
  uint64_t v12 = *(void *)(v8 + 64);
  if (!v12) {
    return 0LL;
  }
  if (v12 != a3) {
    sub_100E86FC8((uint64_t *)a3, *(void *)(v12 + 8), *(void *)(v8 + 64));
  }
  std::string::operator=((std::string *)(a3 + 32), (const std::string *)(v12 + 32));
  *(void *)(a3 + 56) = *(void *)(v12 + 56);
  std::string::operator=((std::string *)(a3 + 72), (const std::string *)(v12 + 72));
  *(void *)(a3 + 96) = *(void *)(v12 + 96);
  *(void *)(a3 + 104) = *(void *)(v12 + 104);
  *(_BYTE *)(a3 + 112) = *(_BYTE *)(v12 + 112);
  return 1LL;
}

uint64_t sub_100E85F94(uint64_t a1, int *a2, uint64_t a3)
{
  int v10 = *a2;
  uint64_t v12 = &v10;
  uint64_t v5 = sub_10023347C((uint64_t **)(a1 + 56), &v10, (uint64_t)&unk_1012CF090, &v12);
  sub_10005F550((uint64_t)(v5 + 8), &v11);
  uint64_t v6 = (std::__shared_weak_count *)*((void *)&v11 + 1);
  if (*((void *)&v11 + 1))
  {
    int v7 = (unint64_t *)(*((void *)&v11 + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return 1LL;
}

void sub_100E86040(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100E86054(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v4[0] = (uint64_t)v4;
  v4[1] = (uint64_t)v4;
  v4[2] = 0LL;
  uint64_t v5 = &off_10182CE18;
  *(_OWORD *)uint64_t v6 = 0u;
  __int128 v7 = 0u;
  unint64_t v8 = &off_10182CE18;
  *(_OWORD *)__int128 __p = 0u;
  __int128 v10 = 0u;
  int v11 = 1;
  char v12 = 1;
  (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  v4,  a3,  a4,  0LL);
  unint64_t v8 = &off_10182CE18;
  if (SBYTE7(v10) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v5 = &off_10182CE18;
  if (SBYTE7(v7) < 0) {
    operator delete(v6[0]);
  }
  sub_100527BBC(v4);
}

void sub_100E860FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E86110(uint64_t a1, int *a2, uint64_t a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    __int128 v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018896A0);
    }
    int v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      char v12 = (void *)(a1 + 8);
      id v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)__int128 buf = 68289794;
      *(_DWORD *)char v66 = 0;
      *(_WORD *)&v66[4] = 2082;
      *(void *)&v66[6] = "";
      *(_WORD *)&v66[14] = 2082;
      *(void *)&v66[16] = "activity";
      __int16 v67 = 2082;
      char v68 = v12;
      __int16 v69 = 2050;
      char v70 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    uint64_t v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      uint64_t v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)int v71 = &v71[8];
      memset(&v71[8], 0, 24);
      __int16 v72 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v71);
      int v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v70;
      if (v70)
      {
        p_shared_owners = (unint64_t *)&v70->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&v66[4], *(void **)&v66[12]);
      BOOL v24 = v72;
      if (v72)
      {
        int v25 = (unint64_t *)&v72->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v71, *(void **)&v71[8]);
    }

    if (a4)
    {
      sub_100E87DE4(a3, buf);
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      __int16 v27 = *(std::__shared_weak_count **)&v66[4];
      if (*(void *)&v66[4])
      {
        int v28 = (unint64_t *)(*(void *)&v66[4] + 8LL);
        do
          unint64_t v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    uint64_t v30 = sub_100E877DC(a3);
    if (a5 == -1)
    {
      sub_100E87934((void *)a1, a2, v30);
    }

    else
    {
      uint64_t v31 = a1 + 88;
      uint64_t v32 = *(void *)(a1 + 88);
      if (!v32) {
        goto LABEL_48;
      }
      uint64_t v33 = a1 + 88;
      do
      {
        int v34 = *(_DWORD *)(v32 + 32);
        BOOL v35 = v34 < a5;
        if (v34 >= a5) {
          __int16 v36 = (uint64_t *)v32;
        }
        else {
          __int16 v36 = (uint64_t *)(v32 + 8);
        }
        if (!v35) {
          uint64_t v33 = v32;
        }
        uint64_t v32 = *v36;
      }

      while (*v36);
      if (v33 == v31 || *(_DWORD *)(v33 + 32) > a5) {
LABEL_48:
      }
        uint64_t v33 = a1 + 88;
      uint64_t v63 = v33;
      unint64_t v37 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v38 = *a2;
      int v39 = (__n128 *)(a1 + 64);
      do
      {
        int v40 = *(_DWORD *)(v37 + 32);
        BOOL v41 = v40 < v38;
        if (v40 >= v38) {
          uint64_t v42 = (unint64_t *)v37;
        }
        else {
          uint64_t v42 = (unint64_t *)(v37 + 8);
        }
        if (!v41) {
          int v39 = (__n128 *)v37;
        }
        unint64_t v37 = *v42;
      }

      while (*v42);
      if (v39 == v15 || v38 < (signed __int32)v39[2].n128_u32[0])
      {
LABEL_59:
        char v62 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_1018896A0);
        }
        __int16 v43 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          char v44 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, int *))(*(void *)a1 + 160LL))(v71, a1, a2);
          if (v71[23] >= 0) {
            __int128 v45 = v71;
          }
          else {
            __int128 v45 = *(_BYTE **)v71;
          }
          *(_DWORD *)__int128 buf = 136315650;
          *(void *)char v66 = v44;
          *(_WORD *)&v66[8] = 1024;
          *(_DWORD *)&v66[10] = a5;
          *(_WORD *)&v66[14] = 2080;
          *(void *)&v66[16] = v45;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v71[23] & 0x80000000) != 0) {
            operator delete(*(void **)v71);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_1018896A0);
          }
          int v46 = (void *)(a1 + 8);
          uint64_t v47 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v61 >= 0) {
            __int128 v48 = __p;
          }
          else {
            __int128 v48 = (void **)__p[0];
          }
          *(_DWORD *)int v71 = 136315650;
          *(void *)&v71[4] = v46;
          *(_WORD *)&v71[12] = 1024;
          *(_DWORD *)&_BYTE v71[14] = a5;
          *(_WORD *)&v71[18] = 2080;
          *(void *)&v71[20] = v48;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v47,  2LL,  "%s; client %d has deregistered, not notifying %s",
            v71,
            28,
            v59);
          char v50 = v49;
          if (v61 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData , char, char>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [N otification_T = CLBTLEBeaconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::Not ificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v50);
        }

        goto LABEL_83;
      }

      char v62 = v39;
      if (v33 == v31) {
        goto LABEL_60;
      }
      uint64_t v53 = v39[3].n128_i64[0];
      __int128 v51 = v39 + 3;
      int v52 = (__n128 *)v53;
      if (!v53) {
        goto LABEL_60;
      }
      int v54 = *(_DWORD *)(v33 + 32);
      int v55 = v51;
      do
      {
        int v56 = v52[1].n128_i32[3];
        BOOL v57 = v56 < v54;
        if (v56 >= v54) {
          __int16 v58 = v52;
        }
        else {
          __int16 v58 = (__n128 *)&v52->n128_i8[8];
        }
        if (!v57) {
          int v55 = v52;
        }
        int v52 = (__n128 *)v58->n128_u64[0];
      }

      while (v58->n128_u64[0]);
      sub_100E87D08((_BYTE *)a1, (uint64_t)&v63, (uint64_t)&v62, v30);
    }

void sub_100E8672C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_100E86778(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018896A0);
    }
    id v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136315138;
      unint64_t v37 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_1018896A0);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v32 = 136315138;
      uint64_t v33 = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
        (const char *)&v32);
      uint64_t v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, ch ar, char>::listClients() [Notification_T = CLBTLEBeaconProvider_Type::Notification, NotificationData_T = CLBTLEB eaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_1018896A0);
    }
    __int128 v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v8 = (void *)(a1 + 8);
      uint64_t v9 = *(void *)(a1 + 96);
      *(_DWORD *)__int128 buf = 136315394;
      unint64_t v37 = v8;
      __int16 v38 = 2048;
      v39[0] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_1018896A0);
      }
      __int16 v27 = (void *)(a1 + 8);
      uint64_t v28 = *(void *)(a1 + 96);
      int v32 = 136315394;
      uint64_t v33 = v27;
      __int16 v34 = 2048;
      v35[0] = v28;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
        (const char *)&v32,
        22);
      uint64_t v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, ch ar, char>::listClients() [Notification_T = CLBTLEBeaconProvider_Type::Notification, NotificationData_T = CLBTLEB eaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }

    __int128 v10 = *(void **)(a1 + 80);
    if (v10 != (void *)(a1 + 88))
    {
      int v11 = (void *)(a1 + 8);
      do
      {
        char v12 = (void *)v10[5];
        if (v12 != v10 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_1018896A0);
            }
            id v13 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v14 = (void *)(a1 + 8);
              int v15 = *((_DWORD *)v10 + 8);
              int v16 = *((_DWORD *)v12 + 7);
              *(_DWORD *)__int128 buf = 136315650;
              unint64_t v37 = v14;
              __int16 v38 = 1024;
              LODWORD(v39[0]) = v15;
              WORD2(v39[0]) = 1024;
              *(_DWORD *)((char *)v39 + 6) = v16;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_1018896A0);
              }
              uint64_t v20 = (void *)(a1 + 8);
              int v21 = *((_DWORD *)v10 + 8);
              int v22 = *((_DWORD *)v12 + 7);
              int v32 = 136315650;
              uint64_t v33 = v20;
              __int16 v34 = 1024;
              LODWORD(v35[0]) = v21;
              WORD2(v35[0]) = 1024;
              *(_DWORD *)((char *)v35 + 6) = v22;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                (const char *)&v32,
                24,
                v31);
              BOOL v24 = (uint8_t *)v23;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::Notification Data, char, char>::listClients() [Notification_T = CLBTLEBeaconProvider_Type::Notification, Notification Data_T = CLBTLEBeaconProvider_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
              if (v24 != buf) {
                free(v24);
              }
            }

            int v17 = (void *)v12[1];
            if (v17)
            {
              do
              {
                signed __int32 v18 = v17;
                int v17 = (void *)*v17;
              }

              while (v17);
            }

            else
            {
              do
              {
                signed __int32 v18 = (void *)v12[2];
                BOOL v19 = *v18 == (void)v12;
                char v12 = v18;
              }

              while (!v19);
            }

            char v12 = v18;
          }

          while (v18 != v10 + 6);
        }

        int v25 = (void *)v10[1];
        if (v25)
        {
          do
          {
            unint64_t v26 = v25;
            int v25 = (void *)*v25;
          }

          while (v25);
        }

        else
        {
          do
          {
            unint64_t v26 = (void *)v10[2];
            BOOL v19 = *v26 == (void)v10;
            __int128 v10 = v26;
          }

          while (!v19);
        }

        __int128 v10 = v26;
      }

      while (v26 != (void *)(a1 + 88));
    }
  }

void sub_100E86D20(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_100E86D4C(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_1018896D0;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = [a3 silo];
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 108) = 0;
  return a1;
}

void sub_100E86DCC(_Unwind_Exception *exception_object)
{
}

void sub_100E86DE8(uint64_t a1)
{
}

void sub_100E86DF0(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0LL;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        sub_100E86E60((uint64_t)(v3 + 2));
        operator delete(v3);
        uint64_t v3 = v5;
      }

      while (v5 != a1);
    }
  }

void sub_100E86E60(uint64_t a1)
{
  *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = &off_10182CE18;
  *(void *)a1 = &off_10182CE18;
}

void sub_100E86EB8(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0LL;
    if (v3 != a1)
    {
      do
      {
        uint64_t v5 = (uint64_t *)v3[1];
        sub_100527BBC(v3 + 2);
        operator delete(v3);
        uint64_t v3 = v5;
      }

      while (v5 != a1);
    }
  }

uint64_t sub_100E86F28(uint64_t a1)
{
  *(void *)a1 = off_1018896D0;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

void sub_100E86F9C(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t *sub_100E86FC8(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v6 = (uint64_t *)a1[1];
  if (a2 != a3 && v6 != a1)
  {
    do
    {
      std::string::operator=((std::string *)(v6 + 2), (const std::string *)(v4 + 16));
      *((_DWORD *)v6 + 1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_DWORD *)(v4 + 40);
      std::string::operator=((std::string *)(v6 + 7), (const std::string *)(v4 + 56));
      v6[10] = *(void *)(v4 + 80);
      uint64_t v7 = *(void *)(v4 + 88);
      *((_WORD *)v6 + 48) = *(_WORD *)(v4 + 96);
      v6[11] = v7;
      uint64_t v4 = *(void *)(v4 + 8);
      uint64_t v6 = (uint64_t *)v6[1];
    }

    while (v4 != a3 && v6 != a1);
  }

  if (v6 == a1) {
    return sub_100E87084((uint64_t)a1, a1, v4, a3);
  }
  else {
    return sub_100E87178((uint64_t)a1, v6, a1);
  }
}

uint64_t *sub_100E87084(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a4)
  {
    unint64_t v8 = sub_100E871F4(a1, 0LL, 0LL, (__int128 *)(a3 + 16));
    uint64_t v9 = v8;
    uint64_t v10 = *(void *)(a3 + 8);
    uint64_t v11 = 1LL;
    if (v10 != a4)
    {
      uint64_t v12 = (uint64_t)v8;
      do
      {
        unint64_t v8 = sub_100E871F4(a1, v12, 0LL, (__int128 *)(v10 + 16));
        *(void *)(v12 + 8) = v8;
        ++v11;
        uint64_t v10 = *(void *)(v10 + 8);
        uint64_t v12 = (uint64_t)v8;
      }

      while (v10 != a4);
    }

    uint64_t v13 = *a2;
    *(void *)(v13 + 8) = v9;
    void *v9 = v13;
    *a2 = (uint64_t)v8;
    v8[1] = a2;
    *(void *)(a1 + 16) += v11;
    return v9;
  }

  return a2;
}

void sub_100E87150(void *a1)
{
}

void sub_100E87164(_Unwind_Exception *a1)
{
}

void *sub_100E87178(uint64_t a1, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v6 = *a3;
    uint64_t v7 = *a2;
    *(void *)(v7 + 8) = *(void *)(*a3 + 8LL);
    **(void **)(v6 + 8) = v7;
    do
    {
      unint64_t v8 = (void *)v4[1];
      --*(void *)(a1 + 16);
      sub_100527C2C((uint64_t)(v4 + 2));
      operator delete(v4);
      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return a3;
}

void *sub_100E871F4(int a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  int v7 = a1 + 16;
  unint64_t v8 = operator new(0x68uLL);
  void *v8 = a2;
  v8[1] = a3;
  sub_100E87264(v7, v8 + 2, a4);
  return v8;
}

void sub_100E87250(_Unwind_Exception *a1)
{
}

_BYTE *sub_100E87264(int a1, void *__dst, __int128 *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 v5 = *a3;
    __dst[2] = *((void *)a3 + 2);
    *(_OWORD *)std::string __dst = v5;
  }

  *((_DWORD *)__dst + 6) = *((_DWORD *)a3 + 6);
  __dst[4] = &off_10182CE18;
  BOOL result = __dst + 5;
  if (*((char *)a3 + 63) < 0)
  {
    BOOL result = sub_1010DD48C(result, *((void **)a3 + 5), *((void *)a3 + 6));
  }

  else
  {
    __int128 v7 = *(__int128 *)((char *)a3 + 40);
    __dst[7] = *((void *)a3 + 7);
    *(_OWORD *)BOOL result = v7;
  }

  __dst[8] = *((void *)a3 + 8);
  uint64_t v8 = *((void *)a3 + 9);
  *((_WORD *)__dst + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *((_WORD *)a3 + 40);
  __dst[9] = v8;
  return result;
}

void sub_100E87308(_Unwind_Exception *exception_object)
{
}

void sub_100E87324(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_100E87324(a1, *(void *)a2);
    sub_100E87324(a1, *((void *)a2 + 1));
    *((void *)a2 + 4) = &off_10182CE18;
    if (a2[63] < 0) {
      operator delete(*((void **)a2 + 5));
    }
    operator delete(a2);
  }

uint64_t *sub_100E87384(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = (uint64_t **)sub_100529238((uint64_t)a1, &v9, a2);
  BOOL result = *v6;
  if (!*v6)
  {
    sub_100E87418((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000085FC(a1, v9, v6, v8);
    return v8;
  }

  return result;
}

uint64_t sub_100E87418@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x50uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  uint64_t result = sub_100E87498((uint64_t)v6 + 32, *a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_100E8747C(_Unwind_Exception *a1)
{
  void *v1 = 0LL;
  sub_100E87500(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_100E87498(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &off_10182CE18;
  uint64_t v4 = a1 + 8;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1010DD48C((_BYTE *)v4, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(a2 + 8);
    *(void *)(v4 + 16) = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v4 = v5;
  }

  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(_DWORD *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  return a1;
}

void sub_100E87500(uint64_t a1, char *__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    *((void *)__p + 4) = &off_10182CE18;
    if (__p[63] < 0) {
      operator delete(*((void **)__p + 5));
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t *sub_100E8755C(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = sub_1000087E8(a1, (uint64_t *)a2);
  *(void *)(a2 + 32) = &off_10182CE18;
  operator delete((void *)a2);
  return v3;
}

void *sub_100E875AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int128 v7 = operator new(0x28uLL);
  void *v7 = a2;
  v7[1] = a3;
  sub_100E87608(v7 + 2, a4);
  return v7;
}

void sub_100E875F4(_Unwind_Exception *a1)
{
}

uint64_t *sub_100E87608(uint64_t *a1, uint64_t a2)
{
  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0LL;
  for (uint64_t i = *(void *)(a2 + 8); i != a2; uint64_t i = *(void *)(i + 8))
  {
    __int128 v5 = sub_100E871F4((int)a1, 0LL, 0LL, (__int128 *)(i + 16));
    uint64_t v6 = *a1;
    *__int128 v5 = *a1;
    v5[1] = a1;
    *(void *)(v6 + 8) = v5;
    *a1 = (uint64_t)v5;
    ++a1[2];
  }

  return a1;
}

void sub_100E87684(_Unwind_Exception *a1)
{
}

void *sub_100E87698(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a1 + 16;
  uint64_t v8 = operator new(0x68uLL);
  void *v8 = a2;
  v8[1] = a3;
  sub_100E87708(v7, v8 + 2, a4);
  return v8;
}

void sub_100E876F4(_Unwind_Exception *a1)
{
}

_BYTE *sub_100E87708(uint64_t a1, void *a2, uint64_t a3)
{
  *a2 = &off_10182CE18;
  __int128 v5 = a2 + 1;
  if (*(char *)(a3 + 31) < 0)
  {
    sub_1010DD48C(v5, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }

  else
  {
    __int128 v6 = *(_OWORD *)(a3 + 8);
    a2[3] = *(void *)(a3 + 24);
    *(_OWORD *)__int128 v5 = v6;
  }

  a2[4] = *(void *)(a3 + 32);
  a2[5] = &off_10182CE18;
  uint64_t result = a2 + 6;
  if (*(char *)(a3 + 71) < 0)
  {
    uint64_t result = sub_1010DD48C(result, *(void **)(a3 + 48), *(void *)(a3 + 56));
  }

  else
  {
    __int128 v8 = *(_OWORD *)(a3 + 48);
    a2[8] = *(void *)(a3 + 64);
    *(_OWORD *)uint64_t result = v8;
  }

  a2[9] = *(void *)(a3 + 72);
  a2[10] = *(void *)(a3 + 80);
  return result;
}

void sub_100E877B8(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3 + 16;
  _Unwind_Resume(exception_object);
}

CLCppContainer *sub_100E877DC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x78uLL);
  sub_100E87608((uint64_t *)v2, a1);
  *((void *)v2 + 3) = &off_10182CE18;
  if (*(char *)(a1 + 55) < 0)
  {
    sub_1010DD48C(v2 + 32, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }

  else
  {
    *((_OWORD *)v2 + 2) = *(_OWORD *)(a1 + 32);
    *((void *)v2 + 6) = *(void *)(a1 + 48);
  }

  *((void *)v2 + 7) = *(void *)(a1 + 56);
  *((void *)v2 + 8) = &off_10182CE18;
  uint64_t v3 = v2 + 72;
  if (*(char *)(a1 + 95) < 0)
  {
    sub_1010DD48C(v3, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }

  else
  {
    *(_OWORD *)uint64_t v3 = *(_OWORD *)(a1 + 72);
    *((void *)v2 + 11) = *(void *)(a1 + 88);
  }

  *((_OWORD *)v2 + 6) = *(_OWORD *)(a1 + 96);
  v2[112] = *(_BYTE *)(a1 + 112);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100E88048;
  v5[3] = &unk_10181D3D0;
  v5[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v5,  0LL,  120LL);
}

void sub_100E878F0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 24) = v3 + 16;
  sub_100527BBC((uint64_t *)v1);
  operator delete((void *)v1);
  _Unwind_Resume(a1);
}

void sub_100E87934(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    __int128 v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      uint64_t v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          uint64_t v12 = (uint64_t *)v4;
        }
        else {
          uint64_t v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          uint64_t v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        __int128 v51 = v9;
        id v13 = sub_100E880B4(a3);
        (*(void (**)(void *, int *, id, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        uint64_t v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          int v15 = a1 + 11;
          int v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            BOOL v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                int v22 = (uint64_t *)v17;
              }
              else {
                int v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                BOOL v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              char v50 = v19;
              sub_100E87D08(a1, (uint64_t)&v50, (uint64_t)&v51, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              unint64_t v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  int v32 = (uint64_t *)v27;
                }
                else {
                  int v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  unint64_t v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              __int128 v51 = v29;
              uint64_t v34 = v29[6];
              uint64_t v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                BOOL v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    int v39 = (uint64_t *)v36;
                  }
                  else {
                    int v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    BOOL v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      uint64_t v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      uint64_t v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      uint64_t v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  __int16 v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      uint64_t v14 = v43;
                      __int16 v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      uint64_t v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      BOOL v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              char v50 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_1018896A0);
              }
              BOOL v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                int v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)__int128 buf = 136446466;
                BOOL v57 = v25;
                __int16 v58 = 1026;
                int v59 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_1018896A0);
                }
                __int128 v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v52 = 136446466;
                uint64_t v53 = v45;
                __int16 v54 = 1026;
                int v55 = v46;
                LODWORD(v49) = 18;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                  &v52,
                  v49);
                __int128 v48 = (uint8_t *)v47;
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLBTLEBeaconProvider_Type::Notification, CLBTLEBeaconProvider_Type::NotificationData, char, char>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLBTLEB eaconProvider_Type::Notification, NotificationData_T = CLBTLEBeaconProvider_Type::NotificationData, No tificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
                if (v48 != buf) {
                  free(v48);
                }
              }
            }
          }

          while (v14 != v51 + 6);
        }
      }
    }
  }

_BYTE *sub_100E87D08(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    uint64_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v13) = *(_DWORD *)(*(void *)a3 + 32LL);
    id v9 = sub_100E880B4(a4);
    uint64_t v10 = *(void *)a3 + 80LL;
    BOOL v11 = (uint64_t **)(*(void *)a3 + 40LL);
    uint64_t v14 = (int *)(*(void *)a2 + 32LL);
    uint64_t v12 = sub_1004EF3D4(v11, v14, (uint64_t)&unk_1012CF090, &v14);
    uint64_t result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, id, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v13,  v9,  v10,  v12 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v13);
    }
  }

  return result;
}

void *sub_100E87DE4@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x90uLL);
  uint64_t result = sub_100E87E3C(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100E87E28(_Unwind_Exception *a1)
{
}

void *sub_100E87E3C(void *a1, uint64_t a2)
{
  a1[2] = 0LL;
  *a1 = off_1018897D0;
  a1[1] = 0LL;
  sub_100E87EFC((uint64_t)&v4, (uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_100E87E88(_Unwind_Exception *a1)
{
}

void sub_100E87E9C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1018897D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E87EB0(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1018897D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_100E87ED4(uint64_t a1)
{
}

_BYTE *sub_100E87EFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a2 + 24) = &off_10182CE18;
  if (*(char *)(a3 + 55) < 0)
  {
    sub_1010DD48C((_BYTE *)(a2 + 32), *(void **)(a3 + 32), *(void *)(a3 + 40));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(a3 + 32);
    *(void *)(a2 + 48) = *(void *)(a3 + 48);
    *(_OWORD *)(a2 + 32) = v5;
  }

  *(void *)(a2 + 56) = *(void *)(a3 + 56);
  *(void *)(a2 + 64) = &off_10182CE18;
  uint64_t result = (_BYTE *)(a2 + 72);
  if (*(char *)(a3 + 95) < 0)
  {
    uint64_t result = sub_1010DD48C(result, *(void **)(a3 + 72), *(void *)(a3 + 80));
  }

  else
  {
    __int128 v7 = *(_OWORD *)(a3 + 72);
    *(void *)(a2 + 88) = *(void *)(a3 + 88);
    *(_OWORD *)uint64_t result = v7;
  }

  *(void *)(a2 + 96) = *(void *)(a3 + 96);
  *(void *)(a2 + 104) = *(void *)(a3 + 104);
  *(_BYTE *)(a2 + 112) = *(_BYTE *)(a3 + 112);
  return result;
}

void sub_100E87FC0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 24) = v3 + 16;
  sub_100527BBC((uint64_t *)v1);
  _Unwind_Resume(a1);
}

void sub_100E87FF4(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 64) = &off_10182CE18;
  *(void *)(a2 + 24) = &off_10182CE18;
  sub_100527BBC((uint64_t *)a2);
}

void sub_100E88048(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    *(void *)(v1 + 64) = &off_10182CE18;
    *(void *)(v1 + 24) = &off_10182CE18;
    sub_100527BBC((uint64_t *)v1);
    operator delete((void *)v1);
  }

id sub_100E880B4(void *a1)
{
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0) {
    return sub_100E88100(a1);
  }
  else {
    return 0LL;
  }
}

id sub_100E88100(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101889810);
    }
    uint64_t v3 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x800000010136337ELL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101889810);
    }
    LODWORD(v8) = 134218498;
    HIDWORD(v8) = (_DWORD)v2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  16LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101889810);
    }
    __int128 v6 = (os_log_s *)qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v10 = v2;
      __int16 v11 = 2048;
      uint64_t v12 = 0LL;
      __int16 v13 = 2080;
      unint64_t v14 = 0x800000010136337ELL & 0x7FFFFFFFFFFFFFFFLL;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_FAULT,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }

    if (!sub_1002921D0(115, 0)) {
      return 0LL;
    }
    bzero(buf, 0x65CuLL);
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_101889810);
    }
    LODWORD(v8) = 134218498;
    HIDWORD(v8) = (_DWORD)v2;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934478,  17LL,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has c hanged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  &v8,  32,  v8);
  }

  __int128 v7 = (uint8_t *)v4;
  sub_10029211C( "Generic",  1LL,  0,  0LL,  "const Object_T *safeDecoder(CLCppContainer *, Callback) [Object_T = CLBTLEBeaconProvider_Type::NotificationData, Cal lbacuint64_t k = (lambda at /Library/Caches/com.apple.xbs/Sources/CoreLocation/Shared/Intersilo/CLCppContainer.h:228:46)]",  "%s\n",  v4);
  if (v7 != buf) {
    free(v7);
  }
  return 0LL;
}

void sub_100E884AC(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

CLCppContainer *sub_100E884D8(uint64_t a1)
{
  id v2 = (char *)operator new(0x78uLL);
  sub_100E87608((uint64_t *)v2, a1);
  *((void *)v2 + 3) = &off_10182CE18;
  if (*(char *)(a1 + 55) < 0)
  {
    sub_1010DD48C(v2 + 32, *(void **)(a1 + 32), *(void *)(a1 + 40));
  }

  else
  {
    *((_OWORD *)v2 + 2) = *(_OWORD *)(a1 + 32);
    *((void *)v2 + 6) = *(void *)(a1 + 48);
  }

  *((void *)v2 + 7) = *(void *)(a1 + 56);
  *((void *)v2 + 8) = &off_10182CE18;
  uint64_t v3 = v2 + 72;
  if (*(char *)(a1 + 95) < 0)
  {
    sub_1010DD48C(v3, *(void **)(a1 + 72), *(void *)(a1 + 80));
  }

  else
  {
    *(_OWORD *)uint64_t v3 = *(_OWORD *)(a1 + 72);
    *((void *)v2 + 11) = *(void *)(a1 + 88);
  }

  *((_OWORD *)v2 + 6) = *(_OWORD *)(a1 + 96);
  v2[112] = *(_BYTE *)(a1 + 112);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100E88630;
  v5[3] = &unk_10181D3D0;
  v5[4] = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:",  v2,  v5,  0LL,  120LL);
}

void sub_100E885EC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 24) = v3 + 16;
  sub_100527BBC((uint64_t *)v1);
  operator delete((void *)v1);
  _Unwind_Resume(a1);
}

void sub_100E88630(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    *(void *)(v1 + 64) = &off_10182CE18;
    *(void *)(v1 + 24) = &off_10182CE18;
    sub_100527BBC((uint64_t *)v1);
    operator delete((void *)v1);
  }

void sub_100E8869C()
{
}

uint64_t sub_100E88940(void *a1, __int128 *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 8 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_10046E554(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  uint64_t v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) + ((v7 & 0x3F) << 6));
  __int128 v9 = *a2;
  __int128 v10 = a2[1];
  __int128 v11 = a2[3];
  v8[2] = a2[2];
  v8[3] = v11;
  _OWORD *v8 = v9;
  v8[1] = v10;
  uint64_t v12 = a1[4];
  uint64_t v13 = a1[5] + 1LL;
  a1[5] = v13;
  unint64_t v14 = v12 + v13;
  uint64_t v15 = a1[1];
  int v16 = (void *)(v15 + 8 * (v14 >> 6));
  uint64_t v17 = *v16 + ((v14 & 0x3F) << 6);
  if (a1[2] == v15) {
    uint64_t v17 = 0LL;
  }
  if (v17 == *v16) {
    uint64_t v17 = *(v16 - 1) + 4096LL;
  }
  return v17 - 64;
}

void sub_100E88F20(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

uint64_t sub_100E88F4C@<X0>(void *a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  return sub_10046A230(a3, a1);
}

uint64_t sub_100E88F78@<X0>(int64x2_t *a1@<X0>, unsigned __int8 *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a1[5].i64[1])
  {
    sub_100E89010(a1, a2, a3);
  }

  else
  {
    unint64_t v6 = a1[2].i64[1] + a1[2].i64[0] - 1;
    else {
      sub_100412F18(a1, (__int128 *)a2);
    }
  }

  return sub_10046A230(a4, a1);
}

void sub_100E89010(int64x2_t *a1, unsigned __int8 *a2, int a3)
{
  unint64_t v6 = a1[2].u64[0];
  uint64_t v7 = a1->i64[1];
  uint64_t v8 = a1[1].i64[0];
  __int128 v9 = (void *)(v7 + 8 * (v6 / 0x11));
  if (v8 == v7)
  {
    unint64_t v10 = 0LL;
  }

  else
  {
    unint64_t v10 = *(void *)(v7 + 8 * (v6 / 0x11)) + 232 * (v6 % 0x11);
    unint64_t v11 = *(void *)(v7 + 8 * ((a1[2].i64[1] + v6) / 0x11)) + 232 * ((a1[2].i64[1] + v6) % 0x11);
    if (v10 != v11)
    {
      while (1)
      {
        __int128 v12 = *(_OWORD *)v10;
        __int128 v13 = *(_OWORD *)(v10 + 32);
        __int128 v102 = *(_OWORD *)(v10 + 16);
        __int128 v103 = v13;
        *(_OWORD *)__int128 buf = v12;
        __int128 v14 = *(_OWORD *)(v10 + 48);
        __int128 v15 = *(_OWORD *)(v10 + 64);
        __int128 v16 = *(_OWORD *)(v10 + 96);
        __int128 v106 = *(_OWORD *)(v10 + 80);
        __int128 v107 = v16;
        __int128 v104 = v14;
        __int128 v105 = v15;
        __int128 v17 = *(_OWORD *)(v10 + 112);
        __int128 v18 = *(_OWORD *)(v10 + 128);
        __int128 v19 = *(_OWORD *)(v10 + 160);
        __int128 v110 = *(_OWORD *)(v10 + 144);
        __int128 v111 = v19;
        __int128 v108 = v17;
        __int128 v109 = v18;
        __int128 v20 = *(_OWORD *)(v10 + 176);
        __int128 v21 = *(_OWORD *)(v10 + 192);
        __int128 v22 = *(_OWORD *)(v10 + 208);
        uint64_t v115 = *(void *)(v10 + 224);
        __int128 v113 = v21;
        __int128 v114 = v22;
        __int128 v112 = v20;
        v10 += 232LL;
        if (v10 - *v9 == 3944)
        {
          unint64_t v23 = v9[1];
          ++v9;
          unint64_t v10 = v23;
        }

        if (v10 == v11)
        {
          unint64_t v10 = v11;
          break;
        }
      }

      uint64_t v7 = a1->i64[1];
      uint64_t v8 = a1[1].i64[0];
    }
  }

  if (v8 == v7)
  {
    unint64_t v25 = 0LL;
  }

  else
  {
    unint64_t v24 = a1[2].i64[1] + a1[2].i64[0];
    unint64_t v25 = *(void *)(v7 + 8 * (v24 / 0x11)) + 232 * (v24 % 0x11);
  }

  if (v10 == v25)
  {
    unint64_t v32 = a1[5].u64[0];
    uint64_t v33 = a1[3].i64[1];
    uint64_t v34 = a1[4].i64[0];
    BOOL v35 = (void *)(v33 + 8 * (v32 / 0x11));
    if (v34 == v33)
    {
      unint64_t v37 = 0LL;
      uint64_t v36 = &a1[5].i64[1];
    }

    else
    {
      uint64_t v36 = &a1[5].i64[1];
      unint64_t v37 = *(void *)(v33 + 8 * (v32 / 0x11)) + 232 * (v32 % 0x11);
      unint64_t v38 = *(void *)(v33 + 8 * ((a1[5].i64[1] + v32) / 0x11)) + 232 * ((a1[5].i64[1] + v32) % 0x11);
      if (v37 != v38)
      {
        while (1)
        {
          __int128 v39 = *(_OWORD *)v37;
          __int128 v40 = *(_OWORD *)(v37 + 32);
          __int128 v102 = *(_OWORD *)(v37 + 16);
          __int128 v103 = v40;
          *(_OWORD *)__int128 buf = v39;
          __int128 v41 = *(_OWORD *)(v37 + 48);
          __int128 v42 = *(_OWORD *)(v37 + 64);
          __int128 v43 = *(_OWORD *)(v37 + 96);
          __int128 v106 = *(_OWORD *)(v37 + 80);
          __int128 v107 = v43;
          __int128 v104 = v41;
          __int128 v105 = v42;
          __int128 v44 = *(_OWORD *)(v37 + 112);
          __int128 v45 = *(_OWORD *)(v37 + 128);
          __int128 v46 = *(_OWORD *)(v37 + 160);
          __int128 v110 = *(_OWORD *)(v37 + 144);
          __int128 v111 = v46;
          __int128 v108 = v44;
          __int128 v109 = v45;
          __int128 v47 = *(_OWORD *)(v37 + 176);
          __int128 v48 = *(_OWORD *)(v37 + 192);
          __int128 v49 = *(_OWORD *)(v37 + 208);
          uint64_t v115 = *(void *)(v37 + 224);
          __int128 v113 = v48;
          __int128 v114 = v49;
          __int128 v112 = v47;
          v37 += 232LL;
          if (v37 - *v35 == 3944)
          {
            unint64_t v50 = v35[1];
            ++v35;
            unint64_t v37 = v50;
          }

          if (v37 == v38)
          {
            unint64_t v37 = v38;
            break;
          }
        }

        uint64_t v33 = a1[3].i64[1];
        uint64_t v34 = a1[4].i64[0];
      }
    }

    if (v34 == v33)
    {
      unint64_t v57 = 0LL;
    }

    else
    {
      unint64_t v56 = a1[5].i64[1] + a1[5].i64[0];
      unint64_t v57 = *(void *)(v33 + 8 * (v56 / 0x11)) + 232 * (v56 % 0x11);
    }

    if (v37 == v57)
    {
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101889850);
      }
      uint64_t v64 = (os_log_s *)qword_101934688;
      if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v64,  OS_LOG_TYPE_DEFAULT,  "CLWorkoutSeriesBuilder, client confirmed segment not in current overview or candidates list, deleting all cand idates and appending confirmed segment",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934680 != -1) {
          dispatch_once(&qword_101934680, &stru_101889850);
        }
        v100[0] = 0;
        unsigned int v99 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "CLWorkoutSeriesBuilder, client confirmed segment not in current overview or candidates list, del eting all candidates and appending confirmed segment",  v100,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutSeriesBuilder::addCandidatesToConfirmedOverview(const CLMotionStateMediator_Type::WorkoutEvent &, BOOL)",  "%s\n",  v99);
      }

      sub_100412F18((int64x2_t *)a1[3].i64, (__int128 *)a2);
      if (a3)
      {
        unint64_t v65 = a1[5].i64[1] + a1[5].i64[0] - 1;
        uint64_t v66 = *(void *)(a1[3].i64[1] + 8 * (v65 / 0x11));
        unint64_t v67 = v65 % 0x11;
        unint64_t v68 = a1[2].i64[1] + a1[2].i64[0] - 1;
        *(void *)(*(void *)(a1->i64[1] + 8 * (v68 / 0x11)) + 232 * (v68 % 0x11) + 8) = *(void *)(v66 + 232 * v67);
      }

      else
      {
        unint64_t v89 = a1[2].i64[1] + a1[2].i64[0] - 1;
        uint64_t v90 = *(void *)(*(void *)(a1->i64[1] + 8 * (v89 / 0x11)) + 232 * (v89 % 0x11) + 8);
        unint64_t v91 = a1[5].i64[1] + a1[5].i64[0] - 1;
        uint64_t v66 = *(void *)(a1[3].i64[1] + 8 * (v91 / 0x11));
        unint64_t v67 = v91 % 0x11;
        *(void *)(v66 + 232 * v67) = v90;
      }

      sub_100412F18(a1, (__int128 *)(v66 + 232 * v67));
    }

    else
    {
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101889850);
      }
      __int16 v58 = (os_log_s *)qword_101934688;
      if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "CLWorkoutSeriesBuilder, client confirmed segment in candidates list, removing candidates after confirmed segment",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934680 != -1) {
          dispatch_once(&qword_101934680, &stru_101889850);
        }
        v100[0] = 0;
        uint64_t v98 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "CLWorkoutSeriesBuilder, client confirmed segment in candidates list, removing candidates after c onfirmed segment",  v100,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutSeriesBuilder::addCandidatesToConfirmedOverview(const CLMotionStateMediator_Type::WorkoutEvent &, BOOL)",  "%s\n",  v98);
      }

      uint64_t v59 = v37 - *v35;
      uint64_t v60 = 0x34F72C234F72C235LL * (v59 >> 3);
      if (v59 < -231)
      {
        unint64_t v69 = 15 - v60;
        char v62 = (char *)&v35[-(v69 / 0x11)];
        uint64_t v63 = (char *)(*(void *)v62 + 232 * (17 * (v69 / 0x11) - v69) + 3712);
      }

      else
      {
        unint64_t v61 = v60 + 1;
        char v62 = (char *)&v35[v61 / 0x11];
        uint64_t v63 = (char *)(*(void *)v62 + 232 * (v61 % 0x11));
      }

      unint64_t v70 = a1[5].i64[0] + a1[5].i64[1];
      uint64_t v71 = a1[3].i64[1];
      __int16 v72 = (char *)(v71 + 8 * (v70 / 0x11));
      if (a1[4].i64[0] == v71) {
        double v73 = 0LL;
      }
      else {
        double v73 = (char *)(*(void *)v72 + 232 * (v70 % 0x11));
      }
      sub_100412FFC((int64x2_t *)a1[3].i64, v62, v63, v72, v73);
      uint64_t v75 = a1[2].i64[0];
      uint64_t v74 = a1[2].i64[1];
      uint64_t v76 = a1->i64[1];
      if (a3)
      {
        uint64_t v77 = *(void *)a2;
        *(void *)(*(void *)(v76 + 8 * ((v74 + v75 - 1) / 0x11uLL)) + 232 * ((v74 + v75 - 1) % 0x11uLL) + 8) = *(void *)a2;
        unint64_t v78 = a1[5].i64[1] + a1[5].i64[0] - 1;
        *(void *)(*(void *)(a1[3].i64[1] + 8 * (v78 / 0x11)) + 232 * (v78 % 0x11)) = v77;
      }

      unint64_t v79 = v75 + v74;
      int v80 = (char *)(v76 + 8 * (v79 / 0x11));
      if (a1[1].i64[0] == v76) {
        uint64_t v81 = 0LL;
      }
      else {
        uint64_t v81 = *(void *)v80 + 232 * (v79 % 0x11);
      }
      unint64_t v82 = a1[5].u64[0];
      uint64_t v83 = a1[3].i64[1];
      if (a1[4].i64[0] == v83)
      {
        __int16 v84 = 0LL;
        uint64_t v87 = 0LL;
        __int16 v86 = (char *)(v83 + 8 * ((*v36 + v82) / 0x11));
      }

      else
      {
        __int16 v84 = (char *)(*(void *)(v83 + 8 * (v82 / 0x11)) + 232 * (v82 % 0x11));
        unint64_t v85 = *v36 + v82;
        __int16 v86 = (char *)(v83 + 8 * (v85 / 0x11));
        uint64_t v87 = (char *)(*(void *)v86 + 232 * (v85 % 0x11));
      }

      sub_100E8A294(a1, v80, v81, (char *)(v83 + 8 * (v82 / 0x11)), v84, v86, v87);
      unint64_t v88 = a1[2].i64[1] + a1[2].i64[0] - 1;
      *(void *)(*(void *)(a1->i64[1] + 8 * (v88 / 0x11)) + 232 * (v88 % 0x11) + 8) = 0xBFF0000000000000LL;
    }
  }

  else
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101889850);
    }
    int v26 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "CLWorkoutSeriesBuilder, client confirmed segment in the current overview, deleting all candidates and removing s egments after confirmed segment",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101889850);
      }
      v100[0] = 0;
      std::stringbuf::string_type v97 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "CLWorkoutSeriesBuilder, client confirmed segment in the current overview, deleting all candidates and removing segments after confirmed segment",  v100,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLWorkoutSeriesBuilder::addCandidatesToConfirmedOverview(const CLMotionStateMediator_Type::WorkoutEvent &, BOOL)",  "%s\n",  v97);
    }

    uint64_t v27 = v10 - *v9;
    uint64_t v28 = 0x34F72C234F72C235LL * (v27 >> 3);
    if (v27 < -231)
    {
      unint64_t v51 = 15 - v28;
      int v30 = (char *)&v9[-(v51 / 0x11)];
      BOOL v31 = (char *)(*(void *)v30 + 232 * (17 * (v51 / 0x11) - v51) + 3712);
    }

    else
    {
      unint64_t v29 = v28 + 1;
      int v30 = (char *)&v9[v29 / 0x11];
      BOOL v31 = (char *)(*(void *)v30 + 232 * (v29 % 0x11));
    }

    unint64_t v52 = a1[2].i64[0] + a1[2].i64[1];
    uint64_t v53 = a1->i64[1];
    __int16 v54 = (char *)(v53 + 8 * (v52 / 0x11));
    if (a1[1].i64[0] == v53) {
      int v55 = 0LL;
    }
    else {
      int v55 = (char *)(*(void *)v54 + 232 * (v52 % 0x11));
    }
    sub_100412FFC(a1, v30, v31, v54, v55);
    *(void *)(v10 + 8) = 0xBFF0000000000000LL;
  }

  uint64_t v92 = (void **)a1[3].i64[1];
  uint64_t v93 = a1[4].i64[0];
  a1[5].i64[1] = 0LL;
  unint64_t v94 = v93 - (void)v92;
  if (v94 >= 0x11)
  {
    do
    {
      operator delete(*v92);
      uint64_t v95 = a1[4].i64[0];
      uint64_t v92 = (void **)(a1[3].i64[1] + 8);
      a1[3].i64[1] = (uint64_t)v92;
      unint64_t v94 = v95 - (void)v92;
    }

    while (v94 > 0x10);
  }

  if (v94 >> 3 == 1)
  {
    uint64_t v96 = 8LL;
  }

  else
  {
    if (v94 >> 3 != 2) {
      return;
    }
    uint64_t v96 = 17LL;
  }

  a1[5].i64[0] = v96;
}

double sub_100E89B48(uint64_t a1, __int128 *a2, void *a3)
{
  uint64_t v3 = a3[5];
  if (v3) {
    *(void *)(*(void *)(a3[1] + 8 * ((v3 + a3[4] - 1) / 0x11uLL)) + 232 * ((v3 + a3[4] - 1) % 0x11uLL) + 8) = *(void *)a2;
  }
  *(void *)&double result = sub_100412F18(a3, a2).n128_u64[0];
  return result;
}

uint64_t sub_100E89B98@<X0>(void *a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5 = a1[5] + a1[4] - 1LL;
  unint64_t v6 = *(void *)(a1[1] + 8 * (v5 / 0x11)) + 232 * (v5 % 0x11);
  double v8 = *(double *)(v6 + 8);
  uint64_t v7 = (void *)(v6 + 8);
  if (v8 == -1.0) {
    void *v7 = *(void *)a2;
  }
  sub_100E89B48((uint64_t)a1, a2, a1 + 6);
  return sub_10046A230(a3, a1);
}

uint64_t sub_100E89C18@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6 = (void **)a1[7];
  uint64_t v7 = a1[8];
  a1[11] = 0LL;
  unint64_t v8 = v7 - (void)v6;
  if (v8 >= 0x11)
  {
    do
    {
      operator delete(*v6);
      uint64_t v9 = a1[8];
      unint64_t v6 = (void **)(a1[7] + 8LL);
      a1[7] = v6;
      unint64_t v8 = v9 - (void)v6;
    }

    while (v8 > 0x10);
  }

  if (v8 >> 3 == 1)
  {
    uint64_t v10 = 8LL;
  }

  else
  {
    if (v8 >> 3 != 2) {
      goto LABEL_8;
    }
    uint64_t v10 = 17LL;
  }

  a1[10] = v10;
LABEL_8:
  unint64_t v11 = a1[4];
  uint64_t v12 = a1[1];
  uint64_t v13 = a1[2];
  __int128 v14 = (void *)(v12 + 8 * (v11 / 0x11));
  if (v13 == v12)
  {
    unint64_t v15 = 0LL;
  }

  else
  {
    unint64_t v15 = *(void *)(v12 + 8 * (v11 / 0x11)) + 232 * (v11 % 0x11);
    unint64_t v16 = *(void *)(v12 + 8 * ((a1[5] + v11) / 0x11)) + 232 * ((a1[5] + v11) % 0x11);
    if (v15 != v16)
    {
      __int128 v17 = (const unsigned __int8 *)(a2 + 64);
      while (1)
      {
        __int128 v18 = *(_OWORD *)v15;
        __int128 v19 = *(_OWORD *)(v15 + 32);
        __int128 v53 = *(_OWORD *)(v15 + 16);
        __int128 v54 = v19;
        *(_OWORD *)__int128 buf = v18;
        __int128 v20 = *(_OWORD *)(v15 + 48);
        __int128 v21 = *(_OWORD *)(v15 + 64);
        __int128 v22 = *(_OWORD *)(v15 + 96);
        v56[1] = *(_OWORD *)(v15 + 80);
        _OWORD v56[2] = v22;
        __int128 v55 = v20;
        v56[0] = v21;
        __int128 v23 = *(_OWORD *)(v15 + 112);
        __int128 v24 = *(_OWORD *)(v15 + 128);
        __int128 v25 = *(_OWORD *)(v15 + 160);
        v56[5] = *(_OWORD *)(v15 + 144);
        _BYTE v56[6] = v25;
        _DWORD v56[3] = v23;
        v56[4] = v24;
        __int128 v26 = *(_OWORD *)(v15 + 176);
        __int128 v27 = *(_OWORD *)(v15 + 192);
        __int128 v28 = *(_OWORD *)(v15 + 208);
        uint64_t v57 = *(void *)(v15 + 224);
        v56[8] = v27;
        v56[9] = v28;
        v56[7] = v26;
        v15 += 232LL;
        if (v15 - *v14 == 3944)
        {
          unint64_t v29 = v14[1];
          ++v14;
          unint64_t v15 = v29;
        }

        if (v15 == v16)
        {
          unint64_t v15 = v16;
          break;
        }
      }

      uint64_t v12 = a1[1];
      uint64_t v13 = a1[2];
    }
  }

  if (v13 == v12)
  {
    unint64_t v31 = 0LL;
  }

  else
  {
    unint64_t v30 = a1[5] + a1[4];
    unint64_t v31 = *(void *)(v12 + 8 * (v30 / 0x11)) + 232 * (v30 % 0x11);
  }

  if (v15 == v31)
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101889850);
    }
    __int128 v39 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "CLWorkoutSeriesBuilder, cannot reset workout to confirmed workout, candidate not in list",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101889850);
      }
      LOWORD(v5sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
      __int128 v40 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  16LL,  "CLWorkoutSeriesBuilder, cannot reset workout to confirmed workout, candidate not in list",  &v50,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLWorkoutSeriesPredictor_Type::WorkoutList CLWorkoutSeriesBuilder::resetToConfirmedWorkout(const CLMotionStateMe diator_Type::WorkoutEvent &)",  "%s\n",  v40);
    }
  }

  else
  {
    if (qword_101934680 != -1) {
      dispatch_once(&qword_101934680, &stru_101889850);
    }
    unint64_t v32 = (os_log_s *)qword_101934688;
    if (os_log_type_enabled((os_log_t)qword_101934688, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v33 = *(void *)(v15 + 112);
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = v33;
      _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "CLWorkoutSeriesBuilder, reset back to confirmed workout, currentSegment,%ld",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934680 != -1) {
        dispatch_once(&qword_101934680, &stru_101889850);
      }
      uint64_t v48 = *(void *)(v15 + 112);
      int v50 = 134217984;
      uint64_t v51 = v48;
      __int128 v49 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934688,  0LL,  "CLWorkoutSeriesBuilder, reset back to confirmed workout, currentSegment,%ld",  &v50);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLWorkoutSeriesPredictor_Type::WorkoutList CLWorkoutSeriesBuilder::resetToConfirmedWorkout(const CLMotionStateMe diator_Type::WorkoutEvent &)",  "%s\n",  v49);
    }

    uint64_t v34 = v15 - *v14;
    uint64_t v35 = 0x34F72C234F72C235LL * (v34 >> 3);
    if (v34 < -231)
    {
      unint64_t v41 = 15 - v35;
      unint64_t v37 = (char *)&v14[-(v41 / 0x11)];
      unint64_t v38 = (char *)(*(void *)v37 + 232 * (17 * (v41 / 0x11) - v41) + 3712);
    }

    else
    {
      unint64_t v36 = v35 + 1;
      unint64_t v37 = (char *)&v14[v36 / 0x11];
      unint64_t v38 = (char *)(*(void *)v37 + 232 * (v36 % 0x11));
    }

    unint64_t v42 = a1[4] + a1[5];
    uint64_t v43 = a1[1];
    __int128 v44 = (char *)(v43 + 8 * (v42 / 0x11));
    if (a1[2] == v43) {
      __int128 v45 = 0LL;
    }
    else {
      __int128 v45 = (char *)(*(void *)v44 + 232 * (v42 % 0x11));
    }
    sub_100412FFC(a1, v37, v38, v44, v45);
    unint64_t v46 = a1[5] + a1[4] - 1LL;
    *(void *)(*(void *)(a1[1] + 8 * (v46 / 0x11)) + 232 * (v46 % 0x11) + 8) = 0xBFF0000000000000LL;
  }

  return sub_10046A230(a3, a1);
}

uint64_t sub_100E8A1C8@<X0>(void *a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  unint64_t v5 = a1[5] + a1[4] - 1LL;
  unint64_t v6 = *(void *)(a1[1] + 8 * (v5 / 0x11)) + 232 * (v5 % 0x11);
  double v8 = *(double *)(v6 + 8);
  uint64_t v7 = (double *)(v6 + 8);
  if (v8 == -1.0) {
    double *v7 = a3;
  }
  uint64_t v9 = (void **)a1[7];
  uint64_t v10 = a1[8];
  a1[11] = 0LL;
  unint64_t v11 = v10 - (void)v9;
  if (v11 >= 0x11)
  {
    do
    {
      operator delete(*v9);
      uint64_t v12 = a1[8];
      uint64_t v9 = (void **)(a1[7] + 8LL);
      a1[7] = v9;
      unint64_t v11 = v12 - (void)v9;
    }

    while (v11 > 0x10);
  }

  if (v11 >> 3 == 1)
  {
    uint64_t v13 = 8LL;
    goto LABEL_9;
  }

  if (v11 >> 3 == 2)
  {
    uint64_t v13 = 17LL;
LABEL_9:
    a1[10] = v13;
  }

  return sub_10046A230(a2, a1);
}

unint64_t sub_100E8A294(int64x2_t *a1, char *a2, uint64_t a3, char *a4, char *a5, char *a6, char *a7)
{
  if (a7 == a5) {
    unint64_t v7 = 0LL;
  }
  else {
    unint64_t v7 = 2 * (a6 - a4)
  }
       + ((a6 - a4) >> 3)
  return sub_100E8A320(a1, a2, a3, (unint64_t)a4, a5, (unint64_t)a6, a7, v7);
}

void sub_100E8A2F4(id a1)
{
  qword_101934688 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Workout");
}

unint64_t sub_100E8A320( int64x2_t *a1, char *a2, uint64_t a3, unint64_t a4, char *a5, unint64_t a6, _BYTE *a7, unint64_t a8)
{
  unint64_t v8 = a8;
  unint64_t v14 = a1[2].u64[0];
  unint64_t v15 = v14 / 0x11;
  uint64_t v16 = a1->i64[1];
  uint64_t v17 = a1[1].i64[0];
  __int128 v18 = (char *)(v16 + 8 * (v14 / 0x11));
  if (v17 == v16) {
    unint64_t v19 = 0LL;
  }
  else {
    unint64_t v19 = *(void *)v18 + 232 * (v14 % 0x11);
  }
  if (a3 == v19) {
    unint64_t v20 = 0LL;
  }
  else {
    unint64_t v20 = 2 * (a2 - v18)
  }
        + ((a2 - v18) >> 3)
        + 0x34F72C234F72C235LL * ((a3 - *(void *)a2) >> 3)
        - 0x34F72C234F72C235LL * ((uint64_t)(v19 - *(void *)v18) >> 3);
  uint64_t v21 = a1[2].i64[1];
  if (v20 >= v21 - v20)
  {
    uint64_t v24 = 2 * (v17 - v16) + ((v17 - v16) >> 3) - 1;
    if (v17 == v16) {
      uint64_t v24 = 0LL;
    }
    unint64_t v25 = v14 + v21;
    unint64_t v26 = v24 - v25;
    if (a8 > v26)
    {
      sub_10046A508(a1, a8 - v26);
      uint64_t v21 = a1[2].i64[1];
      uint64_t v16 = a1->i64[1];
      uint64_t v17 = a1[1].i64[0];
      unint64_t v25 = a1[2].i64[0] + v21;
    }

    __int128 v27 = (void *)(v16 + 8 * (v25 / 0x11));
    __int128 v110 = (char **)a4;
    if (v17 == v16) {
      __int128 v28 = 0LL;
    }
    else {
      __int128 v28 = (char *)(*v27 + 232 * (v25 % 0x11));
    }
    unint64_t v33 = v21 - v20;
    uint64_t v34 = v21 - v20 - v8;
    if (v21 - v20 >= v8)
    {
      __int128 v109 = (char **)a6;
      uint64_t v35 = v28;
      unint64_t v36 = (void *)(v16 + 8 * (v25 / 0x11));
      unint64_t v37 = (unint64_t)a7;
      if (!v8) {
        goto LABEL_72;
      }
    }

    else
    {
      if (v33 >= v8 >> 1)
      {
        v112.n128_u64[0] = a6;
        v112.n128_u64[1] = (unint64_t)a7;
      }

      else
      {
        v112.n128_u64[0] = (unint64_t)v110;
        v112.n128_u64[1] = (unint64_t)a5;
        uint64_t v34 = v21 - v20;
      }

      sub_100414E10(&v112, v34);
      unint64_t v37 = v112.n128_u64[1];
      __int128 v53 = (void *)v112.n128_u64[0];
      __int128 v109 = (char **)v112.n128_u64[0];
      if ((_BYTE *)v112.n128_u64[1] == a7)
      {
        uint64_t v35 = v28;
        unint64_t v36 = v27;
      }

      else
      {
        unint64_t v54 = v112.n128_u64[1];
        unint64_t v36 = v27;
        uint64_t v35 = v28;
        do
        {
          __int128 v55 = *(_OWORD *)v54;
          __int128 v56 = *(_OWORD *)(v54 + 32);
          *((_OWORD *)v35 + 1) = *(_OWORD *)(v54 + 16);
          *((_OWORD *)v35 + 2) = v56;
          *(_OWORD *)uint64_t v35 = v55;
          __int128 v57 = *(_OWORD *)(v54 + 48);
          __int128 v58 = *(_OWORD *)(v54 + 64);
          __int128 v59 = *(_OWORD *)(v54 + 96);
          *((_OWORD *)v35 + 5) = *(_OWORD *)(v54 + 80);
          *((_OWORD *)v35 + 6) = v59;
          *((_OWORD *)v35 + 3) = v57;
          *((_OWORD *)v35 + 4) = v58;
          __int128 v60 = *(_OWORD *)(v54 + 112);
          __int128 v61 = *(_OWORD *)(v54 + 128);
          __int128 v62 = *(_OWORD *)(v54 + 160);
          *((_OWORD *)v35 + 9) = *(_OWORD *)(v54 + 144);
          *((_OWORD *)v35 + 1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v62;
          *((_OWORD *)v35 + 7) = v60;
          *((_OWORD *)v35 + 8) = v61;
          __int128 v63 = *(_OWORD *)(v54 + 176);
          __int128 v64 = *(_OWORD *)(v54 + 192);
          __int128 v65 = *(_OWORD *)(v54 + 208);
          *((void *)v35 + 28) = *(void *)(v54 + 224);
          *((_OWORD *)v35 + 12) = v64;
          *((_OWORD *)v35 + 13) = v65;
          *((_OWORD *)v35 + 11) = v63;
          v35 += 232;
          if (&v35[-*v36] == (char *)3944)
          {
            uint64_t v66 = (char *)v36[1];
            ++v36;
            uint64_t v35 = v66;
          }

          v54 += 232LL;
          if (v54 - *v53 == 3944)
          {
            unint64_t v67 = v53[1];
            ++v53;
            unint64_t v54 = v67;
          }

          ++a1[2].i64[1];
        }

        while ((_BYTE *)v54 != a7);
      }

      unint64_t v8 = v33;
      if (!v33) {
        goto LABEL_72;
      }
    }

    __int128 v107 = (char *)v37;
    v112.n128_u64[0] = (unint64_t)v27;
    v112.n128_u64[1] = (unint64_t)v28;
    sub_100414E10(&v112, -(uint64_t)v8);
    __n128 v85 = v112;
    if ((char *)v112.n128_u64[1] != v28)
    {
      unint64_t v87 = v112.n128_u64[1];
      __int16 v86 = (void *)v112.n128_u64[0];
      do
      {
        __int128 v88 = *(_OWORD *)v87;
        __int128 v89 = *(_OWORD *)(v87 + 32);
        *((_OWORD *)v35 + 1) = *(_OWORD *)(v87 + 16);
        *((_OWORD *)v35 + 2) = v89;
        *(_OWORD *)uint64_t v35 = v88;
        __int128 v90 = *(_OWORD *)(v87 + 48);
        __int128 v91 = *(_OWORD *)(v87 + 64);
        __int128 v92 = *(_OWORD *)(v87 + 96);
        *((_OWORD *)v35 + 5) = *(_OWORD *)(v87 + 80);
        *((_OWORD *)v35 + 6) = v92;
        *((_OWORD *)v35 + 3) = v90;
        *((_OWORD *)v35 + 4) = v91;
        __int128 v93 = *(_OWORD *)(v87 + 112);
        __int128 v94 = *(_OWORD *)(v87 + 128);
        __int128 v95 = *(_OWORD *)(v87 + 160);
        *((_OWORD *)v35 + 9) = *(_OWORD *)(v87 + 144);
        *((_OWORD *)v35 + 1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v95;
        *((_OWORD *)v35 + 7) = v93;
        *((_OWORD *)v35 + 8) = v94;
        __int128 v96 = *(_OWORD *)(v87 + 176);
        __int128 v97 = *(_OWORD *)(v87 + 192);
        __int128 v98 = *(_OWORD *)(v87 + 208);
        *((void *)v35 + 28) = *(void *)(v87 + 224);
        *((_OWORD *)v35 + 12) = v97;
        *((_OWORD *)v35 + 13) = v98;
        *((_OWORD *)v35 + 11) = v96;
        v35 += 232;
        if (&v35[-*v36] == (char *)3944)
        {
          unsigned int v99 = (char *)v36[1];
          ++v36;
          uint64_t v35 = v99;
        }

        v87 += 232LL;
        if (v87 - *v86 == 3944)
        {
          unint64_t v100 = v86[1];
          ++v86;
          unint64_t v87 = v100;
        }

        ++a1[2].i64[1];
      }

      while ((char *)v87 != v28);
    }

    if (v8 < v33)
    {
      v112.n128_u64[0] = (unint64_t)v27;
      v112.n128_u64[1] = (unint64_t)v28;
      sub_100414E10(&v112, -(uint64_t)v33);
      sub_100414EB8( (char **)v112.n128_u64[0],  (char *)v112.n128_u64[1],  (char **)v85.n128_u64[0],  (char *)v85.n128_u64[1],  v27,  v28,  &v112);
      __int128 v27 = v113;
      __int128 v28 = v114;
    }

    sub_100414EB8(v110, a5, v109, v107, v27, v28, &v112);
    goto LABEL_72;
  }

  if (a8 > v14)
  {
    sub_100E8A9BC((void **)a1, a8 - v14);
    unint64_t v14 = a1[2].u64[0];
    uint64_t v16 = a1->i64[1];
    uint64_t v17 = a1[1].i64[0];
    unint64_t v15 = v14 / 0x11;
  }

  __int128 v22 = (void *)(v16 + 8 * v15);
  if (v17 == v16) {
    unint64_t v23 = 0LL;
  }
  else {
    unint64_t v23 = *v22 + 232 * (v14 % 0x11);
  }
  uint64_t v29 = v8 - v20;
  __int128 v108 = (_BYTE **)a6;
  if (v8 <= v20)
  {
    __int128 v111 = (void *)a4;
    unint64_t v30 = v23;
    unint64_t v31 = (void *)(v16 + 8 * v15);
    unint64_t v32 = (unint64_t)a5;
    if (!v8) {
      goto LABEL_72;
    }
    goto LABEL_50;
  }

  if (v20 >= v8 >> 1)
  {
    v112.n128_u64[0] = a4;
    v112.n128_u64[1] = (unint64_t)a5;
  }

  else
  {
    v112.n128_u64[0] = a6;
    v112.n128_u64[1] = (unint64_t)a7;
    uint64_t v29 = -(uint64_t)v20;
  }

  sub_100414E10(&v112, v29);
  unint64_t v32 = v112.n128_u64[1];
  __int128 v111 = (void *)v112.n128_u64[0];
  if ((char *)v112.n128_u64[1] == a5)
  {
    unint64_t v30 = v23;
    unint64_t v31 = v22;
  }

  else
  {
    unint64_t v39 = v112.n128_u64[1];
    unint64_t v38 = (void *)v112.n128_u64[0];
    unint64_t v31 = v22;
    unint64_t v30 = v23;
    do
    {
      if (v30 == *v31)
      {
        uint64_t v40 = *--v31;
        unint64_t v30 = v40 + 3944;
      }

      if (v39 == *v38)
      {
        uint64_t v41 = *--v38;
        unint64_t v39 = v41 + 3944;
      }

      v30 -= 232LL;
      __int128 v42 = *(_OWORD *)(v39 - 232);
      __int128 v43 = *(_OWORD *)(v39 - 200);
      *(_OWORD *)(v30 + 16) = *(_OWORD *)(v39 - 216);
      *(_OWORD *)(v30 + 32) = v43;
      *(_OWORD *)unint64_t v30 = v42;
      __int128 v44 = *(_OWORD *)(v39 - 184);
      __int128 v45 = *(_OWORD *)(v39 - 168);
      __int128 v46 = *(_OWORD *)(v39 - 136);
      *(_OWORD *)(v30 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_OWORD *)(v39 - 152);
      *(_OWORD *)(v30 + 96) = v46;
      *(_OWORD *)(v30 + 48) = v44;
      *(_OWORD *)(v30 + 64) = v45;
      __int128 v47 = *(_OWORD *)(v39 - 120);
      __int128 v48 = *(_OWORD *)(v39 - 104);
      __int128 v49 = *(_OWORD *)(v39 - 72);
      *(_OWORD *)(v30 + 144) = *(_OWORD *)(v39 - 88);
      *(_OWORD *)(v30 + 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v49;
      *(_OWORD *)(v30 + 112) = v47;
      *(_OWORD *)(v30 + 128) = v48;
      __int128 v50 = *(_OWORD *)(v39 - 56);
      __int128 v51 = *(_OWORD *)(v39 - 40);
      __int128 v52 = *(_OWORD *)(v39 - 24);
      *(void *)(v30 + 224) = *(void *)(v39 - 8);
      *(_OWORD *)(v30 + 192) = v51;
      *(_OWORD *)(v30 + 208) = v52;
      *(_OWORD *)(v30 + 176) = v50;
      a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1012E2F20);
      v39 -= 232LL;
    }

    while ((char *)v39 != a5);
  }

  unint64_t v8 = v20;
  if (v20)
  {
LABEL_50:
    __int128 v106 = (_BYTE *)v32;
    v112.n128_u64[0] = (unint64_t)v22;
    v112.n128_u64[1] = v23;
    sub_100414E10(&v112, v8);
    __n128 v68 = v112;
    if (v112.n128_u64[1] != v23)
    {
      unint64_t v70 = v112.n128_u64[1];
      unint64_t v69 = (void *)v112.n128_u64[0];
      do
      {
        if (v30 == *v31)
        {
          uint64_t v71 = *--v31;
          unint64_t v30 = v71 + 3944;
        }

        if (v70 == *v69)
        {
          uint64_t v72 = *--v69;
          unint64_t v70 = v72 + 3944;
        }

        v30 -= 232LL;
        __int128 v73 = *(_OWORD *)(v70 - 232);
        __int128 v74 = *(_OWORD *)(v70 - 200);
        *(_OWORD *)(v30 + 16) = *(_OWORD *)(v70 - 216);
        *(_OWORD *)(v30 + 32) = v74;
        *(_OWORD *)unint64_t v30 = v73;
        __int128 v75 = *(_OWORD *)(v70 - 184);
        __int128 v76 = *(_OWORD *)(v70 - 168);
        __int128 v77 = *(_OWORD *)(v70 - 136);
        *(_OWORD *)(v30 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_OWORD *)(v70 - 152);
        *(_OWORD *)(v30 + 96) = v77;
        *(_OWORD *)(v30 + 48) = v75;
        *(_OWORD *)(v30 + 64) = v76;
        __int128 v78 = *(_OWORD *)(v70 - 120);
        __int128 v79 = *(_OWORD *)(v70 - 104);
        __int128 v80 = *(_OWORD *)(v70 - 72);
        *(_OWORD *)(v30 + 144) = *(_OWORD *)(v70 - 88);
        *(_OWORD *)(v30 + 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v80;
        *(_OWORD *)(v30 + 112) = v78;
        *(_OWORD *)(v30 + 128) = v79;
        __int128 v81 = *(_OWORD *)(v70 - 56);
        __int128 v82 = *(_OWORD *)(v70 - 40);
        __int128 v83 = *(_OWORD *)(v70 - 24);
        *(void *)(v30 + 224) = *(void *)(v70 - 8);
        *(_OWORD *)(v30 + 192) = v82;
        *(_OWORD *)(v30 + 208) = v83;
        *(_OWORD *)(v30 + 176) = v81;
        a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1012E2F20);
        v70 -= 232LL;
      }

      while (v70 != v23);
    }

    if (v8 < v20)
    {
      v112.n128_u64[0] = (unint64_t)v22;
      v112.n128_u64[1] = v23;
      sub_100414E10(&v112, v20);
      __n128 v84 = v112;
      v112.n128_u64[0] = (unint64_t)v22;
      v112.n128_u64[1] = v23;
      sub_100415064( v68.n128_u64[0],  (_BYTE *)v68.n128_u64[1],  v84.n128_u64[0],  (_BYTE *)v84.n128_u64[1],  (uint64_t)&v112);
      unint64_t v23 = v112.n128_u64[1];
      __int128 v22 = (void *)v112.n128_u64[0];
    }

    v112.n128_u64[0] = (unint64_t)v22;
    v112.n128_u64[1] = v23;
    sub_100415064(v111, v106, v108, a7, (uint64_t)&v112);
  }

void sub_100E8A9BC(void **a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  uint64_t v4 = a1[2];
  if (v4 == v3) {
    unint64_t v5 = a2 + 1;
  }
  else {
    unint64_t v5 = a2;
  }
  if (v4 == v3) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = 2 * (v4 - v3) + ((v4 - v3) >> 3) - 1;
  }
  if (v5 == 17 * (v5 / 0x11)) {
    unint64_t v7 = v5 / 0x11;
  }
  else {
    unint64_t v7 = v5 / 0x11 + 1;
  }
  uint64_t v8 = (uint64_t)a1[4];
  else {
    unint64_t v9 = v7;
  }
  if (v7 <= (v6 - ((uint64_t)a1[5] + v8)) / 0x11uLL)
  {
    for (a1[4] = (void *)(17 * v9 + v8); v9; --v9)
    {
      __int128 v18 = (void **)a1[2];
      __p[0] = *(v18 - 1);
      a1[2] = v18 - 1;
      sub_1000ECA74((uint64_t)a1, __p);
    }
  }

  else
  {
    unint64_t v10 = v7 - v9;
    uint64_t v11 = (uint64_t)(a1 + 3);
    uint64_t v12 = (v4 - v3) >> 3;
    uint64_t v13 = (_BYTE *)a1[3] - (_BYTE *)*a1;
    if (v7 - v9 <= (v13 >> 3) - v12)
    {
      if (v10)
      {
        if (v3 == *a1)
        {
LABEL_30:
          unint64_t v21 = v10;
          do
          {
            __p[0] = operator new(0xF68uLL);
            sub_1000EC960(a1, __p);
            --v21;
          }

          while (v21);
          v9 += v10;
          uint64_t v8 = (uint64_t)a1[4];
        }

        else
        {
          while (1)
          {
            __p[0] = operator new(0xF68uLL);
            sub_1000ECA74((uint64_t)a1, __p);
            unint64_t v19 = a1[1];
            uint64_t v20 = (_BYTE *)a1[2] - v19 == 8 ? 16LL : 17LL;
            uint64_t v8 = (uint64_t)a1[4] + v20;
            a1[4] = (void *)v8;
            if (!--v10) {
              break;
            }
            if (v19 == *a1) {
              goto LABEL_30;
            }
          }
        }
      }

      for (a1[4] = (void *)(v8 + 17 * v9); v9; --v9)
      {
        __int128 v22 = (void **)a1[2];
        __p[0] = *(v22 - 1);
        a1[2] = v22 - 1;
        sub_1000ECA74((uint64_t)a1, __p);
      }
    }

    else
    {
      BOOL v14 = v4 == v3;
      uint64_t v15 = 17 * v7;
      if (v13 >> 2 <= v10 + v12) {
        unint64_t v16 = v10 + v12;
      }
      else {
        unint64_t v16 = v13 >> 2;
      }
      unint64_t v69 = a1 + 3;
      if (v16) {
        uint64_t v17 = (char *)sub_1000071BC(v11, v16);
      }
      else {
        uint64_t v17 = 0LL;
      }
      uint64_t v23 = v15 - v14;
      __p[0] = v17;
      __p[1] = v17;
      unint64_t v67 = v17;
      __n128 v68 = &v17[8 * v16];
      do
      {
        __int128 v65 = operator new(0xF68uLL);
        sub_1000ECB90(__p, &v65);
        --v10;
      }

      while (v10);
      uint64_t v24 = (char *)a1[2];
      for (uint64_t i = v67; v9; --v9)
      {
        if (i == v68)
        {
          int64_t v26 = (char *)__p[1] - (char *)__p[0];
          if (__p[1] <= __p[0])
          {
            if (i == __p[0]) {
              unint64_t v34 = 1LL;
            }
            else {
              unint64_t v34 = (i - (char *)__p[0]) >> 2;
            }
            uint64_t v35 = (char *)sub_1000071BC((uint64_t)v69, v34);
            unint64_t v37 = (uint64_t *)__p[1];
            uint64_t i = &v35[8 * (v34 >> 2)];
            uint64_t v38 = v67 - (char *)__p[1];
            if (v67 != __p[1])
            {
              uint64_t i = &v35[8 * (v34 >> 2) + (v38 & 0xFFFFFFFFFFFFFFF8LL)];
              uint64_t v39 = 8 * (v38 >> 3);
              uint64_t v40 = &v35[8 * (v34 >> 2)];
              do
              {
                uint64_t v41 = *v37++;
                *(void *)uint64_t v40 = v41;
                v40 += 8;
                v39 -= 8LL;
              }

              while (v39);
            }

            __int128 v42 = __p[0];
            __p[0] = v35;
            __p[1] = &v35[8 * (v34 >> 2)];
            unint64_t v67 = i;
            __n128 v68 = &v35[8 * v36];
            if (v42)
            {
              operator delete(v42);
              uint64_t i = v67;
            }
          }

          else
          {
            uint64_t v27 = v26 >> 3;
            BOOL v28 = v26 >> 3 < -1;
            uint64_t v29 = (v26 >> 3) + 2;
            if (v28) {
              uint64_t v30 = v29;
            }
            else {
              uint64_t v30 = v27 + 1;
            }
            unint64_t v31 = (char *)__p[1] - 8 * (v30 >> 1);
            int64_t v32 = i - (char *)__p[1];
            if (i != __p[1])
            {
              memmove((char *)__p[1] - 8 * (v30 >> 1), __p[1], i - (char *)__p[1]);
              uint64_t i = (char *)__p[1];
            }

            unint64_t v33 = &i[-8 * (v30 >> 1)];
            uint64_t i = &v31[v32];
            __p[1] = v33;
            unint64_t v67 = &v31[v32];
          }
        }

        *(void *)uint64_t i = *((void *)v24 - 1);
        uint64_t i = v67 + 8;
        v67 += 8;
        uint64_t v24 = (char *)a1[2] - 8;
        a1[2] = v24;
      }

      __int128 v43 = (char *)a1[1];
      if (v43 == v24)
      {
        __int128 v43 = v24;
      }

      else
      {
        do
        {
          if (i == v68)
          {
            int64_t v44 = (char *)__p[1] - (char *)__p[0];
            if (__p[1] <= __p[0])
            {
              if (i == __p[0]) {
                unint64_t v51 = 1LL;
              }
              else {
                unint64_t v51 = (i - (char *)__p[0]) >> 2;
              }
              __int128 v52 = (char *)sub_1000071BC((uint64_t)v69, v51);
              unint64_t v54 = (uint64_t *)__p[1];
              uint64_t i = &v52[8 * (v51 >> 2)];
              uint64_t v55 = v67 - (char *)__p[1];
              if (v67 != __p[1])
              {
                uint64_t i = &v52[8 * (v51 >> 2) + (v55 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v56 = 8 * (v55 >> 3);
                __int128 v57 = &v52[8 * (v51 >> 2)];
                do
                {
                  uint64_t v58 = *v54++;
                  *(void *)__int128 v57 = v58;
                  v57 += 8;
                  v56 -= 8LL;
                }

                while (v56);
              }

              __int128 v59 = __p[0];
              __p[0] = v52;
              __p[1] = &v52[8 * (v51 >> 2)];
              unint64_t v67 = i;
              __n128 v68 = &v52[8 * v53];
              if (v59)
              {
                operator delete(v59);
                uint64_t i = v67;
              }
            }

            else
            {
              uint64_t v45 = v44 >> 3;
              BOOL v28 = v44 >> 3 < -1;
              uint64_t v46 = (v44 >> 3) + 2;
              if (v28) {
                uint64_t v47 = v46;
              }
              else {
                uint64_t v47 = v45 + 1;
              }
              __int128 v48 = (char *)__p[1] - 8 * (v47 >> 1);
              int64_t v49 = i - (char *)__p[1];
              if (i != __p[1])
              {
                memmove((char *)__p[1] - 8 * (v47 >> 1), __p[1], i - (char *)__p[1]);
                uint64_t i = (char *)__p[1];
              }

              __int128 v50 = &i[-8 * (v47 >> 1)];
              uint64_t i = &v48[v49];
              __p[1] = v50;
              unint64_t v67 = &v48[v49];
            }
          }

          uint64_t v60 = *(void *)v43;
          v43 += 8;
          *(void *)uint64_t i = v60;
          uint64_t i = v67 + 8;
          v67 += 8;
        }

        while (v43 != a1[2]);
        uint64_t v24 = (char *)a1[1];
      }

      __int128 v61 = v68;
      __int128 v62 = (char *)a1[3];
      __int128 v63 = (char *)a1[4];
      a1[2] = i;
      a1[3] = v61;
      __int128 v64 = *a1;
      *(_OWORD *)a1 = *(_OWORD *)__p;
      __p[0] = v64;
      __p[1] = v24;
      unint64_t v67 = v43;
      __n128 v68 = v62;
      a1[4] = &v63[v23];
      if (v43 != v24) {
        unint64_t v67 = &v43[(v24 - v43 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v64) {
        operator delete(v64);
      }
    }
  }

void sub_100E8AE34( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_100E8BE54(uint64_t a1)
{
  if (*(double *)(a1 + 8) <= 0.0)
  {
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101889870);
    }
    uint64_t v12 = (os_log_s *)qword_101934968;
    if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "#Error,FusedLoc,getAge called while MCT not set",  buf,  2u);
    }

    double v11 = -1.0;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934960 != -1) {
        dispatch_once(&qword_101934960, &stru_101889870);
      }
      LOWORD(v24) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  16LL,  "#Error,FusedLoc,getAge called while MCT not set",  &v24,  2);
      __int128 v22 = (uint8_t *)v21;
      sub_10029211C("Generic", 1LL, 0, 0LL, "CFTimeInterval cllcf::LCFusionFusedLocation::getAge() const", "%s\n", v21);
      if (v22 != buf) {
        free(v22);
      }
    }
  }

  else
  {
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101889870);
    }
    id v2 = (os_log_s *)qword_101934968;
    if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = sub_10080E94C();
      *(_DWORD *)__int128 buf = 1;
      double v4 = sub_10080EB58(v3, buf);
      double v5 = *(double *)(a1 + 8);
      uint64_t v6 = sub_10080E94C();
      *(_DWORD *)__int128 buf = 1;
      double v7 = sub_10080EB58(v6, buf);
      uint64_t v8 = sub_10080E94C();
      double v9 = sub_10080EF30(v8);
      *(_DWORD *)__int128 buf = 134218496;
      double v31 = v4 - v5;
      __int16 v32 = 2048;
      double v33 = v7;
      __int16 v34 = 2048;
      double v35 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "FusedLoc,getAge,age,%.3f,now_mct,%.3f,propagation_us,%.3f",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934960 != -1) {
        dispatch_once(&qword_101934960, &stru_101889870);
      }
      uint64_t v14 = qword_101934968;
      double v15 = sub_1003713F0();
      double v16 = *(double *)(a1 + 8);
      double v17 = sub_1003713F0();
      uint64_t v18 = sub_10080E94C();
      int v24 = 134218496;
      double v25 = v15 - v16;
      __int16 v26 = 2048;
      double v27 = v17;
      __int16 v28 = 2048;
      double v29 = sub_10080EF30(v18);
      LODWORD(v23) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v14,  2LL,  "FusedLoc,getAge,age,%.3f,now_mct,%.3f,propagation_us,%.3f",  COERCE_DOUBLE(&v24),  v23);
      uint64_t v20 = (uint8_t *)v19;
      sub_10029211C("Generic", 1LL, 0, 2LL, "CFTimeInterval cllcf::LCFusionFusedLocation::getAge() const", "%s\n", v19);
      if (v20 != buf) {
        free(v20);
      }
    }

    uint64_t v10 = sub_10080E94C();
    *(_DWORD *)__int128 buf = 1;
    return sub_10080EB58(v10, buf) - *(double *)(a1 + 8);
  }

  return v11;
}

void sub_100E8C1F4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

double sub_100E8C200(uint64_t a1, double *a2)
{
  double v2 = *(double *)(a1 + 8);
  if (v2 > 0.0) {
    return *a2 - v2;
  }
  if (qword_101934960 != -1) {
    dispatch_once(&qword_101934960, &stru_101889870);
  }
  double v4 = (os_log_s *)qword_101934968;
  if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "#Error,FusedLoc,getAge called while MCT not set",  buf,  2u);
  }

  double v3 = -1.0;
  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101889870);
    }
    v8[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  16LL,  "#Error,FusedLoc,getAge called while MCT not set",  v8,  2);
    double v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "CFTimeInterval cllcf::LCFusionFusedLocation::getAge(const CFTimeInterval &) const",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  return v3;
}

void sub_100E8C3AC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

uint64_t sub_100E8C3B8(uint64_t result, int a2)
{
  *(_BYTE *)(result + 664) = 1;
  *(_DWORD *)(result + 652) = a2;
  *(_DWORD *)(result + 612) = a2;
  return result;
}

void sub_100E8C3CC(void *a1, double *a2)
{
  while (a1[5])
  {
    if (sub_100E8C200(*(void *)(a1[1] + 8 * (a1[4] / 0x17uLL)) + 176 * (a1[4] % 0x17uLL), a2) <= 300.0) {
      break;
    }
    sub_100E8C474(a1);
  }

uint64_t sub_100E8C474(void *a1)
{
  unint64_t v2 = a1[4];
  double v3 = *(std::__shared_weak_count **)(*(void *)(a1[1] + 8 * (v2 / 0x17)) + 176 * (v2 % 0x17) + 24);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
    unint64_t v2 = a1[4];
  }

  uint64_t v4 = a1[5] - 1LL;
  a1[4] = v2 + 1;
  a1[5] = v4;
  return sub_100ABDAF8((uint64_t)a1, 1);
}

void sub_100E8C4F4(int64x2_t *a1, uint64_t a2)
{
  unint64_t v4 = a1[2].u64[1];
  if (a1[41].i8[8])
  {
    if (v4 >= 6) {
      sub_100E8C474(a1);
    }
  }

  else
  {
    if (v4 >= 0x1E) {
      sub_100E8C474(a1);
    }
    if (!a1[40].i32[3])
    {
      int v5 = dword_101991570 + 1;
      dword_101991570 = v5;
      a1[40].i32[3] = v5;
      a1[38].i32[1] = v5;
    }
  }

  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 24);
  if (!v6)
  {
    double v7 = 0LL;
LABEL_24:
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101889870);
    }
    unint64_t v19 = (os_log_s *)qword_101934968;
    if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_DEBUG))
    {
      __int32 v20 = a1[40].i32[3];
      *(_DWORD *)__int128 buf = 67240192;
      __int32 v70 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "FusedLoc,hID,%{public}d,trying to update with unavailable location object",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934960 != -1) {
        dispatch_once(&qword_101934960, &stru_101889870);
      }
      __int32 v60 = a1[40].i32[3];
      v68[0] = 67240192;
      v68[1] = v60;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  2LL,  "FusedLoc,hID,%{public}d,trying to update with unavailable location object",  v68,  8);
      __int128 v62 = (uint8_t *)v61;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void cllcf::LCFusionLocationHypothesis::newLocationUpdate(const LCFusionFusedLocation &)",  "%s\n",  v61);
      if (v62 != buf) {
        free(v62);
      }
    }

    goto LABEL_29;
  }

  double v7 = std::__shared_weak_count::lock(v6);
  if (!v7) {
    goto LABEL_24;
  }
  uint64_t v8 = *(void *)(a2 + 16);
  if (!v8) {
    goto LABEL_24;
  }
  uint64_t v9 = a1[2].i64[1];
  if (!v9)
  {
    sub_100E8CB70(a1, a2);
    a1[40].i32[2] = -1;
    unint64_t v23 = a1[2].i64[1] + a1[2].i64[0] - 1;
    uint64_t v24 = *(void *)(a1->i64[1] + 8 * (v23 / 0x17));
    unint64_t v25 = v23 % 0x17;
    uint64_t v26 = v24 + 176 * v25;
    int v28 = *(unsigned __int8 *)(v26 + 168);
    double v27 = (_BYTE *)(v26 + 168);
    if (v28) {
      goto LABEL_41;
    }
    *double v27 = 1;
    uint64_t v29 = v24 + 176 * v25;
    __int128 v30 = *(_OWORD *)(v8 + 8);
    __int128 v31 = *(_OWORD *)(v8 + 24);
    __int128 v32 = *(_OWORD *)(v8 + 40);
    *(_OWORD *)(v29 + 88) = *(_OWORD *)(v8 + 56);
    *(_OWORD *)(v29 + 72) = v32;
    *(_OWORD *)(v29 + 56) = v31;
    *(_OWORD *)(v29 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v30;
    __int128 v33 = *(_OWORD *)(v8 + 72);
    __int128 v34 = *(_OWORD *)(v8 + 88);
    __int128 v35 = *(_OWORD *)(v8 + 104);
    *(_OWORD *)(v29 + 148) = *(_OWORD *)(v8 + 116);
    *(_OWORD *)(v29 + 136) = v35;
    *(_OWORD *)(v29 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v34;
    *(_OWORD *)(v29 + 104) = v33;
    unint64_t v36 = a1[2].i64[1] + a1[2].i64[0] - 1;
    unint64_t v37 = *(void *)(a1->i64[1] + 8 * (v36 / 0x17)) + 176 * (v36 % 0x17);
LABEL_40:
    *(_BYTE *)(v37 + 169) = 0;
    *(_OWORD *)unint64_t v37 = *(_OWORD *)(v8 + 8);
    goto LABEL_41;
  }

  double v10 = *(double *)(a2 + 8);
  unint64_t v11 = a1[2].u64[0];
  uint64_t v12 = a1->i64[1];
  if (v10 >= *(double *)(*(void *)(v12 + 8 * ((v9 + v11 - 1) / 0x17)) + 176 * ((v9 + v11 - 1) % 0x17) + 8))
  {
    sub_100E8CB70(a1, a2);
    a1[40].i32[2] = a1[2].i32[2] - 2;
    goto LABEL_41;
  }

  unint64_t v13 = *(void *)(v12 + 8 * (v11 / 0x17)) + 176 * (v11 % 0x17);
  if (v10 <= *(double *)(v13 + 8))
  {
    sub_100E8CCA4((uint64_t)a1, a2);
    a1[40].i32[2] = 0;
    unint64_t v38 = a1[2].u64[0];
    uint64_t v39 = *(void *)(a1->i64[1] + 8 * (v38 / 0x17));
    unint64_t v40 = v38 % 0x17;
    uint64_t v41 = v39 + 176 * v40;
    int v43 = *(unsigned __int8 *)(v41 + 168);
    __int128 v42 = (_BYTE *)(v41 + 168);
    if (v43) {
      goto LABEL_41;
    }
    *__int128 v42 = 1;
    uint64_t v44 = v39 + 176 * v40;
    __int128 v45 = *(_OWORD *)(v8 + 8);
    __int128 v46 = *(_OWORD *)(v8 + 24);
    __int128 v47 = *(_OWORD *)(v8 + 40);
    *(_OWORD *)(v44 + 88) = *(_OWORD *)(v8 + 56);
    *(_OWORD *)(v44 + 72) = v47;
    *(_OWORD *)(v44 + 56) = v46;
    *(_OWORD *)(v44 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v45;
    __int128 v48 = *(_OWORD *)(v8 + 72);
    __int128 v49 = *(_OWORD *)(v8 + 88);
    __int128 v50 = *(_OWORD *)(v8 + 104);
    *(_OWORD *)(v44 + 148) = *(_OWORD *)(v8 + 116);
    *(_OWORD *)(v44 + 136) = v50;
    *(_OWORD *)(v44 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v49;
    *(_OWORD *)(v44 + 104) = v48;
    unint64_t v37 = *(void *)(a1->i64[1] + 8 * (a1[2].i64[0] / 0x17uLL)) + 176 * (a1[2].i64[0] % 0x17uLL);
    goto LABEL_40;
  }

  int v14 = v9 - 1;
  a1[40].i32[2] = v9 - 1;
  if (a1[1].i64[0] != v12)
  {
    unint64_t v15 = v11 + v9;
    double v16 = (uint64_t *)(v12 + 8 * (v15 / 0x17));
    uint64_t v17 = *v16;
    for (uint64_t i = *v16 + 176 * (v15 % 0x17); i != v13; i -= 176LL)
    {
      if (i == v17)
      {
        uint64_t v17 = *(v16 - 1);
        if (v10 >= *(double *)(v17 + 3880))
        {
LABEL_59:
          sub_100E8CDC0(a1, v16, i, a2);
          break;
        }

        a1[40].i32[2] = --v14;
        uint64_t i = v17 + 4048;
        --v16;
      }

      else
      {
        a1[40].i32[2] = --v14;
      }
    }
  }

void sub_100E8CB50(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

__n128 sub_100E8CB70(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 23 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100E902BC(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  uint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x17));
  unint64_t v9 = v7 % 0x17;
  uint64_t v10 = v8 + 176 * v9;
  *(_OWORD *)uint64_t v10 = *(_OWORD *)a2;
  uint64_t v11 = *(void *)(a2 + 24);
  *(void *)(v10 + 16) = *(void *)(a2 + 16);
  *(void *)(v10 + 24) = v11;
  if (v11)
  {
    uint64_t v12 = (unint64_t *)(v11 + 16);
    do
      unint64_t v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }

  uint64_t v14 = v8 + 176 * v9;
  *(void *)(v14 + 32) = &off_1018920B8;
  __int128 v15 = *(_OWORD *)(a2 + 40);
  __int128 v16 = *(_OWORD *)(a2 + 56);
  __int128 v17 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(v14 + 88) = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(v14 + 72) = v17;
  *(_OWORD *)(v14 + 56) = v16;
  *(_OWORD *)(v14 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v15;
  __n128 result = *(__n128 *)(a2 + 104);
  __int128 v19 = *(_OWORD *)(a2 + 120);
  __int128 v20 = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(v14 + 148) = *(_OWORD *)(a2 + 148);
  *(_OWORD *)(v14 + 136) = v20;
  *(_OWORD *)(v14 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v19;
  *(__n128 *)(v14 + 104) = result;
  *(_WORD *)(v14 + 168) = *(_WORD *)(a2 + 168);
  ++a1[5];
  return result;
}

int64x2_t sub_100E8CCA4(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_100E905D0((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }

  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 / 0x17));
  uint64_t v7 = *v6 + 176 * (v4 % 0x17);
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0LL;
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4048LL;
  }
  *(_OWORD *)(v7 - 176) = *(_OWORD *)a2;
  uint64_t v8 = *(void *)(a2 + 24);
  *(void *)(v7 - 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(void *)(a2 + 16);
  *(void *)(v7 - 152) = v8;
  if (v8)
  {
    unint64_t v9 = (unint64_t *)(v8 + 16);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  *(void *)(v7 - 144) = &off_1018920B8;
  __int128 v11 = *(_OWORD *)(a2 + 40);
  __int128 v12 = *(_OWORD *)(a2 + 56);
  __int128 v13 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(v7 - 88) = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(v7 - 104) = v13;
  *(_OWORD *)(v7 - 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v12;
  *(_OWORD *)(v7 - 136) = v11;
  __int128 v14 = *(_OWORD *)(a2 + 104);
  __int128 v15 = *(_OWORD *)(a2 + 120);
  __int128 v16 = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(v7 - 28) = *(_OWORD *)(a2 + 148);
  *(_OWORD *)(v7 - 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v16;
  *(_OWORD *)(v7 - 56) = v15;
  *(_OWORD *)(v7 - 72) = v14;
  *(_WORD *)(v7 - 8) = *(_WORD *)(a2 + 168);
  int64x2_t result = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1012E2F20);
  *(int64x2_t *)(a1 + 32) = result;
  return result;
}

void *sub_100E8CDC0(int64x2_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = a1[2].u64[0];
  uint64_t v7 = a1->i64[1];
  uint64_t v8 = a1[1].i64[0];
  unint64_t v9 = (void *)(v7 + 8 * (v6 / 0x17));
  if (v8 == v7) {
    unint64_t v10 = 0LL;
  }
  else {
    unint64_t v10 = *v9 + 176 * (v6 % 0x17);
  }
  if (a3 == v10) {
    unint64_t v11 = 0LL;
  }
  else {
    unint64_t v11 = 23 * (a2 - v9) + 0x2E8BA2E8BA2E8BA3LL * ((a3 - *a2) >> 4) - 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(v10 - *v9) >> 4);
  }
  uint64_t v12 = a1[2].i64[1];
  unint64_t v13 = v12 - v11;
  if (v11 >= v12 - v11)
  {
    if (v8 == v7) {
      uint64_t v22 = 0LL;
    }
    else {
      uint64_t v22 = 23 * ((v8 - v7) >> 3) - 1;
    }
    if (v22 == v12 + v6)
    {
      sub_100E902BC(a1);
      uint64_t v12 = a1[2].i64[1];
      unint64_t v13 = v12 - v11;
    }

    if (v12 != v11)
    {
      uint64_t v87 = a4;
      unint64_t v37 = a1[2].i64[0] + v12;
      uint64_t v38 = a1->i64[1];
      uint64_t v39 = (void *)(v38 + 8 * (v37 / 0x17));
      uint64_t v40 = *v39;
      unint64_t v41 = *v39 + 176 * (v37 % 0x17);
      if (a1[1].i64[0] == v38) {
        uint64_t v42 = 0LL;
      }
      else {
        uint64_t v42 = v41;
      }
      uint64_t v43 = 0x2E8BA2E8BA2E8BA3LL * ((v42 - v40) >> 4);
      if (v42 - v40 < 177)
      {
        unint64_t v71 = 23 - v43;
        __int128 v45 = &v39[-(v71 / 0x17)];
        unint64_t v46 = *v45 + 176 * (23 * (v71 / 0x17) - v71) + 3872;
      }

      else
      {
        unint64_t v44 = v43 - 1;
        __int128 v45 = &v39[v44 / 0x17];
        unint64_t v46 = *v45 + 176 * (v44 % 0x17);
      }

      if (v46 == a4)
      {
        uint64_t v87 = v42;
        a4 = v42;
      }

      *(_OWORD *)uint64_t v42 = *(_OWORD *)v46;
      *(_OWORD *)(v42 + 16) = *(_OWORD *)(v46 + 16);
      *(void *)(v46 + 16) = 0LL;
      *(void *)(v46 + 24) = 0LL;
      *(void *)(v42 + 32) = &off_1018920B8;
      __int128 v72 = *(_OWORD *)(v46 + 40);
      __int128 v73 = *(_OWORD *)(v46 + 56);
      __int128 v74 = *(_OWORD *)(v46 + 72);
      *(_OWORD *)(v42 + 88) = *(_OWORD *)(v46 + 88);
      *(_OWORD *)(v42 + 72) = v74;
      *(_OWORD *)(v42 + 56) = v73;
      *(_OWORD *)(v42 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v72;
      __int128 v75 = *(_OWORD *)(v46 + 104);
      __int128 v76 = *(_OWORD *)(v46 + 120);
      __int128 v77 = *(_OWORD *)(v46 + 136);
      *(_OWORD *)(v42 + 148) = *(_OWORD *)(v46 + 148);
      *(_OWORD *)(v42 + 136) = v77;
      *(_OWORD *)(v42 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v76;
      *(_OWORD *)(v42 + 104) = v75;
      *(_WORD *)(v42 + 168) = *(_WORD *)(v46 + 168);
      ++a1[2].i64[1];
      if (v13 >= 2)
      {
        __int128 v88 = v39;
        uint64_t v89 = v42;
        sub_1005A83FC(&v88, -(uint64_t)v13);
        uint64_t v39 = sub_100E90A68((uint64_t)a1, v88, v89, v45, v46, v39, v42, (unint64_t *)&v87);
        uint64_t v42 = v78;
        a4 = v87;
      }

      if (v42 == *v39) {
        uint64_t v42 = *(v39 - 1) + 4048LL;
      }
      uint64_t v79 = v42 - 176;
      goto LABEL_56;
    }

    unint64_t v23 = a1[2].i64[0] + v11;
    uint64_t v24 = *(void *)(a1->i64[1] + 8 * (v23 / 0x17));
    unint64_t v25 = v23 % 0x17;
    uint64_t v26 = v24 + 176 * v25;
    *(_OWORD *)uint64_t v26 = *(_OWORD *)a4;
    *(void *)(v26 + 16) = *(void *)(a4 + 16);
    uint64_t v27 = *(void *)(a4 + 24);
    *(void *)(v26 + 24) = v27;
    if (v27)
    {
      int v28 = (unint64_t *)(v27 + 16);
      do
        unint64_t v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }

    uint64_t v30 = v24 + 176 * v25;
    *(void *)(v30 + 32) = &off_1018920B8;
    __int128 v31 = *(_OWORD *)(a4 + 40);
    __int128 v32 = *(_OWORD *)(a4 + 56);
    __int128 v33 = *(_OWORD *)(a4 + 72);
    *(_OWORD *)(v30 + 88) = *(_OWORD *)(a4 + 88);
    *(_OWORD *)(v30 + 72) = v33;
    *(_OWORD *)(v30 + 56) = v32;
    *(_OWORD *)(v30 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v31;
    __int128 v34 = *(_OWORD *)(a4 + 104);
    __int128 v35 = *(_OWORD *)(a4 + 120);
    __int128 v36 = *(_OWORD *)(a4 + 136);
    *(_OWORD *)(v30 + 148) = *(_OWORD *)(a4 + 148);
    *(_OWORD *)(v30 + 136) = v36;
    *(_OWORD *)(v30 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v35;
    *(_OWORD *)(v30 + 104) = v34;
    *(_WORD *)(v30 + 168) = *(_WORD *)(a4 + 168);
    ++a1[2].i64[1];
  }

  else
  {
    if (v6)
    {
      if (v11)
      {
LABEL_10:
        uint64_t v87 = a4;
        unint64_t v14 = a1[2].u64[0];
        uint64_t v15 = a1->i64[1];
        __int128 v16 = (void *)(v15 + 8 * (v14 / 0x17));
        uint64_t v17 = *v16;
        unint64_t v18 = *v16 + 176 * (v14 % 0x17);
        if (a1[1].i64[0] == v15) {
          uint64_t v19 = 0LL;
        }
        else {
          uint64_t v19 = v18;
        }
        uint64_t v20 = 0x2E8BA2E8BA2E8BA3LL * ((v19 - v17) >> 4);
        if (v19 - v17 < 177) {
          unint64_t v21 = v16[-((23 - v20) / 0x17uLL)] + 176 * (23 * ((23 - v20) / 0x17uLL) - (23 - v20)) + 3872;
        }
        else {
          unint64_t v21 = v16[(v20 - 1) / 0x17uLL] + 176 * ((v20 - 1) % 0x17uLL);
        }
        if (v19 == a4)
        {
          uint64_t v87 = v21;
          a4 = v21;
        }

        *(_OWORD *)unint64_t v21 = *(_OWORD *)v19;
        *(_OWORD *)(v21 + 16) = *(_OWORD *)(v19 + 16);
        *(void *)(v19 + 16) = 0LL;
        *(void *)(v19 + 24) = 0LL;
        *(void *)(v21 + 32) = &off_1018920B8;
        __int128 v60 = *(_OWORD *)(v19 + 40);
        __int128 v61 = *(_OWORD *)(v19 + 56);
        __int128 v62 = *(_OWORD *)(v19 + 72);
        *(_OWORD *)(v21 + 88) = *(_OWORD *)(v19 + 88);
        *(_OWORD *)(v21 + 72) = v62;
        *(_OWORD *)(v21 + 56) = v61;
        *(_OWORD *)(v21 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v60;
        __int128 v63 = *(_OWORD *)(v19 + 104);
        __int128 v64 = *(_OWORD *)(v19 + 120);
        __int128 v65 = *(_OWORD *)(v19 + 136);
        *(_OWORD *)(v21 + 148) = *(_OWORD *)(v19 + 148);
        *(_OWORD *)(v21 + 136) = v65;
        *(_OWORD *)(v21 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v64;
        *(_OWORD *)(v21 + 104) = v63;
        *(_WORD *)(v21 + 168) = *(_WORD *)(v19 + 168);
        a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1012E2F20);
        if (v11 >= 2)
        {
          uint64_t v66 = v19 - *v16;
          uint64_t v67 = 0x2E8BA2E8BA2E8BA3LL * (v66 >> 4);
          if (v66 < -175)
          {
            unint64_t v80 = 21 - v67;
            unint64_t v69 = &v16[-(v80 / 0x17)];
            unint64_t v70 = *v69 + 176 * (23 * (v80 / 0x17) - v80) + 3872;
          }

          else
          {
            unint64_t v68 = v67 + 1;
            unint64_t v69 = &v16[v68 / 0x17];
            unint64_t v70 = *v69 + 176 * (v68 % 0x17);
          }

          __int128 v88 = v16;
          uint64_t v89 = v19;
          sub_1005A83FC(&v88, v11);
          sub_100E908E8((uint64_t)a1, v69, v70, v88, v89, v16, v19, (unint64_t *)&v87);
          uint64_t v19 = v81;
          a4 = v87;
        }

        uint64_t v79 = v19;
LABEL_56:
        sub_100ABE580(v79, a4);
        goto LABEL_57;
      }
    }

    else
    {
      sub_100E905D0((void **)a1);
      if (v11) {
        goto LABEL_10;
      }
    }

    unint64_t v47 = a1[2].u64[0];
    uint64_t v48 = a1->i64[1];
    __int128 v49 = (void *)(v48 + 8 * (v47 / 0x17));
    uint64_t v50 = *v49 + 176 * (v47 % 0x17);
    if (a1[1].i64[0] == v48) {
      uint64_t v50 = 0LL;
    }
    if (v50 == *v49) {
      uint64_t v50 = *(v49 - 1) + 4048LL;
    }
    *(_OWORD *)(v50 - 176) = *(_OWORD *)a4;
    *(void *)(v50 - 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(void *)(a4 + 16);
    uint64_t v51 = *(void *)(a4 + 24);
    *(void *)(v50 - 152) = v51;
    if (v51)
    {
      unint64_t v52 = (unint64_t *)(v51 + 16);
      do
        unint64_t v53 = __ldxr(v52);
      while (__stxr(v53 + 1, v52));
    }

    *(void *)(v50 - 144) = &off_1018920B8;
    __int128 v54 = *(_OWORD *)(a4 + 40);
    __int128 v55 = *(_OWORD *)(a4 + 56);
    __int128 v56 = *(_OWORD *)(a4 + 72);
    *(_OWORD *)(v50 - 88) = *(_OWORD *)(a4 + 88);
    *(_OWORD *)(v50 - 104) = v56;
    *(_OWORD *)(v50 - 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v55;
    *(_OWORD *)(v50 - 136) = v54;
    __int128 v57 = *(_OWORD *)(a4 + 104);
    __int128 v58 = *(_OWORD *)(a4 + 120);
    __int128 v59 = *(_OWORD *)(a4 + 136);
    *(_OWORD *)(v50 - 28) = *(_OWORD *)(a4 + 148);
    *(_OWORD *)(v50 - 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v59;
    *(_OWORD *)(v50 - 56) = v58;
    *(_OWORD *)(v50 - 72) = v57;
    *(_WORD *)(v50 - 8) = *(_WORD *)(a4 + 168);
    a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1012E2F20);
  }

BOOL sub_100E8D56C(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 648);
  if ((v2 & 0x80000000) == 0)
  {
    unint64_t v3 = *(void *)(a1 + 40);
    if (v3 > v2)
    {
      if (v3 - 1 <= v2)
      {
        *(_DWORD *)(a1 + 648) = v3 - 1;
        return 1LL;
      }

      char v187 = 0;
      uint64_t v189 = a1 + 48;
      __asm { FMOV            V0.2D, #-1.0 }

      __int128 v188 = _Q0;
      while (1)
      {
        uint64_t v9 = *(void *)(a1 + 32);
        uint64_t v10 = *(void *)(a1 + 8);
        uint64_t v11 = ((unint64_t)(v9 + v2) * (unsigned __int128)0x642C8590B21642C9uLL) >> 64;
        unint64_t v12 = (v11 + ((unint64_t)(v9 + v2 - v11) >> 1)) >> 4;
        if (!*(_BYTE *)(*(void *)(v10 + 8 * v12) + 176 * (v9 + v2 - 23 * v12) + 168))
        {
          if (qword_101934960 != -1) {
            dispatch_once(&qword_101934960, &stru_101889870);
          }
          uint64_t v162 = (os_log_s *)qword_101934968;
          if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_ERROR))
          {
            int v163 = *(_DWORD *)(a1 + 652);
            uint64_t v164 = *(void *)(a1 + 40);
            LODWORD(buf) = 67240704;
            DWORD1(buf) = v163;
            WORD4(buf) = 1026;
            *(_DWORD *)((char *)&buf + 1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v2;
            HIWORD(buf) = 2050;
            *(void *)float v226 = v164;
            _os_log_impl( (void *)&_mh_execute_header,  v162,  OS_LOG_TYPE_ERROR,  "#Error,FusedLoc,hID,%{public}d,DataFusion called on fusion index which is not previously fused,index,%{pub lic}d,bufferSize,%{public}zu",  (uint8_t *)&buf,  0x18u);
          }

          BOOL result = sub_1002921D0(115, 0);
          if (!result) {
            return result;
          }
          bzero(&buf, 0x65CuLL);
          if (qword_101934960 != -1) {
            dispatch_once(&qword_101934960, &stru_101889870);
          }
          int v181 = *(_DWORD *)(a1 + 652);
          uint64_t v182 = *(void *)(a1 + 40);
          LODWORD(v215) = 67240704;
          HIDWORD(v215) = v181;
          LOWORD(v216) = 1026;
          *(_DWORD *)((char *)&v216 + 2) = v2;
          WORD3(v216) = 2050;
          *((void *)&v216 + 1) = v182;
          LODWORD(v184) = 24;
          _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934968,  16LL,  "#Error,FusedLoc,hID,%{public}d,DataFusion called on fusion index which is not previously fused,index,%{publi c}d,bufferSize,%{public}zu",  &v215,  v184);
          v161 = (__int128 *)v183;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL cllcf::LCFusionLocationHypothesis::performLocationDataFusion()",  "%s\n",  v183);
LABEL_178:
          if (v161 != &buf) {
            free(v161);
          }
          return 0LL;
        }

        unint64_t v13 = v2 + 1;
        unint64_t v14 = *(void *)(v10 + 8 * ((v9 + v2 + 1) / 0x17uLL)) + 176 * ((v9 + v2 + 1) % 0x17uLL);
        uint64_t v15 = *(std::__shared_weak_count **)(v14 + 24);
        if (!v15)
        {
          __int128 v16 = 0LL;
LABEL_21:
          if (qword_101934960 != -1) {
            dispatch_once(&qword_101934960, &stru_101889870);
          }
          uint64_t v40 = (os_log_s *)qword_101934968;
          if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_ERROR))
          {
            int v41 = *(_DWORD *)(a1 + 652);
            uint64_t v42 = *(void *)(a1 + 40);
            LODWORD(buf) = 67240704;
            DWORD1(buf) = v41;
            WORD4(buf) = 1026;
            *(_DWORD *)((char *)&buf + 1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v2 + 1;
            HIWORD(buf) = 2050;
            *(void *)float v226 = v42;
            _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_ERROR,  "#Error,FusedLoc,hID,%{public}d,DataFusion called on invalid new raw location,index,%{public}d,bufferSize,%{public}zu",  (uint8_t *)&buf,  0x18u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(&buf, 0x65CuLL);
            if (qword_101934960 != -1) {
              dispatch_once(&qword_101934960, &stru_101889870);
            }
            int v106 = *(_DWORD *)(a1 + 652);
            uint64_t v107 = *(void *)(a1 + 40);
            LODWORD(v215) = 67240704;
            HIDWORD(v215) = v106;
            LOWORD(v216) = 1026;
            *(_DWORD *)((char *)&v216 + 2) = v2 + 1;
            WORD3(v216) = 2050;
            *((void *)&v216 + 1) = v107;
            LODWORD(v184) = 24;
            _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934968,  16LL,  "#Error,FusedLoc,hID,%{public}d,DataFusion called on invalid new raw location,index,%{public}d,bufferSize,%{public}zu",  &v215,  v184);
            __int128 v109 = (__int128 *)v108;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL cllcf::LCFusionLocationHypothesis::performLocationDataFusion()",  "%s\n",  v108);
            if (v109 != &buf) {
              free(v109);
            }
          }

          int v39 = 1;
          goto LABEL_27;
        }

        __int128 v16 = std::__shared_weak_count::lock(v15);
        if (!v16) {
          goto LABEL_21;
        }
        uint64_t v17 = *(void *)(v14 + 16);
        double v18 = *(double *)(v17 + 16);
        unint64_t v19 = *(void *)(a1 + 32) + v2;
        uint64_t v20 = *(void *)(*(void *)(a1 + 8) + 8 * (v19 / 0x17));
        unint64_t v21 = v19 % 0x17;
        double v22 = *(double *)(v20 + 176 * (v19 % 0x17) + 8);
        unint64_t v23 = (char *)operator new(0xA0uLL);
        *((void *)v23 + 1) = 0LL;
        uint64_t v24 = (unint64_t *)(v23 + 8);
        *(void *)unint64_t v23 = off_10186D518;
        *((void *)v23 + 2) = 0LL;
        *((void *)v23 + 3) = &off_1018920B8;
        uint64_t v25 = v20 + 176 * v21;
        __int128 v26 = *(_OWORD *)(v25 + 40);
        __int128 v27 = *(_OWORD *)(v25 + 56);
        __int128 v28 = *(_OWORD *)(v25 + 88);
        *((_OWORD *)v23 + 4) = *(_OWORD *)(v25 + 72);
        *((_OWORD *)v23 + 5) = v28;
        *((_OWORD *)v23 + 2) = v26;
        *((_OWORD *)v23 + 3) = v27;
        __int128 v29 = *(_OWORD *)(v25 + 104);
        __int128 v30 = *(_OWORD *)(v25 + 120);
        __int128 v31 = *(_OWORD *)(v25 + 136);
        *(_OWORD *)(v23 + 14sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *(_OWORD *)(v25 + 148);
        *((_OWORD *)v23 + 7) = v30;
        *((_OWORD *)v23 + 8) = v31;
        *((_OWORD *)v23 + 6) = v29;
        uint64_t v215 = &off_1018920B8;
        __int128 v216 = v188;
        __int128 v217 = xmmword_1012E0070;
        __int128 v218 = xmmword_1012E0070;
        __int128 v219 = v188;
        __int128 v220 = v188;
        unint64_t v221 = 0xBFF0000000000000LL;
        int v222 = 0;
        char v223 = 0;
        int v224 = 0;
        if (!sub_1004CCD0C(v189, (double *)(v17 + 16)) || (sub_1004CE2F8(v189, (uint64_t)&v215) & 1) == 0)
        {
          if (qword_101934960 != -1) {
            dispatch_once(&qword_101934960, &stru_101889870);
          }
          unint64_t v46 = (os_log_s *)qword_101934968;
          if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_ERROR))
          {
            int v47 = *(_DWORD *)(a1 + 652);
            int v48 = *(_DWORD *)(v17 + 128);
            uint64_t v49 = *(void *)(v17 + 16);
            uint64_t v50 = *((void *)v23 + 5);
            LODWORD(buf) = 67240960;
            DWORD1(buf) = v47;
            WORD4(buf) = 1026;
            *(_DWORD *)((char *)&buf + 1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v48;
            HIWORD(buf) = 2050;
            *(void *)float v226 = v49;
            *(_WORD *)&v226[8] = 2050;
            *(void *)&v226[10] = v50;
            _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_ERROR,  "#Error,FusedLoc,hID,%{public}d,DataFusion failed time aligning fused location,type,%{public}d,new location mct,%{public}.3f,fused location mct,%{public}.3f",  (uint8_t *)&buf,  0x22u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(&buf, 0x65CuLL);
            if (qword_101934960 != -1) {
              dispatch_once(&qword_101934960, &stru_101889870);
            }
            int v110 = *(_DWORD *)(a1 + 652);
            int v111 = *(_DWORD *)(v17 + 128);
            uint64_t v112 = *(void *)(v17 + 16);
            uint64_t v113 = *((void *)v23 + 5);
            LODWORD(v205) = 67240960;
            HIDWORD(v205) = v110;
            *(_WORD *)int v206 = 1026;
            *(_DWORD *)&v206[2] = v111;
            *(_WORD *)&v206[6] = 2050;
            *(void *)&v206[8] = v112;
            *(_WORD *)&v206[16] = 2050;
            *(void *)&v206[18] = v113;
            LODWORD(v184) = 34;
            _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934968,  16LL,  "#Error,FusedLoc,hID,%{public}d,DataFusion failed time aligning fused location,type,%{public}d,new location mct,%{public}.3f,fused location mct,%{public}.3f",  &v205,  v184);
            uint64_t v115 = (__int128 *)v114;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL cllcf::LCFusionLocationHypothesis::performLocationDataFusion()",  "%s\n",  v114);
            if (v115 != &buf) {
              free(v115);
            }
          }

          int v39 = 1;
          goto LABEL_42;
        }

        double v32 = v18 - v22;
        if (qword_101934960 != -1) {
          dispatch_once(&qword_101934960, &stru_101889870);
        }
        __int128 v33 = (os_log_s *)qword_101934968;
        if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_DEBUG))
        {
          int v34 = *(_DWORD *)(a1 + 652);
          int v35 = *(_DWORD *)(v17 + 128);
          uint64_t v36 = *(void *)(v17 + 40);
          uint64_t v37 = *(void *)(a1 + 416);
          uint64_t v38 = *(void *)(a1 + 40);
          LODWORD(buf) = 67241728;
          DWORD1(buf) = v34;
          WORD4(buf) = 1026;
          *(_DWORD *)((char *)&buf + 1sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v35;
          HIWORD(buf) = 2050;
          *(void *)float v226 = v36;
          *(_WORD *)&v226[8] = 2050;
          *(void *)&v226[10] = v217;
          __int16 v227 = 2050;
          *(void *)float v228 = v37;
          *(_WORD *)&v228[8] = 1026;
          *(_DWORD *)&v228[10] = v2;
          __int16 v229 = 2050;
          uint64_t v230 = v38;
          _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEBUG,  "FusedLoc,hID,%{public}d,predicted fused location with large uncertainty switching to CC Fusion,type,%{public }d,new loc hunc,%{public}.1f,fused loc hunc,%{public}.1f,fused loc DR time_s,%{public}.1f,index,%{public}d,b ufferSize,%{public}zu",  (uint8_t *)&buf,  0x3Cu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(&buf, 0x65CuLL);
          if (qword_101934960 != -1) {
            dispatch_once(&qword_101934960, &stru_101889870);
          }
          int v116 = *(_DWORD *)(a1 + 652);
          int v117 = *(_DWORD *)(v17 + 128);
          uint64_t v118 = *(void *)(v17 + 40);
          uint64_t v119 = *(void *)(a1 + 416);
          uint64_t v120 = *(void *)(a1 + 40);
          LODWORD(v205) = 67241728;
          HIDWORD(v205) = v116;
          *(_WORD *)int v206 = 1026;
          *(_DWORD *)&v206[2] = v117;
          *(_WORD *)&v206[6] = 2050;
          *(void *)&v206[8] = v118;
          *(_WORD *)&v206[16] = 2050;
          *(void *)&v206[18] = v217;
          __int16 v207 = 2050;
          *(void *)float v208 = v119;
          *(_WORD *)&v208[8] = 1026;
          *(_DWORD *)&v208[10] = v2;
          *(_WORD *)&v208[14] = 2050;
          *(void *)&v208[16] = v120;
          LODWORD(v184) = 60;
          _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934968,  2LL,  "FusedLoc,hID,%{public}d,predicted fused location with large uncertainty switching to CC Fusion,type,%{public }d,new loc hunc,%{public}.1f,fused loc hunc,%{public}.1f,fused loc DR time_s,%{public}.1f,index,%{public}d,b ufferSize,%{public}zu",  &v205,  v184);
          __int128 v122 = (__int128 *)v121;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL cllcf::LCFusionLocationHypothesis::performLocationDataFusion()",  "%s\n",  v121);
          if (v122 != &buf) {
            free(v122);
          }
        }

        sub_100E8F104(a1, v2 + 1, v17, (uint64_t)&v215, v32);
        char v187 = 1;
        int v39 = 10;
        do
LABEL_42:
          unint64_t v51 = __ldaxr(v24);
        while (__stlxr(v51 - 1, v24));
        if (!v51)
        {
          (*(void (**)(char *))(*(void *)v23 + 16LL))(v23);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v23);
        }

void sub_100E8F0EC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_100006BB8(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100E8F104(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  __int128 v10 = *(_OWORD *)(a3 + 72);
  uint64_t v37 = &off_1018920B8;
  __int128 v11 = *(_OWORD *)(a3 + 88);
  *(_OWORD *)int v41 = v10;
  *(_OWORD *)&v41[16] = v11;
  *(_OWORD *)&unsigned __int16 v41[32] = *(_OWORD *)(a3 + 104);
  *(_OWORD *)&v41[44] = *(_OWORD *)(a3 + 116);
  __int128 v12 = *(_OWORD *)(a3 + 24);
  __int128 v38 = *(_OWORD *)(a3 + 8);
  __int128 v39 = v12;
  __int128 v13 = *(_OWORD *)(a3 + 56);
  *(_OWORD *)uint64_t v40 = *(_OWORD *)(a3 + 40);
  *(_OWORD *)&v40[16] = v13;
  sub_100FBA824((uint64_t)&v37, (uint64_t)"FusedLoc,CC Fusion a priori", *(_DWORD *)(a1 + 652));
  *(double *)v15.i64 = *(double *)(a4 + 40) * *(double *)(a4 + 40) * 0.5;
  *(double *)v16.i64 = *(double *)(a3 + 40) * *(double *)(a3 + 40) * 0.5;
  else {
    double v17 = 1.0;
  }
  else {
    double v18 = 1.0;
  }
  double v19 = 1.0 / (v17 + v18);
  *(void *)uint64_t v40 = sqrt(v19 + v19);
  *(double *)v14.i64 = v17 * (*(double *)(a4 + 32) * 0.0174532925);
  *(double *)v15.i64 = v19 * (*(double *)(a3 + 24) * 0.0174532925 * v18 + v17 * (*(double *)(a4 + 24) * 0.0174532925));
  double v20 = v18 * (*(double *)(a3 + 32) * 0.0174532925) + *(double *)v14.i64;
  v14.i64[0] = 0x400921FB54442D18LL;
  int8x16_t v35 = v14;
  if (fabs(*(double *)v15.i64) > 3.14159265)
  {
    v21.f64[0] = NAN;
    v21.f64[1] = NAN;
    int8x16_t v34 = vbslq_s8((int8x16_t)vnegq_f64(v21), v14, v15);
    *(double *)v15.i64 = fmod(*(double *)v15.i64 + *(double *)v34.i64, 6.28318531);
    v16.i64[1] = v34.i64[1];
    *(double *)v15.i64 = *(double *)v15.i64 - *(double *)v34.i64;
  }

  *(double *)v16.i64 = v19 * v20;
  if (*(double *)v15.i64 >= 1.57079633)
  {
    int8x16_t v22 = v35;
    *(double *)v15.i64 = *(double *)v35.i64 - *(double *)v15.i64;
  }

  else
  {
    int8x16_t v22 = v35;
  }

  *(double *)&__int128 v39 = *(double *)v15.i64 * 57.2957795;
  if (fabs(*(double *)v16.i64) > *(double *)v22.i64)
  {
    v23.f64[0] = NAN;
    v23.f64[1] = NAN;
    double v36 = *(double *)vbslq_s8((int8x16_t)vnegq_f64(v23), v22, v16).i64;
    *(double *)v16.i64 = fmod(*(double *)v16.i64 + v36, 6.28318531) - v36;
  }

  *((double *)&v39 + 1) = *(double *)v16.i64 * 57.2957795;
  if (a5 <= 2.0)
  {
    if (((*(uint64_t (**)(uint64_t))(*(void *)a3 + 32LL))(a3) & 1) == 0)
    {
    }
  }

  double v24 = *(double *)v40;
  *(double *)uint64_t v40 = v24;
  sub_100FBA824((uint64_t)&v37, (uint64_t)"FusedLoc,CC Fusion a posteriori", *(_DWORD *)(a1 + 652));
  unint64_t v25 = *(void *)(*(void *)(a1 + 8) + 8 * ((*(void *)(a1 + 32) + a2) / 0x17uLL))
      + 176 * ((*(void *)(a1 + 32) + a2) % 0x17uLL);
  __int128 v26 = v38;
  __int128 v27 = v39;
  __int128 v28 = *(_OWORD *)v40;
  *(_OWORD *)(v25 + 88) = *(_OWORD *)&v40[16];
  *(_OWORD *)(v25 + 72) = v28;
  *(_OWORD *)(v25 + 56) = v27;
  *(_OWORD *)(v25 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v26;
  __int128 v29 = *(_OWORD *)v41;
  __int128 v30 = *(_OWORD *)&v41[16];
  __int128 v31 = *(_OWORD *)&v41[32];
  *(_OWORD *)(v25 + 148) = *(_OWORD *)&v41[44];
  *(_OWORD *)(v25 + 136) = v31;
  *(_OWORD *)(v25 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v30;
  *(_OWORD *)(v25 + 104) = v29;
  unint64_t v32 = *(void *)(*(void *)(a1 + 8) + 8 * ((*(void *)(a1 + 32) + a2) / 0x17uLL))
      + 176 * ((*(void *)(a1 + 32) + a2) % 0x17uLL);
  *(_WORD *)(v32 + 168) = 1;
  *(_OWORD *)unint64_t v32 = v38;
  return 1LL;
}

uint64_t sub_100E8F440(uint64_t a1, uint64_t a2, uint64_t a3, double *a4, uint64_t a5, double a6)
{
  uint64_t v87 = &off_1018920B8;
  __int128 v11 = *(_OWORD *)(a3 + 88);
  *(_OWORD *)int v91 = *(_OWORD *)(a3 + 72);
  *(_OWORD *)&v91[16] = v11;
  *(_OWORD *)&v91[32] = *(_OWORD *)(a3 + 104);
  *(_OWORD *)&v91[44] = *(_OWORD *)(a3 + 116);
  __int128 v12 = *(_OWORD *)(a3 + 24);
  __int128 v88 = *(_OWORD *)(a3 + 8);
  __int128 v89 = v12;
  __int128 v13 = *(_OWORD *)(a3 + 56);
  *(_OWORD *)int v90 = *(_OWORD *)(a3 + 40);
  *(_OWORD *)&v90[16] = v13;
  sub_100FBA824((uint64_t)&v87, (uint64_t)"FusedLoc,IDC Fusion a priori", *(_DWORD *)(a1 + 652));
  *(double *)v18.i64 = *(double *)(a5 + 40) * *(double *)(a5 + 40) * 0.5;
  else {
    double v19 = 1.0;
  }
  double v20 = *(double *)(a3 + 40) * *(double *)(a3 + 40) * 0.5;
  if (v20 >= 1.0) {
    double v21 = 1.0 / v20;
  }
  else {
    double v21 = 1.0;
  }
  double v22 = a4[5] * a4[5] * 0.5;
  if (v22 >= 1.0) {
    double v23 = 1.0 / v22;
  }
  else {
    double v23 = 1.0;
  }
  double v24 = v21 - v23;
  if (v23 > v21) {
    double v24 = v23 - v21;
  }
  double v71 = 1.0 / (v19 + v24);
  *(void *)int v90 = sqrt(v71 + v71);
  double v68 = *(double *)(a3 + 24);
  *(double *)v14.i64 = *(double *)(a3 + 32) * 0.0174532925;
  double v25 = a4[3];
  *(double *)v15.i64 = a4[4] * 0.0174532925;
  double v26 = *(double *)(a5 + 24);
  double v27 = *(double *)(a5 + 32);
  v17.i64[0] = 0x400921FB54442D18LL;
  int8x16_t v85 = v17;
  if (fabs(*(double *)v14.i64) > 3.14159265)
  {
    v28.f64[0] = NAN;
    v28.f64[1] = NAN;
    int8x16_t v80 = vbslq_s8((int8x16_t)vnegq_f64(v28), v17, v14);
    int8x16_t v76 = v15;
    *(double *)v18.i64 = fmod(*(double *)v14.i64 + *(double *)v80.i64, 6.28318531);
    int8x16_t v15 = v76;
    v14.i64[1] = v80.i64[1];
    int8x16_t v17 = v85;
    *(double *)v14.i64 = *(double *)v18.i64 - *(double *)v80.i64;
  }

  *(double *)v16.i64 = v27 * 0.0174532925;
  int8x16_t v81 = v14;
  if (fabs(*(double *)v15.i64) > *(double *)v17.i64)
  {
    v29.f64[0] = NAN;
    v29.f64[1] = NAN;
    int8x16_t v77 = vbslq_s8((int8x16_t)vnegq_f64(v29), v17, v15);
    int8x16_t v73 = v16;
    *(double *)v18.i64 = fmod(*(double *)v15.i64 + *(double *)v77.i64, 6.28318531);
    int8x16_t v16 = v73;
    v14.i64[1] = v77.i64[1];
    int8x16_t v17 = v85;
    *(double *)v15.i64 = *(double *)v18.i64 - *(double *)v77.i64;
  }

  int8x16_t v78 = v15;
  if (fabs(*(double *)v16.i64) > *(double *)v17.i64)
  {
    v30.f64[0] = NAN;
    v30.f64[1] = NAN;
    int8x16_t v74 = vbslq_s8((int8x16_t)vnegq_f64(v30), v17, v16);
    *(double *)v18.i64 = fmod(*(double *)v16.i64 + *(double *)v74.i64, 6.28318531);
    v14.i64[1] = v74.i64[1];
    int8x16_t v15 = v78;
    int8x16_t v17 = v85;
    *(double *)v16.i64 = *(double *)v18.i64 - *(double *)v74.i64;
  }

  double v31 = *(double *)v81.i64;
  double v32 = fabs(*(double *)v16.i64);
  int8x16_t v75 = v16;
  if (vabdd_f64(*(double *)v81.i64, *(double *)v16.i64) > *(double *)v17.i64)
  {
    if (fabs(*(double *)v81.i64) > *(double *)v17.i64)
    {
      v33.f64[0] = NAN;
      v33.f64[1] = NAN;
      int8x16_t v66 = vbslq_s8((int8x16_t)vnegq_f64(v33), v17, v81);
      *(double *)v18.i64 = fmod(*(double *)v81.i64 + *(double *)v66.i64, 6.28318531);
      int8x16_t v16 = v75;
      int8x16_t v15 = v78;
      int8x16_t v17 = v85;
      v14.i64[1] = v66.i64[1];
      double v31 = *(double *)v18.i64 - *(double *)v66.i64;
    }

    v18.i64[0] = v16.i64[0];
    if (v32 > *(double *)v17.i64)
    {
      v34.f64[0] = NAN;
      v34.f64[1] = NAN;
      int8x16_t v67 = vbslq_s8((int8x16_t)vnegq_f64(v34), v17, v16);
      double v82 = v31;
      *(double *)v18.i64 = fmod(*(double *)v16.i64 + *(double *)v67.i64, 6.28318531);
      int8x16_t v16 = v75;
      int8x16_t v15 = v78;
      double v31 = v82;
      int8x16_t v17 = v85;
      v14.i64[1] = v67.i64[1];
      *(double *)v18.i64 = *(double *)v18.i64 - *(double *)v67.i64;
    }

    double v35 = v31 - *(double *)v18.i64;
    BOOL v36 = v31 - *(double *)v18.i64 > *(double *)v17.i64;
    BOOL v37 = vabdd_f64(v31, *(double *)v18.i64) <= *(double *)v17.i64;
    double v38 = -0.0;
    if (!v37) {
      double v38 = dbl_1013477A0[v36];
    }
    double v31 = *(double *)v16.i64 + v35 + v38;
  }

  double v39 = v68 * 0.0174532925;
  double v40 = v25 * 0.0174532925;
  double v41 = v26 * 0.0174532925;
  if (vabdd_f64(*(double *)v15.i64, *(double *)v16.i64) > *(double *)v17.i64)
  {
    double v83 = v31;
    if (fabs(*(double *)v15.i64) > *(double *)v17.i64)
    {
      v42.f64[0] = NAN;
      v42.f64[1] = NAN;
      int8x16_t v69 = vbslq_s8((int8x16_t)vnegq_f64(v42), v17, v15);
      *(double *)v18.i64 = fmod(*(double *)v15.i64 + *(double *)v69.i64, 6.28318531);
      int8x16_t v16 = v75;
      int8x16_t v17 = v85;
      v14.i64[1] = v69.i64[1];
      *(double *)v15.i64 = *(double *)v18.i64 - *(double *)v69.i64;
    }

    v18.i64[0] = v16.i64[0];
    if (v32 > *(double *)v17.i64)
    {
      v43.f64[0] = NAN;
      v43.f64[1] = NAN;
      int8x16_t v70 = vbslq_s8((int8x16_t)vnegq_f64(v43), v17, v16);
      uint64_t v79 = v15.i64[0];
      *(double *)v18.i64 = fmod(*(double *)v16.i64 + *(double *)v70.i64, 6.28318531);
      v16.i64[0] = v75.i64[0];
      v15.i64[0] = v79;
      int8x16_t v17 = v85;
      v14.i64[1] = v70.i64[1];
      *(double *)v18.i64 = *(double *)v18.i64 - *(double *)v70.i64;
    }

    double v44 = *(double *)v15.i64 - *(double *)v18.i64;
    double v45 = dbl_1013477A0[*(double *)v15.i64 - *(double *)v18.i64 > *(double *)v17.i64];
    BOOL v37 = vabdd_f64(*(double *)v15.i64, *(double *)v18.i64) <= *(double *)v17.i64;
    double v46 = -0.0;
    if (!v37) {
      double v46 = v45;
    }
    *(double *)v15.i64 = *(double *)v16.i64 + v44 + v46;
    double v31 = v83;
  }

  double v47 = v23 * *(double *)v15.i64;
  double v48 = v19 * v41;
  double v49 = v19 * *(double *)v16.i64;
  double v50 = v23 * v40 - v21 * v39;
  double v51 = v47 - v21 * v31;
  if (v23 <= v21)
  {
    double v50 = v21 * v39 - v23 * v40;
    double v51 = v21 * v31 - v47;
  }

  double v52 = v49 + v51;
  *(double *)v14.i64 = v71 * (v48 + v50);
  if (fabs(*(double *)v14.i64) > *(double *)v17.i64)
  {
    v53.f64[0] = NAN;
    v53.f64[1] = NAN;
    double v84 = *(double *)vbslq_s8((int8x16_t)vnegq_f64(v53), v17, v14).i64;
    *(double *)v14.i64 = fmod(*(double *)v14.i64 + v84, 6.28318531) - v84;
  }

  *(double *)v18.i64 = v71 * v52;
  if (*(double *)v14.i64 >= 1.57079633)
  {
    int8x16_t v54 = v85;
    *(double *)v14.i64 = *(double *)v85.i64 - *(double *)v14.i64;
  }

  else
  {
    int8x16_t v54 = v85;
  }

  *(double *)&__int128 v89 = *(double *)v14.i64 * 57.2957795;
  if (fabs(*(double *)v18.i64) > *(double *)v54.i64)
  {
    v55.f64[0] = NAN;
    v55.f64[1] = NAN;
    double v86 = *(double *)vbslq_s8((int8x16_t)vnegq_f64(v55), v54, v18).i64;
    *(double *)v18.i64 = fmod(*(double *)v18.i64 + v86, 6.28318531) - v86;
  }

  *((double *)&v89 + 1) = *(double *)v18.i64 * 57.2957795;
  if (a6 <= 2.0)
  {
    if (((*(uint64_t (**)(uint64_t))(*(void *)a3 + 32LL))(a3) & 1) == 0)
    {
    }
  }

  double v56 = *(double *)v90;
  *(double *)int v90 = v56;
  sub_100FBA824((uint64_t)&v87, (uint64_t)"FusedLoc,IDC Fusion a posteriori", *(_DWORD *)(a1 + 652));
  unint64_t v57 = *(void *)(*(void *)(a1 + 8) + 8 * ((*(void *)(a1 + 32) + a2) / 0x17uLL))
      + 176 * ((*(void *)(a1 + 32) + a2) % 0x17uLL);
  __int128 v58 = v88;
  __int128 v59 = v89;
  __int128 v60 = *(_OWORD *)v90;
  *(_OWORD *)(v57 + 88) = *(_OWORD *)&v90[16];
  *(_OWORD *)(v57 + 72) = v60;
  *(_OWORD *)(v57 + 56) = v59;
  *(_OWORD *)(v57 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v58;
  __int128 v61 = *(_OWORD *)v91;
  __int128 v62 = *(_OWORD *)&v91[16];
  __int128 v63 = *(_OWORD *)&v91[32];
  *(_OWORD *)(v57 + 148) = *(_OWORD *)&v91[44];
  *(_OWORD *)(v57 + 136) = v63;
  *(_OWORD *)(v57 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v62;
  *(_OWORD *)(v57 + 104) = v61;
  unint64_t v64 = *(void *)(*(void *)(a1 + 8) + 8 * ((*(void *)(a1 + 32) + a2) / 0x17uLL))
      + 176 * ((*(void *)(a1 + 32) + a2) % 0x17uLL);
  *(_WORD *)(v64 + 168) = 1;
  *(_OWORD *)unint64_t v64 = v88;
  return 1LL;
}

uint64_t sub_100E8FA20(uint64_t a1, double *a2)
{
  int v52 = 0;
  unint64_t v4 = *(void *)(a1 + 32) + *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = (void *)(v5 + 8 * (v4 / 0x17));
  if (v6 == v5) {
    unint64_t v8 = 0LL;
  }
  else {
    unint64_t v8 = *v7 + 176 * (v4 % 0x17);
  }
  while (1)
  {
    unint64_t v9 = v6 == v5
       ? 0LL
       : *(void *)(v5 + 8 * (*(void *)(a1 + 32) / 0x17uLL)) + 176 * (*(void *)(a1 + 32) % 0x17uLL);
    if (v8 == v9) {
      break;
    }
    uint64_t v10 = v8;
    if (v8 == *v7) {
      uint64_t v10 = *(v7 - 1) + 4048LL;
    }
    if (sub_100E8C200(v10 - 176, a2) > 5.0) {
      break;
    }
    uint64_t v11 = v8;
    if (v8 == *v7) {
      uint64_t v11 = *(v7 - 1) + 4048LL;
    }
    __int128 v12 = (char *)off_101936128;
    if (!off_101936128) {
      goto LABEL_32;
    }
    __int128 v13 = &off_101936128;
    int v14 = *(_DWORD *)(v11 - 16);
    int8x16_t v15 = (char *)off_101936128;
    do
    {
      int v16 = *((_DWORD *)v15 + 7);
      BOOL v17 = v16 < v14;
      if (v16 >= v14) {
        int8x16_t v18 = (char **)v15;
      }
      else {
        int8x16_t v18 = (char **)(v15 + 8);
      }
      if (!v17) {
        __int128 v13 = (_UNKNOWN **)v15;
      }
      int8x16_t v15 = *v18;
    }

    while (*v18);
    if (v13 == &off_101936128 || v14 < *((_DWORD *)v13 + 7)) {
      goto LABEL_32;
    }
    double v19 = &off_101936128;
    int v20 = *(_DWORD *)(a1 + 712);
    do
    {
      int v21 = *((_DWORD *)v12 + 7);
      BOOL v22 = v21 < v20;
      if (v21 >= v20) {
        double v23 = (char **)v12;
      }
      else {
        double v23 = (char **)(v12 + 8);
      }
      if (!v22) {
        double v19 = (_UNKNOWN **)v12;
      }
      __int128 v12 = *v23;
    }

    while (*v23);
    if (v19 == &off_101936128 || v20 < *((_DWORD *)v19 + 7))
    {
LABEL_32:
      if (qword_101934960 != -1) {
        dispatch_once(&qword_101934960, &stru_101889870);
      }
      double v24 = (os_log_s *)qword_101934968;
      if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_ERROR))
      {
        uint64_t v25 = v8;
        if (v8 == *v7) {
          uint64_t v25 = *(v7 - 1) + 4048LL;
        }
        double v26 = *a2;
        int v27 = *(_DWORD *)(a1 + 652);
        int v28 = *(_DWORD *)(v25 - 16);
        int v29 = *(_DWORD *)(a1 + 712);
        *(_DWORD *)__int128 buf = 134349824;
        *(double *)__int128 v60 = v26;
        *(_WORD *)&v60[8] = 1026;
        *(_DWORD *)__int128 v61 = v27;
        *(_WORD *)&v61[4] = 1026;
        int v62 = v28;
        __int16 v63 = 1026;
        int v64 = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "FusedLoc,Invalid provider type,time,%{public}.2lf,ID,%{public}d,locType,%{public}d,prominentType,%{public}d",  buf,  0x1Eu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934960 != -1) {
          dispatch_once(&qword_101934960, &stru_101889870);
        }
        double v34 = *a2;
        int v35 = *(_DWORD *)(a1 + 652);
        uint64_t v36 = v8;
        if (v8 == *v7) {
          uint64_t v36 = *(v7 - 1) + 4048LL;
        }
        int v37 = *(_DWORD *)(v36 - 16);
        int v38 = *(_DWORD *)(a1 + 712);
        int v53 = 134349824;
        *(double *)int8x16_t v54 = v34;
        *(_WORD *)&v54[8] = 1026;
        *(_DWORD *)float64x2_t v55 = v35;
        *(_WORD *)&v55[4] = 1026;
        int v56 = v37;
        __int16 v57 = 1026;
        int v58 = v38;
        LODWORD(v51) = 30;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  16LL,  "FusedLoc,Invalid provider type,time,%{public}.2lf,ID,%{public}d,locType,%{public}d,prominentType,%{public}d",  &v53,  v51);
        double v40 = (uint8_t *)v39;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CLLocationType cllcf::LCFusionLocationHypothesis::updateProminentProviderType(const CFTimeInterval &)",  "%s\n",  v39);
        if (v40 != buf) {
          free(v40);
        }
      }
    }

    else
    {
      uint64_t v31 = v8;
      if (v8 == *v7) {
        uint64_t v31 = *(v7 - 1) + 4048LL;
      }
      int v32 = *(_DWORD *)sub_100E90094((uint64_t)&unk_101936120, (int *)(v31 - 16));
      if (v32 <= *(_DWORD *)sub_100E90094((uint64_t)&unk_101936120, &v52))
      {
        uint64_t v33 = v8;
        if (v8 == *v7) {
          uint64_t v33 = *(v7 - 1) + 4048LL;
        }
        int v52 = *(_DWORD *)(v33 - 16);
      }
    }

    if (v8 == *v7)
    {
      uint64_t v30 = *--v7;
      unint64_t v8 = v30 + 4048;
    }

    v8 -= 176LL;
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(void *)(a1 + 16);
  }

  if (v52)
  {
    *(_DWORD *)(a1 + 712) = v52;
  }

  else
  {
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101889870);
    }
    double v41 = (os_log_s *)qword_101934968;
    if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_DEBUG))
    {
      int v42 = *(_DWORD *)(a1 + 652);
      unint64_t v43 = *(void *)(a1 + 40) + *(void *)(a1 + 32) - 1LL;
      LODWORD(v43) = *(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 8 * (v43 / 0x17)) + 176 * (v43 % 0x17) + 160);
      int v44 = *(_DWORD *)(a1 + 712);
      *(_DWORD *)__int128 buf = 67240704;
      *(_DWORD *)__int128 v60 = v42;
      *(_WORD *)&v60[4] = 1026;
      *(_DWORD *)&v60[6] = v43;
      *(_WORD *)__int128 v61 = 1026;
      *(_DWORD *)&v61[2] = v44;
      _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEBUG,  "FusedLoc,Unable to set a provider type for hypothesis ID,%{public}d,currentLocationType,%{public}d,previously se t type,%{public}d,will be used",  buf,  0x14u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934960 != -1) {
        dispatch_once(&qword_101934960, &stru_101889870);
      }
      int v46 = *(_DWORD *)(a1 + 652);
      unint64_t v47 = *(void *)(a1 + 40) + *(void *)(a1 + 32) - 1LL;
      LODWORD(v47) = *(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 8 * (v47 / 0x17)) + 176 * (v47 % 0x17) + 160);
      int v48 = *(_DWORD *)(a1 + 712);
      int v53 = 67240704;
      *(_DWORD *)int8x16_t v54 = v46;
      *(_WORD *)&v54[4] = 1026;
      *(_DWORD *)&v54[6] = v47;
      *(_WORD *)float64x2_t v55 = 1026;
      *(_DWORD *)&v55[2] = v48;
      LODWORD(v51) = 20;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  2LL,  "FusedLoc,Unable to set a provider type for hypothesis ID,%{public}d,currentLocationType,%{public}d,previously se t type,%{public}d,will be used",  &v53,  v51);
      double v50 = (uint8_t *)v49;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLLocationType cllcf::LCFusionLocationHypothesis::updateProminentProviderType(const CFTimeInterval &)",  "%s\n",  v49);
      if (v50 != buf) {
        free(v50);
      }
    }
  }

  return *(unsigned int *)(a1 + 712);
}

void sub_100E90084(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_100006BB8(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_100E90094(uint64_t a1, int *a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  if (!v2) {
LABEL_8:
  }
    sub_10000C918("map::at:  key not found");
  int v3 = *a2;
  while (1)
  {
    while (1)
    {
      int v4 = *((_DWORD *)v2 + 7);
      if (v3 >= v4) {
        break;
      }
      uint64_t v2 = (uint64_t *)*v2;
      if (!v2) {
        goto LABEL_8;
      }
    }

    if (v4 >= v3) {
      return v2 + 4;
    }
    uint64_t v2 = (uint64_t *)v2[1];
    if (!v2) {
      goto LABEL_8;
    }
  }

void sub_100E900E8(uint64_t a1, double a2)
{
  if (a2 >= 0.0)
  {
    *(double *)(a1 + 632) = a2;
    *(double *)(a1 + 64sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = log(a2);
  }

  else
  {
    if (qword_101934960 != -1) {
      dispatch_once(&qword_101934960, &stru_101889870);
    }
    uint64_t v2 = (os_log_s *)qword_101934968;
    if (os_log_type_enabled((os_log_t)qword_101934968, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "#selection Invalid likelihood passed to set likelihood",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934960 != -1) {
        dispatch_once(&qword_101934960, &stru_101889870);
      }
      v5[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934968,  16LL,  "#selection Invalid likelihood passed to set likelihood",  v5,  2);
      int v4 = (uint8_t *)v3;
      sub_10029211C("Generic", 1LL, 0, 0LL, "void cllcf::LCFusionLocationHypothesis::setLikelihood(double)", "%s\n", v3);
      if (v4 != buf) {
        free(v4);
      }
    }
  }

void sub_100E90284(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

void sub_100E90290(id a1)
{
  qword_101934968 = (uint64_t)os_log_create("com.apple.locationd.Position", "LCFusion");
}

void sub_100E902BC(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x17;
  unint64_t v4 = v2 - 23;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      double v34 = (char *)sub_1000071BC(v5, v33);
      int v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      int v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        double v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)double v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100E90584( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100E905D0(void **a1)
{
  unint64_t v2 = a1[1];
  BOOL v3 = a1[2];
  unint64_t v4 = (v3 - v2) >> 3;
  if (v3 == v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = 23 * v4 - 1;
  }
  uint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x17)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    unint64_t v8 = a1[3];
    unint64_t v9 = *a1;
    uint64_t v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      unint64_t v46 = a1 + 3;
      __int128 __p = sub_1000071BC(v7, v11);
      unint64_t v43 = (char *)__p;
      int v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      double v41 = operator new(0xFD0uLL);
      sub_1000ECB90(&__p, &v41);
      uint64_t v13 = (char *)a1[1];
      BOOL v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }

      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1LL;
              }
              else {
                unint64_t v23 = (v14 - (_BYTE *)__p) >> 2;
              }
              uint64_t v24 = (char *)sub_1000071BC((uint64_t)v46, v23);
              uint64_t v26 = v43;
              BOOL v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                BOOL v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v28 = 8 * (v27 >> 3);
                int v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)int v29 = v30;
                  v29 += 8;
                  v28 -= 8LL;
                }

                while (v28);
              }

              __int128 v31 = __p;
              __int128 __p = v24;
              unint64_t v43 = &v24[8 * (v23 >> 2)];
              int v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                BOOL v14 = v44;
              }
            }

            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              int64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                BOOL v14 = v43;
              }

              unint64_t v22 = &v14[-8 * (v19 >> 1)];
              BOOL v14 = &v20[v21];
              unint64_t v43 = v22;
              int v44 = &v20[v21];
            }
          }

          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)BOOL v14 = v32;
          BOOL v14 = v44 + 8;
          v44 += 8;
        }

        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }

      uint64_t v36 = *a1;
      int v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      __int128 __p = v36;
      unint64_t v43 = v33;
      int v38 = (char *)a1[3];
      uint64_t v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      int v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 11LL;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 23;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        int v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v36) {
        operator delete(v36);
      }
    }

    else
    {
      if (v2 == v9)
      {
        __int128 __p = operator new(0xFD0uLL);
        sub_1000EC960(a1, &__p);
        double v34 = a1[2];
        __int128 __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }

      else
      {
        __int128 __p = operator new(0xFD0uLL);
      }

      sub_1000ECA74((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8) {
        uint64_t v35 = 11LL;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 23;
      }
      a1[4] = (void *)v35;
    }
  }

  else
  {
    a1[4] = v6 + 23;
    __int128 __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1000ECA74((uint64_t)a1, &__p);
  }

void sub_100E9089C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t *sub_100E908E8( uint64_t a1, void *a2, unint64_t a3, void *a4, uint64_t a5, uint64_t *a6, uint64_t a7, unint64_t *a8)
{
  int64_t v20 = a2;
  unint64_t v21 = a3;
  if (a3 != a5)
  {
    uint64_t v10 = 0x2E8BA2E8BA2E8BA3LL * ((a5 - *a4) >> 4) + 23 * (a4 - a2) - 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(a3 - *a2) >> 4);
    if (v10 >= 1)
    {
      do
      {
        uint64_t v12 = v21;
        uint64_t v13 = *v20 + 4048LL;
        uint64_t v14 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(v13 - v21) >> 4);
        if (v14 >= v10) {
          uint64_t v15 = v10;
        }
        else {
          uint64_t v15 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(v13 - v21) >> 4);
        }
        if (v14 <= v10) {
          unint64_t v16 = *v20 + 4048LL;
        }
        else {
          unint64_t v16 = v21 + 176 * v10;
        }
        unint64_t v17 = *a8;
        if (v21 <= *a8 && v17 < v16)
        {
          if (v21 == a7) {
            uint64_t v18 = 0LL;
          }
          else {
            uint64_t v18 = 0xD1745D1745D1745DLL * ((uint64_t)(v21 - *v20) >> 4)
          }
                - 23 * (v20 - a6)
                + 0x2E8BA2E8BA2E8BA3LL * ((a7 - *a6) >> 4);
          unint64_t v22 = v20;
          unint64_t v23 = (uint64_t *)v17;
          *a8 = sub_1005A83FC(&v22, v18)[1];
        }

        sub_100E90C28(v12, v16, a6, a7, (uint64_t *)&v22);
        a6 = v23;
        a7 = v24;
        v10 -= v15;
        sub_1005A83FC(&v20, v15);
      }

      while (v10 > 0);
    }
  }

  return a6;
}

void *sub_100E90A68( uint64_t a1, void *a2, uint64_t a3, unint64_t *a4, unint64_t a5, void *a6, uint64_t a7, unint64_t *a8)
{
  unint64_t v21 = a4;
  unint64_t v22 = a5;
  if (a5 != a3)
  {
    uint64_t v10 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(a5 - *a4) >> 4) + 23 * (a4 - a2) - 0x2E8BA2E8BA2E8BA3LL * ((a3 - *a2) >> 4);
    if (v10 >= 1)
    {
      do
      {
        uint64_t v12 = v21;
        unint64_t v13 = v22;
        if (v22 == *v21)
        {
          --v21;
          unint64_t v13 = *--v12 + 4048;
        }

        unint64_t v14 = v13 - 176;
        unint64_t v22 = v13 - 176;
        uint64_t v15 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(v13 - *v12) >> 4);
        if (v15 >= v10) {
          uint64_t v16 = v10;
        }
        else {
          uint64_t v16 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(v13 - *v12) >> 4);
        }
        if (v15 <= v10) {
          unint64_t v17 = *v12;
        }
        else {
          unint64_t v17 = v13 - 176 * v10;
        }
        unint64_t v18 = *a8;
        if (*a8 < v13 && v17 <= v18)
        {
          if (v14 == a7) {
            uint64_t v19 = 0LL;
          }
          else {
            uint64_t v19 = 23 * (a6 - v12)
          }
          unint64_t v23 = v12;
          uint64_t v24 = (void *)v18;
          *a8 = sub_1005A83FC(&v23, v19 - 1)[1];
        }

        sub_100E90DE0(v17, v13, a6, a7, (uint64_t *)&v23);
        a6 = v24;
        a7 = v25;
        v10 -= v16;
        sub_1005A83FC(&v21, 1 - v16);
      }

      while (v10 > 0);
    }
  }

  return a6;
}

uint64_t sub_100E90C28@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t *a3@<X3>, uint64_t a4@<X4>, uint64_t *a5@<X8>)
{
  uint64_t v5 = a3;
  uint64_t result = a1;
  if (a1 == a2)
  {
    uint64_t v8 = a1;
  }

  else
  {
    uint64_t v8 = a2;
    uint64_t v5 = a3 + 1;
    uint64_t v9 = *a3;
    while (1)
    {
      uint64_t v10 = 0x2E8BA2E8BA2E8BA3LL * ((v9 - a4 + 4048) >> 4);
      if (0x2E8BA2E8BA2E8BA3LL * ((v8 - result) >> 4) < v10) {
        uint64_t v10 = 0x2E8BA2E8BA2E8BA3LL * ((v8 - result) >> 4);
      }
      uint64_t result = sub_100E90CF8(result, result + 176 * v10, a4);
      if (result == v8) {
        break;
      }
      uint64_t v12 = *v5++;
      uint64_t v9 = v12;
      a4 = v12;
    }

    a4 = v11;
    if (*(v5 - 1) + 4048 == v11) {
      a4 = *v5;
    }
    else {
      --v5;
    }
  }

  *a5 = v8;
  a5[1] = (uint64_t)v5;
  a5[2] = a4;
  return result;
}

uint64_t sub_100E90CF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      sub_100E90D54(a3, v4);
      v4 += 176LL;
      a3 += 176LL;
    }

    while (v4 != a2);
    return a2;
  }

  return v4;
}

uint64_t sub_100E90D54(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(void *)(a2 + 16) = 0LL;
  *(void *)(a2 + 24) = 0LL;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 24);
  *(_OWORD *)(a1 + 16) = v4;
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
  __int128 v6 = *(_OWORD *)(a2 + 40);
  __int128 v7 = *(_OWORD *)(a2 + 56);
  __int128 v8 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v8;
  *(_OWORD *)(a1 + 56) = v7;
  *(_OWORD *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v6;
  __int128 v9 = *(_OWORD *)(a2 + 104);
  __int128 v10 = *(_OWORD *)(a2 + 120);
  __int128 v11 = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 148) = *(_OWORD *)(a2 + 148);
  *(_OWORD *)(a1 + 136) = v11;
  *(_OWORD *)(a1 + 12sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v10;
  *(_OWORD *)(a1 + 104) = v9;
  *(_WORD *)(a1 + 168) = *(_WORD *)(a2 + 168);
  return a1;
}

uint64_t sub_100E90DE0@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, void *a3@<X3>, uint64_t a4@<X4>, uint64_t *a5@<X8>)
{
  uint64_t v5 = a3;
  if (a1 == a2)
  {
    uint64_t v8 = a1;
  }

  else
  {
    uint64_t v8 = a2;
    uint64_t v9 = *a3;
    for (uint64_t i = a2; ; uint64_t i = v12)
    {
      uint64_t v11 = 0x2E8BA2E8BA2E8BA3LL * ((a4 - v9) >> 4);
      if (0x2E8BA2E8BA2E8BA3LL * ((i - a1) >> 4) < v11) {
        uint64_t v11 = 0x2E8BA2E8BA2E8BA3LL * ((i - a1) >> 4);
      }
      uint64_t v12 = i - 176 * v11;
      uint64_t result = sub_100E90EB8(v12, i, a4);
      if (v12 == a1) {
        break;
      }
      uint64_t v15 = *--v5;
      uint64_t v9 = v15;
      a4 = v15 + 4048;
    }

    a4 = v14;
    if (*v5 + 4048LL == v14)
    {
      uint64_t v16 = v5[1];
      ++v5;
      a4 = v16;
    }
  }

  *a5 = v8;
  a5[1] = (uint64_t)v5;
  a5[2] = a4;
  return result;
}

uint64_t sub_100E90EB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a1)
  {
    uint64_t v6 = a2;
    do
    {
      v6 -= 176LL;
      a3 -= 176LL;
      sub_100E90D54(a3, v6);
    }

    while (v6 != a1);
  }

  return a2;
}

void sub_100E90F14()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_101936138);
  if ((v0 & 1) == 0)
  {
    if (__cxa_guard_acquire(&qword_101936138))
    {
      uint64_t v2 = 0x7FFFFFFF00000000LL;
      v1[2] = xmmword_1013633D0;
      v1[3] = unk_1013633E0;
      v1[4] = xmmword_1013633F0;
      v1[0] = xmmword_1013633B0;
      v1[1] = unk_1013633C0;
      sub_1001BB3C4((uint64_t)&unk_101936120, (int *)v1, 11LL);
      __cxa_atexit((void (*)(void *))sub_1001BA444, &unk_101936120, (void *)&_mh_execute_header);
      __cxa_guard_release(&qword_101936138);
    }
  }

void sub_100E90FE8(_Unwind_Exception *a1)
{
}

void sub_100E91474(id a1)
{
  qword_10199EE88 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLBTLEFenceManagerSilo");
}

uint64_t sub_100E91528(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100E91B80;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_10199EEB0 != -1) {
    dispatch_once(&qword_10199EEB0, block);
  }
  return qword_10199EEA8;
}

void sub_100E916C8(id a1)
{
  if ((sub_1004F64FC() & 0x100000) != 0) {
    byte_10199EE98 = 1;
  }
}

void sub_100E91774(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E917E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E9184C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E918CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E91960( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E91A1C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100E91A38(uint64_t a1, void *a2)
{
  uint64_t result = (void *)sub_100E91A64(a1, "CLBTLEFenceManager-Notifier", a2);
  *uint64_t result = off_1018898E0;
  return result;
}

uint64_t sub_100E91A64(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_101889AA8;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = [a3 silo];
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 108) = 0;
  return a1;
}

void sub_100E91AE4(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100E91B04(uint64_t a1)
{
  *(void *)a1 = off_101889AA8;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100589F4C(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

uint64_t sub_100E91B80(uint64_t a1)
{
  uint64_t v2 = operator new(0x178uLL);
  uint64_t result = sub_100520CDC((uint64_t)v2, *(void **)(a1 + 32));
  qword_10199EEA8 = (uint64_t)v2;
  return result;
}

void sub_100E91BB8(_Unwind_Exception *a1)
{
}

void *sub_100E91BCC@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

void sub_100E91C44(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x30uLL);
  sub_1010DDBC0(__p, "CLBTLEFenceManager");
  sub_100E91D0C((uint64_t)v8, 0LL, (uint64_t *)__p, a3, a1, a2);
  void *v8 = off_101889A00;
  *a4 = v8;
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100E91CE0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_100E91D0C(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = off_101889B88;
  *(void *)(a1 + 8) = -[CLNotifierClientAdapter initWithClient:]( objc_alloc(&OBJC_CLASS___CLNotifierClientAdapter),  "initWithClient:",  a1);
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  else {
    uint64_t v12 = (uint64_t *)*a3;
  }
  id v13 = objc_msgSend( objc_msgSend(a4, "vendor"),  "proxyForService:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
  *(void *)(a1 + 16) = v13;
  id v14 = v13;
  if (a2) {
    [*(id *)(a1 + 16) setDelegateEntityName:a2];
  }
  objc_msgSend(*(id *)(a1 + 16), "registerDelegate:inSilo:", *(void *)(a1 + 8), objc_msgSend(a4, "silo"));
  return a1;
}

void sub_100E91DE4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E91E70(a1);
  operator delete(v1);
}

id sub_100E91DF8(uint64_t a1, int a2, void *a3)
{
  id result = sub_100528AEC(a3);
  if (result)
  {
    int v6 = a2;
    return (id)(*(uint64_t (**)(void, int *, id, void))(a1 + 24))(0LL, &v6, result, *(void *)(a1 + 32));
  }

  return result;
}

void sub_100E91E44(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

uint64_t sub_100E91E70(uint64_t a1)
{
  *(void *)a1 = off_101889B88;
  uint64_t v2 = (id *)(a1 + 8);
  [*(id *)(a1 + 16) forget:*(void *)(a1 + 8)];

  [*v2 invalidate];
  *uint64_t v2 = 0LL;
  *(void *)(a1 + 16) = 0LL;
  return a1;
}

uint64_t sub_100E91ED0(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t result = sub_100C6AAF0(a1, a2, a3, a4, a5);
  *(void *)uint64_t result = off_101889BB0;
  *(_BYTE *)(result + 41) = 0;
  *(_DWORD *)(result + 44) = -1;
  *(_BYTE *)(result + 48) = 0;
  return result;
}

uint64_t sub_100E91F00(uint64_t a1)
{
  *(void *)a1 = off_101889BB0;
  if (*(_BYTE *)(a1 + 41) && sub_100A290E4())
  {
    if (qword_1019344A0 != -1) {
      dispatch_once(&qword_1019344A0, &stru_101889C00);
    }
    uint64_t v2 = (os_log_s *)qword_1019344A8;
    if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 24);
      int v4 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)__int128 buf = 138478083;
      uint64_t v16 = v3;
      __int16 v17 = 1026;
      int v18 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Service client is going away: %{private}@, clientType, %{public}d. Unregistering for suppression.",  buf,  0x12u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344A0 != -1) {
        dispatch_once(&qword_1019344A0, &stru_101889C00);
      }
      uint64_t v7 = *(void *)(a1 + 24);
      int v8 = *(_DWORD *)(a1 + 44);
      int v11 = 138478083;
      uint64_t v12 = v7;
      __int16 v13 = 1026;
      int v14 = v8;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  0LL,  "Service client is going away: %{private}@, clientType, %{public}d. Unregistering for suppression.",  &v11,  18);
      char v10 = (uint8_t *)v9;
      sub_10029211C("Generic", 1LL, 0, 2LL, "virtual CLEclipseSubscription::~CLEclipseSubscription()", "%s\n", v9);
      if (v10 != buf) {
        free(v10);
      }
    }

    uint64_t v5 = sub_100A290E4();
    sub_100A2963C(v5, 0, *(_DWORD *)(a1 + 44), *(_BYTE *)(a1 + 48));
  }

  sub_100C6AB50(a1);
  return a1;
}

void sub_100E9210C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

void sub_100E9211C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E91F00(a1);
  operator delete(v1);
}

void *sub_100E92130@<X0>(uint64_t a1@<X8>)
{
  v11[0] = &off_101889C30;
  v11[1] = sub_100E92398;
  _DWORD v11[2] = 0LL;
  uint64_t v12 = v11;
  sub_1010DDBC0(v13, "kCLConnectionMessageEclipseServiceRequest");
  sub_10089E6B8((uint64_t)&v14, (uint64_t)v11);
  v9[0] = &off_101889C30;
  v9[1] = sub_100E92C40;
  _OWORD v9[2] = 0LL;
  char v10 = v9;
  sub_1010DDBC0(v15, "kCLConnectionMessageEclipseViewObstructedStateRequest");
  sub_10089E6B8((uint64_t)v16, (uint64_t)v9);
  sub_100E93324(a1, (unsigned __int8 *)v13, 2LL);
  for (uint64_t i = 0LL; i != -14; i -= 7LL)
  {
    uint64_t v3 = *(_BYTE **)&v16[i * 8 + 24];
    if (&v16[i * 8] == v3)
    {
      uint64_t v3 = &v16[i * 8];
      uint64_t v4 = 4LL;
    }

    else
    {
      if (!v3) {
        goto LABEL_7;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
LABEL_7:
    if (SHIBYTE(v15[i + 2]) < 0) {
      operator delete((void *)v15[i]);
    }
  }

  uint64_t v5 = v10;
  if (v10 == v9)
  {
    uint64_t v6 = 4LL;
    uint64_t v5 = v9;
LABEL_14:
    (*(void (**)(void))(*v5 + 8 * v6))();
  }

  else if (v10)
  {
    uint64_t v6 = 5LL;
    goto LABEL_14;
  }

  uint64_t result = v12;
  if (v12 == v11)
  {
    uint64_t v8 = 4LL;
    uint64_t result = v11;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  else if (v12)
  {
    uint64_t v8 = 5LL;
    return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
  }

  return result;
}

void sub_100E922C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  for (uint64_t i = 56LL; i != -56; i -= 56LL)
    sub_10026E430(v17 + i);
  int64_t v20 = a13;
  if (a13 == &a10)
  {
    uint64_t v21 = 4LL;
    int64_t v20 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_8;
    }
    uint64_t v21 = 5LL;
  }

  (*(void (**)(void))(*(void *)v20 + 8 * v21))();
LABEL_8:
  unint64_t v22 = a17;
  if (a17 == &a14)
  {
    uint64_t v23 = 4LL;
    unint64_t v22 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_13;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void))(*(void *)v22 + 8 * v23))();
LABEL_13:
  _Unwind_Resume(a1);
}

void sub_100E92398(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  sub_100C6AC8C(a1);
  sub_1010DDBC0(buf, "com.apple.locationd.asmanager");
  char v5 = sub_100C6AC9C(a1);
  char v6 = v5;
  if (SHIBYTE(v51) < 0)
  {
    operator delete(*(void **)buf);
    if ((v6 & 1) != 0) {
      goto LABEL_3;
    }
  }

  else if ((v5 & 1) != 0)
  {
LABEL_3:
    Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
    uint64_t v8 = CMEclipseServiceEnable;
    if ([Dictionary objectForKey:CMEclipseServiceEnable]
      && (id v9 = [Dictionary objectForKeyedSubscript:v8]) != 0)
    {
      if (sub_100A290E4())
      {
        unsigned int v10 = [v9 BOOLValue];
        if ([Dictionary objectForKey:CMViewObstructedStateEnable])
        {
          if (qword_1019344A0 != -1) {
            dispatch_once(&qword_1019344A0, &stru_101889C00);
          }
          int v11 = (os_log_s *)qword_1019344A8;
          if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)__int128 buf = 67240192;
            *(_DWORD *)&uint8_t buf[4] = v10;
            _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "Incoming view obstructed service request: %{public}d",  buf,  8u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344A0 != -1) {
              dispatch_once(&qword_1019344A0, &stru_101889C00);
            }
            int v39 = 67240192;
            *(_DWORD *)uint64_t v40 = v10;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  1LL,  "Incoming view obstructed service request: %{public}d",  &v39,  8);
            uint64_t v30 = (char *)v29;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEclipseSubscription::handleMessageEclipseServiceRequest(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v29);
            if (v30 != buf) {
              free(v30);
            }
          }
        }

        if ([Dictionary objectForKey:v8])
        {
          uint64_t v12 = CMSuppressionManagerClientType;
          if ([Dictionary objectForKey:CMSuppressionManagerClientType]) {
            *(_DWORD *)(a1 + 44) = objc_msgSend( objc_msgSend(Dictionary, "objectForKeyedSubscript:", v12),  "intValue");
          }
          uint64_t v13 = CMSuppressionManagerAlwaysOnViewObstructedRequested;
          if ([Dictionary objectForKey:CMSuppressionManagerAlwaysOnViewObstructedRequested]) {
            *(_BYTE *)(a1 + 48) = objc_msgSend( objc_msgSend(Dictionary, "objectForKeyedSubscript:", v13),  "BOOLValue");
          }
          if (qword_1019344A0 != -1) {
            dispatch_once(&qword_1019344A0, &stru_101889C00);
          }
          uint64_t v14 = (os_log_s *)qword_1019344A8;
          if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_INFO))
          {
            uint64_t v15 = *(void *)(a1 + 24);
            int v16 = *(_DWORD *)(a1 + 44);
            int v17 = *(unsigned __int8 *)(a1 + 48);
            *(_DWORD *)__int128 buf = 67240963;
            *(_DWORD *)&uint8_t buf[4] = v10;
            *(_WORD *)&uint8_t buf[8] = 2113;
            *(void *)&buf[10] = v15;
            __int16 v50 = 1026;
            int v51 = v16;
            __int16 v52 = 1026;
            int v53 = v17;
            _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "Incoming eclipse service request: %{public}d, client: %{private}@, clientType: %{public}d, alwaysOnViewObs tructed: %{public}d",  buf,  0x1Eu);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019344A0 != -1) {
              dispatch_once(&qword_1019344A0, &stru_101889C00);
            }
            uint64_t v31 = *(void *)(a1 + 24);
            int v32 = *(_DWORD *)(a1 + 44);
            int v33 = *(unsigned __int8 *)(a1 + 48);
            int v39 = 67240963;
            *(_DWORD *)uint64_t v40 = v10;
            *(_WORD *)&v40[4] = 2113;
            *(void *)&v40[6] = v31;
            __int16 v41 = 1026;
            int v42 = v32;
            __int16 v43 = 1026;
            int v44 = v33;
            LODWORD(v36) = 30;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  1LL,  "Incoming eclipse service request: %{public}d, client: %{private}@, clientType: %{public}d, alwaysOnViewObs tructed: %{public}d",  &v39,  v36);
            uint64_t v35 = (char *)v34;
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEclipseSubscription::handleMessageEclipseServiceRequest(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v34);
            if (v35 != buf) {
              free(v35);
            }
          }

          *(_BYTE *)(a1 + 41) = v10;
          uint64_t v18 = sub_100A290E4();
          else {
            uint64_t v19 = 108LL;
          }
          uint64_t v37 = CMErrorMessage;
          int v38 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v19);
          *(void *)__int128 buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v38,  &v37,  1LL);
          sub_100E930B0(a1, buf);
        }

        sub_100C6AC8C(a1);
        goto LABEL_40;
      }

      uint64_t v23 = *a2;
      uint64_t v45 = CMErrorMessage;
      unint64_t v46 = &off_1018D47C0;
      +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v46,  &v45,  1LL);
      CLConnectionMessage::sendReply(v23);
    }

    else
    {
      if (qword_1019344A0 != -1) {
        dispatch_once(&qword_1019344A0, &stru_101889C00);
      }
      unint64_t v22 = (os_log_s *)qword_1019344A8;
      if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_FAULT, "Invalid parameters!", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344A0 != -1) {
          dispatch_once(&qword_1019344A0, &stru_101889C00);
        }
        LOWORD(v39) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  17LL,  "Invalid parameters!",  &v39,  2);
        uint64_t v28 = (char *)v27;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEclipseSubscription::handleMessageEclipseServiceRequest(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v27);
        if (v28 != buf) {
          free(v28);
        }
      }
    }

    sub_100C6AC8C(a1);
    goto LABEL_40;
  }

  if (qword_1019344A0 != -1) {
    dispatch_once(&qword_1019344A0, &stru_101889C00);
  }
  int64_t v20 = (os_log_s *)qword_1019344A8;
  if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_ERROR))
  {
    uint64_t v21 = *(void *)(a1 + 24);
    *(_DWORD *)__int128 buf = 138477827;
    *(void *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Client %{private}@ is not entitled.", buf, 0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344A0 != -1) {
      dispatch_once(&qword_1019344A0, &stru_101889C00);
    }
    uint64_t v24 = *(void *)(a1 + 24);
    int v39 = 138477827;
    *(void *)uint64_t v40 = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  16LL,  "Client %{private}@ is not entitled.",  &v39,  12);
    uint64_t v26 = (char *)v25;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEclipseSubscription::handleMessageEclipseServiceRequest(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  uint64_t v47 = CMErrorMessage;
  int v48 = &off_1018D47A8;
  *(void *)__int128 buf = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v48,  &v47,  1LL);
  sub_100E930B0(a1, buf);
LABEL_40:
}

void sub_100E92BD4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
  _Unwind_Resume(a1);
}

void sub_100E92C40(uint64_t a1, CLConnectionMessage **a2)
{
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSAutoreleasePool);
  sub_100C6AC8C(a1);
  Dictionary = (void *)CLConnectionMessage::getDictionary(*a2);
  uint64_t v6 = CMViewObstructedStateEnable;
  if ([Dictionary objectForKey:CMViewObstructedStateEnable]
    && (id v7 = [Dictionary objectForKeyedSubscript:v6]) != 0)
  {
    unsigned int v8 = [v7 BOOLValue];
    if ([Dictionary objectForKey:v6])
    {
      if (qword_1019344A0 != -1) {
        dispatch_once(&qword_1019344A0, &stru_101889C00);
      }
      id v9 = (os_log_s *)qword_1019344A8;
      if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 67240192;
        unsigned int v24 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "Incoming view obstructed service request: %{public}d",  buf,  8u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344A0 != -1) {
          dispatch_once(&qword_1019344A0, &stru_101889C00);
        }
        v22[0] = 67240192;
        v22[1] = v8;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  1LL,  "Incoming view obstructed service request: %{public}d",  v22,  8);
        int v17 = (uint8_t *)v16;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLEclipseSubscription::handleMessageViewObstructedDebugRequest(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v16);
        if (v17 != buf) {
          free(v17);
        }
      }
    }

    if (sub_100A290E4())
    {
      if ([Dictionary objectForKey:v6])
      {
        uint64_t v10 = sub_100A290E4();
        if ((sub_100A2A080(v10, v8) & 1) == 0)
        {
          int v11 = *a2;
          uint64_t v18 = CMErrorMessage;
          uint64_t v19 = +[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", 108LL);
          +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v19,  &v18,  1LL);
          CLConnectionMessage::sendReply(v11);
        }
      }

      sub_100C6AC8C(a1);
    }

    else
    {
      uint64_t v13 = *a2;
      uint64_t v20 = CMErrorMessage;
      uint64_t v21 = &off_1018D47C0;
      +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v21,  &v20,  1LL);
      CLConnectionMessage::sendReply(v13);
    }
  }

  else
  {
    if (qword_1019344A0 != -1) {
      dispatch_once(&qword_1019344A0, &stru_101889C00);
    }
    uint64_t v12 = (os_log_s *)qword_1019344A8;
    if (os_log_type_enabled((os_log_t)qword_1019344A8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "Invalid parameters!", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344A0 != -1) {
        dispatch_once(&qword_1019344A0, &stru_101889C00);
      }
      LOWORD(v22[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344A8,  17LL,  "Invalid parameters!",  v22,  2);
      uint64_t v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLEclipseSubscription::handleMessageViewObstructedDebugRequest(std::shared_ptr<CLConnectionMessage>)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }
  }
}

void sub_100E93070(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_100E930B0(uint64_t a1, void *a2)
{
  uint64_t v3 = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

void sub_100E93144(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100E93158(id a1)
{
  qword_1019344A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Eclipse");
}

__n128 sub_100E93184(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_101889C30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 sub_100E931C0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_101889C30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void sub_100E931E4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

uint64_t sub_100E931EC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100E93228()
{
}

void sub_100E93234(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *a3;
  uint64_t v3 = (std::__shared_weak_count *)a3[1];
  uint64_t v15 = v3;
  *a3 = 0LL;
  a3[1] = 0LL;
  unint64_t v5 = *(void (**)(void *, uint64_t *))a1;
  uint64_t v6 = *(void *)(a1 + 8);
  id v7 = (void *)(a2 + (v6 >> 1));
  if ((v6 & 1) != 0) {
    unint64_t v5 = *(void (**)(void *, uint64_t *))(*v7 + v5);
  }
  uint64_t v16 = v4;
  int v17 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }

  v5(v7, &v16);
  uint64_t v10 = v17;
  if (v17)
  {
    int v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (v15)
  {
    uint64_t v13 = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }

void sub_100E93308( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_100E93324(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    uint64_t v5 = 56 * a3;
    do
    {
      sub_100E9339C(a1, a2, (__int128 *)a2);
      a2 += 56;
      v5 -= 56LL;
    }

    while (v5);
  }

  return a1;
}

void sub_100E93388(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_100E9339C(uint64_t a1, unsigned __int8 *a2, __int128 *a3)
{
  id v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    uint64_t v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_100E9361C(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  unint64_t v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    void *v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_100272D04((uint64_t)v25, 0LL);
  return i;
}

void sub_100E93604(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100E9361C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  void *v8 = 0LL;
  v8[1] = a2;
  __n128 result = sub_100E93690(v8 + 2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_100E93678(_Unwind_Exception *a1)
{
}

void *sub_100E93690(void *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }

  sub_10001A504((uint64_t)(__dst + 3), (uint64_t)a2 + 24);
  return __dst;
}

void sub_100E936E8(_Unwind_Exception *exception_object)
{
}

void sub_100E93704()
{
  if (sub_100231608())
  {
    unsigned __int8 v0 = operator new(0x68uLL);
    sub_100E61F40((uint64_t)v0, (uint64_t)"CLAccessoryAccelerometer", 2, 32, 115);
    *unsigned __int8 v0 = &off_101889CE8;
    qword_1019A3D80 = (uint64_t)v0;
  }

void sub_100E9375C(_Unwind_Exception *a1)
{
}

uint64_t sub_100E93770()
{
  if (qword_10199EEB8 != -1) {
    dispatch_once(&qword_10199EEB8, &stru_101889CB8);
  }
  return qword_1019A3D80;
}

void sub_100E937B8(void *a1)
{
  uint64_t v1 = sub_100E61F94(a1);
  operator delete(v1);
}

double sub_100E937CC(uint64_t a1, int a2, double *a3)
{
  if (a2)
  {
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889D40);
    }
    __int128 v4 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 67240192;
      LODWORD(v19) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "[AccessoryAccelerometer] Unrecognized update interval notification %{public}d",  buf,  8u);
    }

    double v5 = 0.0;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101889D40);
      }
      int v16 = 67240192;
      LODWORD(v17) = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  17LL,  "[AccessoryAccelerometer] Unrecognized update interval notification %{public}d",  &v16,  8);
      uint64_t v7 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CFTimeInterval CLAccessoryAccelerometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

  else
  {
    sub_100E62108(a1);
    if (*a3 > 0.0)
    {
      (*(void (**)(double))(**(void **)(a1 + 32) + 16LL))(*a3);
      (*(void (**)(void))(**(void **)(a1 + 32) + 16LL))();
      *(_BYTE *)(a1 + 3sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
    }

    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889D40);
    }
    unint64_t v10 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_INFO))
    {
      uint64_t v11 = *(void *)a3;
      *(_DWORD *)__int128 buf = 134349056;
      uint64_t v19 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "[AccessoryAccelerometer] Setting update interval to %{public}f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101889D40);
      }
      uint64_t v13 = *(void *)a3;
      int v16 = 134349056;
      uint64_t v17 = v13;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  1LL,  "[AccessoryAccelerometer] Setting update interval to %{public}f",  &v16,  12);
      unint64_t v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CFTimeInterval CLAccessoryAccelerometer::minimumUpdateIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    sub_10071A73C(*(void *)(a1 + 32), *a3);
    return *a3;
  }

  return v5;
}

double sub_100E93B78(uint64_t a1, int a2, double *a3)
{
  if (a2)
  {
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889D40);
    }
    __int128 v4 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 67240192;
      LODWORD(v19) = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "[AccessoryAccelerometer] Unrecognized batch interval notification %{public}d",  buf,  8u);
    }

    double v5 = 0.0;
    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101889D40);
      }
      int v16 = 67240192;
      LODWORD(v17) = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  17LL,  "[AccessoryAccelerometer] Unrecognized batch interval notification %{public}d",  &v16,  8);
      uint64_t v7 = (uint8_t *)v6;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual CFTimeInterval CLAccessoryAccelerometer::minimumBatchIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v6);
      if (v7 != buf) {
        free(v7);
      }
    }
  }

  else
  {
    sub_100E62108(a1);
    if (qword_1019345C0 != -1) {
      dispatch_once(&qword_1019345C0, &stru_101889D40);
    }
    unint64_t v10 = (os_log_s *)qword_1019345C8;
    if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_INFO))
    {
      double v11 = *a3;
      *(_DWORD *)__int128 buf = 134349056;
      double v19 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "[AccessoryAccelerometer] Setting batch interval to %{public}f",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101889D40);
      }
      uint64_t v13 = *(void *)a3;
      int v16 = 134349056;
      uint64_t v17 = v13;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  1LL,  "[AccessoryAccelerometer] Setting batch interval to %{public}f",  &v16,  12);
      unint64_t v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CFTimeInterval CLAccessoryAccelerometer::minimumBatchIntervalChanged(int, const CFTimeInterval &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    sub_10071A7C0(*(void *)(a1 + 32), *a3);
    return *a3;
  }

  return v5;
}

void sub_100E93EA0(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 30))
  {
    *(_BYTE *)(a1 + 3sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 1;
    int v28 = 0;
    sub_1010DDBC0(v29, "N/A");
    sub_1010DDBC0(v31, "N/A");
    memset(v33, 0, 93);
    if (sub_100E62278(a1, (uint64_t)&v28))
    {
      memset(v21, 0, 44);
      unint64_t v3 = (__IOHIDServiceClient *)sub_100719C6C(*(void *)(a1 + 32));
      if (sub_100FAD980(v21, v3, @"ARSC", (id)0x2C))
      {
        uint64_t v4 = 0LL;
        double v5 = &v33[4];
        do
        {
          snprintf(v5, 0x2CuLL, "%02x", *((unsigned __int8 *)v21 + v4++));
          v5 += 2;
        }

        while (v4 != 44);
      }

      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101889D40);
      }
      uint64_t v6 = (os_log_s *)qword_1019345C8;
      if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_DEBUG))
      {
        if (v30 >= 0) {
          uint64_t v7 = v29;
        }
        else {
          uint64_t v7 = (void **)v29[0];
        }
        if (v32 >= 0) {
          unint64_t v8 = v31;
        }
        else {
          unint64_t v8 = (void **)v31[0];
        }
        *(_DWORD *)__int128 buf = 67240707;
        int v23 = v28;
        __int16 v24 = 2081;
        uint64_t v25 = v7;
        __int16 v26 = 2081;
        uint64_t v27 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "[AccessoryAccelerometer] config,side,%{public}d,configuration,%{private}s,serialNumber,%{private}s",  buf,  0x1Cu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345C0 != -1) {
          dispatch_once(&qword_1019345C0, &stru_101889D40);
        }
        if (v30 >= 0) {
          unint64_t v12 = v29;
        }
        else {
          unint64_t v12 = (void **)v29[0];
        }
        if (v32 >= 0) {
          uint64_t v13 = v31;
        }
        else {
          uint64_t v13 = (void **)v31[0];
        }
        v16[0] = 67240707;
        v16[1] = v28;
        __int16 v17 = 2081;
        BOOL v18 = v12;
        __int16 v19 = 2081;
        unint64_t v20 = v13;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  2LL,  "[AccessoryAccelerometer] config,side,%{public}d,configuration,%{private}s,serialNumber,%{private}s",  v16,  28);
        unint64_t v15 = (uint8_t *)v14;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLAccessoryAccelerometer::onAccelerometerData(const Sample &)",  "%s\n",  v14);
        if (v15 != buf) {
          free(v15);
        }
      }

      sub_1006DD528(a1, 1LL, (uint64_t)&v28, 152LL);
    }

    else
    {
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101889D40);
      }
      unint64_t v9 = (os_log_s *)qword_1019345C8;
      if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "[AccessoryAccelerometer] Service not found!",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345C0 != -1) {
          dispatch_once(&qword_1019345C0, &stru_101889D40);
        }
        LOWORD(v21[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  17LL,  "[AccessoryAccelerometer] Service not found!",  v21,  2);
        double v11 = (uint8_t *)v10;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLAccessoryAccelerometer::onAccelerometerData(const Sample &)",  "%s\n",  v10);
        if (v11 != buf) {
          free(v11);
        }
      }
    }

    if (v32 < 0) {
      operator delete(v31[0]);
    }
    if (v30 < 0) {
      operator delete(v29[0]);
    }
  }

void sub_100E9432C(_Unwind_Exception *a1)
{
}

void sub_100E9436C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (IOHIDEventGetType(a4) == 13)
  {
    if (IOHIDEventGetIntegerValue(a4, 851971LL) == 1)
    {
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101889D40);
      }
      uint64_t v6 = (os_log_s *)qword_1019345C8;
      if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "[AccessoryAccelerometer] Received shake data, discarding.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345C0 != -1) {
          dispatch_once(&qword_1019345C0, &stru_101889D40);
        }
        LOWORD(v25[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  2LL,  "[AccessoryAccelerometer] Received shake data, discarding.",  v25,  2);
        unint64_t v8 = (uint8_t *)v7;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLAccessoryAccelerometer::onEventData(void *, void *, IOHIDEventRef)",  "%s\n",  v7);
        if (v8 != buf) {
          free(v8);
        }
      }
    }

    else
    {
      float FloatValue = IOHIDEventGetFloatValue(a4, 851968LL);
      float v20 = FloatValue;
      float v10 = IOHIDEventGetFloatValue(a4, 851969LL);
      float v21 = v10;
      float v11 = IOHIDEventGetFloatValue(a4, 851970LL);
      float v22 = v11;
      unint64_t TimeStamp = IOHIDEventGetTimeStamp(a4);
      double v13 = sub_101171C7C(TimeStamp);
      double v19 = v13;
      unsigned __int16 IntegerValue = IOHIDEventGetIntegerValue(a4, 851973LL);
      unsigned __int16 v24 = IntegerValue;
      uint64_t v15 = sub_100FACB74();
      uint64_t v23 = v15;
      if (qword_1019345C0 != -1) {
        dispatch_once(&qword_1019345C0, &stru_101889D40);
      }
      int v16 = (os_log_s *)qword_1019345C8;
      if (os_log_type_enabled((os_log_t)qword_1019345C8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 67241472;
        int v37 = IntegerValue;
        __int16 v38 = 2050;
        double v39 = FloatValue;
        __int16 v40 = 2050;
        double v41 = v10;
        __int16 v42 = 2050;
        double v43 = v11;
        __int16 v44 = 2050;
        uint64_t v45 = v15;
        __int16 v46 = 2050;
        double v47 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "[AccessoryAccelerometer] seq,%{public}d,x,%{public}20.20f,y,%{public}20.20f,z,%{public}20.20f,sensorTime,%{pub lic}llu,timestamp,%{public}20.20f",  buf,  0x3Au);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019345C0 != -1) {
          dispatch_once(&qword_1019345C0, &stru_101889D40);
        }
        v25[0] = 67241472;
        v25[1] = IntegerValue;
        __int16 v26 = 2050;
        double v27 = FloatValue;
        __int16 v28 = 2050;
        double v29 = v10;
        __int16 v30 = 2050;
        double v31 = v11;
        __int16 v32 = 2050;
        uint64_t v33 = v15;
        __int16 v34 = 2050;
        double v35 = v13;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019345C8,  2LL,  "[AccessoryAccelerometer] seq,%{public}d,x,%{public}20.20f,y,%{public}20.20f,z,%{public}20.20f,sensorTime,%{pub lic}llu,timestamp,%{public}20.20f",  v25,  58);
        BOOL v18 = (uint8_t *)v17;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLAccessoryAccelerometer::onEventData(void *, void *, IOHIDEventRef)",  "%s\n",  v17);
        if (v18 != buf) {
          free(v18);
        }
      }

      sub_100E93EA0(a1, (uint64_t)&v19);
    }
  }

void sub_100E9478C(id a1)
{
  qword_1019345C8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Accessory");
}

uint64_t sub_100E947B8(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  double v5 = sub_10101B9AC((void *)a1, a2);
  *double v5 = off_101889D70;
  *(_OWORD *)(v5 + 11) = 0u;
  *(_OWORD *)(v5 + 13) = 0u;
  *(_OWORD *)(v5 + 15) = 0u;
  *(void *)(a1 + 144) = 0x4334000042820000LL;
  *(void *)(a1 + 152) = 0xFFEFFFFFFFFFFFFFLL;
  *(_DWORD *)(a1 + 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0LL;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0LL;
  *(_DWORD *)(a1 + 20sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  *(void *)(a1 + 208) = 0LL;
  *(void *)(a1 + 136) = 0x7FF8000000000000LL;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 68) = 0u;
  sub_1000F2F30(v5 + 15, a3);
  return a1;
}

uint64_t sub_100E94850()
{
  return 1LL;
}

uint64_t sub_100E94858(uint64_t a1, __int128 *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  double v5 = *(std::__shared_weak_count **)(a1 + 16);
  __int16 v17 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v4 + 16LL))(&v18, v4, a1);
  sub_1000F2F30((void *)(a1 + 88), &v18);
  unint64_t v8 = v19;
  if (v19)
  {
    unint64_t v9 = (unint64_t *)&v19->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  if (v17)
  {
    float v11 = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  __int128 v13 = *a2;
  __int128 v14 = a2[1];
  __int128 v15 = a2[2];
  *(_OWORD *)(a1 + 68) = *(__int128 *)((char *)a2 + 44);
  *(_OWORD *)(a1 + 56) = v15;
  *(_OWORD *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v14;
  *(_OWORD *)(a1 + 24) = v13;
  return 1LL;
}

void sub_100E9495C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100E94970(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1) {
    sub_100AE5528(v1);
  }
  return 1LL;
}

double sub_100E94990(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a3 + 4);
  else {
    double v4 = (double)v3;
  }
  if (*(_BYTE *)(a3 + 58) && *(_BYTE *)(a3 + 57) && *(_BYTE *)(a3 + 56) && (float v6 = *(float *)(a3 + 8), v6 > 1.0))
  {
    double v8 = (float)(*(float *)(a3 + 12) / (float)(v6 * v6));
    if (*(_BYTE *)(a2 + 16)) {
      double v9 = (float)((float)(*(float *)(a3 + 20) * 0.001) + 5.34)
    }
         + v8 * 0.00800000038
         + v4 * 0.850000024
         + (float)(*(float *)(a2 + 8) * 0.107)
         + (float)(*(float *)a2 * -9.33)
    else {
      double v9 = NAN;
    }
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_101889DD0);
    }
    unint64_t v12 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
    {
      double v13 = *(float *)(a3 + 20);
      double v14 = *(float *)(a3 + 12);
      int v15 = *(_DWORD *)(a3 + 4);
      double v16 = *(float *)(a2 + 8);
      double v17 = *(float *)a2;
      double v18 = *(float *)(a2 + 4);
      double v19 = *(float *)(a2 + 12);
      int v20 = *(unsigned __int8 *)(a2 + 16);
      *(_DWORD *)__int128 buf = 134220544;
      double v57 = v13;
      __int16 v58 = 2048;
      double v59 = v14;
      __int16 v60 = 2048;
      double v61 = v8;
      __int16 v62 = 1024;
      int v63 = v15;
      __int16 v64 = 2048;
      double v65 = v16;
      __int16 v66 = 2048;
      double v67 = v17;
      __int16 v68 = 2048;
      double v69 = v18;
      __int16 v70 = 2048;
      double v71 = v19;
      __int16 v72 = 2048;
      double v73 = v9;
      __int16 v74 = 1024;
      int v75 = v20;
      __int16 v76 = 2048;
      double v77 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "age,%f,weight,%f,bmi,%f,biologicalSex,%d,maxMets,%f,oneMinusFhr,%f,cyclingPowerMets,%f,efficiency,%f,estimatedVo 2max,%f,shouldEstimate,%d,biologicalSexCoefficient,%f",  buf,  0x68u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_101889DD0);
      }
      double v21 = *(float *)(a3 + 20);
      double v22 = *(float *)(a3 + 12);
      int v23 = *(_DWORD *)(a3 + 4);
      double v24 = *(float *)(a2 + 8);
      double v25 = *(float *)a2;
      double v26 = *(float *)(a2 + 4);
      double v27 = *(float *)(a2 + 12);
      int v28 = *(unsigned __int8 *)(a2 + 16);
      int v34 = 134220544;
      double v35 = v21;
      __int16 v36 = 2048;
      double v37 = v22;
      __int16 v38 = 2048;
      double v39 = v8;
      __int16 v40 = 1024;
      int v41 = v23;
      __int16 v42 = 2048;
      double v43 = v24;
      __int16 v44 = 2048;
      double v45 = v25;
      __int16 v46 = 2048;
      double v47 = v26;
      __int16 v48 = 2048;
      double v49 = v27;
      __int16 v50 = 2048;
      double v51 = v9;
      __int16 v52 = 1024;
      int v53 = v28;
      __int16 v54 = 2048;
      double v55 = v4;
      LODWORD(v33) = 104;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "age,%f,weight,%f,bmi,%f,biologicalSex,%d,maxMets,%f,oneMinusFhr,%f,cyclingPowerMets,%f,efficiency,%f,estimatedVo 2max,%f,shouldEstimate,%d,biologicalSexCoefficient,%f",  COERCE_DOUBLE(&v34),  v33);
      __int16 v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "double CLCyclingVO2MaxModel::estimateCyclingVO2Max(CLCyclingVO2MaxModel::ModelInputs, CLBodyMetrics) const",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }
  }

  else
  {
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_101889DD0);
    }
    unint64_t v10 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "Not estimating Cycling VO2Max as User height, weight or age not set",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_101889DD0);
      }
      LOWORD(v34) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  1LL,  "Not estimating Cycling VO2Max as User height, weight or age not set",  &v34,  2);
      __int16 v32 = (uint8_t *)v31;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "double CLCyclingVO2MaxModel::estimateCyclingVO2Max(CLCyclingVO2MaxModel::ModelInputs, CLBodyMetrics) const",  "%s\n",  v31);
      if (v32 != buf) {
        free(v32);
      }
    }

    return NAN;
  }

  return v9;
}

float sub_100E94E8C(double a1, uint64_t a2, void *a3)
{
  if (a1 > 0.0)
  {
    __int128 __p = 0LL;
    int v20 = 0LL;
    uint64_t v21 = 0LL;
    float v3 = 4.5841;
    if (!*a3) {
      goto LABEL_17;
    }
    int v4 = (*(uint64_t (**)(void, void **, double))(*(void *)*a3 + 8LL))(*a3, &__p, a1 + -2419200.0);
    if (v4 != 100)
    {
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_101889DD0);
      }
      double v16 = (os_log_s *)qword_1019347A8;
      if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__int128 buf = 67109120;
        LODWORD(v27) = v4;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "Maxmets DB inaccesible %d", buf, 8u);
      }

      float v3 = 4.5841;
      if (!sub_1002921D0(115, 0)) {
        goto LABEL_31;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019347A0 != -1) {
        dispatch_once(&qword_1019347A0, &stru_101889DD0);
      }
      int v22 = 67109120;
      LODWORD(v23) = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  17LL,  "Maxmets DB inaccesible %d",  &v22);
      int v15 = (uint8_t *)v18;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "float CLCyclingVO2MaxModel::getMeanMaxMets(std::shared_ptr<CLMaxMetsRecorderForCycling>, CFAbsoluteTime)",  "%s\n",  v18);
      goto LABEL_37;
    }

    double v5 = (double *)__p;
    if (__p == v20)
    {
LABEL_17:
      LODWORD(v9) = 0;
    }

    else
    {
      uint64_t v6 = 0LL;
      float v7 = 0.0;
      do
      {
        float v8 = v5[3];
        float v7 = v7 + v8;
        v5 += 4;
        --v6;
      }

      while (v5 != v20);
      uint64_t v9 = -v6;
      float v3 = v7 / (float)(unint64_t)-v6;
    }

    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_101889DD0);
    }
    double v13 = (os_log_s *)qword_1019347A8;
    if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134218240;
      double v27 = v3;
      __int16 v28 = 1024;
      int v29 = v9;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "meanMaxMets,%f,numOfRecords,%d", buf, 0x12u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_31;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_101889DD0);
    }
    int v22 = 134218240;
    double v23 = v3;
    __int16 v24 = 1024;
    int v25 = v9;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "meanMaxMets,%f,numOfRecords,%d",  COERCE_DOUBLE(&v22),  18);
    int v15 = (uint8_t *)v14;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "float CLCyclingVO2MaxModel::getMeanMaxMets(std::shared_ptr<CLMaxMetsRecorderForCycling>, CFAbsoluteTime)",  "%s\n",  v14);
LABEL_37:
    if (v15 != buf) {
      free(v15);
    }
LABEL_31:
    if (__p)
    {
      int v20 = __p;
      operator delete(__p);
    }

    return v3;
  }

  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_101889DD0);
  }
  unint64_t v10 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "Maxmets DB query time range is invalid (queryEndTime <= 0)",  buf,  2u);
  }

  float v3 = 4.5841;
  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_101889DD0);
    }
    LOWORD(__p) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  17LL,  "Maxmets DB query time range is invalid (queryEndTime <= 0)",  &__p,  2);
    unint64_t v12 = (uint8_t *)v11;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "float CLCyclingVO2MaxModel::getMeanMaxMets(std::shared_ptr<CLMaxMetsRecorderForCycling>, CFAbsoluteTime)",  "%s\n",  v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  return v3;
}

void sub_100E95370( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E953A0(uint64_t a1)
{
  *(_DWORD *)(a1 + 16sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0LL;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0LL;
  *(_DWORD *)(a1 + 20sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0;
  *(void *)(a1 + 208) = 0LL;
  return 1LL;
}

uint64_t sub_100E953C4(uint64_t a1, uint64_t a2)
{
  *(float32x2_t *)(a1 + 144) = vcvt_f32_f64(*(float64x2_t *)(a2 + 64));
  float v3 = *(uint64_t **)(a2 + 48);
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  if (*v3 == v5)
  {
    int v7 = 0;
  }

  else
  {
    int v7 = 0;
    double v8 = *(double *)(v4 + 8);
    ++*(_DWORD *)(a1 + 160);
    *(double *)(a1 + 152) = v8;
    do
    {
      if (sub_100F291A8(*(void *)(a2 + 32)) && *(double *)(v4 + 8) - v8 < 2700.0)
      {
        if (*(_BYTE *)(a1 + 82))
        {
          ++v7;
          double v9 = sub_100F290B8(*(float *)(v4 + 32), *(float *)(a1 + 36));
          float v10 = *(float *)(v4 + 32);
          if (v10 > 0.0 && v10 <= 1500.0)
          {
            float v11 = v9;
            if (v11 > 3.0 && v11 < 20.0)
            {
              float v12 = *(float *)(v4 + 16);
              if (v12 > 0.0 && *(float *)(v4 + 20) > 0.39)
              {
                float v13 = (*(float *)(a1 + 148) - v12) / (*(float *)(a1 + 148) - *(float *)(a1 + 144));
                float v14 = 1.0 - v13;
                if (v14 > 0.4 && v14 < 1.2 && (float)(v11 / v14) < 20.0)
                {
                  *(float *)(a1 + 168) = *(float *)(a1 + 168) + v11;
                  ++*(void *)(a1 + 176);
                  *(float *)(a1 + 184) = v14 + *(float *)(a1 + 184);
                  ++*(void *)(a1 + 192);
                  *(float *)(a1 + 20sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = (float)(v11 / v14) + *(float *)(a1 + 200);
                  ++*(void *)(a1 + 208);
                }
              }
            }
          }
        }
      }

      v4 += 64LL;
    }

    while (v4 != v5);
  }

  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_101889DD0);
  }
  int v15 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = (uint64_t)(*(void *)(*(void *)(a2 + 48) + 8LL) - **(void **)(a2 + 48)) >> 6;
    *(_DWORD *)__int128 buf = 134218240;
    uint64_t v26 = v16;
    __int16 v27 = 1024;
    int v28 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "CLCyclingVO2MaxModel::processSession, out of %zu samples, %d samples are eligible for processing.",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_101889DD0);
    }
    uint64_t v18 = (uint64_t)(*(void *)(*(void *)(a2 + 48) + 8LL) - **(void **)(a2 + 48)) >> 6;
    int v21 = 134218240;
    uint64_t v22 = v18;
    __int16 v23 = 1024;
    int v24 = v7;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "CLCyclingVO2MaxModel::processSession, out of %zu samples, %d samples are eligible for processing.",  (size_t)&v21,  18);
    int v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLCyclingVO2MaxModel::processSession(const CLCyclingFTPHistory::Session &)",  "%s\n",  v19);
    if (v20 != buf) {
      free(v20);
    }
  }

  return 1LL;
}

void sub_100E95754(uint64_t a1, _OWORD *a2, void *a3)
{
  uint64_t v5 = (std::__shared_weak_count *)a3[1];
  v33[0] = *a3;
  v33[1] = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  float v8 = sub_100E94E8C(*(double *)(a1 + 152), a1, v33);
  if (v5)
  {
    double v9 = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  BOOL v11 = *(void *)(a1 + 176) >= 0x65uLL && *(void *)(a1 + 192) >= 0x65uLL && *(void *)(a1 + 208) > 0x64uLL;
  if (qword_1019347A0 != -1) {
    dispatch_once(&qword_1019347A0, &stru_101889DD0);
  }
  float v12 = (os_log_s *)qword_1019347A8;
  if (os_log_type_enabled((os_log_t)qword_1019347A8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = *(void *)(a1 + 176);
    uint64_t v14 = *(void *)(a1 + 192);
    uint64_t v15 = *(void *)(a1 + 208);
    *(_DWORD *)__int128 buf = 134218752;
    uint64_t v43 = v13;
    __int16 v44 = 2048;
    uint64_t v45 = v14;
    __int16 v46 = 2048;
    uint64_t v47 = v15;
    __int16 v48 = 1024;
    int v49 = 100;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "fCyclingPowerMetsMean.numberOfSamples, %zu, fOneMinusFhrMean.numberOfSamples, %zu, fEfficiencyMean.numberOfSamples , %zu, minimum required number of valid samples to estimate Vo2max, %d",  buf,  0x26u);
  }

  uint64_t v16 = sub_1002921D0(115, 2);
  if ((_DWORD)v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019347A0 != -1) {
      dispatch_once(&qword_1019347A0, &stru_101889DD0);
    }
    uint64_t v24 = *(void *)(a1 + 176);
    uint64_t v25 = *(void *)(a1 + 192);
    uint64_t v26 = *(void *)(a1 + 208);
    int v34 = 134218752;
    uint64_t v35 = v24;
    __int16 v36 = 2048;
    uint64_t v37 = v25;
    __int16 v38 = 2048;
    uint64_t v39 = v26;
    __int16 v40 = 1024;
    int v41 = 100;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019347A8,  0LL,  "fCyclingPowerMetsMean.numberOfSamples, %zu, fOneMinusFhrMean.numberOfSamples, %zu, fEfficiencyMean.numberOfSamples , %zu, minimum required number of valid samples to estimate Vo2max, %d",  (size_t)&v34,  38,  *(size_t *)&v29[0],  DWORD2(v29[0]));
    int v28 = (uint8_t *)v27;
    uint64_t v16 = sub_10029211C( "Generic",  1LL,  0,  2LL,  "const double CLCyclingVO2MaxModel::getVO2MaxEstimate(CLBodyMetrics, std::shared_ptr<CLMaxMetsRecorderForCycling>)",  "%s\n",  v27);
    if (v28 != buf) {
      free(v28);
    }
  }

  unint64_t v17 = *(void *)(a1 + 192);
  float v18 = 0.0;
  float v19 = 0.0;
  if (v17) {
    float v19 = *(float *)(a1 + 184) / (float)v17;
  }
  unint64_t v20 = *(void *)(a1 + 176);
  if (v20) {
    float v18 = *(float *)(a1 + 168) / (float)v20;
  }
  unint64_t v21 = *(void *)(a1 + 208);
  if (v21) {
    float v22 = *(float *)(a1 + 200) / (float)v21;
  }
  else {
    float v22 = 0.0;
  }
  *(float *)double v31 = v19;
  *(float *)&v31[1] = v18;
  *(float *)&v31[2] = v8;
  *(float *)&v31[3] = v22;
  BOOL v32 = v11;
  __int128 v23 = a2[1];
  v29[0] = *a2;
  v29[1] = v23;
  *(_OWORD *)__int16 v30 = a2[2];
  *(_OWORD *)&v30[12] = *(_OWORD *)((char *)a2 + 44);
  sub_100E94990(v16, (uint64_t)v31, (uint64_t)v29);
}

void sub_100E95A80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t sub_100E95A9C(uint64_t a1)
{
  __int128 v2 = *(_OWORD *)(a1 + 40);
  v11[0] = *(_OWORD *)(a1 + 24);
  v11[1] = v2;
  v12[0] = *(_OWORD *)(a1 + 56);
  *(_OWORD *)((char *)v12 + 12) = *(_OWORD *)(a1 + 68);
  float v3 = *(std::__shared_weak_count **)(a1 + 128);
  v10[0] = *(void *)(a1 + 120);
  v10[1] = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  sub_100E95754(a1, v11, v10);
  *(void *)(a1 + 136) = v6;
  if (v3)
  {
    unint64_t v7 = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  return 1LL;
}

void sub_100E95B48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double sub_100E95B5C(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 208);
  if (v1) {
    return (float)(*(float *)(a1 + 200) / (float)v1);
  }
  else {
    return 0.0;
  }
}

double sub_100E95B80(uint64_t a1)
{
  return *(double *)(a1 + 136);
}

uint64_t sub_100E95B88(uint64_t a1)
{
  return *(unsigned int *)(a1 + 160);
}

void sub_100E95B94(void *a1)
{
  unint64_t v1 = sub_100E95BD4(a1);
  operator delete(v1);
}

void sub_100E95BA8(id a1)
{
  qword_1019347A8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "CyclingPower");
}

void *sub_100E95BD4(void *a1)
{
  *a1 = off_101889D70;
  uint64_t v2 = (uint64_t)(a1 + 11);
  sub_10000AE14((uint64_t)(a1 + 15));
  sub_10000AE14((uint64_t)(a1 + 13));
  sub_10000AE14(v2);
  *a1 = off_101868780;
  sub_10000AE14((uint64_t)(a1 + 1));
  return a1;
}

void sub_100E95CD8(id a1)
{
  qword_10199EEC0 = -[CLDispatchSilo initWithIdentifier:]( objc_alloc(&OBJC_CLASS___CLDispatchSilo),  "initWithIdentifier:",  @"CLSpringTrackingNotifierSilo");
}

uint64_t sub_100E95D8C(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100E96D48;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_10199EEE0 != -1) {
    dispatch_once(&qword_10199EEE0, block);
  }
  return qword_1019A3D88;
}

uint64_t sub_100E95F20(uint64_t a1)
{
  if (!+[CMActivityAlarmLocal activityAlarmAvailable](&OBJC_CLASS___CMActivityAlarmLocal, "activityAlarmAvailable")) {
    return 109LL;
  }
  uint64_t v2 = *(void **)(a1 + 208);
  if (v2)
  {
    [v2 invalidate];

    *(void *)(a1 + 208) = 0LL;
  }

  float v3 = objc_alloc(&OBJC_CLASS___CMActivityAlarmLocal);
  double v4 = *(double *)(a1 + 192);
  id v5 = [*(id *)(a1 + 40) queue];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  _OWORD v12[2] = sub_100E971D8;
  uint64_t v12[3] = &unk_10182FA08;
  _DWORD v12[4] = a1;
  *(void *)(a1 + 208) = -[CMActivityAlarmLocal initWithTrigger:duration:onQueue:withHandler:]( v3,  "initWithTrigger:duration:onQueue:withHandler:",  14LL,  v5,  v12,  v4);
  if (qword_101934820 != -1) {
    dispatch_once(&qword_101934820, &stru_101889F80);
  }
  uint64_t v6 = (os_log_s *)qword_101934828;
  if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_INFO))
  {
    uint64_t v7 = *(void *)(a1 + 192);
    *(_DWORD *)__int128 buf = 134217984;
    uint64_t v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Started tracking,duration,%.3f", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934820 != -1) {
      dispatch_once(&qword_101934820, &stru_101889F80);
    }
    uint64_t v9 = *(void *)(a1 + 192);
    int v13 = 134217984;
    uint64_t v14 = v9;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934828,  1LL,  "Started tracking,duration,%.3f",  COERCE_DOUBLE(&v13));
    BOOL v11 = (uint8_t *)v10;
    sub_10029211C("Generic", 1LL, 0, 2LL, "CMError CLSpringTrackingNotifier::startTracking()", "%s\n", v10);
    if (v11 != buf) {
      free(v11);
    }
  }

  return 100LL;
}

uint64_t sub_100E9618C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 208);
  if (v2)
  {
    [v2 invalidate];

    *(void *)(a1 + 208) = 0LL;
  }

  if (qword_101934820 != -1) {
    dispatch_once(&qword_101934820, &stru_101889F80);
  }
  float v3 = (os_log_s *)qword_101934828;
  if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Stopped tracking", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934820 != -1) {
      dispatch_once(&qword_101934820, &stru_101889F80);
    }
    v7[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934828,  1LL,  "Stopped tracking",  v7,  2);
    uint64_t v6 = (uint8_t *)v5;
    sub_10029211C("Generic", 1LL, 0, 2LL, "CMError CLSpringTrackingNotifier::stopTracking()", "%s\n", v5);
    if (v6 != buf) {
      free(v6);
    }
  }

  return 100LL;
}

void sub_100E96458( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E96480@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)a3 = 0LL;
  *(void *)(a3 + 8) = 0LL;
  *(void *)(a3 + 16) = 0LL;
  return sub_100E9B658(*(uint64_t **)(a1 + 120), a2, (void **)a3);
}

void sub_100E964B0(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_100E9650C(id a1)
{
}

uint64_t sub_100E96534(uint64_t a1, void *a2)
{
  uint64_t v3 = sub_100E967AC(a1, "CLSpringTrackingNotifier", a2);
  *(void *)uint64_t v3 = off_101889E40;
  *(void *)(a1 + 112) = [*(id *)(v3 + 40) newTimer];
  double v4 = operator new(0x178uLL);
  sub_100E9B074(v4, 0LL);
  sub_100E98E74((void *)(a1 + 120), (uint64_t)v4);
  id v5 = *(std::__shared_weak_count **)(a1 + 128);
  uint64_t v17 = *(void *)(a1 + 120);
  float v18 = v5;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }

  sub_1001B4E14(a1 + 136, &v17);
  unint64_t v8 = v18;
  if (v18)
  {
    uint64_t v9 = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  uint64_t v19 = 0x4014000000000000LL;
  sub_101204164((unsigned __int8 *)(a1 + 184), "SpringTrackerWakeHysteresis", &v19, 0);
  *(void *)(a1 + 208) = 0LL;
  *(void *)(a1 + 216) = 0LL;
  sub_100E96848((void **)(a1 + 136), 604800.0);
  [*(id *)(a1 + 112) setNextFireDelay:3600.0 interval:3600.0];
  uint64_t v19 = (uint64_t)_NSConcreteStackBlock;
  uint64_t v20 = 3221225472LL;
  unint64_t v21 = sub_100E96ED8;
  float v22 = &unk_10181D3D0;
  uint64_t v23 = a1;
  [*(id *)(a1 + 112) setHandler:&v19];
  uint64_t v11 = *(void *)(a1 + 120);
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v19 = (uint64_t)_NSConcreteStackBlock;
  uint64_t v20 = 3221225472LL;
  unint64_t v21 = sub_100E96F64;
  float v22 = &unk_101889F10;
  uint64_t v23 = a1;
  sub_100E9BED8(v11, v12, &v19);
  sub_100ACD980((uint64_t)sub_100E96AFC, a1, *(void **)(a1 + 32), &v19);
  uint64_t v13 = v19;
  uint64_t v19 = 0LL;
  uint64_t v14 = *(void *)(a1 + 216);
  *(void *)(a1 + 216) = v13;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
    uint64_t v15 = v19;
    uint64_t v19 = 0LL;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
  }

  [*(id *)(*(void *)(a1 + 216) + 16) register:*(void *)(*(void *)(a1 + 216) + 8) forNotification:0 registrationInfo:0];
  return a1;
}

void sub_100E96738(_Unwind_Exception *a1)
{
  uint64_t v5 = *(void *)(v1 + 216);
  *(void *)(v1 + 216) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  sub_1001B4FBC(v3);
  sub_10000AE14(v2);
  sub_100E96CD4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100E967AC(uint64_t a1, char *a2, void *a3)
{
  *(void *)a1 = off_101889FB0;
  sub_1010DDBC0((void *)(a1 + 8), a2);
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = [a3 silo];
  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a1 + 88;
  *(_DWORD *)(a1 + 104) = 0;
  *(_BYTE *)(a1 + 108) = 0;
  return a1;
}

void sub_100E9682C(_Unwind_Exception *exception_object)
{
}

void sub_100E96848(void **a1, double a2)
{
  if (a2 >= 0.0)
  {
    uint64_t v9 = a1[2];
    uint64_t v7 = (uint64_t)(a1 + 2);
    unint64_t v8 = v9;
    unint64_t v10 = *(void *)(v7 - 8);
    if (v10 >= (unint64_t)v9)
    {
      unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - (void)*a1) >> 3);
      unint64_t v13 = v12 + 1;
      if (v12 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100007008();
      }
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v8 - (_BYTE *)*a1) >> 3);
      if (2 * v14 > v13) {
        unint64_t v13 = 2 * v14;
      }
      if (v14 >= 0x555555555555555LL) {
        unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v15) {
        uint64_t v16 = (char *)sub_10000701C(v7, v15);
      }
      else {
        uint64_t v16 = 0LL;
      }
      uint64_t v17 = &v16[24 * v12];
      float v18 = &v16[24 * v15];
      *(double *)uint64_t v17 = a2;
      *((void *)v17 + 1) = 0x7FEFFFFFFFFFFFFFLL;
      v17[16] = 0;
      uint64_t v11 = v17 + 24;
      uint64_t v20 = (char *)*a1;
      uint64_t v19 = (char *)a1[1];
      if (v19 != *a1)
      {
        do
        {
          __int128 v21 = *(_OWORD *)(v19 - 24);
          *(v17 - 8) = *(v19 - 8);
          *(_OWORD *)(v17 - 24) = v21;
          v17 -= 24;
          v19 -= 24;
        }

        while (v19 != v20);
        uint64_t v19 = (char *)*a1;
      }

      *a1 = v17;
      a1[1] = v11;
      a1[2] = v18;
      if (v19) {
        operator delete(v19);
      }
    }

    else
    {
      *(double *)unint64_t v10 = a2;
      *(void *)(v10 + 8) = 0x7FEFFFFFFFFFFFFFLL;
      *(_BYTE *)(v10 + 16) = 0;
      uint64_t v11 = (char *)(v10 + 24);
    }

    a1[1] = v11;
  }

  else
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10188A118);
    }
    uint64_t v3 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 134349056;
      double v25 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "Programmer error, this expiration rule with time %{public}fis not valid.",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10188A118);
      }
      int v22 = 134349056;
      double v23 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  17LL,  "Programmer error, this expiration rule with time %{public}fis not valid.",  &v22,  12);
      uint64_t v5 = (uint8_t *)v4;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLActivityAggregator<CLSpringTrackerEntry>::setExpirationRule(CFTimeInterval) [T = CLSpringTrackerEntry, Da taProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v4);
      if (v5 != buf) {
        free(v5);
      }
    }
  }

void sub_100E96AFC(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101889F60);
  }
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
  {
    char v11 = 1;
    unint64_t v8 = _os_activity_create( (void *)&_mh_execute_header,  "CL: CLSpringTrackingNotifier::onDataProtectionNotification",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_DEFAULT);
    os_activity_scope_enter(v8, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889F60);
    }
    uint64_t v9 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289538;
      int v13 = 0;
      __int16 v14 = 2082;
      unint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = "activity";
      __int16 v18 = 2050;
      uint64_t v19 = a4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLSpringTrackingNotifier::onDataProtectionNotification, event:%{public, location:es cape_only}s, this:%{public}p}",  buf,  0x26u);
    }
  }

  else
  {
    char v11 = 0;
  }

  sub_100E972CC(a4, v7, a2, a3);
  if (v11) {
    os_activity_scope_leave(&state);
  }
}

void sub_100E96CB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_activity_scope_state_s state, char a11)
{
  if (a11) {
    os_activity_scope_leave(&state);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E96CD4(uint64_t a1)
{
  *(void *)a1 = off_101889FB0;
  [*(id *)(a1 + 48) invalidate];

  sub_100231CA4(a1 + 80, *(void **)(a1 + 88));
  sub_100231CF0(a1 + 56, *(void **)(a1 + 64));
  return a1;
}

uint64_t sub_100E96D48(uint64_t a1)
{
  uint64_t v2 = operator new(0xE0uLL);
  uint64_t result = sub_100E96534((uint64_t)v2, *(void **)(a1 + 32));
  qword_1019A3D88 = (uint64_t)v2;
  return result;
}

void sub_100E96D80(_Unwind_Exception *a1)
{
}

uint64_t sub_100E96D94(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100E96E08;
  block[3] = &unk_10181A288;
  block[4] = a1;
  if (qword_10199EEF0 != -1) {
    dispatch_once(&qword_10199EEF0, block);
  }
  return byte_10199EEE8;
}

id sub_100E96E08(uint64_t a1)
{
  id result = objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "vendor"),  "isServiceEnabled:",  @"CLSpringTrackingNotifier");
  byte_10199EEE8 = (char)result;
  return result;
}

uint64_t sub_100E96E34(uint64_t a1)
{
  *(void *)a1 = off_101889E40;

  *(void *)(a1 + 112) = 0LL;
  *(void *)(a1 + 208) = 0LL;
  (*(void (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  uint64_t v2 = *(void *)(a1 + 216);
  *(void *)(a1 + 216) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  sub_1001B4FBC(a1 + 136);
  sub_10000AE14(a1 + 120);
  return sub_100E96CD4(a1);
}

void sub_100E96EB8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_100E96E34(a1);
  operator delete(v1);
}

uint64_t sub_100E96ECC(uint64_t result)
{
  *(_BYTE *)(result + 108) = 1;
  return result;
}

void sub_100E96ED8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (char *)operator new(0x18uLL);
  double v4 = v2 + 24;
  uint64_t v5 = v2 + 24;
  v2[16] = 0;
  *(_OWORD *)uint64_t v2 = xmmword_1013637E0;
  __int128 __p = v2;
  (*(void (**)(void, void **))(**(void **)(v1 + 120) + 32LL))(*(void *)(v1 + 120), &__p);
  if (__p)
  {
    double v4 = __p;
    operator delete(__p);
  }

void sub_100E96F48( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100E96F64(uint64_t a1, uint64_t *a2)
{
  if (qword_101934820 != -1) {
    dispatch_once(&qword_101934820, &stru_101889F80);
  }
  uint64_t v3 = (os_log_s *)qword_101934828;
  if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_INFO))
  {
    uint64_t v4 = *a2;
    uint64_t v5 = a2[5];
    uint64_t v6 = a2[6];
    *(_DWORD *)__int128 buf = 134218496;
    uint64_t v21 = v4;
    __int16 v22 = 2048;
    uint64_t v23 = v5;
    __int16 v24 = 2048;
    uint64_t v25 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "id,%llu,startTime,%lf,eventType,%ld", buf, 0x20u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934820 != -1) {
      dispatch_once(&qword_101934820, &stru_101889F80);
    }
    uint64_t v8 = *a2;
    uint64_t v9 = a2[5];
    uint64_t v10 = a2[6];
    int v14 = 134218496;
    uint64_t v15 = v8;
    __int16 v16 = 2048;
    uint64_t v17 = v9;
    __int16 v18 = 2048;
    uint64_t v19 = v10;
    LODWORD(v13) = 32;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934828,  1LL,  "id,%llu,startTime,%lf,eventType,%ld",  &v14,  v13);
    unint64_t v12 = (uint8_t *)v11;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLSpringTrackingNotifier::setUpdateFinishedHandler()_block_invoke",  "%s\n",  v11);
    if (v12 != buf) {
      free(v12);
    }
  }

  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterPostNotification(DarwinNotifyCenter, @"com.apple.locationd.lorievent", 0LL, 0LL, 0);
}

void *sub_100E97160@<X0>(_DWORD *a1@<X1>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, __str);
}

void sub_100E971D8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if ([a2 trigger] == 14)
  {
    uint64_t v6 = 0LL;
    __int128 v4 = 0u;
    __int128 v5 = 0u;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    uint64_t v8 = 0LL;
    sub_100E97278(v2 + 136, (uint64_t)&v4);
    uint64_t v3 = *(void **)(v2 + 208);
    if (v3)
    {
      objc_msgSend(v3, "invalidate", v4, v5, v6);

      *(void *)(v2 + 208) = 0LL;
    }
  }

uint64_t sub_100E97278(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100E98F8C(*(void *)(a1 + 24), a2);
  if (!*(_BYTE *)(a1 + 41))
  {
    uint64_t result = sub_100D8A92C(*(void *)(a1 + 24) + 72LL);
    if ((_DWORD)result)
    {
      *(_BYTE *)(a1 + 41) = 1;
      return sub_100E994B0(a1);
    }
  }

  return result;
}

void sub_100E972CC(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  if (*a3) {
    BOOL v4 = 0;
  }
  else {
    BOOL v4 = *a4 == 1;
  }
  if (v4 && *(void *)(a1 + 208))
  {
    uint64_t v9 = 0LL;
    __int128 v7 = 0u;
    __int128 v8 = 0u;
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    uint64_t v11 = 0LL;
    sub_100E97278(a1 + 136, (uint64_t)&v7);
    uint64_t v6 = *(void **)(a1 + 208);
    if (v6)
    {
      objc_msgSend(v6, "invalidate", v7, v8, v9);

      *(void *)(a1 + 208) = 0LL;
    }
  }

void sub_100E97378(uint64_t a1, uint64_t a2)
{
  HIDWORD(v15) = a2;
  if (!*(_BYTE *)(a1 + 108))
  {
    uint64_t v4 = *(void *)(a1 + 88);
    if (!v4) {
      goto LABEL_12;
    }
    uint64_t v5 = a1 + 80;
    uint64_t v6 = a1 + 88;
    do
    {
      int v7 = *(_DWORD *)(v4 + 32);
      BOOL v8 = v7 < (int)a2;
      else {
        uint64_t v9 = (uint64_t *)(v4 + 8);
      }
      if (!v8) {
        uint64_t v6 = v4;
      }
      uint64_t v4 = *v9;
    }

    while (*v9);
    if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= (int)a2)
    {
      while (*(void *)(v6 + 56))
      {
        *(_DWORD *)__int128 buf = *(_DWORD *)(*(void *)(v6 + 40) + 28LL);
        (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(void *)a1 + 112LL))(a1, a2, buf);
      }

      sub_100233254(v5, (int *)&v15 + 1);
    }

    else
    {
LABEL_12:
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101889F60);
      }
      uint64_t v10 = (os_log_s *)qword_1019349D8;
      if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v11 = (void *)(a1 + 8);
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v21 = v11;
        __int16 v22 = 1026;
        int v23 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
          buf,
          0x12u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101889F60);
        }
        unint64_t v12 = (void *)(a1 + 8);
        int v16 = 136446466;
        uint64_t v17 = v12;
        __int16 v18 = 1026;
        int v19 = a2;
        LODWORD(v15) = 18;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
          &v16,
          v15);
        int v14 = (uint8_t *)v13;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::Notificati onData>::removeClient(int) [Notification_T = CLSpringTrackingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v13);
        if (v14 != buf) {
          free(v14);
        }
      }
    }
  }

uint64_t sub_100E975EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)a1 + 96LL))( a1,  a2,  a3,  &unk_101991698);
}

uint64_t sub_100E97600(uint64_t a1, int a2, int *a3, char *a4)
{
  int v42 = a2;
  if (*(_BYTE *)(a1 + 108)) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v10 = a1 + 88;
    do
    {
      int v11 = *(_DWORD *)(v7 + 32);
      BOOL v12 = v11 < a2;
      if (v11 >= a2) {
        double v13 = (uint64_t *)v7;
      }
      else {
        double v13 = (uint64_t *)(v7 + 8);
      }
      if (!v12) {
        uint64_t v10 = v7;
      }
      uint64_t v7 = *v13;
    }

    while (*v13);
    if (v10 != a1 + 88 && *(_DWORD *)(v10 + 32) <= a2)
    {
      *(void *)uint64_t v43 = v10;
      int v17 = *a3;
      uint64_t v20 = *(void *)(v10 + 48);
      uint64_t v19 = v10 + 48;
      uint64_t v18 = v20;
      if (!v20) {
        goto LABEL_31;
      }
      uint64_t v21 = v19;
      do
      {
        int v22 = *(_DWORD *)(v18 + 28);
        BOOL v23 = v22 < v17;
        if (v22 >= v17) {
          __int16 v24 = (uint64_t *)v18;
        }
        else {
          __int16 v24 = (uint64_t *)(v18 + 8);
        }
        if (!v23) {
          uint64_t v21 = v18;
        }
        uint64_t v18 = *v24;
      }

      while (*v24);
      if (v21 == v19 || v17 < *(_DWORD *)(v21 + 28)) {
LABEL_31:
      }
        uint64_t v21 = v19;
      uint64_t v25 = *(void *)(a1 + 64);
      if (!v25) {
        goto LABEL_42;
      }
      uint64_t v26 = a1 + 64;
      do
      {
        int v27 = *(_DWORD *)(v25 + 32);
        BOOL v28 = v27 < v17;
        if (v27 >= v17) {
          int v29 = (uint64_t *)v25;
        }
        else {
          int v29 = (uint64_t *)(v25 + 8);
        }
        if (!v28) {
          uint64_t v26 = v25;
        }
        uint64_t v25 = *v29;
      }

      while (*v29);
      if (v26 != a1 + 64 && v17 >= *(_DWORD *)(v26 + 32))
      {
        uint64_t v41 = v26;
        uint64_t v34 = *(void *)(v26 + 56);
        char v35 = *a4;
        *(void *)&buf[0] = &v42;
        *((_BYTE *)sub_1004EF3D4((uint64_t **)(v26 + 40), &v42, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v35;
        uint64_t v47 = 0LL;
        memset(buf, 0, sizeof(buf));
        if (v21 == v19
          && (*(unsigned int (**)(uint64_t, int *, _OWORD *))(*(void *)a1 + 128LL))(a1, a3, buf))
        {
          __int16 v36 = sub_100E9A048((uint64_t)buf);
          sub_100E9A0D8((_BYTE *)a1, (uint64_t)v43, (uint64_t)&v41, v36);
        }

        if (v34) {
          goto LABEL_44;
        }
      }

      else
      {
LABEL_42:
        uint64_t v41 = a1 + 64;
        char v30 = byte_101991699;
        HIDWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v17;
        *(void *)&buf[0] = (char *)&v40 + 4;
        *((_BYTE *)sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 8sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v30;
        HIDWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *a3;
        *(void *)&buf[0] = (char *)&v40 + 4;
        double v31 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        sub_1000F0D38(v31 + 8);
        char v32 = *a4;
        HIDWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = *a3;
        *(void *)&buf[0] = (char *)&v40 + 4;
        double v33 = sub_10023347C((uint64_t **)(a1 + 56), (int *)&v40 + 1, (uint64_t)&unk_1012CF090, (_DWORD **)buf);
        *(void *)&buf[0] = &v42;
        *((_BYTE *)sub_1004EF3D4(v33 + 5, &v42, (uint64_t)&unk_1012CF090, (_DWORD **)buf) + 32) = v32;
      }

      (*(void (**)(uint64_t, int *))(*(void *)a1 + 168LL))(a1, a3);
LABEL_44:
      if (v21 == v19)
      {
        LODWORD(buf[0]) = *a3;
        sub_10004A8FC((uint64_t **)(*(void *)v43 + 40LL), (int *)buf, buf);
      }

      return 1LL;
    }
  }

  if (qword_1019349D0 != -1) {
    dispatch_once(&qword_1019349D0, &stru_101889F60);
  }
  int v14 = (os_log_s *)qword_1019349D8;
  if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
  {
    uint64_t v15 = (void *)(a1 + 8);
    LODWORD(buf[0]) = 136446466;
    *(void *)((char *)buf + 4) = v15;
    WORD6(buf[0]) = 1026;
    *(_DWORD *)((char *)buf + 14) = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
      (uint8_t *)buf,
      0x12u);
  }

  BOOL v16 = sub_1002921D0(115, 0);
  uint64_t result = 0LL;
  if (v16)
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889F60);
    }
    uint64_t v37 = (void *)(a1 + 8);
    *(_DWORD *)uint64_t v43 = 136446466;
    *(void *)&v43[4] = v37;
    __int16 v44 = 1026;
    int v45 = a2;
    LODWORD(v4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
      v43,
      v40);
    uint64_t v39 = (char *)v38;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::NotificationDa ta>::registerForNotification(int, const Notification_T &, const RegistrationInfo_T &) [Notification_T = CLSpringTr ackingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData, Notificat ionInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v38);
    return 0LL;
  }

  return result;
}

BOOL sub_100E97A68(uint64_t a1, int a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  if (!v5) {
    goto LABEL_11;
  }
  uint64_t v6 = a1 + 88;
  do
  {
    int v7 = *(_DWORD *)(v5 + 32);
    BOOL v8 = v7 < a2;
    if (v7 >= a2) {
      uint64_t v9 = (uint64_t *)v5;
    }
    else {
      uint64_t v9 = (uint64_t *)(v5 + 8);
    }
    if (!v8) {
      uint64_t v6 = v5;
    }
    uint64_t v5 = *v9;
  }

  while (*v9);
  if (v6 != a1 + 88 && *(_DWORD *)(v6 + 32) <= a2)
  {
    uint64_t v16 = *(void *)(v6 + 48);
    uint64_t v14 = v6 + 48;
    uint64_t v15 = v16;
    if (!v16) {
      goto LABEL_29;
    }
    int v17 = *a3;
    uint64_t v18 = v14;
    do
    {
      int v19 = *(_DWORD *)(v15 + 28);
      BOOL v20 = v19 < v17;
      if (v19 >= v17) {
        uint64_t v21 = (uint64_t *)v15;
      }
      else {
        uint64_t v21 = (uint64_t *)(v15 + 8);
      }
      if (!v20) {
        uint64_t v18 = v15;
      }
      uint64_t v15 = *v21;
    }

    while (*v21);
    if (v18 == v14 || v17 < *(_DWORD *)(v18 + 28)) {
LABEL_29:
    }
      uint64_t v18 = v14;
    return v18 != v14;
  }

  else
  {
LABEL_11:
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889F60);
    }
    uint64_t v10 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
    {
      int v11 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136446466;
      char v30 = v11;
      __int16 v31 = 1026;
      int v32 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_FAULT,  "%{public}s; client %{public}d does not exist",
        buf,
        0x12u);
    }

    BOOL v12 = sub_1002921D0(115, 0);
    BOOL result = 0LL;
    if (v12)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101889F60);
      }
      int v22 = (void *)(a1 + 8);
      int v25 = 136446466;
      uint64_t v26 = v22;
      __int16 v27 = 1026;
      int v28 = a2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; client %{public}d does not exist",
        &v25,
        18);
      __int16 v24 = (uint8_t *)v23;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::Notification Data>::clientRegistered(int, const Notification_T &) [Notification_T = CLSpringTrackingNotifier_Type::Notificati on, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
      if (v24 != buf) {
        free(v24);
      }
      return 0LL;
    }
  }

  return result;
}

BOOL sub_100E97CE8(char *a1, int a2, int *a3)
{
  HIDWORD(v34) = a2;
  int v3 = a1[108];
  if (!a1[108])
  {
    uint64_t v6 = *((void *)a1 + 11);
    if (v6)
    {
      BOOL v8 = a1 + 88;
      do
      {
        int v9 = *(_DWORD *)(v6 + 32);
        BOOL v10 = v9 < a2;
        if (v9 >= a2) {
          int v11 = (uint64_t *)v6;
        }
        else {
          int v11 = (uint64_t *)(v6 + 8);
        }
        if (!v10) {
          BOOL v8 = (char *)v6;
        }
        uint64_t v6 = *v11;
      }

      while (*v11);
      if (v8 != a1 + 88 && *((_DWORD *)v8 + 8) <= a2)
      {
        uint64_t v14 = (char *)*((void *)v8 + 6);
        BOOL v12 = v8 + 48;
        double v13 = v14;
        if (v14)
        {
          int v15 = *a3;
          uint64_t v16 = v12;
          do
          {
            int v17 = *((_DWORD *)v13 + 7);
            BOOL v18 = v17 < v15;
            if (v17 >= v15) {
              int v19 = (char **)v13;
            }
            else {
              int v19 = (char **)(v13 + 8);
            }
            if (!v18) {
              uint64_t v16 = v13;
            }
            double v13 = *v19;
          }

          while (*v19);
          if (v16 != v12 && v15 >= *((_DWORD *)v16 + 7))
          {
            LODWORD(__p[0]) = *a3;
            sub_1004EF494((uint64_t)(v12 - 8), (int *)__p);
            uint64_t v20 = *((void *)a1 + 8);
            if (!v20) {
              goto LABEL_33;
            }
            int v21 = *a3;
            int v22 = a1 + 64;
            do
            {
              int v23 = *(_DWORD *)(v20 + 32);
              BOOL v24 = v23 < v21;
              if (v23 >= v21) {
                int v25 = (uint64_t *)v20;
              }
              else {
                int v25 = (uint64_t *)(v20 + 8);
              }
              if (!v24) {
                int v22 = (char *)v20;
              }
              uint64_t v20 = *v25;
            }

            while (*v25);
            if (v22 != a1 + 64 && v21 >= *((_DWORD *)v22 + 8))
            {
              sub_1004EF494((uint64_t)(v22 + 40), (int *)&v34 + 1);
              if (!*((void *)v22 + 7)) {
                (*(void (**)(char *, int *))(*(void *)a1 + 176LL))(a1, a3);
              }
            }

            else
            {
LABEL_33:
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101889F60);
              }
              uint64_t v26 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                __int16 v27 = a1 + 8;
                if (a1[31] < 0) {
                  __int16 v27 = (void *)*v27;
                }
                (*(void (**)(void **__return_ptr, char *, int *))(*(void *)a1 + 160LL))(__p, a1, a3);
                if (v44 >= 0) {
                  int v28 = __p;
                }
                else {
                  int v28 = (void **)__p[0];
                }
                *(_DWORD *)__int128 buf = 136446466;
                *(void *)&uint8_t buf[4] = v27;
                __int16 v36 = 2082;
                uint64_t v37 = v28;
                _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_FAULT,  "%{public}s; notification %{public}s not found",
                  buf,
                  0x16u);
                if (v44 < 0) {
                  operator delete(__p[0]);
                }
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(__p, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101889F60);
                }
                int v29 = a1 + 8;
                if (a1[31] < 0) {
                  int v29 = (void *)*v29;
                }
                uint64_t v30 = qword_1019349D8;
                (*(void (**)(_BYTE *__return_ptr, char *, int *))(*(void *)a1 + 160LL))(buf, a1, a3);
                if (v38 >= 0) {
                  __int16 v31 = buf;
                }
                else {
                  __int16 v31 = *(_BYTE **)buf;
                }
                int v39 = 136446466;
                uint64_t v40 = v29;
                __int16 v41 = 2082;
                int v42 = v31;
                LODWORD(v34) = 22;
                _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v30,  17LL,  "%{public}s; notification %{public}s not found",
                  &v39,
                  v34);
                double v33 = v32;
                if (v38 < 0) {
                  operator delete(*(void **)buf);
                }
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::No tificationData>::unregisterForNotification(int, const Notification_T &) [Notification_T = CLSpringTrac kingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v33);
              }
            }
          }
        }
      }
    }
  }

  return v3 == 0;
}

uint64_t sub_100E98070(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v6 = (char *)operator new(0x50uLL);
  __int128 v7 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(v6 + 24) = *(_OWORD *)a3;
  *((void *)v6 + 2) = 0LL;
  *(void *)uint64_t v6 = off_10188A188;
  *((void *)v6 + 1) = 0LL;
  *(_OWORD *)(v6 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v7;
  *(_OWORD *)(v6 + 56) = *(_OWORD *)(a3 + 32);
  *((void *)v6 + 9) = *(void *)(a3 + 48);
  *(void *)&__int128 v14 = v6 + 24;
  *((void *)&v14 + 1) = v6;
  int v13 = *a2;
  int v15 = &v13;
  BOOL v8 = sub_10023347C((uint64_t **)(a1 + 56), &v13, (uint64_t)&unk_1012CF090, &v15);
  sub_10005F550((uint64_t)(v8 + 8), &v14);
  int v9 = (std::__shared_weak_count *)*((void *)&v14 + 1);
  if (*((void *)&v14 + 1))
  {
    BOOL v10 = (unint64_t *)(*((void *)&v14 + 1) + 8LL);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  return 1LL;
}

void sub_100E98158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100E9816C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = 0LL;
  memset(v5, 0, sizeof(v5));
  return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, void))(*(void *)a1 + 152LL))( a1,  a2,  v5,  a3,  a4,  0LL);
}

void sub_100E981DC(uint64_t a1, unsigned int *a2, uint64_t a3, int a4, int a5)
{
  if (!*(_BYTE *)(a1 + 108))
  {
    BOOL v10 = _os_activity_create( (void *)&_mh_execute_header,  "CL: notifyClientsWithData (Fallback)",  (os_activity_t)&_os_activity_current,  OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
    os_activity_scope_enter(v10, &state);

    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889F60);
    }
    unint64_t v11 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      BOOL v12 = (void *)(a1 + 8);
      int v13 = (std::__shared_weak_count *)*a2;
      *(_DWORD *)__int128 buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&_BYTE buf[20] = "activity";
      __int16 v68 = 2082;
      double v69 = v12;
      __int16 v70 = 2050;
      double v71 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:notifyClientsWithData, event:%{public, location:escape_only}s, name:%{public, l ocation:escape_only}s, notification:%{public}lld}",  buf,  0x30u);
    }

    int v15 = (__n128 *)(a1 + 64);
    __int128 v14 = *(__n128 **)(a1 + 64);
    if (!v14) {
      goto LABEL_18;
    }
    signed __int32 v16 = *a2;
    int v17 = (__n128 *)(a1 + 64);
    do
    {
      signed __int32 v18 = v14[2].n128_i32[0];
      BOOL v19 = v18 < v16;
      if (v18 >= v16) {
        uint64_t v20 = (__n128 **)v14;
      }
      else {
        uint64_t v20 = (__n128 **)&v14->n128_u64[1];
      }
      if (!v19) {
        int v17 = v14;
      }
      __int128 v14 = *v20;
    }

    while (*v20);
    if (v17 == v15 || v16 < (signed __int32)v17[2].n128_u32[0])
    {
LABEL_18:
      *(void *)__int16 v72 = &v72[8];
      memset(&v72[8], 0, 24);
      double v73 = 0LL;
      sub_1002343E4((uint64_t)buf, a2, (uint64_t)v72);
      int v17 = sub_1002342A4((uint64_t **)(a1 + 56), (__n128 *)buf);
      int v21 = v71;
      if (v71)
      {
        p_shared_owners = (unint64_t *)&v71->__shared_owners_;
        do
          unint64_t v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }

      sub_100008390((uint64_t)&buf[8], *(void **)&buf[16]);
      BOOL v24 = v73;
      if (v73)
      {
        int v25 = (unint64_t *)&v73->__shared_owners_;
        do
          unint64_t v26 = __ldaxr(v25);
        while (__stlxr(v26 - 1, v25));
        if (!v26)
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }

      sub_100008390((uint64_t)v72, *(void **)&v72[8]);
    }

    if (a4)
    {
      __int16 v27 = (char *)operator new(0x50uLL);
      __int128 v28 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)(v27 + 24) = *(_OWORD *)a3;
      *((void *)v27 + 2) = 0LL;
      *(void *)__int16 v27 = off_10188A188;
      *((void *)v27 + 1) = 0LL;
      *(_OWORD *)(v27 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v28;
      *(_OWORD *)(v27 + 56) = *(_OWORD *)(a3 + 32);
      *((void *)v27 + 9) = *(void *)(a3 + 48);
      *(void *)__int128 buf = v27 + 24;
      *(void *)&uint8_t buf[8] = v27;
      sub_10005F550((uint64_t)&v17[4], (__int128 *)buf);
      int v29 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        uint64_t v30 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
    }

    else
    {
      sub_1000F0D38((__n128 *)v17[4].n128_u64);
    }

    if (!v17[3].n128_u64[1]) {
      goto LABEL_83;
    }
    int v32 = sub_100E9A67C(a3);
    if (a5 == -1)
    {
      sub_100E9A70C((void *)a1, (int *)a2, v32);
    }

    else
    {
      uint64_t v33 = a1 + 88;
      uint64_t v34 = *(void *)(a1 + 88);
      if (!v34) {
        goto LABEL_48;
      }
      uint64_t v35 = a1 + 88;
      do
      {
        int v36 = *(_DWORD *)(v34 + 32);
        BOOL v37 = v36 < a5;
        if (v36 >= a5) {
          char v38 = (uint64_t *)v34;
        }
        else {
          char v38 = (uint64_t *)(v34 + 8);
        }
        if (!v37) {
          uint64_t v35 = v34;
        }
        uint64_t v34 = *v38;
      }

      while (*v38);
      if (v35 == v33 || *(_DWORD *)(v35 + 32) > a5) {
LABEL_48:
      }
        uint64_t v35 = a1 + 88;
      uint64_t v65 = v35;
      unint64_t v39 = v15->n128_u64[0];
      if (!v15->n128_u64[0]) {
        goto LABEL_59;
      }
      int v40 = *a2;
      __int16 v41 = (__n128 *)(a1 + 64);
      do
      {
        int v42 = *(_DWORD *)(v39 + 32);
        BOOL v43 = v42 < v40;
        if (v42 >= v40) {
          char v44 = (unint64_t *)v39;
        }
        else {
          char v44 = (unint64_t *)(v39 + 8);
        }
        if (!v43) {
          __int16 v41 = (__n128 *)v39;
        }
        unint64_t v39 = *v44;
      }

      while (*v44);
      if (v41 == v15 || v40 < (signed __int32)v41[2].n128_u32[0])
      {
LABEL_59:
        __int16 v64 = (__n128 *)(a1 + 64);
LABEL_60:
        if (qword_1019349D0 != -1) {
          dispatch_once(&qword_1019349D0, &stru_101889F60);
        }
        int v45 = (os_log_s *)qword_1019349D8;
        if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
        {
          __int16 v46 = (void *)(a1 + 8);
          (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(v72, a1, a2);
          if (v72[23] >= 0) {
            uint64_t v47 = v72;
          }
          else {
            uint64_t v47 = *(_BYTE **)v72;
          }
          *(_DWORD *)__int128 buf = 136315650;
          *(void *)&uint8_t buf[4] = v46;
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = a5;
          *(_WORD *)&_BYTE buf[18] = 2080;
          *(void *)&_BYTE buf[20] = v47;
          _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_DEBUG,  "%s; client %d has deregistered, not notifying %s",
            buf,
            0x1Cu);
          if ((v72[23] & 0x80000000) != 0) {
            operator delete(*(void **)v72);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019349D0 != -1) {
            dispatch_once(&qword_1019349D0, &stru_101889F60);
          }
          __int16 v48 = (void *)(a1 + 8);
          uint64_t v49 = qword_1019349D8;
          (*(void (**)(void **__return_ptr, uint64_t, unsigned int *))(*(void *)a1 + 160LL))(__p, a1, a2);
          if (v63 >= 0) {
            __int16 v50 = __p;
          }
          else {
            __int16 v50 = (void **)__p[0];
          }
          *(_DWORD *)__int16 v72 = 136315650;
          *(void *)&v72[4] = v48;
          *(_WORD *)&v72[12] = 1024;
          *(_DWORD *)&v72[14] = a5;
          *(_WORD *)&v72[18] = 2080;
          *(void *)&v72[20] = v50;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v49,  2LL,  "%s; client %d has deregistered, not notifying %s",
            v72,
            28,
            v61);
          __int16 v52 = v51;
          if (v63 < 0) {
            operator delete(__p[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::Notifica tionData>::notifyClientsWithData(const Notification_T &, const NotificationData_T &, BOOL, int, BOOL) [Notif ication_T = CLSpringTrackingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type: :NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v52);
          if (v52 != buf) {
            free(v52);
          }
        }

        goto LABEL_83;
      }

      __int16 v64 = v41;
      if (v35 == v33) {
        goto LABEL_60;
      }
      uint64_t v55 = v41[3].n128_i64[0];
      int v53 = v41 + 3;
      __int16 v54 = (__n128 *)v55;
      if (!v55) {
        goto LABEL_60;
      }
      int v56 = *(_DWORD *)(v35 + 32);
      double v57 = v53;
      do
      {
        int v58 = v54[1].n128_i32[3];
        BOOL v59 = v58 < v56;
        if (v58 >= v56) {
          __int16 v60 = v54;
        }
        else {
          __int16 v60 = (__n128 *)&v54->n128_i8[8];
        }
        if (!v59) {
          double v57 = v54;
        }
        __int16 v54 = (__n128 *)v60->n128_u64[0];
      }

      while (v60->n128_u64[0]);
      sub_100E9A0D8((_BYTE *)a1, (uint64_t)&v65, (uint64_t)&v64, v32);
    }

void sub_100E98828( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state, char a18)
{
}

void sub_100E98874(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 108))
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889F60);
    }
    uint64_t v2 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      int v3 = (void *)(a1 + 8);
      *(_DWORD *)__int128 buf = 136315138;
      BOOL v37 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "%s; already shutdown; not listing clients",
        buf,
        0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101889F60);
      }
      uint64_t v4 = (void *)(a1 + 8);
      int v32 = 136315138;
      uint64_t v33 = v4;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; already shutdown; not listing clients",
        (const char *)&v32);
      uint64_t v6 = (uint8_t *)v5;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::Notification Data>::listClients() [Notification_T = CLSpringTrackingNotifier_Type::Notification, NotificationData_T = CLSprin gTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v5);
      if (v6 != buf) {
        free(v6);
      }
    }
  }

  else
  {
    if (qword_1019349D0 != -1) {
      dispatch_once(&qword_1019349D0, &stru_101889F60);
    }
    __int128 v7 = (os_log_s *)qword_1019349D8;
    if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
    {
      BOOL v8 = (void *)(a1 + 8);
      uint64_t v9 = *(void *)(a1 + 96);
      *(_DWORD *)__int128 buf = 136315394;
      BOOL v37 = v8;
      __int16 v38 = 2048;
      v39[0] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "%s; listing clients, num clients: %zu",
        buf,
        0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019349D0 != -1) {
        dispatch_once(&qword_1019349D0, &stru_101889F60);
      }
      __int16 v27 = (void *)(a1 + 8);
      uint64_t v28 = *(void *)(a1 + 96);
      int v32 = 136315394;
      uint64_t v33 = v27;
      __int16 v34 = 2048;
      v35[0] = v28;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; listing clients, num clients: %zu",
        (const char *)&v32,
        22);
      uint64_t v30 = (uint8_t *)v29;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::Notification Data>::listClients() [Notification_T = CLSpringTrackingNotifier_Type::Notification, NotificationData_T = CLSprin gTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v29);
      if (v30 != buf) {
        free(v30);
      }
    }

    BOOL v10 = *(void **)(a1 + 80);
    if (v10 != (void *)(a1 + 88))
    {
      unint64_t v11 = (void *)(a1 + 8);
      do
      {
        BOOL v12 = (void *)v10[5];
        if (v12 != v10 + 6)
        {
          do
          {
            if (qword_1019349D0 != -1) {
              dispatch_once(&qword_1019349D0, &stru_101889F60);
            }
            int v13 = (os_log_s *)qword_1019349D8;
            if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_DEBUG))
            {
              __int128 v14 = (void *)(a1 + 8);
              int v15 = *((_DWORD *)v10 + 8);
              int v16 = *((_DWORD *)v12 + 7);
              *(_DWORD *)__int128 buf = 136315650;
              BOOL v37 = v14;
              __int16 v38 = 1024;
              LODWORD(v39[0]) = v15;
              WORD2(v39[0]) = 1024;
              *(_DWORD *)((char *)v39 + 6) = v16;
              _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "%s; clients, id: %d, notification: %d",
                buf,
                0x18u);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101889F60);
              }
              uint64_t v20 = (void *)(a1 + 8);
              int v21 = *((_DWORD *)v10 + 8);
              int v22 = *((_DWORD *)v12 + 7);
              int v32 = 136315650;
              uint64_t v33 = v20;
              __int16 v34 = 1024;
              LODWORD(v35[0]) = v21;
              WORD2(v35[0]) = 1024;
              *(_DWORD *)((char *)v35 + 6) = v22;
              _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  2LL,  "%s; clients, id: %d, notification: %d",
                (const char *)&v32,
                24,
                v31);
              BOOL v24 = (uint8_t *)v23;
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::Noti ficationData>::listClients() [Notification_T = CLSpringTrackingNotifier_Type::Notification, Notification Data_T = CLSpringTrackingNotifier_Type::NotificationData, NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v23);
              if (v24 != buf) {
                free(v24);
              }
            }

            int v17 = (void *)v12[1];
            if (v17)
            {
              do
              {
                signed __int32 v18 = v17;
                int v17 = (void *)*v17;
              }

              while (v17);
            }

            else
            {
              do
              {
                signed __int32 v18 = (void *)v12[2];
                BOOL v19 = *v18 == (void)v12;
                BOOL v12 = v18;
              }

              while (!v19);
            }

            BOOL v12 = v18;
          }

          while (v18 != v10 + 6);
        }

        int v25 = (void *)v10[1];
        if (v25)
        {
          do
          {
            unint64_t v26 = v25;
            int v25 = (void *)*v25;
          }

          while (v25);
        }

        else
        {
          do
          {
            unint64_t v26 = (void *)v10[2];
            BOOL v19 = *v26 == (void)v10;
            BOOL v10 = v26;
          }

          while (!v19);
        }

        BOOL v10 = v26;
      }

      while (v26 != (void *)(a1 + 88));
    }
  }

void sub_100E98E1C(id a1)
{
  qword_1019349D8 = (uint64_t)os_log_create("com.apple.locationd.Core", "Notifier");
}

void sub_100E98E48(id a1)
{
  qword_101934828 = (uint64_t)os_log_create("com.apple.locationd.Position", "Spring");
}

void *sub_100E98E74(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &off_10188A090;
  v4[1] = 0LL;
  v4[2] = 0LL;
  uint64_t v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100E98EBC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E98EDC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 24LL))(result);
  }
  return result;
}

uint64_t sub_100E98EF4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void sub_100E98F34(id a1)
{
  qword_1019344B8 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Motion");
}

void sub_100E98F60(id a1)
{
  qword_101934A78 = (uint64_t)os_log_create("com.apple.locationd.Legacy", "Generic_deprecated");
}

uint64_t sub_100E98F8C(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1 + 112;
  uint64_t v4 = *(void *)(a1 + 112);
  uint64_t v6 = a1 + 72;
  *(void *)&v23[1] = a1 + 112;
  (*(void (**)(uint64_t))(v4 + 16))(a1 + 112);
  __int16 v24 = 256;
  v23[0] = *(double *)(a2 + 40);
  if (sub_100D8AB44(v6, v23))
  {
    if (sub_100D8A92C(v6))
    {
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 80LL))(a1, a2, 0LL);
    }

    else if (!*(_BYTE *)(a1 + 128))
    {
      BOOL v12 = (void *)(a1 + 176);
      unint64_t v13 = *(void *)(a1 + 216);
      if (v13 > *(int *)(a1 + 280))
      {
        ++*(void *)(a1 + 208);
        *(void *)(a1 + 216) = v13 - 1;
        sub_10079E85C(a1 + 176, 1);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188A0F8);
        }
        __int128 v14 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEBUG,  "Maximum number of entries exceeded, throwing out oldest entry.",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10188A0F8);
          }
          v22[0] = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Maximum number of entries exceeded, throwing out oldest entry.",  v22,  2);
          uint64_t v20 = (uint8_t *)v19;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityRecorderDb<CLSpringTrackerEntry>::addSuspectRecord(const T &) [T = CLSpringTrackerEntry, Data ProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v19);
          if (v20 != buf) {
            free(v20);
          }
        }
      }

      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10188A138);
      }
      int v15 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEBUG,  "Buffer was added to since db was inaccesible.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10188A138);
        }
        v22[0] = 0;
        LODWORD(v21) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Buffer was added to since db was inaccesible.",  v22,  v21);
        signed __int32 v18 = (uint8_t *)v17;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLActivityRecorderDb<CLSpringTrackerEntry>::addSuspectRecord(const T &) [T = CLSpringTrackerEntry, DataPr otectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v17);
        if (v18 != buf) {
          free(v18);
        }
      }

      __n128 v7 = sub_100E99A24(v12, a2);
    }
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188A0F8);
    }
    BOOL v8 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289538;
      int v26 = 0;
      __int16 v27 = 2082;
      uint64_t v28 = "";
      __int16 v29 = 1026;
      int v30 = (int)v23[0];
      __int16 v31 = 2082;
      int v32 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CL database error, record contains invalid time, invalid time:%{public}d, name: %{public, location:escape_only}s}",  buf,  0x22u);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188A0F8);
      }
    }

    BOOL v10 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      unint64_t v11 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289538;
      int v26 = 0;
      __int16 v27 = 2082;
      uint64_t v28 = "";
      __int16 v29 = 1026;
      int v30 = (int)v23[0];
      __int16 v31 = 2082;
      int v32 = v11;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CL database error, record contains invalid time",  "{msg%{public}.0s:CL database error, record contains invalid time, invalid time:%{public}d, name: %{public, location:escape_only}s}",  buf,  0x22u);
    }
  }

  return (*(uint64_t (**)(uint64_t, __n128))(*(void *)v5 + 24LL))(v5, v7);
}

void sub_100E99484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

uint64_t sub_100E994B0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 40)) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10188A118);
  }
  uint64_t v2 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v3 = sub_101171D38();
    int v4 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)__int128 buf = 134218240;
    *(double *)int v36 = v3;
    *(_WORD *)&v36[8] = 1024;
    int v37 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "Aggregating records start %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10188A118);
    }
    uint64_t v16 = qword_101934A78;
    double v17 = sub_101171D38();
    int v18 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v32 = 134218240;
    *(double *)uint64_t v33 = v17;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v18;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v16,  2LL,  "Aggregating records start %f, count ~%d",  COERCE_DOUBLE(&v32),  18);
    uint64_t v20 = (uint8_t *)v19;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLSpringTrackerEntry>::aggregateRecords() [T = CLSpringTrackerEntry, DataProtectionPolic y = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v19);
    if (v20 != buf) {
      free(v20);
    }
  }

  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a1);
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_10188A118);
  }
  uint64_t v6 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    double v7 = sub_101171D38();
    int v8 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    *(_DWORD *)__int128 buf = 134218240;
    *(double *)int v36 = v7;
    *(_WORD *)&v36[8] = 1024;
    int v37 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Aggregating records stop %f, count ~%d",  buf,  0x12u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10188A118);
    }
    uint64_t v21 = qword_101934A78;
    double v22 = sub_101171D38();
    int v23 = *(_DWORD *)(*(void *)(a1 + 24) + 132LL);
    int v32 = 134218240;
    *(double *)uint64_t v33 = v22;
    *(_WORD *)&v33[8] = 1024;
    int v34 = v23;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v21,  2LL,  "Aggregating records stop %f, count ~%d",  COERCE_DOUBLE(&v32),  18);
    int v25 = (uint8_t *)v24;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLSpringTrackerEntry>::aggregateRecords() [T = CLSpringTrackerEntry, DataProtectionPolic y = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v24);
    if (v25 != buf) {
      free(v25);
    }
  }

  uint64_t v9 = *(void *)(a1 + 24);
  double v10 = (double)*(int *)(v9 + 132);
  if ((double)(int)sub_100E99E20(v9, (double **)a1) * 1.2 < v10)
  {
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_10188A118);
    }
    unint64_t v11 = (os_log_s *)qword_101934A78;
    if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 24);
      int v13 = *(_DWORD *)(v12 + 132);
      int v14 = sub_100E99E20(v12, (double **)a1);
      *(_DWORD *)__int128 buf = 67109376;
      *(_DWORD *)int v36 = v13;
      *(_WORD *)&v36[4] = 1024;
      *(_DWORD *)&v36[6] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10188A118);
      }
      uint64_t v26 = qword_101934A78;
      uint64_t v27 = *(void *)(a1 + 24);
      int v28 = *(_DWORD *)(v27 + 132);
      int v29 = sub_100E99E20(v27, (double **)a1);
      int v32 = 67109376;
      *(_DWORD *)uint64_t v33 = v28;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v29;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v26,  0LL,  "#Warning Number of records after aggregation is %d and it greatly exceeds the number of records estimated to be needed %d",  &v32,  14);
      __int16 v31 = (uint8_t *)v30;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "long CLActivityAggregator<CLSpringTrackerEntry>::aggregateRecords() [T = CLSpringTrackerEntry, DataProtectionPol icy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v30);
      if (v31 != buf) {
        free(v31);
      }
    }
  }

  return v5;
}

__n128 sub_100E99A24(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 73 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_100E99B0C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x49)) + 56 * (v7 % 0x49);
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  __int128 v11 = *(_OWORD *)(a2 + 32);
  *(void *)(v8 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(v8 + 16) = v10;
  *(_OWORD *)(v8 + 32) = v11;
  *(__n128 *)unint64_t v8 = result;
  ++a1[5];
  return result;
}

void sub_100E99AE0(id a1)
{
  qword_101934518 = (uint64_t)os_log_create("com.apple.locationd.Motion", "Pedometer");
}

void sub_100E99B0C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x49;
  unint64_t v4 = v2 - 73;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      int v34 = (char *)sub_1000071BC(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      __int16 v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        __int16 v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)__int16 v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_100E99DD4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100E99E20(uint64_t a1, double **a2)
{
  BOOL v3 = *a2;
  unint64_t v2 = a2[1];
  double v4 = (*a2)[1];
  double v5 = *(float *)(a1 + 136);
  if (v4 <= v5) {
    double v4 = *(float *)(a1 + 136);
  }
  uint64_t v6 = v3 + 3;
  if (v3 + 3 == v2)
  {
    uint64_t v7 = 0LL;
  }

  else
  {
    LODWORD(v7) = 0;
    double v8 = *v3;
    do
    {
      double v9 = *v6;
      double v10 = v6[1];
      v6 += 3;
      uint64_t v7 = (v7 + (int)((v9 - v8) / v4));
      if (v10 <= v5) {
        double v4 = *(float *)(a1 + 136);
      }
      else {
        double v4 = v10;
      }
      double v8 = v9;
    }

    while (v6 != v2);
  }

  if (v4 != 1.79769313e308)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188A0F8);
    }
    uint64_t v11 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "#Warning No expiration rule was added so the number of records will be unbounded.",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188A0F8);
      }
      v15[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Warning No expiration rule was added so the number of records will be unbounded.",  v15,  2);
      BOOL v14 = (uint8_t *)v13;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLActivityRecorderDb<CLSpringTrackerEntry>::estimateRecordsNeeded(const CLAggregationRules &) [T = CLSpringT rackerEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v13);
      if (v14 != buf) {
        free(v14);
      }
    }
  }

  return v7;
}

void sub_100E9A01C(id a1)
{
  qword_101934478 = (uint64_t)os_log_create("com.apple.locationd.Support", "Support");
}

CLCppContainer *sub_100E9A048(uint64_t a1)
{
  unint64_t v2 = operator new(0x38uLL);
  __int128 v3 = *(_OWORD *)(a1 + 16);
  *unint64_t v2 = *(_OWORD *)a1;
  v2[1] = v3;
  v2[2] = *(_OWORD *)(a1 + 32);
  *((void *)v2 + 6) = *(void *)(a1 + 48);
  double v5 = _NSConcreteStackBlock;
  uint64_t v6 = 3221225472LL;
  uint64_t v7 = sub_100E9A1B4;
  double v8 = &unk_10181D3D0;
  double v9 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

_BYTE *sub_100E9A0D8(_BYTE *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (!result[108])
  {
    uint64_t v7 = result;
    uint64_t v8 = *(unsigned int *)(*(void *)a2 + 32LL);
    LODWORD(v14) = *(_DWORD *)(*(void *)a3 + 32LL);
    sub_100E9A1C4(a4);
    uint64_t v10 = v9;
    uint64_t v11 = *(void *)a3 + 80LL;
    uint64_t v12 = (uint64_t **)(*(void *)a3 + 40LL);
    uint64_t v15 = (int *)(*(void *)a2 + 32LL);
    uint64_t v13 = sub_1004EF3D4(v12, v15, (uint64_t)&unk_1012CF090, &v15);
    __n128 result = (_BYTE *)(*(uint64_t (**)(_BYTE *, uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t **))(*(void *)v7 + 192LL))( v7,  v8,  &v14,  v10,  v11,  v13 + 4);
    if ((_DWORD)result) {
      return objc_msgSend( *(id *)(*(void *)a2 + 64),  "onNotification:withData:",  *(unsigned int *)(*(void *)a3 + 32),  a4,  v14);
    }
  }

  return result;
}

void sub_100E9A1B4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

void sub_100E9A1C4(void *a1)
{
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0)
  {
    sub_100E9A23C(a1);
  }

  else
  {
    objc_opt_class(&OBJC_CLASS___CLCppContainer);
    if ((objc_opt_isKindOfClass(a1, v3) & 1) != 0) {
      sub_100E9A3F4(a1);
    }
  }

void sub_100E9A23C(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2)
  {
    sub_100E9A5C8((uint64_t)&v7, a1);
    return;
  }

  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10188A158);
    }
    uint64_t v3 = qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v9 = v2;
      __int16 v10 = 2048;
      uint64_t v11 = 0LL;
      __int16 v12 = 2080;
      unint64_t v13 = 0x800000010136399FLL & 0x7FFFFFFFFFFFFFFFLL;
      double v4 = (os_log_s *)v3;
      os_log_type_t v5 = OS_LOG_TYPE_ERROR;
LABEL_12:
      _os_log_impl( (void *)&_mh_execute_header,  v4,  v5,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has changed on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  buf,  0x20u);
    }
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10188A158);
    }
    uint64_t v6 = qword_101934478;
    if (os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 134218498;
      id v9 = v2;
      __int16 v10 = 2048;
      uint64_t v11 = 0LL;
      __int16 v12 = 2080;
      unint64_t v13 = 0x800000010136399FLL & 0x7FFFFFFFFFFFFFFFLL;
      double v4 = (os_log_s *)v6;
      os_log_type_t v5 = OS_LOG_TYPE_FAULT;
      goto LABEL_12;
    }
  }

id sub_100E9A3F4(void *a1)
{
  id v2 = [a1 binaryVersion];
  [a1 sizeOfType];
  if (!v2) {
    return [a1 cppObjectPtr];
  }
  if (getenv("_INTERSILO_UNIT_TEST"))
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10188A158);
    }
    uint64_t v3 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    int v8 = 134218498;
    id v9 = v2;
    __int16 v10 = 2048;
    uint64_t v11 = 0LL;
    __int16 v12 = 2080;
    unint64_t v13 = 0x800000010136399FLL & 0x7FFFFFFFFFFFFFFFLL;
    double v4 = (os_log_s *)v3;
    os_log_type_t v5 = OS_LOG_TYPE_ERROR;
  }

  else
  {
    if (qword_101934470 != -1) {
      dispatch_once(&qword_101934470, &stru_10188A158);
    }
    uint64_t v7 = qword_101934478;
    if (!os_log_type_enabled((os_log_t)qword_101934478, OS_LOG_TYPE_FAULT)) {
      return 0LL;
    }
    int v8 = 134218498;
    id v9 = v2;
    __int16 v10 = 2048;
    uint64_t v11 = 0LL;
    __int16 v12 = 2080;
    unint64_t v13 = 0x800000010136399FLL & 0x7FFFFFFFFFFFFFFFLL;
    double v4 = (os_log_s *)v7;
    os_log_type_t v5 = OS_LOG_TYPE_FAULT;
  }

  _os_log_impl( (void *)&_mh_execute_header,  v4,  v5,  "Mismatch of versions between encoded (%llu) and decoded (%llu) objects! This is possibly because the version has cha nged on one side and possibly broken ABI compatibility. Please update your type for %s accordingly",  (uint8_t *)&v8,  0x20u);
  return 0LL;
}

void sub_100E9A5C8(uint64_t a1, void *a2)
{
  if ([a2 cppObjectPtr]
    || !objc_msgSend(objc_msgSend(a2, "compatibilityInfo"), "isEqual:", &off_1018D4820))
  {
    goto LABEL_5;
  }

  if (objc_msgSend(objc_msgSend(a2, "serialized"), "length") == (id)56)
  {
    objc_msgSend(a2, "setCppObjectPtr:", objc_msgSend(objc_msgSend(a2, "serialized"), "bytes"));
LABEL_5:
    [a2 cppObjectPtr];
    return;
  }

  uint64_t v3 = (std::__shared_weak_count *)sub_101275610();
  sub_100E9A63C(v3);
}

void sub_100E9A63C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10188A188;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100E9A650(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10188A188;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

CLCppContainer *sub_100E9A67C(uint64_t a1)
{
  id v2 = operator new(0x38uLL);
  __int128 v3 = *(_OWORD *)(a1 + 16);
  *id v2 = *(_OWORD *)a1;
  v2[1] = v3;
  v2[2] = *(_OWORD *)(a1 + 32);
  *((void *)v2 + 6) = *(void *)(a1 + 48);
  os_log_type_t v5 = _NSConcreteStackBlock;
  uint64_t v6 = 3221225472LL;
  uint64_t v7 = sub_100E9AAE0;
  int v8 = &unk_10181D3D0;
  id v9 = v2;
  return +[CLCppContainer containerWithObject:destructor:binaryVersion:typeSize:]( &OBJC_CLASS___CLCppContainer,  "containerWithObject:destructor:binaryVersion:typeSize:");
}

void sub_100E9A70C(void *a1, int *a2, void *a3)
{
  if (!*((_BYTE *)a1 + 108))
  {
    os_log_type_t v5 = a1 + 8;
    uint64_t v4 = a1[8];
    if (v4)
    {
      int v8 = *a2;
      id v9 = a1 + 8;
      do
      {
        int v10 = *(_DWORD *)(v4 + 32);
        BOOL v11 = v10 < v8;
        if (v10 >= v8) {
          __int16 v12 = (uint64_t *)v4;
        }
        else {
          __int16 v12 = (uint64_t *)(v4 + 8);
        }
        if (!v11) {
          id v9 = (void *)v4;
        }
        uint64_t v4 = *v12;
      }

      while (*v12);
      if (v9 != v5 && v8 >= *((_DWORD *)v9 + 8))
      {
        double v51 = v9;
        sub_100E9A1C4(a3);
        (*(void (**)(void *, int *, uint64_t, void *))(*a1 + 184LL))(a1, a2, v13, v9 + 10);
        uint64_t v14 = (void *)v9[5];
        if (v14 != v9 + 6)
        {
          uint64_t v15 = a1 + 11;
          uint64_t v16 = a1 + 1;
          do
          {
            uint64_t v17 = *v15;
            if (!*v15) {
              goto LABEL_25;
            }
            int v18 = *((_DWORD *)v14 + 7);
            BOOL v19 = a1 + 11;
            do
            {
              int v20 = *(_DWORD *)(v17 + 32);
              BOOL v21 = v20 < v18;
              if (v20 >= v18) {
                unint64_t v22 = (uint64_t *)v17;
              }
              else {
                unint64_t v22 = (uint64_t *)(v17 + 8);
              }
              if (!v21) {
                BOOL v19 = (uint64_t *)v17;
              }
              uint64_t v17 = *v22;
            }

            while (*v22);
            if (v19 != v15 && (int v23 = *((_DWORD *)v19 + 8), v18 >= v23))
            {
              uint64_t v50 = v19;
              sub_100E9A0D8(a1, (uint64_t)&v50, (uint64_t)&v51, a3);
              uint64_t v27 = a1[8];
              if (!v27) {
                return;
              }
              int v28 = *a2;
              int v29 = v5;
              do
              {
                int v30 = *(_DWORD *)(v27 + 32);
                BOOL v31 = v30 < v28;
                if (v30 >= v28) {
                  __int128 v32 = (uint64_t *)v27;
                }
                else {
                  __int128 v32 = (uint64_t *)(v27 + 8);
                }
                if (!v31) {
                  int v29 = (void *)v27;
                }
                uint64_t v27 = *v32;
              }

              while (*v32);
              if (v29 == v5 || v28 < *((_DWORD *)v29 + 8)) {
                return;
              }
              double v51 = v29;
              uint64_t v34 = v29[6];
              uint64_t v14 = v29 + 6;
              uint64_t v33 = v34;
              if (v34)
              {
                uint64_t v35 = v14;
                uint64_t v36 = v33;
                do
                {
                  int v37 = *(_DWORD *)(v36 + 28);
                  BOOL v38 = v37 < v23;
                  if (v37 >= v23) {
                    uint64_t v39 = (uint64_t *)v36;
                  }
                  else {
                    uint64_t v39 = (uint64_t *)(v36 + 8);
                  }
                  if (!v38) {
                    uint64_t v35 = (void *)v36;
                  }
                  uint64_t v36 = *v39;
                }

                while (*v39);
                if (v35 == v14 || v23 < *((_DWORD *)v35 + 7))
                {
                  do
                  {
                    int v40 = *(_DWORD *)(v33 + 28);
                    BOOL v41 = v23 < v40;
                    if (v23 >= v40) {
                      uint64_t v42 = (uint64_t *)(v33 + 8);
                    }
                    else {
                      uint64_t v42 = (uint64_t *)v33;
                    }
                    if (v41) {
                      uint64_t v14 = (void *)v33;
                    }
                    uint64_t v33 = *v42;
                  }

                  while (*v42);
                }

                else
                {
                  BOOL v43 = (void *)v35[1];
                  if (v43)
                  {
                    do
                    {
                      uint64_t v14 = v43;
                      BOOL v43 = (void *)*v43;
                    }

                    while (v43);
                  }

                  else
                  {
                    do
                    {
                      uint64_t v14 = (void *)v35[2];
                      BOOL v44 = *v14 == (void)v35;
                      uint64_t v35 = v14;
                    }

                    while (!v44);
                  }
                }
              }
            }

            else
            {
LABEL_25:
              uint64_t v50 = a1 + 11;
              if (qword_1019349D0 != -1) {
                dispatch_once(&qword_1019349D0, &stru_101889F60);
              }
              uint64_t v24 = (os_log_s *)qword_1019349D8;
              if (os_log_type_enabled((os_log_t)qword_1019349D8, OS_LOG_TYPE_FAULT))
              {
                unint64_t v25 = a1 + 1;
                int v26 = *((_DWORD *)v14 + 7);
                *(_DWORD *)__int128 buf = 136446466;
                double v57 = v25;
                __int16 v58 = 1026;
                int v59 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "%{public}s; unknown client %{public}d",
                  buf,
                  0x12u);
              }

              if (sub_1002921D0(115, 0))
              {
                bzero(buf, 0x65CuLL);
                if (qword_1019349D0 != -1) {
                  dispatch_once(&qword_1019349D0, &stru_101889F60);
                }
                uint64_t v45 = a1 + 1;
                int v46 = *((_DWORD *)v14 + 7);
                int v52 = 136446466;
                int v53 = v45;
                __int16 v54 = 1026;
                int v55 = v46;
                LODWORD(v49) = 18;
                _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019349D8,  17LL,  "%{public}s; unknown client %{public}d",
                  &v52,
                  v49);
                __int16 v48 = (uint8_t *)v47;
                sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLNotifier<CLSpringTrackingNotifier_Type::Notification, CLSpringTrackingNotifier_Type::Notificati onData>::invokeClientsWithData(const Notification_T &, CLCppContainer *) [Notification_T = CLSpringTra ckingNotifier_Type::Notification, NotificationData_T = CLSpringTrackingNotifier_Type::NotificationData , NotificationInfo_T = char, RegistrationInfo_T = char]",  "%s\n",  v47);
                if (v48 != buf) {
                  free(v48);
                }
              }
            }
          }

          while (v14 != v51 + 6);
        }
      }
    }
  }

void sub_100E9AAE0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  if (v1) {
    operator delete(v1);
  }
}

void *sub_100E9AAF0(void *a1, int a2)
{
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  *a1 = off_10188A1D8;
  a1[9] = off_10188A290;
  a1[45] = 0LL;
  a1[46] = 0LL;
  sub_100E9BF34((uint64_t)a1);
  return a1;
}

void sub_100E9AB7C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_100E9ABA8(uint64_t a1, char *a2, int a3, uint64_t a4, int a5, float a6)
{
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  __int16 v12 = (void *)(a1 + 8);
  *(void *)a1 = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 8));
  *__int16 v12 = &off_10182BDA0;
  *(void *)a1 = off_10188A430;
  *(void *)(a1 + 72) = off_10188A4D8;
  sub_100D8A584(a1 + 72, a2, a3, a1, a6, a4, a5, 0LL);
  *(void *)a1 = off_10188A430;
  *(void *)(a1 + 72) = off_10188A4D8;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 28sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = 12000;
  *(void *)(a1 + 288) = off_10182BD58;
  sub_1001B9AC4((void *)(a1 + 296));
  *(void *)(a1 + 296) = &off_10182BDA0;
  uint64_t v13 = *(void *)(a1 + 112);
  uint64_t v29 = a1 + 112;
  (*(void (**)(void))(v13 + 16))();
  __int16 v31 = 256;
  if (a3)
  {
    *(void *)(a1 + 264) = 0xBFF0000000000000LL;
LABEL_3:
    (*(void (**)(uint64_t))(*(void *)v29 + 24LL))(v29);
    return a1;
  }

  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)__int128 __p = *(_OWORD *)a4;
    uint64_t v28 = *(void *)(a4 + 16);
  }

  sub_100D8AF38(a1 + 72, (uint64_t)__p);
  if (SHIBYTE(v28) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v14 = sub_1006E27E8();
  sub_100413284(v14, buf);
  uint64_t v15 = (int *)(a1 + 280);
  char v16 = sub_1002A7CB0(*(uint64_t *)buf, "ActivityInMemoryBufferSize", (_DWORD *)(a1 + 280));
  uint64_t v17 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v19 = __ldaxr(p_shared_owners);
    while (__stlxr(v19 - 1, p_shared_owners));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if ((v16 & 1) == 0) {
    int *v15 = 12000;
  }
  if (qword_1019344B0 != -1) {
    dispatch_once(&qword_1019344B0, &stru_10188A518);
  }
  int v20 = (os_log_s *)qword_1019344B8;
  if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
  {
    int v21 = *v15;
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Buffer size: %d", buf, 8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188A518);
    }
    int v24 = *v15;
    v32[0] = 67109120;
    v32[1] = v24;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  2LL,  "Buffer size: %d",  v32);
    int v26 = (uint8_t *)v25;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLActivityRecorderDb<CLSpringTrackerEntry>::CLActivityRecorderDb(const char *, BOOL, float, const std::string &, c onst CLSqliteDatabase::SqlitePropertyPersistence) [T = CLSpringTrackerEntry, DataProtectionPolicy = CLActivityDB:: ClassCDataProtectionPolicy]",  "%s\n",  v25);
    if (v26 != buf) {
      free(v26);
    }
  }

  int v22 = HIBYTE(v31);
  *(void *)(a1 + 264) = 0xBFF0000000000000LL;
  if (v22)
  {
    if ((_BYTE)v31)
    {
      pthread_mutex_unlock(v30);
      return a1;
    }

    goto LABEL_3;
  }

  return a1;
}

void sub_100E9AF50( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24)
{
  v24[36] = off_10182BD58;
  sub_1001B9C98(v27);
  sub_1003580A0(v26);
  sub_100D8A88C(a12);
  *int v24 = off_10182BD58;
  sub_1001B9C98(v25);
  _Unwind_Resume(a1);
}

void sub_100E9AFF4()
{
}

void *sub_100E9AFFC(void *a1)
{
  a1[9] = off_10188A4D8;
  uint64_t v2 = (uint64_t)(a1 + 9);
  *a1 = off_10188A430;
  a1[36] = off_10182BD58;
  sub_1001B9C98(a1 + 37);
  sub_1003580A0(a1 + 22);
  sub_100D8A88C(v2);
  *a1 = off_10182BD58;
  sub_1001B9C98(a1 + 1);
  return a1;
}

void *sub_100E9B07C(uint64_t a1)
{
  return sub_100E9AFFC((void *)(a1 - 72));
}

void sub_100E9B084(void *a1)
{
  uint64_t v1 = sub_100E9AFFC(a1);
  operator delete(v1);
}

void sub_100E9B098(uint64_t a1)
{
  uint64_t v1 = sub_100E9AFFC((void *)(a1 - 72));
  operator delete(v1);
}

uint64_t sub_100E9B0B0(uint64_t *a1, uint64_t a2)
{
  if (*(double *)(*(void *)(a2 + 8) - 16LL) != 1.79769313e308)
  {
    if (qword_101934820 != -1) {
      dispatch_once(&qword_101934820, &stru_10188A340);
    }
    int v10 = (os_log_s *)qword_101934828;
    if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "Error expiring records.", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934820 != -1) {
        dispatch_once(&qword_101934820, &stru_10188A340);
      }
      v16[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934828,  17LL,  "Error expiring records.",  v16,  2);
      uint64_t v15 = (uint8_t *)v14;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual long CLSpringTrackerRecorderDb::aggregateRecords(const CLAggregationRules &)",  "%s\n",  v14);
      if (v15 != buf) {
        free(v15);
      }
    }

    return -1LL;
  }

  sub_1003C0454(a1[10]);
  double Current = CFAbsoluteTimeGetCurrent();
  sub_1003C0D54(a1[10], "DELETE FROM SleepHistory WHERE startTime < ?", buf);
  uint64_t v5 = *(void *)buf;
  char v6 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
  if (sub_1003B7480(v6, 1, Current - *(double *)(*(void *)(a2 + 8) - 24LL)))
  {
    uint64_t v7 = a1[10];
    int v8 = (sqlite3_stmt *)sub_100019240(v5);
    sub_1003BB2BC(v7, v8);
    uint64_t v9 = (*(int (**)(uint64_t *))(*a1 + 160))(a1);
  }

  else
  {
    uint64_t v9 = -1LL;
  }

  sub_1003C05BC(a1[10]);
  uint64_t v11 = a1[10];
  else {
    uint64_t v12 = *(void *)(v11 + 88);
  }
  sub_1003C1EC0(v11, v12);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return v9;
}

void sub_100E9B324(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100E9B34C(uint64_t a1, uint64_t a2)
{
  return sub_100E9B0B0((uint64_t *)(a1 - 72), a2);
}

uint64_t sub_100E9B354(uint64_t a1, void **a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "SELECT * from SleepHistory ORDER BY id ASC", &v29);
    uint64_t v5 = v29;
    uint64_t v27 = v29;
    sub_1003C0454(*(void *)(a1 + 80));
    sub_100405344(a1, src);
    while (!sub_100E9B5C0(&v27, (uint64_t)&v29))
    {
      uuid_copy((unsigned __int8 *)&v29 + 8, src);
      char v6 = (char *)a2[1];
      uint64_t v7 = (char *)a2[2];
      if (v6 >= v7)
      {
        uint64_t v12 = 0x6DB6DB6DB6DB6DB7LL * ((v6 - (_BYTE *)*a2) >> 3);
        unint64_t v13 = v12 + 1;
        unint64_t v14 = 0x6DB6DB6DB6DB6DB7LL * ((v7 - (_BYTE *)*a2) >> 3);
        if (2 * v14 > v13) {
          unint64_t v13 = 2 * v14;
        }
        if (v14 >= 0x249249249249249LL) {
          unint64_t v15 = 0x492492492492492LL;
        }
        else {
          unint64_t v15 = v13;
        }
        if (v15) {
          char v16 = (char *)sub_1000AC8F0((uint64_t)(a2 + 2), v15);
        }
        else {
          char v16 = 0LL;
        }
        uint64_t v17 = &v16[56 * v12];
        __int128 v18 = v29;
        __int128 v19 = v30;
        __int128 v20 = v31;
        *((void *)v17 + 6) = v32;
        *((_OWORD *)v17 + 1) = v19;
        *((_OWORD *)v17 + 2) = v20;
        *(_OWORD *)uint64_t v17 = v18;
        int v22 = (char *)*a2;
        int v21 = (char *)a2[1];
        int v23 = v17;
        if (v21 != *a2)
        {
          do
          {
            __int128 v24 = *(_OWORD *)(v21 - 56);
            __int128 v25 = *(_OWORD *)(v21 - 40);
            __int128 v26 = *(_OWORD *)(v21 - 24);
            *((void *)v23 - 1) = *((void *)v21 - 1);
            *(_OWORD *)(v23 - 24) = v26;
            *(_OWORD *)(v23 - 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v25;
            *(_OWORD *)(v23 - 56) = v24;
            v23 -= 56;
            v21 -= 56;
          }

          while (v21 != v22);
          int v21 = (char *)*a2;
        }

        uint64_t v11 = v17 + 56;
        *a2 = v23;
        a2[1] = v17 + 56;
        a2[2] = &v16[56 * v15];
        if (v21) {
          operator delete(v21);
        }
      }

      else
      {
        __int128 v8 = v29;
        __int128 v9 = v30;
        __int128 v10 = v31;
        *((void *)v6 + 6) = v32;
        *((_OWORD *)v6 + 1) = v9;
        *((_OWORD *)v6 + 2) = v10;
        *(_OWORD *)char v6 = v8;
        uint64_t v11 = v6 + 56;
      }

      a2[1] = v11;
    }

    uint64_t result = sub_1003C05BC(*(void *)(a1 + 80));
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100E9B590(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E9B5C0(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(*a1);
  int v5 = sqlite3_step(v4);
  if (v5 == 101) {
    return 1LL;
  }
  if (v5 != 100) {
    return 2LL;
  }
  char v6 = (sqlite3_stmt *)sub_100019240(*a1);
  *(void *)a2 = sqlite3_column_int(v6, 0);
  uint64_t v7 = (sqlite3_stmt *)sub_100019240(*a1);
  *(double *)(a2 + 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = sqlite3_column_double(v7, 1);
  __int128 v8 = (sqlite3_stmt *)sub_100019240(*a1);
  int v9 = sqlite3_column_int(v8, 2);
  uint64_t result = 0LL;
  *(void *)(a2 + 48) = v9;
  return result;
}

uint64_t sub_100E9B658(uint64_t *a1, uint64_t a2, void **a3)
{
  if ((sub_100D8A92C(a1 + 9) & 1) != 0)
  {
    if (sub_1003B76B4(a1[10]))
    {
      sub_100405344((uint64_t)a1, uu1);
      if (uuid_is_null((const unsigned __int8 *)(a2 + 8))
        || uuid_compare(uu1, (const unsigned __int8 *)(a2 + 8))
        || !(*(unsigned int (**)(uint64_t *, void *))(*a1 + 104))(a1, v49) && v49[0] < *(void *)a2)
      {
        if (qword_101934820 != -1) {
          dispatch_once(&qword_101934820, &stru_10188A340);
        }
        char v6 = (os_log_s *)qword_101934828;
        if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Non-existent query record, returning all records.",  buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934820 != -1) {
            dispatch_once(&qword_101934820, &stru_10188A340);
          }
          LOWORD(v44) = 0;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934828,  16LL,  "Non-existent query record, returning all records.",  &v44,  2);
          int v37 = (uint8_t *)v36;
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLSpringTrackerRecorderDb::querySince(const CLSpringTrackerEntry &, std::vector<CLSpringTrackerEntry> &) const",  "%s\n",  v36);
          if (v37 != buf) {
            free(v37);
          }
        }

        (*(void (**)(uint64_t *, void **))(*a1 + 40))(a1, a3);
      }

      else
      {
        sub_1003C0D54(a1[10], "SELECT * FROM SleepHistory WHERE id >= ? ORDER BY id ASC", buf);
        uint64_t v10 = *(void *)buf;
        uint64_t v43 = *(void *)buf;
        uint64_t v11 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)buf);
        if (sub_1003C28BC(v11, 1, *(_DWORD *)a2))
        {
          while (!sub_100E9B5C0(&v43, (uint64_t)&v44))
          {
            uuid_copy((unsigned __int8 *)&v44 + 8, uu1);
            uint64_t v12 = (char *)a3[1];
            unint64_t v13 = (char *)a3[2];
            if (v12 >= v13)
            {
              uint64_t v18 = 0x6DB6DB6DB6DB6DB7LL * ((v12 - (_BYTE *)*a3) >> 3);
              unint64_t v19 = v18 + 1;
              unint64_t v20 = 0x6DB6DB6DB6DB6DB7LL * ((v13 - (_BYTE *)*a3) >> 3);
              if (2 * v20 > v19) {
                unint64_t v19 = 2 * v20;
              }
              if (v20 >= 0x249249249249249LL) {
                unint64_t v21 = 0x492492492492492LL;
              }
              else {
                unint64_t v21 = v19;
              }
              if (v21) {
                int v22 = (char *)sub_1000AC8F0((uint64_t)(a3 + 2), v21);
              }
              else {
                int v22 = 0LL;
              }
              int v23 = &v22[56 * v18];
              __int128 v24 = v44;
              __int128 v25 = v45;
              __int128 v26 = v46;
              *((void *)v23 + 6) = v47;
              *((_OWORD *)v23 + 1) = v25;
              *((_OWORD *)v23 + 2) = v26;
              *(_OWORD *)int v23 = v24;
              uint64_t v28 = (char *)*a3;
              uint64_t v27 = (char *)a3[1];
              __int128 v29 = v23;
              if (v27 != *a3)
              {
                do
                {
                  __int128 v30 = *(_OWORD *)(v27 - 56);
                  __int128 v31 = *(_OWORD *)(v27 - 40);
                  __int128 v32 = *(_OWORD *)(v27 - 24);
                  *((void *)v29 - 1) = *((void *)v27 - 1);
                  *(_OWORD *)(v29 - 24) = v32;
                  *(_OWORD *)(v29 - 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v31;
                  *(_OWORD *)(v29 - 56) = v30;
                  v29 -= 56;
                  v27 -= 56;
                }

                while (v27 != v28);
                uint64_t v27 = (char *)*a3;
              }

              uint64_t v17 = v23 + 56;
              *a3 = v29;
              a3[1] = v23 + 56;
              a3[2] = &v22[56 * v21];
              if (v27) {
                operator delete(v27);
              }
            }

            else
            {
              __int128 v14 = v44;
              __int128 v15 = v45;
              __int128 v16 = v46;
              *((void *)v12 + 6) = v47;
              *((_OWORD *)v12 + 1) = v15;
              *((_OWORD *)v12 + 2) = v16;
              *(_OWORD *)uint64_t v12 = v14;
              uint64_t v17 = v12 + 56;
            }

            a3[1] = v17;
          }
        }

        else
        {
          if (qword_101934820 != -1) {
            dispatch_once(&qword_101934820, &stru_10188A340);
          }
          uint64_t v33 = (os_log_s *)qword_101934828;
          if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_FAULT, "Error querying records.", buf, 2u);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(buf, 0x65CuLL);
            if (qword_101934820 != -1) {
              dispatch_once(&qword_101934820, &stru_10188A340);
            }
            __int16 v42 = 0;
            _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934828,  17LL,  "Error querying records.",  &v42,  2);
            BOOL v41 = (uint8_t *)v40;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLSpringTrackerRecorderDb::querySince(const CLSpringTrackerEntry &, std::vector<CLSpringTrackerEntry> &) const",  "%s\n",  v40);
            if (v41 != buf) {
              free(v41);
            }
          }
        }

        if (v10) {
          (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
        }
      }

      return 100LL;
    }

    else
    {
      if (qword_101934820 != -1) {
        dispatch_once(&qword_101934820, &stru_10188A340);
      }
      int v9 = (os_log_s *)qword_101934828;
      if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "DB UUID un-initialized", buf, 2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934820 != -1) {
          dispatch_once(&qword_101934820, &stru_10188A340);
        }
        LOWORD(v49[0]) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934828,  17LL,  "DB UUID un-initialized",  v49,  2);
        uint64_t v39 = (uint8_t *)v38;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "CMError CLSpringTrackerRecorderDb::querySince(const CLSpringTrackerEntry &, std::vector<CLSpringTrackerEntry> &) const",  "%s\n",  v38);
        if (v39 != buf) {
          free(v39);
        }
      }

      return 103LL;
    }
  }

  else
  {
    if (qword_101934820 != -1) {
      dispatch_once(&qword_101934820, &stru_10188A340);
    }
    __int128 v8 = (os_log_s *)qword_101934828;
    if (os_log_type_enabled((os_log_t)qword_101934828, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "History not accessible", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934820 != -1) {
        dispatch_once(&qword_101934820, &stru_10188A340);
      }
      LOWORD(v49[0]) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934828,  2LL,  "History not accessible",  v49,  2);
      uint64_t v35 = (uint8_t *)v34;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CMError CLSpringTrackerRecorderDb::querySince(const CLSpringTrackerEntry &, std::vector<CLSpringTrackerEntry> &) const",  "%s\n",  v34);
      if (v35 != buf) {
        free(v35);
      }
    }

    return 109LL;
  }

void sub_100E9BDDC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E9BE0C(uint64_t a1)
{
  uint64_t v3 = v8;
  uint64_t v4 = (sqlite3_stmt *)sub_100019240(v8);
  int v5 = sqlite3_step(v4);
  if (v5 == 100)
  {
    char v6 = (sqlite3_stmt *)sub_100019240(v3);
    uint64_t v1 = sqlite3_column_int(v6, 0);
  }

  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v5 != 100) {
    return 0xFFFFFFFFLL;
  }
  return v1;
}

void sub_100E9BEAC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E9BED0(uint64_t a1)
{
  return sub_100E9BE0C(a1 - 72);
}

void *sub_100E9BED8(uint64_t a1, uint64_t a2, const void *a3)
{
  if (a2 && a3)
  {

    *(void *)(a1 + 36sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = a2;
    char v6 = *(const void **)(a1 + 368);
    if (v6) {
      _Block_release(v6);
    }
    uint64_t result = _Block_copy(a3);
    *(void *)(a1 + 368) = result;
  }

  else
  {
    uint64_t v8 = sub_101275784();
    return (void *)sub_100E9BF34(v8);
  }

  return result;
}

uint64_t sub_100E9BF34(uint64_t a1)
{
  uint64_t result = sub_1003C1048(*(void *)(a1 + 80));
  if ((_DWORD)result) {
    return sub_1003B59A0( *(void *)(a1 + 80),  "SleepHistory",  (const char **)&off_10188A360,  (const std::string::value_type **)off_1019916A0,  0);
  }
  return result;
}

uint64_t sub_100E9BF88(uint64_t a1)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "DELETE FROM SleepHistory", &v8);
    uint64_t v3 = v8;
    uint64_t v4 = *(void *)(a1 + 80);
    int v5 = (sqlite3_stmt *)sub_100019240(v8);
    sub_1003BB2BC(v4, v5);
    uint64_t v6 = *(void *)(a1 + 80);
    else {
      uint64_t v7 = *(void *)(v6 + 88);
    }
    uint64_t result = sub_1003C1EC0(v6, v7);
    if (v3) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  return result;
}

void sub_100E9C01C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E9C03C(uint64_t a1)
{
  return sub_100E9BF88(a1 - 72);
}

uint64_t sub_100E9C044(uint64_t *a1, uint64_t a2)
{
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    (*(void (**)(uint64_t *, uint64_t, uint64_t))(*a1 + 120))(a1, a2, 1LL);
    sub_1003C0D54(a1[10], "DELETE FROM SleepHistory WHERE startTime > ?", &v11);
    uint64_t v5 = v11;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v11);
    if (sub_1003B7480(v6, 1, *(double *)(a2 + 40)))
    {
      uint64_t v7 = a1[10];
      uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
      sub_1003BB2BC(v7, v8);
    }

    uint64_t v9 = a1[10];
    else {
      uint64_t v10 = *(void *)(v9 + 88);
    }
    uint64_t result = sub_1003C1EC0(v9, v10);
    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100E9C10C(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E9C12C(uint64_t a1, double a2)
{
  uint64_t result = sub_100D8A92C(a1 + 72);
  if ((_DWORD)result)
  {
    sub_1003C0D54(*(void *)(a1 + 80), "UPDATE SleepHistory SET startTime = startTime + ?", &v9);
    uint64_t v5 = v9;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v9);
    uint64_t result = sub_1003B7480(v6, 1, a2);
    if ((_DWORD)result)
    {
      uint64_t v7 = *(void *)(a1 + 80);
      uint64_t v8 = (sqlite3_stmt *)sub_100019240(v5);
      uint64_t result = sub_1003BB2BC(v7, v8);
    }

    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100E9C1C4(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E9C1E4(uint64_t *a1, __int128 *a2)
{
  uint64_t result = sub_100D8A92C(a1 + 9);
  if ((_DWORD)result)
  {
    sub_1003C0D54(a1[10], "INSERT INTO SleepHistory (startTime, eventType) VALUES (?, ?)", &v18);
    uint64_t v5 = v18;
    uint64_t v6 = (sqlite3_stmt *)sub_100019240(v18);
    uint64_t result = sub_1003B7480(v6, 1, *((double *)a2 + 5));
    if ((_DWORD)result)
    {
      uint64_t v7 = (sqlite3_stmt *)sub_100019240(v5);
      uint64_t result = sub_1003C28BC(v7, 2, *((_DWORD *)a2 + 12));
      if ((_DWORD)result)
      {
        uint64_t v8 = a1[10];
        uint64_t v9 = (sqlite3_stmt *)sub_100019240(v5);
        uint64_t result = sub_1003BB2BC(v8, v9);
        if ((_DWORD)result)
        {
          if (a1[45] && a1[46])
          {
            __int128 v10 = a2[1];
            __int128 v18 = *a2;
            __int128 v19 = v10;
            __int128 v20 = a2[2];
            uint64_t v21 = *((void *)a2 + 6);
            sub_100405344((uint64_t)a1, src);
            uuid_copy((unsigned __int8 *)&v18 + 8, src);
            v12[1] = 3221225472LL;
            __int128 v13 = v18;
            uint64_t v11 = (void *)a1[45];
            v12[0] = _NSConcreteStackBlock;
            _OWORD v12[2] = sub_100E9C38C;
            uint64_t v12[3] = &unk_10188A2D0;
            _DWORD v12[4] = a1;
            __int128 v14 = v19;
            __int128 v15 = v20;
            uint64_t v16 = v21;
            uint64_t result = (uint64_t)[v11 async:v12];
          }
        }
      }
    }

    if (v5) {
      return (*(uint64_t (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
    }
  }

  return result;
}

void sub_100E9C360(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E9C38C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 368LL);
  __int128 v2 = *(_OWORD *)(a1 + 72);
  v4[1] = *(_OWORD *)(a1 + 56);
  v4[2] = v2;
  uint64_t v5 = *(void *)(a1 + 88);
  v4[0] = *(_OWORD *)(a1 + 40);
  return (*(uint64_t (**)(uint64_t, _OWORD *))(v1 + 16))(v1, v4);
}

uint64_t sub_100E9C404()
{
  return 0LL;
}

uint64_t sub_100E9C40C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)src;
  uint64_t v7 = *(void *)src;
  uint64_t v5 = sub_100E9B5C0(&v7, a2);
  if (!(_DWORD)v5)
  {
    sub_100405344(a1, src);
    uuid_copy((unsigned __int8 *)(a2 + 8), src);
  }

  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  return v5;
}

void sub_100E9C4DC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100E9C508(void *a1, void **a2, double a3, double a4)
{
  uint64_t v8 = (*(void *(**)(void **__return_ptr))(*a1 + 64LL))(v45);
  if ((SHIBYTE(v46) & 0x80000000) == 0)
  {
    if (HIBYTE(v46)) {
      goto LABEL_3;
    }
LABEL_39:
    sub_10127590C(v8);
    __break(1u);
  }

  int v40 = v45[1];
  operator delete(v45[0]);
  if (!v40) {
    goto LABEL_39;
  }
LABEL_3:
  sub_10000CE18((uint64_t)v45);
  uint64_t v9 = sub_10000CF44(&v46, (uint64_t)"SELECT * FROM ", 14LL);
  (*(void (**)(_BYTE *__return_ptr, void *))(*a1 + 64LL))(v49, a1);
  if (v49[23] >= 0) {
    __int128 v10 = v49;
  }
  else {
    __int128 v10 = *(_BYTE **)v49;
  }
  if (v49[23] >= 0) {
    uint64_t v11 = v49[23];
  }
  else {
    uint64_t v11 = *(void *)&v49[8];
  }
  uint64_t v12 = sub_10000CF44(v9, (uint64_t)v10, v11);
  sub_10000CF44(v12, (uint64_t)" WHERE startTime > ? and startTime <= ? ORDER BY rowid ASC", 58LL);
  if ((v49[23] & 0x80000000) != 0) {
    operator delete(*(void **)v49);
  }
  uint64_t v13 = a1[10];
  std::stringbuf::str((std::stringbuf::string_type *)v49, &v47);
  if (v49[23] >= 0) {
    __int128 v14 = v49;
  }
  else {
    __int128 v14 = *(char **)v49;
  }
  sub_1003C0D54(v13, v14, &v43);
  uint64_t v15 = v43;
  uint64_t v43 = 0LL;
  uint64_t v44 = v15;
  if ((v49[23] & 0x80000000) != 0) {
    operator delete(*(void **)v49);
  }
  uint64_t v16 = (sqlite3_stmt *)sub_100019240(v15);
  if (sub_1003B7480(v16, 1, a3) && (uint64_t v17 = (sqlite3_stmt *)sub_100019240(v15), sub_1003B7480(v17, 2, a4)))
  {
    while (1)
    {
      uint64_t v18 = sub_1001BA11C((uint64_t)a1, &v44, (uint64_t)v49);
      if ((_DWORD)v18) {
        break;
      }
      __int128 v19 = (char *)a2[1];
      __int128 v20 = (char *)a2[2];
      if (v19 >= v20)
      {
        uint64_t v25 = 0x6DB6DB6DB6DB6DB7LL * ((v19 - (_BYTE *)*a2) >> 3);
        unint64_t v26 = v25 + 1;
        unint64_t v27 = 0x6DB6DB6DB6DB6DB7LL * ((v20 - (_BYTE *)*a2) >> 3);
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x249249249249249LL) {
          unint64_t v28 = 0x492492492492492LL;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28) {
          __int128 v29 = (char *)sub_1000AC8F0((uint64_t)(a2 + 2), v28);
        }
        else {
          __int128 v29 = 0LL;
        }
        __int128 v30 = &v29[56 * v25];
        __int128 v31 = *(_OWORD *)v49;
        __int128 v32 = *(_OWORD *)&v49[16];
        __int128 v33 = v50;
        *((void *)v30 + 6) = v51;
        *((_OWORD *)v30 + 1) = v32;
        *((_OWORD *)v30 + 2) = v33;
        *(_OWORD *)__int128 v30 = v31;
        uint64_t v35 = (char *)*a2;
        uint64_t v34 = (char *)a2[1];
        uint64_t v36 = v30;
        if (v34 != *a2)
        {
          do
          {
            __int128 v37 = *(_OWORD *)(v34 - 56);
            __int128 v38 = *(_OWORD *)(v34 - 40);
            __int128 v39 = *(_OWORD *)(v34 - 24);
            *((void *)v36 - 1) = *((void *)v34 - 1);
            *(_OWORD *)(v36 - 24) = v39;
            *(_OWORD *)(v36 - 4sub_100222B94(v28, (uint64_t)"CLBatchedSensor.onDeviceMotionData", 0) = v38;
            *(_OWORD *)(v36 - 56) = v37;
            v36 -= 56;
            v34 -= 56;
          }

          while (v34 != v35);
          uint64_t v34 = (char *)*a2;
        }

        __int128 v24 = v30 + 56;
        *a2 = v36;
        a2[1] = v30 + 56;
        a2[2] = &v29[56 * v28];
        if (v34) {
          operator delete(v34);
        }
      }

      else
      {
        __int128 v21 = *(_OWORD *)v49;
        __int128 v22 = *(_OWORD *)&v49[16];
        __int128 v23 = v50;
        *((void *)v19 + 6) = v51;
        *((_OWORD *)v19 + 1) = v22;
        *((_OWORD *)v19 + 2) = v23;
        *(_OWORD *)__int128 v19 = v21;
        __int128 v24 = v19 + 56;
      }

      a2[1] = v24;
    }

    uint64_t v15 = v44;
  }

  else
  {
    uint64_t v18 = 2LL;
  }

  uint64_t v44 = 0LL;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
  }
  *(void **)((char *)v45
  uint64_t v46 = v41;
  std::streambuf::~streambuf(&v47);
  std::ios::~ios(&v48);
  return v18;
}

void sub_100E9C8B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100E9C924(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 112);
  uint64_t v2 = a1 + 112;
  uint64_t v4 = v2 - 40;
  uint64_t v40 = v2;
  (*(void (**)(void))(v3 + 16))();
  if (sub_100D8A92C(v4))
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188A518);
    }
    uint64_t v5 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)uint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      uint64_t v46 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Database is already opened., name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(void *)(a1 + 216))
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188A518);
      }
      uint64_t v7 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        uint64_t v8 = *(void *)(a1 + 216);
        *(_DWORD *)__int128 buf = 134349056;
        *(void *)uint64_t v44 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188A518);
        }
        uint64_t v35 = *(void *)(a1 + 216);
        int v41 = 134349056;
        uint64_t v42 = v35;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "In memory buffer should have been empty! Instead it had a size of %{public}lu.",  &v41,  12);
        __int128 v37 = (uint8_t *)v36;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual BOOL CLActivityRecorderDb<CLSpringTrackerEntry>::setDatabaseAccessible() [T = CLSpringTrackerEntry, Da taProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v36);
        if (v37 != buf) {
          free(v37);
        }
      }
    }

    uint64_t v9 = 1LL;
    goto LABEL_63;
  }

  sub_1001BA070(a1);
  uint64_t v9 = sub_100D8A92C(v4);
  if ((_DWORD)v9)
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188A518);
    }
    __int128 v10 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = (void *)(a1 + 88);
      uint64_t v12 = *(void *)(a1 + 216);
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)uint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      uint64_t v46 = v11;
      __int16 v47 = 2049;
      uint64_t v48 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Inserting entries into database, name:%{public, location:escape_only}s, size:%{private}llu}",  buf,  0x26u);
    }

    sub_1003C0454(*(void *)(a1 + 80));
    unint64_t v13 = *(void *)(a1 + 208);
    uint64_t v14 = *(void *)(a1 + 184);
    uint64_t v15 = *(void *)(a1 + 192);
    uint64_t v16 = (void *)(v14 + 8 * (v13 / 0x49));
    unsigned int v39 = v9;
    if (v15 == v14) {
      unint64_t v17 = 0LL;
    }
    else {
      unint64_t v17 = *v16 + 56 * (v13 % 0x49);
    }
    while (1)
    {
      if (v15 == v14)
      {
        unint64_t v23 = 0LL;
      }

      else
      {
        unint64_t v22 = *(void *)(a1 + 216) + *(void *)(a1 + 208);
        unint64_t v23 = *(void *)(v14 + 8 * (v22 / 0x49)) + 56 * (v22 % 0x49);
      }

      if (v17 == v23) {
        break;
      }
      if (qword_101934510 != -1) {
        dispatch_once(&qword_101934510, &stru_10188A538);
      }
      __int128 v24 = (os_log_s *)qword_101934518;
      if (os_log_type_enabled((os_log_t)qword_101934518, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Adding from buffer to db.", buf, 2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934510 != -1) {
          dispatch_once(&qword_101934510, &stru_10188A538);
        }
        LOWORD(v41) = 0;
        LODWORD(v38) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934518,  2LL,  "Adding from buffer to db.",  &v41,  v38);
        unint64_t v27 = (uint8_t *)v26;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLActivityRecorderDb<CLSpringTrackerEntry>::setDatabaseAccessible() [T = CLSpringTrackerEntry, Da taProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v26);
        if (v27 != buf) {
          free(v27);
        }
      }

      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 80LL))(a1, v17, 1LL);
      v17 += 56LL;
      if (v17 - *v16 == 4088)
      {
        unint64_t v25 = v16[1];
        ++v16;
        unint64_t v17 = v25;
      }

      uint64_t v14 = *(void *)(a1 + 184);
      uint64_t v15 = *(void *)(a1 + 192);
    }

    sub_1003C05BC(*(void *)(a1 + 80));
    uint64_t v9 = v39;
  }

  else
  {
    if (qword_1019344B0 != -1) {
      dispatch_once(&qword_1019344B0, &stru_10188A518);
    }
    uint64_t v18 = (os_log_s *)qword_1019344B8;
    if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
    {
      __int128 v19 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)uint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      uint64_t v46 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188A518);
      }
    }

    __int128 v20 = (os_log_s *)qword_1019344B8;
    if (os_signpost_enabled((os_log_t)qword_1019344B8))
    {
      __int128 v21 = (void *)(a1 + 88);
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)uint64_t v44 = 0;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = "";
      __int16 v45 = 2082;
      uint64_t v46 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Unexpected error condition! Device has been unlocked but database remains unreadable!",  "{msg%{public}.0s:Unexpected error condition! Device has been unlocked but database remains unreadable!, name:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    *(_BYTE *)(a1 + 128) = 1;
  }

  unint64_t v28 = *(void ***)(a1 + 184);
  uint64_t v29 = *(void *)(a1 + 192);
  *(void *)(a1 + 216) = 0LL;
  unint64_t v30 = v29 - (void)v28;
  if (v30 >= 0x11)
  {
    do
    {
      operator delete(*v28);
      uint64_t v31 = *(void *)(a1 + 192);
      unint64_t v28 = (void **)(*(void *)(a1 + 184) + 8LL);
      *(void *)(a1 + 184) = v28;
      unint64_t v30 = v31 - (void)v28;
    }

    while (v30 > 0x10);
  }

  if (v30 >> 3 == 1)
  {
    uint64_t v32 = 36LL;
  }

  else
  {
    if (v30 >> 3 != 2) {
      goto LABEL_61;
    }
    uint64_t v32 = 73LL;
  }

  *(void *)(a1 + 208) = v32;
LABEL_61:
  __int128 v33 = *(void **)(a1 + 144);
  if (v33)
  {

    *(void *)(a1 + 144) = 0LL;
  }

void sub_100E9D058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

__n128 sub_100E9D08C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  __int128 v4 = *(_OWORD *)(a3 + 16);
  __int128 v5 = *(_OWORD *)(a3 + 32);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

id *sub_100E9D0A8(uint64_t a1, __int128 *a2, char a3)
{
  v34[0] = (id)os_transaction_create("CLActivityRecorderDb::sanitizeAndStoreRecordUL");
  v34[1] = 0LL;
  if (*(double *)(a1 + 264) > 0.0
    && (*(unsigned int (**)(uint64_t, uint64_t, __int128 *))(*(void *)a1 + 136LL))(a1, a1 + 224, a2))
  {
    (*(void (**)(uint64_t, uint64_t, __int128 *))(*(void *)a1 + 72LL))(a1, a1 + 224, a2);
    return sub_1001BA1BC(v34);
  }

  if ((a3 & 1) == 0) {
    sub_1003C0454(*(void *)(a1 + 80));
  }
  int v6 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)a1 + 104LL))(a1, v43);
  if (v6 == 1)
  {
    (*(void (**)(uint64_t, __int128 *, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

  else
  {
    if (v6)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188A518);
      }
      uint64_t v14 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_FAULT,  "Failed to insert record due to failure from reading the most recent entry.",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188A518);
        }
        LOWORD(v35) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  17LL,  "Failed to insert record due to failure from reading the most recent entry.",  &v35,  2);
        uint64_t v16 = (uint8_t *)v15;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLActivityRecorderDb<CLSpringTrackerEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSpri ngTrackerEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v15);
        if (v16 != buf) {
          free(v16);
        }
      }

      goto LABEL_43;
    }

    double v7 = *((double *)a2 + 5);
    double v8 = v44;
    double v9 = v7 - v44;
    if (v7 - v44 < 0.0) {
      double v9 = -(v7 - v44);
    }
    if (v9 > 604800.0)
    {
      if (qword_1019344B0 != -1) {
        dispatch_once(&qword_1019344B0, &stru_10188A518);
      }
      __int128 v10 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *((void *)a2 + 5);
        *(_DWORD *)__int128 buf = 134349312;
        double v40 = v44;
        __int16 v41 = 2050;
        uint64_t v42 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  buf,  0x16u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188A518);
        }
        uint64_t v25 = *((void *)a2 + 5);
        int v35 = 134349312;
        double v36 = v44;
        __int16 v37 = 2050;
        uint64_t v38 = v25;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  0LL,  "#Notice Potential CM database inconsistency, time jump %{public}lf %{public}lf",  &v35,  22);
        unint64_t v27 = (uint8_t *)v26;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLSpringTrackerEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSpri ngTrackerEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v26);
        if (v27 != buf) {
          free(v27);
        }
      }

      CLWriteStackshot("Potential CM database inconsistency, time jump", 0LL);
      double v7 = *((double *)a2 + 5);
      double v8 = v44;
    }

    if (v7 < v8)
    {
      if (v8 - v7 < 10.0)
      {
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188A518);
        }
        uint64_t v12 = (os_log_s *)qword_1019344B8;
        if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
        {
          double v13 = *((double *)a2 + 5);
          *(_DWORD *)__int128 buf = 134217984;
          double v40 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  buf,  0xCu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019344B0 != -1) {
            dispatch_once(&qword_1019344B0, &stru_10188A518);
          }
          double v28 = *((double *)a2 + 5);
          int v35 = 134217984;
          double v36 = v28;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the recent past.  Deleting records after %f.",  COERCE_DOUBLE(&v35));
          unint64_t v30 = (uint8_t *)v29;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLSpringTrackerEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSp ringTrackerEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v29);
          if (v30 != buf) {
            free(v30);
          }
        }

        (*(void (**)(uint64_t, __int128 *))(*(void *)a1 + 88LL))(a1, a2);
        goto LABEL_42;
      }

      double v17 = v7 - v8;
      double v18 = *(float *)(a1 + 136);
      if (qword_1019344B0 != -1)
      {
        double v33 = *(float *)(a1 + 136);
        dispatch_once(&qword_1019344B0, &stru_10188A518);
        double v18 = v33;
      }

      double v19 = v17 - v18;
      __int128 v20 = (os_log_s *)qword_1019344B8;
      if (os_log_type_enabled((os_log_t)qword_1019344B8, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)__int128 buf = 134217984;
        double v40 = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019344B0 != -1) {
          dispatch_once(&qword_1019344B0, &stru_10188A518);
        }
        int v35 = 134217984;
        double v36 = v19;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019344B8,  1LL,  "Entry being recorded has a startTime in the substantial past.  Shift records by %f.",  COERCE_DOUBLE(&v35));
        uint64_t v32 = (uint8_t *)v31;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLActivityRecorderDb<CLSpringTrackerEntry>::sanitizeAndStoreRecordUL(const T &, BOOL) [T = CLSpri ngTrackerEntry, DataProtectionPolicy = CLActivityDB::ClassCDataProtectionPolicy]",  "%s\n",  v31);
        if (v32 != buf) {
          free(v32);
        }
      }

      (*(void (**)(uint64_t, double))(*(void *)a1 + 96LL))(a1, v19);
    }

    (*(void (**)(uint64_t, _BYTE *, uint64_t, __int128 *))(*(void *)a1 + 144LL))(a1, v43, a1 + 224, a2);
    (*(void (**)(uint64_t, __int128 *, uint64_t))(*(void *)a1 + 120LL))(a1, a2, 1LL);
  }

void sub_100E9D7F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}