void sub_100099CFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, void *a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *__p, uint64_t a36, int a37, __int16 a38, char a39, char a40)
{
  uint64_t v40;
  void *v42;
  if (*(_BYTE *)(v40 - 168))
  {
    v42 = *(void **)(v40 - 192);
    *(void *)(v40 - 192) = 0LL;
    if (v42) {
      operator delete[](v42);
    }
  }

  sub_1002A5554(&a32);
  sub_100008390((uint64_t)&a29, a30);
  if (a40 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_100099DF4(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4)
{
  LODWORD(v7) = sub_10009AE14();
  sub_100103634(0LL, (uint64_t)v79);
  sub_10000C0A8((uint64_t)v76, (unsigned __int8 *)v79);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a3[1] - *a3) >> 6);
  if (v8 == (a4[1] - *a4) >> 4)
  {
    v68 = a4;
    else {
      uint64_t v7 = v7;
    }
    uint64_t v9 = 60LL;
    if (!*(_BYTE *)(a1 + 57)) {
      uint64_t v9 = 64LL;
    }
    sub_100093BA8(&v72, v7, (*(_DWORD *)(a1 + v9) + 1));
    if ((_DWORD)v7)
    {
      v10 = 0LL;
      v69 = (void **)(int)v7;
      do
      {
        v11 = a3;
        sub_1000CCB00(a2, *a3 + 192LL * (void)v10, (uint64_t)v76, 0LL, 0, (uint64_t)v93);
        v12 = *(double **)v93;
        v13 = *(double **)v94;
        while (v12 != v13)
        {
          if (*(_OWORD *)v12 == 0LL)
          {
            if ((sub_100093B0C((uint64_t)&v72, (int)v10, 0, v12[2]) & 1) == 0)
            {
              if (qword_1019348D0 != -1) {
                dispatch_once(&qword_1019348D0, &stru_10181CB88);
              }
              v25 = (os_log_s *)qword_1019348D8;
              if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
              {
                int v26 = v74;
                if (v73) {
                  int v27 = v75;
                }
                else {
                  int v27 = v74;
                }
                if (!v73) {
                  int v26 = v75;
                }
                *(_DWORD *)buf = 68290050;
                *(_DWORD *)&buf[4] = 0;
                __int16 v83 = 2082;
                v84 = "";
                __int16 v85 = 2050;
                v86 = v10;
                __int16 v87 = 1026;
                int v88 = 0;
                __int16 v89 = 1026;
                int v90 = v27;
                __int16 v91 = 1026;
                int v92 = v26;
                _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:appendNewEvents, set value error, row:%{public}lu, col:%{public}d,  numRows:%{public}d, numCols:%{public}d}",  buf,  0x2Eu);
                if (qword_1019348D0 != -1) {
                  dispatch_once(&qword_1019348D0, &stru_10181CB88);
                }
              }

              uint64_t v28 = qword_1019348D8;
              if (os_signpost_enabled((os_log_t)qword_1019348D8))
              {
                int v29 = v74;
                if (v73) {
                  int v30 = v75;
                }
                else {
                  int v30 = v74;
                }
                if (!v73) {
                  int v29 = v75;
                }
                *(_DWORD *)buf = 68290050;
                *(_DWORD *)&buf[4] = 0;
                __int16 v83 = 2082;
                v84 = "";
                __int16 v85 = 2050;
                v86 = v10;
                __int16 v87 = 1026;
                int v88 = 0;
                __int16 v89 = 1026;
                int v90 = v30;
                __int16 v91 = 1026;
                int v92 = v29;
                v24 = (os_log_s *)v28;
                goto LABEL_56;
              }
            }
          }

          else
          {
            v14 = *(void **)(a1 + 8);
            v15 = *(void **)a1;
            if (*(void **)a1 != v14)
            {
              while (*v15 != *(void *)v12 || v15[1] != *((void *)v12 + 1))
              {
                v15 += 2;
                if (v15 == v14)
                {
                  v15 = *(void **)(a1 + 8);
                  break;
                }
              }
            }

            if (v15 == v14)
            {
              if (qword_1019348D0 != -1) {
                dispatch_once(&qword_1019348D0, &stru_10181CB88);
              }
              v41 = (os_log_s *)qword_1019348D8;
              if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
              {
                v42 = operator new(0x28uLL);
                __p[0] = v42;
                *(_OWORD *)&__p[1] = xmmword_1012C8460;
                _OWORD *v42 = 0u;
                v42[1] = 0u;
                *(void *)((char *)v42 + 29) = 0LL;
                sub_10000AE6C((uint64_t)v12, v42);
                v43 = __p;
                if (SHIBYTE(__p[2]) < 0) {
                  v43 = (void **)__p[0];
                }
                *(_DWORD *)buf = 68289282;
                *(_DWORD *)&buf[4] = 0;
                __int16 v83 = 2082;
                v84 = "";
                __int16 v85 = 2082;
                v86 = v43;
                _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Similarity List fail to append new event, unexpected identifier, cluster ID :%{public, location:escape_only}s}",  buf,  0x1Cu);
                if (SHIBYTE(__p[2]) < 0) {
                  operator delete(__p[0]);
                }
                if (qword_1019348D0 != -1) {
                  dispatch_once(&qword_1019348D0, &stru_10181CB88);
                }
              }

              v44 = (os_log_s *)qword_1019348D8;
              if (os_signpost_enabled((os_log_t)qword_1019348D8))
              {
                v45 = (char *)operator new(0x28uLL);
                *(void *)(v45 + 29) = 0LL;
                *(_OWORD *)v45 = 0u;
                *((_OWORD *)v45 + 1) = 0u;
                sub_10000AE6C((uint64_t)v12, v45);
                *(_DWORD *)buf = 68289282;
                *(_DWORD *)&buf[4] = 0;
                __int16 v83 = 2082;
                v84 = "";
                __int16 v85 = 2082;
                v86 = (void **)v45;
                _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v44,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Similarity List fail to append new event, unexpected identifier",  "{msg%{public}.0s:Similarity List fail to append new event, unexpected identifier, cluster ID :%{public, location:escape_only}s}",  buf,  0x1Cu);
                operator delete(v45);
              }

              if (v102 && v100)
              {
                v101 = v100;
                operator delete(v100);
              }

              if (*(void *)&v98[2])
              {
                uint64_t v99 = *(void *)&v98[2];
                operator delete(*(void **)&v98[2]);
              }

              if (*(void *)v93)
              {
                *(void *)v94 = *(void *)v93;
                operator delete(*(void **)v93);
              }

              goto LABEL_130;
            }

            int v17 = (((unint64_t)v15 - *(void *)a1) >> 4) + 1;
            if ((sub_100093B0C((uint64_t)&v72, (int)v10, v17, v12[2]) & 1) == 0)
            {
              if (qword_1019348D0 != -1) {
                dispatch_once(&qword_1019348D0, &stru_10181CB88);
              }
              v18 = (os_log_s *)qword_1019348D8;
              if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
              {
                int v19 = v74;
                if (v73) {
                  int v20 = v75;
                }
                else {
                  int v20 = v74;
                }
                if (!v73) {
                  int v19 = v75;
                }
                *(_DWORD *)buf = 68290050;
                *(_DWORD *)&buf[4] = 0;
                __int16 v83 = 2082;
                v84 = "";
                __int16 v85 = 2050;
                v86 = v10;
                __int16 v87 = 1026;
                int v88 = v17;
                __int16 v89 = 1026;
                int v90 = v20;
                __int16 v91 = 1026;
                int v92 = v19;
                _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:appendNewEvents, set value error, row:%{public}lu, col:%{public}d,  numRows:%{public}d, numCols:%{public}d}",  buf,  0x2Eu);
                if (qword_1019348D0 != -1) {
                  dispatch_once(&qword_1019348D0, &stru_10181CB88);
                }
              }

              uint64_t v21 = qword_1019348D8;
              if (os_signpost_enabled((os_log_t)qword_1019348D8))
              {
                int v22 = v74;
                if (v73) {
                  int v23 = v75;
                }
                else {
                  int v23 = v74;
                }
                if (!v73) {
                  int v22 = v75;
                }
                *(_DWORD *)buf = 68290050;
                *(_DWORD *)&buf[4] = 0;
                __int16 v83 = 2082;
                v84 = "";
                __int16 v85 = 2050;
                v86 = v10;
                __int16 v87 = 1026;
                int v88 = v17;
                __int16 v89 = 1026;
                int v90 = v23;
                __int16 v91 = 1026;
                int v92 = v22;
                v24 = (os_log_s *)v21;
LABEL_56:
                _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v24,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "appendNewEvents, set value error",  "{msg%{public}.0s:appendNewEvents, set value error, row:%{public}lu, col:%{public}d,  numRows:%{public}d, numCols:%{public}d}",  buf,  0x2Eu);
              }
            }
          }

          v12 += 4;
        }

        if (v102 && v100)
        {
          v101 = v100;
          operator delete(v100);
        }

        a3 = v11;
        if (*(void *)&v98[2])
        {
          uint64_t v99 = *(void *)&v98[2];
          operator delete(*(void **)&v98[2]);
        }

        if (*(void *)v93)
        {
          *(void *)v94 = *(void *)v93;
          operator delete(*(void **)v93);
        }

        v10 = (void **)((char *)v10 + 1);
      }

      while (v10 != v69);
    }

    if (!sub_100093EEC((uint64_t)&v72))
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CB88);
      }
      v46 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        *(void *)v93 = 68289026LL;
        *(_WORD *)v94 = 2082;
        *(void *)&v94[2] = "";
        _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Similarity List appending new events, fail to normalize rows}",  v93,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181CB88);
        }
      }

      v47 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        *(void *)v93 = 68289026LL;
        *(_WORD *)v94 = 2082;
        *(void *)&v94[2] = "";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v47,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Similarity List appending new events, fail to normalize rows",  "{msg%{public}.0s:Similarity List appending new events, fail to normalize rows}",  v93,  0x12u);
      }

      goto LABEL_130;
    }

    sub_100093D84(&v72, 1u, (uint64_t)buf);
    if (BYTE4(v86))
    {
      if (*(_BYTE *)(a1 + 57))
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181CB88);
        }
        v31 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
        {
          *(void *)v93 = 68289026LL;
          *(_WORD *)v94 = 2082;
          *(void *)&v94[2] = "";
          _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Does not support appending new events to a transposed matrix!}",  v93,  0x12u);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181CB88);
          }
        }

        v32 = (os_log_s *)qword_1019348D8;
        if (!os_signpost_enabled((os_log_t)qword_1019348D8)) {
          goto LABEL_127;
        }
        *(void *)v93 = 68289026LL;
        *(_WORD *)v94 = 2082;
        *(void *)&v94[2] = "";
        v33 = "Does not support appending new events to a transposed matrix!";
        v34 = "{msg%{public}.0s:Does not support appending new events to a transposed matrix!}";
      }

      else
      {
        signed int v49 = sub_10009AE14();
        if (sub_100094290(a1 + 48, (uint64_t)buf, v49))
        {
          memset(__p, 0, sizeof(__p));
          uint64_t v50 = *a3;
          uint64_t v51 = a3[1];
          *(void *)v93 = __p;
          if (v50 == v51)
          {
            v52 = 0LL;
          }

          else
          {
            do
            {
              int v81 = *(_DWORD *)(v50 + 160);
              sub_10009CA94((uint64_t *)v93, &v81);
              v50 += 192LL;
            }

            while (v50 != v51);
            v52 = __p[1];
          }

          uint64_t v56 = *(void *)(a1 + 24);
          uint64_t v57 = *(void *)(a1 + 32);
          sub_10000AEE4( (uint64_t)__p,  (uint64_t)v52,  *(char **)(a1 + 80),  *(char **)(a1 + 88),  (uint64_t)(*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2);
          v58 = __p[0];
          __int128 v59 = *(_OWORD *)(a1 + 80);
          *(void **)(a1 + 80) = __p[0];
          v60 = *(void **)(a1 + 96);
          __int128 v61 = *(_OWORD *)&__p[1];
          *(_OWORD *)__p = v59;
          __p[2] = v60;
          *(_OWORD *)(a1 + 88) = v61;
          sub_10009CC88( (uint64_t)v68,  v68[1],  *(char **)(a1 + 24),  *(char **)(a1 + 32),  (uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 4);
          uint64_t v62 = *v68;
          uint64_t *v68 = *(void *)(a1 + 24);
          *(void *)(a1 + 24) = v62;
          uint64_t v63 = v68[1];
          v68[1] = *(void *)(a1 + 32);
          *(void *)(a1 + 32) = v63;
          uint64_t v64 = v68[2];
          v68[2] = *(void *)(a1 + 40);
          *(void *)(a1 + 40) = v64;
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181CB88);
          }
          v65 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v66 = (v68[1] - *v68) >> 4;
            uint64_t v67 = (uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 4;
            *(void *)v93 = 68289794LL;
            *(_WORD *)v94 = 2082;
            *(void *)&v94[2] = "";
            __int16 v95 = 2050;
            unint64_t v96 = v66;
            __int16 v97 = 2050;
            *(void *)v98 = (v57 - v56) >> 4;
            *(_WORD *)&v98[8] = 2050;
            uint64_t v99 = v67;
            _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Similarity List appended new events, Num new Labels:%{public}lu, Old LSL le ngth:%{public}lu, New LSL length:%{public}lu}",  v93,  0x30u);
          }

          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }

          goto LABEL_127;
        }

        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181CB88);
        }
        v53 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
        {
          *(void *)v93 = 68289026LL;
          *(_WORD *)v94 = 2082;
          *(void *)&v94[2] = "";
          _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Similarity List appending new events, fail to append rows}",  v93,  0x12u);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181CB88);
          }
        }

        v32 = (os_log_s *)qword_1019348D8;
        if (!os_signpost_enabled((os_log_t)qword_1019348D8)) {
          goto LABEL_127;
        }
        *(void *)v93 = 68289026LL;
        *(_WORD *)v94 = 2082;
        *(void *)&v94[2] = "";
        v33 = "Similarity List appending new events, fail to append rows";
        v34 = "{msg%{public}.0s:Similarity List appending new events, fail to append rows}";
      }
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CB88);
      }
      v48 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        *(void *)v93 = 68289026LL;
        *(_WORD *)v94 = 2082;
        *(void *)&v94[2] = "";
        _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Similarity List appending new events, fail to remove nullspace column}",  v93,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181CB88);
        }
      }

      v32 = (os_log_s *)qword_1019348D8;
      if (!os_signpost_enabled((os_log_t)qword_1019348D8)) {
        goto LABEL_127;
      }
      *(void *)v93 = 68289026LL;
      *(_WORD *)v94 = 2082;
      *(void *)&v94[2] = "";
      v33 = "Similarity List appending new events, fail to remove nullspace column";
      v34 = "{msg%{public}.0s:Similarity List appending new events, fail to remove nullspace column}";
    }

    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v32,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v33,  v34,  v93,  0x12u);
LABEL_127:
    if (BYTE4(v86))
    {
      v54 = *(void **)buf;
      *(void *)buf = 0LL;
      if (v54) {
        operator delete[](v54);
      }
    }

LABEL_132:
  sub_1002A5554(v78);
  sub_100008390((uint64_t)v76, v77);
  if (v80 < 0) {
    operator delete(v79[0]);
  }
}

    sub_100E57614((uint64_t)&v47, (uint64_t)"locationd");
    return sub_1002A5590(&v47);
  }

  return result;
}

  if (v33)
  {
    if (v41 <= 0.00000001 && !a12[2])
    {
      sub_100853D24(a5, (uint64_t)v93, a9, a7, a16);
      *a17 = 0.0;
      int v92 = 3;
LABEL_148:
      *a18 = v92;
      return 1LL;
    }

    if (v42 <= 0.00000001 && !a12[3])
    {
      sub_100853D24(a5, (uint64_t)v93, a9, a8, a16);
      *a17 = *a14;
      int v92 = 4;
      goto LABEL_148;
    }
  }

  if (v40)
  {
    if (v34 <= 0.00000001 && !*a12)
    {
      *a16 = 0.0;
      sub_100853D24(a7, (uint64_t)a8, a10, a5, a17);
      goto LABEL_143;
    }

    if (v35 <= 0.00000001 && !a12[1])
    {
      *a16 = *a13;
      sub_100853D24(a7, (uint64_t)a8, a10, v93, a17);
      goto LABEL_147;
    }
  }

  *a18 = 0;
  return v33 & v40;
}

  result = *(float *)(a2 + 188);
  v5 |= 0x1000000000uLL;
  *v2 = v5;
  *(_BYTE *)(a1 + 324) = v6;
  *(float *)(a1 + 188) = result;
  uint64_t v7 = *v3;
  if ((*v3 & 0x200000) == 0)
  {
LABEL_67:
    if ((v7 & 0x400000000000000LL) == 0) {
      goto LABEL_68;
    }
    goto LABEL_134;
  }

  PB::TextFormatter::format(this, "lgDurationXYZBiggestImpact", *(float *)(a1 + 296));
  v6 = *v5;
  uint64_t v7 = *(_BYTE *)(a1 + 324);
  if ((v7 & 1) == 0)
  {
LABEL_66:
    if ((v7 & 2) == 0) {
      goto LABEL_67;
    }
    goto LABEL_134;
  }

  result = PB::Writer::write(this, *(float *)(v3 + 188), 0x3Eu);
  v6 = *v4;
  if ((*v4 & 0x200000) == 0)
  {
LABEL_67:
    if ((v6 & 0x400000000000000LL) == 0) {
      goto LABEL_68;
    }
    goto LABEL_134;
  }

  result = *(float *)(a2 + 156);
  v5 |= 0x1000000000uLL;
  *v2 = v5;
  *(_WORD *)(a1 + 288) = v6;
  *(float *)(a1 + 156) = result;
  v4 = *v3;
  uint64_t v7 = *(_WORD *)(a2 + 288);
  if ((*v3 & 0x4000000000LL) == 0)
  {
LABEL_59:
    if ((v7 & 0x20) == 0) {
      goto LABEL_60;
    }
    goto LABEL_134;
  }

  PB::TextFormatter::format(this, "lowSenseWithAudioMaxaccelnormThreshold", *(float *)(a1 + 184));
  v6 = *v5;
  uint64_t v7 = *(_WORD *)(a1 + 288);
  if ((*v5 & 0x100000000000LL) == 0)
  {
LABEL_58:
    if ((v6 & 0x200000000000LL) == 0) {
      goto LABEL_59;
    }
    goto LABEL_134;
  }

  result = PB::Writer::write(this, *(_BYTE *)(v3 + 273), 0x35u);
  v5 = *v4;
  v6 = *((_WORD *)v4 + 4);
  if ((*v4 & 0x1000000000000000LL) == 0)
  {
LABEL_58:
    if ((v5 & 0x400000000000000LL) == 0) {
      goto LABEL_59;
    }
    goto LABEL_134;
  }

  result = *(float *)(a2 + 48);
  v5 |= 0x200uLL;
  *v2 = v5;
  *(_WORD *)(a1 + 324) = v6;
  *(_BYTE *)(a1 + 326) = BYTE2(v6);
  *(float *)(a1 + 48) = result;
  LOWORD(v8) = *(_WORD *)(a2 + 324);
  v4 = *v3;
  if ((*v3 & 0x100) == 0)
  {
LABEL_52:
    if ((v4 & 0x20000) == 0) {
      goto LABEL_53;
    }
    goto LABEL_134;
  }

  PB::TextFormatter::format(this, "kRegimeRotThresholdROWOASB", *(float *)(a1 + 168));
  uint64_t v7 = *(unsigned __int16 *)(a1 + 324) | (*(unsigned __int8 *)(a1 + 326) << 16);
  v6 = *v5;
  if ((*v5 & 0x10000000000LL) == 0)
  {
LABEL_51:
    if ((v6 & 0x20000000000LL) == 0) {
      goto LABEL_52;
    }
    goto LABEL_134;
  }

  result = PB::Writer::write(this, *(float *)(v3 + 48), 0xF2u);
  LOWORD(v7) = *((_WORD *)v4 + 4);
  v5 = *v4;
  if ((*v4 & 0x100) == 0)
  {
LABEL_52:
    if ((v5 & 0x20000) == 0) {
      goto LABEL_53;
    }
    goto LABEL_134;
  }

  uint64_t v21 = *(_BYTE *)(a2 + 337);
  v6 |= 0x4000000uLL;
  *v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(_BYTE *)(a1 + 337) = v21;
  v4 = *v3;
  uint64_t v7 = *(void *)(a2 + 364);
  if ((v7 & 0x2000000) == 0)
  {
LABEL_27:
    if ((v7 & 0x800) == 0) {
      goto LABEL_28;
    }
    goto LABEL_134;
  }

  PB::TextFormatter::format(this, "isMAPFPDecided", *(_BYTE *)(a1 + 330));
  uint64_t v7 = *v5;
  v6 = *(void *)(a1 + 364);
  if ((v6 & 0x100000) == 0)
  {
LABEL_31:
    if ((v6 & 0x200000) == 0) {
      goto LABEL_32;
    }
    goto LABEL_134;
  }

  result = PB::Writer::write(this, *(_BYTE *)(v3 + 337), 0x67u);
  v5 = *v4;
  v6 = v4[1];
  if ((v6 & 0x2000000) == 0)
  {
LABEL_27:
    if ((v6 & 0x800) == 0) {
      goto LABEL_28;
    }
    goto LABEL_134;
  }

  uint64_t v63 = *(_DWORD *)(a2 + 104);
  v3 |= 0x100000uLL;
  *(void *)(result + 204) = v3;
  *(_WORD *)(result + 212) = v4;
  *(_BYTE *)(result + 214) = BYTE2(v4);
  *(_DWORD *)(result + 104) = v63;
  v5 = *(unsigned __int16 *)(a2 + 212) | (*(unsigned __int8 *)(a2 + 214) << 16);
  v2 = *(void *)(a2 + 204);
  if ((v2 & 0x100000000LL) == 0)
  {
LABEL_54:
    if ((v2 & 0x1000000000000LL) == 0) {
      goto LABEL_55;
    }
    goto LABEL_134;
  }

  PB::TextFormatter::format(this, "kPassthruRO1", *(_BYTE *)(a1 + 190));
  v6 = *(unsigned __int16 *)(a1 + 212) | (*(unsigned __int8 *)(a1 + 214) << 16);
  v5 = *(void *)(a1 + 204);
  if ((*(_WORD *)(a1 + 212) & 0x10) == 0)
  {
LABEL_53:
    if ((v6 & 0x20) == 0) {
      goto LABEL_54;
    }
    goto LABEL_134;
  }

  result = PB::Writer::write(this, *(_BYTE *)(v3 + 202), 0x456u);
  v5 = *(unsigned __int16 *)(v3 + 212) | (*(unsigned __int8 *)(v3 + 214) << 16);
  v4 = *(void *)(v3 + 204);
  if ((v4 & 0x8000000000LL) == 0)
  {
LABEL_54:
    if ((v4 & 0x80000000000LL) == 0) {
      goto LABEL_55;
    }
    goto LABEL_134;
  }

void sub_10009AD48( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, void *a34, uint64_t a35, uint64_t a36, char a37)
{
  if (__p) {
    operator delete(__p);
  }
  if (a37)
  {
    v38 = a34;
    a34 = 0LL;
    if (v38) {
      operator delete[](v38);
    }
  }

  if (a18) {
    operator delete[](a18);
  }
  sub_10000ADB4((uint64_t)&a21);
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10009AE14()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsSimilarityListMaxNumberOfItems",  0x8000100u,  kCFAllocatorNull);
  int v1 = sub_1002A7D20(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  unsigned int v2 = v7;
  v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 1000LL;
  }
}

void sub_10009AED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10009AEEC(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }

  else
  {
    sub_10009CB80((char **)a1, a2 - v2);
  }

void sub_10009AF1C(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }

  else
  {
    sub_10009CF68((void **)a1, a2 - v2);
  }

void *sub_10009AF4C()
{
  CFStringRef v0 = operator new(0x70uLL);
  sub_100063398((uint64_t)v0);
  return v0;
}

void sub_10009AF78(_Unwind_Exception *a1)
{
}

void *sub_10009AF8C()
{
  CFStringRef v0 = operator new(0x30uLL);
  sub_1000633D4((uint64_t)v0);
  return v0;
}

void sub_10009AFB8(_Unwind_Exception *a1)
{
}

void sub_10009AFCC(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_10009AFF8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (*(_BYTE *)(a1 + 24)) {
      sub_100093D08(a1, a2);
    }
  }

  else if (*(_BYTE *)(a1 + 24))
  {
    v3 = *(void **)a1;
    *(void *)a1 = 0LL;
    if (v3) {
      operator delete[](v3);
    }
    *(_BYTE *)(a1 + 24) = 0;
  }

  else
  {
    sub_100093C80(a1);
    *(_BYTE *)(a1 + 24) = 1;
  }

void *sub_10009B064()
{
  CFStringRef v0 = operator new(0x28uLL);
  sub_100063498(v0);
  return v0;
}

void sub_10009B090(_Unwind_Exception *a1)
{
}

uint64_t sub_10009B0A4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0LL;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  sub_10009B174((_BYTE *)(a1 + 48), a2 + 48);
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 80) = 0LL;
  *(void *)(a2 + 88) = 0LL;
  *(void *)(a2 + 96) = 0LL;
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  return a1;
}

void sub_10009B148(_Unwind_Exception *exception_object)
{
  v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }

  unint64_t v5 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(exception_object);
}

_BYTE *sub_10009B174(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[24] = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    sub_100093C80(a1);
    a1[24] = 1;
  }

  return a1;
}

void sub_10009B1B4(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 24)) {
    sub_101228A10((void **)v1);
  }
  _Unwind_Resume(exception_object);
}

char *sub_10009B1D0(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    v6 = result;
    result = sub_10005782C(result, a4);
    unsigned int v7 = (_OWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      *v7++ = *((_OWORD *)a2 + 1);
      a2 = (uint64_t *)*a2;
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

void sub_10009B228(_Unwind_Exception *exception_object)
{
  v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_10009B244(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unsigned int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *unsigned int v7 = 0LL;
      v7[1] = 0LL;
      v7[2] = 0LL;
    }

    if (a4 >> 60) {
      sub_100007008();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    else {
      unint64_t v11 = v10;
    }
    result = sub_10005782C(v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      v18 = v9;
      int v19 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 4;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }

  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    v18 = v9;
    int v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }

void sub_10009B34C(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (*(_BYTE *)(a1 + 24)) {
      sub_100093C84(a1, a2);
    }
  }

  else if (*(_BYTE *)(a1 + 24))
  {
    v3 = *(void **)a1;
    *(void *)a1 = 0LL;
    if (v3) {
      operator delete[](v3);
    }
    *(_BYTE *)(a1 + 24) = 0;
  }

  else
  {
    sub_100093C24(a1);
    *(_BYTE *)(a1 + 24) = 1;
  }

uint64_t sub_10009B3B8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  sub_1000577B4( (void *)a1,  *(const void **)a2,  *(void *)(a2 + 8),  (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  sub_1000577B4( (void *)(a1 + 24),  *(const void **)(a2 + 24),  *(void *)(a2 + 32),  (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 4);
  sub_10009B4A8((_BYTE *)(a1 + 48), a2 + 48);
  *(void *)(a1 + 80) = 0LL;
  *(void *)(a1 + 88) = 0LL;
  *(void *)(a1 + 96) = 0LL;
  sub_10001B72C( (void *)(a1 + 80),  *(const void **)(a2 + 80),  *(void *)(a2 + 88),  (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 2);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  return a1;
}

void sub_10009B454(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 72))
  {
    unint64_t v5 = *v3;
    void *v3 = 0LL;
    if (v5) {
      operator delete[](v5);
    }
  }

  v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v6;
    operator delete(v6);
  }

  unsigned int v7 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v7;
    operator delete(v7);
  }

  _Unwind_Resume(exception_object);
}

_BYTE *sub_10009B4A8(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[24] = 0;
  if (*(_BYTE *)(a2 + 24))
  {
    sub_100093C24(a1);
    a1[24] = 1;
  }

  return a1;
}

void sub_10009B4E8(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 24)) {
    sub_101228A10((void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10009B504(uint64_t a1, void *a2, _OWORD *a3, __int128 *a4)
{
  unint64_t v8 = 0LL;
  for (uint64_t i = 0LL; i != 16; ++i)
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + i);
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
    }

    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }

    v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      v13 = *v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v8)
          {
            if (v13[2] == *a2 && v13[3] == a2[1]) {
              return v13;
            }
          }

          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v14 >= v10) {
                v14 %= v10;
              }
            }

            else
            {
              v14 &= v10 - 1;
            }

            if (v14 != v4) {
              break;
            }
          }

          v13 = (void *)*v13;
        }

        while (v13);
      }
    }
  }

  v16 = (void *)(a1 + 16);
  v13 = operator new(0x38uLL);
  void *v13 = 0LL;
  v13[1] = v8;
  __int128 v17 = *a4;
  *((_OWORD *)v13 + 1) = *a3;
  *((_OWORD *)v13 + 2) = v17;
  v13[6] = *((void *)a4 + 2);
  *(void *)a4 = 0LL;
  *((void *)a4 + 1) = 0LL;
  *((void *)a4 + 2) = 0LL;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v19 = *(float *)(a1 + 32);
  if (!v10 || (float)(v19 * (float)v10) < v18)
  {
    BOOL v20 = 1LL;
    if (v10 >= 3) {
      BOOL v20 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v10);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    sub_100019E10(a1, v23);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
      else {
        unint64_t v4 = v8;
      }
    }

    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }
  }

  uint64_t v24 = *(void *)a1;
  v25 = *(void **)(*(void *)a1 + 8 * v4);
  if (v25)
  {
    void *v13 = *v25;
LABEL_44:
    void *v25 = v13;
    goto LABEL_45;
  }

  void *v13 = *v16;
  void *v16 = v13;
  *(void *)(v24 + 8 * v4) = v16;
  if (*v13)
  {
    unint64_t v26 = *(void *)(*v13 + 8LL);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v26 >= v10) {
        v26 %= v10;
      }
    }

    else
    {
      v26 &= v10 - 1;
    }

    v25 = (void *)(*(void *)a1 + 8 * v26);
    goto LABEL_44;
  }

void sub_10009B77C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void sub_10009B798(uint64_t a1, void *__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    v3 = (void *)__p[4];
    if (v3)
    {
      __p[5] = v3;
      operator delete(v3);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t *sub_10009B7E4(void *a1, void *a2)
{
  result = sub_10001A7B8(a1, a2);
  if (result)
  {
    sub_10009B818(a1, result);
    return (uint64_t *)1;
  }

  return result;
}

uint64_t sub_10009B818(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  sub_10005BEB8(a1, a2, (uint64_t)&__p);
  v3 = __p;
  __p = 0LL;
  if (v3) {
    sub_10009B798((uint64_t)&v6, v3);
  }
  return v2;
}

void *sub_10009B860(uint64_t a1, void *a2, _OWORD *a3)
{
  unint64_t v6 = 0LL;
  for (uint64_t i = 0LL; i != 16; ++i)
    v6 ^= (v6 << 6) + (v6 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + i);
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v3 = v6;
      if (v6 >= v8) {
        unint64_t v3 = v6 % v8;
      }
    }

    else
    {
      unint64_t v3 = (v8 - 1) & v6;
    }

    unint64_t v10 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v6)
          {
            if (v11[2] == *a2 && v11[3] == a2[1]) {
              return v11;
            }
          }

          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }

            else
            {
              v12 &= v8 - 1;
            }

            if (v12 != v3) {
              break;
            }
          }

          uint64_t v11 = (void *)*v11;
        }

        while (v11);
      }
    }
  }

  uint64_t v11 = operator new(0x30uLL);
  void *v11 = 0LL;
  v11[1] = v6;
  __int128 v14 = a3[1];
  *((_OWORD *)v11 + 1) = *a3;
  *((_OWORD *)v11 + 2) = v14;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1LL;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_100019E10(a1, v20);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v6 >= v8) {
        unint64_t v3 = v6 % v8;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = (v8 - 1) & v6;
    }
  }

  uint64_t v21 = *(void *)a1;
  unint64_t v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    void *v11 = *v22;
LABEL_44:
    *unint64_t v22 = v11;
    goto LABEL_45;
  }

  void *v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v21 + 8 * v3) = a1 + 16;
  if (*v11)
  {
    unint64_t v23 = *(void *)(*v11 + 8LL);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v23 >= v8) {
        v23 %= v8;
      }
    }

    else
    {
      v23 &= v8 - 1;
    }

    unint64_t v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_44;
  }

void sub_10009BA9C(_Unwind_Exception *a1)
{
}

char *sub_10009BAB0(uint64_t **a1, double *a2, _OWORD *a3)
{
  unint64_t v6 = (char *)operator new(0x48uLL);
  double v7 = *a2;
  *((double *)v6 + 4) = *a2;
  __int128 v8 = a3[1];
  *(_OWORD *)(v6 + 40) = *a3;
  *(_OWORD *)(v6 + 56) = v8;
  uint8x8_t v9 = a1 + 1;
  unint64_t v10 = a1[1];
  if (v10)
  {
    do
    {
      while (1)
      {
        uint8x8_t v9 = (uint64_t **)v10;
        unint64_t v10 = (uint64_t *)*v10;
        uint64_t v11 = v9;
        if (!*v9) {
          goto LABEL_8;
        }
      }

      unint64_t v10 = (uint64_t *)v10[1];
    }

    while (v10);
    uint64_t v11 = v9 + 1;
  }

  else
  {
    uint64_t v11 = a1 + 1;
  }

uint64_t sub_10009BB4C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = sub_10009BBB0(*(uint64_t ***)a1, *(double **)(a1 + 8), a2);
  *(void *)(a1 + 8) = v3;
  unint64_t v4 = (void *)v3[1];
  if (v4)
  {
    do
    {
      unint64_t v5 = v4;
      unint64_t v4 = (void *)*v4;
    }

    while (v4);
  }

  else
  {
    do
    {
      unint64_t v5 = (void *)v3[2];
      BOOL v6 = *v5 == (void)v3;
      unint64_t v3 = v5;
    }

    while (!v6);
  }

  *(void *)(a1 + 8) = v5;
  return a1;
}

void *sub_10009BBB0(uint64_t **a1, double *a2, uint64_t a3)
{
  BOOL v6 = operator new(0x48uLL);
  __int128 v7 = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v6 + 2) = *(_OWORD *)a3;
  *((_OWORD *)v6 + 3) = v7;
  *((void *)v6 + 8) = *(void *)(a3 + 32);
  __int128 v8 = sub_10009BC40(a1, a2, &v10, (double *)v6 + 4);
  sub_1000085FC(a1, (uint64_t)v10, (uint64_t **)v8, (uint64_t *)v6);
  return v6;
}

void sub_10009BC2C(_Unwind_Exception *a1)
{
}

double *sub_10009BC40(void *a1, double *a2, double **a3, double *a4)
{
  unint64_t v4 = (double *)(a1 + 1);
  if (a1 + 1 != (void *)a2 && a2[4] < *a4)
  {
    while (1)
    {
      uint64_t v5 = *(void *)v4;
      a2 = v4;
      if (!*(void *)v4) {
        break;
      }
      while (1)
      {
        unint64_t v4 = (double *)v5;
        uint64_t v5 = *(void *)(v5 + 8);
        if (!v5) {
          goto LABEL_19;
        }
      }
    }

__int128 *sub_10009BD28(__int128 *a1, __int128 *a2, uint64_t a3)
{
  unint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  uint64_t v5 = a2;
  do
  {
    sub_10005F550(a3, v4);
    *(_OWORD *)(a3 + 16) = v4[1];
    a3 += 32LL;
    v4 += 2;
  }

  while (v4 != v5);
  return v5;
}

_OWORD *sub_10009BD90(uint64_t **a1, unint64_t *a2, _OWORD *a3, void *a4)
{
  double v7 = (void **)sub_10009BE24((uint64_t)a1, &v11, a2);
  __int128 v8 = *v7;
  if (!*v7)
  {
    uint8x8_t v9 = (uint64_t **)v7;
    __int128 v8 = operator new(0x38uLL);
    v8[2] = *a3;
    *((void *)v8 + 6) = *a4;
    sub_1000085FC(a1, v11, v9, (uint64_t *)v8);
  }

  return v8;
}

void *sub_10009BE24(uint64_t a1, void *a2, unint64_t *a3)
{
  uint64_t v5 = *(void **)(a1 + 8);
  result = (void *)(a1 + 8);
  unint64_t v4 = v5;
  if (v5)
  {
    do
    {
      while (1)
      {
        double v6 = v4;
        unint64_t v7 = bswap64(*a3);
        unint64_t v8 = bswap64(v6[4]);
        if (v7 == v8)
        {
          unint64_t v7 = bswap64(a3[1]);
          unint64_t v8 = bswap64(v6[5]);
          if (v7 == v8) {
            break;
          }
        }

        int v9 = v7 < v8 ? -1 : 1;
        if ((v9 & 0x80000000) == 0) {
          break;
        }
        unint64_t v4 = (void *)*v6;
        result = v6;
        if (!*v6) {
          goto LABEL_20;
        }
      }

      unint64_t v10 = bswap64(v6[4]);
      unint64_t v11 = bswap64(*a3);
      if (v10 == v11)
      {
        unint64_t v10 = bswap64(v6[5]);
        unint64_t v11 = bswap64(a3[1]);
        if (v10 == v11) {
          break;
        }
      }

      int v12 = v10 < v11 ? -1 : 1;
      if ((v12 & 0x80000000) == 0) {
        break;
      }
      result = v6 + 1;
      unint64_t v4 = (void *)v6[1];
    }

    while (v4);
  }

  else
  {
    double v6 = result;
  }

void sub_10009BEEC(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }

  else
  {
    sub_10009BF1C((void **)a1, a2 - v3, a3);
  }

void sub_10009BF1C(void **a1, unint64_t a2, void *a3)
{
  unint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  unint64_t v7 = v8;
  int v9 = *(void **)(v6 - 8);
  if (a2 <= (v8 - (_BYTE *)v9) >> 3)
  {
    if (a2)
    {
      uint64_t v16 = 8 * a2;
      BOOL v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 8LL;
      }

      while (v16);
      int v9 = v17;
    }

    a1[1] = v9;
  }

  else
  {
    uint64_t v10 = (char *)v9 - (_BYTE *)*a1;
    unint64_t v11 = a2 + (v10 >> 3);
    if (v11 >> 61) {
      sub_100007008();
    }
    uint64_t v12 = v10 >> 3;
    uint64_t v13 = v7 - (_BYTE *)*a1;
    if (v13 >> 2 > v11) {
      unint64_t v11 = v13 >> 2;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      float v15 = (char *)sub_1000071BC(v6, v14);
    }
    else {
      float v15 = 0LL;
    }
    unint64_t v18 = &v15[8 * v12];
    unint64_t v19 = &v18[8 * a2];
    uint64_t v20 = 8 * a2;
    uint64_t v21 = v18;
    do
    {
      *(void *)uint64_t v21 = *a3;
      v21 += 8;
      v20 -= 8LL;
    }

    while (v20);
    unint64_t v22 = &v15[8 * v14];
    unint64_t v23 = (char *)*a1;
    for (uint64_t i = (char *)a1[1]; i != v23; i -= 8)
    {
      uint64_t v25 = *((void *)i - 1);
      *((void *)v18 - 1) = v25;
      v18 -= 8;
    }

    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23) {
      operator delete(v23);
    }
  }

void sub_10009C02C(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }

  else
  {
    sub_10009C05C((void **)a1, a2 - v3, a3);
  }

void sub_10009C05C(void **a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  unint64_t v7 = v8;
  int v9 = *(_DWORD **)(v6 - 8);
  if (a2 <= (v8 - (_BYTE *)v9) >> 2)
  {
    if (a2)
    {
      uint64_t v16 = 4 * a2;
      BOOL v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 4LL;
      }

      while (v16);
      int v9 = v17;
    }

    a1[1] = v9;
  }

  else
  {
    uint64_t v10 = (char *)v9 - (_BYTE *)*a1;
    unint64_t v11 = a2 + (v10 >> 2);
    if (v11 >> 62) {
      sub_100007008();
    }
    uint64_t v12 = v10 >> 2;
    uint64_t v13 = v7 - (_BYTE *)*a1;
    if (v13 >> 1 > v11) {
      unint64_t v11 = v13 >> 1;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      float v15 = (char *)sub_10000956C(v6, v14);
    }
    else {
      float v15 = 0LL;
    }
    unint64_t v18 = &v15[4 * v12];
    unint64_t v19 = &v18[4 * a2];
    uint64_t v20 = 4 * a2;
    uint64_t v21 = v18;
    do
    {
      *(_DWORD *)uint64_t v21 = *a3;
      v21 += 4;
      v20 -= 4LL;
    }

    while (v20);
    unint64_t v22 = &v15[4 * v14];
    unint64_t v23 = (char *)*a1;
    for (uint64_t i = (char *)a1[1]; i != v23; i -= 4)
    {
      int v25 = *((_DWORD *)i - 1);
      *((_DWORD *)v18 - 1) = v25;
      v18 -= 4;
    }

    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23) {
      operator delete(v23);
    }
  }

_OWORD *sub_10009C16C(uint64_t **a1, unint64_t *a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v6 = (void **)sub_10009BE24((uint64_t)a1, &v10, a2);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    unint64_t v8 = (uint64_t **)v6;
    unint64_t v7 = operator new(0x38uLL);
    v7[2] = **a4;
    *((void *)v7 + 6) = 0LL;
    sub_1000085FC(a1, v10, v8, (uint64_t *)v7);
  }

  return v7;
}

uint64_t *sub_10009C1F4(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    __int128 v5 = *(_OWORD *)(v2 - 32);
    v2 -= 32LL;
    *(_OWORD *)(v4 - 32) = v5;
    v4 -= 32LL;
    *(void *)uint64_t v2 = 0LL;
    *(void *)(v2 + 8) = 0LL;
    *(_OWORD *)(v4 + 16) = *(_OWORD *)(v2 + 16);
  }

  a2[1] = v4;
  uint64_t v6 = *result;
  void *result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10009C258(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    sub_10000AE14(i - 32);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_10009C2A4(uint64_t a1, void *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v7 = 0LL;
  for (uint64_t i = 0LL; i != 16; ++i)
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + i);
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = v7;
      if (v7 >= v9) {
        unint64_t v4 = v7 % v9;
      }
    }

    else
    {
      unint64_t v4 = (v9 - 1) & v7;
    }

    unint64_t v11 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      for (j = *v11; j; j = (void *)*j)
      {
        unint64_t v13 = j[1];
        if (v13 == v7)
        {
          if (j[2] == *a2 && j[3] == a2[1]) {
            return j;
          }
        }

        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }

          else
          {
            v13 &= v9 - 1;
          }

          if (v13 != v4) {
            break;
          }
        }
      }
    }
  }

  float v15 = (void *)(a1 + 16);
  j = operator new(0x38uLL);
  void *j = 0LL;
  j[1] = v7;
  *((_OWORD *)j + 1) = **a4;
  j[5] = 0LL;
  j[6] = 0LL;
  j[4] = 0LL;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    BOOL v18 = 1LL;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v7 >= v9) {
        unint64_t v4 = v7 % v9;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = (v9 - 1) & v7;
    }
  }

  uint64_t v22 = *(void *)a1;
  unint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    void *j = *v23;
LABEL_44:
    *unint64_t v23 = j;
    goto LABEL_45;
  }

  void *j = *v15;
  void *v15 = j;
  *(void *)(v22 + 8 * v4) = v15;
  if (*j)
  {
    unint64_t v24 = *(void *)(*j + 8LL);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v24 >= v9) {
        v24 %= v9;
      }
    }

    else
    {
      v24 &= v9 - 1;
    }

    unint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_44;
  }

void sub_10009C510( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

uint64_t sub_10009C52C(uint64_t a1, unint64_t *a2, unint64_t *a3)
{
  *(void *)(a1 + 8) = 0LL;
  unint64_t v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_10009C5AC((uint64_t **)a1, v4, v6, v6);
      v6 += 2;
    }

    while (v6 != a3);
  }

  return a1;
}

void sub_10009C594(_Unwind_Exception *a1)
{
}

char *sub_10009C5AC(uint64_t **a1, void *a2, unint64_t *a3, _OWORD *a4)
{
  uint64_t v6 = (void **)sub_10009C630(a1, a2, &v11, &v10, a3);
  unint64_t v7 = (char *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    unint64_t v7 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v7 + 25) = *a4;
    sub_1000085FC(a1, v11, v8, (uint64_t *)v7);
  }

  return v7;
}

void *sub_10009C630(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  if (a1 + 1 == a2
    || ((unint64_t v5 = bswap64(*a5), v6 = bswap64(*(void *)((char *)a2 + 25)), v5 != v6)
     || (unint64_t v5 = bswap64(a5[1]), v6 = bswap64(*(void *)((char *)a2 + 33)), v5 != v6))
    && (v5 < v6 ? (int v10 = -1) : (int v10 = 1), v10 < 0))
  {
    uint64_t v7 = *a2;
    if ((void *)*a1 == a2)
    {
      unint64_t v9 = a2;
    }

    else
    {
      if (v7)
      {
        uint64_t v8 = (void *)*a2;
        do
        {
          unint64_t v9 = v8;
          uint64_t v8 = (void *)v8[1];
        }

        while (v8);
      }

      else
      {
        float v16 = a2;
        do
        {
          unint64_t v9 = (void *)v16[2];
          BOOL v17 = *v9 == (void)v16;
          float v16 = v9;
        }

        while (v17);
      }

      unint64_t v18 = bswap64(*(void *)((char *)v9 + 25));
      unint64_t v19 = bswap64(*a5);
      if (v18 == v19)
      {
        unint64_t v18 = bswap64(*(void *)((char *)v9 + 33));
        unint64_t v19 = bswap64(a5[1]);
        if (v18 == v19) {
          return sub_10009C838((uint64_t)a1, a3, a5);
        }
      }

      int v20 = v18 < v19 ? -1 : 1;
      if ((v20 & 0x80000000) == 0) {
        return sub_10009C838((uint64_t)a1, a3, a5);
      }
    }

    if (v7)
    {
      *a3 = v9;
      return v9 + 1;
    }

    else
    {
      *a3 = a2;
      return a2;
    }
  }

  unint64_t v11 = bswap64(*(void *)((char *)a2 + 25));
  unint64_t v12 = bswap64(*a5);
  if (v11 != v12 || (unint64_t v11 = bswap64(*(void *)((char *)a2 + 33)), v12 = bswap64(a5[1]), v11 != v12))
  {
    int v15 = v11 < v12 ? -1 : 1;
    if (v15 < 0)
    {
      uint64_t v13 = a2[1];
      if (v13)
      {
        unint64_t v14 = (void *)a2[1];
        do
        {
          a4 = v14;
          unint64_t v14 = (void *)*v14;
        }

        while (v14);
      }

      else
      {
        size_t v21 = a2;
        do
        {
          a4 = (void *)v21[2];
          BOOL v17 = *a4 == (void)v21;
          size_t v21 = a4;
        }

        while (!v17);
      }

      if (a4 == a1 + 1
        || ((unint64_t v22 = bswap64(*a5), v23 = bswap64(*(void *)((char *)a4 + 25)), v22 != v23)
         || (unint64_t v22 = bswap64(a5[1]), v23 = bswap64(*(void *)((char *)a4 + 33)), v22 != v23)
          ? (v22 < v23
           ? (int v24 = -1)
           : (int v24 = 1))
          : (int v24 = 0),
            v24 < 0))
      {
        if (v13)
        {
          *a3 = a4;
        }

        else
        {
          *a3 = a2;
          return a2 + 1;
        }

        return a4;
      }

      return sub_10009C838((uint64_t)a1, a3, a5);
    }
  }

  *a3 = a2;
  *a4 = a2;
  return a4;
}

void *sub_10009C838(uint64_t a1, void *a2, unint64_t *a3)
{
  unint64_t v5 = *(void **)(a1 + 8);
  result = (void *)(a1 + 8);
  unint64_t v4 = v5;
  if (v5)
  {
    do
    {
      while (1)
      {
        unint64_t v6 = v4;
        unint64_t v7 = bswap64(*a3);
        unint64_t v8 = bswap64(*(void *)((char *)v6 + 25));
        if (v7 == v8)
        {
          unint64_t v7 = bswap64(a3[1]);
          unint64_t v8 = bswap64(*(void *)((char *)v6 + 33));
          if (v7 == v8) {
            break;
          }
        }

        int v9 = v7 < v8 ? -1 : 1;
        if ((v9 & 0x80000000) == 0) {
          break;
        }
        unint64_t v4 = (void *)*v6;
        result = v6;
        if (!*v6) {
          goto LABEL_20;
        }
      }

      unint64_t v10 = bswap64(*(void *)((char *)v6 + 25));
      unint64_t v11 = bswap64(*a3);
      if (v10 == v11)
      {
        unint64_t v10 = bswap64(*(void *)((char *)v6 + 33));
        unint64_t v11 = bswap64(a3[1]);
        if (v10 == v11) {
          break;
        }
      }

      int v12 = v10 < v11 ? -1 : 1;
      if ((v12 & 0x80000000) == 0) {
        break;
      }
      result = v6 + 1;
      unint64_t v4 = (void *)v6[1];
    }

    while (v4);
  }

  else
  {
    unint64_t v6 = result;
  }

void *sub_10009C900(void *a1, void *a2, void *a3)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2 == a3)
  {
    unint64_t v4 = 0LL;
  }

  else
  {
    unint64_t v4 = 0LL;
    unint64_t v5 = a2;
    do
    {
      unint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          unint64_t v7 = v6;
          unint64_t v6 = (void *)*v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          unint64_t v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          unint64_t v5 = v7;
        }

        while (!v8);
      }

      ++v4;
      unint64_t v5 = v7;
    }

    while (v7 != a3);
  }

  sub_10009C984(a1, a2, a3, v4);
  return a1;
}

void *sub_10009C984(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = (uint64_t)result;
    sub_10005782C(result, a4);
    return (void *)sub_10009C9F0(v6, a2, a3);
  }

  return result;
}

void sub_10009C9D4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10009C9F0(uint64_t result, void *a2, void *a3)
{
  uint64_t v3 = *(_OWORD **)(result + 8);
  if (a2 != a3)
  {
    do
    {
      _OWORD *v3 = *(_OWORD *)((char *)a2 + 25);
      unint64_t v4 = (void *)a2[1];
      if (v4)
      {
        do
        {
          unint64_t v5 = v4;
          unint64_t v4 = (void *)*v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          unint64_t v5 = (void *)a2[2];
          BOOL v6 = *v5 == (void)a2;
          a2 = v5;
        }

        while (!v6);
      }

      ++v3;
      a2 = v5;
    }

    while (v5 != a3);
  }

  *(void *)(result + 8) = v3;
  return result;
}

void *sub_10009CA48(void *a1, void *a2)
{
  result = sub_10004ACA4(a1, a2);
  if (result)
  {
    unint64_t v4 = result;
    do
    {
      unint64_t v4 = (void *)*v4;
      if (!v4) {
        break;
      }
    }

    while (v4[2] == *a2 && v4[3] == a2[1]);
  }

  return result;
}

uint64_t *sub_10009CA94(uint64_t *a1, _DWORD *a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = *(_DWORD **)(*a1 + 8);
  BOOL v6 = (void *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    BOOL v8 = *(_DWORD **)v4;
    uint64_t v9 = ((uint64_t)v5 - *(void *)v4) >> 2;
    unint64_t v10 = v9 + 1;
    uint64_t v11 = *v6 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      uint64_t v13 = (char *)sub_10000956C((uint64_t)v6, v12);
      BOOL v8 = *(_DWORD **)v4;
      unint64_t v5 = *(_DWORD **)(v4 + 8);
    }

    else
    {
      uint64_t v13 = 0LL;
    }

    unint64_t v14 = &v13[4 * v9];
    int v15 = &v13[4 * v12];
    *(_DWORD *)unint64_t v14 = *a2;
    unint64_t v7 = v14 + 4;
    while (v5 != v8)
    {
      int v16 = *--v5;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }

    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }

  else
  {
    *unint64_t v5 = *a2;
    unint64_t v7 = v5 + 1;
  }

  *(void *)(v4 + 8) = v7;
  return a1;
}

void sub_10009CB80(char **a1, unint64_t a2)
{
  BOOL v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }

    a1[1] = v7;
  }

  else
  {
    BOOL v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      sub_100007008();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = v5 - v8;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v14 = (char *)sub_10000956C(v4, v13);
      BOOL v8 = *a1;
      unint64_t v7 = a1[1];
    }

    else
    {
      unint64_t v14 = 0LL;
    }

    int v15 = &v14[4 * v11];
    int v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    BOOL v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      int v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }

    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8) {
      operator delete(v8);
    }
  }

char *sub_10009CC88(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  unint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  unint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    unint64_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 4);
    if (v14 >> 60) {
      sub_100007008();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 4;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 3 > v14) {
      unint64_t v14 = v16 >> 3;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      int v18 = (char *)sub_100037038(v9, v17);
    }
    else {
      int v18 = 0LL;
    }
    uint64_t v28 = &v18[16 * v15];
    __p = v18;
    v34 = v28;
    unint64_t v36 = &v18[16 * v17];
    uint64_t v29 = 16 * a5;
    int v30 = &v28[16 * a5];
    do
    {
      __int128 v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)uint64_t v28 = v31;
      v28 += 16;
      v29 -= 16LL;
    }

    while (v29);
    v35 = v30;
    unint64_t v5 = (char *)sub_10009CE94((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0LL;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }

  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    size_t v21 = &__src[16 * a5];
    unint64_t v23 = *(char **)(v9 - 8);
LABEL_17:
    int v24 = &v5[16 * a5];
    int v25 = &v23[-16 * a5];
    unint64_t v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      unint64_t v26 = v23;
      do
      {
        __int128 v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)unint64_t v26 = v27;
        v26 += 16;
      }

      while ((unint64_t)v25 < v12);
    }

    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }

  size_t v21 = &__src[16 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  }
  unint64_t v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_10009CE5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10009CE94(void **a1, uint64_t a2, char *__src)
{
  unint64_t v5 = *(void **)(a2 + 8);
  BOOL v6 = (char *)*a1;
  unint64_t v7 = v5;
  if (*a1 != __src)
  {
    BOOL v8 = __src;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      unint64_t v7 = (void *)(v9 - 16);
      *(_OWORD *)(v9 - 16) = *((_OWORD *)v8 - 1);
      v8 -= 16;
      v9 -= 16LL;
    }

    while (v8 != v6);
  }

  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    unint64_t v7 = *(void **)(a2 + 8);
  }

  *(void *)(a2 + 16) = v11 + v12;
  unint64_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void sub_10009CF68(void **a1, unint64_t a2)
{
  BOOL v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }

    a1[1] = v7;
  }

  else
  {
    uint64_t v8 = v7 - (_BYTE *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      sub_100007008();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      unint64_t v13 = (char *)sub_100037038(v4, v12);
    }
    else {
      unint64_t v13 = 0LL;
    }
    unint64_t v14 = &v13[16 * v10];
    uint64_t v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    uint64_t v16 = &v14[16 * a2];
    int v18 = (char *)*a1;
    unint64_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }

      while (v17 != v18);
      unint64_t v17 = (char *)*a1;
    }

    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17) {
      operator delete(v17);
    }
  }

void *sub_10009D074(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCCDLL) {
    sub_1000070D4();
  }
  return operator new(20 * a2);
}

  ;
}

void sub_10009D0CC(void *a1@<X1>, _BYTE *a2@<X2>, double *a3@<X3>, _BYTE *a4@<X8>)
{
  if (objc_msgSend(objc_msgSend(a1, "bundleId"), "isEqualToString:", &stru_1018A4B00))
  {
    double v8 = *a3;
    sub_1000635A4((uint64_t)v18);
    sub_10009D400((uint64_t)v18, 0, 0, 3u, (uint64_t)v22, v8);
    buf[0] = 0;
    sub_1000865CC(v25);
    *a4 = buf[0];
    sub_1000865CC(a4 + 8);
  }

  else
  {
    unint64_t v9 = (const std::string::value_type *)objc_msgSend( objc_msgSend(a1, "launchReason", sub_1000635A4((uint64_t)v18)),  "UTF8String");
    v21 |= 8u;
    uint64_t v10 = v20;
    if (v20 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v10 = (std::string *)operator new(0x18uLL);
      v10->__r_.__value_.__r.__words[0] = 0LL;
      v10->__r_.__value_.__l.__size_ = 0LL;
      v10->__r_.__value_.__l.__cap_ = 0LL;
      uint64_t v20 = v10;
    }

    std::string::assign(v10, v9);
    v21 |= 4u;
    uint64_t v11 = v19;
    if (!v19)
    {
      uint64_t v11 = (unsigned __int8 *)operator new(0x18uLL);
      sub_100063538((uint64_t)v11);
      uint64_t v19 = v11;
    }

    sub_100071530((uint64_t)v11, a2);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBA8);
    }
    unint64_t v12 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v13 = v20;
      int v14 = v21 | 4;
      v21 |= 4u;
      uint64_t v15 = v19;
      if (!v19)
      {
        uint64_t v15 = (unsigned __int8 *)operator new(0x18uLL);
        sub_100063538((uint64_t)v15);
        uint64_t v19 = v15;
        int v14 = v21 | 4;
      }

      int v16 = v15[8];
      int v21 = v14;
      int v17 = v15[9];
      *(_DWORD *)buf = 68289794;
      int v24 = 0;
      v25[0] = 34;
      v25[1] = 8;
      unint64_t v26 = "";
      __int16 v27 = 2082;
      uint64_t v28 = v13;
      __int16 v29 = 1026;
      int v30 = v16;
      __int16 v31 = 1026;
      int v32 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:appLaunch, launchReason:%{public, location:escape_only}s, islongformvideo:%{pub lic}hhd, is MR allowed app:%{public}hhd}",  buf,  0x28u);
    }

    sub_10009D400((uint64_t)v18, 0, 0, 3u, (uint64_t)v22, *a3);
    buf[0] = 1;
    sub_1000865CC(v25);
    *a4 = buf[0];
    sub_1000865CC(a4 + 8);
  }

  sub_100086708(v25);
  sub_100086708(v22);
  sub_100072C04((wireless_diagnostics::google::protobuf::MessageLite *)v18);
}

void sub_10009D39C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

void sub_10009D400( uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12 = *(_DWORD *)(a1 + 32);
  if (!sub_100064160(v12))
  {
    int v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    int v16 = "set_eventtype";
    goto LABEL_6;
  }

  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_100064130(a4) & 1) == 0)
  {
    int v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    int v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }

  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_100101A70(a5, a1);
}

void sub_10009D4E4(_Unwind_Exception *a1)
{
}

void sub_10009D4F8(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_10009D524(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  v9[0] = &off_10181CC40;
  v9[1] = a1;
  v9[3] = v9;
  v10[0] = &off_10181CCC0;
  v10[1] = a1;
  v10[3] = v10;
  v11[0] = &off_10181CD40;
  v11[1] = a1;
  v11[3] = v11;
  v12[0] = &off_10181CDC0;
  v12[1] = a1;
  v12[3] = v12;
  v13[0] = &off_10181CE40;
  v13[1] = a1;
  v13[3] = v13;
  v14[0] = &off_10181CEC0;
  v14[1] = a1;
  int v15 = v14;
  a1[3] = 0LL;
  a1[4] = 0LL;
  a1[2] = 0LL;
  uint64_t v4 = (char *)operator new(0xC0uLL);
  a1[4] = v4 + 192;
  a1[2] = v4;
  a1[3] = v4;
  uint64_t v5 = 0LL;
  a1[3] = sub_1000575E0((uint64_t)(a1 + 4), (uint64_t)v9, (uint64_t)&v16, (uint64_t)v4);
  do
  {
    BOOL v6 = (&v15)[v5];
    if (&v14[v5] == v6)
    {
      BOOL v6 = &v14[v5];
      uint64_t v7 = 4LL;
    }

    else
    {
      if (!v6) {
        goto LABEL_7;
      }
      uint64_t v7 = 5LL;
    }

    (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_7:
    v5 -= 4LL;
  }

  while (v5 != -24);
  return a1;
}

void sub_10009D688( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  uint64_t v14 = v13;
  *(void *)(v12 + 24) = v14;
  sub_10005771C(&a10);
  uint64_t v16 = 0LL;
  while (1)
  {
    int v17 = *(char **)(&a12 + v16 + 184);
    if (&a12 + v16 + 160 == v17) {
      break;
    }
    if (v17)
    {
      uint64_t v18 = 5LL;
LABEL_6:
      (*(void (**)(void))(*(void *)v17 + 8 * v18))();
    }

    v16 -= 32LL;
    if (v16 == -192) {
      _Unwind_Resume(a1);
    }
  }

  int v17 = &a12 + v16 + 160;
  uint64_t v18 = 4LL;
  goto LABEL_6;
}

uint64_t sub_10009D6F8()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsLearningLabeledRecordingTriggersLimit",  0x8000100u,  kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  unsigned int v2 = v7;
  uint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 250LL;
  }
}

void sub_10009D7B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10009D7D0@<X0>(uint64_t a1@<X0>, __int128 *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t result = sub_10009D958();
  if ((_DWORD)result)
  {
    sub_10002B6F4(*(void *)(a1 + 8), a2, v15);
    if (v17
      || *a2 != 0
      && (uint64_t v9 = *(void *)(a1 + 8),
          __int128 v10 = 0uLL,
          sub_10002B6F4(v9, &v10, v11),
          sub_1000A77B0((uint64_t)v15, (uint64_t)v11),
          sub_1000A7938((uint64_t)v11),
          v17))
    {
      uint64_t v7 = v16;
      if (!v16) {
        uint64_t v7 = *(void *)(qword_1019A09E0 + 24);
      }
      uint64_t v8 = *(void *)(v7 + 8);
      if (!v8) {
        uint64_t v8 = *(void *)(qword_1019A09D0 + 8);
      }
      sub_10014C3FC((uint64_t)v11, v8);
      if (v11 != (_BYTE *)a3)
      {
        *(_DWORD *)(a3 + 32) = v13;
        sub_1000193A0((void *)a3, v12, 0LL);
      }

      *(_OWORD *)(a3 + 40) = v14;
      sub_100019CEC((uint64_t)v11);
    }

    return sub_1000A7938((uint64_t)v15);
  }

  return result;
}

void sub_10009D90C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

uint64_t sub_10009D958()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsAdaptiveAnchorsEnable", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A6FD4(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  BOOL v2 = v7;
  uint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v2) {
    return 1LL;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_10009DA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10009DA30( uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  v31[0] = a5;
  v31[1] = a6;
  if (a3[1] != *a3)
  {
    sub_101228B98();
    goto LABEL_31;
  }

  if (*(void *)(a4 + 8) != *(void *)a4)
  {
    sub_101228A28();
LABEL_31:
    __break(1u);
  }

  char v10 = a5;
  uint64_t v14 = a2 + 24;
  sub_100026FB8(*(void *)(a1 + 8), a2 + 24, a5, a6, a8, __p, 0.0);
  sub_1000A9954(a3);
  *(_OWORD *)a3 = *(_OWORD *)__p;
  a3[2] = v27;
  __p[1] = 0LL;
  uint64_t v27 = 0LL;
  __p[0] = 0LL;
  *(void *)&__int128 v29 = __p;
  sub_100012948((void ***)&v29);
  uint64_t v15 = a3[1] - *a3;
  if (a8 > (unint64_t)(v15 >> 6))
  {
    if (v10)
    {
LABEL_5:
      sub_100026FB8(*(void *)(a1 + 8), v14, 0LL, 0LL, a8 - ((unint64_t)v15 >> 6), __p, 0.0);
      sub_1000A998C(a3, a3[1], (uint64_t)__p[0], (__int128 *)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 6);
      *(void *)&__int128 v29 = __p;
      sub_100012948((void ***)&v29);
    }

    else
    {
      uint64_t v24 = 1LL;
      while (v24 != 16)
      {
        if (*((unsigned __int8 *)v31 + v24++))
        {
          break;
        }
      }
    }
  }

  int v16 = *(char *)(a2 + 23);
  if (v16 < 0)
  {
    if (*(void *)(a2 + 8) != 10LL) {
      goto LABEL_18;
    }
    uint64_t v17 = *(void *)a2;
  }

  else
  {
    uint64_t v17 = a2;
    if (v16 != 10) {
      goto LABEL_18;
    }
  }

  uint64_t v18 = *(void *)v17;
  int v19 = *(unsigned __int16 *)(v17 + 8);
  if (v18 == 0x6F6D2D7375636F66LL && v19 == 25956)
  {
    uint64_t v21 = a3[1] - *a3;
    if (a8 > (unint64_t)(v21 >> 6))
    {
      sub_100026FB8(*(void *)(a1 + 8), a2, 0LL, 0LL, a8 - ((unint64_t)v21 >> 6), __p, 0.0);
      sub_1000A998C(a3, a3[1], (uint64_t)__p[0], (__int128 *)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 6);
      *(void *)&__int128 v29 = __p;
      sub_100012948((void ***)&v29);
    }
  }

void sub_10009DCEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void **p_p)
{
  p_p = &__p;
  sub_100012948(&p_p);
  _Unwind_Resume(a1);
}

void sub_10009DD30(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  unsigned int v165 = a3;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CBC8);
  }
  unint64_t v5 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)v196 = 2082;
    *(void *)&v196[2] = "";
    *(_WORD *)&v196[10] = 2050;
    *(void *)&v196[12] = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:start learn model, model-type:%{public}lu}",  buf,  0x1Cu);
  }

  sub_1002F0B04(buf);
  BOOL v6 = kCFAllocatorNull;
  CFStringRef v7 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsEnableLearning", 0x8000100u, kCFAllocatorNull);
  int v8 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v7, (BOOL *)&__p);
  CFRelease(v7);
  int v9 = __p;
  char v10 = *(std::__shared_weak_count **)v196;
  if (*(void *)v196)
  {
    uint64_t v11 = (unint64_t *)(*(void *)v196 + 8LL);
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  if (v9) {
    int v13 = 0;
  }
  else {
    int v13 = v8;
  }
  if (v13 == 1)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v14 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "#Warning Tried to run learning, but learning is disabled",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      LOWORD(__p) = 0;
      uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Tried to run learning, but learning is disabled",  &__p,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationPro to::Model::ModelType)",  "%s\n",  v15);
LABEL_67:
      return;
    }

    return;
  }

  sub_1002F0B04(&__p);
  int v16 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsEnabledModelTypes", 0x8000100u, kCFAllocatorNull);
  BOOL v17 = sub_1002AA610((uint64_t)__p, v16, (CFTypeRef *)v178);
  CFRelease(v16);
  if (v17)
  {
    v18.n128_f64[0] = sub_1000A7978(*(const __CFArray **)v178, (uint64_t)buf);
  }

  else
  {
    *(void *)v196 = 0LL;
    *(void *)buf = 0LL;
    *(void *)&v196[8] = 0LL;
    *(void *)buf = operator new(8uLL);
    *(_OWORD *)v196 = xmmword_1012CB1D0;
    sub_1000A7E0C(buf, byte_1012CCD50, &byte_1012CCD50[3], 3LL);
  }

  int v19 = v192;
  if (v192)
  {
    p_shared_owners = (unint64_t *)&v192->__shared_owners_;
    do
      unint64_t v21 = __ldaxr(p_shared_owners);
    while (__stlxr(v21 - 1, p_shared_owners));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *, __n128))v19->__on_zero_shared)(v19, v18);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  v128 = a1;
  unint64_t v22 = *(void *)(*(void *)buf + (((unint64_t)v165 >> 3) & 0x1FFFFFF8));
  operator delete(*(void **)buf);
  if (((v22 >> v165) & 1) == 0)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    v38 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67174657;
      *(_DWORD *)&uint8_t buf[4] = v165;
      _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEBUG,  "Model Type %{private}d disabled in settings",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      LODWORD(__p) = 67174657;
      HIDWORD(__p) = v165;
      uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Model Type %{private}d disabled in settings",  &__p,  8);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationPro to::Model::ModelType)",  "%s\n",  v15);
      goto LABEL_67;
    }

    return;
  }

  sub_1000303F0((void *)v128[1]);
  if (sub_100031790(v128[1]))
  {
    double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
    sub_1004F2598();
    sub_1002F0B04(buf);
    CFStringRef v24 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsEnableSamplingForLearningAnalyticsOnInternal",  0x8000100u,  kCFAllocatorNull);
    int v25 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v24, (BOOL *)&__p);
    CFRelease(v24);
    int v26 = __p;
    uint64_t v27 = *(std::__shared_weak_count **)v196;
    if (*(void *)v196)
    {
      uint64_t v28 = (unint64_t *)(*(void *)v196 + 8LL);
      do
        unint64_t v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }

    int v30 = v26 ? v25 : 0;
    if (v30 != 1)
    {
      BOOL v37 = 1;
    }

    else
    {
LABEL_43:
      sub_1002F0B04(buf);
      CFStringRef v31 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsSamplingRateForLearningAnalytics",  0x8000100u,  kCFAllocatorNull);
      int v32 = sub_1002A832C(*(uint64_t *)buf, (uint64_t)v31, &__p);
      CFRelease(v31);
      double v33 = *(double *)&__p;
      v34 = *(std::__shared_weak_count **)v196;
      if (*(void *)v196)
      {
        v35 = (unint64_t *)(*(void *)v196 + 8LL);
        do
          unint64_t v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }

      if (!v32) {
        double v33 = 0.1;
      }
      BOOL v37 = (double)arc4random_uniform(0xF4241u) / 1000000.0 <= v33;
    }

    sub_1002F0B04(buf);
    CFStringRef v40 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsAnalyticsSendEventEnabled", 0x8000100u, kCFAllocatorNull);
    int v41 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v40, (BOOL *)&__p);
    CFRelease(v40);
    int v42 = __p;
    v43 = *(std::__shared_weak_count **)v196;
    if (*(void *)v196)
    {
      v44 = (unint64_t *)(*(void *)v196 + 8LL);
      do
        unint64_t v45 = __ldaxr(v44);
      while (__stlxr(v45 - 1, v44));
      if (!v45)
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }

    int v46 = v41 ^ 1;
    if (v42) {
      int v46 = 1;
    }
    char v164 = v46;
    int v47 = v37 & v46;
    unsigned __int8 v163 = v37 & v46;
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v48 = (uint64_t)v128;
    signed int v49 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      sub_100103634((void *)v165, (uint64_t)&__p);
      uint64_t v50 = v193 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)v196 = 2082;
      *(void *)&v196[2] = "";
      *(_WORD *)&v196[10] = 2082;
      *(void *)&v196[12] = v50;
      *(_WORD *)&v196[20] = 1026;
      *(_DWORD *)&v196[22] = v47;
      _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Analytics events for learning, model type:%{public, location:escape_only}s, enabl ed:%{public}hhd}",  buf,  0x22u);
      if (v193 < 0) {
        operator delete(__p);
      }
    }

    sub_1000C7998(v165, (char **)&v161);
    if (v161 == v162)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      uint64_t v56 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = v165;
        _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "#Warning No recording events for model type %{public}d",  buf,  8u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181CBC8);
        }
        LODWORD(__p) = 67240192;
        HIDWORD(__p) = v165;
        uint64_t v57 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning No recording events for model type %{public}d",  &__p,  8);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationP roto::Model::ModelType)",  "%s\n",  v57);
      }

      goto LABEL_271;
    }

    LOBYTE(__p) = 0;
    char v194 = 0;
    v190[0] = 0;
    v190[112] = 0;
    LOBYTE(v159) = 0;
    char v160 = 0;
    memset(v157, 0, sizeof(v157));
    int v158 = 1065353216;
    v156[0] = v128;
    v156[1] = &v165;
    v156[2] = &v164;
    v156[3] = &__p;
    v156[4] = v190;
    v156[5] = &v159;
    if (v165 == 2)
    {
      sub_1000A0F70((uint64_t)v128, 4u, 0, (uint64_t *)&v154);
      if (v154 == v155)
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181CBC8);
        }
        v119 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 68289026;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)v196 = 2082;
          *(void *)&v196[2] = "";
          _os_log_impl( (void *)&_mh_execute_header,  v119,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:skipping Location Similarity List model learning, no such clients}",  buf,  0x12u);
        }
      }

      else
      {
        sub_100029334(v128[1], &v149);
        buf[0] = 0;
        v196[16] = 0;
        id v123 = sub_10008EAEC(v47, (void *)v165, (const std::string *)buf);
        if (v196[16] && (v196[15] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v60 = v149;
        uint64_t v59 = v150;
        if (v149 != v150)
        {
          uint64_t v122 = v150;
          do
          {
            v124 = (uint64_t *)(v60 + 40);
            unint64_t v127 = sub_1000E72E8((uint64_t *)(v60 + 40));
            __int128 v61 = (__int128 *)(v60 + 24);
            if (v62)
            {
              v146 = 0LL;
              uint64_t v147 = 0LL;
              v145 = 0LL;
              sub_10001B72C(&v145, v161, (uint64_t)v162, (v162 - (_BYTE *)v161) >> 2);
              sub_10009FF0C(v48, (uint64_t)&v145, *(void *)(v60 + 24), *(void *)(v60 + 32), (uint64_t)v148);
              if (v145)
              {
                v146 = v145;
                operator delete(v145);
              }

              sub_10009D7D0(v48, (__int128 *)(v60 + 24), (uint64_t)v144);
              if (qword_1019348D0 != -1) {
                dispatch_once(&qword_1019348D0, &stru_10181CBC8);
              }
              uint64_t v63 = (os_log_s *)qword_1019348D8;
              if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
              {
                uint64_t v64 = (char *)operator new(0x28uLL);
                *(void *)v178 = v64;
                *(_OWORD *)v179 = xmmword_1012C8460;
                *(_OWORD *)uint64_t v64 = 0u;
                *((_OWORD *)v64 + 1) = 0u;
                *(void *)(v64 + 29) = 0LL;
                sub_10000AE6C(v60 + 24, v64);
                v65 = v179[15] >= 0 ? v178 : *(uint8_t **)v178;
                *(_DWORD *)buf = 68289282;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)v196 = 2082;
                *(void *)&v196[2] = "";
                *(_WORD *)&v196[10] = 2082;
                *(void *)&v196[12] = v65;
                _os_log_impl( (void *)&_mh_execute_header,  v63,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:learning internal model for LOI, loiGroupId:%{public, location:escape_only}s}",  buf,  0x1Cu);
                if ((v179[15] & 0x80000000) != 0) {
                  operator delete(*(void **)v178);
                }
              }

              v178[0] = 0;
              char v189 = 0;
              sub_1000A1790( v48,  v123,  (uint64_t)v148,  a2,  (uint64_t)v144,  (uint64_t)v157,  v60 + 24,  (uint64_t)v178,  buf,  Current_1,  v165);
              sub_100019D34((uint64_t)v178);
              if (v202 && sub_100097CA8((uint64_t)buf))
              {
                if (!v202) {
                  sub_100036CD8();
                }
                LOBYTE(v140) = 0;
                char v143 = 0;
                sub_1002F0B04(v178);
                CFStringRef v66 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsClusterAnchorValueStatisticsEnabled",  0x8000100u,  v6);
                char v67 = sub_1002A6FD4(*(uint64_t *)v178, (uint64_t)v66, (BOOL *)&v173);
                CFRelease(v66);
                int v68 = v173;
                v69 = *(std::__shared_weak_count **)v179;
                if (*(void *)v179)
                {
                  v70 = (unint64_t *)(*(void *)v179 + 8LL);
                  do
                    unint64_t v71 = __ldaxr(v70);
                  while (__stlxr(v71 - 1, v70));
                  if (!v71)
                  {
                    ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
                    std::__shared_weak_count::__release_weak(v69);
                  }
                }

                if (v68) {
                  char v72 = 0;
                }
                else {
                  char v72 = v67;
                }
                if ((v72 & 1) == 0) {
                  sub_1000A3604((uint64_t)&v140);
                }
                v126 = v155;
                id v73 = v123;
                if (v154 != v155)
                {
                  int v74 = v154 + 3;
                  do
                  {
                    unint64_t v75 = sub_1000F0D94((unint64_t)v74[3]);
                    if (v127 >= 0x20) {
                      sub_10000C918("bitset test argument out of range");
                    }
                    if ((v75 & (1LL << v127)) != 0)
                    {
                      if (qword_1019348D0 != -1) {
                        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
                      }
                      v76 = v74 - 3;
                      v77 = (os_log_s *)qword_1019348D8;
                      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
                      {
                        v78 = v74 - 3;
                        v79 = v74;
                        char v80 = operator new(0x28uLL);
                        v173 = v80;
                        __int128 v174 = xmmword_1012C8460;
                        *char v80 = 0u;
                        v80[1] = 0u;
                        *(void *)((char *)v80 + 29) = 0LL;
                        sub_10000AE6C(v60 + 24, v80);
                        int v81 = &v173;
                        if (v174 < 0) {
                          int v81 = v173;
                        }
                        id v73 = v123;
                        uint64_t v82 = v60 + 40;
                        *(_DWORD *)v178 = 68290050;
                        *(_DWORD *)&v178[4] = 0;
                        *(_WORD *)v179 = 2082;
                        *(void *)&v179[2] = "";
                        *(_WORD *)&v179[10] = 2082;
                        *(void *)&v179[12] = v78;
                        __int16 v180 = 2082;
                        v181 = v79;
                        __int16 v182 = 2082;
                        v183 = v81;
                        __int16 v184 = 2082;
                        uint64_t v185 = v82;
                        _os_log_impl( (void *)&_mh_execute_header,  v77,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:learning a Location Similarity List model for client, ClientId:%{ public, location:escape_only}s, ClientIdAndServiceUuid:%{public, location:escape_only}s,  loiGroupId:%{public, location:escape_only}s, loiType:%{public, location:escape_only}s}",  v178,  0x3Au);
                        if (SHIBYTE(v174) < 0) {
                          operator delete(v173);
                        }
                        uint64_t v48 = (uint64_t)v128;
                      }

                      if (v73)
                      {
                        __int16 v83 = +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v73);
                        v84 = v74 - 3;
                        -[NSMutableDictionary setObject:forKeyedSubscript:]( v83,  "setObject:forKeyedSubscript:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v84),  @"clientIdentifier");
                      }

                      else
                      {
                        __int16 v83 = 0LL;
                      }

                      uint64_t v85 = *(void *)(v48 + 8);
                      if (*((char *)v74 + 23) < 0)
                      {
                        sub_1010DD48C(__dst, *v74, (unint64_t)v74[1]);
                      }

                      else
                      {
                        __int128 v86 = *(_OWORD *)v74;
                        v138 = v74[2];
                        *(_OWORD *)__dst = v86;
                      }

                      char v139 = 1;
                      __int128 v176 = *v61;
                      char v177 = 1;
                      sub_100028FD8(v85, 2u, (__int128 *)__dst, &v176, v178);
                      if (v139 && SHIBYTE(v138) < 0) {
                        operator delete(__dst[0]);
                      }
                      LOBYTE(v135[0]) = 0;
                      char v136 = 0;
                      if (v189)
                      {
                        v135[0] = v187 | ((unint64_t)v186 << 32);
                        v135[1] = *(void *)&v179[8];
                        char v136 = 1;
                      }

                      sub_10001D050((uint64_t)v178);
                      v133 = 0LL;
                      uint64_t v134 = 0LL;
                      v132 = 0LL;
                      sub_10001B72C(&v132, v161, (uint64_t)v162, (v162 - (_BYTE *)v161) >> 2);
                      sub_1000A3648( v48,  v83,  a2,  (uint64_t)(v74 - 3),  buf,  (uint64_t *)(v60 + 24),  (uint64_t)&v132,  (uint64_t)&v173,  Current_1,  (uint64_t)v135);
                      if (v132)
                      {
                        v133 = v132;
                        operator delete(v132);
                      }

                      if (v175)
                      {
                        if (v143)
                        {
                          sub_10014EDAC((uint64_t)&v140, (const std::string::value_type *)&v173, (uint64_t)v166);
                          *(_OWORD *)&v171[2] = *v61;
                          sub_1000A4DBC((uint64_t)v190, (uint64_t)v166);
                          sub_10008C0E0((wireless_diagnostics::google::protobuf::MessageLite *)&v172);
                          if ((v171[1] & 0x80000000) != 0) {
                            operator delete(*(void **)v167);
                          }
                          if (!v175) {
                            sub_100036CD8();
                          }
                        }

                        sub_1000A062C((uint64_t)&__p, (uint64_t)&v173);
                        if (qword_1019348D0 != -1) {
                          dispatch_once(&qword_1019348D0, &stru_10181CBC8);
                        }
                        __int16 v87 = (os_log_s *)qword_1019348D8;
                        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
                        {
                          int v88 = v74;
                          __int16 v89 = operator new(0x28uLL);
                          v130 = v89;
                          __int128 v131 = xmmword_1012C8460;
                          *__int16 v89 = 0u;
                          v89[1] = 0u;
                          *(void *)((char *)v89 + 29) = 0LL;
                          sub_10000AE6C((uint64_t)&v173, v89);
                          int v90 = &v130;
                          if (v131 < 0) {
                            int v90 = v130;
                          }
                          *(_DWORD *)v166 = 68289538;
                          *(_DWORD *)&v166[4] = 0;
                          *(_WORD *)v167 = 2082;
                          *(void *)&v167[2] = "";
                          __int16 v168 = 2082;
                          v169 = v88;
                          __int16 v170 = 2082;
                          *(void *)v171 = v90;
                          _os_log_impl( (void *)&_mh_execute_header,  v87,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Inserted Similarity list Model, ClientIdAndServiceUuid:%{public , location:escape_only}s, ModelUuid:%{public, location:escape_only}s}",  v166,  0x26u);
                          if (SHIBYTE(v131) < 0) {
                            operator delete(v130);
                          }
                        }
                      }

                      if (v83)
                      {
                        v159 = v83;
                        char v160 = 1;
                      }

                      sub_1000A0670((uint64_t)v156);
                      sub_100019D34((uint64_t)&v173);
                      sub_100019D34((uint64_t)v178);
                    }

                    __int16 v91 = v74 + 4;
                    v74 += 7;
                  }

                  while (v91 != v126);
                }

                if (v143) {
                  sub_1000A8728((uint64_t)&v140);
                }
                uint64_t v59 = v122;
                BOOL v6 = kCFAllocatorNull;
              }

              else
              {
                if (qword_1019348D0 != -1) {
                  dispatch_once(&qword_1019348D0, &stru_10181CBC8);
                }
                int v92 = (os_log_s *)qword_1019348D8;
                if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)v178 = 68289026;
                  *(_DWORD *)&v178[4] = 0;
                  *(_WORD *)v179 = 2082;
                  *(void *)&v179[2] = "";
                  _os_log_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Similarity List Model Learning, unsupervised model not created or is invalid so learning is skipped}",  v178,  0x12u);
                }
              }

              sub_1000A879C((uint64_t)buf);
              sub_100019CEC((uint64_t)v144);
              *(void *)buf = v148;
              sub_10001A350((void ***)buf);
            }

            else
            {
              if (qword_1019348D0 != -1) {
                dispatch_once(&qword_1019348D0, &stru_10181CBC8);
              }
              v93 = (os_log_s *)qword_1019348D8;
              if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
              {
                v94 = (char *)operator new(0x28uLL);
                *(void *)v178 = v94;
                *(_OWORD *)v179 = xmmword_1012C8460;
                *(_OWORD *)v94 = 0u;
                *((_OWORD *)v94 + 1) = 0u;
                *(void *)(v94 + 29) = 0LL;
                sub_10000AE6C(v60 + 24, v94);
                if (v179[15] >= 0) {
                  __int16 v95 = (const __CFArray *)v178;
                }
                else {
                  __int16 v95 = *(const __CFArray **)v178;
                }
                uint64_t v96 = v60 + 40;
                *(_DWORD *)buf = 68289538;
                *(_DWORD *)&uint8_t buf[4] = 0;
                *(_WORD *)v196 = 2082;
                *(void *)&v196[2] = "";
                *(_WORD *)&v196[10] = 2082;
                *(void *)&v196[12] = v95;
                *(_WORD *)&v196[20] = 2082;
                *(void *)&v196[22] = v96;
                _os_log_impl( (void *)&_mh_execute_header,  v93,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:skipping Location Similarity List model learning because of LOI, loiGroupId :%{public, location:escape_only}s, loiType:%{public, location:escape_only}s}",  buf,  0x26u);
                if ((v179[15] & 0x80000000) != 0) {
                  operator delete(*(void **)v178);
                }
              }
            }

            v60 += 64LL;
          }

          while (v60 != v59);
        }

        *(void *)buf = &v149;
        sub_10003706C((void ***)buf);
      }

      v58 = (uint8_t *)&v154;
    }

    else
    {
      if (v165 != 1)
      {
        if (v165)
        {
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181CBC8);
          }
          __int16 v97 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)v196 = 2082;
            *(void *)&v196[2] = "";
            *(_WORD *)&v196[10] = 2050;
            *(void *)&v196[12] = v165;
            _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:invalid model type, model type:%{public}lu}",  buf,  0x1Cu);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181CBC8);
            }
          }

          v98 = (os_log_s *)qword_1019348D8;
          if (os_signpost_enabled((os_log_t)qword_1019348D8))
          {
            *(_DWORD *)buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)v196 = 2082;
            *(void *)&v196[2] = "";
            *(_WORD *)&v196[10] = 2050;
            *(void *)&v196[12] = v165;
            _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v98,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "invalid model type",  "{msg%{public}.0s:invalid model type, model type:%{public}lu}",  buf,  0x1Cu);
          }
        }

        else
        {
          sub_100029334(v128[1], (uint64_t *)v166);
          sub_10002DC1C(v128[1], 1u, v144);
          uint64_t v51 = (uint64_t *)&v141;
          v141 = 0LL;
          uint64_t v142 = 0LL;
          v140 = (uint64_t *)&v141;
          v53 = (void **)v144[0];
          v52 = (void **)v144[1];
          while (v53 != v52)
          {
            v55 = *v53;
            uint64_t v54 = (uint64_t)(v53 + 4);
            sub_1000F0EFC(v55, v54, buf);
            sub_10002276C(&v140, (const void **)buf, (uint64_t)buf);
            if ((v196[15] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            v53 = (void **)(v54 + 56);
          }

          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181CBC8);
          }
          uint64_t v99 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)v196 = 2082;
            *(void *)&v196[2] = "";
            *(_WORD *)&v196[10] = 2050;
            *(void *)&v196[12] = v142;
            _os_log_impl( (void *)&_mh_execute_header,  v99,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Learning Unsupervised Model for clients, Num Clients:%{public}lu}",  buf,  0x1Cu);
          }

          uint64_t v100 = *(void *)v166;
          uint64_t v101 = *(void *)v167;
          if (*(void *)v166 != *(void *)v167)
          {
            uint64_t v125 = *(void *)v167;
            do
            {
              char v102 = (void ***)(v100 + 40);
              uint64_t v103 = sub_1000E72E8((uint64_t *)(v100 + 40));
              if (v104) {
                BOOL v105 = v103 == 0;
              }
              else {
                BOOL v105 = 0;
              }
              if (v105)
              {
                v152 = 0LL;
                uint64_t v153 = 0LL;
                v151 = 0LL;
                sub_10001B72C(&v151, v161, (uint64_t)v162, (v162 - (_BYTE *)v161) >> 2);
                sub_10009FF0C( (uint64_t)v128,  (uint64_t)&v151,  *(void *)(v100 + 24),  *(void *)(v100 + 32),  (uint64_t)&v154);
                if (v151)
                {
                  v152 = v151;
                  operator delete(v151);
                }

                sub_10009D7D0((uint64_t)v128, (__int128 *)(v100 + 24), (uint64_t)&v173);
                v109 = v140;
                if (v140 != v51)
                {
                  do
                  {
                    buf[0] = 0;
                    v196[16] = 0;
                    v110 = (NSMutableDictionary *)sub_10008EAEC(v163, (void *)v165, (const std::string *)buf);
                    if (v196[16] && (v196[15] & 0x80000000) != 0) {
                      operator delete(*(void **)buf);
                    }
                    if (qword_1019348D0 != -1) {
                      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
                    }
                    v111 = (os_log_s *)qword_1019348D8;
                    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
                    {
                      v112 = v51;
                      v113 = v109 + 4;
                      v114 = (char *)operator new(0x28uLL);
                      *(void *)v178 = v114;
                      *(_OWORD *)v179 = xmmword_1012C8460;
                      *(_OWORD *)v114 = 0u;
                      *((_OWORD *)v114 + 1) = 0u;
                      *(void *)(v114 + 29) = 0LL;
                      sub_10000AE6C(v100 + 24, v114);
                      v115 = (const __CFArray *)v178;
                      if (v179[15] < 0) {
                        v115 = *(const __CFArray **)v178;
                      }
                      v116 = (void **)(v100 + 40);
                      *(_DWORD *)buf = 68289794;
                      *(_DWORD *)&uint8_t buf[4] = 0;
                      *(_WORD *)v196 = 2082;
                      *(void *)&v196[2] = "";
                      *(_WORD *)&v196[10] = 2082;
                      *(void *)&v196[12] = v113;
                      *(_WORD *)&v196[20] = 2082;
                      *(void *)&v196[22] = v115;
                      *(_WORD *)&v196[30] = 2082;
                      v197 = v116;
                      _os_log_impl( (void *)&_mh_execute_header,  v111,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Learning Unsupervised Model for client, Client ID:%{public, locatio n:escape_only}s, loiGroupId:%{public, location:escape_only}s, loiType:%{public, location:escape_only}s}",  buf,  0x30u);
                      if ((v179[15] & 0x80000000) != 0) {
                        operator delete(*(void **)v178);
                      }
                      uint64_t v51 = v112;
                    }

                    sub_1000A0028( (uint64_t)v128,  (uint64_t)(v109 + 4),  *(void *)(v100 + 24),  *(void *)(v100 + 32),  (uint64_t)buf);
                    sub_1000A0158( (uint64_t)v128,  v110,  (uint64_t)&v154,  a2,  (uint64_t)&v173,  (uint64_t)v157,  (uint64_t)(v109 + 4),  v100 + 24,  v178,  (uint64_t)buf);
                    if (v189)
                    {
                      __int128 v188 = *(_OWORD *)(v100 + 24);
                      sub_1000A062C((uint64_t)&__p, (uint64_t)v178);
                      sub_10001D050((uint64_t)v178);
                    }

                    if (v110)
                    {
                      v159 = v110;
                      char v160 = 1;
                    }

                    sub_1000A0670((uint64_t)v156);
                    sub_100019D34((uint64_t)v178);
                    sub_100019D34((uint64_t)buf);
                    v117 = (uint64_t *)v109[1];
                    if (v117)
                    {
                      do
                      {
                        v118 = v117;
                        v117 = (uint64_t *)*v117;
                      }

                      while (v117);
                    }

                    else
                    {
                      do
                      {
                        v118 = (uint64_t *)v109[2];
                        BOOL v105 = *v118 == (void)v109;
                        v109 = v118;
                      }

                      while (!v105);
                    }

                    v109 = v118;
                  }

                  while (v118 != v51);
                }

                sub_100019CEC((uint64_t)&v173);
                *(void *)buf = &v154;
                sub_10001A350((void ***)buf);
                uint64_t v101 = v125;
              }

              else
              {
                if (qword_1019348D0 != -1) {
                  dispatch_once(&qword_1019348D0, &stru_10181CBC8);
                }
                v106 = (os_log_s *)qword_1019348D8;
                if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
                {
                  v107 = (char *)operator new(0x28uLL);
                  *(void *)v178 = v107;
                  *(_OWORD *)v179 = xmmword_1012C8460;
                  *(_OWORD *)v107 = 0u;
                  *((_OWORD *)v107 + 1) = 0u;
                  *(void *)(v107 + 29) = 0LL;
                  sub_10000AE6C(v100 + 24, v107);
                  v108 = (const __CFArray *)v178;
                  if (v179[15] < 0) {
                    v108 = *(const __CFArray **)v178;
                  }
                  *(_DWORD *)buf = 68289538;
                  *(_DWORD *)&uint8_t buf[4] = 0;
                  *(_WORD *)v196 = 2082;
                  *(void *)&v196[2] = "";
                  *(_WORD *)&v196[10] = 2082;
                  *(void *)&v196[12] = v108;
                  *(_WORD *)&v196[20] = 2082;
                  *(void *)&v196[22] = v102;
                  _os_log_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:skipping Location Unsupervised model learning because of LOI, loiGroupId :%{public, location:escape_only}s, loiType:%{public, location:escape_only}s}",  buf,  0x26u);
                  if ((v179[15] & 0x80000000) != 0) {
                    operator delete(*(void **)v178);
                  }
                }
              }

              v100 += 64LL;
            }

            while (v100 != v101);
          }

          sub_1000229D4((uint64_t)&v140, v141);
          *(void *)buf = v144;
          sub_1000AA544((void ***)buf);
          *(void *)buf = v166;
          sub_10003706C((void ***)buf);
        }

        goto LABEL_270;
      }

      sub_1000A0F70((uint64_t)v128, 3u, 1, (uint64_t *)v178);
      sub_1000A0F70((uint64_t)v128, 2u, 1, (uint64_t *)&v173);
      sub_100029334(v128[1], (uint64_t *)v166);
      *(void *)buf = v128;
      *(void *)v196 = v156;
      *(void *)&v196[8] = &v165;
      *(void *)&v196[16] = &v163;
      *(void *)&v196[24] = &v159;
      v197 = &v161;
      uint64_t v198 = a2;
      v199 = v157;
      p_p = &__p;
      v201 = v166;
      sub_1000A1294((uint64_t)buf, (uint64_t *)v178, 3u);
      sub_1000A1294((uint64_t)buf, (uint64_t *)&v173, 4u);
      *(void *)buf = v166;
      sub_10003706C((void ***)buf);
      *(void *)buf = &v173;
      sub_1000AA60C((void ***)buf);
      v58 = v178;
    }

    *(void *)buf = v58;
    sub_1000AA60C((void ***)buf);
LABEL_270:
    (*(void (**)(uint64_t, void))(*(void *)*v128 + 32LL))(*v128, v165);
    sub_1000A8814((uint64_t)v157);
    sub_1000A7938((uint64_t)v190);
    sub_100019D34((uint64_t)&__p);
LABEL_271:
    double v120 = j__CFAbsoluteTimeGetCurrent_1();
    if (qword_1019348E0 != -1) {
      dispatch_once(&qword_1019348E0, &stru_10181CBE8);
    }
    v121 = (os_log_s *)qword_1019348E8;
    if (os_log_type_enabled((os_log_t)qword_1019348E8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)v196 = 2082;
      *(void *)&v196[2] = "";
      *(_WORD *)&v196[10] = 2050;
      *(void *)&v196[12] = v165;
      *(_WORD *)&v196[20] = 2050;
      *(double *)&v196[22] = v120 - Current_1;
      _os_log_impl( (void *)&_mh_execute_header,  v121,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Learning, completed, model-type:%{public}lu, Total Time (sec):%{public}.4f}",  buf,  0x26u);
    }

    if (v161)
    {
      v162 = v161;
      operator delete(v161);
    }

    return;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CBC8);
  }
  unint64_t v39 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "#Warning Tried to run learning, but database is not valid",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    LOWORD(__p) = 0;
    uint64_t v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Tried to run learning, but database is not valid",  &__p,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto ::Model::ModelType)",  "%s\n",  v15);
    goto LABEL_67;
  }

void sub_10009FB24(_Unwind_Exception *a1)
{
  BOOL v2 = (void *)STACK[0x290];
  if (STACK[0x290])
  {
    STACK[0x298] = (unint64_t)v2;
    operator delete(v2);
  }

  _Unwind_Resume(a1);
}

_BYTE *sub_10009FEA0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x28uLL);
  *(void *)a2 = v4;
  *(_OWORD *)(a2 + 8) = xmmword_1012C8460;
  *(_OWORD *)uint64_t v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *(void *)(v4 + 29) = 0LL;
  return sub_10000AE6C(a1, v4);
}

void sub_10009FEF0(_Unwind_Exception *exception_object)
{
}

void sub_10009FF0C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  *(void *)&__int128 v17 = a3;
  *((void *)&v17 + 1) = a4;
  uint64_t v8 = *(void *)(a1 + 8);
  __int128 v15 = v17;
  char v16 = 1;
  sub_1000A74D4(v8, a2, &v15, (void *)a5);
  if (v17 != 0)
  {
    uint64_t v9 = *(void *)(a1 + 8);
    __int128 v13 = 0uLL;
    char v14 = 1;
    sub_1000A74D4(v9, a2, &v13, &v10);
    sub_1000B0364((uint64_t *)a5, *(__int128 **)(a5 + 8), v10, v11, 0xEEEEEEEEEEEEEEEFLL * (v11 - v10));
    unint64_t v12 = &v10;
    sub_10001A350((void ***)&v12);
  }

void sub_10009FFF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, void ***a13)
{
  a13 = &a10;
  sub_10001A350((void ***)&a13);
  sub_10001A350(&a10);
  _Unwind_Resume(a1);
}

void sub_1000A0028(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  if (!*(_BYTE *)(a5 + 280))
  {
    sub_100028CE4(*(void *)(a1 + 8), a2, 0LL, 0LL, v10);
    sub_1000A88B8(a5, (uint64_t)v10);
    sub_100019D34((uint64_t)v10);
    if (*(_BYTE *)(a5 + 280))
    {
      *(void *)(a5 + 264) = a3;
      *(void *)(a5 + 272) = a4;
    }

    else
    {
      sub_1000289F0(*(void *)(a1 + 8), 0, a3, a4, v10);
      sub_1000A88B8(a5, (uint64_t)v10);
      sub_100019D34((uint64_t)v10);
      if (*(_BYTE *)(a5 + 280))
      {
        if (*(_BYTE *)(a5 + 256)) {
          sub_10001D050(a5);
        }
      }
    }
  }

void sub_1000A012C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000A0158@<X0>( uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, _BYTE *a9@<X8>, uint64_t a10)
{
  *a9 = 0;
  a9[280] = 0;
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  sub_1000A1790(a1, a2, a3, a4, a5, a6, a8, a10, v34, Current_1, 0);
  if (v46 && sub_100097CA8((uint64_t)v34))
  {
    if (qword_1019348E0 != -1) {
      dispatch_once(&qword_1019348E0, &stru_10181CBE8);
    }
    uint64_t v20 = (os_log_s *)qword_1019348E8;
    if (os_log_type_enabled((os_log_t)qword_1019348E8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = sub_100096B20((uint64_t)v34);
      uint64_t v23 = v44;
      uint64_t v22 = v45;
      uint64_t v24 = sub_1000954B4((uint64_t)v34);
      *(_DWORD *)buf = 68292098;
      int v48 = 0;
      __int16 v49 = 2082;
      uint64_t v50 = "";
      __int16 v51 = 2050;
      uint64_t v52 = v21;
      __int16 v53 = 2050;
      uint64_t v54 = (v22 - v23) >> 5;
      __int16 v55 = 2050;
      uint64_t v56 = v24;
      __int16 v57 = 1026;
      int v58 = v35;
      __int16 v59 = 2050;
      uint64_t v60 = v36;
      __int16 v61 = 1026;
      int v62 = v37;
      __int16 v63 = 1026;
      int v64 = v38;
      __int16 v65 = 1026;
      int v66 = v40;
      __int16 v67 = 1026;
      int v68 = v39;
      __int16 v69 = 1026;
      int v70 = v41;
      __int16 v71 = 1026;
      int v72 = v42;
      __int16 v73 = 1026;
      int v74 = v43;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Microlocation model learned, numFingerprints before pruning:%{public}lu, numFinge rprints after pruning:%{public}lu, numClusters:%{public}lu, type:%{public}d, numAnchors:%{public}l u, Number of Recording triggers at current LOI:%{public}u, Number of Input Valid Fingerprints:%{public}u , Number of Input Valid Fingerprints Labeled:%{public}u, Number of Input Valid Fingerprints Unlabeled:%{ public}u, Number of WiFi Access Points:%{public}u, Number of Ble Sources:%{public}u, Number of Uwb Sou rces:%{public}u}",  buf,  0x6Au);
    }

    int v33 = 0;
    sub_100018E34(&v33);
    uint64_t v25 = sub_100017338((ssize_t)&v33);
    uint64_t v27 = v26;
    sub_100094E1C((uint64_t)v34, (uint64_t)v78);
    else {
      std::string __dst = *(std::string *)a7;
    }
    char v32 = 1;
    sub_100151464((uint64_t)buf, v25, v27, (uint64_t)v78, &__dst, 0LL, 0LL, Current_1);
    sub_1000A062C((uint64_t)a9, (uint64_t)buf);
    if (v77 && v76 < 0) {
      operator delete(__p);
    }
    sub_10006F50C((char *)&v54 + 2);
    sub_10006F50C(v78);
    sub_100019D7C((unsigned int *)&v33);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v28 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67240192;
      int v48 = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "No models were generated for model type %{public}d",  buf,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      v78[0] = 67240192;
      v78[1] = v35;
      unint64_t v29 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "No models were generated for model type %{public}d",  v78,  8);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<CLMicroLocationModelTable::Entry> CLMicroLocationLearner::learnMagicalMomentsModel(NSMutableDictio nary *, std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationLearner::ShouldCancelFun ction &, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, const std::string &, cons t boost::uuids::uuid &, const std::optional<CLMicroLocationModelTable::Entry> &)",  "%s\n",  v29);
    }
  }

  return sub_1000A879C((uint64_t)v34);
}

void sub_1000A05A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *__p, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t sub_1000A062C(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 280))
  {
    sub_100151544(a1, a2);
  }

  else
  {
    sub_100151540(a1, a2);
    *(_BYTE *)(a1 + 280) = 1;
  }

  return a1;
}

void sub_1000A0670(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(void *)(a1 + 24);
  if (*(_BYTE *)(v3 + 280))
  {
    uint64_t v4 = v2[1];
    sub_1000A83A0(buf, (__int128 *)v3);
    __int128 v44 = 0uLL;
    v45[0] = 0LL;
    *(void *)char v46 = &v44;
    v46[8] = 0;
    *(void *)&__int128 v44 = operator new(0x118uLL);
    *((void *)&v44 + 1) = v44;
    v45[0] = v44 + 280;
    *((void *)&v44 + 1) = sub_1000A841C((uint64_t)v45, (__int128 *)buf, v43, (_OWORD *)v44);
    char v5 = sub_1000A7EA8(v4, (uint64_t *)&v44);
    *(void *)char v46 = &v44;
    sub_1000A8578((void ***)v46);
    if (v42 && v41 < 0) {
      operator delete(__p);
    }
    sub_10006F50C(&v36[24]);
    if ((v5 & 1) != 0)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      BOOL v6 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = **(_DWORD **)(a1 + 8);
        *(_DWORD *)buf = 67240192;
        *(_DWORD *)&uint8_t buf[4] = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Model generated successfully for type %{public}d",  buf,  8u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181CBC8);
        }
        int v32 = **(_DWORD **)(a1 + 8);
        LODWORD(v44) = 67240192;
        DWORD1(v44) = v32;
        int v33 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Model generated successfully for type %{public}d",  &v44,  8);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationP roto::Model::ModelType)::(anonymous class)::operator()() const",  "%s\n",  v33);
      }

      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      uint64_t v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(a1 + 24);
        if (!*(_BYTE *)(v9 + 280)) {
          sub_100036CD8();
        }
        char v10 = (char *)operator new(0x28uLL);
        *(void *)buf = v10;
        *(_OWORD *)uint64_t v36 = xmmword_1012C8460;
        *(_OWORD *)char v10 = 0u;
        *((_OWORD *)v10 + 1) = 0u;
        *(void *)(v10 + 29) = 0LL;
        sub_10000AE6C(v9, v10);
        uint64_t v11 = buf;
        if (v36[15] < 0) {
          uint64_t v11 = *(uint8_t **)buf;
        }
        LODWORD(v44) = 136380675;
        *(void *)((char *)&v44 + 4) = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "MicroLocation learned model: %{private}s",  (uint8_t *)&v44,  0xCu);
        if ((v36[15] & 0x80000000) != 0) {
          operator delete(*(void **)buf);
        }
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_35;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      uint64_t v12 = *(void *)(a1 + 24);
      if (!*(_BYTE *)(v12 + 280)) {
        sub_100036CD8();
      }
      uint64_t v13 = qword_1019348D8;
      sub_10009FEA0(v12, (uint64_t)&v44);
      if (v45[0] >= 0) {
        char v14 = &v44;
      }
      else {
        char v14 = (__int128 *)v44;
      }
      *(_DWORD *)char v46 = 136380675;
      *(void *)&v46[4] = v14;
      LODWORD(v34) = 12;
      __int128 v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v13,  0LL,  "MicroLocation learned model: %{private}s",  v46,  v34);
      if (SHIBYTE(v45[0]) < 0) {
        operator delete((void *)v44);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationPro to::Model::ModelType)::(anonymous class)::operator()() const",  "%s\n",  v15);
LABEL_61:
      free(v15);
      goto LABEL_35;
    }
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CBC8);
  }
  char v16 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#Warning Model was not generated properly. Inserted: %{public,BOOL}d",  buf,  8u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    *(void *)&__int128 v44 = 67240192LL;
    __int128 v15 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Model was not generated properly. Inserted: %{public,BOOL}d",  &v44,  8);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLMicroLocationLearner::learnFromModelType(CLMicroLocationLearner::ShouldCancelFunction, CLMicroLocationProto ::Model::ModelType)::(anonymous class)::operator()() const",  "%s\n",  v15);
  }

void sub_1000A0ED8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
}

void sub_1000A0F70(uint64_t a1@<X0>, unsigned int a2@<W1>, char a3@<W2>, uint64_t *a4@<X8>)
{
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  uint64_t v8 = v31;
  if (v30 != v31)
  {
    uint64_t v9 = v30 + 16;
    do
    {
      sub_100060440((const void **)v9, (uint64_t)(v9 - 12), &v29);
      uint64_t v10 = sub_1000AC7C8(v32, v33, (unsigned __int8 **)&v29);
      uint64_t v11 = v33;
      int v12 = *((char *)v9 + 23);
      if (v12 < 0)
      {
        if (*((void *)v9 + 1) != 10LL) {
          goto LABEL_12;
        }
        uint64_t v13 = *(unsigned __int16 **)v9;
      }

      else
      {
        uint64_t v13 = v9;
        if (v12 != 10) {
          goto LABEL_12;
        }
      }

      uint64_t v14 = *(void *)v13;
      int v15 = v13[4];
      if (v14 == 0x6F6D2D7375636F66LL && v15 == 25956)
      {
        uint64_t v20 = sub_1000AC7C8(v32, v33, (unsigned __int8 **)v9);
        BOOL v17 = v20 != v33;
        goto LABEL_13;
      }

void sub_1000A11EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, int a31, __int16 a32, char a33, char a34, char a35)
{
  std::string __p = (void *)(v35 - 112);
  sub_1000129D4((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_1000A1294(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v3 = *(uint64_t **)(a1 + 72);
  uint64_t v4 = *v3;
  uint64_t v33 = v3[1];
  if (*v3 != v33)
  {
    uint64_t v36 = *(void *)a1;
    do
    {
      uint64_t v34 = (void *)(v4 + 40);
      uint64_t v35 = v4;
      uint64_t v6 = sub_1000E72E8((uint64_t *)(v4 + 40));
      uint64_t v7 = v35 + 24;
      if (v8)
      {
        uint64_t v10 = *a2;
        uint64_t v9 = a2[1];
        if (*a2 != v9)
        {
          unint64_t v11 = v6;
          uint64_t v12 = 1LL << v6;
          while (2)
          {
            unint64_t v13 = sub_1000F0D94(*(void *)(v10 + 48));
            if (v11 > 0x1F) {
              sub_10000C918("bitset test argument out of range");
            }
            if ((v13 & v12) == 0) {
              goto LABEL_37;
            }
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181CBC8);
            }
            uint64_t v14 = (os_log_s *)qword_1019348D8;
            if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
            {
              int v15 = (void *)v10;
              char v16 = (void *)(v10 + 24);
              BOOL v17 = operator new(0x28uLL);
              std::string __p = v17;
              __int128 v39 = xmmword_1012C8460;
              *BOOL v17 = 0u;
              v17[1] = 0u;
              *(void *)((char *)v17 + 29) = 0LL;
              sub_10000AE6C(v7, v17);
              p_p = &__p;
              if (v39 < 0) {
                p_p = __p;
              }
              __int128 v19 = v34;
              *(_DWORD *)buf = 68290050;
              *(_DWORD *)&uint8_t buf[4] = 0;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = "";
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = v15;
              __int16 v43 = 2082;
              __int128 v44 = v16;
              __int16 v45 = 2082;
              char v46 = p_p;
              __int16 v47 = 2082;
              int v48 = v19;
              _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:learning a semi-supervised model for client, ClientId:%{public, location:es cape_only}s, ClientIdAndServiceUuid:%{public, location:escape_only}s, loiGroupId:%{public, locat ion:escape_only}s, loiType:%{public, location:escape_only}s}",  buf,  0x3Au);
              if (SHIBYTE(v39) < 0) {
                operator delete(__p);
              }
            }

            int v20 = **(unsigned __int8 **)(a1 + 24);
            int v21 = (void *)**(unsigned int **)(a1 + 16);
            if (*(char *)(v10 + 23) < 0)
            {
              sub_1010DD48C(buf, *(void **)v10, *(void *)(v10 + 8));
            }

            else
            {
              __int128 v22 = *(_OWORD *)v10;
              *(void *)&buf[16] = *(void *)(v10 + 16);
              *(_OWORD *)buf = v22;
            }

            buf[24] = 1;
            id v23 = sub_10008EAEC(v20 != 0, v21, (const std::string *)buf);
            if (buf[24] && (buf[23] & 0x80000000) != 0) {
              operator delete(*(void **)buf);
            }
            uint64_t v24 = *(void *)(a1 + 40);
            sub_10001A504((uint64_t)v40, *(void *)(a1 + 48));
            sub_1000A4E90(v36, v10, v24, a3, v23, (uint64_t)v40, *(void *)(a1 + 56), buf, v7);
            uint64_t v25 = v41;
            if (v41 == v40)
            {
              uint64_t v25 = v40;
              uint64_t v26 = 4LL;
LABEL_31:
              (*(void (**)(void))(*v25 + 8 * v26))();
            }

            else if (v41)
            {
              uint64_t v26 = 5LL;
              goto LABEL_31;
            }

            if (v49) {
              sub_1000A062C(*(void *)(a1 + 64), (uint64_t)buf);
            }
            if (v23)
            {
              uint64_t v27 = *(void *)(a1 + 32);
              *(void *)uint64_t v27 = v23;
              *(_BYTE *)(v27 + 8) = 1;
            }

            sub_1000A0670(*(void *)(a1 + 8));
            sub_100019D34((uint64_t)buf);
LABEL_37:
            v10 += 56LL;
            if (v10 == v9) {
              break;
            }
            continue;
          }
        }
      }

      else
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181CBC8);
        }
        std::string v28 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          std::string v29 = operator new(0x28uLL);
          std::string __p = v29;
          __int128 v39 = xmmword_1012C8460;
          *std::string v29 = 0u;
          v29[1] = 0u;
          *(void *)((char *)v29 + 29) = 0LL;
          sub_10000AE6C(v7, v29);
          uint64_t v30 = &__p;
          if (v39 < 0) {
            uint64_t v30 = __p;
          }
          uint64_t v31 = v34;
          *(_DWORD *)buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v30;
          __int16 v43 = 2082;
          __int128 v44 = v31;
          _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:skipping Location semi-supervised model learning because of LOI, loiGroupId:%{p ublic, location:escape_only}s, loiType:%{public, location:escape_only}s}",  buf,  0x26u);
          if (SHIBYTE(v39) < 0) {
            operator delete(__p);
          }
        }
      }

      uint64_t v4 = v35 + 64;
    }

    while (v35 + 64 != v33);
  }

void sub_1000A1704( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36, char a37)
{
}

uint64_t sub_1000A1790@<X0>( uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, _BYTE *a9@<X8>, double a10@<D0>, unsigned int a11)
{
  double v174 = a10;
  sub_1002F0B04(buf);
  CFStringRef v13 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsLearnerAlgorithm", 0x8000100u, kCFAllocatorNull);
  int v14 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v13, &v157);
  CFRelease(v13);
  unsigned int v15 = v157;
  char v16 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    BOOL v17 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  if (v14) {
    uint64_t v19 = v15;
  }
  else {
    uint64_t v19 = 0LL;
  }
  sub_100040B28(v19, &v173);
  sub_1002F0B04(buf);
  CFStringRef v20 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsNumberOfModelIterations", 0x8000100u, kCFAllocatorNull);
  int v21 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v20, &v157);
  CFRelease(v20);
  unsigned int v22 = v157;
  id v23 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    uint64_t v24 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  if (v21) {
    uint64_t v26 = v22;
  }
  else {
    uint64_t v26 = 3LL;
  }
  unint64_t v131 = v26;
  std::string v28 = *(unint64_t **)a3;
  uint64_t v27 = *(void *)(a3 + 8);
  sub_1002F0B04(buf);
  CFStringRef v29 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMinimumNumberOfRecordingsInStableModel",  0x8000100u,  kCFAllocatorNull);
  int v30 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v29, &v157);
  CFRelease(v29);
  uint64_t v31 = v157;
  uint64_t v32 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    uint64_t v33 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v34 = __ldaxr(v33);
    while (__stlxr(v34 - 1, v33));
    if (!v34)
    {
      ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
      std::__shared_weak_count::__release_weak(v32);
    }
  }

  uint64_t v35 = 200LL;
  if (v30) {
    uint64_t v35 = v31;
  }
  unint64_t v123 = v35;
  v171 = 0LL;
  __int16 v170 = 0LL;
  uint64_t v172 = 0LL;
  sub_1000A7198(&v170, v131);
  if (qword_1019348E0 != -1) {
    dispatch_once(&qword_1019348E0, &stru_10181CBE8);
  }
  uint64_t v36 = (os_log_s *)qword_1019348E8;
  if (os_log_type_enabled((os_log_t)qword_1019348E8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v37 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 4);
    *(_DWORD *)buf = 68290050;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 1026;
    *(_DWORD *)&buf[20] = a11;
    *(_WORD *)&buf[24] = 1026;
    *(_DWORD *)&buf[26] = v19;
    *(_WORD *)&buf[30] = 1026;
    *(_DWORD *)&buf[32] = v131;
    *(_WORD *)&buf[36] = 2050;
    *(void *)&buf[38] = v37;
    _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Learning started, modelType:%{public}d, algorithmType:%{public}d, numModelIters :%{public}d, numRecordingTriggers:%{public}lu}",  buf,  0x2Eu);
  }

  sub_100094E18(&v157);
  unint64_t v122 = 0xEEEEEEEEEEEEEEEFLL * ((v27 - (uint64_t)v28) >> 4);
  v199[0] = 0;
  char v201 = 0;
  v129 = a2;
  if (!*(_BYTE *)(a8 + 280)) {
    goto LABEL_36;
  }
  sub_100095AF0(a8 + 32, a6, (uint64_t)buf);
  __int128 v157 = *(_OWORD *)buf;
  int v159 = *(_DWORD *)v186;
  sub_1000193A0(v158, *(uint64_t **)&buf[32], 0LL);
  __int128 v160 = v188;
  sub_1000A88FC((uint64_t)v161, (uint64_t)v189);
  v162[0] = v190[0];
  *(_OWORD *)((char *)v162 + 12) = *(_OWORD *)((char *)v190 + 12);
  sub_1000A8A0C((void **)&v163);
  __int128 v163 = v191;
  uint64_t v164 = v192;
  uint64_t v192 = 0LL;
  __int128 v191 = 0uLL;
  sub_1000A8A68((uint64_t)v165, v193);
  v165[5] = v194;
  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }

  __int128 __p = v195;
  uint64_t v167 = v196;
  uint64_t v196 = 0LL;
  __int128 v195 = 0uLL;
  if (SHIBYTE(v169) < 0)
  {
    operator delete((void *)v168);
    __int128 v168 = v197;
    uint64_t v169 = v198;
    HIBYTE(v198) = 0;
    LOBYTE(v197) = 0;
    if ((void)v195)
    {
      *((void *)&v195 + 1) = v195;
      operator delete((void *)v195);
    }
  }

  else
  {
    uint64_t v169 = v198;
    __int128 v168 = v197;
    HIBYTE(v198) = 0;
    LOBYTE(v197) = 0;
  }

  sub_100019B90((uint64_t)v193);
  *(void *)&__int128 v142 = &v191;
  sub_100019C0C((void ***)&v142);
  sub_100019C7C((uint64_t)v189);
  sub_100019CEC((uint64_t)&buf[16]);
  if (sub_1000954BC((uint64_t)&v157) || v122 < v123 && (unint64_t v38 = HIDWORD(v157), sub_1000A722C() - 1 > v38))
  {
LABEL_36:
    int v134 = 0;
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    __int128 v39 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "got sufficient recording triggers, will ignore prior cluster number in learning",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      LOWORD(v142) = 0;
      v116 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "got sufficient recording triggers, will ignore prior cluster number in learning",  &v142,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<CLMicroLocationModel> CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictionary *, std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationLearner::ShouldCancelFunctio n &, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, cl::chrono::CFAbsoluteTimeClo ck::time_point, const boost::uuids::uuid &, const std::optional<CLMicroLocationModelTable::Entry> &, const CLMic roLocationProto::Model::ModelType)",  "%s\n",  v116);
      if (v116 != buf) {
        free(v116);
      }
    }

    int v134 = 1;
  }

  v183[0] = &off_101818E08;
  v183[1] = sub_100137504;
  __int16 v184 = v183;
  sub_100094E18(&v142);
  int v40 = *(unint64_t **)(a3 + 8);
  unint64_t v120 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v40 - *(void *)a3) >> 4);
  unint64_t v41 = 126 - 2 * __clz(v120);
  else {
    uint64_t v42 = v41;
  }
  sub_1000AD3C4(*(unint64_t **)a3, v40, v42, 1);
  if (!(_DWORD)v131)
  {
    int v132 = 0;
    int v125 = 0;
    LODWORD(v133) = 0;
LABEL_180:
    LOBYTE(v138) = 0;
    BYTE8(v139) = 0;
    char v104 = v129;
    if (*(_BYTE *)(a8 + 280))
    {
      uint64_t v105 = *(void *)(a8 + 16);
      v138 = (void *)(*(unsigned int *)(a8 + 140) | ((unint64_t)*(unsigned __int8 *)(a8 + 136) << 32));
      *(void *)&__int128 v139 = v105;
      BYTE8(v139) = 1;
    }

    sub_1000A6E7C(a1, (uint64_t)&v142, &v174, (uint64_t)&v138, a7);
    if (a11 != 2)
    {
      if (v122 >= v123 || (unint64_t v106 = HIDWORD(v142), sub_1000A722C() <= v106))
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181CBC8);
        }
        v107 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEBUG, "set model to stable", buf, 2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181CBC8);
          }
          LOWORD(v176) = 0;
          LODWORD(v119) = 2;
          v117 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "set model to stable",  &v176,  v119);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<CLMicroLocationModel> CLMicroLocationLearner::learnMagicalMomentsModelInternal(NSMutableDictio nary *, std::vector<CLMicroLocationRecordingEventsTable::Entry> &, const CLMicroLocationLearner::ShouldCance lFunction &, const CLMicroLocationAnchorAppearanceMap &, CLMicroLocationFingerprintPool &, cl::chrono::CFAbs oluteTimeClock::time_point, const boost::uuids::uuid &, const std::optional<CLMicroLocationModelTable::Entry > &, const CLMicroLocationProto::Model::ModelType)",  "%s\n",  v117);
          if (v117 != buf) {
            free(v117);
          }
          char v104 = v129;
        }

        BYTE8(v142) = 1;
      }
    }

    sub_100096B18((uint64_t)&v142, v132);
    sub_1001163AC((uint64_t)&v142, (uint64_t)&v176);
    sub_100096B4C((uint64_t)&v142, (int)v176);
    sub_100096B54((uint64_t)&v142, (uint64_t)v177);
    *(void **)&v147[16] = v177[3];
    *(_DWORD *)&v147[24] = v178;
    sub_100094E1C((uint64_t)&v142, (uint64_t)buf);
    double v108 = v174;
    sub_100090058(v104, &v142, (uint64_t)buf, v174);
    if (*(_BYTE *)(a8 + 280))
    {
      if (v201) {
        uint64_t v109 = v200;
      }
      else {
        uint64_t v109 = 0LL;
      }
      sub_100090928((uint64_t)v104, &v142, &v157, v109, v201, v108);
    }

    v137[0] = sub_1000954BC((uint64_t)&v157);
    v137[1] = 1;
    sub_100090FD8(v104, (uint64_t)&v142, v137);
    *(_DWORD *)uint64_t v147 = v120;
    *(_DWORD *)&v147[4] = v133;
    *(_DWORD *)&v147[8] = v125;
    *(_DWORD *)&v147[12] = 0;
    sub_1000A8B5C((uint64_t)a9, (uint64_t)&v142);
    sub_10006F50C(buf);
    if (v177[0])
    {
      v177[1] = v177[0];
      operator delete(v177[0]);
    }

    goto LABEL_209;
  }

  uint64_t v133 = 0LL;
  int v132 = 0;
  uint64_t v43 = 0LL;
  int v125 = 0;
  uint64_t v126 = a8;
  while (1)
  {
    if (sub_100097CA8((uint64_t)&v142))
    {
      memset(buf, 0, 32);
      *(_DWORD *)&buf[32] = 1065353216;
      for (uint64_t i = v151; i; uint64_t i = (void *)*i)
      {
        char v46 = (void *)i[4];
        __int16 v45 = (void *)i[5];
        while (v46 != v45)
        {
          sub_10001A568((uint64_t)buf, v46, v46);
          v46 += 2;
        }
      }

      int v48 = *(unint64_t **)a3;
      __int16 v47 = *(unint64_t **)(a3 + 8);
      if (*(unint64_t **)a3 != v47)
      {
        while (sub_10001A7B8(buf, v48))
        {
          v48 += 30;
          if (v48 == v47)
          {
            int v48 = v47;
            goto LABEL_68;
          }
        }

        if (v48 != v47)
        {
          for (j = v48 + 30; j != v47; j += 30)
          {
            if (sub_10001A7B8(buf, j))
            {
              __int128 v50 = *(_OWORD *)j;
              v48[2] = j[2];
              *(_OWORD *)int v48 = v50;
              __int16 v51 = (void **)(v48 + 3);
              __int128 v52 = *(_OWORD *)(j + 3);
              v48[5] = j[5];
              *(_OWORD *)__int16 v51 = v52;
              *((_BYTE *)j + 47) = 0;
              *((_BYTE *)j + 24) = 0;
              __int128 v53 = *((_OWORD *)j + 3);
              *(_OWORD *)((char *)v48 + 60) = *(_OWORD *)((char *)j + 60);
              *((_OWORD *)v48 + 3) = v53;
              sub_100087EC8((uint64_t)(v48 + 10), (uint64_t)(j + 10));
              __int128 v54 = *(_OWORD *)(j + 27);
              *((_BYTE *)v48 + 232) = *((_BYTE *)j + 232);
              *(_OWORD *)(v48 + 27) = v54;
              v48 += 30;
            }
          }
        }
      }

LABEL_207:
  *a9 = 0;
  a9[352] = 0;
  uint64_t v112 = v141;
  uint64_t v141 = 0LL;
  if (v112) {
    (*(void (**)(uint64_t))(*(void *)v112 + 8LL))(v112);
  }
LABEL_209:
  if (SHIBYTE(v156) < 0) {
    operator delete((void *)v155);
  }
  if ((void)v153)
  {
    *((void *)&v153 + 1) = v153;
    operator delete((void *)v153);
  }

  sub_100019B90((uint64_t)v150);
  *(void *)buf = &v148;
  sub_100019C0C((void ***)buf);
  sub_100019C7C((uint64_t)v146);
  sub_100019CEC((uint64_t)v143);
  v113 = v184;
  if (v184 == v183)
  {
    uint64_t v114 = 4LL;
    v113 = v183;
LABEL_217:
    (*(void (**)(void))(*v113 + 8 * v114))();
  }

  else if (v184)
  {
    uint64_t v114 = 5LL;
    goto LABEL_217;
  }

  sub_100019D34((uint64_t)v199);
  if (SHIBYTE(v169) < 0) {
    operator delete((void *)v168);
  }
  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }

  sub_100019B90((uint64_t)v165);
  *(void *)buf = &v163;
  sub_100019C0C((void ***)buf);
  sub_100019C7C((uint64_t)v161);
  sub_100019CEC((uint64_t)v158);
  if (v170)
  {
    v171 = (char *)v170;
    operator delete(v170);
  }

  uint64_t result = v173;
  uint64_t v173 = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

            if (v30) {
              CFRelease(v30);
            }
            v174[0] = 0LL;
            goto LABEL_210;
          }

          v94 = +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  sub_100215280());
        }

        uint64_t v98 = *(void *)(a1 + 80);
        goto LABEL_190;
      }

          uint64_t v4 = *((void *)this + 1);
          char v5 = *((void *)this + 2);
          uint64_t v6 = *((unsigned __int8 *)this + 24);
          if (v4 >= v5 || *((_BYTE *)this + 24)) {
            return v6 == 0;
          }
          break;
        default:
          if ((PB::Reader::skip(this, v17 >> 3, v17 & 7, 0) & 1) == 0) {
            return 0LL;
          }
          goto LABEL_207;
      }
    }

    int v21 = 0;
    unsigned int v22 = 0;
    BOOL v17 = 0LL;
    if (v4 > v5) {
      char v5 = v4;
    }
    while (v5 != v4)
    {
      id v23 = v4 + 1;
      uint64_t v24 = *(_BYTE *)(v14 + v4);
      *((void *)this + 1) = v23;
      v17 |= (unint64_t)(v24 & 0x7F) << v21;
      if ((v24 & 0x80) == 0) {
        goto LABEL_21;
      }
      v21 += 7;
      uint64_t v4 = v23;
      if (v22++ >= 9)
      {
LABEL_20:
        BOOL v17 = 0LL;
        goto LABEL_21;
      }
    }

    uint64_t v6 = 1;
    *((_BYTE *)this + 24) = 1;
  }

  return v6 == 0;
}

              *(_DWORD *)(a1 + 52) = v25;
              break;
            case 402:
              *(_DWORD *)(a1 + 68) |= 0x100u;
              uint64_t v42 = *((void *)this + 1);
              uint64_t v2 = *((void *)this + 2);
              uint64_t v43 = *(void *)this;
              if (v42 > 0xFFFFFFFFFFFFFFF5LL || v42 + 10 > v2)
              {
                uint64_t v98 = 0;
                uint64_t v99 = 0;
                char v46 = 0LL;
                if (v2 <= v42) {
                  uint64_t v2 = *((void *)this + 1);
                }
                while (1)
                {
                  if (v2 == v42)
                  {
                    LODWORD(v46) = 0;
                    *((_BYTE *)this + 24) = 1;
                    goto LABEL_212;
                  }

                  double v100 = v42++;
                  double v101 = *(_BYTE *)(v43 + v100);
                  *((void *)this + 1) = v42;
                  v46 |= (unint64_t)(v101 & 0x7F) << v98;
                  if ((v101 & 0x80) == 0) {
                    break;
                  }
                  v98 += 7;
                  int v14 = v99++ > 8;
                  if (v14)
                  {
                    LODWORD(v46) = 0;
                    goto LABEL_211;
                  }
                }

                if (*((_BYTE *)this + 24)) {
                  LODWORD(v46) = 0;
                }
LABEL_211:
                uint64_t v2 = v100 + 1;
              }

              else
              {
                __int128 v44 = 0;
                __int16 v45 = 0;
                char v46 = 0LL;
                while (1)
                {
                  uint64_t v2 = v42 + 1;
                  *((void *)this + 1) = v42 + 1;
                  __int16 v47 = *(_BYTE *)(v43 + v42);
                  v46 |= (unint64_t)(v47 & 0x7F) << v44;
                  if ((v47 & 0x80) == 0) {
                    break;
                  }
                  v44 += 7;
                  uint64_t v42 = v2;
                  int v14 = v45++ > 8;
                  if (v14)
                  {
                    LODWORD(v46) = 0;
                    break;
                  }
                }
              }

  uint64_t v85 = *(_DWORD *)(a2 + 176);
  v5 |= 0x400000000uLL;
  *uint64_t v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(_DWORD *)(a1 + 176) = v85;
  uint64_t v4 = *v3;
  uint64_t v7 = *(void *)(a2 + 364);
  if ((v7 & 0x40) == 0)
  {
LABEL_102:
    if ((v7 & 0x4000) == 0) {
      goto LABEL_103;
    }
    goto LABEL_209;
  }

  if ((v9 & 2) != 0)
  {
    PB::TextFormatter::format(this, "stepsSecondOpportunityLookbackLength", *(_DWORD *)(a1 + 300));
    uint64_t v9 = *(void *)(a1 + 364);
    if ((*v5 & 0x80) == 0)
    {
LABEL_209:
      if ((v9 & 4) == 0) {
        goto LABEL_210;
      }
      goto LABEL_216;
    }
  }

  else if ((v8 & 0x80) == 0)
  {
    goto LABEL_209;
  }

  PB::TextFormatter::format(this, "timestamp", *(void *)(a1 + 64));
  uint64_t v9 = *(void *)(a1 + 364);
  if ((v9 & 4) == 0)
  {
LABEL_210:
    if ((v9 & 8) == 0) {
      goto LABEL_211;
    }
LABEL_217:
    PB::TextFormatter::format(this, "ushaCumulativeRotationThreshold", *(float *)(a1 + 308));
    if ((*(void *)(a1 + 364) & 0x10) == 0) {
      return PB::TextFormatter::endObject(this);
    }
    goto LABEL_212;
  }

  uint64_t result = PB::Writer::writeVarInt(this, *(_DWORD *)(v3 + 176), 0x51Au);
  char v5 = *v4;
  uint64_t v6 = v4[1];
  if ((v6 & 0x40) == 0)
  {
LABEL_102:
    if ((v6 & 0x4000) == 0) {
      goto LABEL_103;
    }
    goto LABEL_209;
  }

  if (v113) {
    operator delete(v113);
  }
  sub_1011D6008((uint64_t)__p);
  return v113 != v112;
}

void sub_1000A3134( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  if (a62) {
    (*(void (**)(uint64_t))(*(void *)a62 + 8LL))(a62);
  }
  sub_1000173AC((uint64_t)&a63);
  int v64 = (unint64_t *)STACK[0x538];
  if ((unint64_t *)STACK[0x538] == &STACK[0x520])
  {
    uint64_t v65 = 4LL;
    int v64 = &STACK[0x520];
  }

  else
  {
    if (!v64) {
      goto LABEL_8;
    }
    uint64_t v65 = 5LL;
  }

  (*(void (**)(void))(*v64 + 8 * v65))();
LABEL_8:
  sub_100019D34((uint64_t)&STACK[0xBA8]);
  sub_1000173AC((uint64_t)&STACK[0x310]);
  int v66 = (void *)STACK[0x470];
  if (STACK[0x470])
  {
    STACK[0x478] = (unint64_t)v66;
    operator delete(v66);
  }

  unint64_t v67 = STACK[0x488];
  STACK[0x488] = 0LL;
  if (v67) {
    (*(void (**)(unint64_t))(*(void *)v67 + 8LL))(v67);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000A3604(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40)) {
    *(_BYTE *)(sub_1000A8728(a1) + 40) = 0;
  }
  uint64_t result = sub_10014E960();
  *(_BYTE *)(result + 40) = 1;
  return result;
}

void sub_1000A3648( uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X4>, uint64_t *a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>, double a9@<D0>, uint64_t a10)
{
  double v186 = a9;
  __int16 v184 = 0LL;
  v183 = 0LL;
  uint64_t v185 = 0LL;
  uint64_t v181 = 0LL;
  uint64_t v180 = 0LL;
  uint64_t v182 = 0LL;
  sub_1002F0B04(buf);
  char v136 = a2;
  CFStringRef v17 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsSimilarityListMaxNumberOfItems",  0x8000100u,  kCFAllocatorNull);
  int v18 = sub_1002A7D20(*(uint64_t *)buf, (uint64_t)v17, &v142);
  CFRelease(v17);
  unsigned int v19 = v142;
  CFStringRef v20 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    int v21 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }

  uint64_t v23 = *a6;
  uint64_t v24 = a6[1];
  uint64_t v179 = 0LL;
  __int128 __p = 0LL;
  int v178 = 0LL;
  sub_10001B72C(&__p, *(const void **)a7, *(void *)(a7 + 8), (uint64_t)(*(void *)(a7 + 8) - *(void *)a7) >> 2);
  if (v18) {
    unsigned int v26 = v19;
  }
  else {
    unsigned int v26 = 1000;
  }
  sub_10009DA30(a1, a4, (uint64_t *)&v183, (uint64_t)&v180, v23, v24, v25, v26);
  if (__p)
  {
    int v178 = __p;
    operator delete(__p);
  }

  memset(v175, 0, sizeof(v175));
  int v176 = 1065353216;
  uint64_t v27 = v180;
  for (uint64_t i = v181; v27 != i; v27 += 240LL)
  {
    if (!*(_BYTE *)(v27 + 232))
    {
      p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
      if (qword_1019348D0 != -1) {
        goto LABEL_206;
      }
      while (1)
      {
        v118 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
        {
          uint64_t v119 = *(void *)(a4 + 24);
          int v120 = *(char *)(a4 + 47);
          sub_10009FEA0(v27, (uint64_t)&v142);
          if (v120 >= 0) {
            uint64_t v121 = a4 + 24;
          }
          else {
            uint64_t v121 = v119;
          }
          if (v143 >= 0) {
            unint64_t v122 = &v142;
          }
          else {
            unint64_t v122 = v142;
          }
          *(_DWORD *)buf = 68290051;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v121;
          *(_WORD *)&_BYTE buf[28] = 2082;
          *(void *)&buf[30] = v122;
          __int16 v188 = 2082;
          unint64_t v189 = (unint64_t)"assert";
          __int16 v190 = 2081;
          *(void *)__int128 v191 = "recordingEntry.fTriggerUUID.has_value()";
          _os_log_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Similarity List Model Learning, labeled recording entry without trigger UUID, Cli ent Id:%{public, location:escape_only}s, Recording UUID:%{public, location:escape_only}s, event:%{ public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x3Au);
          if (SHIBYTE(v143) < 0) {
            operator delete(v142);
          }
        }

        unint64_t v123 = (os_log_s *)qword_1019348D8;
        if (os_signpost_enabled((os_log_t)qword_1019348D8))
        {
          uint64_t v124 = *(void *)(a4 + 24);
          int v125 = *(char *)(a4 + 47);
          sub_10009FEA0(v27, (uint64_t)&v142);
          if (v125 >= 0) {
            uint64_t v126 = a4 + 24;
          }
          else {
            uint64_t v126 = v124;
          }
          if (v143 >= 0) {
            unint64_t v127 = &v142;
          }
          else {
            unint64_t v127 = v142;
          }
          *(_DWORD *)buf = 68290051;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v126;
          *(_WORD *)&_BYTE buf[28] = 2082;
          *(void *)&buf[30] = v127;
          __int16 v188 = 2082;
          unint64_t v189 = (unint64_t)"assert";
          __int16 v190 = 2081;
          *(void *)__int128 v191 = "recordingEntry.fTriggerUUID.has_value()";
          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v123,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Similarity List Model Learning, labeled recording entry without trigger UUID",  "{msg%{public}.0s:Similarity List Model Learning, labeled recording entry without trigger UUID, Cli ent Id:%{public, location:escape_only}s, Recording UUID:%{public, location:escape_only}s, event:%{ public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x3Au);
          if (SHIBYTE(v143) < 0) {
            operator delete(v142);
          }
        }

        v128 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
        {
          v129 = *(void ***)(a4 + 24);
          a4 += 24LL;
          p_vtable = v129;
          int v130 = *(char *)(a4 + 23);
          sub_10009FEA0(v27, (uint64_t)&v142);
          unint64_t v131 = v130 >= 0 ? (void **)a4 : p_vtable;
          int v132 = v143 >= 0 ? &v142 : (void **)v142;
          *(_DWORD *)buf = 68290051;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v131;
          *(_WORD *)&_BYTE buf[28] = 2082;
          *(void *)&buf[30] = v132;
          __int16 v188 = 2082;
          unint64_t v189 = (unint64_t)"assert";
          __int16 v190 = 2081;
          *(void *)__int128 v191 = "recordingEntry.fTriggerUUID.has_value()";
          _os_log_impl( (void *)&_mh_execute_header,  v128,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Similarity List Model Learning, labeled recording entry without trigger UUID, Cli ent Id:%{public, location:escape_only}s, Recording UUID:%{public, location:escape_only}s, event:%{ public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x3Au);
          if (SHIBYTE(v143) < 0) {
            operator delete(v142);
          }
        }

        abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationLearner.mm",  1115,  "learnLocationSimilarityListModel");
        __break(1u);
LABEL_206:
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
    }

    *(_OWORD *)buf = *(_OWORD *)v27;
    *(_OWORD *)&buf[16] = *(_OWORD *)(v27 + 216);
    sub_10009B860((uint64_t)v175, buf, buf);
  }

  memset(v173, 0, sizeof(v173));
  int v174 = 1065353216;
  CFStringRef v29 = v183;
  int v30 = v184;
  if (v183 != (_OWORD *)v184)
  {
    do
    {
      *(_OWORD *)buf = *v29;
      *(_OWORD *)&buf[16] = *(_OWORD *)((char *)v29 + 40);
      sub_1000AF034(v173, buf);
      v29 += 4;
    }

    while (v29 != v30);
  }

  if (v180 == v181)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v31 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v32 = a4 + 24;
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v32;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Similarity List Model Learning, no labeled recording triggers, Client ID:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }
  }

  uint64_t v171 = 0LL;
  uint64_t v170 = 0LL;
  uint64_t v172 = 0LL;
  uint64_t v168 = 0LL;
  uint64_t v167 = 0LL;
  uint64_t v169 = 0LL;
  uint64_t v33 = v180;
  uint64_t v34 = v181;
  *(void *)buf = &v170;
  if (v180 == v181) {
    goto LABEL_32;
  }
  do
  {
    if (*(_DWORD *)(v33 + 72) == 13) {
      sub_10001D3CC((uint64_t **)buf, (__int128 *)v33);
    }
    v33 += 240LL;
  }

  while (v33 != v34);
  uint64_t v35 = v180;
  uint64_t v33 = v181;
  *(void *)buf = &v167;
  if (v180 == v181)
  {
LABEL_32:
    uint64_t v36 = v33;
  }

  else
  {
    do
    {
      if (*(_DWORD *)(v35 + 72) == 1) {
        sub_10001D3CC((uint64_t **)buf, (__int128 *)v35);
      }
      v35 += 240LL;
    }

    while (v35 != v33);
    uint64_t v36 = v181;
    uint64_t v33 = v180;
  }

  if (0xEEEEEEEEEEEEEEEFLL * ((v36 - v33) >> 4) != 0xEEEEEEEEEEEEEEEFLL * ((v171 - v170) >> 4)
                                                  - 0x1111111111111111LL * ((v168 - v167) >> 4))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    unint64_t v37 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2050;
      *(void *)&buf[20] = 0xEEEEEEEEEEEEEEEFLL * ((v181 - v180) >> 4);
      *(_WORD *)&_BYTE buf[28] = 2050;
      *(void *)&buf[30] = 0xEEEEEEEEEEEEEEEFLL * ((v171 - v170) >> 4);
      __int16 v188 = 2050;
      unint64_t v189 = 0xEEEEEEEEEEEEEEEFLL * ((v168 - v167) >> 4);
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:learnLocationSimilarityListModel, didn't classify all labeled triggers to either recordin g or localization, Num labeled triggers:%{public}lu, Num inferred recordings:%{public}lu, Num inferr ed localizations:%{public}lu}",  buf,  0x30u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
    }

    unint64_t v38 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 2050;
      *(void *)&buf[20] = 0xEEEEEEEEEEEEEEEFLL * ((v181 - v180) >> 4);
      *(_WORD *)&_BYTE buf[28] = 2050;
      *(void *)&buf[30] = 0xEEEEEEEEEEEEEEEFLL * ((v171 - v170) >> 4);
      __int16 v188 = 2050;
      unint64_t v189 = 0xEEEEEEEEEEEEEEEFLL * ((v168 - v167) >> 4);
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v38,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "learnLocationSimilarityListModel, didn't classify all labeled triggers to either recording or localization",  "{msg%{public}.0s:learnLocationSimilarityListModel, didn't classify all labeled triggers to either recordin g or localization, Num labeled triggers:%{public}lu, Num inferred recordings:%{public}lu, Num inferr ed localizations:%{public}lu}",  buf,  0x30u);
    }
  }

  sub_1000A7344(a3, (uint64_t)sub_100137504, (uint64_t)&v170, *(void *)(a1 + 8), &v166);
  sub_1000A7344(a3, (uint64_t)sub_100138214, (uint64_t)&v167, *(void *)(a1 + 8), &v165);
  for (unsigned int j = 0; (*(uint64_t (**)(uint64_t))(*(void *)v165 + 16LL))(v165) > (unint64_t)j; ++j)
  {
    int v40 = v166;
    uint64_t v41 = (*(uint64_t (**)(uint64_t, void))(*(void *)v165 + 24LL))(v165, j);
    sub_100149C88(v40, v41);
  }

  uint64_t v42 = (uint64_t)v166;
  v166 = 0LL;
  uint64_t v163 = v42;
  sub_1000EFC74(&v164, &v163);
  uint64_t v43 = v163;
  uint64_t v163 = 0LL;
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8LL))(v43);
  }
  int v137 = sub_1000EFCD4(&v164);
  if (sub_1000EFCD4(&v164))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v44 = qword_1019348D8;
    if (!os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_60;
    }
    unsigned int v45 = sub_1000EFCD4(&v164);
    uint64_t v46 = a4 + 24;
    *(_DWORD *)buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2049;
    *(void *)&buf[20] = v45;
    *(_WORD *)&_BYTE buf[28] = 2082;
    *(void *)&buf[30] = v46;
    __int16 v47 = "{msg%{public}.0s:Similarity List Model Learning, generated LSL, NumLabels:%{private}lu, Client I"
          "D:%{public, location:escape_only}s}";
    int v48 = (os_log_s *)v44;
    uint32_t v49 = 38;
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v50 = qword_1019348D8;
    if (!os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_60;
    }
    uint64_t v51 = a4 + 24;
    *(_DWORD *)buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v51;
    __int16 v47 = "{msg%{public}.0s:Similarity List Model Learning, learned without labeled fingerprints, Client ID:%"
          "{public, location:escape_only}s}";
    int v48 = (os_log_s *)v50;
    uint32_t v49 = 28;
  }

  _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, v47, buf, v49);
LABEL_60:
  __int128 v52 = (char *)operator new(0x10uLL);
  __int128 v53 = v52 + 16;
  v162 = v52 + 16;
  *(void *)__int128 v52 = 0LL;
  *((void *)v52 + 1) = 0LL;
  __int128 v160 = v52;
  v161 = v52 + 16;
  sub_10009773C(a5, (uint64_t)buf);
  __int128 v54 = *(void **)&buf[16];
  sub_10009773C(a5, (uint64_t)&v142);
  uint64_t v55 = 0LL;
  if (v54)
  {
    int v56 = v54;
    do
    {
      ++v55;
      int v56 = (void *)*v56;
    }

    while (v56);
  }

  sub_1000AF110((uint64_t)&v160, v53, v54, 0LL, v55);
  sub_100019CEC((uint64_t)&v142);
  sub_100019CEC((uint64_t)buf);
  uint64_t v133 = a5;
  int v134 = a6;
  uint64_t v135 = a4;
  v144[0] = (void *)sub_1000EFD0C((uint64_t)&v164);
  v144[1] = v57;
  int v58 = 0LL;
  __int16 v59 = 0LL;
  unint64_t v60 = 0LL;
  *(void *)&__int128 v154 = sub_1000EFD18(&v164);
  *((void *)&v154 + 1) = v61;
  while (sub_1000EFC24(v144, &v154))
  {
    uint64_t v62 = sub_1000EFC50(v144);
    uint64_t v63 = sub_10001A7B8(v175, (void *)(v62 + 40));
    if (!v63) {
      sub_10000C918("unordered_map::at: key not found");
    }
    int v64 = sub_1000AF370(v173, v63 + 4);
    int v66 = v65;
    while (v64 != v66)
    {
      unint64_t v67 = v183;
      if (v183 != (_OWORD *)v184)
      {
        while (v67[5] != v64[4] || v67[6] != v64[5])
        {
          v67 += 8;
          if (v67 == v184) {
            goto LABEL_78;
          }
        }
      }

      if (v67 == v184)
      {
LABEL_78:
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181CBC8);
        }
        int v72 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
        {
          __int16 v73 = operator new(0x28uLL);
          __int128 v142 = v73;
          __int128 v143 = xmmword_1012C8460;
          *__int16 v73 = 0u;
          v73[1] = 0u;
          *(void *)((char *)v73 + 29) = 0LL;
          sub_10000AE6C((uint64_t)(v64 + 4), v73);
          uint64_t v74 = &v142;
          if (v143 < 0) {
            uint64_t v74 = v142;
          }
          *(_DWORD *)buf = 68289283;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2081;
          *(void *)&buf[20] = v74;
          _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:couldn't find label entry of label, LabelUUID:%{private, location:escape_only}s}",  buf,  0x1Cu);
          if (SHIBYTE(v143) < 0) {
            operator delete(v142);
          }
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181CBC8);
          }
        }

        unint64_t v75 = (os_log_s *)qword_1019348D8;
        if (os_signpost_enabled((os_log_t)qword_1019348D8))
        {
          uint64_t v76 = operator new(0x28uLL);
          __int128 v142 = v76;
          __int128 v143 = xmmword_1012C8460;
          *uint64_t v76 = 0u;
          v76[1] = 0u;
          *(void *)((char *)v76 + 29) = 0LL;
          sub_10000AE6C((uint64_t)(v64 + 4), v76);
          unint64_t v77 = &v142;
          if (v143 < 0) {
            unint64_t v77 = v142;
          }
          *(_DWORD *)buf = 68289283;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          *(_WORD *)&buf[18] = 2081;
          *(void *)&buf[20] = v77;
          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v75,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "couldn't find label entry of label",  "{msg%{public}.0s:couldn't find label entry of label, LabelUUID:%{private, location:escape_only}s}",  buf,  0x1Cu);
          if (SHIBYTE(v143) < 0) {
            operator delete(v142);
          }
        }
      }

      else
      {
        *(_OWORD *)buf = *((_OWORD *)v64 + 2);
        unsigned __int32 v69 = *(_DWORD *)(v62 + 160);
        unint64_t v70 = v67[7];
        if (v59 >= v60)
        {
          uint64_t v78 = ((char *)v59 - (char *)v58) >> 5;
          unint64_t v79 = v78 + 1;
          if (v60 - v58 > v79) {
            unint64_t v79 = v60 - v58;
          }
          else {
            unint64_t v80 = v79;
          }
          if (v80)
          {
            if (v80 >> 59) {
              sub_1000070D4();
            }
            uint64_t v81 = (char *)operator new(32 * v80);
          }

          else
          {
            uint64_t v81 = 0LL;
          }

          uint64_t v82 = (__n128 *)&v81[32 * v78];
          *uint64_t v82 = *(__n128 *)buf;
          v82[1].n128_u32[0] = v69;
          v82[1].n128_u64[1] = v70;
          if (v59 == v58)
          {
            int v58 = (__n128 *)&v81[32 * v78];
          }

          else
          {
            unint64_t v83 = (__n128 *)&v81[32 * v78];
            do
            {
              __n128 v84 = v59[-1];
              v83[-2] = v59[-2];
              v83[-1] = v84;
              v83 -= 2;
              v59 -= 2;
            }

            while (v59 != v58);
            __int16 v59 = v58;
            int v58 = v83;
          }

          unint64_t v60 = (__n128 *)&v81[32 * v80];
          __int16 v71 = v82 + 2;
          if (v59) {
            operator delete(v59);
          }
        }

        else
        {
          *__int16 v59 = *((__n128 *)v64 + 2);
          v59[1].n128_u32[0] = v69;
          v59[1].n128_u64[1] = v70;
          __int16 v71 = v59 + 2;
        }

        __int16 v59 = v71;
      }

      int v64 = (void *)*v64;
    }

    sub_1000EFC64((uint64_t)v144);
  }

  unint64_t v85 = 126 - 2 * __clz(((char *)v59 - (char *)v58) >> 5);
  if (v59 == v58) {
    uint64_t v86 = 0LL;
  }
  else {
    uint64_t v86 = v85;
  }
  sub_1000AF3BC((uint64_t)v58, v59, v86, 1);
  int v158 = 0LL;
  __int128 v157 = 0LL;
  uint64_t v159 = 0LL;
  v144[0] = &v157;
  if (v59 == v58)
  {
    __int128 v154 = 0u;
    __int128 v155 = 0u;
    int v156 = 1065353216;
    int v90 = v134;
    uint64_t v89 = v135;
    uint64_t v91 = (uint64_t)v133;
  }

  else
  {
    uint64_t v87 = v58;
    do
    {
      *(__n128 *)buf = *v87;
      *(_DWORD *)&buf[16] = v87[1].n128_u32[0];
      sub_1000AFFDC((void ***)v144, (__int128 *)buf);
      v87 += 2;
    }

    while (v87 != v59);
    uint64_t v88 = (char *)v157;
    __int128 v154 = 0u;
    __int128 v155 = 0u;
    int v156 = 1065353216;
    int v90 = v134;
    uint64_t v89 = v135;
    uint64_t v91 = (uint64_t)v133;
    if (v158 != v157)
    {
      uint64_t v92 = 0LL;
      unint64_t v93 = 0LL;
      do
      {
        *(_OWORD *)buf = *(_OWORD *)&v88[v92];
        *(_DWORD *)&buf[16] = v93;
        sub_1000B010C((uint64_t)&v154, buf, (uint64_t)buf);
        ++v93;
        uint64_t v88 = (char *)v157;
        v92 += 20LL;
      }

      while (v93 < 0xCCCCCCCCCCCCCCCDLL * ((v158 - (_BYTE *)v157) >> 2));
    }
  }

  char v148 = 0;
  char v153 = 0;
  *(_OWORD *)int v144 = 0u;
  *(_OWORD *)__int128 v145 = 0u;
  __int128 v146 = 0u;
  LOBYTE(v147) = 0;
  uint64_t v150 = 0LL;
  uint64_t v151 = 0LL;
  uint64_t v149 = 0LL;
  char v152 = 0;
  sub_1000977A8((uint64_t)v144, (unint64_t **)&v160, (uint64_t *)&v157);
  sub_100099544((uint64_t)v144, v91, &v164, v175, v173, &v154);
  sub_100097B14(v91 + 72, (uint64_t)v144);
  int v94 = *(_DWORD *)(v91 + 204) - v137;
  if (v94 < 0)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    __int16 v95 = (os_log_s *)qword_1019348D8;
    int v94 = 0;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      int v96 = *(_DWORD *)(v91 + 204);
      *(_DWORD *)buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&buf[18] = 1026;
      *(_DWORD *)&buf[20] = v96;
      *(_WORD *)&buf[24] = 1026;
      *(_DWORD *)&buf[26] = v137;
      _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning, number of total input fingerprints is smaller than number of labeled fingerprin ts, note labeled fingerprints include localization triggers which used a different fp generation configuration , Number of Input ValidFingerprints:%{public}u, Number of Input Valid Fingerprints Labeled:%{public}u}",  buf,  0x1Eu);
      int v94 = 0;
    }
  }

  *(_DWORD *)(v91 + 208) = v94;
  *(_DWORD *)(v91 + 212) = v137;
  sub_1000A6E7C(a1, v91, &v186, a10, (uint64_t)v90);
  if (sub_100095788(v91) == 3)
  {
    *(_BYTE *)(v91 + 8) = 1;
    if (!*(_BYTE *)(a10 + 16)) {
      goto LABEL_134;
    }
LABEL_133:
    *(_WORD *)buf = *(unsigned __int8 *)(a10 + 4) | 0x100;
    goto LABEL_135;
  }

  if (*(_BYTE *)(a10 + 16))
  {
    *(_BYTE *)(v91 + 8) = *(_BYTE *)(a10 + 4);
    goto LABEL_133;
  }

LABEL_134:
  *(_WORD *)buf = 0;
LABEL_135:
  sub_100090FD8(v136, v91, buf);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CBC8);
  }
  uint64_t v97 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v98 = sub_100096B20(v91);
    uint64_t v100 = *(void *)(v91 + 232);
    uint64_t v99 = *(void *)(v91 + 240);
    uint64_t v101 = sub_1000954B4(v91);
    int v102 = *(_DWORD *)(v91 + 4);
    uint64_t v103 = *(void *)(v91 + 40);
    int v104 = *(_DWORD *)(v91 + 200);
    int v105 = *(_DWORD *)(v91 + 204);
    int v106 = *(_DWORD *)(v91 + 216);
    int v107 = *(_DWORD *)(v91 + 220);
    int v108 = *(_DWORD *)(v91 + 224);
    *(_DWORD *)buf = 68292098;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&buf[18] = 2050;
    *(void *)&buf[20] = v98;
    *(_WORD *)&_BYTE buf[28] = 2050;
    *(void *)&buf[30] = (v99 - v100) >> 5;
    __int16 v188 = 2050;
    unint64_t v189 = v101;
    __int16 v190 = 1026;
    *(_DWORD *)__int128 v191 = v102;
    *(_WORD *)&v191[4] = 2050;
    *(void *)&v191[6] = v103;
    __int16 v192 = 1026;
    int v193 = v104;
    __int16 v194 = 1026;
    int v195 = v105;
    __int16 v196 = 1026;
    int v197 = v137;
    __int16 v198 = 1026;
    int v199 = v94;
    __int16 v200 = 1026;
    int v201 = v106;
    __int16 v202 = 1026;
    int v203 = v107;
    __int16 v204 = 1026;
    int v205 = v108;
    _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Microlocation model learned, numFingerprints before pruning:%{public}lu, numFingerp rints after pruning:%{public}lu, numClusters:%{public}lu, type:%{public}d, numAnchors:%{public}lu,  Number of Recording triggers at current LOI:%{public}u, Number of Input Valid Fingerprints:%{public}u, Num ber of Input Valid Fingerprints Labeled:%{public}u, Number of Input Valid Fingerprints Unlabeled:%{public}d, Number of WiFi Access Points:%{public}u, Number of Ble Sources:%{public}u, Number of Uwb Sources:%{public}u}",  buf,  0x6Au);
  }

  sub_100094E1C(v91, (uint64_t)&v142);
  int v141 = 0;
  sub_100018E34(&v141);
  uint64_t v109 = sub_100017338((ssize_t)&v141);
  uint64_t v111 = v110;
  double v112 = v186;
  else {
    std::string __dst = *(std::string *)(v89 + 24);
  }
  char v140 = 1;
  sub_100151464((uint64_t)buf, v109, v111, (uint64_t)&v142, &__dst, *v90, v90[1], v112);
  sub_100019D7C((unsigned int *)&v141);
  sub_100151540(a8, (uint64_t)buf);
  *(_BYTE *)(a8 + 280) = 1;
  if (v208 && v207 < 0) {
    operator delete(v206);
  }
  sub_10006F50C(&buf[32]);
  sub_10006F50C(&v142);
  if (v149)
  {
    uint64_t v150 = v149;
    operator delete(v149);
  }

  if (v148)
  {
    v113 = v147;
    uint64_t v147 = 0LL;
    if (v113) {
      operator delete[](v113);
    }
  }

  if (v145[1])
  {
    *(void **)&__int128 v146 = v145[1];
    operator delete(v145[1]);
  }

  if (v144[0])
  {
    v144[1] = v144[0];
    operator delete(v144[0]);
  }

  sub_100019CEC((uint64_t)&v154);
  if (v157)
  {
    int v158 = v157;
    operator delete(v157);
  }

  if (v58) {
    operator delete(v58);
  }
  if (v160)
  {
    v161 = v160;
    operator delete(v160);
  }

  uint64_t v114 = v164;
  uint64_t v164 = 0LL;
  if (v114) {
    (*(void (**)(uint64_t))(*(void *)v114 + 8LL))(v114);
  }
  uint64_t v115 = v165;
  uint64_t v165 = 0LL;
  if (v115) {
    (*(void (**)(uint64_t))(*(void *)v115 + 8LL))(v115);
  }
  v116 = v166;
  v166 = 0LL;
  if (v116) {
    (*(void (**)(uint64_t *))(*v116 + 8))(v116);
  }
  *(void *)buf = &v167;
  sub_10001A350((void ***)buf);
  *(void *)buf = &v170;
  sub_10001A350((void ***)buf);
  sub_100019CEC((uint64_t)v173);
  sub_100019CEC((uint64_t)v175);
  *(void *)buf = &v180;
  sub_10001A350((void ***)buf);
  *(void *)buf = &v183;
  sub_100012948((void ***)buf);
}

    *(_DWORD *)(v16 + 320) = sub_1009D943C(a1, v16 + 16);
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101866538);
    }
    uint64_t v61 = qword_101934878;
    if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_INFO))
    {
      log = (os_log_s *)v61;
      uint64_t v62 = *(_DWORD *)(v16 + 320);
      sub_100923668(v16 + 16, (std::stringbuf::string_type *)v135);
      uint64_t v63 = v135;
      if (v136[3] < 0) {
        uint64_t v63 = *(_BYTE **)v135;
      }
      int v64 = *(unsigned __int8 *)(a1 + 193);
      uint64_t v65 = *(unsigned __int8 *)(a1 + 192);
      int v66 = *(unsigned __int8 *)(a1 + 448);
      *(_DWORD *)buf = 67242243;
      *(_DWORD *)&uint8_t buf[4] = v62;
      *(_WORD *)&uint8_t buf[8] = 2081;
      *(void *)&buf[10] = v63;
      *(_WORD *)&buf[18] = 1026;
      *(_DWORD *)__int128 v145 = v64;
      *(_WORD *)&v145[4] = 1026;
      *(_DWORD *)__int128 v146 = v65;
      *(_WORD *)&v146[4] = 1026;
      *(_DWORD *)uint64_t v147 = v66;
      *(_WORD *)&v147[4] = 2050;
      *(double *)&v147[6] = v24;
      *(_WORD *)&v147[14] = 1026;
      *(_DWORD *)&v147[16] = HIDWORD(v109);
      char v148 = 1026;
      uint64_t v149 = v109;
      uint64_t v150 = 1026;
      uint64_t v151 = v107;
      _os_log_impl( (void *)&_mh_execute_header,  log,  OS_LOG_TYPE_INFO,  "Fence: request ALS/tile download, tag, %{public}d, %{private}s, need refresh, %{public}d,%{public}d,%{public}d, age, %{public}.1lf, num %{public}d, %{public}d, isUrgentDownload, %{public}d",  buf,  0x40u);
      if ((v136[3] & 0x80000000) != 0) {
        operator delete(*(void **)v135);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_101866538);
      }
      loga = (os_log_t)qword_101934878;
      uint64_t v76 = *(_DWORD *)(v16 + 320);
      sub_100923668(v16 + 16, &__p);
      unint64_t v77 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        unint64_t v77 = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
      }
      uint64_t v78 = *(unsigned __int8 *)(a1 + 193);
      unint64_t v79 = *(unsigned __int8 *)(a1 + 192);
      unint64_t v80 = *(unsigned __int8 *)(a1 + 448);
      *(_DWORD *)uint64_t v135 = 67242243;
      *(_DWORD *)&v135[4] = v76;
      *(_WORD *)&v135[8] = 2081;
      *(void *)&v135[10] = v77;
      *(_WORD *)&v135[18] = 1026;
      *(_DWORD *)char v136 = v78;
      *(_WORD *)&v136[4] = 1026;
      *(_DWORD *)int v137 = v79;
      *(_WORD *)&v137[4] = 1026;
      *(_DWORD *)v138 = v80;
      *(_WORD *)&v138[4] = 2050;
      *(double *)&v138[6] = v24;
      *(_WORD *)&v138[14] = 1026;
      *(_DWORD *)&v138[16] = HIDWORD(v109);
      __int128 v139 = 1026;
      char v140 = v109;
      int v141 = 1026;
      __int128 v142 = v107;
      LODWORD(v104) = 64;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  loga,  1LL,  "Fence: request ALS/tile download, tag, %{public}d, %{private}s, need refresh, %{public}d,%{public}d,%{public}d, age, %{public}.1lf, num %{public}d, %{public}d, isUrgentDownload, %{public}d",  v135,  v104);
      uint64_t v82 = v81;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFenceDataDownloadManager::checkDownloadState()", "%s\n", v82);
      if (v82 != buf) {
        free(v82);
      }
    }

    if ((*(_DWORD *)(v16 + 320) & 0x80000000) != 0)
    {
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_101866538);
      }
      unint64_t v70 = (os_log_s *)qword_101934878;
      if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_INFO, "#Warning Fence: can't start query", buf, 2u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_83;
      }
      bzero(buf, 0x65CuLL);
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_101866538);
      }
      *(_WORD *)uint64_t v135 = 0;
      LODWORD(v104) = 2;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  1LL,  "#Warning Fence: can't start query",  v135,  v104);
      uint64_t v23 = (char *)v71;
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFenceDataDownloadManager::checkDownloadState()", "%s\n", v71);
      goto LABEL_43;
    }

    unint64_t v67 = objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "vendor"), "proxyForService:", @"CLWifiTilesManager");
    unsigned int v68 = *(double *)(v16 + 88);
    unsigned __int32 v69 = *(double *)(v16 + 96);
    uint64_t v110 = 0;
    uint64_t v111 = 0;
    double v112 = v133;
    v113 = v134;
    uint64_t v114 = 0xBFF0000000000000LL;
    uint64_t v115 = 0;
    v116 = v15;
    v117 = 257;
    v118 = v131;
    uint64_t v119 = v132;
    [v67 requestTileDownloadForLat:&v110 lon:v68 details:v69];
    ++v17;
LABEL_83:
    char v16 = *(void *)(v16 + 8);
    if (v16 == v2) {
      goto LABEL_191;
    }
  }

  if (qword_101934870 != -1) {
    dispatch_once(&qword_101934870, &stru_101866538);
  }
  uint64_t v89 = (os_log_s *)qword_101934878;
  if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67174913;
    *(_DWORD *)&uint8_t buf[4] = v17 + v4;
    *(_WORD *)&uint8_t buf[8] = 1025;
    *(_DWORD *)&buf[10] = 5;
    _os_log_impl( (void *)&_mh_execute_header,  v89,  OS_LOG_TYPE_DEBUG,  "avoiding more concurrent downloads, %{private}d, max, %{private}d",  buf,  0xEu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101866538);
    }
    *(_DWORD *)uint64_t v135 = 67174913;
    *(_DWORD *)&v135[4] = v17 + v4;
    *(_WORD *)&v135[8] = 1025;
    *(_DWORD *)&v135[10] = 5;
    LODWORD(v104) = 14;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934878,  2LL,  "avoiding more concurrent downloads, %{private}d, max, %{private}d",  v135,  v104);
    uint64_t v103 = (char *)v102;
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLFenceDataDownloadManager::checkDownloadState()", "%s\n", v102);
    if (v103 != buf) {
      free(v103);
    }
  }

  unsigned __int32 v69 = *(void *)(a1 + 144);
  if (!v69) {
    unsigned __int32 v69 = *(void *)(qword_1019A1D38 + 144);
  }
  if ((*(_BYTE *)(v69 + 20) & 1) == 0)
  {
    unint64_t v70 = 0;
    *(_DWORD *)(v69 + 16) = 0;
LABEL_139:
    int v72 = 1;
    goto LABEL_141;
  }

  __int16 v71 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize64( *(wireless_diagnostics::google::protobuf::io::CodedOutputStream **)(v69 + 8),  a2);
  unint64_t v70 = v71 + 1;
  *(_DWORD *)(v69 + 16) = v71 + 1;
  int v72 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback( (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)(v71 + 1),  a2);
LABEL_141:
  v4 += v70 + v72 + 2;
  uint64_t v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x80000) == 0)
  {
LABEL_117:
    if ((v3 & 0x100000) == 0) {
      goto LABEL_118;
    }
    goto LABEL_148;
  }

  uint64_t result = *(float *)(a2 + 276);
  v5 |= 0x400000000000000uLL;
  *uint64_t v2 = v5;
  *(_BYTE *)(a1 + 324) = v6;
  *(float *)(a1 + 276) = result;
  uint64_t v7 = *v3;
  if ((*v3 & 0x8000000000LL) == 0)
  {
LABEL_69:
    if ((v7 & 2) == 0) {
      goto LABEL_70;
    }
    goto LABEL_136;
  }

  PB::TextFormatter::format(this, "maxPulse", *(float *)(a1 + 304));
  uint64_t v6 = *v5;
  if ((*(_BYTE *)(a1 + 324) & 4) == 0)
  {
LABEL_68:
    if ((v6 & 0x20) == 0) {
      goto LABEL_69;
    }
    goto LABEL_136;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 276), 0x40u);
  uint64_t v6 = *v4;
  if ((*v4 & 0x8000000000LL) == 0)
  {
LABEL_69:
    if ((v6 & 2) == 0) {
      goto LABEL_70;
    }
    goto LABEL_136;
  }

  CFStringRef v20 = *(_BYTE *)(a2 + 273);
  v6 |= 0x20u;
  *uint64_t v2 = v5;
  *(_WORD *)(a1 + 288) = v6;
  *(_BYTE *)(a1 + 273) = v20;
  uint64_t v4 = *v3;
  uint64_t v7 = *(_WORD *)(a2 + 288);
  if ((*v3 & 0x1000000000000000LL) == 0)
  {
LABEL_61:
    if ((v4 & 0x400000000000000LL) == 0) {
      goto LABEL_62;
    }
    goto LABEL_136;
  }

  PB::TextFormatter::format(this, "lowSenseWithoutAudioDeltaVThreshold1", *(float *)(a1 + 192));
  uint64_t v6 = *v5;
  uint64_t v7 = *(_WORD *)(a1 + 288);
  if ((*v5 & 0x400000000000LL) == 0)
  {
LABEL_60:
    if ((v6 & 0x800000000000LL) == 0) {
      goto LABEL_61;
    }
    goto LABEL_136;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 244), 0x37u);
  char v5 = *v4;
  uint64_t v6 = *((_WORD *)v4 + 4);
  if ((v6 & 0x200) == 0)
  {
LABEL_60:
    if ((v5 & 0x8000000000LL) == 0) {
      goto LABEL_61;
    }
    goto LABEL_136;
  }

  uint64_t result = *(float *)(a2 + 80);
  v5 |= 0x20000uLL;
  *uint64_t v2 = v5;
  *(_WORD *)(a1 + 324) = v6;
  *(_BYTE *)(a1 + 326) = BYTE2(v6);
  *(float *)(a1 + 80) = result;
  LOWORD(v8) = *(_WORD *)(a2 + 324);
  uint64_t v4 = *v3;
  if ((*v3 & 0x100000) == 0)
  {
LABEL_54:
    if ((v4 & 0x80000) == 0) {
      goto LABEL_55;
    }
    goto LABEL_136;
  }

  PB::TextFormatter::format(this, "kRegimeZgThresholdROWOASB", *(float *)(a1 + 176));
  uint64_t v7 = *(unsigned __int16 *)(a1 + 324) | (*(unsigned __int8 *)(a1 + 326) << 16);
  uint64_t v6 = *v5;
  if ((*v5 & 0x40000000000LL) == 0)
  {
LABEL_53:
    if ((v7 & 0x10000) == 0) {
      goto LABEL_54;
    }
    goto LABEL_136;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 80), 0xF4u);
  LOWORD(v7) = *((_WORD *)v4 + 4);
  char v5 = *v4;
  if ((*v4 & 0x100000) == 0)
  {
LABEL_54:
    if ((v5 & 0x80000) == 0) {
      goto LABEL_55;
    }
    goto LABEL_136;
  }

  uint64_t v23 = *(_BYTE *)(a2 + 322);
  v6 |= 0x800uLL;
  *uint64_t v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(_BYTE *)(a1 + 322) = v23;
  uint64_t v4 = *v3;
  uint64_t v7 = *(void *)(a2 + 364);
  if ((v7 & 0x1000) == 0)
  {
LABEL_29:
    if ((v7 & 0x200000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_136;
  }

  PB::TextFormatter::format(this, "isStepsDecided", *(_BYTE *)(a1 + 332));
  uint64_t v7 = *v5;
  uint64_t v6 = *(void *)(a1 + 364);
  if ((v6 & 0x400000) == 0)
  {
LABEL_33:
    if ((v6 & 0x800000) == 0) {
      goto LABEL_34;
    }
    goto LABEL_136;
  }

  uint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 322), 0x69u);
  char v5 = *v4;
  uint64_t v6 = v4[1];
  if ((v6 & 0x1000) == 0)
  {
LABEL_29:
    if ((v6 & 0x200000) == 0) {
      goto LABEL_30;
    }
    goto LABEL_136;
  }

  uint64_t v65 = *(_BYTE *)(a2 + 171);
  v3 |= 0x1000000000000uLL;
  *(void *)(result + 204) = v3;
  *(_WORD *)(result + 212) = v4;
  *(_BYTE *)(result + 214) = BYTE2(v4);
  *(_BYTE *)(result + 171) = v65;
  char v5 = *(unsigned __int16 *)(a2 + 212) | (*(unsigned __int8 *)(a2 + 214) << 16);
  uint64_t v2 = *(void *)(a2 + 204);
  if ((v2 & 0x1000000000LL) == 0)
  {
LABEL_56:
    if ((v5 & 0x10000) == 0) {
      goto LABEL_57;
    }
    goto LABEL_136;
  }

  PB::TextFormatter::format(this, "kSaturationMetRO", *(_BYTE *)(a1 + 192));
  uint64_t v6 = *(unsigned __int16 *)(a1 + 212) | (*(unsigned __int8 *)(a1 + 214) << 16);
  char v5 = *(void *)(a1 + 204);
  if ((*(_WORD *)(a1 + 212) & 0x40) == 0)
  {
LABEL_55:
    if ((v6 & 0x80) == 0) {
      goto LABEL_56;
    }
    goto LABEL_136;
  }

  uint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 166), 0x458u);
  char v5 = *(unsigned __int16 *)(v3 + 212) | (*(unsigned __int8 *)(v3 + 214) << 16);
  uint64_t v4 = *(void *)(v3 + 204);
  if ((*(_WORD *)(v3 + 212) & 0x800) == 0)
  {
LABEL_56:
    if ((v4 & 0x800) == 0) {
      goto LABEL_57;
    }
    goto LABEL_136;
  }

          *(_DWORD *)(a1 + 64) = v34;
          goto LABEL_156;
        case 4u:
          *(_BYTE *)(a1 + 72) |= 8u;
          unint64_t v37 = *((void *)this + 1);
          unint64_t v38 = *((void *)this + 2);
          __int128 v39 = *(void *)this;
          if (v37 <= 0xFFFFFFFFFFFFFFF5LL && v37 + 10 <= v38)
          {
            int v40 = 0;
            uint64_t v41 = 0;
            uint64_t v42 = 0LL;
            do
            {
              uint64_t v43 = v37 + 1;
              *((void *)this + 1) = v37 + 1;
              uint64_t v44 = *(_BYTE *)(v39 + v37);
              v42 |= (unint64_t)(v44 & 0x7F) << v40;
              if ((v44 & 0x80) == 0) {
                goto LABEL_137;
              }
              v40 += 7;
              unint64_t v37 = v43;
              CFStringRef v20 = v41++ > 8;
            }

            while (!v20);
LABEL_107:
            LODWORD(v42) = 0;
            goto LABEL_137;
          }

          unint64_t v77 = 0;
          uint64_t v78 = 0;
          uint64_t v42 = 0LL;
          if (v38 <= v37) {
            unint64_t v38 = *((void *)this + 1);
          }
          while (2)
          {
            if (v38 == v37)
            {
              LODWORD(v42) = 0;
              *((_BYTE *)this + 24) = 1;
            }

            else
            {
              unint64_t v79 = v37 + 1;
              unint64_t v80 = *(_BYTE *)(v39 + v37);
              *((void *)this + 1) = v79;
              v42 |= (unint64_t)(v80 & 0x7F) << v77;
              if (v80 < 0)
              {
                v77 += 7;
                unint64_t v37 = v79;
                CFStringRef v20 = v78++ > 8;
                if (v20) {
                  goto LABEL_107;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v42) = 0;
              }
            }

            break;
          }

void sub_1000A4B64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30)
{
  unint64_t v31 = STACK[0x258];
  STACK[0x258] = 0LL;
  if (v31) {
    (*(void (**)(unint64_t))(*(void *)v31 + 8LL))(v31);
  }
  unint64_t v32 = STACK[0x260];
  STACK[0x260] = 0LL;
  if (v32) {
    (*(void (**)(unint64_t))(*(void *)v32 + 8LL))(v32);
  }
  unint64_t v33 = STACK[0x268];
  STACK[0x268] = 0LL;
  if (v33) {
    (*(void (**)(unint64_t))(*(void *)v33 + 8LL))(v33);
  }
  a30 = (uint64_t)&STACK[0x270];
  sub_10001A350((void ***)&a30);
  a30 = (uint64_t)&STACK[0x288];
  sub_10001A350((void ***)&a30);
  sub_100019CEC((uint64_t)&STACK[0x2A0]);
  sub_100019CEC((uint64_t)&STACK[0x2D0]);
  a30 = (uint64_t)&STACK[0x318];
  sub_10001A350((void ***)&a30);
  a30 = (uint64_t)&STACK[0x330];
  sub_100012948((void ***)&a30);
  _Unwind_Resume(a1);
}

uint64_t sub_1000A4DBC(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 112))
  {
    *(void *)a1 = *(void *)a2;
    uint64_t v4 = (void **)(a1 + 8);
    __int128 v5 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v4 = v5;
    *(_BYTE *)(a2 + 31) = 0;
    *(_BYTE *)(a2 + 8) = 0;
    __int128 v6 = *(_OWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v6;
    sub_10008C938(a1 + 56, a2 + 56);
  }

  else
  {
    sub_1000A78B4(a1, a2);
    *(_BYTE *)(a1 + 112) = 1;
  }

  return a1;
}

uint64_t sub_1000A4E58(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000A4E90@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned int a4@<W3>, void *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, _BYTE *a8@<X8>, uint64_t a9)
{
  uint64_t v61 = 0LL;
  uint64_t v62 = 0LL;
  uint64_t v63 = 0LL;
  unsigned int v14 = sub_10009D6F8();
  uint64_t v15 = *(void *)a9;
  uint64_t v16 = *(void *)(a9 + 8);
  __int16 v59 = 0LL;
  uint64_t v60 = 0LL;
  __int128 __p = 0LL;
  sub_10001B72C(&__p, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  sub_10009DA30(a1, a2, v64, (uint64_t)&v61, v15, v16, v17, v14);
  if (__p)
  {
    __int16 v59 = __p;
    operator delete(__p);
  }

  memset(v56, 0, sizeof(v56));
  int v57 = 1065353216;
  int v18 = v61;
  unsigned int v19 = v62;
  while (v18 != v19)
  {
    *(_OWORD *)buf = *v18;
    sub_10001A568((uint64_t)v56, buf, buf);
    v18 += 15;
  }

  sub_1000A55A0(a1, a3, *(void *)a9, *(void *)(a9 + 8), (uint64_t)&v54);
  int v21 = v54;
  CFStringRef v20 = v55;
  if (v54 != v55)
  {
    while (!sub_10001A7B8(v56, v21))
    {
      v21 += 15;
      if (v21 == v20)
      {
        int v21 = v20;
        goto LABEL_18;
      }
    }

    if (v21 != v20)
    {
      for (uint64_t i = v21 + 15; i != v20; i += 15)
      {
        if (!sub_10001A7B8(v56, i))
        {
          __int128 v23 = *i;
          *((void *)v21 + 2) = *((void *)i + 2);
          *int v21 = v23;
          uint64_t v24 = (void **)v21 + 3;
          __int128 v25 = *(__int128 *)((char *)i + 24);
          *((void *)v21 + 5) = *((void *)i + 5);
          *(_OWORD *)uint64_t v24 = v25;
          *((_BYTE *)i + 47) = 0;
          *((_BYTE *)i + 24) = 0;
          __int128 v26 = i[3];
          *(__int128 *)((char *)v21 + 60) = *(__int128 *)((char *)i + 60);
          v21[3] = v26;
          sub_100087EC8((uint64_t)(v21 + 5), (uint64_t)(i + 5));
          __int128 v27 = *(__int128 *)((char *)i + 216);
          *((_BYTE *)v21 + 232) = *((_BYTE *)i + 232);
          *(__int128 *)((char *)v21 + 216) = v27;
          v21 += 15;
        }
      }
    }
  }

void sub_1000A5474( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *__p, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, char a30, uint64_t a31, uint64_t a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, char *a40, char a41, uint64_t a42, uint64_t a43, char *a44, char a45, uint64_t a46, uint64_t a47, uint64_t a48, char a49)
{
  uint64_t v51 = a44;
  if (a44 == &a41)
  {
    uint64_t v52 = 4LL;
    uint64_t v51 = &a41;
  }

  else
  {
    if (!a44) {
      goto LABEL_6;
    }
    uint64_t v52 = 5LL;
  }

  (*(void (**)(void))(*(void *)v51 + 8 * v52))();
LABEL_6:
  sub_100019D34(v49);
  a40 = &a16;
  sub_10001A350((void ***)&a40);
  sub_100019CEC((uint64_t)&a19);
  a19 = &a27;
  sub_10001A350((void ***)&a19);
  a19 = &a30;
  sub_100012948((void ***)&a19);
  sub_100019CEC((uint64_t)&a33);
  _Unwind_Resume(a1);
}

void sub_1000A55A0(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  char v5 = a3;
  *(void *)&__int128 v20 = a3;
  *((void *)&v20 + 1) = a4;
  uint64_t v9 = *(void *)(a1 + 8);
  __int128 v18 = v20;
  char v19 = 1;
  sub_1000A75A4(v9, a2, &v18, (void *)a5);
  if (v5)
  {
LABEL_2:
    uint64_t v10 = *(void *)(a1 + 8);
    __int128 v16 = 0uLL;
    char v17 = 1;
    sub_1000A75A4(v10, a2, &v16, &v13);
    sub_1000B0364((uint64_t *)a5, *(__int128 **)(a5 + 8), v13, v14, 0xEEEEEEEEEEEEEEEFLL * (v14 - v13));
    uint64_t v15 = &v13;
    sub_10001A350((void ***)&v15);
  }

  else
  {
    uint64_t v11 = 1LL;
    while (v11 != 16)
    {
      if (*((unsigned __int8 *)&v20 + v11++))
      {
        return;
      }
    }
  }

void sub_1000A56B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, void ***a13)
{
  a13 = &a10;
  sub_10001A350((void ***)&a13);
  sub_10001A350(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1000A56E8(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000A5728(uint64_t *a1, __int128 *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = a1 + 2;
  unint64_t v5 = v6;
  unint64_t v7 = *(v4 - 1);
  if (v7 >= v6)
  {
    uint64_t v11 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v7 - *a1) >> 3);
    unint64_t v12 = v11 + 1;
    unint64_t v13 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x249249249249249LL) {
      unint64_t v14 = 0x492492492492492LL;
    }
    else {
      unint64_t v14 = v12;
    }
    v21[4] = v4;
    uint64_t v15 = (char *)sub_1000AC8F0((uint64_t)v4, v14);
    __int128 v16 = &v15[56 * v11];
    v21[0] = v15;
    v21[1] = v16;
    v21[3] = &v15[56 * v17];
    uint64_t v18 = *((void *)a2 + 2);
    *(_OWORD *)__int128 v16 = *a2;
    *((void *)v16 + 2) = v18;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    uint64_t v19 = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = *(__int128 *)((char *)a2 + 24);
    *((void *)v16 + 5) = v19;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    *((void *)v16 + 6) = *((void *)a2 + 6);
    v21[2] = v16 + 56;
    sub_1000AC87C(a1, v21);
    uint64_t v10 = a1[1];
    sub_1000ACA80(v21);
  }

  else
  {
    __int128 v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    __int128 v9 = *(__int128 *)((char *)a2 + 24);
    *(void *)(v7 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    *(void *)(v7 + 48) = *((void *)a2 + 6);
    uint64_t v10 = v7 + 56;
    a1[1] = v7 + 56;
  }

  a1[1] = v10;
  return v10 - 56;
}

void sub_1000A589C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000A58B0(uint64_t a1, uint64_t a2, __int128 **a3, uint64_t a4, double a5)
{
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  int v28 = 1065353216;
  uint64_t v10 = *(void **)a4;
  uint64_t v11 = *(void **)(a4 + 8);
  while (v10 != v11)
  {
    sub_10001A568((uint64_t)&v26, v10, v10);
    v10 += 10;
  }

  unint64_t v12 = *a3;
  unint64_t v13 = a3[1];
  if (*a3 == v13)
  {
    __int128 v16 = *a3;
  }

  else
  {
    do
    {
      uint64_t v14 = *(void *)(a1 + 8);
      __int128 v40 = *v12;
      uint64_t v15 = operator new(0x10uLL);
      uint64_t v24 = v15 + 1;
      __int128 v25 = v15 + 1;
      _OWORD *v15 = v40;
      __int128 __p = v15;
      sub_100029F04(v14, (uint64_t)&__p, &buf);
      if (__p)
      {
        uint64_t v24 = __p;
        operator delete(__p);
      }

      sub_10014D154(&v26, &buf);
      __int128 __p = &buf;
      sub_10003F8A8((void ***)&__p);
      v12 += 15;
    }

    while (v12 != v13);
    unint64_t v12 = *a3;
    __int128 v16 = a3[1];
  }

  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  sub_10014C9B0(a2, &v26, v16 != v12, a5, Current_1);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CBC8);
  }
  uint64_t v18 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v19 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 4);
    unint64_t v20 = 0xEEEEEEEEEEEEEEEFLL * (a3[1] - *a3);
    uint64_t v21 = *(void *)(a2 + 24);
    uint64_t buf = 68290050LL;
    __int16 v30 = 2082;
    unint64_t v31 = "";
    __int16 v32 = 2050;
    unint64_t v33 = v19;
    __int16 v34 = 2050;
    uint64_t v35 = *((void *)&v27 + 1);
    __int16 v36 = 2050;
    unint64_t v37 = v20;
    __int16 v38 = 2050;
    uint64_t v39 = v21;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Updating Anchor ID Set, Num. Rapport Anchor Devices:%{public}lu, Num Rapport and Me asured Anchor Devices:%{public}lu, Number of recordings since last model:%{public}lu, Anchor Appearance Ma p size:%{public}lu}",  (uint8_t *)&buf,  0x3Au);
  }

  return sub_100019CEC((uint64_t)&v26);
}

void sub_1000A5B04( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

uint64_t sub_1000A5B50@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, __int128 *a3@<X2>, uint64_t a4@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CBC8);
  }
  __int128 v8 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    __int128 v9 = (char *)operator new(0x28uLL);
    *(void *)__int128 __p = v9;
    *(_OWORD *)&__p[8] = xmmword_1012C8460;
    *(_OWORD *)__int128 v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    *(void *)(v9 + 29) = 0LL;
    sub_10000AE6C((uint64_t)a3, v9);
    uint64_t v10 = __p;
    if (__p[23] < 0) {
      uint64_t v10 = *(_BYTE **)__p;
    }
    else {
      uint64_t v11 = (uint64_t *)*a2;
    }
    *(void *)uint64_t buf = 68289538LL;
    __int16 v52 = 2082;
    __int128 v53 = "";
    __int16 v54 = 2082;
    uint64_t v55 = v10;
    __int16 v56 = 2082;
    int v57 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:generating anchor appearance map for LOI, LOI Id:%{public, location:escape_only}s,  LOI Type:%{public, location:escape_only}s}",  buf,  0x26u);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }

  sub_10014C3A8((uint64_t)v41);
  memset(v39, 0, sizeof(v39));
  int v40 = 1065353216;
  sub_10002B6F4(a1[1], a3, buf);
  if (v59) {
    goto LABEL_12;
  }
  uint64_t v18 = a1[1];
  uint64_t v44 = 0LL;
  *(void *)&__int128 v45 = 0LL;
  sub_10002B6F4(v18, (__int128 *)&v44, __p);
  sub_1000A77B0((uint64_t)buf, (uint64_t)__p);
  sub_1000A7938((uint64_t)__p);
  double v14 = 0.0;
  if (v59)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    unint64_t v19 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v20 = operator new(0x28uLL);
      uint64_t v44 = v20;
      __int128 v45 = xmmword_1012C8460;
      *unint64_t v20 = 0u;
      v20[1] = 0u;
      *(void *)((char *)v20 + 29) = 0LL;
      sub_10000AE6C((uint64_t)a3, v20);
      uint64_t v21 = &v44;
      if (v45 < 0) {
        uint64_t v21 = v44;
      }
      else {
        unint64_t v22 = (uint64_t *)*a2;
      }
      *(void *)__int128 __p = 68289539LL;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&__p[10] = "";
      *(_WORD *)&__p[18] = 2082;
      *(void *)&__p[20] = v21;
      __int16 v48 = 2081;
      uint64_t v49 = v22;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Previous anchor appearance not found for LOI ID. Using anchor appearance map for null uui d and loi type, loi id:%{public, location:escape_only}s, loi type:%{private, location:escape_only}s}",  __p,  0x26u);
      if (SHIBYTE(v45) < 0) {
        operator delete(v44);
      }
    }

    if (v59)
    {
LABEL_12:
      uint64_t v12 = v58;
      if (!v58) {
        uint64_t v12 = *(void *)(qword_1019A09E0 + 24);
      }
      uint64_t v13 = *(void *)(v12 + 8);
      if (!v13) {
        uint64_t v13 = *(void *)(qword_1019A09D0 + 8);
      }
      sub_10014C3FC((uint64_t)__p, v13);
      int v42 = *(_DWORD *)((char *)&v49 + 2);
      sub_1000193A0(v41, *(uint64_t **)&__p[16], 0LL);
      __int128 v43 = v50;
      sub_100019CEC((uint64_t)__p);
      double v14 = *(double *)buf;
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      uint64_t v15 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        __int128 v16 = operator new(0x28uLL);
        uint64_t v44 = v16;
        __int128 v45 = xmmword_1012C8460;
        _OWORD *v16 = 0u;
        v16[1] = 0u;
        *(void *)((char *)v16 + 29) = 0LL;
        sub_10000AE6C((uint64_t)a3, v16);
        uint64_t v17 = &v44;
        if (v45 < 0) {
          uint64_t v17 = v44;
        }
        *(void *)__int128 __p = 68289538LL;
        *(_WORD *)&__p[8] = 2082;
        *(void *)&__p[10] = "";
        *(_WORD *)&__p[18] = 2082;
        *(void *)&__p[20] = v17;
        __int16 v48 = 1026;
        LODWORD(v49) = (int)v14;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Relying on previous anchor appearance map from configuration table, loiGroupId:%{ public, location:escape_only}s, timestamp:%{public}d}",  __p,  0x22u);
        if (SHIBYTE(v45) < 0) {
          operator delete(v44);
        }
      }
    }
  }

  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  std::to_string(&v38, v14);
  std::to_string(&v37, Current_1);
  sub_10002A8F8(a1[1], (uint64_t)&v38, (uint64_t)&v37, (uint64_t)a3, v36);
  if (*a3 != 0)
  {
    uint64_t v24 = a1[1];
    uint64_t v44 = 0LL;
    *(void *)&__int128 v45 = 0LL;
    sub_10002A8F8(v24, (uint64_t)&v38, (uint64_t)&v37, (uint64_t)&v44, __p);
    sub_1000ACAF4( (uint64_t *)v36,  v36[1],  *(__int128 **)__p,  *(__int128 **)&__p[8],  0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)&__p[8] - *(void *)__p) >> 4));
    uint64_t v44 = __p;
    sub_10001A350((void ***)&v44);
  }

  __int128 v34 = 0uLL;
  uint64_t v35 = 0LL;
  sub_1002F0B04(__p);
  CFStringRef v25 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsRapportUsageEnabled", 0x8000100u, kCFAllocatorNull);
  int v26 = sub_1002A6FD4(*(uint64_t *)__p, (uint64_t)v25, (BOOL *)&v44);
  CFRelease(v25);
  int v27 = v44;
  int v28 = *(std::__shared_weak_count **)&__p[8];
  if (*(void *)&__p[8])
  {
    int v29 = (unint64_t *)(*(void *)&__p[8] + 8LL);
    do
      unint64_t v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }

  if (v27) {
    int v31 = 0;
  }
  else {
    int v31 = v26;
  }
  if (v31 != 1)
  {
    (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t *, __int128 *, double))(*(void *)*a1 + 40LL))( __p,  *a1,  a2,  a3,  v14);
    sub_1000AD180((void **)&v34);
    __int128 v34 = *(_OWORD *)__p;
    uint64_t v35 = *(void *)&__p[16];
    memset(__p, 0, 24);
    uint64_t v44 = __p;
    sub_1000AD0FC((void ***)&v44);
  }

  sub_1000A58B0((uint64_t)a1, (uint64_t)v41, v36, (uint64_t)&v34, v14);
  sub_100063B7C((uint64_t)&v44);
  v46 |= 2u;
  __int16 v32 = (_DWORD *)v45;
  if (!(void)v45)
  {
    __int16 v32 = operator new(0x28uLL);
    sub_10006341C((uint64_t)v32);
    *(void *)&__int128 v45 = v32;
  }

  sub_10014C640((uint64_t)v41, (int *)__p);
  sub_10006C9C4(v32, (uint64_t)__p);
  sub_10006C5E8((wireless_diagnostics::google::protobuf::MessageLite *)__p);
  sub_1000A6348((uint64_t)&v44, a4, Current_1);
  sub_10008B118((wireless_diagnostics::google::protobuf::MessageLite *)&v44);
  *(void *)__int128 __p = &v34;
  sub_1000AD0FC((void ***)__p);
  *(void *)__int128 __p = v36;
  sub_10001A350((void ***)__p);
  sub_1000A7938((uint64_t)buf);
  sub_1000A8814((uint64_t)v39);
  return sub_100019CEC((uint64_t)v41);
}

void sub_1000A61F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char a45)
{
}

void sub_1000A6348(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (!sub_1000641E0(v6)) {
    __assert_rtn("set_type", "microlocation.pb.h", 21547, "::CLMicroLocationProto::ConfigurationType_IsValid(value)");
  }
  int v7 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 40) = v6;
  *(_DWORD *)(a2 + 48) = v7 | 3;
  *(double *)(a2 + 8) = a3;
  sub_100101D64(a2, a1);
}

void sub_1000A63D8(_Unwind_Exception *a1)
{
}

void sub_1000A63EC(uint64_t *a1, uint64_t a2)
{
  if (sub_10009D958())
  {
    uint64_t v16 = 0LL;
    unint64_t v17 = 0LL;
    unint64_t v18 = 0LL;
    sub_100029334(a1[1], &v14);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v20 = 2082;
      uint64_t v21 = "";
      __int16 v22 = 2050;
      uint64_t v23 = (v15 - v14) >> 6;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Generating anchor appearance maps, LOI count:%{public}ld}",  buf,  0x1Cu);
    }

    uint64_t v5 = v14;
    uint64_t v6 = v15;
    if (v14 == v15)
    {
LABEL_13:
      if ((sub_1000A6898(a1[1], &v16) & 1) != 0) {
        goto LABEL_27;
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      uint64_t v10 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "#Warning failed to insert Anchor Appearances Map to MicroLocation DB",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_27;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      v13[0] = 0;
      uint64_t v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning failed to insert Anchor Appearances Map to MicroLocation DB",  v13,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationLearner::generateAnchorAppearanceMap(CLMicroLocationLearner::ShouldCancelFunction)",  "%s\n",  v11);
    }

    else
    {
      while (1)
      {
        uint64_t v7 = *(void *)(a2 + 24);
        if (!v7) {
          sub_100008BDC();
        }
        sub_1000A5B50(a1, (uint64_t *)(v5 + 40), (__int128 *)(v5 + 24), (uint64_t)buf);
        unint64_t v8 = v17;
        if (v17 >= v18)
        {
          uint64_t v9 = sub_1000AD1EC(&v16, v5 + 40, (uint64_t)buf, (uint64_t *)(v5 + 24));
        }

        else
        {
          sub_1000AD328((uint64_t)&v18, v17, v5 + 40, (uint64_t)buf, (uint64_t *)(v5 + 24));
          uint64_t v9 = v8 + 112;
        }

        unint64_t v17 = v9;
        sub_10008C0E0((wireless_diagnostics::google::protobuf::MessageLite *)buf);
        v5 += 64LL;
        if (v5 == v6) {
          goto LABEL_13;
        }
      }

      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      uint64_t v12 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Cancelled, skipping generation of anchor appearance maps",  buf,  2u);
      }

      if (!sub_1002921D0(115, 2)) {
        goto LABEL_27;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      v13[0] = 0;
      uint64_t v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Cancelled, skipping generation of anchor appearance maps",  v13,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationLearner::generateAnchorAppearanceMap(CLMicroLocationLearner::ShouldCancelFunction)",  "%s\n",  v11);
    }

void sub_1000A6834( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, void **a19)
{
  a19 = (void **)&a13;
  sub_10003706C(&a19);
  a19 = (void **)&a16;
  sub_100050CAC(&a19);
  _Unwind_Resume(a1);
}

uint64_t sub_1000A6898(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = a1 + 72;
  if (sub_1003C1048(a1 + 72))
  {
    uint64_t v5 = *(void **)(a1 + 208);
    if (!v5)
    {
      uint64_t v5 = operator new(0x10uLL);
      sub_10004D434((uint64_t)v5, v4);
      uint64_t v6 = *(void **)(a1 + 208);
      *(void *)(a1 + 208) = v5;
      if (v6)
      {
        operator delete(v6);
        uint64_t v5 = *(void **)(a1 + 208);
      }
    }

    uint64_t v7 = sub_10004D4B4((uint64_t)v5, a2);
    sub_1000AA278(a1);
    return v7;
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v9 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning Can't insert because the database is invalid",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      v11[0] = 0;
      uint64_t v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Can't insert because the database is invalid",  v11,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationConf igurationTable::Entry]",  "%s\n",  v10);
    }

    return 0LL;
  }

void sub_1000A6AA8(_Unwind_Exception *a1)
{
}

void sub_1000A6AC4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_100008BDC();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 48LL))(v3))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Learning cancelled before onLearningBegin event",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      v6[0] = 0;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Learning cancelled before onLearningBegin event",  v6,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationLearner::onLearningBegin(CLMicroLocationLearner::ShouldCancelFunction)",  "%s\n",  v5);
    }
  }

  else
  {
    (*(void (**)(void))(**(void **)a1 + 16LL))();
  }

void sub_1000A6CA0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_100008BDC();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v3 + 48LL))(v3))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Learning cancelled before onLearningCompleted event",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      v6[0] = 0;
      uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Learning cancelled before onLearningCompleted event",  v6,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationLearner::onLearningCompleted(CLMicroLocationLearner::ShouldCancelFunction)",  "%s\n",  v5);
    }
  }

  else
  {
    (*(void (**)(void))(**(void **)a1 + 48LL))();
  }

void sub_1000A6E7C(uint64_t a1, uint64_t a2, double *a3, uint64_t a4, uint64_t a5)
{
  if (*(_BYTE *)(a4 + 16))
  {
    std::to_string(&v17, *(double *)(a4 + 8));
    std::to_string(&v18, *a3);
    sub_10002A8F8(*(void *)(a1 + 8), (uint64_t)&v17, (uint64_t)&v18, a5, v15);
    if (v15[1] == v15[0]) {
      int v10 = *(_DWORD *)a4;
    }
    else {
      int v10 = *(_DWORD *)a4 + 1;
    }
    *(_DWORD *)(a2 + 12) = v10;
    uint64_t v16 = (void **)v15;
    sub_10001A350(&v16);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v11 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      v17.__r_.__value_.__r.__words[0] = 0x104000100LL;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "Learning model without old model. Setting number of days with recordings to %d",  (uint8_t *)&v17,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&v17, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      v18.__r_.__value_.__r.__words[0] = 0x104000100LL;
      uint64_t v14 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v17,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Learning model without old model. Setting number of days with recordings to %d",  &v18);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationLearner::updateModelDaysWithRecordings(CLMicroLocationModel &, const cl::chrono::CFAbsoluteT imeClock::time_point &, const std::optional<struct ModelStabilityParameters> &, const boost::uuids::uuid &)",  "%s\n",  (const char *)v14);
      if (v14 != &v17) {
        free(v14);
      }
    }

    *(_DWORD *)(a2 + 12) = 1;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CBC8);
  }
  uint64_t v12 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    int v13 = *(_DWORD *)(a2 + 12);
    v17.__r_.__value_.__r.__words[0] = 68289283LL;
    LOWORD(v17.__r_.__value_.__r.__words[1]) = 2082;
    *(std::string::size_type *)((char *)&v17.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
    WORD1(v17.__r_.__value_.__r.__words[2]) = 1025;
    HIDWORD(v17.__r_.__value_.__r.__words[2]) = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Setting model number of days with recordings, numDaysWithRecordings:%{private}u}",  (uint8_t *)&v17,  0x18u);
  }

void sub_1000A715C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A7198(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61) {
      sub_100007008();
    }
    int64_t v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    uint64_t v6 = (char *)sub_1000071BC(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8LL];
    uint64_t v9 = &v6[8 * v8];
    int v10 = (char *)*a1;
    uint64_t v11 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v11 != *a1)
    {
      uint64_t v12 = v7;
      do
      {
        uint64_t v13 = *((void *)v11 - 1);
        v11 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }

      while (v11 != v10);
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

uint64_t sub_1000A722C()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMinimumNumberOfDaysWithRecordingsInStableModel",  0x8000100u,  kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  uint64_t v2 = v7;
  uint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 10LL;
  }
}

void sub_1000A72EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1000A7304(uint64_t a1)
{
  return a1;
}

void *sub_1000A7344@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  int v10 = operator new(0x20uLL);
  sub_10001A504((uint64_t)v17, a1);
  v15[0] = &off_101818E08;
  v15[1] = a2;
  uint64_t v16 = v15;
  sub_100149C58(v10, v17, v15, a3, a4);
  *a5 = v10;
  uint64_t v11 = v16;
  if (v16 == v15)
  {
    uint64_t v12 = 4LL;
    uint64_t v11 = v15;
  }

  else
  {
    if (!v16) {
      goto LABEL_6;
    }
    uint64_t v12 = 5LL;
  }

  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_6:
  uint64_t result = v18;
  if (v18 == v17)
  {
    uint64_t v14 = 4LL;
    uint64_t result = v17;
  }

  else
  {
    if (!v18) {
      return result;
    }
    uint64_t v14 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v14))();
}

void sub_1000A745C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  uint64_t v20 = a13;
  if (a13 == v18)
  {
    uint64_t v21 = 4LL;
    uint64_t v20 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v21 = 5LL;
  }

  (*(void (**)(void))(*(void *)v20 + 8 * v21))();
LABEL_6:
  __int16 v22 = a17;
  if (a17 == &a14)
  {
    uint64_t v23 = 4LL;
    __int16 v22 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_11;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void))(*(void *)v22 + 8 * v23))();
LABEL_11:
  operator delete(v17);
  _Unwind_Resume(a1);
}

void sub_1000A74D4(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, void *a4@<X8>)
{
  __int128 v10 = *a3;
  char v11 = *((_BYTE *)a3 + 16);
  sub_10002A4DC(a1, a2, (uint64_t)__p, (uint64_t)&v10, a4);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1000A7580( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A75A4(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 *a3@<X2>, void *a4@<X8>)
{
  __int128 v10 = *a3;
  char v11 = *((_BYTE *)a3 + 16);
  sub_10002A4DC(a1, a2, (uint64_t)__p, (uint64_t)&v10, a4);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
}

void sub_1000A7650( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000A7674(void *result)
{
  uint64_t v1 = result[2];
  uint64_t v2 = result[3];
  if (v1 != v2)
  {
    while (1)
    {
      v5[0] = &off_10181CF40;
      uint64_t v6 = v5;
      uint64_t v3 = *(void *)(v1 + 24);
      if (!v3) {
        sub_100008BDC();
      }
      (*(void (**)(uint64_t, void *))(*(void *)v3 + 48LL))(v3, v5);
      uint64_t result = v6;
      if (v6 == v5) {
        break;
      }
      if (v6)
      {
        uint64_t v4 = 5LL;
LABEL_7:
        uint64_t result = (void *)(*(uint64_t (**)(void))(*result + 8 * v4))();
      }

      v1 += 32LL;
      if (v1 == v2) {
        return result;
      }
    }

    uint64_t result = v5;
    uint64_t v4 = 4LL;
    goto LABEL_7;
  }

  return result;
}

void sub_1000A7744( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v14 = a13;
  if (a13 == &a10)
  {
    uint64_t v15 = 4LL;
    uint64_t v14 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*(void *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1000A7784(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1000A77B0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 112) == *(unsigned __int8 *)(a2 + 112))
  {
    if (*(_BYTE *)(a1 + 112))
    {
      *(void *)a1 = *(void *)a2;
      uint64_t v4 = (void **)(a1 + 8);
      __int128 v5 = *(_OWORD *)(a2 + 8);
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(_OWORD *)uint64_t v4 = v5;
      *(_BYTE *)(a2 + 31) = 0;
      *(_BYTE *)(a2 + 8) = 0;
      __int128 v6 = *(_OWORD *)(a2 + 32);
      *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 32) = v6;
      sub_10008C938(a1 + 56, a2 + 56);
    }
  }

  else if (*(_BYTE *)(a1 + 112))
  {
    sub_1000A7874(a1);
  }

  else
  {
    sub_1000A78B4(a1, a2);
    *(_BYTE *)(a1 + 112) = 1;
  }

void sub_1000A7874(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 112))
  {
    sub_10008C0E0((wireless_diagnostics::google::protobuf::MessageLite *)(a1 + 56));
    *(_BYTE *)(a1 + 112) = 0;
  }

uint64_t sub_1000A78B4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  __int128 v3 = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 8) = v3;
  *(void *)(a2 + 16) = 0LL;
  *(void *)(a2 + 24) = 0LL;
  *(void *)(a2 + 8) = 0LL;
  __int128 v4 = *(_OWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = v4;
  sub_10008C06C(a1 + 56, a2 + 56);
  return a1;
}

void sub_1000A791C(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1000A7938(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 112))
  {
    sub_10008C0E0((wireless_diagnostics::google::protobuf::MessageLite *)(a1 + 56));
  }

  return a1;
}

double sub_1000A7978@<D0>(const __CFArray *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t context = 0LL;
  __int128 v6 = 0uLL;
  v7.length = CFArrayGetCount(a1);
  v7.location = 0LL;
  CFArrayApplyFunction(a1, v7, (CFArrayApplierFunction)sub_1000A79F0, &context);
  *(void *)a2 = context;
  double result = *(double *)&v6;
  *(_OWORD *)(a2 + 8) = v6;
  return result;
}

void sub_1000A79D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000A79F0(const void *a1, uint64_t a2)
{
  char v3 = sub_1000A7A28(a1);
  sub_1000A7A6C(a2, &v3);
}

uint64_t sub_1000A7A28(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFBooleanGetTypeID()) {
    return CFBooleanGetValue((CFBooleanRef)a1) != 0;
  }
  uint64_t v4 = sub_101228D08();
  return sub_1000A7A6C(v4);
}

void sub_1000A7A6C(uint64_t a1, _BYTE *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  if (v4 == v5 << 6)
  {
    unint64_t v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0LL) + 64) {
      unint64_t v6 = (v4 & 0xFFFFFFFFFFFFFFC0LL) + 64;
    }
    if (v4 <= 0x3FFFFFFFFFFFFFFELL) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    }
    sub_1000A7B10((char **)a1, v7);
    unint64_t v4 = *(void *)(a1 + 8);
  }

  *(void *)(a1 + 8) = v4 + 1;
  uint64_t v8 = *(char **)a1;
  unint64_t v9 = v4 >> 6;
  uint64_t v10 = 1LL << v4;
  if (*a2) {
    uint64_t v11 = *(void *)&v8[8 * v9] | v10;
  }
  else {
    uint64_t v11 = *(void *)&v8[8 * v9] & ~v10;
  }
  *(void *)&v8[8 * v9] = v11;
}

void sub_1000A7B10(char **a1, unint64_t a2)
{
  if (a2 > (void)a1[2] << 6)
  {
    if ((a2 & 0x8000000000000000LL) != 0) {
      sub_100007008();
    }
    uint64_t v10 = 0LL;
    __int128 v11 = 0uLL;
    sub_1000A7BCC(&v10, a2);
    unint64_t v3 = (unint64_t)a1[1];
    uint64_t v8 = *a1;
    int v9 = 0;
    unint64_t v6 = &v8[8 * (v3 >> 6)];
    int v7 = v3 & 0x3F;
    sub_1000A7C10(&v10, (uint64_t)&v8, (uint64_t)&v6, v3);
    unint64_t v4 = *a1;
    *a1 = v10;
    uint64_t v10 = v4;
    __int128 v5 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = v11;
    __int128 v11 = v5;
    if (v4) {
      operator delete(v4);
    }
  }

void sub_1000A7BB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000A7BCC(void *a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_100007008();
  }
  double result = sub_1000071BC((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0LL;
  a1[2] = v4;
  return result;
}

void sub_1000A7C10(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a1[1];
  unint64_t v5 = v4 + a4;
  a1[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41) {
      unint64_t v6 = (v5 - 1) >> 6;
    }
    else {
      unint64_t v6 = 0LL;
    }
    *(void *)(*a1 + 8 * v6) = 0LL;
  }

  int v7 = *(_DWORD *)(a2 + 8);
  uint64_t v8 = *(void *)a3;
  int v9 = *(_DWORD *)(a3 + 8);
  uint64_t v10 = *a1 + 8 * (v4 >> 6);
  uint64_t v16 = *(void *)a2;
  int v17 = v7;
  uint64_t v14 = v8;
  int v15 = v9;
  uint64_t v12 = v10;
  int v13 = v4 & 0x3F;
  sub_1000A7CB0(&v16, &v14, &v12, (uint64_t)&v11);
}

void sub_1000A7CB0(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v5 = *((_DWORD *)a1 + 2);
  uint64_t v6 = *a2;
  int v7 = *((_DWORD *)a2 + 2);
  uint64_t v16 = *a1;
  int v17 = v5;
  uint64_t v14 = v6;
  int v15 = v7;
  int v8 = *((_DWORD *)a3 + 2);
  uint64_t v12 = *a3;
  int v13 = v8;
  sub_1000A7D3C((uint64_t)&v16, (uint64_t)&v14, (uint64_t)&v12, (uint64_t)&v18);
  int v9 = v19;
  uint64_t v10 = v20;
  int v11 = v21;
  *(void *)a4 = v18;
  *(_DWORD *)(a4 + 8) = v9;
  *(void *)(a4 + 16) = v10;
  *(_DWORD *)(a4 + 24) = v11;
}

void sub_1000A7D3C(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v4 = *(void **)a1;
  int v5 = *(_DWORD *)(a1 + 8);
  for (i = *(_DWORD *)(a3 + 8); *(void *)a1 != *(void *)a2 || v5 != *(_DWORD *)(a2 + 8); int v5 = *(_DWORD *)(a1 + 8))
  {
    int v8 = *(uint64_t **)a3;
    uint64_t v9 = 1LL << i;
    if (((*v4 >> v5) & 1) != 0) {
      uint64_t v10 = *v8 | v9;
    }
    else {
      uint64_t v10 = *v8 & ~v9;
    }
    *int v8 = v10;
    if (v5 == 63)
    {
      int v11 = 0;
      *(void *)a1 = v4 + 1;
    }

    else
    {
      int v11 = v5 + 1;
    }

    *(_DWORD *)(a1 + 8) = v11;
    int v12 = *(_DWORD *)(a3 + 8);
    if (v12 == 63)
    {
      int i = 0;
      *(void *)a3 += 8LL;
    }

    else
    {
      int i = v12 + 1;
    }

    *(_DWORD *)(a3 + 8) = i;
    unint64_t v4 = *(void **)a1;
  }

  *(void *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v5;
  *(void *)(a4 + 16) = *(void *)a3;
  *(_DWORD *)(a4 + 24) = i;
}

void *sub_1000A7E0C(void *result, _BYTE *a2, _BYTE *a3, uint64_t a4)
{
  unint64_t v4 = result[1];
  unint64_t v5 = v4 + a4;
  result[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41) {
      unint64_t v6 = (v5 - 1) >> 6;
    }
    else {
      unint64_t v6 = 0LL;
    }
    *(void *)(*result + 8 * v6) = 0LL;
  }

  if (a2 != a3)
  {
    int v7 = v4 & 0x3F;
    int v8 = (uint64_t *)(*result + 8 * (v4 >> 6));
    do
    {
      uint64_t v9 = 1LL << v7;
      if (*a2) {
        uint64_t v10 = *v8 | v9;
      }
      else {
        uint64_t v10 = *v8 & ~v9;
      }
      *int v8 = v10;
      ++a2;
      v8 += v7 == 63;
      if (v7 == 63) {
        int v7 = 0;
      }
      else {
        ++v7;
      }
    }

    while (a2 != a3);
  }

  return result;
}

uint64_t sub_1000A7EA8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = a1 + 72;
  if (sub_1003C1048(a1 + 72))
  {
    unint64_t v5 = *(void **)(a1 + 224);
    if (!v5)
    {
      unint64_t v5 = operator new(0x10uLL);
      sub_1001519B8((uint64_t)v5, v4);
      unint64_t v6 = *(void **)(a1 + 224);
      *(void *)(a1 + sub_1000A7938(v46 - 224) = v5;
      if (v6)
      {
        operator delete(v6);
        unint64_t v5 = *(void **)(a1 + 224);
      }
    }

    uint64_t v7 = sub_100151A38((uint64_t)v5, a2);
    sub_1000A80D4(a1);
    return v7;
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    uint64_t v9 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning Can't insert because the database is invalid",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CBC8);
      }
      v11[0] = 0;
      uint64_t v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Can't insert because the database is invalid",  v11,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationModelTable::Entry]",  "%s\n",  v10);
    }

    return 0LL;
  }

void sub_1000A80B8(_Unwind_Exception *a1)
{
}

BOOL sub_1000A80D4(uint64_t a1)
{
  unsigned int v2 = sub_1000382F4(a1);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CBC8);
  }
  unint64_t v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 136446210;
    uint64_t v10 = "MicroLocationModels";
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicate s a serious problem",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    int v7 = 136446210;
    int v8 = "MicroLocationModels";
    unint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem",  &v7,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationModelTable]",  "%s\n",  v6);
  }

  BOOL result = sub_100030C84(a1);
  if (result)
  {
    else {
      uint64_t v5 = *(void *)(a1 + 160);
    }
    sub_1003C1EC0(a1 + 72, v5);
    return 1LL;
  }

  return result;
}

uint64_t sub_1000A82C8()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsModelTableMaxRows", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  unsigned int v2 = v7;
  unint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 100LL;
  }
}

void sub_1000A8388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

_OWORD *sub_1000A83A0(_OWORD *a1, __int128 *a2)
{
  __int128 v4 = *a2;
  *(_OWORD *)((char *)a1 + 12) = *(__int128 *)((char *)a2 + 12);
  *a1 = v4;
  sub_10006F41C((uint64_t)(a1 + 2), (uint64_t)(a2 + 2));
  sub_10004B7D4((uint64_t)a1 + 232, (__int128 *)((char *)a2 + 232));
  *(_OWORD *)((char *)a1 + 264) = *(__int128 *)((char *)a2 + 264);
  return a1;
}

void sub_1000A8408(_Unwind_Exception *a1)
{
}

_OWORD *sub_1000A841C(uint64_t a1, __int128 *a2, __int128 *a3, _OWORD *a4)
{
  __int128 v4 = a4;
  uint64_t v10 = a4;
  int v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    unint64_t v6 = a2;
    do
    {
      sub_1000A83A0(v4, v6);
      unint64_t v6 = (__int128 *)((char *)v6 + 280);
      __int128 v4 = (_OWORD *)((char *)v11 + 280);
      int v11 = (_OWORD *)((char *)v11 + 280);
    }

    while (v6 != a3);
  }

  char v9 = 1;
  sub_1000A84BC((uint64_t)v8);
  return v4;
}

void sub_1000A84A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000A84BC(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1000A84F0((uint64_t *)a1);
  }
  return a1;
}

uint64_t *sub_1000A84F0(uint64_t *result)
{
  unsigned int v2 = (uint64_t *)result[1];
  uint64_t v1 = (uint64_t *)result[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *result;
    do
    {
      v3 -= 280LL;
      BOOL result = (uint64_t *)sub_1000A8540(v5, v3);
    }

    while (v3 != v4);
  }

  return result;
}

uint64_t sub_1000A8540(uint64_t a1, uint64_t a2)
{
  return sub_10006F50C(a2 + 32);
}

void sub_1000A8578(void ***a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 280LL;
        sub_1000A8540((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_1000A85FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_10005068C(a1, v4, v6);
      v6 += 112LL;
      uint64_t v4 = v12 + 112;
      v12 += 112LL;
    }

    while (v6 != a3);
  }

  char v10 = 1;
  sub_1000A86A4((uint64_t)v9);
  return v4;
}

void sub_1000A8690( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000A86A4(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1000A86D8((uint64_t *)a1);
  }
  return a1;
}

void sub_1000A86D8(uint64_t *a1)
{
  unsigned int v2 = (uint64_t *)a1[1];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 112LL;
      sub_1000507A8(v5, v3);
    }

    while (v3 != v4);
  }

uint64_t sub_1000A8728(uint64_t a1)
{
  unsigned int v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1000A8760(uint64_t a1, void *a2)
{
  if (a2)
  {
    unsigned int v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_10004AD90((uint64_t)(v2 + 4));
      operator delete(v2);
      unsigned int v2 = v3;
    }

    while (v3);
  }

uint64_t sub_1000A879C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 352))
  {
    unsigned int v2 = *(void **)(a1 + 304);
    if (v2)
    {
      *(void *)(a1 + 312) = v2;
      operator delete(v2);
    }

    sub_100019B90(a1 + 256);
    uint64_t v4 = (void **)(a1 + 232);
    sub_100019C0C(&v4);
    sub_100019C7C(a1 + 72);
    sub_100019CEC(a1 + 16);
  }

  return a1;
}

uint64_t sub_1000A8814(uint64_t a1)
{
  unsigned int v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1000A884C(int a1, void *__p)
{
  if (__p)
  {
    unsigned int v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (std::__shared_weak_count *)v2[5];
      if (v4) {
        std::__shared_weak_count::__release_weak(v4);
      }
      operator delete(v2);
      unsigned int v2 = v3;
    }

    while (v3);
  }

void sub_1000A888C(id a1)
{
  qword_1019348E8 = (uint64_t)os_log_create("com.apple.locationd.Position", "MicrolocationQE");
}

uint64_t sub_1000A88B8(uint64_t result, uint64_t a2)
{
  if (*(unsigned __int8 *)(result + 280) == *(unsigned __int8 *)(a2 + 280))
  {
    if (*(_BYTE *)(result + 280)) {
      return sub_100151544(result, a2);
    }
  }

  else if (*(_BYTE *)(result + 280))
  {
    return sub_10001D050(result);
  }

  else
  {
    BOOL result = sub_100151540(result, a2);
    *(_BYTE *)(result + 280) = 1;
  }

  return result;
}

void sub_1000A88FC(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 120) == *(unsigned __int8 *)(a2 + 120))
  {
    if (*(_BYTE *)(a1 + 120))
    {
      sub_100007664(a1, (__n128 *)a2);
      sub_100007664(a1 + 24, (__n128 *)(a2 + 24));
      sub_10009AFF8(a1 + 48, a2 + 48);
      sub_100007664(a1 + 80, (__n128 *)(a2 + 80));
      uint64_t v4 = *(void *)(a2 + 104);
      *(_BYTE *)(a1 + 112) = *(_BYTE *)(a2 + 112);
      *(void *)(a1 + 104) = v4;
    }
  }

  else if (*(_BYTE *)(a1 + 120))
  {
    sub_1000A899C(a1);
  }

  else
  {
    sub_10009B0A4(a1, a2);
    *(_BYTE *)(a1 + 120) = 1;
  }

void sub_1000A899C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 120))
  {
    unsigned int v2 = *(void **)(a1 + 80);
    if (v2)
    {
      *(void *)(a1 + 88) = v2;
      operator delete(v2);
    }

    if (*(_BYTE *)(a1 + 72))
    {
      uint64_t v3 = *(void **)(a1 + 48);
      *(void *)(a1 + 48) = 0LL;
      if (v3) {
        operator delete[](v3);
      }
    }

    uint64_t v4 = *(void **)(a1 + 24);
    if (v4)
    {
      *(void *)(a1 + 32) = v4;
      operator delete(v4);
    }

    uint64_t v5 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v5;
      operator delete(v5);
    }

    *(_BYTE *)(a1 + 120) = 0;
  }

void sub_1000A8A0C(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = v1;
    if ((void *)v3 != v1)
    {
      do
        uint64_t v3 = sub_10000AE14(v3 - 32);
      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

void sub_1000A8A68(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0LL;
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v8 = a2[2];
  unsigned int v7 = a2 + 2;
  uint64_t v6 = v8;
  uint64_t v9 = *(v7 - 1);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 8) = v9;
  *(v7 - 1) = 0LL;
  uint64_t v10 = v7[1];
  *(void *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        v11 %= v12;
      }
    }

    else
    {
      v11 &= v12 - 1;
    }

    *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
    *unsigned int v7 = 0LL;
    v7[1] = 0LL;
  }

void sub_1000A8B08(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_100019BC8(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0LL;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0LL; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0LL;
    }

    *(void *)(a1 + 24) = 0LL;
  }

uint64_t sub_1000A8B5C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_100019D9C(a1 + 16, a2 + 16);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  sub_1000A8C4C((_BYTE *)(a1 + 72), a2 + 72);
  __int128 v4 = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 212) = *(_OWORD *)(a2 + 212);
  *(_OWORD *)(a1 + 200) = v4;
  *(void *)(a1 + 240) = 0LL;
  *(void *)(a1 + 248) = 0LL;
  *(void *)(a1 + 232) = 0LL;
  *(_OWORD *)(a1 + 232) = *(_OWORD *)(a2 + 232);
  *(void *)(a1 + 248) = *(void *)(a2 + 248);
  *(void *)(a2 + 232) = 0LL;
  *(void *)(a2 + 240) = 0LL;
  *(void *)(a2 + 248) = 0LL;
  sub_10001B9CC(a1 + 256, (uint64_t *)(a2 + 256));
  *(void *)(a1 + 296) = *(void *)(a2 + 296);
  *(void *)(a1 + 304) = 0LL;
  *(void *)(a1 + 312) = 0LL;
  *(void *)(a1 + 320) = 0LL;
  *(_OWORD *)(a1 + 304) = *(_OWORD *)(a2 + 304);
  *(void *)(a1 + 320) = *(void *)(a2 + 320);
  *(void *)(a2 + 304) = 0LL;
  *(void *)(a2 + 312) = 0LL;
  *(void *)(a2 + 320) = 0LL;
  __int128 v5 = *(_OWORD *)(a2 + 328);
  *(void *)(a1 + 344) = *(void *)(a2 + 344);
  *(_OWORD *)(a1 + 328) = v5;
  *(void *)(a2 + 336) = 0LL;
  *(void *)(a2 + 344) = 0LL;
  *(void *)(a2 + 328) = 0LL;
  *(_BYTE *)(a1 + 352) = 1;
  return a1;
}

void sub_1000A8C38(_Unwind_Exception *a1)
{
}

_BYTE *sub_1000A8C4C(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[120] = 0;
  if (*(_BYTE *)(a2 + 120))
  {
    sub_10009B0A4((uint64_t)a1, a2);
    a1[120] = 1;
  }

  return a1;
}

void sub_1000A8C8C(_Unwind_Exception *a1)
{
}

void *sub_1000A8CA8(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181CC40;
  result[1] = v3;
  return result;
}

uint64_t sub_1000A8CDC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181CC40;
  a2[1] = v2;
  return result;
}

void *sub_1000A8CF8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = (uint64_t)v10;
  if (!v10) {
    goto LABEL_4;
  }
  if (v10 != v9)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*v10 + 16LL))();
LABEL_4:
    unint64_t v12 = (_BYTE *)v4;
    goto LABEL_6;
  }

  unint64_t v12 = v11;
  (*(void (**)(void *, _BYTE *))(v9[0] + 24LL))(v9, v11);
LABEL_6:
  sub_1000A6AC4(v3, (uint64_t)v11);
  __int128 v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    __int128 v5 = v11;
  }

  else
  {
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  BOOL result = v10;
  if (v10 == v9)
  {
    uint64_t v8 = 4LL;
    BOOL result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v8 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1000A8E04( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v18 = a13;
  if (a13 == &a10)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*(void *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000A8E74(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000A8EB0()
{
}

void *sub_1000A8EC4(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181CCC0;
  result[1] = v3;
  return result;
}

uint64_t sub_1000A8EF8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181CCC0;
  a2[1] = v2;
  return result;
}

void *sub_1000A8F14(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = (uint64_t)v10;
  if (!v10) {
    goto LABEL_4;
  }
  if (v10 != v9)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*v10 + 16LL))();
LABEL_4:
    unint64_t v12 = (_BYTE *)v4;
    goto LABEL_6;
  }

  unint64_t v12 = v11;
  (*(void (**)(void *, _BYTE *))(v9[0] + 24LL))(v9, v11);
LABEL_6:
  sub_1000A63EC(v3, (uint64_t)v11);
  __int128 v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    __int128 v5 = v11;
  }

  else
  {
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  BOOL result = v10;
  if (v10 == v9)
  {
    uint64_t v8 = 4LL;
    BOOL result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v8 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1000A9020( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v18 = a13;
  if (a13 == &a10)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*(void *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000A9090(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000A90CC()
{
}

void *sub_1000A90E0(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181CD40;
  result[1] = v3;
  return result;
}

uint64_t sub_1000A9114(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181CD40;
  a2[1] = v2;
  return result;
}

void *sub_1000A9130(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = (uint64_t)v10;
  if (!v10) {
    goto LABEL_4;
  }
  if (v10 != v9)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*v10 + 16LL))();
LABEL_4:
    unint64_t v12 = (_BYTE *)v4;
    goto LABEL_6;
  }

  unint64_t v12 = v11;
  (*(void (**)(void *, _BYTE *))(v9[0] + 24LL))(v9, v11);
LABEL_6:
  sub_10009DD30(v3, (uint64_t)v11, 0);
  __int128 v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    __int128 v5 = v11;
  }

  else
  {
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  BOOL result = v10;
  if (v10 == v9)
  {
    uint64_t v8 = 4LL;
    BOOL result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v8 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1000A9240( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v18 = a13;
  if (a13 == &a10)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*(void *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000A92B0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000A92EC()
{
}

void *sub_1000A9300(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181CDC0;
  result[1] = v3;
  return result;
}

uint64_t sub_1000A9334(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181CDC0;
  a2[1] = v2;
  return result;
}

void *sub_1000A9350(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = (uint64_t)v10;
  if (!v10) {
    goto LABEL_4;
  }
  if (v10 != v9)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*v10 + 16LL))();
LABEL_4:
    unint64_t v12 = (_BYTE *)v4;
    goto LABEL_6;
  }

  unint64_t v12 = v11;
  (*(void (**)(void *, _BYTE *))(v9[0] + 24LL))(v9, v11);
LABEL_6:
  sub_10009DD30(v3, (uint64_t)v11, 1u);
  __int128 v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    __int128 v5 = v11;
  }

  else
  {
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  BOOL result = v10;
  if (v10 == v9)
  {
    uint64_t v8 = 4LL;
    BOOL result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v8 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1000A9460( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v18 = a13;
  if (a13 == &a10)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*(void *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000A94D0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000A950C()
{
}

void *sub_1000A9520(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181CE40;
  result[1] = v3;
  return result;
}

uint64_t sub_1000A9554(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181CE40;
  a2[1] = v2;
  return result;
}

void *sub_1000A9570(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = (uint64_t)v10;
  if (!v10) {
    goto LABEL_4;
  }
  if (v10 != v9)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*v10 + 16LL))();
LABEL_4:
    unint64_t v12 = (_BYTE *)v4;
    goto LABEL_6;
  }

  unint64_t v12 = v11;
  (*(void (**)(void *, _BYTE *))(v9[0] + 24LL))(v9, v11);
LABEL_6:
  sub_10009DD30(v3, (uint64_t)v11, 2u);
  __int128 v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    __int128 v5 = v11;
  }

  else
  {
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  BOOL result = v10;
  if (v10 == v9)
  {
    uint64_t v8 = 4LL;
    BOOL result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v8 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1000A9680( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v18 = a13;
  if (a13 == &a10)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*(void *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000A96F0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000A972C()
{
}

void *sub_1000A9740(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181CEC0;
  result[1] = v3;
  return result;
}

uint64_t sub_1000A9774(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181CEC0;
  a2[1] = v2;
  return result;
}

void *sub_1000A9790(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = (uint64_t)v10;
  if (!v10) {
    goto LABEL_4;
  }
  if (v10 != v9)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*v10 + 16LL))();
LABEL_4:
    unint64_t v12 = (_BYTE *)v4;
    goto LABEL_6;
  }

  unint64_t v12 = v11;
  (*(void (**)(void *, _BYTE *))(v9[0] + 24LL))(v9, v11);
LABEL_6:
  sub_1000A6CA0(v3, (uint64_t)v11);
  __int128 v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    __int128 v5 = v11;
  }

  else
  {
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  BOOL result = v10;
  if (v10 == v9)
  {
    uint64_t v8 = 4LL;
    BOOL result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v8 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1000A989C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v18 = a13;
  if (a13 == &a10)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*(void *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000A990C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000A9948()
{
}

void sub_1000A9954(uint64_t *a1)
{
  if (*a1)
  {
    sub_100012988(a1);
    operator delete((void *)*a1);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

uint64_t sub_1000A998C(uint64_t *a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5)
{
  uint64_t v5 = a2;
  if (a5 >= 1)
  {
    uint64_t v11 = a1[2];
    uint64_t v9 = (uint64_t)(a1 + 2);
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if (a5 <= (uint64_t)(v11 - v12) >> 6)
    {
      uint64_t v19 = v12 - a2;
      uint64_t v20 = (uint64_t)(v12 - a2) >> 6;
      if (v20 >= a5)
      {
        int v21 = (__int128 *)(a3 + (a5 << 6));
      }

      else
      {
        int v21 = (__int128 *)(a3 + (v20 << 6));
        a1[1] = sub_1000A9CE8(v9, v21, a4, *(void *)(v9 - 8));
        if (v19 < 1) {
          return v5;
        }
      }

      sub_1000A9B08((uint64_t)a1, v5, v12, v5 + (a5 << 6));
      sub_1000A9EF0(a3, (uint64_t)v21, v5);
    }

    else
    {
      uint64_t v13 = *a1;
      unint64_t v14 = a5 + ((uint64_t)(v12 - *a1) >> 6);
      if (v14 >> 58) {
        sub_100007008();
      }
      uint64_t v15 = (a2 - v13) >> 6;
      uint64_t v16 = v10 - v13;
      if (v16 >> 5 > v14) {
        unint64_t v14 = v16 >> 5;
      }
      else {
        unint64_t v17 = v14;
      }
      uint64_t v27 = v9;
      if (v17) {
        uint64_t v18 = (char *)sub_10001275C(v9, v17);
      }
      else {
        uint64_t v18 = 0LL;
      }
      uint64_t v23 = v18;
      uint64_t v24 = &v18[64 * v15];
      CFStringRef v25 = v24;
      int v26 = &v18[64 * v17];
      sub_1000A9B94(&v23, a3, a5);
      uint64_t v5 = sub_1000A9C38(a1, &v23, v5);
      sub_1000128C0((uint64_t)&v23);
    }
  }

  return v5;
}

void sub_1000A9AE8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000A9B08(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    unint64_t v9 = v7;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      *(_OWORD *)uint64_t v8 = *(_OWORD *)v9;
      __int128 v10 = *(_OWORD *)(v9 + 16);
      *(void *)(v8 + 32) = *(void *)(v9 + 32);
      *(_OWORD *)(v8 + 16) = v10;
      *(void *)(v9 + 24) = 0LL;
      *(void *)(v9 + 32) = 0LL;
      *(void *)(v9 + 16) = 0LL;
      __int128 v11 = *(_OWORD *)(v9 + 40);
      *(void *)(v8 + 56) = *(void *)(v9 + 56);
      *(_OWORD *)(v8 + 40) = v11;
      v8 += 64LL;
      v9 += 64LL;
    }

    while (v9 < a3);
  }

  *(void *)(a1 + 8) = v8;
  return sub_1000A9E40((uint64_t)&v13, a2, v7, v6);
}

void *sub_1000A9B94(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = result[2];
  if (a3)
  {
    uint64_t v5 = (__int128 *)(a2 + 16);
    uint64_t v6 = a3 << 6;
    uint64_t v7 = v4 + (a3 << 6);
    do
    {
      *(_OWORD *)uint64_t v4 = *(v5 - 1);
      BOOL result = (void *)(v4 + 16);
      if (*((char *)v5 + 23) < 0)
      {
        BOOL result = sub_1010DD48C(result, *(void **)v5, *((void *)v5 + 1));
      }

      else
      {
        __int128 v8 = *v5;
        *(void *)(v4 + 32) = *((void *)v5 + 2);
        *(_OWORD *)BOOL result = v8;
      }

      __int128 v9 = *(__int128 *)((char *)v5 + 24);
      *(void *)(v4 + 56) = *((void *)v5 + 5);
      *(_OWORD *)(v4 + 40) = v9;
      v4 += 64LL;
      v5 += 4;
      v6 -= 64LL;
    }

    while (v6);
    uint64_t v4 = v7;
  }

  v3[2] = v4;
  return result;
}

void sub_1000A9C30(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1000A9C38(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = (uint64_t)(a1 + 2);
  sub_100012790((uint64_t)(a1 + 2), a3, a3, *a1, *a1, v6, v6);
  a2[1] = v8;
  a2[2] = sub_1000A9F68(v7, a3, a1[1], a2[2]);
  uint64_t v9 = *a1;
  *a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = a1[1];
  a1[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = a1[2];
  a1[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_1000A9CE8(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v15 = a4;
  uint64_t v16 = a4;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  char v14 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2 + 1;
    do
    {
      *(_OWORD *)uint64_t v4 = *(v6 - 1);
      uint64_t v7 = (_BYTE *)(v4 + 16);
      if (*((char *)v6 + 23) < 0)
      {
        sub_1010DD48C(v7, *(void **)v6, *((void *)v6 + 1));
        uint64_t v9 = v16;
      }

      else
      {
        __int128 v8 = *v6;
        *(void *)(v4 + 32) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v7 = v8;
        uint64_t v9 = v4;
      }

      uint64_t v10 = v6 - 1;
      __int128 v11 = *(__int128 *)((char *)v6 + 24);
      *(void *)(v4 + 56) = *((void *)v6 + 5);
      *(_OWORD *)(v4 + 40) = v11;
      uint64_t v4 = v9 + 64;
      uint64_t v16 = v9 + 64;
      v6 += 4;
    }

    while (v10 + 4 != a3);
  }

  char v14 = 1;
  sub_1000A9DC8((uint64_t)v13);
  return v4;
}

void sub_1000A9DB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000A9DC8(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1000A9DFC(a1);
  }
  return a1;
}

void sub_1000A9DFC(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    v1 -= 64LL;
  }

uint64_t sub_1000A9E40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = a3 + v7;
      uint64_t v9 = a4 + v7;
      *(_OWORD *)(a4 + v7 - 64) = *(_OWORD *)(a3 + v7 - 64);
      uint64_t v10 = (void **)(a4 + v7 - 48);
      __int128 v11 = *(_OWORD *)(v8 - 48);
      *(void *)(a4 + v7 - 32) = *(void *)(v8 - 32);
      *(_OWORD *)uint64_t v10 = v11;
      *(_BYTE *)(v8 - 25) = 0;
      *(_BYTE *)(v8 - 48) = 0;
      __int128 v12 = *(_OWORD *)(v8 - 24);
      *(void *)(v9 - 8) = *(void *)(v8 - 8);
      *(_OWORD *)(v9 - 24) = v12;
      v7 -= 64LL;
    }

    while (a3 + v7 != a2);
  }

  return a3;
}

uint64_t sub_1000A9EF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  uint64_t v5 = a2;
  do
  {
    *(_OWORD *)a3 = *(_OWORD *)v4;
    std::string::operator=((std::string *)(a3 + 16), (const std::string *)(v4 + 16));
    uint64_t v6 = *(void *)(v4 + 56);
    *(_OWORD *)(a3 + 40) = *(_OWORD *)(v4 + 40);
    *(void *)(a3 + 56) = v6;
    a3 += 64LL;
    v4 += 64LL;
  }

  while (v4 != v5);
  return v5;
}

uint64_t sub_1000A9F68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v10 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  if (a2 != a3)
  {
    do
    {
      *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
      __int128 v5 = *(_OWORD *)(a2 + 16);
      *(void *)(v4 + 32) = *(void *)(a2 + 32);
      *(_OWORD *)(v4 + 16) = v5;
      *(void *)(a2 + 24) = 0LL;
      *(void *)(a2 + 32) = 0LL;
      *(void *)(a2 + 16) = 0LL;
      __int128 v6 = *(_OWORD *)(a2 + 40);
      *(void *)(v4 + 56) = *(void *)(a2 + 56);
      *(_OWORD *)(v4 + 40) = v6;
      v4 += 64LL;
      a2 += 64LL;
    }

    while (a2 != a3);
    uint64_t v11 = v4;
  }

  char v9 = 1;
  sub_1000A9DC8((uint64_t)v8);
  return v4;
}

void sub_1000AA004(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 240LL;
        sub_10001A3D4((uint64_t)(a1 + 2), v3);
      }

      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

void sub_1000AA070(__int128 *a1, __int128 *a2)
{
  __int128 v11 = *a1;
  uint64_t v12 = *((void *)a1 + 2);
  *(_OWORD *)__int128 __p = *(__int128 *)((char *)a1 + 24);
  uint64_t v14 = *((void *)a1 + 5);
  *((void *)a1 + 3) = 0LL;
  *((void *)a1 + 4) = 0LL;
  *((void *)a1 + 5) = 0LL;
  *(_OWORD *)uint64_t v15 = a1[3];
  *(_OWORD *)&v15[12] = *(__int128 *)((char *)a1 + 60);
  uint64_t v4 = (uint64_t)(a1 + 5);
  sub_1000865CC(v16);
  __int128 v5 = (void **)a1 + 3;
  __int128 v17 = *(__int128 *)((char *)a1 + 216);
  char v18 = *((_BYTE *)a1 + 232);
  uint64_t v6 = *((void *)a2 + 2);
  *a1 = *a2;
  *((void *)a1 + 2) = v6;
  __int128 v7 = *(__int128 *)((char *)a2 + 24);
  *((void *)a1 + 5) = *((void *)a2 + 5);
  *(_OWORD *)__int128 v5 = v7;
  *((_BYTE *)a2 + 47) = 0;
  *((_BYTE *)a2 + 24) = 0;
  __int128 v8 = a2[3];
  *(__int128 *)((char *)a1 + 60) = *(__int128 *)((char *)a2 + 60);
  a1[3] = v8;
  sub_100087EC8(v4, (uint64_t)(a2 + 5));
  char v9 = (void **)a2 + 3;
  __int128 v10 = *(__int128 *)((char *)a2 + 216);
  *((_BYTE *)a1 + 232) = *((_BYTE *)a2 + 232);
  *(__int128 *)((char *)a1 + 216) = v10;
  *a2 = v11;
  *((void *)a2 + 2) = v12;
  *(_OWORD *)char v9 = *(_OWORD *)__p;
  *((void *)a2 + 5) = v14;
  a2[3] = *(_OWORD *)v15;
  *(__int128 *)((char *)a2 + 60) = *(_OWORD *)&v15[12];
  sub_100087EC8((uint64_t)(a2 + 5), (uint64_t)v16);
  *(__int128 *)((char *)a2 + 216) = v17;
  *((_BYTE *)a2 + 232) = v18;
  sub_100086708(v16);
}

void sub_1000AA24C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1000AA278(uint64_t a1)
{
  unsigned int v2 = sub_100038508(a1);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CBC8);
  }
  uint64_t v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 136446210;
    __int128 v10 = "MicroLocationConfiguration";
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicate s a serious problem",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CBC8);
    }
    int v7 = 136446210;
    __int128 v8 = "MicroLocationConfiguration";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem",  &v7,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationConfigurationTable]",  "%s\n",  v6);
  }

  BOOL result = sub_100030E18(a1);
  if (result)
  {
    else {
      uint64_t v5 = *(void *)(a1 + 160);
    }
    sub_1003C1EC0(a1 + 72, v5);
    return 1LL;
  }

  return result;
}

uint64_t sub_1000AA46C()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsConfigurationTableMaxRows", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  unsigned int v2 = v7;
  uint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 6666LL;
  }
}

void sub_1000AA52C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_1000AA544(void ***a1)
{
  int v1 = *a1;
  unsigned int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 88LL;
        sub_1000AA5C8((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_1000AA5C8(uint64_t a1, uint64_t a2)
{
}

void sub_1000AA60C(void ***a1)
{
  int v1 = *a1;
  unsigned int v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56LL;
        sub_1000AA690((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_1000AA690(uint64_t a1, uint64_t a2)
{
}

void sub_1000AA6D4(unint64_t *a1, unint64_t *a2, uint64_t a3, char a4)
{
LABEL_1:
  uint64_t v6 = (__int128 *)a2;
  unsigned int v7 = a2 - 30;
  uint64_t v8 = a1;
  while (2)
  {
    a1 = v8;
    uint64_t v9 = (char *)v6 - (char *)v8;
    uint64_t v10 = 0xEEEEEEEEEEEEEEEFLL * (v9 >> 4);
    switch(v10)
    {
      case 0LL:
      case 1LL:
        return;
      case 2LL:
        unint64_t v101 = bswap64(*(a2 - 30));
        unint64_t v102 = bswap64(*a1);
        if (v101 != v102 || (v101 = bswap64(*(a2 - 29)), unint64_t v102 = bswap64(a1[1]), v101 != v102))
        {
          if (v101 < v102) {
            int v211 = -1;
          }
          else {
            int v211 = 1;
          }
          if (v211 < 0) {
            sub_1000AA070((__int128 *)a1, (__int128 *)a2 - 15);
          }
        }

        return;
      case 3LL:
        sub_1000AC0C8(a1, a1 + 30, v7);
        return;
      case 4LL:
        sub_1000AC684(a1, a1 + 30, a1 + 60, v7);
        return;
      case 5LL:
        sub_1000ABF1C(a1, a1 + 30, a1 + 60, a1 + 90, v7);
        return;
      default:
        if (v9 > 5759)
        {
          if (!a3)
          {
            if (a1 != (unint64_t *)v6)
            {
              int64_t v126 = (unint64_t)(v10 - 2) >> 1;
              int64_t v127 = v126;
              do
              {
                int64_t v128 = v127;
                if (v126 >= v127)
                {
                  uint64_t v129 = (2 * v127) | 1;
                  int v130 = &a1[30 * v129];
                  if (2 * v127 + 2 < v10)
                  {
                    unint64_t v131 = bswap64(*v130);
                    unint64_t v132 = bswap64(v130[30]);
                    if (v131 == v132 && (unint64_t v131 = bswap64(v130[1]), v132 = bswap64(v130[31]), v131 == v132)) {
                      int v133 = 0;
                    }
                    else {
                      int v133 = v131 < v132 ? -1 : 1;
                    }
                    if (v133 < 0)
                    {
                      v130 += 30;
                      uint64_t v129 = 2 * v127 + 2;
                    }
                  }

                  int v134 = &a1[30 * v127];
                  unint64_t v135 = bswap64(*v130);
                  unint64_t v136 = bswap64(*v134);
                  if (v135 == v136 && (v135 = bswap64(v130[1]), unint64_t v136 = bswap64(v134[1]), v135 == v136)
                    || (v135 < v136 ? (int v137 = -1) : (int v137 = 1), (v137 & 0x80000000) == 0))
                  {
                    __int128 v138 = *(_OWORD *)v134;
                    unint64_t v243 = v134[2];
                    __int128 v242 = v138;
                    __int128 v139 = &a1[30 * v128];
                    __int128 v140 = *(_OWORD *)(v139 + 3);
                    unint64_t v245 = v139[5];
                    __int128 __p = v140;
                    v139[4] = 0LL;
                    v139[5] = 0LL;
                    v139[3] = 0LL;
                    __int128 v141 = *((_OWORD *)v139 + 3);
                    *(_OWORD *)((char *)v246 + 12) = *(_OWORD *)((char *)v139 + 60);
                    v246[0] = v141;
                    sub_1000865CC(v247);
                    __int128 v142 = &a1[30 * v128];
                    __int128 v143 = *(_OWORD *)(v142 + 27);
                    char v249 = *((_BYTE *)v142 + 232);
                    __int128 v248 = v143;
                    do
                    {
                      int v144 = v130;
                      __int128 v145 = *(_OWORD *)v130;
                      v134[2] = v130[2];
                      *(_OWORD *)int v134 = v145;
                      __int128 v146 = (void **)(v134 + 3);
                      __int128 v147 = *(_OWORD *)(v144 + 3);
                      v134[5] = v144[5];
                      *(_OWORD *)__int128 v146 = v147;
                      *((_BYTE *)v144 + 47) = 0;
                      *((_BYTE *)v144 + 24) = 0;
                      __int128 v148 = *((_OWORD *)v144 + 3);
                      *(_OWORD *)((char *)v134 + 60) = *(_OWORD *)((char *)v144 + 60);
                      *((_OWORD *)v134 + 3) = v148;
                      sub_100087EC8((uint64_t)(v134 + 10), (uint64_t)(v144 + 10));
                      __int128 v149 = *(_OWORD *)(v144 + 27);
                      *((_BYTE *)v134 + 232) = *((_BYTE *)v144 + 232);
                      *(_OWORD *)(v134 + 27) = v149;
                      if (v126 < v129) {
                        break;
                      }
                      int v130 = &a1[30 * ((2 * v129) | 1)];
                      if (2 * v129 + 2 >= v10)
                      {
                        uint64_t v129 = (2 * v129) | 1;
                      }

                      else
                      {
                        unint64_t v150 = bswap64(*v130);
                        unint64_t v151 = bswap64(v130[30]);
                        if (v150 == v151 && (unint64_t v150 = bswap64(v130[1]), v151 = bswap64(v130[31]), v150 == v151)) {
                          int v152 = 0;
                        }
                        else {
                          int v152 = v150 < v151 ? -1 : 1;
                        }
                        if (v152 >= 0)
                        {
                          uint64_t v129 = (2 * v129) | 1;
                        }

                        else
                        {
                          v130 += 30;
                          uint64_t v129 = 2 * v129 + 2;
                        }
                      }

                      unint64_t v153 = bswap64(*v130);
                      unint64_t v154 = bswap64(v242);
                      if (v153 == v154
                        && (unint64_t v153 = bswap64(v130[1]), v154 = bswap64(*((unint64_t *)&v242 + 1)), v153 == v154))
                      {
                        int v155 = 0;
                      }

                      else
                      {
                        int v155 = v153 < v154 ? -1 : 1;
                      }

                      int v134 = v144;
                    }

                    while ((v155 & 0x80000000) == 0);
                    int v156 = (void **)(v144 + 3);
                    __int128 v157 = v242;
                    v144[2] = v243;
                    *(_OWORD *)int v144 = v157;
                    __int128 v158 = __p;
                    v144[5] = v245;
                    *(_OWORD *)int v156 = v158;
                    HIBYTE(v245) = 0;
                    LOBYTE(__p) = 0;
                    __int128 v159 = *(_OWORD *)((char *)v246 + 12);
                    *((_OWORD *)v144 + 3) = v246[0];
                    *(_OWORD *)((char *)v144 + 60) = v159;
                    sub_100087EC8((uint64_t)(v144 + 10), (uint64_t)v247);
                    __int128 v160 = v248;
                    *((_BYTE *)v144 + 232) = v249;
                    *(_OWORD *)(v144 + 27) = v160;
                    sub_100086708(v247);
                    if (SHIBYTE(v245) < 0) {
                      operator delete((void *)__p);
                    }
                  }
                }

                int64_t v127 = v128 - 1;
              }

              while (v128);
              int64_t v161 = v9 / 0xF0uLL;
              v230 = (__int128 *)(a1 + 3);
              do
              {
                unint64_t v235 = a1[2];
                __int128 v234 = *(_OWORD *)a1;
                __int128 v236 = *v230;
                unint64_t v237 = a1[5];
                a1[4] = 0LL;
                a1[5] = 0LL;
                *(void *)v230 = 0LL;
                *(_OWORD *)v238 = *((_OWORD *)a1 + 3);
                *(_OWORD *)&v238[12] = *(_OWORD *)((char *)a1 + 60);
                sub_1000865CC(v239);
                uint64_t v162 = 0LL;
                __int128 v163 = *(_OWORD *)(a1 + 27);
                char v241 = *((_BYTE *)a1 + 232);
                __int128 v240 = v163;
                uint64_t v164 = (uint64_t)a1;
                do
                {
                  uint64_t v165 = v164 + 240 * v162 + 240;
                  uint64_t v166 = 2 * v162;
                  uint64_t v162 = (2 * v162) | 1;
                  if (v166 + 2 < v161)
                  {
                    unint64_t v167 = bswap64(*(void *)v165);
                    unint64_t v168 = bswap64(*(void *)(v165 + 240));
                    if (v167 == v168
                      && (v167 = bswap64(*(void *)(v165 + 8)), unint64_t v168 = bswap64(*(void *)(v165 + 248)), v167 == v168))
                    {
                      int v169 = 0;
                    }

                    else
                    {
                      int v169 = v167 < v168 ? -1 : 1;
                    }

                    if (v169 < 0)
                    {
                      v165 += 240LL;
                      uint64_t v162 = v166 + 2;
                    }
                  }

                  __int128 v170 = *(_OWORD *)v165;
                  *(void *)(v164 + 16) = *(void *)(v165 + 16);
                  *(_OWORD *)uint64_t v164 = v170;
                  uint64_t v171 = (void **)(v164 + 24);
                  __int128 v172 = *(_OWORD *)(v165 + 24);
                  *(void *)(v164 + 40) = *(void *)(v165 + 40);
                  *(_OWORD *)uint64_t v171 = v172;
                  *(_BYTE *)(v165 + 47) = 0;
                  *(_BYTE *)(v165 + 24) = 0;
                  __int128 v173 = *(_OWORD *)(v165 + 48);
                  *(_OWORD *)(v164 + 60) = *(_OWORD *)(v165 + 60);
                  *(_OWORD *)(v164 + 48) = v173;
                  sub_100087EC8(v164 + 80, v165 + 80);
                  __int128 v174 = *(_OWORD *)(v165 + 216);
                  *(_BYTE *)(v164 + 232) = *(_BYTE *)(v165 + 232);
                  *(_OWORD *)(v164 + 216) = v174;
                  uint64_t v164 = v165;
                }

                while (v162 <= (uint64_t)((unint64_t)(v161 - 2) >> 1));
                unsigned int v175 = (void **)(v165 + 24);
                int v176 = (__int128 *)(v165 + 48);
                v232 = (__int128 *)(v165 + 216);
                if ((unint64_t *)v165 == a2 - 30)
                {
                  *(void *)(v165 + 16) = v235;
                  *(_OWORD *)uint64_t v165 = v234;
                  *(void *)(v165 + 40) = v237;
                  *(_OWORD *)unsigned int v175 = v236;
                  *(_OWORD *)(v165 + 60) = *(_OWORD *)&v238[12];
                  *int v176 = *(_OWORD *)v238;
                  sub_100087EC8(v165 + 80, (uint64_t)v239);
                  __int128 v190 = v240;
                  *(_BYTE *)(v165 + 232) = v241;
                  __int128 *v232 = v190;
                }

                else
                {
                  __int128 v177 = *((_OWORD *)a2 - 15);
                  *(void *)(v165 + 16) = *(a2 - 28);
                  *(_OWORD *)uint64_t v165 = v177;
                  __int128 v178 = *(_OWORD *)(a2 - 27);
                  *(void *)(v165 + 40) = *(a2 - 25);
                  *(_OWORD *)unsigned int v175 = v178;
                  *((_BYTE *)a2 - 193) = 0;
                  *((_BYTE *)a2 - 216) = 0;
                  __int128 v179 = *((_OWORD *)a2 - 12);
                  *(_OWORD *)(v165 + 60) = *(_OWORD *)((char *)a2 - 180);
                  *int v176 = v179;
                  sub_100087EC8(v165 + 80, (uint64_t)(a2 - 20));
                  uint64_t v180 = (void **)(a2 - 27);
                  __int128 v181 = *(_OWORD *)(a2 - 3);
                  *(_BYTE *)(v165 + 232) = *((_BYTE *)a2 - 8);
                  __int128 *v232 = v181;
                  *(a2 - 28) = v235;
                  *((_OWORD *)a2 - 15) = v234;
                  uint64_t v182 = a2 - 24;
                  *(a2 - 25) = v237;
                  *(_OWORD *)uint64_t v180 = v236;
                  *(_OWORD *)((char *)v182 + 12) = *(_OWORD *)&v238[12];
                  *(_OWORD *)uint64_t v182 = *(_OWORD *)v238;
                  sub_100087EC8((uint64_t)(a2 - 20), (uint64_t)v239);
                  v183 = a2 - 3;
                  __int128 v184 = v240;
                  *((_BYTE *)v183 + 16) = v241;
                  *(_OWORD *)v183 = v184;
                  uint64_t v185 = v165 - (void)a1 + 240;
                  if (v185 >= 241)
                  {
                    unint64_t v186 = (v185 / 0xF0uLL - 2) >> 1;
                    __int16 v187 = &a1[30 * v186];
                    unint64_t v188 = bswap64(*v187);
                    unint64_t v189 = bswap64(*(void *)v165);
                    if (v188 != v189 || (unint64_t v188 = bswap64(v187[1]), v189 = bswap64(*(void *)(v165 + 8)), v188 != v189))
                    {
                      int v191 = v188 < v189 ? -1 : 1;
                      if (v191 < 0)
                      {
                        __int128 v192 = *(_OWORD *)v165;
                        unint64_t v243 = *(void *)(v165 + 16);
                        __int128 v242 = v192;
                        __int128 v193 = *(_OWORD *)v175;
                        unint64_t v245 = *(void *)(v165 + 40);
                        __int128 __p = v193;
                        *(void *)(v165 + 32) = 0LL;
                        *(void *)(v165 + 40) = 0LL;
                        *unsigned int v175 = 0LL;
                        __int128 v194 = *v176;
                        *(_OWORD *)((char *)v246 + 12) = *(_OWORD *)(v165 + 60);
                        v246[0] = v194;
                        sub_1000865CC(v247);
                        __int128 v195 = *v232;
                        char v249 = *(_BYTE *)(v165 + 232);
                        __int128 v248 = v195;
                        do
                        {
                          uint64_t v196 = (uint64_t)v187;
                          __int128 v197 = *(_OWORD *)v187;
                          *(void *)(v165 + 16) = v187[2];
                          *(_OWORD *)uint64_t v165 = v197;
                          __int16 v198 = (void **)(v165 + 24);
                          __int128 v199 = *(_OWORD *)(v187 + 3);
                          *(void *)(v165 + 40) = v187[5];
                          *(_OWORD *)__int16 v198 = v199;
                          *((_BYTE *)v187 + 47) = 0;
                          *((_BYTE *)v187 + 24) = 0;
                          __int128 v200 = *((_OWORD *)v187 + 3);
                          *(_OWORD *)(v165 + 60) = *(_OWORD *)((char *)v187 + 60);
                          *(_OWORD *)(v165 + 48) = v200;
                          sub_100087EC8(v165 + 80, (uint64_t)(v187 + 10));
                          __int128 v201 = *(_OWORD *)(v187 + 27);
                          *(_BYTE *)(v165 + 232) = *((_BYTE *)v187 + 232);
                          *(_OWORD *)(v165 + 216) = v201;
                          if (!v186) {
                            break;
                          }
                          unint64_t v186 = (v186 - 1) >> 1;
                          __int16 v187 = &a1[30 * v186];
                          unint64_t v202 = bswap64(*v187);
                          unint64_t v203 = bswap64(v242);
                          if (v202 == v203
                            && (unint64_t v202 = bswap64(v187[1]), v203 = bswap64(*((unint64_t *)&v242 + 1)), v202 == v203))
                          {
                            int v204 = 0;
                          }

                          else
                          {
                            int v204 = v202 < v203 ? -1 : 1;
                          }

                          uint64_t v165 = v196;
                        }

                        while (v204 < 0);
                        int v205 = (void **)(v196 + 24);
                        __int128 v206 = v242;
                        *(void *)(v196 + 16) = v243;
                        *(_OWORD *)uint64_t v196 = v206;
                        __int128 v207 = __p;
                        *(void *)(v196 + 40) = v245;
                        *(_OWORD *)int v205 = v207;
                        HIBYTE(v245) = 0;
                        LOBYTE(__p) = 0;
                        __int128 v208 = *(_OWORD *)((char *)v246 + 12);
                        *(_OWORD *)(v196 + 48) = v246[0];
                        *(_OWORD *)(v196 + 60) = v208;
                        sub_100087EC8(v196 + 80, (uint64_t)v247);
                        __int128 v209 = v248;
                        *(_BYTE *)(v196 + 232) = v249;
                        *(_OWORD *)(v196 + 216) = v209;
                        sub_100086708(v247);
                        if (SHIBYTE(v245) < 0) {
                          operator delete((void *)__p);
                        }
                      }
                    }
                  }
                }

                sub_100086708(v239);
                a2 -= 30;
              }

              while (v161-- > 2);
            }

            return;
          }

          unint64_t v11 = (unint64_t)v10 >> 1;
          uint64_t v12 = &a1[30 * ((unint64_t)v10 >> 1)];
          if ((unint64_t)v9 < 0x7801)
          {
            sub_1000AC0C8(v12, a1, v7);
          }

          else
          {
            sub_1000AC0C8(a1, v12, v7);
            sub_1000AC0C8(a1 + 30, &a1[30 * v11 - 30], a2 - 60);
            sub_1000AC0C8(a1 + 60, &a1[30 * v11 + 30], a2 - 90);
            sub_1000AC0C8(&a1[30 * v11 - 30], v12, &a1[30 * v11 + 30]);
            sub_1000AA070((__int128 *)a1, (__int128 *)v12);
          }

          --a3;
          if ((a4 & 1) == 0)
          {
            if ((v13 = bswap64(*(a1 - 30)), unint64_t v14 = bswap64(*a1), v13 == v14)
              && (v13 = bswap64(*(a1 - 29)), unint64_t v14 = bswap64(a1[1]), v13 == v14)
              || (v13 < v14 ? (int v22 = -1) : (int v22 = 1), (v22 & 0x80000000) == 0))
            {
              __int128 v15 = *(_OWORD *)a1;
              unint64_t v243 = a1[2];
              __int128 v242 = v15;
              unint64_t v16 = a1[5];
              __int128 __p = *(_OWORD *)(a1 + 3);
              unint64_t v245 = v16;
              a1[4] = 0LL;
              a1[5] = 0LL;
              a1[3] = 0LL;
              __int128 v17 = *(_OWORD *)((char *)a1 + 60);
              v246[0] = *((_OWORD *)a1 + 3);
              *(_OWORD *)((char *)v246 + 12) = v17;
              sub_1000865CC(v247);
              __int128 v18 = *(_OWORD *)(a1 + 27);
              char v249 = *((_BYTE *)a1 + 232);
              __int128 v248 = v18;
              unint64_t v19 = bswap64(v242);
              unint64_t v20 = bswap64(*v7);
              if (v19 == v20
                && (unint64_t v19 = bswap64(*((unint64_t *)&v242 + 1)), v20 = bswap64(*(a2 - 29)), v19 == v20))
              {
                int v21 = 0;
              }

              else if (v19 < v20)
              {
                int v21 = -1;
              }

              else
              {
                int v21 = 1;
              }

              if (v21 < 0)
              {
                unsigned __int32 v69 = a1;
                uint64_t v8 = a1;
                do
                {
                  unint64_t v70 = v8[30];
                  v8 += 30;
                  unint64_t v71 = bswap64(v242);
                  unint64_t v72 = bswap64(v70);
                  if (v71 == v72
                    && (unint64_t v71 = bswap64(*((unint64_t *)&v242 + 1)), v72 = bswap64(v69[31]), v71 == v72))
                  {
                    int v73 = 0;
                  }

                  else if (v71 < v72)
                  {
                    int v73 = -1;
                  }

                  else
                  {
                    int v73 = 1;
                  }

                  unsigned __int32 v69 = v8;
                }

                while ((v73 & 0x80000000) == 0);
              }

              else
              {
                uint64_t v65 = a1 + 30;
                do
                {
                  uint64_t v8 = v65;
                  unint64_t v66 = bswap64(v242);
                  unint64_t v67 = bswap64(*v8);
                  else {
                    int v68 = v66 < v67 ? -1 : 1;
                  }
                  uint64_t v65 = v8 + 30;
                }

                while ((v68 & 0x80000000) == 0);
              }

              uint64_t v74 = v6;
              if (v8 < (unint64_t *)v6)
              {
                unint64_t v75 = v6;
                uint64_t v74 = v6;
                do
                {
                  unint64_t v76 = *((void *)v74 - 30);
                  v74 -= 15;
                  unint64_t v77 = bswap64(v242);
                  unint64_t v78 = bswap64(v76);
                  if (v77 == v78
                    && (unint64_t v77 = bswap64(*((unint64_t *)&v242 + 1)), v78 = bswap64(*((void *)v75 - 29)),
                                                                         v77 == v78))
                  {
                    int v79 = 0;
                  }

                  else if (v77 < v78)
                  {
                    int v79 = -1;
                  }

                  else
                  {
                    int v79 = 1;
                  }

                  unint64_t v75 = v74;
                }

                while (v79 < 0);
              }

              while (v8 < (unint64_t *)v74)
              {
                sub_1000AA070((__int128 *)v8, v74);
                unint64_t v80 = v8;
                do
                {
                  unint64_t v81 = v8[30];
                  v8 += 30;
                  unint64_t v82 = bswap64(v242);
                  unint64_t v83 = bswap64(v81);
                  if (v82 == v83
                    && (v82 = bswap64(*((unint64_t *)&v242 + 1)), unint64_t v83 = bswap64(v80[31]), v82 == v83))
                  {
                    int v84 = 0;
                  }

                  else if (v82 < v83)
                  {
                    int v84 = -1;
                  }

                  else
                  {
                    int v84 = 1;
                  }

                  unint64_t v80 = v8;
                }

                while ((v84 & 0x80000000) == 0);
                unint64_t v85 = v74;
                do
                {
                  unint64_t v86 = *((void *)v74 - 30);
                  v74 -= 15;
                  unint64_t v87 = bswap64(v242);
                  unint64_t v88 = bswap64(v86);
                  if (v87 == v88
                    && (unint64_t v87 = bswap64(*((unint64_t *)&v242 + 1)), v88 = bswap64(*((void *)v85 - 29)),
                                                                         v87 == v88))
                  {
                    int v89 = 0;
                  }

                  else if (v87 < v88)
                  {
                    int v89 = -1;
                  }

                  else
                  {
                    int v89 = 1;
                  }

                  unint64_t v85 = v74;
                }

                while (v89 < 0);
              }

              int v90 = v8 - 30;
              if (v8 - 30 != a1)
              {
                uint64_t v91 = (void **)(a1 + 3);
                __int128 v92 = *(_OWORD *)v90;
                a1[2] = *(v8 - 28);
                *(_OWORD *)a1 = v92;
                __int128 v93 = *(_OWORD *)(v8 - 27);
                a1[5] = *(v8 - 25);
                *(_OWORD *)uint64_t v91 = v93;
                *((_BYTE *)v8 - 193) = 0;
                *((_BYTE *)v8 - 216) = 0;
                __int128 v94 = *((_OWORD *)v8 - 12);
                *(_OWORD *)((char *)a1 + 60) = *(_OWORD *)((char *)v8 - 180);
                *((_OWORD *)a1 + 3) = v94;
                sub_100087EC8((uint64_t)(a1 + 10), (uint64_t)(v8 - 20));
                __int128 v95 = *(_OWORD *)(v8 - 3);
                *((_BYTE *)a1 + 232) = *((_BYTE *)v8 - 8);
                *(_OWORD *)(a1 + 27) = v95;
              }

              __int128 v96 = v242;
              *(v8 - 28) = v243;
              *(_OWORD *)int v90 = v96;
              uint64_t v97 = (void **)(v8 - 27);
              __int128 v98 = __p;
              *(v8 - 25) = v245;
              *(_OWORD *)uint64_t v97 = v98;
              HIBYTE(v245) = 0;
              LOBYTE(__p) = 0;
              __int128 v99 = v246[0];
              *(_OWORD *)((char *)v8 - 180) = *(_OWORD *)((char *)v246 + 12);
              *((_OWORD *)v8 - 12) = v99;
              sub_100087EC8((uint64_t)(v8 - 20), (uint64_t)v247);
              __int128 v100 = v248;
              *((_BYTE *)v8 - 8) = v249;
              *(_OWORD *)(v8 - 3) = v100;
              sub_100086708(v247);
              if (SHIBYTE(v245) < 0) {
                operator delete((void *)__p);
              }
              goto LABEL_78;
            }
          }

          __int128 v23 = *(_OWORD *)a1;
          unint64_t v243 = a1[2];
          __int128 v242 = v23;
          unint64_t v24 = a1[5];
          __int128 __p = *(_OWORD *)(a1 + 3);
          unint64_t v245 = v24;
          a1[4] = 0LL;
          a1[5] = 0LL;
          a1[3] = 0LL;
          __int128 v25 = *(_OWORD *)((char *)a1 + 60);
          v246[0] = *((_OWORD *)a1 + 3);
          *(_OWORD *)((char *)v246 + 12) = v25;
          sub_1000865CC(v247);
          uint64_t v26 = 0LL;
          uint64_t v27 = (void **)(a1 + 3);
          __int128 v28 = *(_OWORD *)(a1 + 27);
          char v249 = *((_BYTE *)a1 + 232);
          __int128 v248 = v28;
          do
          {
            unint64_t v29 = bswap64(a1[v26 + 30]);
            unint64_t v30 = bswap64(v242);
            if (v29 == v30
              && (unint64_t v29 = bswap64(a1[v26 + 31]), v30 = bswap64(*((unint64_t *)&v242 + 1)), v29 == v30))
            {
              int v31 = 0;
            }

            else if (v29 < v30)
            {
              int v31 = -1;
            }

            else
            {
              int v31 = 1;
            }

            v26 += 30LL;
          }

          while (v31 < 0);
          __int16 v32 = &a1[v26];
          unint64_t v33 = v6;
          if (v26 == 30)
          {
            std::string v38 = a2;
            while (v32 < v38)
            {
              __int128 v34 = (__int128 *)(v38 - 30);
              unint64_t v39 = bswap64(*(v38 - 30));
              unint64_t v40 = bswap64(v242);
              if (v39 == v40
                && (unint64_t v39 = bswap64(*(v38 - 29)), v40 = bswap64(*((unint64_t *)&v242 + 1)), v39 == v40))
              {
                int v41 = 0;
              }

              else if (v39 < v40)
              {
                int v41 = -1;
              }

              else
              {
                int v41 = 1;
              }

              v38 -= 30;
              if (v41 < 0) {
                goto LABEL_46;
              }
            }

            __int128 v34 = (__int128 *)v38;
          }

          else
          {
            do
            {
              __int128 v34 = v33 - 15;
              unint64_t v35 = bswap64(*((void *)v33 - 30));
              unint64_t v36 = bswap64(v242);
              if (v35 == v36
                && (v35 = bswap64(*((void *)v33 - 29)), unint64_t v36 = bswap64(*((unint64_t *)&v242 + 1)), v35 == v36))
              {
                int v37 = 0;
              }

              else if (v35 < v36)
              {
                int v37 = -1;
              }

              else
              {
                int v37 = 1;
              }

              v33 -= 15;
            }

            while ((v37 & 0x80000000) == 0);
          }

void sub_1000ABE48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a63 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1000ABF1C( unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t v10 = bswap64(*a5);
  unint64_t v11 = bswap64(*a4);
  if (v10 != v11 || (unint64_t v10 = bswap64(a5[1]), v11 = bswap64(a4[1]), v10 != v11))
  {
    int v12 = v10 < v11 ? -1 : 1;
    if (v12 < 0)
    {
      sub_1000AA070((__int128 *)a4, (__int128 *)a5);
      unint64_t v13 = bswap64(*a4);
      unint64_t v14 = bswap64(*a3);
      if (v13 != v14 || (v13 = bswap64(a4[1]), unint64_t v14 = bswap64(a3[1]), v13 != v14))
      {
        int v15 = v13 < v14 ? -1 : 1;
        if (v15 < 0)
        {
          sub_1000AA070((__int128 *)a3, (__int128 *)a4);
          unint64_t v16 = bswap64(*a3);
          unint64_t v17 = bswap64(*a2);
          if (v16 != v17 || (v16 = bswap64(a3[1]), unint64_t v17 = bswap64(a2[1]), v16 != v17))
          {
            int v18 = v16 < v17 ? -1 : 1;
            if (v18 < 0)
            {
              sub_1000AA070((__int128 *)a2, (__int128 *)a3);
              unint64_t v19 = bswap64(*a2);
              unint64_t v20 = bswap64(*a1);
              if (v19 == v20 && (unint64_t v19 = bswap64(a2[1]), v20 = bswap64(a1[1]), v19 == v20))
              {
                int v21 = 0;
              }

              else if (v19 < v20)
              {
                int v21 = -1;
              }

              else
              {
                int v21 = 1;
              }

              if (v21 < 0) {
                sub_1000AA070((__int128 *)a1, (__int128 *)a2);
              }
            }
          }
        }
      }
    }
  }

void sub_1000AC0C8(unint64_t *a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v5 = a1;
  unint64_t v6 = bswap64(*a2);
  unint64_t v7 = bswap64(*a1);
  if (v6 == v7 && (v6 = bswap64(a2[1]), unint64_t v7 = bswap64(a1[1]), v6 == v7))
  {
    int v8 = 0;
  }

  else if (v6 < v7)
  {
    int v8 = -1;
  }

  else
  {
    int v8 = 1;
  }

  unint64_t v9 = bswap64(*a3);
  unint64_t v10 = bswap64(*a2);
  if (v9 != v10 || (unint64_t v9 = bswap64(a3[1]), v10 = bswap64(a2[1]), v9 != v10))
  {
    if (v9 < v10) {
      int v11 = -1;
    }
    else {
      int v11 = 1;
    }
    if (v8 < 0) {
      goto LABEL_10;
    }
LABEL_18:
    if (v11 < 0)
    {
      sub_1000AA070((__int128 *)a2, (__int128 *)a3);
      unint64_t v14 = bswap64(*a2);
      unint64_t v15 = bswap64(*v5);
      if (v14 != v15 || (v14 = bswap64(a2[1]), unint64_t v15 = bswap64(v5[1]), v14 != v15))
      {
        int v18 = v14 < v15 ? -1 : 1;
        if (v18 < 0)
        {
          a1 = v5;
          unint64_t v17 = (__int128 *)a2;
          goto LABEL_34;
        }
      }
    }

    return;
  }

  int v11 = 0;
  if ((v8 & 0x80000000) == 0) {
    goto LABEL_18;
  }
LABEL_10:
  if (v11 < 0)
  {
LABEL_27:
    unint64_t v17 = (__int128 *)a3;
LABEL_34:
    sub_1000AA070((__int128 *)a1, v17);
    return;
  }

  sub_1000AA070((__int128 *)a1, (__int128 *)a2);
  unint64_t v12 = bswap64(*a3);
  unint64_t v13 = bswap64(*a2);
  if (v12 != v13 || (unint64_t v12 = bswap64(a3[1]), v13 = bswap64(a2[1]), v12 != v13))
  {
    int v16 = v12 < v13 ? -1 : 1;
    if (v16 < 0)
    {
      a1 = a2;
      goto LABEL_27;
    }
  }

BOOL sub_1000AC25C(unint64_t *a1, unint64_t *a2)
{
  unsigned int v2 = a2;
  unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * (((char *)a2 - (char *)a1) >> 4);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unint64_t v6 = bswap64(*(a2 - 30));
      unint64_t v7 = bswap64(*a1);
      if (v6 != v7 || (v6 = bswap64(*(a2 - 29)), unint64_t v7 = bswap64(a1[1]), v6 != v7))
      {
        int v31 = v6 < v7 ? -1 : 1;
        if (v31 < 0)
        {
          sub_1000AA070((__int128 *)a1, (__int128 *)a2 - 15);
          return 1LL;
        }
      }

      return result;
    case 3uLL:
      sub_1000AC0C8(a1, a1 + 30, a2 - 30);
      return 1LL;
    case 4uLL:
      sub_1000AC684(a1, a1 + 30, a1 + 60, a2 - 30);
      return 1LL;
    case 5uLL:
      sub_1000ABF1C(a1, a1 + 30, a1 + 60, a1 + 90, a2 - 30);
      return 1LL;
    default:
      int v8 = a1 + 60;
      sub_1000AC0C8(a1, a1 + 30, a1 + 60);
      unint64_t v9 = a1 + 90;
      if (a1 + 90 == v2) {
        return 1LL;
      }
      uint64_t v10 = 0LL;
      int v11 = 0;
      p_p = &__p;
      unint64_t v13 = &v37;
      __int16 v32 = v2;
      break;
  }

  while (1)
  {
    unint64_t v14 = bswap64(*v9);
    unint64_t v15 = bswap64(*v8);
    if (v14 != v15 || (v14 = bswap64(v9[1]), unint64_t v15 = bswap64(v8[1]), v14 != v15))
    {
      int v16 = v14 < v15 ? -1 : 1;
      if (v16 < 0)
      {
        __int128 v33 = *(_OWORD *)v9;
        unint64_t v34 = v9[2];
        *(_OWORD *)p_p = *(_OWORD *)(v9 + 3);
        unint64_t v17 = p_p;
        p_p[2] = (void *)v9[5];
        void v9[3] = 0LL;
        void v9[4] = 0LL;
        v9[5] = 0LL;
        *(_OWORD *)unint64_t v13 = *((_OWORD *)v9 + 3);
        int v18 = v13;
        *(_OWORD *)((char *)v13 + 12) = *(_OWORD *)((char *)v9 + 60);
        sub_1000865CC(v38);
        __int128 v39 = *(_OWORD *)(v9 + 27);
        char v40 = *((_BYTE *)v9 + 232);
        uint64_t v19 = v10;
        while (1)
        {
          unint64_t v20 = (char *)a1 + v19;
          *((_OWORD *)v20 + 45) = *(_OWORD *)((char *)a1 + v19 + 480);
          *((void *)v20 + 92) = *(unint64_t *)((char *)a1 + v19 + 496);
          int v21 = (void **)((char *)a1 + v19 + 744);
          *(unint64_t *)((char *)a1 + v19 + 760) = *((void *)v20 + 65);
          *(_OWORD *)int v21 = *(_OWORD *)(v20 + 504);
          v20[527] = 0;
          v20[504] = 0;
          *((_OWORD *)v20 + 48) = *((_OWORD *)v20 + 33);
          *(_OWORD *)(v20 + 780) = *(_OWORD *)(v20 + 540);
          sub_100087EC8((uint64_t)(v20 + 800), (uint64_t)(v20 + 560));
          int v22 = (char *)a1 + v19;
          uint64_t v23 = (uint64_t)a1 + v19 + 696;
          *((_BYTE *)a1 + v19 + 952) = *((_BYTE *)a1 + v19 + 712);
          *(_OWORD *)((char *)a1 + v19 + 936) = *(_OWORD *)v23;
          if (v19 == -480) {
            break;
          }
          unint64_t v24 = bswap64(v33);
          unint64_t v25 = bswap64(*((void *)v22 + 30));
          if (v24 == v25
            && (unint64_t v24 = bswap64(*((unint64_t *)&v33 + 1)), v25 = bswap64(*((void *)v22 + 31)), v24 == v25))
          {
            int v26 = 0;
          }

          else if (v24 < v25)
          {
            int v26 = -1;
          }

          else
          {
            int v26 = 1;
          }

          v19 -= 240LL;
          if ((v26 & 0x80000000) == 0)
          {
            uint64_t v27 = (uint64_t)a1 + v19 + 720;
            goto LABEL_26;
          }
        }

        uint64_t v27 = (uint64_t)a1;
LABEL_26:
        *(_OWORD *)uint64_t v27 = v33;
        *(void *)(v27 + 16) = v34;
        __int128 v28 = v22 + 504;
        unint64_t v29 = v22 + 528;
        uint64_t v30 = (uint64_t)(v22 + 560);
        p_p = v17;
        *(_OWORD *)__int128 v28 = *(_OWORD *)v17;
        *((void *)v28 + 2) = v17[2];
        char v36 = 0;
        LOBYTE(__p) = 0;
        unint64_t v13 = v18;
        *unint64_t v29 = *(_OWORD *)v18;
        *(_OWORD *)((char *)v29 + 12) = *(_OWORD *)((char *)v18 + 12);
        sub_100087EC8(v30, (uint64_t)v38);
        *(_OWORD *)uint64_t v23 = v39;
        *(_BYTE *)(v23 + 16) = v40;
        sub_100086708(v38);
        unsigned int v2 = v32;
        if (v36 < 0) {
          operator delete(__p);
        }
        if (++v11 == 8) {
          return v9 + 30 == v32;
        }
      }
    }

    int v8 = v9;
    v10 += 240LL;
    v9 += 30;
    if (v9 == v2) {
      return 1LL;
    }
  }

void sub_1000AC654( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
}

void sub_1000AC684(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t v8 = bswap64(*a4);
  unint64_t v9 = bswap64(*a3);
  if (v8 != v9 || (unint64_t v8 = bswap64(a4[1]), v9 = bswap64(a3[1]), v8 != v9))
  {
    int v10 = v8 < v9 ? -1 : 1;
    if (v10 < 0)
    {
      sub_1000AA070((__int128 *)a3, (__int128 *)a4);
      unint64_t v11 = bswap64(*a3);
      unint64_t v12 = bswap64(*a2);
      if (v11 != v12 || (unint64_t v11 = bswap64(a3[1]), v12 = bswap64(a2[1]), v11 != v12))
      {
        int v13 = v11 < v12 ? -1 : 1;
        if (v13 < 0)
        {
          sub_1000AA070((__int128 *)a2, (__int128 *)a3);
          unint64_t v14 = bswap64(*a2);
          unint64_t v15 = bswap64(*a1);
          if (v14 != v15 || (v14 = bswap64(a2[1]), unint64_t v15 = bswap64(a1[1]), v14 != v15))
          {
            if (v14 < v15) {
              int v16 = -1;
            }
            else {
              int v16 = 1;
            }
            if (v16 < 0) {
              sub_1000AA070((__int128 *)a1, (__int128 *)a2);
            }
          }
        }
      }
    }
  }

uint64_t sub_1000AC7C8(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  uint64_t v3 = a1;
  if (a1 != a2)
  {
    char v5 = *((_BYTE *)a3 + 23);
    if (v5 >= 0) {
      unint64_t v6 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
    }
    else {
      unint64_t v6 = a3[1];
    }
    if (v5 >= 0) {
      unint64_t v7 = (unsigned __int8 *)a3;
    }
    else {
      unint64_t v7 = *a3;
    }
    do
    {
      uint64_t v8 = *(unsigned __int8 *)(v3 + 23);
      if ((v8 & 0x80u) == 0LL) {
        unint64_t v9 = (unsigned __int8 *)*(unsigned __int8 *)(v3 + 23);
      }
      else {
        unint64_t v9 = *(unsigned __int8 **)(v3 + 8);
      }
      if (v9 == v6)
      {
        if ((v8 & 0x80) != 0)
        {
        }

        else
        {
          if (!*(_BYTE *)(v3 + 23)) {
            return v3;
          }
          uint64_t v10 = 0LL;
          while (*(unsigned __int8 *)(v3 + v10) == v7[v10])
          {
            if (v8 == ++v10) {
              return v3;
            }
          }
        }
      }

      v3 += 24LL;
    }

    while (v3 != a2);
    return a2;
  }

  return v3;
}

uint64_t sub_1000AC87C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000AC938((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000AC8F0(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493LL) {
    sub_1000070D4();
  }
  return operator new(56 * a2);
}

uint64_t sub_1000AC938(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v16 = a6;
  *((void *)&v16 + 1) = a7;
  __int128 v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }

  else
  {
    uint64_t v8 = a7;
    do
    {
      __int128 v9 = *(_OWORD *)(a3 - 56);
      *(void *)(v8 - 40) = *(void *)(a3 - 40);
      *(_OWORD *)(v8 - 56) = v9;
      *(void *)(a3 - 48) = 0LL;
      *(void *)(a3 - 40) = 0LL;
      *(void *)(a3 - 56) = 0LL;
      __int128 v10 = *(_OWORD *)(a3 - 32);
      *(void *)(v8 - 16) = *(void *)(a3 - 16);
      *(_OWORD *)(v8 - 32) = v10;
      *(void *)(a3 - 24) = 0LL;
      *(void *)(a3 - 16) = 0LL;
      *(void *)(a3 - 32) = 0LL;
      *(void *)(v8 - 8) = *(void *)(a3 - 8);
      v8 -= 56LL;
      v7 -= 56LL;
      a3 -= 56LL;
    }

    while (a3 != a5);
    *((void *)&v16 + 1) = v8;
    uint64_t v11 = v16;
  }

  char v14 = 1;
  sub_1000AC9FC((uint64_t)v13);
  return v11;
}

uint64_t sub_1000AC9FC(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1000ACA30((uint64_t *)a1);
  }
  return a1;
}

void sub_1000ACA30(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_1000AA690(v3, v1);
      v1 += 56LL;
    }

    while (v1 != v2);
  }

void **sub_1000ACA80(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_1000ACAB0(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 56;
    sub_1000AA690(v4, i - 56);
  }

__int128 *sub_1000ACAF4(uint64_t *a1, __int128 *a2, __int128 *a3, __int128 *a4, uint64_t a5)
{
  uint64_t v5 = a2;
  if (a5 >= 1)
  {
    uint64_t v7 = a3;
    uint64_t v11 = a1[2];
    uint64_t v9 = (uint64_t)(a1 + 2);
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v11 - v12) >> 4)) >= a5)
    {
      uint64_t v20 = v12 - (void)a2;
      if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v12 - (void)a2) >> 4)) >= a5)
      {
        int v21 = &a3[15 * a5];
      }

      else
      {
        int v21 = &a3[(uint64_t)(v12 - (void)a2) >> 4];
        a1[1] = sub_1000ACE3C(v9, v21, a4, *(void *)(v9 - 8));
        if (v20 < 1) {
          return v5;
        }
      }

      sub_1000ACCE4((uint64_t)a1, (uint64_t)v5, v12, (uint64_t)&v5[15 * a5]);
      sub_10001A8A4((uint64_t)v26, v7, v21, (uint64_t)v5);
    }

    else
    {
      uint64_t v13 = *a1;
      unint64_t v14 = a5 - 0x1111111111111111LL * ((uint64_t)(v12 - *a1) >> 4);
      if (v14 > 0x111111111111111LL) {
        sub_100007008();
      }
      unint64_t v15 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)a2 - v13) >> 4);
      unint64_t v16 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v13) >> 4);
      uint64_t v17 = 2 * v16;
      if (2 * v16 <= v14) {
        uint64_t v17 = v14;
      }
      if (v16 >= 0x88888888888888LL) {
        unint64_t v18 = 0x111111111111111LL;
      }
      else {
        unint64_t v18 = v17;
      }
      uint64_t v29 = v9;
      if (v18) {
        uint64_t v19 = (char *)sub_10001D66C(v9, v18);
      }
      else {
        uint64_t v19 = 0LL;
      }
      int v22 = &v19[240 * v15];
      v26[0] = v19;
      v26[1] = v22;
      uint64_t v27 = v22;
      __int128 v28 = &v19[240 * v18];
      uint64_t v23 = 240 * a5;
      unint64_t v24 = &v22[240 * a5];
      do
      {
        sub_1000ACEE4(v29, (uint64_t)v22, v7);
        v22 += 240;
        v7 += 15;
        v23 -= 240LL;
      }

      while (v23);
      uint64_t v27 = v24;
      uint64_t v5 = (__int128 *)sub_1000ACD8C((uint64_t)a1, v26, v5);
      sub_10001D7FC(v26);
    }
  }

  return v5;
}

void sub_1000ACCB8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000ACCE4(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    uint64_t v10 = (__int128 *)(a2 + v6 - a4);
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      sub_1000ACEE4(a1 + 16, v8, v10);
      v10 += 15;
      v8 += 240LL;
    }

    while ((unint64_t)v10 < a3);
  }

  *(void *)(a1 + 8) = v8;
  return sub_1000ACF80((uint64_t)&v12, a2, v7, v6);
}

void sub_1000ACD84(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1000ACD8C(uint64_t a1, void *a2, __int128 *a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = a1 + 16;
  sub_10001D6B0(a1 + 16, (uint64_t)a3, a3, *(void *)a1, *(__int128 **)a1, v6, v6);
  a2[1] = v8;
  a2[2] = sub_1000AD054(v7, a3, *(__int128 **)(a1 + 8), a2[2]);
  uint64_t v9 = *(void *)a1;
  *(void *)a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = a2[2];
  a2[2] = v10;
  uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_1000ACE3C(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_1000ACEE4(a1, v4, v6);
      v6 += 15;
      uint64_t v4 = v12 + 240;
      v12 += 240LL;
    }

    while (v6 != a3);
  }

  char v10 = 1;
  sub_1000619CC((uint64_t)v9);
  return v4;
}

void sub_1000ACED0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

__n128 sub_1000ACEE4(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v5 = *a3;
  *(void *)(a2 + 16) = *((void *)a3 + 2);
  *(_OWORD *)a2 = v5;
  __int128 v6 = *(__int128 *)((char *)a3 + 24);
  *(void *)(a2 + 40) = *((void *)a3 + 5);
  *(_OWORD *)(a2 + 24) = v6;
  *((void *)a3 + 4) = 0LL;
  *((void *)a3 + 5) = 0LL;
  *((void *)a3 + 3) = 0LL;
  __int128 v7 = a3[3];
  *(_OWORD *)(a2 + 60) = *(__int128 *)((char *)a3 + 60);
  *(_OWORD *)(a2 + 48) = v7;
  sub_1000865CC(a2 + 80);
  __n128 result = *(__n128 *)((char *)a3 + 216);
  *(_BYTE *)(a2 + 232) = *((_BYTE *)a3 + 232);
  *(__n128 *)(a2 + 216) = result;
  return result;
}

void sub_1000ACF64(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1000ACF80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a2)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = a3 + v7;
      uint64_t v9 = a4 + v7;
      __int128 v10 = *(_OWORD *)(a3 + v7 - 240);
      *(void *)(v9 - sub_1000A7938(v46 - 224) = *(void *)(a3 + v7 - 224);
      *(_OWORD *)(v9 - 240) = v10;
      uint64_t v11 = (void **)(a4 + v7 - 216);
      __int128 v12 = *(_OWORD *)(v8 - 216);
      *(void *)(a4 + v7 - 200) = *(void *)(v8 - 200);
      *(_OWORD *)uint64_t v11 = v12;
      *(_BYTE *)(v8 - 193) = 0;
      *(_BYTE *)(v8 - 216) = 0;
      __int128 v13 = *(_OWORD *)(v8 - 192);
      *(_OWORD *)(v9 - 180) = *(_OWORD *)(v8 - 180);
      *(_OWORD *)(v9 - 192) = v13;
      sub_100087EC8(v9 - 160, v8 - 160);
      __int128 v14 = *(_OWORD *)(v8 - 24);
      *(_BYTE *)(v9 - 8) = *(_BYTE *)(v8 - 8);
      *(_OWORD *)(v9 - 24) = v14;
      v7 -= 240LL;
    }

    while (a3 + v7 != a2);
  }

  return a3;
}

uint64_t sub_1000AD054(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    __int128 v6 = a2;
    do
    {
      sub_10001D548(a1, v4, v6);
      v6 += 15;
      uint64_t v4 = v12 + 240;
      v12 += 240LL;
    }

    while (v6 != a3);
  }

  char v10 = 1;
  sub_1000619CC((uint64_t)v9);
  return v4;
}

void sub_1000AD0E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1000AD0FC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    __int128 v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80LL;
        sub_100046498((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_1000AD180(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 80LL;
        sub_100046498((uint64_t)(a1 + 2), v3);
      }

      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

uint64_t sub_1000AD1EC(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 4);
  unint64_t v6 = v5 + 1;
  if (0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4) > v6) {
    unint64_t v6 = 0xDB6DB6DB6DB6DB6ELL * ((a1[2] - *a1) >> 4);
  }
  else {
    unint64_t v10 = v6;
  }
  unint64_t v18 = a1 + 2;
  if (v10) {
    uint64_t v11 = (char *)sub_10005057C((uint64_t)(a1 + 2), v10);
  }
  else {
    uint64_t v11 = 0LL;
  }
  __int128 v14 = v11;
  unint64_t v15 = &v11[112 * v5];
  uint64_t v17 = &v11[112 * v10];
  sub_1000AD328((uint64_t)(a1 + 2), (uint64_t)v15, a2, a3, a4);
  unint64_t v16 = v15 + 112;
  sub_100050508(a1, &v14);
  uint64_t v12 = a1[1];
  sub_1000507E4(&v14);
  return v12;
}

void sub_1000AD314(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_1000AD328(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  if (*(char *)(a3 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)__int128 __p = *(_OWORD *)a3;
    uint64_t v9 = *(void *)(a3 + 16);
  }

  sub_10004D03C(a2, (__int128 *)__p, a4, *a5, a5[1]);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1000AD3A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000AD3C4(unint64_t *a1, unint64_t *a2, uint64_t a3, char a4)
{
LABEL_1:
  unint64_t v6 = (__int128 *)a2;
  uint64_t v7 = a2 - 30;
  uint64_t v8 = a1;
  while (2)
  {
    a1 = v8;
    uint64_t v9 = (char *)v6 - (char *)v8;
    uint64_t v10 = 0xEEEEEEEEEEEEEEEFLL * (v9 >> 4);
    switch(v10)
    {
      case 0LL:
      case 1LL:
        return;
      case 2LL:
        unint64_t v101 = bswap64(*(a2 - 30));
        unint64_t v102 = bswap64(*a1);
        if (v101 != v102 || (v101 = bswap64(*(a2 - 29)), unint64_t v102 = bswap64(a1[1]), v101 != v102))
        {
          if (v101 < v102) {
            int v211 = -1;
          }
          else {
            int v211 = 1;
          }
          if (v211 < 0) {
            sub_1000AA070((__int128 *)a1, (__int128 *)a2 - 15);
          }
        }

        return;
      case 3LL:
        sub_1000AC0C8(a1, a1 + 30, v7);
        return;
      case 4LL:
        sub_1000AC684(a1, a1 + 30, a1 + 60, v7);
        return;
      case 5LL:
        sub_1000ABF1C(a1, a1 + 30, a1 + 60, a1 + 90, v7);
        return;
      default:
        if (v9 > 5759)
        {
          if (!a3)
          {
            if (a1 != (unint64_t *)v6)
            {
              int64_t v126 = (unint64_t)(v10 - 2) >> 1;
              int64_t v127 = v126;
              do
              {
                int64_t v128 = v127;
                if (v126 >= v127)
                {
                  uint64_t v129 = (2 * v127) | 1;
                  int v130 = &a1[30 * v129];
                  if (2 * v127 + 2 < v10)
                  {
                    unint64_t v131 = bswap64(*v130);
                    unint64_t v132 = bswap64(v130[30]);
                    if (v131 == v132 && (unint64_t v131 = bswap64(v130[1]), v132 = bswap64(v130[31]), v131 == v132)) {
                      int v133 = 0;
                    }
                    else {
                      int v133 = v131 < v132 ? -1 : 1;
                    }
                    if (v133 < 0)
                    {
                      v130 += 30;
                      uint64_t v129 = 2 * v127 + 2;
                    }
                  }

                  int v134 = &a1[30 * v127];
                  unint64_t v135 = bswap64(*v130);
                  unint64_t v136 = bswap64(*v134);
                  if (v135 == v136 && (v135 = bswap64(v130[1]), unint64_t v136 = bswap64(v134[1]), v135 == v136)
                    || (v135 < v136 ? (int v137 = -1) : (int v137 = 1), (v137 & 0x80000000) == 0))
                  {
                    __int128 v138 = *(_OWORD *)v134;
                    unint64_t v243 = v134[2];
                    __int128 v242 = v138;
                    __int128 v139 = &a1[30 * v128];
                    __int128 v140 = *(_OWORD *)(v139 + 3);
                    unint64_t v245 = v139[5];
                    __int128 __p = v140;
                    v139[4] = 0LL;
                    v139[5] = 0LL;
                    v139[3] = 0LL;
                    __int128 v141 = *((_OWORD *)v139 + 3);
                    *(_OWORD *)((char *)v246 + 12) = *(_OWORD *)((char *)v139 + 60);
                    v246[0] = v141;
                    sub_1000865CC(v247);
                    __int128 v142 = &a1[30 * v128];
                    __int128 v143 = *(_OWORD *)(v142 + 27);
                    char v249 = *((_BYTE *)v142 + 232);
                    __int128 v248 = v143;
                    do
                    {
                      int v144 = v130;
                      __int128 v145 = *(_OWORD *)v130;
                      v134[2] = v130[2];
                      *(_OWORD *)int v134 = v145;
                      __int128 v146 = (void **)(v134 + 3);
                      __int128 v147 = *(_OWORD *)(v144 + 3);
                      v134[5] = v144[5];
                      *(_OWORD *)__int128 v146 = v147;
                      *((_BYTE *)v144 + 47) = 0;
                      *((_BYTE *)v144 + 24) = 0;
                      __int128 v148 = *((_OWORD *)v144 + 3);
                      *(_OWORD *)((char *)v134 + 60) = *(_OWORD *)((char *)v144 + 60);
                      *((_OWORD *)v134 + 3) = v148;
                      sub_100087EC8((uint64_t)(v134 + 10), (uint64_t)(v144 + 10));
                      __int128 v149 = *(_OWORD *)(v144 + 27);
                      *((_BYTE *)v134 + 232) = *((_BYTE *)v144 + 232);
                      *(_OWORD *)(v134 + 27) = v149;
                      if (v126 < v129) {
                        break;
                      }
                      int v130 = &a1[30 * ((2 * v129) | 1)];
                      if (2 * v129 + 2 >= v10)
                      {
                        uint64_t v129 = (2 * v129) | 1;
                      }

                      else
                      {
                        unint64_t v150 = bswap64(*v130);
                        unint64_t v151 = bswap64(v130[30]);
                        if (v150 == v151 && (unint64_t v150 = bswap64(v130[1]), v151 = bswap64(v130[31]), v150 == v151)) {
                          int v152 = 0;
                        }
                        else {
                          int v152 = v150 < v151 ? -1 : 1;
                        }
                        if (v152 >= 0)
                        {
                          uint64_t v129 = (2 * v129) | 1;
                        }

                        else
                        {
                          v130 += 30;
                          uint64_t v129 = 2 * v129 + 2;
                        }
                      }

                      unint64_t v153 = bswap64(*v130);
                      unint64_t v154 = bswap64(v242);
                      if (v153 == v154
                        && (unint64_t v153 = bswap64(v130[1]), v154 = bswap64(*((unint64_t *)&v242 + 1)), v153 == v154))
                      {
                        int v155 = 0;
                      }

                      else
                      {
                        int v155 = v153 < v154 ? -1 : 1;
                      }

                      int v134 = v144;
                    }

                    while ((v155 & 0x80000000) == 0);
                    int v156 = (void **)(v144 + 3);
                    __int128 v157 = v242;
                    v144[2] = v243;
                    *(_OWORD *)int v144 = v157;
                    __int128 v158 = __p;
                    v144[5] = v245;
                    *(_OWORD *)int v156 = v158;
                    HIBYTE(v245) = 0;
                    LOBYTE(__p) = 0;
                    __int128 v159 = *(_OWORD *)((char *)v246 + 12);
                    *((_OWORD *)v144 + 3) = v246[0];
                    *(_OWORD *)((char *)v144 + 60) = v159;
                    sub_100087EC8((uint64_t)(v144 + 10), (uint64_t)v247);
                    __int128 v160 = v248;
                    *((_BYTE *)v144 + 232) = v249;
                    *(_OWORD *)(v144 + 27) = v160;
                    sub_100086708(v247);
                    if (SHIBYTE(v245) < 0) {
                      operator delete((void *)__p);
                    }
                  }
                }

                int64_t v127 = v128 - 1;
              }

              while (v128);
              int64_t v161 = v9 / 0xF0uLL;
              v230 = (__int128 *)(a1 + 3);
              do
              {
                unint64_t v235 = a1[2];
                __int128 v234 = *(_OWORD *)a1;
                __int128 v236 = *v230;
                unint64_t v237 = a1[5];
                a1[4] = 0LL;
                a1[5] = 0LL;
                *(void *)v230 = 0LL;
                *(_OWORD *)v238 = *((_OWORD *)a1 + 3);
                *(_OWORD *)&v238[12] = *(_OWORD *)((char *)a1 + 60);
                sub_1000865CC(v239);
                uint64_t v162 = 0LL;
                __int128 v163 = *(_OWORD *)(a1 + 27);
                char v241 = *((_BYTE *)a1 + 232);
                __int128 v240 = v163;
                uint64_t v164 = (uint64_t)a1;
                do
                {
                  uint64_t v165 = v164 + 240 * v162 + 240;
                  uint64_t v166 = 2 * v162;
                  uint64_t v162 = (2 * v162) | 1;
                  if (v166 + 2 < v161)
                  {
                    unint64_t v167 = bswap64(*(void *)v165);
                    unint64_t v168 = bswap64(*(void *)(v165 + 240));
                    if (v167 == v168
                      && (v167 = bswap64(*(void *)(v165 + 8)), unint64_t v168 = bswap64(*(void *)(v165 + 248)), v167 == v168))
                    {
                      int v169 = 0;
                    }

                    else
                    {
                      int v169 = v167 < v168 ? -1 : 1;
                    }

                    if (v169 < 0)
                    {
                      v165 += 240LL;
                      uint64_t v162 = v166 + 2;
                    }
                  }

                  __int128 v170 = *(_OWORD *)v165;
                  *(void *)(v164 + 16) = *(void *)(v165 + 16);
                  *(_OWORD *)uint64_t v164 = v170;
                  uint64_t v171 = (void **)(v164 + 24);
                  __int128 v172 = *(_OWORD *)(v165 + 24);
                  *(void *)(v164 + 40) = *(void *)(v165 + 40);
                  *(_OWORD *)uint64_t v171 = v172;
                  *(_BYTE *)(v165 + 47) = 0;
                  *(_BYTE *)(v165 + 24) = 0;
                  __int128 v173 = *(_OWORD *)(v165 + 48);
                  *(_OWORD *)(v164 + 60) = *(_OWORD *)(v165 + 60);
                  *(_OWORD *)(v164 + 48) = v173;
                  sub_100087EC8(v164 + 80, v165 + 80);
                  __int128 v174 = *(_OWORD *)(v165 + 216);
                  *(_BYTE *)(v164 + 232) = *(_BYTE *)(v165 + 232);
                  *(_OWORD *)(v164 + 216) = v174;
                  uint64_t v164 = v165;
                }

                while (v162 <= (uint64_t)((unint64_t)(v161 - 2) >> 1));
                unsigned int v175 = (void **)(v165 + 24);
                int v176 = (__int128 *)(v165 + 48);
                v232 = (__int128 *)(v165 + 216);
                if ((unint64_t *)v165 == a2 - 30)
                {
                  *(void *)(v165 + 16) = v235;
                  *(_OWORD *)uint64_t v165 = v234;
                  *(void *)(v165 + 40) = v237;
                  *(_OWORD *)unsigned int v175 = v236;
                  *(_OWORD *)(v165 + 60) = *(_OWORD *)&v238[12];
                  *int v176 = *(_OWORD *)v238;
                  sub_100087EC8(v165 + 80, (uint64_t)v239);
                  __int128 v190 = v240;
                  *(_BYTE *)(v165 + 232) = v241;
                  __int128 *v232 = v190;
                }

                else
                {
                  __int128 v177 = *((_OWORD *)a2 - 15);
                  *(void *)(v165 + 16) = *(a2 - 28);
                  *(_OWORD *)uint64_t v165 = v177;
                  __int128 v178 = *(_OWORD *)(a2 - 27);
                  *(void *)(v165 + 40) = *(a2 - 25);
                  *(_OWORD *)unsigned int v175 = v178;
                  *((_BYTE *)a2 - 193) = 0;
                  *((_BYTE *)a2 - 216) = 0;
                  __int128 v179 = *((_OWORD *)a2 - 12);
                  *(_OWORD *)(v165 + 60) = *(_OWORD *)((char *)a2 - 180);
                  *int v176 = v179;
                  sub_100087EC8(v165 + 80, (uint64_t)(a2 - 20));
                  uint64_t v180 = (void **)(a2 - 27);
                  __int128 v181 = *(_OWORD *)(a2 - 3);
                  *(_BYTE *)(v165 + 232) = *((_BYTE *)a2 - 8);
                  __int128 *v232 = v181;
                  *(a2 - 28) = v235;
                  *((_OWORD *)a2 - 15) = v234;
                  uint64_t v182 = a2 - 24;
                  *(a2 - 25) = v237;
                  *(_OWORD *)uint64_t v180 = v236;
                  *(_OWORD *)((char *)v182 + 12) = *(_OWORD *)&v238[12];
                  *(_OWORD *)uint64_t v182 = *(_OWORD *)v238;
                  sub_100087EC8((uint64_t)(a2 - 20), (uint64_t)v239);
                  v183 = a2 - 3;
                  __int128 v184 = v240;
                  *((_BYTE *)v183 + 16) = v241;
                  *(_OWORD *)v183 = v184;
                  uint64_t v185 = v165 - (void)a1 + 240;
                  if (v185 >= 241)
                  {
                    unint64_t v186 = (v185 / 0xF0uLL - 2) >> 1;
                    __int16 v187 = &a1[30 * v186];
                    unint64_t v188 = bswap64(*v187);
                    unint64_t v189 = bswap64(*(void *)v165);
                    if (v188 != v189 || (unint64_t v188 = bswap64(v187[1]), v189 = bswap64(*(void *)(v165 + 8)), v188 != v189))
                    {
                      int v191 = v188 < v189 ? -1 : 1;
                      if (v191 < 0)
                      {
                        __int128 v192 = *(_OWORD *)v165;
                        unint64_t v243 = *(void *)(v165 + 16);
                        __int128 v242 = v192;
                        __int128 v193 = *(_OWORD *)v175;
                        unint64_t v245 = *(void *)(v165 + 40);
                        __int128 __p = v193;
                        *(void *)(v165 + 32) = 0LL;
                        *(void *)(v165 + 40) = 0LL;
                        *unsigned int v175 = 0LL;
                        __int128 v194 = *v176;
                        *(_OWORD *)((char *)v246 + 12) = *(_OWORD *)(v165 + 60);
                        v246[0] = v194;
                        sub_1000865CC(v247);
                        __int128 v195 = *v232;
                        char v249 = *(_BYTE *)(v165 + 232);
                        __int128 v248 = v195;
                        do
                        {
                          uint64_t v196 = (uint64_t)v187;
                          __int128 v197 = *(_OWORD *)v187;
                          *(void *)(v165 + 16) = v187[2];
                          *(_OWORD *)uint64_t v165 = v197;
                          __int16 v198 = (void **)(v165 + 24);
                          __int128 v199 = *(_OWORD *)(v187 + 3);
                          *(void *)(v165 + 40) = v187[5];
                          *(_OWORD *)__int16 v198 = v199;
                          *((_BYTE *)v187 + 47) = 0;
                          *((_BYTE *)v187 + 24) = 0;
                          __int128 v200 = *((_OWORD *)v187 + 3);
                          *(_OWORD *)(v165 + 60) = *(_OWORD *)((char *)v187 + 60);
                          *(_OWORD *)(v165 + 48) = v200;
                          sub_100087EC8(v165 + 80, (uint64_t)(v187 + 10));
                          __int128 v201 = *(_OWORD *)(v187 + 27);
                          *(_BYTE *)(v165 + 232) = *((_BYTE *)v187 + 232);
                          *(_OWORD *)(v165 + 216) = v201;
                          if (!v186) {
                            break;
                          }
                          unint64_t v186 = (v186 - 1) >> 1;
                          __int16 v187 = &a1[30 * v186];
                          unint64_t v202 = bswap64(*v187);
                          unint64_t v203 = bswap64(v242);
                          if (v202 == v203
                            && (unint64_t v202 = bswap64(v187[1]), v203 = bswap64(*((unint64_t *)&v242 + 1)), v202 == v203))
                          {
                            int v204 = 0;
                          }

                          else
                          {
                            int v204 = v202 < v203 ? -1 : 1;
                          }

                          uint64_t v165 = v196;
                        }

                        while (v204 < 0);
                        int v205 = (void **)(v196 + 24);
                        __int128 v206 = v242;
                        *(void *)(v196 + 16) = v243;
                        *(_OWORD *)uint64_t v196 = v206;
                        __int128 v207 = __p;
                        *(void *)(v196 + 40) = v245;
                        *(_OWORD *)int v205 = v207;
                        HIBYTE(v245) = 0;
                        LOBYTE(__p) = 0;
                        __int128 v208 = *(_OWORD *)((char *)v246 + 12);
                        *(_OWORD *)(v196 + 48) = v246[0];
                        *(_OWORD *)(v196 + 60) = v208;
                        sub_100087EC8(v196 + 80, (uint64_t)v247);
                        __int128 v209 = v248;
                        *(_BYTE *)(v196 + 232) = v249;
                        *(_OWORD *)(v196 + 216) = v209;
                        sub_100086708(v247);
                        if (SHIBYTE(v245) < 0) {
                          operator delete((void *)__p);
                        }
                      }
                    }
                  }
                }

                sub_100086708(v239);
                a2 -= 30;
              }

              while (v161-- > 2);
            }

            return;
          }

          unint64_t v11 = (unint64_t)v10 >> 1;
          uint64_t v12 = &a1[30 * ((unint64_t)v10 >> 1)];
          if ((unint64_t)v9 < 0x7801)
          {
            sub_1000AC0C8(v12, a1, v7);
          }

          else
          {
            sub_1000AC0C8(a1, v12, v7);
            sub_1000AC0C8(a1 + 30, &a1[30 * v11 - 30], a2 - 60);
            sub_1000AC0C8(a1 + 60, &a1[30 * v11 + 30], a2 - 90);
            sub_1000AC0C8(&a1[30 * v11 - 30], v12, &a1[30 * v11 + 30]);
            sub_1000AA070((__int128 *)a1, (__int128 *)v12);
          }

          --a3;
          if ((a4 & 1) == 0)
          {
            if ((v13 = bswap64(*(a1 - 30)), unint64_t v14 = bswap64(*a1), v13 == v14)
              && (v13 = bswap64(*(a1 - 29)), unint64_t v14 = bswap64(a1[1]), v13 == v14)
              || (v13 < v14 ? (int v22 = -1) : (int v22 = 1), (v22 & 0x80000000) == 0))
            {
              __int128 v15 = *(_OWORD *)a1;
              unint64_t v243 = a1[2];
              __int128 v242 = v15;
              unint64_t v16 = a1[5];
              __int128 __p = *(_OWORD *)(a1 + 3);
              unint64_t v245 = v16;
              a1[4] = 0LL;
              a1[5] = 0LL;
              a1[3] = 0LL;
              __int128 v17 = *(_OWORD *)((char *)a1 + 60);
              v246[0] = *((_OWORD *)a1 + 3);
              *(_OWORD *)((char *)v246 + 12) = v17;
              sub_1000865CC(v247);
              __int128 v18 = *(_OWORD *)(a1 + 27);
              char v249 = *((_BYTE *)a1 + 232);
              __int128 v248 = v18;
              unint64_t v19 = bswap64(v242);
              unint64_t v20 = bswap64(*v7);
              if (v19 == v20
                && (unint64_t v19 = bswap64(*((unint64_t *)&v242 + 1)), v20 = bswap64(*(a2 - 29)), v19 == v20))
              {
                int v21 = 0;
              }

              else if (v19 < v20)
              {
                int v21 = -1;
              }

              else
              {
                int v21 = 1;
              }

              if (v21 < 0)
              {
                unsigned __int32 v69 = a1;
                uint64_t v8 = a1;
                do
                {
                  unint64_t v70 = v8[30];
                  v8 += 30;
                  unint64_t v71 = bswap64(v242);
                  unint64_t v72 = bswap64(v70);
                  if (v71 == v72
                    && (unint64_t v71 = bswap64(*((unint64_t *)&v242 + 1)), v72 = bswap64(v69[31]), v71 == v72))
                  {
                    int v73 = 0;
                  }

                  else if (v71 < v72)
                  {
                    int v73 = -1;
                  }

                  else
                  {
                    int v73 = 1;
                  }

                  unsigned __int32 v69 = v8;
                }

                while ((v73 & 0x80000000) == 0);
              }

              else
              {
                uint64_t v65 = a1 + 30;
                do
                {
                  uint64_t v8 = v65;
                  unint64_t v66 = bswap64(v242);
                  unint64_t v67 = bswap64(*v8);
                  else {
                    int v68 = v66 < v67 ? -1 : 1;
                  }
                  uint64_t v65 = v8 + 30;
                }

                while ((v68 & 0x80000000) == 0);
              }

              uint64_t v74 = v6;
              if (v8 < (unint64_t *)v6)
              {
                unint64_t v75 = v6;
                uint64_t v74 = v6;
                do
                {
                  unint64_t v76 = *((void *)v74 - 30);
                  v74 -= 15;
                  unint64_t v77 = bswap64(v242);
                  unint64_t v78 = bswap64(v76);
                  if (v77 == v78
                    && (unint64_t v77 = bswap64(*((unint64_t *)&v242 + 1)), v78 = bswap64(*((void *)v75 - 29)),
                                                                         v77 == v78))
                  {
                    int v79 = 0;
                  }

                  else if (v77 < v78)
                  {
                    int v79 = -1;
                  }

                  else
                  {
                    int v79 = 1;
                  }

                  unint64_t v75 = v74;
                }

                while (v79 < 0);
              }

              while (v8 < (unint64_t *)v74)
              {
                sub_1000AA070((__int128 *)v8, v74);
                unint64_t v80 = v8;
                do
                {
                  unint64_t v81 = v8[30];
                  v8 += 30;
                  unint64_t v82 = bswap64(v242);
                  unint64_t v83 = bswap64(v81);
                  if (v82 == v83
                    && (v82 = bswap64(*((unint64_t *)&v242 + 1)), unint64_t v83 = bswap64(v80[31]), v82 == v83))
                  {
                    int v84 = 0;
                  }

                  else if (v82 < v83)
                  {
                    int v84 = -1;
                  }

                  else
                  {
                    int v84 = 1;
                  }

                  unint64_t v80 = v8;
                }

                while ((v84 & 0x80000000) == 0);
                unint64_t v85 = v74;
                do
                {
                  unint64_t v86 = *((void *)v74 - 30);
                  v74 -= 15;
                  unint64_t v87 = bswap64(v242);
                  unint64_t v88 = bswap64(v86);
                  if (v87 == v88
                    && (unint64_t v87 = bswap64(*((unint64_t *)&v242 + 1)), v88 = bswap64(*((void *)v85 - 29)),
                                                                         v87 == v88))
                  {
                    int v89 = 0;
                  }

                  else if (v87 < v88)
                  {
                    int v89 = -1;
                  }

                  else
                  {
                    int v89 = 1;
                  }

                  unint64_t v85 = v74;
                }

                while (v89 < 0);
              }

              int v90 = v8 - 30;
              if (v8 - 30 != a1)
              {
                uint64_t v91 = (void **)(a1 + 3);
                __int128 v92 = *(_OWORD *)v90;
                a1[2] = *(v8 - 28);
                *(_OWORD *)a1 = v92;
                __int128 v93 = *(_OWORD *)(v8 - 27);
                a1[5] = *(v8 - 25);
                *(_OWORD *)uint64_t v91 = v93;
                *((_BYTE *)v8 - 193) = 0;
                *((_BYTE *)v8 - 216) = 0;
                __int128 v94 = *((_OWORD *)v8 - 12);
                *(_OWORD *)((char *)a1 + 60) = *(_OWORD *)((char *)v8 - 180);
                *((_OWORD *)a1 + 3) = v94;
                sub_100087EC8((uint64_t)(a1 + 10), (uint64_t)(v8 - 20));
                __int128 v95 = *(_OWORD *)(v8 - 3);
                *((_BYTE *)a1 + 232) = *((_BYTE *)v8 - 8);
                *(_OWORD *)(a1 + 27) = v95;
              }

              __int128 v96 = v242;
              *(v8 - 28) = v243;
              *(_OWORD *)int v90 = v96;
              uint64_t v97 = (void **)(v8 - 27);
              __int128 v98 = __p;
              *(v8 - 25) = v245;
              *(_OWORD *)uint64_t v97 = v98;
              HIBYTE(v245) = 0;
              LOBYTE(__p) = 0;
              __int128 v99 = v246[0];
              *(_OWORD *)((char *)v8 - 180) = *(_OWORD *)((char *)v246 + 12);
              *((_OWORD *)v8 - 12) = v99;
              sub_100087EC8((uint64_t)(v8 - 20), (uint64_t)v247);
              __int128 v100 = v248;
              *((_BYTE *)v8 - 8) = v249;
              *(_OWORD *)(v8 - 3) = v100;
              sub_100086708(v247);
              if (SHIBYTE(v245) < 0) {
                operator delete((void *)__p);
              }
              goto LABEL_78;
            }
          }

          __int128 v23 = *(_OWORD *)a1;
          unint64_t v243 = a1[2];
          __int128 v242 = v23;
          unint64_t v24 = a1[5];
          __int128 __p = *(_OWORD *)(a1 + 3);
          unint64_t v245 = v24;
          a1[4] = 0LL;
          a1[5] = 0LL;
          a1[3] = 0LL;
          __int128 v25 = *(_OWORD *)((char *)a1 + 60);
          v246[0] = *((_OWORD *)a1 + 3);
          *(_OWORD *)((char *)v246 + 12) = v25;
          sub_1000865CC(v247);
          uint64_t v26 = 0LL;
          uint64_t v27 = (void **)(a1 + 3);
          __int128 v28 = *(_OWORD *)(a1 + 27);
          char v249 = *((_BYTE *)a1 + 232);
          __int128 v248 = v28;
          do
          {
            unint64_t v29 = bswap64(a1[v26 + 30]);
            unint64_t v30 = bswap64(v242);
            if (v29 == v30
              && (unint64_t v29 = bswap64(a1[v26 + 31]), v30 = bswap64(*((unint64_t *)&v242 + 1)), v29 == v30))
            {
              int v31 = 0;
            }

            else if (v29 < v30)
            {
              int v31 = -1;
            }

            else
            {
              int v31 = 1;
            }

            v26 += 30LL;
          }

          while (v31 < 0);
          __int16 v32 = &a1[v26];
          __int128 v33 = v6;
          if (v26 == 30)
          {
            std::string v38 = a2;
            while (v32 < v38)
            {
              unint64_t v34 = (__int128 *)(v38 - 30);
              unint64_t v39 = bswap64(*(v38 - 30));
              unint64_t v40 = bswap64(v242);
              if (v39 == v40
                && (unint64_t v39 = bswap64(*(v38 - 29)), v40 = bswap64(*((unint64_t *)&v242 + 1)), v39 == v40))
              {
                int v41 = 0;
              }

              else if (v39 < v40)
              {
                int v41 = -1;
              }

              else
              {
                int v41 = 1;
              }

              v38 -= 30;
              if (v41 < 0) {
                goto LABEL_46;
              }
            }

            unint64_t v34 = (__int128 *)v38;
          }

          else
          {
            do
            {
              unint64_t v34 = v33 - 15;
              unint64_t v35 = bswap64(*((void *)v33 - 30));
              unint64_t v36 = bswap64(v242);
              if (v35 == v36
                && (v35 = bswap64(*((void *)v33 - 29)), unint64_t v36 = bswap64(*((unint64_t *)&v242 + 1)), v35 == v36))
              {
                int v37 = 0;
              }

              else if (v35 < v36)
              {
                int v37 = -1;
              }

              else
              {
                int v37 = 1;
              }

              v33 -= 15;
            }

            while ((v37 & 0x80000000) == 0);
          }

void sub_1000AEB38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *__p,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a63 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1000AEC0C(unint64_t *a1, unint64_t *a2)
{
  uint64_t v2 = a2;
  unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * (((char *)a2 - (char *)a1) >> 4);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unint64_t v6 = bswap64(*(a2 - 30));
      unint64_t v7 = bswap64(*a1);
      if (v6 != v7 || (v6 = bswap64(*(a2 - 29)), unint64_t v7 = bswap64(a1[1]), v6 != v7))
      {
        int v31 = v6 < v7 ? -1 : 1;
        if (v31 < 0)
        {
          sub_1000AA070((__int128 *)a1, (__int128 *)a2 - 15);
          return 1LL;
        }
      }

      return result;
    case 3uLL:
      sub_1000AC0C8(a1, a1 + 30, a2 - 30);
      return 1LL;
    case 4uLL:
      sub_1000AC684(a1, a1 + 30, a1 + 60, a2 - 30);
      return 1LL;
    case 5uLL:
      sub_1000ABF1C(a1, a1 + 30, a1 + 60, a1 + 90, a2 - 30);
      return 1LL;
    default:
      uint64_t v8 = a1 + 60;
      sub_1000AC0C8(a1, a1 + 30, a1 + 60);
      uint64_t v9 = a1 + 90;
      if (a1 + 90 == v2) {
        return 1LL;
      }
      uint64_t v10 = 0LL;
      int v11 = 0;
      p_p = &__p;
      unint64_t v13 = &v37;
      __int16 v32 = v2;
      break;
  }

  while (1)
  {
    unint64_t v14 = bswap64(*v9);
    unint64_t v15 = bswap64(*v8);
    if (v14 != v15 || (v14 = bswap64(v9[1]), unint64_t v15 = bswap64(v8[1]), v14 != v15))
    {
      int v16 = v14 < v15 ? -1 : 1;
      if (v16 < 0)
      {
        __int128 v33 = *(_OWORD *)v9;
        unint64_t v34 = v9[2];
        *(_OWORD *)p_p = *(_OWORD *)(v9 + 3);
        __int128 v17 = p_p;
        p_p[2] = (void *)v9[5];
        void v9[3] = 0LL;
        void v9[4] = 0LL;
        v9[5] = 0LL;
        *(_OWORD *)unint64_t v13 = *((_OWORD *)v9 + 3);
        __int128 v18 = v13;
        *(_OWORD *)((char *)v13 + 12) = *(_OWORD *)((char *)v9 + 60);
        sub_1000865CC(v38);
        __int128 v39 = *(_OWORD *)(v9 + 27);
        char v40 = *((_BYTE *)v9 + 232);
        uint64_t v19 = v10;
        while (1)
        {
          unint64_t v20 = (char *)a1 + v19;
          *((_OWORD *)v20 + 45) = *(_OWORD *)((char *)a1 + v19 + 480);
          *((void *)v20 + 92) = *(unint64_t *)((char *)a1 + v19 + 496);
          int v21 = (void **)((char *)a1 + v19 + 744);
          *(unint64_t *)((char *)a1 + v19 + 760) = *((void *)v20 + 65);
          *(_OWORD *)int v21 = *(_OWORD *)(v20 + 504);
          v20[527] = 0;
          v20[504] = 0;
          *((_OWORD *)v20 + 48) = *((_OWORD *)v20 + 33);
          *(_OWORD *)(v20 + 780) = *(_OWORD *)(v20 + 540);
          sub_100087EC8((uint64_t)(v20 + 800), (uint64_t)(v20 + 560));
          int v22 = (char *)a1 + v19;
          uint64_t v23 = (uint64_t)a1 + v19 + 696;
          *((_BYTE *)a1 + v19 + 952) = *((_BYTE *)a1 + v19 + 712);
          *(_OWORD *)((char *)a1 + v19 + 936) = *(_OWORD *)v23;
          if (v19 == -480) {
            break;
          }
          unint64_t v24 = bswap64(v33);
          unint64_t v25 = bswap64(*((void *)v22 + 30));
          if (v24 == v25
            && (unint64_t v24 = bswap64(*((unint64_t *)&v33 + 1)), v25 = bswap64(*((void *)v22 + 31)), v24 == v25))
          {
            int v26 = 0;
          }

          else if (v24 < v25)
          {
            int v26 = -1;
          }

          else
          {
            int v26 = 1;
          }

          v19 -= 240LL;
          if ((v26 & 0x80000000) == 0)
          {
            uint64_t v27 = (uint64_t)a1 + v19 + 720;
            goto LABEL_26;
          }
        }

        uint64_t v27 = (uint64_t)a1;
LABEL_26:
        *(_OWORD *)uint64_t v27 = v33;
        *(void *)(v27 + 16) = v34;
        __int128 v28 = v22 + 504;
        unint64_t v29 = v22 + 528;
        uint64_t v30 = (uint64_t)(v22 + 560);
        p_p = v17;
        *(_OWORD *)__int128 v28 = *(_OWORD *)v17;
        *((void *)v28 + 2) = v17[2];
        char v36 = 0;
        LOBYTE(__p) = 0;
        unint64_t v13 = v18;
        *unint64_t v29 = *(_OWORD *)v18;
        *(_OWORD *)((char *)v29 + 12) = *(_OWORD *)((char *)v18 + 12);
        sub_100087EC8(v30, (uint64_t)v38);
        *(_OWORD *)uint64_t v23 = v39;
        *(_BYTE *)(v23 + 16) = v40;
        sub_100086708(v38);
        uint64_t v2 = v32;
        if (v36 < 0) {
          operator delete(__p);
        }
        if (++v11 == 8) {
          return v9 + 30 == v32;
        }
      }
    }

    uint64_t v8 = v9;
    v10 += 240LL;
    v9 += 30;
    if (v9 == v2) {
      return 1LL;
    }
  }

void sub_1000AF004( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
}

void *sub_1000AF034(void *a1, _OWORD *a2)
{
  return sub_1000194A4(a1, v4);
}

void sub_1000AF06C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

_OWORD *sub_1000AF088@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 16;
  BOOL result = operator new(0x30uLL);
  unint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v5;
  *(void *)BOOL result = 0LL;
  __int128 v9 = a2[1];
  result[1] = *a2;
  result[2] = v9;
  *(_BYTE *)(a3 + 16) = 1;
  do
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)result + v8++ + 16);
  while (v8 != 16);
  *((void *)result + 1) = v7;
  return result;
}

char *sub_1000AF110(uint64_t a1, char *__src, void *a3, void *a4, uint64_t a5)
{
  uint64_t v5 = __src;
  if (a5 >= 1)
  {
    unint64_t v7 = a3;
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v9 = a1 + 16;
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if (a5 <= (uint64_t)(v11 - v12) >> 4)
    {
      unint64_t v19 = a5 + 1;
      unint64_t v20 = a3;
      do
      {
        unint64_t v20 = (void *)*v20;
        --v19;
      }

      while (v19 > 1);
      uint64_t v21 = (uint64_t)(v12 - (void)__src) >> 4;
      if (v21 >= a5)
      {
        uint64_t v23 = *(char **)(v9 - 8);
        uint64_t v21 = a5;
      }

      else
      {
        if ((uint64_t)(v12 - (void)__src) < 1)
        {
          unint64_t v20 = a3;
        }

        else
        {
          unint64_t v22 = v21 + 1;
          unint64_t v20 = a3;
          do
          {
            unint64_t v20 = (void *)*v20;
            --v22;
          }

          while (v22 > 1);
        }

        uint64_t v23 = *(char **)(v9 - 8);
        if (v20 != a4)
        {
          uint64_t v27 = v20;
          __int128 v28 = *(_OWORD **)(v9 - 8);
          do
          {
            *v28++ = *((_OWORD *)v27 + 1);
            uint64_t v27 = (void *)*v27;
            v23 += 16;
          }

          while (v27 != a4);
        }

        *(void *)(a1 + 8) = v23;
      }

      if (v21 >= 1)
      {
        unint64_t v29 = &__src[16 * a5];
        uint64_t v30 = &v23[-16 * a5];
        int v31 = v23;
        if ((unint64_t)v30 < v12)
        {
          int v31 = v23;
          do
          {
            __int128 v32 = *(_OWORD *)v30;
            v30 += 16;
            *(_OWORD *)int v31 = v32;
            v31 += 16;
          }

          while ((unint64_t)v30 < v12);
        }

        *(void *)(a1 + 8) = v31;
        if (v23 != v29) {
          memmove(&v23[-16 * ((v23 - v29) >> 4)], __src, v23 - v29);
        }
        if (v20 != v7)
        {
          __int128 v33 = v5;
          do
          {
            *(_OWORD *)__int128 v33 = *((_OWORD *)v7 + 1);
            v33 += 16;
            unint64_t v7 = (void *)*v7;
          }

          while (v7 != v20);
        }
      }
    }

    else
    {
      unint64_t v13 = *(_BYTE **)a1;
      unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 4);
      if (v14 >> 60) {
        sub_100007008();
      }
      uint64_t v15 = (__src - v13) >> 4;
      uint64_t v16 = v10 - (void)v13;
      if (v16 >> 3 > v14) {
        unint64_t v14 = v16 >> 3;
      }
      else {
        unint64_t v17 = v14;
      }
      uint64_t v39 = v9;
      if (v17) {
        __int128 v18 = (char *)sub_100037038(v9, v17);
      }
      else {
        __int128 v18 = 0LL;
      }
      unint64_t v24 = &v18[16 * v15];
      __int128 __p = v18;
      char v36 = v24;
      std::string v38 = &v18[16 * v17];
      uint64_t v25 = 16 * a5;
      int v26 = &v24[16 * a5];
      do
      {
        *(_OWORD *)unint64_t v24 = *((_OWORD *)v7 + 1);
        v24 += 16;
        unint64_t v7 = (void *)*v7;
        v25 -= 16LL;
      }

      while (v25);
      uint64_t v37 = v26;
      uint64_t v5 = (char *)sub_10009CE94((void **)a1, (uint64_t)&__p, v5);
      if (v37 != v36) {
        v37 += (v36 - v37 + 15) & 0xFFFFFFFFFFFFFFF0LL;
      }
      if (__p) {
        operator delete(__p);
      }
    }
  }

  return v5;
}

void sub_1000AF338( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000AF370(void *a1, void *a2)
{
  BOOL result = sub_10001A7B8(a1, a2);
  if (result)
  {
    unint64_t v4 = result;
    do
    {
      unint64_t v4 = (void *)*v4;
      if (!v4) {
        break;
      }
    }

    while (v4[2] == *a2 && v4[3] == a2[1]);
  }

  return result;
}

void sub_1000AF3BC(uint64_t a1, __n128 *a2, uint64_t a3, char a4)
{
LABEL_1:
  unint64_t v8 = a1;
  while (2)
  {
    a1 = v8;
    uint64_t v9 = (uint64_t)a2 - v8;
    unint64_t v10 = (uint64_t)((uint64_t)a2 - v8) >> 5;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (*(double *)(v8 + 24) < a2[-1].n128_f64[1])
        {
          __n128 v105 = *(__n128 *)v8;
          __n128 v114 = *(__n128 *)(v8 + 16);
          __n128 v42 = a2[-1];
          *(__n128 *)unint64_t v8 = a2[-2];
          *(__n128 *)(v8 + 16) = v42;
          a2[-2] = v105;
          a2[-1] = v114;
        }

        return;
      case 3uLL:
        sub_1000AFBE8((double *)v8, (double *)(v8 + 32), a2[-2].n128_f64);
        return;
      case 4uLL:
        sub_1000AFF14((__n128 *)v8, (__n128 *)(v8 + 32), (__n128 *)(v8 + 64), a2 - 2);
        return;
      case 5uLL:
        __int128 v43 = (__n128 *)(v8 + 32);
        unint64_t v44 = (__n128 *)(v8 + 64);
        unint64_t v45 = (__n128 *)(v8 + 96);
        sub_1000AFF14((__n128 *)v8, (__n128 *)(v8 + 32), (__n128 *)(v8 + 64), (__n128 *)(v8 + 96));
        if (*(double *)(v8 + 120) < a2[-1].n128_f64[1])
        {
          __n128 v46 = *v45;
          __n128 v115 = *(__n128 *)(v8 + 112);
          __n128 v47 = a2[-1];
          __n128 *v45 = a2[-2];
          *(__n128 *)(v8 + 112) = v47;
          a2[-2] = v46;
          a2[-1] = v115;
          if (*(double *)(v8 + 88) < *(double *)(v8 + 120))
          {
            __n128 v49 = *v44;
            __int128 v48 = *(_OWORD *)(v8 + 80);
            __int128 v50 = *(_OWORD *)(v8 + 112);
            __n128 *v44 = *v45;
            *(_OWORD *)(v8 + 80) = v50;
            __n128 *v45 = v49;
            *(_OWORD *)(v8 + 112) = v48;
            if (*(double *)(v8 + 56) < *(double *)(v8 + 88))
            {
              __n128 v52 = *v43;
              __int128 v51 = *(_OWORD *)(v8 + 48);
              __int128 v53 = *(_OWORD *)(v8 + 80);
              __n128 *v43 = *v44;
              *(_OWORD *)(v8 + 48) = v53;
              __n128 *v44 = v52;
              *(_OWORD *)(v8 + 80) = v51;
              if (*(double *)(v8 + 24) < *(double *)(v8 + 56))
              {
                __n128 v106 = *(__n128 *)v8;
                __int128 v116 = *(_OWORD *)(v8 + 16);
                __int128 v54 = *(_OWORD *)(v8 + 48);
                *(__n128 *)unint64_t v8 = *v43;
                *(_OWORD *)(v8 + 16) = v54;
                __n128 *v43 = v106;
                *(_OWORD *)(v8 + 48) = v116;
              }
            }
          }
        }

        return;
      default:
        if (v9 <= 767)
        {
          __int128 v55 = (__n128 *)(v8 + 32);
          BOOL v57 = (__n128 *)v8 == a2 || v55 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v57)
            {
              uint64_t v58 = 0LL;
              unint64_t v59 = v8;
              do
              {
                double v60 = *(double *)(v59 + 24);
                double v61 = *(double *)(v59 + 56);
                unint64_t v59 = (unint64_t)v55;
                if (v60 < v61)
                {
                  uint64_t v117 = v55[1].n128_i64[0];
                  __n128 v107 = *v55;
                  uint64_t v62 = v58;
                  while (1)
                  {
                    uint64_t v63 = v8 + v62;
                    __int128 v64 = *(_OWORD *)(v8 + v62 + 16);
                    *(_OWORD *)(v63 + 32) = *(_OWORD *)(v8 + v62);
                    *(_OWORD *)(v63 + 48) = v64;
                    if (!v62) {
                      break;
                    }
                    v62 -= 32LL;
                    if (*(double *)(v63 - 8) >= v61)
                    {
                      uint64_t v65 = v8 + v62 + 32;
                      goto LABEL_78;
                    }
                  }

                  uint64_t v65 = v8;
LABEL_78:
                  *(void *)(v65 + 16) = v117;
                  *(__n128 *)uint64_t v65 = v107;
                  *(double *)(v65 + 24) = v61;
                }

                __int128 v55 = (__n128 *)(v59 + 32);
                v58 += 32LL;
              }

              while ((__n128 *)(v59 + 32) != a2);
            }
          }

          else if (!v57)
          {
            do
            {
              double v91 = *(double *)(a1 + 24);
              double v92 = *(double *)(a1 + 56);
              a1 = (uint64_t)v55;
              if (v91 < v92)
              {
                uint64_t v120 = v55[1].n128_i64[0];
                __n128 v110 = *v55;
                __int128 v93 = v55;
                do
                {
                  __n128 v94 = v93[-1];
                  __n128 *v93 = v93[-2];
                  v93[1] = v94;
                  double v95 = v93[-3].n128_f64[1];
                  v93 -= 2;
                }

                while (v95 < v92);
                v93[1].n128_u64[0] = v120;
                __n128 *v93 = v110;
                v93[1].n128_f64[1] = v92;
              }

              v55 += 2;
            }

            while ((__n128 *)(a1 + 32) != a2);
          }

          return;
        }

        if (!a3)
        {
          if ((__n128 *)v8 != a2)
          {
            int64_t v66 = (v10 - 2) >> 1;
            int64_t v67 = v66;
            do
            {
              int64_t v68 = v67;
              if (v66 >= v67)
              {
                uint64_t v69 = (2 * v67) | 1;
                unint64_t v70 = v8 + 32 * v69;
                if (2 * v68 + 2 < (uint64_t)v10 && *(double *)(v70 + 56) < *(double *)(v70 + 24))
                {
                  v70 += 32LL;
                  uint64_t v69 = 2 * v68 + 2;
                }

                double v71 = *(double *)(v8 + 32 * v68 + 24);
                if (v71 >= *(double *)(v70 + 24))
                {
                  unint64_t v72 = v8 + 32 * v68;
                  uint64_t v118 = *(void *)(v72 + 16);
                  __int128 v108 = *(_OWORD *)v72;
                  do
                  {
                    int v73 = (_OWORD *)v72;
                    unint64_t v72 = v70;
                    __int128 v74 = *(_OWORD *)(v70 + 16);
                    *int v73 = *(_OWORD *)v70;
                    v73[1] = v74;
                    if (v66 < v69) {
                      break;
                    }
                    uint64_t v75 = 2 * v69;
                    uint64_t v69 = (2 * v69) | 1;
                    unint64_t v70 = v8 + 32 * v69;
                    uint64_t v76 = v75 + 2;
                    if (v76 < (uint64_t)v10 && *(double *)(v70 + 56) < *(double *)(v70 + 24))
                    {
                      v70 += 32LL;
                      uint64_t v69 = v76;
                    }
                  }

                  while (v71 >= *(double *)(v70 + 24));
                  *(void *)(v72 + 16) = v118;
                  *(_OWORD *)unint64_t v72 = v108;
                  *(double *)(v72 + 24) = v71;
                }
              }

              int64_t v67 = v68 - 1;
            }

            while (v68);
            uint64_t v77 = (unint64_t)v9 >> 5;
            do
            {
              uint64_t v78 = 0LL;
              __n128 v109 = *(__n128 *)v8;
              __n128 v119 = *(__n128 *)(v8 + 16);
              unint64_t v79 = v8;
              do
              {
                unint64_t v80 = (_OWORD *)v79;
                v79 += 32 * (v78 + 1);
                uint64_t v81 = 2 * v78;
                uint64_t v78 = (2 * v78) | 1;
                uint64_t v82 = v81 + 2;
                if (v82 < v77 && *(double *)(v79 + 56) < *(double *)(v79 + 24))
                {
                  v79 += 32LL;
                  uint64_t v78 = v82;
                }

                __int128 v83 = *(_OWORD *)(v79 + 16);
                *unint64_t v80 = *(_OWORD *)v79;
                v80[1] = v83;
              }

              while (v78 <= (uint64_t)((unint64_t)(v77 - 2) >> 1));
              a2 -= 2;
              if ((__n128 *)v79 == a2)
              {
                *(__n128 *)unint64_t v79 = v109;
                *(__n128 *)(v79 + 16) = v119;
              }

              else
              {
                __n128 v84 = a2[1];
                *(__n128 *)unint64_t v79 = *a2;
                *(__n128 *)(v79 + 16) = v84;
                *a2 = v109;
                a2[1] = v119;
                uint64_t v85 = v79 - v8 + 32;
                if (v85 >= 33)
                {
                  unint64_t v86 = (((unint64_t)v85 >> 5) - 2) >> 1;
                  double v87 = *(double *)(v79 + 24);
                  if (v87 < *(double *)(v8 + 32 * v86 + 24))
                  {
                    uint64_t v101 = *(void *)(v79 + 16);
                    __int128 v98 = *(_OWORD *)v79;
                    do
                    {
                      unint64_t v88 = (_OWORD *)v79;
                      unint64_t v79 = v8 + 32 * v86;
                      __int128 v89 = *(_OWORD *)(v79 + 16);
                      *unint64_t v88 = *(_OWORD *)v79;
                      v88[1] = v89;
                      if (!v86) {
                        break;
                      }
                      unint64_t v86 = (v86 - 1) >> 1;
                    }

                    while (v87 < *(double *)(v8 + 32 * v86 + 24));
                    *(void *)(v79 + 16) = v101;
                    *(_OWORD *)unint64_t v79 = v98;
                    *(double *)(v79 + 24) = v87;
                  }
                }
              }
            }

            while (v77-- > 2);
          }

          return;
        }

        unint64_t v11 = v10 >> 1;
        unint64_t v12 = v8 + 32 * (v10 >> 1);
        if ((unint64_t)v9 <= 0x1000)
        {
          sub_1000AFBE8((double *)(a1 + 32 * (v10 >> 1)), (double *)a1, a2[-2].n128_f64);
        }

        else
        {
          sub_1000AFBE8((double *)a1, (double *)(a1 + 32 * (v10 >> 1)), a2[-2].n128_f64);
          sub_1000AFBE8((double *)(a1 + 32), (double *)(v12 - 32), a2[-4].n128_f64);
          sub_1000AFBE8((double *)(a1 + 64), (double *)(a1 + 32 + 32 * v11), a2[-6].n128_f64);
          sub_1000AFBE8((double *)(v12 - 32), (double *)v12, (double *)(a1 + 32 + 32 * v11));
          __int128 v102 = *(_OWORD *)a1;
          __int128 v111 = *(_OWORD *)(a1 + 16);
          __int128 v13 = *(_OWORD *)(v12 + 16);
          *(_OWORD *)a1 = *(_OWORD *)v12;
          *(_OWORD *)(a1 + 16) = v13;
          *(_OWORD *)unint64_t v12 = v102;
          *(_OWORD *)(v12 + 16) = v111;
        }

        --a3;
        if ((a4 & 1) == 0)
        {
          double v14 = *(double *)(a1 + 24);
          uint64_t v100 = *(void *)(a1 + 16);
          __int128 v97 = *(_OWORD *)a1;
          if (a2[-1].n128_f64[1] >= v14)
          {
            unint64_t v32 = a1 + 32;
            do
            {
              unint64_t v8 = v32;
              double v33 = *(double *)(v32 + 24);
              v32 += 32LL;
            }

            while (v33 >= v14);
          }

          else
          {
            uint64_t v30 = a1;
            do
            {
              unint64_t v8 = v30 + 32;
              double v31 = *(double *)(v30 + 56);
              v30 += 32LL;
            }

            while (v31 >= v14);
          }

          unint64_t v34 = a2;
          if (v8 < (unint64_t)a2)
          {
            unint64_t v35 = a2;
            do
            {
              unint64_t v34 = v35 - 2;
              double v36 = v35[-1].n128_f64[1];
              v35 -= 2;
            }

            while (v36 < v14);
          }

          while (v8 < (unint64_t)v34)
          {
            __n128 v104 = *(__n128 *)v8;
            __n128 v113 = *(__n128 *)(v8 + 16);
            __n128 v37 = v34[1];
            *(__n128 *)unint64_t v8 = *v34;
            *(__n128 *)(v8 + 16) = v37;
            __n128 *v34 = v104;
            v34[1] = v113;
            do
            {
              double v38 = *(double *)(v8 + 56);
              v8 += 32LL;
            }

            while (v38 >= v14);
            do
            {
              double v39 = v34[-1].n128_f64[1];
              v34 -= 2;
            }

            while (v39 < v14);
          }

          char v40 = (_OWORD *)(v8 - 32);
          if (v8 - 32 != a1)
          {
            __int128 v41 = *(_OWORD *)(v8 - 16);
            *(_OWORD *)a1 = *v40;
            *(_OWORD *)(a1 + 16) = v41;
          }

          a4 = 0;
          *(void *)(v8 - 16) = v100;
          *char v40 = v97;
          *(double *)(v8 - 8) = v14;
          continue;
        }

        double v14 = *(double *)(a1 + 24);
LABEL_11:
        uint64_t v15 = 0LL;
        uint64_t v99 = *(void *)(a1 + 16);
        __int128 v96 = *(_OWORD *)a1;
        do
        {
          double v16 = *(double *)(a1 + v15 + 56);
          v15 += 32LL;
        }

        while (v14 < v16);
        unint64_t v17 = a1 + v15;
        __int128 v18 = a2;
        if (v15 == 32)
        {
          uint64_t v21 = a2;
          while (v17 < (unint64_t)v21)
          {
            unint64_t v19 = v21 - 2;
            double v22 = v21[-1].n128_f64[1];
            v21 -= 2;
            if (v14 < v22) {
              goto LABEL_21;
            }
          }

          unint64_t v19 = v21;
        }

        else
        {
          do
          {
            unint64_t v19 = v18 - 2;
            double v20 = v18[-1].n128_f64[1];
            v18 -= 2;
          }

          while (v14 >= v20);
        }

double *sub_1000AFBE8(double *result, double *a2, double *a3)
{
  double v3 = a2[3];
  double v4 = a3[3];
  if (result[3] >= v3)
  {
    if (v3 < v4)
    {
      __int128 v9 = *(_OWORD *)a2;
      __int128 v8 = *((_OWORD *)a2 + 1);
      __int128 v10 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v10;
      *(_OWORD *)a3 = v9;
      *((_OWORD *)a3 + 1) = v8;
      if (result[3] < a2[3])
      {
        __int128 v12 = *(_OWORD *)result;
        __int128 v11 = *((_OWORD *)result + 1);
        __int128 v13 = *((_OWORD *)a2 + 1);
        *(_OWORD *)BOOL result = *(_OWORD *)a2;
        *((_OWORD *)result + 1) = v13;
        *(_OWORD *)a2 = v12;
        *((_OWORD *)a2 + 1) = v11;
      }
    }
  }

  else
  {
    if (v3 >= v4)
    {
      __int128 v15 = *(_OWORD *)result;
      __int128 v14 = *((_OWORD *)result + 1);
      __int128 v16 = *((_OWORD *)a2 + 1);
      *(_OWORD *)BOOL result = *(_OWORD *)a2;
      *((_OWORD *)result + 1) = v16;
      *(_OWORD *)a2 = v15;
      *((_OWORD *)a2 + 1) = v14;
      if (a2[3] >= a3[3]) {
        return result;
      }
      __int128 v6 = *(_OWORD *)a2;
      __int128 v5 = *((_OWORD *)a2 + 1);
      __int128 v17 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v17;
    }

    else
    {
      __int128 v6 = *(_OWORD *)result;
      __int128 v5 = *((_OWORD *)result + 1);
      __int128 v7 = *((_OWORD *)a3 + 1);
      *(_OWORD *)BOOL result = *(_OWORD *)a3;
      *((_OWORD *)result + 1) = v7;
    }

    *(_OWORD *)a3 = v6;
    *((_OWORD *)a3 + 1) = v5;
  }

  return result;
}

BOOL sub_1000AFCC4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      if (*(double *)(a1 + 24) < *(double *)(a2 - 8))
      {
        __n128 v7 = *(__n128 *)a1;
        __int128 v6 = *(_OWORD *)(a1 + 16);
        __int128 v8 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a1 + 16) = v8;
        *(__n128 *)(a2 - 32) = v7;
        *(_OWORD *)(a2 - 16) = v6;
      }

      return result;
    case 3LL:
      sub_1000AFBE8((double *)a1, (double *)(a1 + 32), (double *)(a2 - 32));
      return 1LL;
    case 4LL:
      sub_1000AFF14((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a2 - 32));
      return 1LL;
    case 5LL:
      __int128 v18 = (__n128 *)(a1 + 32);
      unint64_t v19 = (__n128 *)(a1 + 64);
      double v20 = (__n128 *)(a1 + 96);
      sub_1000AFF14((__n128 *)a1, (__n128 *)(a1 + 32), (__n128 *)(a1 + 64), (__n128 *)(a1 + 96));
      if (*(double *)(a1 + 120) < *(double *)(a2 - 8))
      {
        __n128 v22 = *v20;
        __int128 v21 = *(_OWORD *)(a1 + 112);
        __int128 v23 = *(_OWORD *)(a2 - 16);
        *double v20 = *(__n128 *)(a2 - 32);
        *(_OWORD *)(a1 + 112) = v23;
        *(__n128 *)(a2 - 32) = v22;
        *(_OWORD *)(a2 - 16) = v21;
        if (*(double *)(a1 + 88) < *(double *)(a1 + 120))
        {
          __n128 v25 = *v19;
          __int128 v24 = *(_OWORD *)(a1 + 80);
          __int128 v26 = *(_OWORD *)(a1 + 112);
          *unint64_t v19 = *v20;
          *(_OWORD *)(a1 + 80) = v26;
          *double v20 = v25;
          *(_OWORD *)(a1 + 112) = v24;
          if (*(double *)(a1 + 56) < *(double *)(a1 + 88))
          {
            __n128 v28 = *v18;
            __int128 v27 = *(_OWORD *)(a1 + 48);
            __int128 v29 = *(_OWORD *)(a1 + 80);
            __n128 *v18 = *v19;
            *(_OWORD *)(a1 + 48) = v29;
            *unint64_t v19 = v28;
            *(_OWORD *)(a1 + 80) = v27;
            if (*(double *)(a1 + 24) < *(double *)(a1 + 56))
            {
              __n128 v31 = *(__n128 *)a1;
              __int128 v30 = *(_OWORD *)(a1 + 16);
              __int128 v32 = *(_OWORD *)(a1 + 48);
              *(__n128 *)a1 = *v18;
              *(_OWORD *)(a1 + 16) = v32;
              __n128 *v18 = v31;
              *(_OWORD *)(a1 + 48) = v30;
            }
          }
        }
      }

      return 1LL;
    default:
      uint64_t v9 = a1 + 64;
      sub_1000AFBE8((double *)a1, (double *)(a1 + 32), (double *)(a1 + 64));
      uint64_t v10 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1LL;
      }
      uint64_t v11 = 0LL;
      int v12 = 0;
      break;
  }

  while (1)
  {
    double v13 = *(double *)(v10 + 24);
    if (*(double *)(v9 + 24) < v13)
    {
      __int128 v33 = *(_OWORD *)v10;
      uint64_t v34 = *(void *)(v10 + 16);
      uint64_t v14 = v11;
      while (1)
      {
        uint64_t v15 = a1 + v14;
        __int128 v16 = *(_OWORD *)(a1 + v14 + 80);
        *(_OWORD *)(v15 + 96) = *(_OWORD *)(a1 + v14 + 64);
        *(_OWORD *)(v15 + 112) = v16;
        if (v14 == -64) {
          break;
        }
        v14 -= 32LL;
        if (*(double *)(v15 + 56) >= v13)
        {
          uint64_t v17 = a1 + v14 + 96;
          goto LABEL_12;
        }
      }

      uint64_t v17 = a1;
LABEL_12:
      *(_OWORD *)uint64_t v17 = v33;
      *(void *)(v17 + 16) = v34;
      *(double *)(v17 + 24) = v13;
      if (++v12 == 8) {
        return v10 + 32 == a2;
      }
    }

    uint64_t v9 = v10;
    v11 += 32LL;
    v10 += 32LL;
    if (v10 == a2) {
      return 1LL;
    }
  }

__n128 sub_1000AFF14(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4)
{
  result.n128_u64[0] = a3[1].n128_u64[1];
  if (result.n128_f64[0] < a4[1].n128_f64[1])
  {
    __n128 v9 = *a3;
    __n128 result = a3[1];
    __n128 v10 = a4[1];
    *a3 = *a4;
    a3[1] = v10;
    *a4 = v9;
    a4[1] = result;
    result.n128_u64[0] = a2[1].n128_u64[1];
    if (result.n128_f64[0] < a3[1].n128_f64[1])
    {
      __n128 v11 = *a2;
      __n128 result = a2[1];
      __n128 v12 = a3[1];
      *a2 = *a3;
      a2[1] = v12;
      *a3 = v11;
      a3[1] = result;
      result.n128_u64[0] = a1[1].n128_u64[1];
      if (result.n128_f64[0] < a2[1].n128_f64[1])
      {
        __n128 v13 = *a1;
        __n128 result = a1[1];
        __n128 v14 = a2[1];
        *a1 = *a2;
        a1[1] = v14;
        *a2 = v13;
        a2[1] = result;
      }
    }
  }

  return result;
}

void ***sub_1000AFFDC(void ***a1, __int128 *a2)
{
  uint64_t v4 = *a1;
  __int128 v5 = (char *)(*a1)[1];
  __int128 v6 = *a1;
  __n128 v9 = (char *)v6[2];
  uint64_t v7 = (uint64_t)(v6 + 2);
  __int128 v8 = v9;
  if (v5 >= v9)
  {
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (_BYTE *)*v4) >> 2);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0xCCCCCCCCCCCCCCCLL) {
      sub_100007008();
    }
    unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - (_BYTE *)*v4) >> 2);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x666666666666666LL) {
      unint64_t v15 = 0xCCCCCCCCCCCCCCCLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15) {
      __int128 v16 = (char *)sub_10009D074(v7, v15);
    }
    else {
      __int128 v16 = 0LL;
    }
    uint64_t v17 = &v16[20 * v12];
    __int128 v18 = &v16[20 * v15];
    __int128 v19 = *a2;
    *((_DWORD *)v17 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)uint64_t v17 = v19;
    __n128 v11 = v17 + 20;
    __int128 v21 = (char *)*v4;
    double v20 = (char *)v4[1];
    if (v20 != *v4)
    {
      do
      {
        __int128 v22 = *(_OWORD *)(v20 - 20);
        *((_DWORD *)v17 - 1) = *((_DWORD *)v20 - 1);
        *(_OWORD *)(v17 - 20) = v22;
        v17 -= 20;
        v20 -= 20;
      }

      while (v20 != v21);
      double v20 = (char *)*v4;
    }

    void *v4 = v17;
    v4[1] = v11;
    v4[2] = v18;
    if (v20) {
      operator delete(v20);
    }
  }

  else
  {
    __int128 v10 = *a2;
    *((_DWORD *)v5 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)__int128 v5 = v10;
    __n128 v11 = v5 + 20;
  }

  v4[1] = v11;
  return a1;
}

void *sub_1000B010C(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v6 = 0LL;
  for (uint64_t i = 0LL; i != 16; ++i)
    v6 ^= (v6 << 6) + (v6 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + i);
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v3 = v6;
      if (v6 >= v8) {
        unint64_t v3 = v6 % v8;
      }
    }

    else
    {
      unint64_t v3 = (v8 - 1) & v6;
    }

    __int128 v10 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v10)
    {
      __n128 v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v6)
          {
            if (v11[2] == *a2 && v11[3] == a2[1]) {
              return v11;
            }
          }

          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }

            else
            {
              v12 &= v8 - 1;
            }

            if (v12 != v3) {
              break;
            }
          }

          __n128 v11 = (void *)*v11;
        }

        while (v11);
      }
    }
  }

  __n128 v11 = operator new(0x28uLL);
  void *v11 = 0LL;
  v11[1] = v6;
  *((_OWORD *)v11 + 1) = *(_OWORD *)a3;
  *((_DWORD *)v11 + 8) = *(_DWORD *)(a3 + 16);
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1LL;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    sub_100019E10(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v6 >= v8) {
        unint64_t v3 = v6 % v8;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = (v8 - 1) & v6;
    }
  }

  uint64_t v20 = *(void *)a1;
  __int128 v21 = *(void **)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    void *v11 = *v21;
LABEL_44:
    *__int128 v21 = v11;
    goto LABEL_45;
  }

  void *v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v20 + 8 * v3) = a1 + 16;
  if (*v11)
  {
    unint64_t v22 = *(void *)(*v11 + 8LL);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }

    else
    {
      v22 &= v8 - 1;
    }

    __int128 v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_44;
  }

void sub_1000B0350(_Unwind_Exception *a1)
{
}

__int128 *sub_1000B0364(uint64_t *a1, __int128 *a2, __int128 *a3, __int128 *a4, uint64_t a5)
{
  __int128 v5 = a2;
  if (a5 >= 1)
  {
    uint64_t v7 = a3;
    uint64_t v11 = a1[2];
    uint64_t v9 = (uint64_t)(a1 + 2);
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v11 - v12) >> 4)) >= a5)
    {
      uint64_t v20 = v12 - (void)a2;
      if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v12 - (void)a2) >> 4)) >= a5)
      {
        __int128 v21 = &a3[15 * a5];
      }

      else
      {
        __int128 v21 = &a3[(uint64_t)(v12 - (void)a2) >> 4];
        a1[1] = sub_1000B0554(v9, v21, a4, *(void *)(v9 - 8));
        if (v20 < 1) {
          return v5;
        }
      }

      sub_1000ACCE4((uint64_t)a1, (uint64_t)v5, v12, (uint64_t)&v5[15 * a5]);
      sub_1000B05FC((uint64_t)v26, v7, v21, (uint64_t)v5);
    }

    else
    {
      uint64_t v13 = *a1;
      unint64_t v14 = a5 - 0x1111111111111111LL * ((uint64_t)(v12 - *a1) >> 4);
      if (v14 > 0x111111111111111LL) {
        sub_100007008();
      }
      unint64_t v15 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)a2 - v13) >> 4);
      unint64_t v16 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v13) >> 4);
      uint64_t v17 = 2 * v16;
      if (2 * v16 <= v14) {
        uint64_t v17 = v14;
      }
      if (v16 >= 0x88888888888888LL) {
        unint64_t v18 = 0x111111111111111LL;
      }
      else {
        unint64_t v18 = v17;
      }
      uint64_t v29 = v9;
      if (v18) {
        size_t v19 = (char *)sub_10001D66C(v9, v18);
      }
      else {
        size_t v19 = 0LL;
      }
      unint64_t v22 = &v19[240 * v15];
      v26[0] = v19;
      v26[1] = v22;
      __int128 v27 = v22;
      __n128 v28 = &v19[240 * v18];
      uint64_t v23 = 240 * a5;
      __int128 v24 = &v22[240 * a5];
      do
      {
        sub_10001D548(v29, (uint64_t)v22, v7);
        v22 += 240;
        v7 += 15;
        v23 -= 240LL;
      }

      while (v23);
      __int128 v27 = v24;
      __int128 v5 = (__int128 *)sub_1000ACD8C((uint64_t)a1, v26, v5);
      sub_10001D7FC(v26);
    }
  }

  return v5;
}

void sub_1000B0528( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000B0554(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    unint64_t v6 = a2;
    do
    {
      sub_10001D548(a1, v4, v6);
      v6 += 15;
      uint64_t v4 = v12 + 240;
      v12 += 240LL;
    }

    while (v6 != a3);
  }

  char v10 = 1;
  sub_1000619CC((uint64_t)v9);
  return v4;
}

void sub_1000B05E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

__int128 *sub_1000B05FC(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  __int128 v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  unint64_t v6 = a3;
  do
  {
    __int128 v7 = *v5;
    *(void *)(a4 + 16) = *((void *)v5 + 2);
    *(_OWORD *)a4 = v7;
    std::string::operator=((std::string *)(a4 + 24), (const std::string *)v5 + 1);
    __int128 v8 = *(__int128 *)((char *)v5 + 60);
    *(_OWORD *)(a4 + 48) = v5[3];
    *(_OWORD *)(a4 + 60) = v8;
    sub_100087EC8(a4 + 80, (uint64_t)(v5 + 5));
    __int128 v9 = *(__int128 *)((char *)v5 + 216);
    *(_BYTE *)(a4 + 232) = *((_BYTE *)v5 + 232);
    *(_OWORD *)(a4 + 216) = v9;
    a4 += 240LL;
    v5 += 15;
  }

  while (v5 != v6);
  return v6;
}

void *sub_1000B06A0()
{
  __n128 result = operator new(0x10uLL);
  void *result = &off_10181CF40;
  return result;
}

void sub_1000B06C4(uint64_t a1, void *a2)
{
  *a2 = &off_10181CF40;
}

uint64_t sub_1000B06DC()
{
  return 0LL;
}

uint64_t sub_1000B06E4(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000B0720()
{
}

void *sub_1000B072C(void *result, uint64_t a2)
{
  void *result = a2;
  return result;
}

uint64_t sub_1000B0734(uint64_t *a1)
{
  if (v14)
  {
    uint64_t v2 = __p;
    if (v13 < 0) {
      uint64_t v2 = (void **)__p[0];
    }
    unsigned int v3 = -[NSFileManager fileExistsAtPath:isDirectory:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:isDirectory:",  +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v2),  0LL);
  }

  else
  {
    unsigned int v3 = 0;
  }

  int v4 = sub_1000380E0(*a1);
  int v5 = sub_100037DF0(*a1);
  int v6 = sub_1000B0A38(*a1);
  int v7 = v6;
  if (v4) {
    unsigned int v8 = 0;
  }
  else {
    unsigned int v8 = v3;
  }
  if (v5) {
    unsigned int v8 = 0;
  }
  if (v6) {
    uint64_t v9 = 0LL;
  }
  else {
    uint64_t v9 = v8;
  }
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CFB0);
  }
  char v10 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68290306;
    int v16 = 0;
    __int16 v17 = 2082;
    unint64_t v18 = "";
    __int16 v19 = 1026;
    int v20 = v9;
    __int16 v21 = 1026;
    int v22 = v4;
    __int16 v23 = 1026;
    int v24 = v5;
    __int16 v25 = 1026;
    int v26 = v7;
    __int16 v27 = 1026;
    unsigned int v28 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Checking if should migrate from backup, result:%{public}hhd, numMainDBRecordingEven ts:%{public}d, numMainDBMeasurements:%{public}d, numMainDBServices:%{public}d, restoreDbExists:%{public}hhd}",  buf,  0x30u);
  }

  if (v14 && v13 < 0) {
    operator delete(__p[0]);
  }
  return v9;
}

void sub_1000B0904( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_1000B093C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (v8)
  {
    if (v7 >= 0) {
      unsigned int v3 = __p;
    }
    else {
      unsigned int v3 = (void **)__p[0];
    }
    sub_1010DDBC0( &v4,  (char *)-[NSString UTF8String]( -[NSString stringByAppendingPathComponent:]( +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v3),  "stringByAppendingPathComponent:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", "milo_restore.db")),  "UTF8String"));
    *(_OWORD *)a2 = v4;
    *(void *)(a2 + 16) = v5;
    *(_BYTE *)(a2 + 24) = 1;
    if (v8)
    {
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }
  }

  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 24) = 0;
  }

void sub_1000B0A10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a19)
  {
    if (a18 < 0) {
      operator delete(__p);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1000B0A38(uint64_t a1)
{
  if (sub_1003C1048(a1 + 72)) {
    return sub_100024DEC(a1, "MiLoServices");
  }
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CFB0);
  }
  unsigned int v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#Warning Attempt to get numEntries without a backing database",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CFB0);
    }
    v6[0] = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Attempt to get numEntries without a backing database",  v6,  2);
    uint64_t v5 = (uint8_t *)v4;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMiLoServiceTable]",  "%s\n",  v4);
    if (v5 != buf) {
      free(v5);
    }
  }

  return 0LL;
}

uint64_t sub_1000B0C0C(uint64_t a1, uint64_t a2)
{
  double v4 = sub_101171D4C();
  sub_1000B093C(a1, (uint64_t)__p);
  if (!v29) {
    goto LABEL_17;
  }
  uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  if ((v5 & 0x80u) != 0LL) {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  if (!v5)
  {
LABEL_17:
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CFB0);
    }
    unint64_t v15 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "Failed to get paths for exporting iCloud Restore db",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_44;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CFB0);
    }
    LOWORD(v30) = 0;
    int v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Failed to get paths for exporting iCloud Restore db",  &v30,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)",  "%s\n",  v16);
    goto LABEL_67;
  }

  int v6 = __p;
  if (v28 < 0) {
    int v6 = (void **)__p[0];
  }
  if (!-[NSFileManager fileExistsAtPath:isDirectory:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:isDirectory:",  +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v6),  0LL))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CFB0);
    }
    __int16 v17 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      if (!v29) {
        sub_100036CD8();
      }
      unint64_t v18 = __p;
      if (v28 < 0) {
        unint64_t v18 = (void **)__p[0];
      }
      *(_DWORD *)uint64_t buf = 136380675;
      *(void *)__int128 v33 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "iCloud restore db file does not exist at %{private}s",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_44;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CFB0);
    }
    if (!v29) {
      sub_100036CD8();
    }
    __int16 v19 = __p;
    if (v28 < 0) {
      __int16 v19 = (void **)__p[0];
    }
    int v30 = 136380675;
    __n128 v31 = v19;
    int v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "iCloud restore db file does not exist at %{private}s",  &v30,  12);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)",  "%s\n",  v16);
    goto LABEL_67;
  }

  if (!+[CLMicroLocationKeychain retrieveSymmetricKey:]( &OBJC_CLASS____TtC19microlocation_logic23CLMicroLocationKeychain,  "retrieveSymmetricKey:",  @"com.apple.milo.security.database.backup"))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CFB0);
    }
    int v20 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "Failed to get key for backup decryption",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_44;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CFB0);
    }
    LOWORD(v30) = 0;
    int v16 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Failed to get key for backup decryption",  &v30,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)",  "%s\n",  v16);
LABEL_67:
LABEL_44:
    uint64_t v14 = 0LL;
    goto LABEL_45;
  }

  char v7 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "com.apple.locationd.microlocation.migrate-cloud-backup");
  if (!v29) {
    sub_100036CD8();
  }
  char v8 = v7;
  if (v28 >= 0) {
    uint64_t v9 = __p;
  }
  else {
    uint64_t v9 = (void **)__p[0];
  }
  char v10 = sub_100293D24((const char *)v9);
  if (!v29) {
    sub_100036CD8();
  }
  uint64_t v11 = v10;
  id v12 = sub_1000B1444( (uint64_t)v10,  (uint64_t *)__p,  (uint64_t *)a2,  (uint64_t)@"com.apple.milo.security.database.backup");
  if (!(_DWORD)v12)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CFB0);
    }
    int v22 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Failed to decrypt backup file", buf, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CFB0);
      }
      LOWORD(v30) = 0;
      int v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Failed to decrypt backup file",  &v30,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMicroLocationBackupAndRestore::exportiCloudBackupDatabaseInternal(std::string &)",  "%s\n",  v26);
    }

    else {
      uint64_t v23 = *(void *)a2;
    }
    uint64_t v13 = -[NSFileManager fileExistsAtPath:isDirectory:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:isDirectory:",  +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v23),  0LL);
    if (!(_DWORD)v13) {
      goto LABEL_59;
    }
    goto LABEL_58;
  }

  sub_1000B14F8((uint64_t)v12, a2);
  uint64_t v13 = sub_100036C7C(a2, 2LL, 0LL);
  if (!(_DWORD)v13)
  {
LABEL_58:
    sub_1000B1B90(v13, a2);
LABEL_59:
    uint64_t v14 = 0LL;
    goto LABEL_60;
  }

  sub_1000B19F4(a1, a2, 2);
  uint64_t v14 = 1LL;
LABEL_60:

  double v24 = sub_101171D4C();
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CFB0);
  }
  __int16 v25 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289795;
    *(_DWORD *)__int128 v33 = 0;
    *(_WORD *)&v33[4] = 2082;
    *(void *)&v33[6] = "";
    __int16 v34 = 1025;
    int v35 = v14;
    __int16 v36 = 2049;
    double v37 = v24 - v4;
    __int16 v38 = 2049;
    double v39 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Microlocation export restored backup for migration, result:%{private}hhd, duration [s]:%{private}f, restore file size [B]:%{private}ld}",  buf,  0x2Cu);
  }

void sub_1000B13EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a17)
  {
    if (a16 < 0) {
      operator delete(__p);
    }
  }

  _Unwind_Resume(exception_object);
}

id sub_1000B1444(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  else {
    int v6 = (uint64_t *)*a2;
  }
  char v7 = +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v6);
  else {
    char v8 = (uint64_t *)*a3;
  }
  uint64_t v9 = +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v8);
  uint64_t v10 = objc_opt_class(&OBJC_CLASS____TtC19microlocation_logic23CLMicroLocationKeychain);
  return (id)+[CLMicroLocationEncryption decryptFile:destinationPath:keyLabel:keychainClass:]( &OBJC_CLASS____TtC19microlocation_logic25CLMicroLocationEncryption,  "decryptFile:destinationPath:keyLabel:keychainClass:",  v7,  v9,  a4,  v10);
}

uint64_t sub_1000B14F8(uint64_t a1, uint64_t a2)
{
  int v3 = *(char *)(a2 + 23);
  if (v3 < 0)
  {
    sub_1010DD48C(buf, *(void **)a2, *(void *)(a2 + 8));
    LOBYTE(v3) = *(_BYTE *)(a2 + 23);
  }

  else
  {
    *(_OWORD *)uint64_t buf = *(_OWORD *)a2;
    *(void *)&buf[16] = *(void *)(a2 + 16);
  }

  double v4 = &buf[24];
  if ((v3 & 0x80u) == 0) {
    size_t v5 = v3;
  }
  else {
    size_t v5 = *(void *)(a2 + 8);
  }
  sub_1000392EC((uint64_t)&buf[24], v5 + 4);
  if (v32 < 0) {
    double v4 = *(_BYTE **)&buf[24];
  }
  if (v5)
  {
    else {
      int v6 = *(const void **)a2;
    }
    memmove(v4, v6, v5);
  }

  strcpy(&v4[v5], "-wal");
  char v7 = v33;
  else {
    size_t v8 = *(void *)(a2 + 8);
  }
  sub_1000392EC((uint64_t)v33, v8 + 4);
  if (v34[0] < 0) {
    char v7 = (void *)v33[0];
  }
  if (v8)
  {
    else {
      uint64_t v9 = *(const void **)a2;
    }
    memmove(v7, v9, v8);
  }

  strcpy((char *)v7 + v8, "-shm");
  double v24 = 0LL;
  __int16 v25 = 0LL;
  int v26 = 0LL;
  __int16 v27 = &v24;
  char v28 = 0;
  double v24 = (char *)operator new(0x48uLL);
  __int16 v25 = v24;
  int v26 = v24 + 72;
  uint64_t v10 = 0LL;
  __int16 v25 = sub_1000B2874((uint64_t)&v26, (__int128 *)buf, &v35, v24);
  do
  {
    v10 -= 3LL;
  }

  while (v10 != -9);
  uint64_t v11 = v24;
  id v12 = v25;
  if (v24 == v25)
  {
    char v13 = 1;
  }

  else
  {
    char v13 = 1;
    do
    {
      if (v11[23] >= 0) {
        uint64_t v14 = v11;
      }
      else {
        uint64_t v14 = *(char **)v11;
      }
      if (-[NSFileManager fileExistsAtPath:isDirectory:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:isDirectory:",  +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v14),  0LL))
      {
        __int16 v27 = 0LL;
        unint64_t v15 = +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager");
        NSFileAttributeKey v29 = NSFileProtectionKey;
        NSFileProtectionType v30 = NSFileProtectionCompleteUnlessOpen;
        int v16 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v30,  &v29,  1LL);
        __int16 v17 = v11;
        if (v11[23] < 0) {
          __int16 v17 = *(char **)v11;
        }
        unsigned __int8 v18 = -[NSFileManager setAttributes:ofItemAtPath:error:]( v15,  "setAttributes:ofItemAtPath:error:",  v16,  +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v17),  &v27);
        if ((v18 & 1) == 0)
        {
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181CFB0);
          }
          __int16 v19 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
          {
            int v20 = v11;
            if (v11[23] < 0) {
              int v20 = *(char **)v11;
            }
            *(_DWORD *)uint64_t buf = 68289539;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            *(_WORD *)&_BYTE buf[18] = 2081;
            *(void *)&buf[20] = v20;
            *(_WORD *)&_BYTE buf[28] = 2113;
            *(void *)&buf[30] = v27;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:failed to set attributes for file, filename:%{private, location:escape_only}s , error:%{private, location:escape_only}@}",  buf,  0x26u);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181CFB0);
            }
          }

          __int16 v21 = (os_log_s *)qword_1019348D8;
          if (os_signpost_enabled((os_log_t)qword_1019348D8))
          {
            int v22 = v11;
            if (v11[23] < 0) {
              int v22 = *(char **)v11;
            }
            *(_DWORD *)uint64_t buf = 68289539;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            *(_WORD *)&_BYTE buf[18] = 2081;
            *(void *)&buf[20] = v22;
            *(_WORD *)&_BYTE buf[28] = 2113;
            *(void *)&buf[30] = v27;
            _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v21,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "failed to set attributes for file",  "{msg%{public}.0s:failed to set attributes for file, filename:%{private, location:escape_only}s , error:%{private, location:escape_only}@}",  buf,  0x26u);
          }
        }

        v13 &= v18;
      }

      v11 += 24;
    }

    while (v11 != v12);
  }

  *(void *)uint64_t buf = &v24;
  sub_1000129D4((void ***)buf);
  return v13 & 1;
}

void sub_1000B1964( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
}

uint64_t sub_1000B19F4(uint64_t a1, uint64_t a2, int a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a2, *(void *)(a2 + 8));
  }

  else
  {
    *(_OWORD *)__int128 __p = *(_OWORD *)a2;
    uint64_t v9 = *(void *)(a2 + 16);
  }

  uint64_t v4 = sub_1000243A4((uint64_t)v10, (__int128 *)__p, a3);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  sub_1000B1EB4(v4, (uint64_t)v10, v7);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CFB0);
  }
  size_t v5 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t buf = 68290051LL;
    __int16 v12 = 2082;
    char v13 = "";
    __int16 v14 = 1025;
    int v15 = v7[0];
    __int16 v16 = 1025;
    int v17 = v7[1];
    __int16 v18 = 1025;
    int v19 = v7[2];
    __int16 v20 = 1025;
    int v21 = v7[3];
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Restored iCloud Backup database tables contents, numRecordingEventsEntries:%{private} d, numMeasurementsEntries:%{private}d, numConfigurationEntries:%{private}d, numLoiEntries:%{private}d}",  (uint8_t *)&buf,  0x2Au);
  }

  return sub_1000244B0((uint64_t)v10);
}

void sub_1000B1B5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, char a18)
{
}

void sub_1000B1B90(uint64_t a1, uint64_t a2)
{
  int v3 = *(char *)(a2 + 23);
  if (v3 < 0)
  {
    sub_1010DD48C(&__dst, *(void **)a2, *(void *)(a2 + 8));
    LOBYTE(v3) = *(_BYTE *)(a2 + 23);
  }

  else
  {
    __int128 __dst = *(_OWORD *)a2;
    uint64_t v20 = *(void *)(a2 + 16);
  }

  uint64_t v4 = v21;
  if ((v3 & 0x80u) == 0) {
    size_t v5 = v3;
  }
  else {
    size_t v5 = *(void *)(a2 + 8);
  }
  sub_1000392EC((uint64_t)v21, v5 + 4);
  if (v22 < 0) {
    uint64_t v4 = (void *)v21[0];
  }
  if (v5)
  {
    else {
      int v6 = *(const void **)a2;
    }
    memmove(v4, v6, v5);
  }

  strcpy((char *)v4 + v5, "-wal");
  char v7 = v23;
  else {
    size_t v8 = *(void *)(a2 + 8);
  }
  sub_1000392EC((uint64_t)v23, v8 + 4);
  if (v24 < 0) {
    char v7 = (void *)v23[0];
  }
  if (v8)
  {
    else {
      uint64_t v9 = *(const void **)a2;
    }
    memmove(v7, v9, v8);
  }

  strcpy((char *)v7 + v8, "-shm");
  int v15 = 0LL;
  __int16 v16 = 0LL;
  v17[0] = 0LL;
  v17[1] = &v15;
  char v18 = 0;
  int v15 = (char *)operator new(0x48uLL);
  __int16 v16 = v15;
  v17[0] = v15 + 72;
  uint64_t v10 = 0LL;
  __int16 v16 = sub_100036E0C((uint64_t)v17, &__dst, &v25, v15);
  do
  {
    if (*(&v24 + v10 * 8) < 0) {
      operator delete((void *)v23[v10]);
    }
    v10 -= 3LL;
  }

  while (v10 != -9);
  uint64_t v11 = v15;
  for (uint64_t i = v16; v11 != i; v11 += 24)
  {
    if (v11[23] >= 0) {
      char v13 = v11;
    }
    else {
      char v13 = *(char **)v11;
    }
    if (-[NSFileManager fileExistsAtPath:isDirectory:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:isDirectory:",  +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v13),  0LL))
    {
      __int16 v14 = v11;
      if (v11[23] < 0) {
        __int16 v14 = *(char **)v11;
      }
      -[NSFileManager removeItemAtURL:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtURL:error:",  +[NSURL fileURLWithPath:]( &OBJC_CLASS___NSURL,  "fileURLWithPath:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v14)),  0LL);
    }
  }

  *(void *)&__int128 __dst = &v15;
  sub_1000129D4((void ***)&__dst);
}

void sub_1000B1E24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15)
{
}

uint64_t sub_1000B1EB4(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = sub_1000380E0(a2);
  a3[1] = sub_100037DF0(a2);
  a3[2] = sub_100038508(a2);
  uint64_t result = sub_1000B2678(a2);
  a3[3] = result;
  return result;
}

void sub_1000B1F04(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (v12 >= 0) {
    int v3 = __p;
  }
  else {
    int v3 = (void **)__p[0];
  }
  uint64_t v4 = -[NSString stringByDeletingLastPathComponent]( +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v3),  "stringByDeletingLastPathComponent");
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  char v10 = 0;
  unsigned int v5 = -[NSFileManager fileExistsAtPath:isDirectory:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:isDirectory:",  v4,  &v10);
  if (v10) {
    unsigned int v6 = v5;
  }
  else {
    unsigned int v6 = 0;
  }
  if (v6 == 1)
  {
    sub_1010DDBC0(__p, (char *)-[NSString UTF8String](v4, "UTF8String"));
    *(_OWORD *)a2 = *(_OWORD *)__p;
    *(void *)(a2 + 16) = v12;
    *(_BYTE *)(a2 + 24) = 1;
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CFB0);
    }
    char v7 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Failed to get locationDb directory",  (uint8_t *)__p,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CFB0);
      }
      v9[0] = 0;
      size_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Failed to get locationDb directory",  v9,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "std::optional<std::string> CLMicroLocationBackupAndRestore::getLocationDbDirPath()",  "%s\n",  v8);
    }

    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 24) = 0;
  }

void sub_1000B2154( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000B2178(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (v9
    && (v8 >= 0 ? (int v3 = __p) : (int v3 = (void **)__p[0]),
        uint64_t v4 = -[NSString stringByAppendingPathComponent:]( +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v3),  "stringByAppendingPathComponent:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", "milo_cache")),  -[NSFileManager fileExistsAtPath:isDirectory:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:isDirectory:",  v4,  0LL)))
  {
    sub_1010DDBC0(&v5, (char *)-[NSString UTF8String](v4, "UTF8String"));
    *(_OWORD *)a2 = v5;
    *(void *)(a2 + 16) = v6;
    *(_BYTE *)(a2 + 24) = 1;
  }

  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 24) = 0;
  }

  if (v9)
  {
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }

void sub_1000B2270( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a19)
  {
    if (a18 < 0) {
      operator delete(__p);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_1000B2298(uint64_t a1)
{
  if (v18)
  {
    uint64_t v2 = v16;
    if (v17 < 0) {
      uint64_t v2 = (void **)v16[0];
    }
    if (-[NSFileManager fileExistsAtPath:isDirectory:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:isDirectory:",  +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v2),  0LL))
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181CFB0);
      }
      int v3 = (os_log_s *)qword_1019348D8;
      BOOL v4 = os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT);
      if (v4)
      {
        if (!v18) {
          sub_100036CD8();
        }
        __int128 v5 = v16;
        if (v17 < 0) {
          __int128 v5 = (void **)v16[0];
        }
        *(_DWORD *)uint64_t buf = 68289283;
        int v20 = 0;
        __int16 v21 = 2082;
        char v22 = "";
        __int16 v23 = 2081;
        char v24 = (const char *)v5;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:deleting restore database file, filename:%{private, location:escape_only}s}",  buf,  0x1Cu);
      }

      if (!v18) {
        sub_100036CD8();
      }
      sub_1000B1B90(v4, (uint64_t)v16);
    }
  }

  sub_1000B2178(a1, (uint64_t)__p);
  if (v15)
  {
    uint64_t v6 = __p;
    if (v14 < 0) {
      uint64_t v6 = (void **)__p[0];
    }
    char v7 = +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", v6);
    if (-[NSFileManager fileExistsAtPath:isDirectory:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:isDirectory:",  v7,  0LL))
    {
      uint64_t v12 = 0LL;
      if (!-[NSFileManager removeItemAtPath:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "removeItemAtPath:error:",  v7,  &v12))
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181CFB0);
        }
        char v8 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
        {
          char v9 = -[NSString UTF8String](v7, "UTF8String");
          *(_DWORD *)uint64_t buf = 68289538;
          int v20 = 0;
          __int16 v21 = 2082;
          char v22 = "";
          __int16 v23 = 2082;
          char v24 = v9;
          __int16 v25 = 2114;
          uint64_t v26 = v12;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:failed to remove existing directory, directory:%{public, location:escape_only}s , error:%{public, location:escape_only}@}",  buf,  0x26u);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181CFB0);
          }
        }

        char v10 = (os_log_s *)qword_1019348D8;
        if (os_signpost_enabled((os_log_t)qword_1019348D8))
        {
          uint64_t v11 = -[NSString UTF8String](v7, "UTF8String");
          *(_DWORD *)uint64_t buf = 68289538;
          int v20 = 0;
          __int16 v21 = 2082;
          char v22 = "";
          __int16 v23 = 2082;
          char v24 = v11;
          __int16 v25 = 2114;
          uint64_t v26 = v12;
          _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "failed to remove existing directory",  "{msg%{public}.0s:failed to remove existing directory, directory:%{public, location:escape_only}s , error:%{public, location:escape_only}@}",  buf,  0x26u);
        }
      }
    }

    if (v15 && v14 < 0) {
      operator delete(__p[0]);
    }
  }

  if (v18)
  {
    if (v17 < 0) {
      operator delete(v16[0]);
    }
  }

void sub_1000B2618( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, char a24)
{
  if (a17 && a16 < 0) {
    operator delete(__p);
  }
  if (a24)
  {
    if (a23 < 0) {
      operator delete(a18);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1000B2678(uint64_t a1)
{
  if (sub_1003C1048(a1 + 72)) {
    return sub_100024DEC(a1, "MiLoLoiTable");
  }
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181CFB0);
  }
  int v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#Warning Attempt to get numEntries without a backing database",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181CFB0);
    }
    v5[0] = 0;
    BOOL v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Attempt to get numEntries without a backing database",  v5,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "uint32_t CLMicroLocationDatabase::numEntriesFromTriggerTable() [Table = CLMiLoLoiTable]",  "%s\n",  v4);
  }

  return 0LL;
}

void sub_1000B2848(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

char *sub_1000B2874(uint64_t a1, __int128 *a2, __int128 *a3, char *__dst)
{
  BOOL v4 = __dst;
  uint64_t v11 = __dst;
  uint64_t v12 = __dst;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        sub_1010DD48C(v4, *(void **)v6, *((void *)v6 + 1));
        BOOL v4 = v12;
      }

      else
      {
        __int128 v7 = *v6;
        *((void *)v4 + 2) = *((void *)v6 + 2);
        *(_OWORD *)BOOL v4 = v7;
      }

      uint64_t v6 = (__int128 *)((char *)v6 + 24);
      v4 += 24;
      uint64_t v12 = v4;
    }

    while (v6 != a3);
  }

  char v10 = 1;
  sub_1000B2930((uint64_t)v9);
  return v4;
}

void sub_1000B291C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000B2930(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100036EFC(a1);
  }
  return a1;
}

void *sub_1000B2964(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  a1[1] = a3;
  v9[0] = &off_10181D030;
  v9[1] = a1;
  void v9[3] = v9;
  v10[0] = &off_10181D0B0;
  v10[1] = a1;
  v10[3] = v10;
  v11[0] = &off_10181D130;
  v11[1] = a1;
  v11[3] = v11;
  v12[0] = &off_10181D1B0;
  v12[1] = a1;
  char v13 = v12;
  a1[3] = 0LL;
  a1[4] = 0LL;
  a1[2] = 0LL;
  BOOL v4 = (char *)operator new(0x80uLL);
  a1[4] = v4 + 128;
  a1[2] = v4;
  a1[3] = v4;
  uint64_t v5 = 0LL;
  a1[3] = sub_1000575E0((uint64_t)(a1 + 4), (uint64_t)v9, (uint64_t)&v14, (uint64_t)v4);
  do
  {
    uint64_t v6 = (&v13)[v5];
    if (&v12[v5] == v6)
    {
      uint64_t v6 = &v12[v5];
      uint64_t v7 = 4LL;
    }

    else
    {
      if (!v6) {
        goto LABEL_7;
      }
      uint64_t v7 = 5LL;
    }

    (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_7:
    v5 -= 4LL;
  }

  while (v5 != -16);
  return a1;
}

void sub_1000B2AA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  uint64_t v14 = v13;
  *(void *)(v12 + 24) = v14;
  sub_10005771C(&a10);
  uint64_t v16 = 0LL;
  while (1)
  {
    char v17 = *(char **)(&a12 + v16 + 120);
    if (&a12 + v16 + 96 == v17) {
      break;
    }
    if (v17)
    {
      uint64_t v18 = 5LL;
LABEL_6:
      (*(void (**)(void))(*(void *)v17 + 8 * v18))();
    }

    v16 -= 32LL;
    if (v16 == -128) {
      _Unwind_Resume(a1);
    }
  }

  char v17 = &a12 + v16 + 96;
  uint64_t v18 = 4LL;
  goto LABEL_6;
}

void *sub_1000B2B10(void *result)
{
  uint64_t v1 = result[2];
  uint64_t v2 = result[3];
  if (v1 != v2)
  {
    while (1)
    {
      v5[0] = &off_10181D230;
      uint64_t v6 = v5;
      uint64_t v3 = *(void *)(v1 + 24);
      if (!v3) {
        sub_100008BDC();
      }
      (*(void (**)(uint64_t, void *))(*(void *)v3 + 48LL))(v3, v5);
      uint64_t result = v6;
      if (v6 == v5) {
        break;
      }
      if (v6)
      {
        uint64_t v4 = 5LL;
LABEL_7:
        uint64_t result = (void *)(*(uint64_t (**)(void))(*result + 8 * v4))();
      }

      v1 += 32LL;
      if (v1 == v2) {
        return result;
      }
    }

    uint64_t result = v5;
    uint64_t v4 = 4LL;
    goto LABEL_7;
  }

  return result;
}

void sub_1000B2BE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  uint64_t v14 = a13;
  if (a13 == &a10)
  {
    uint64_t v15 = 4LL;
    uint64_t v14 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*(void *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

unint64_t sub_1000B2C20(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  unint64_t result = sub_1000EFB38((uint64_t)a5, a4);
  if ((result & 0xFF00000000LL) != 0)
  {
    LODWORD(sub_10009B798(v11, v10) = result;
    return (unint64_t)objc_msgSend( a2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v10),  objc_msgSend(a3, "stringByAppendingString:", @"Utilization"));
  }

  return result;
}

void sub_1000B2CF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (sub_1000B31D4())
  {
    char v8 = operator new(0x68uLL);
    *char v8 = xmmword_1012CB930;
    v8[1] = xmmword_1012CB940;
    v8[2] = xmmword_1012CB950;
    void v8[3] = xmmword_1012CB960;
    v8[4] = xmmword_1012CB970;
    v8[5] = xmmword_1012CB980;
    *((void *)v8 + 12) = 13LL;
    sub_1000BA8F0(&v35, 0xDuLL);
    uint64_t v9 = 0LL;
    *(void *)uint64_t buf = &v35;
    do
    {
      LODWORD(v33) = *(_DWORD *)((char *)v8 + v9);
      sub_10009CA94((uint64_t *)buf, &v33);
      v9 += 8LL;
    }

    while (v9 != 24);
    sub_1000EF828(buf, a2);
    uint64_t v10 = sub_10008CFB4((uint64_t)buf);
    sub_1000EF82C((uint64_t *)buf, 3uLL, &v33);
    sub_1000EF82C((uint64_t *)buf, 4uLL, &v31);
    sub_1000EF82C((uint64_t *)buf, 5uLL, &v29);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3321888768LL;
    v13[2] = sub_1000B32AC;
    void v13[3] = &unk_10181CFD0;
    void v13[4] = a1;
    v13[5] = buf;
    v13[6] = a4;
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    uint64_t v16 = 0LL;
    sub_10001B72C(&v14, v33, (uint64_t)v34, (v34 - (_BYTE *)v33) >> 2);
    char v17 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t v19 = 0LL;
    sub_10001B72C(&v17, v31, (uint64_t)v32, (v32 - (_BYTE *)v31) >> 2);
    int v20 = 0LL;
    __int16 v21 = 0LL;
    uint64_t v22 = 0LL;
    sub_10001B72C(&v20, v29, (uint64_t)v30, (v30 - (_BYTE *)v29) >> 2);
    __int128 __p = 0LL;
    char v24 = 0LL;
    uint64_t v25 = 0LL;
    sub_10001B72C(&__p, v35, (uint64_t)v36, (v36 - (_BYTE *)v35) >> 2);
    uint64_t v26 = a3;
    uint64_t v27 = v10;
    uint64_t v28 = a2;
    AnalyticsSendEventLazy(@"com.apple.MicroLocation.Analytics", v13);
    if (__p)
    {
      char v24 = __p;
      operator delete(__p);
    }

    if (v20)
    {
      __int16 v21 = v20;
      operator delete(v20);
    }

    if (v17)
    {
      uint64_t v18 = v17;
      operator delete(v17);
    }

    if (v14)
    {
      uint64_t v15 = v14;
      operator delete(v14);
    }

    if (v29)
    {
      NSFileProtectionType v30 = v29;
      operator delete(v29);
    }

    if (v31)
    {
      char v32 = v31;
      operator delete(v31);
    }

    if (v33)
    {
      __int16 v34 = v33;
      operator delete(v33);
    }

    if (v39)
    {
      char v40 = v39;
      operator delete(v39);
    }

    if (*(void *)buf)
    {
      __int16 v38 = *(void **)buf;
      operator delete(*(void **)buf);
    }

    if (v35)
    {
      __int16 v36 = v35;
      operator delete(v35);
    }

    operator delete(v8);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    uint64_t v11 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "CLMicroLocationAnalytics, sendCoreAnalyticsEvent, not sending event because sending to CoreAnalytics is disabled",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      LOWORD(v35) = 0;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "CLMicroLocationAnalytics, sendCoreAnalyticsEvent, not sending event because sending to CoreAnalytics is disabled",  &v35,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationAnalytics::sendCoreAnalyticsEvent(const std::vector<CLMicroLocationWiFiChannelHistogram> &, const std::vector<CLMicroLocationWiFiChannelHistogram> &, const std::string &) const",  "%s\n",  v12);
    }
  }

void sub_1000B30E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, void *__p, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void *a34, uint64_t a35, uint64_t a36, void *a37, uint64_t a38, uint64_t a39, void *a40, uint64_t a41, uint64_t a42, void *a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47)
{
}

uint64_t sub_1000B31D4()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsAnalyticsSendEventEnabled", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A6FD4(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  BOOL v2 = v7;
  uint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v2) {
    return 1LL;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_1000B3294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

id sub_1000B32AC(uint64_t a1)
{
  id v2 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
  objc_msgSend( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:]( NSNumber,  "numberWithUnsignedLong:",  sub_10008CFB4(*(void *)(a1 + 40))),  @"histogramTotalChannelCount");
  uint64_t v3 = *(uint64_t **)(a1 + 48);
  objc_msgSend( v2,  "setObject:forKeyedSubscript:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v3),  @"loiType");
  __int128 v159 = 0LL;
  __int128 v160 = 0LL;
  uint64_t v161 = 0LL;
  sub_10001B72C( &v159,  *(const void **)(a1 + 56),  *(void *)(a1 + 64),  (uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 2);
  uint64_t v4 = *(void *)(a1 + 40);
  unint64_t v153 = 0LL;
  uint64_t v154 = 0LL;
  int v152 = 0LL;
  sub_100007590(&v152, *(const void **)v4, *(void *)(v4 + 8), (uint64_t)(*(void *)(v4 + 8) - *(void *)v4) >> 3);
  int v155 = *(_DWORD *)(v4 + 24);
  __int128 v157 = 0LL;
  uint64_t v158 = 0LL;
  int v156 = 0LL;
  unint64_t v5 = sub_10001B72C( &v156,  *(const void **)(v4 + 32),  *(void *)(v4 + 40),  (uint64_t)(*(void *)(v4 + 40) - *(void *)(v4 + 32)) >> 2);
  sub_1000B2C20((uint64_t)v5, v2, @"localizationTopThreeChannels", (uint64_t)&v159, (uint64_t *)&v152);
  if (v156)
  {
    __int128 v157 = v156;
    operator delete(v156);
  }

  if (v152)
  {
    unint64_t v153 = v152;
    operator delete(v152);
  }

  if (v159)
  {
    __int128 v160 = v159;
    operator delete(v159);
  }

  __int128 v149 = 0LL;
  unint64_t v150 = 0LL;
  uint64_t v151 = 0LL;
  sub_10001B72C( &v149,  *(const void **)(a1 + 80),  *(void *)(a1 + 88),  (uint64_t)(*(void *)(a1 + 88) - *(void *)(a1 + 80)) >> 2);
  uint64_t v6 = *(void *)(a1 + 40);
  __int128 v143 = 0LL;
  uint64_t v144 = 0LL;
  __int128 v142 = 0LL;
  sub_100007590(&v142, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 3);
  int v145 = *(_DWORD *)(v6 + 24);
  __int128 v147 = 0LL;
  uint64_t v148 = 0LL;
  __int128 v146 = 0LL;
  BOOL v7 = sub_10001B72C( &v146,  *(const void **)(v6 + 32),  *(void *)(v6 + 40),  (uint64_t)(*(void *)(v6 + 40) - *(void *)(v6 + 32)) >> 2);
  sub_1000B2C20((uint64_t)v7, v2, @"localizationTopFourChannels", (uint64_t)&v149, (uint64_t *)&v142);
  if (v146)
  {
    __int128 v147 = v146;
    operator delete(v146);
  }

  if (v142)
  {
    __int128 v143 = v142;
    operator delete(v142);
  }

  if (v149)
  {
    unint64_t v150 = v149;
    operator delete(v149);
  }

  __int128 v140 = 0LL;
  __int128 v139 = 0LL;
  uint64_t v141 = 0LL;
  sub_10001B72C( &v139,  *(const void **)(a1 + 104),  *(void *)(a1 + 112),  (uint64_t)(*(void *)(a1 + 112) - *(void *)(a1 + 104)) >> 2);
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v134 = 0LL;
  unint64_t v132 = 0LL;
  int v133 = 0LL;
  sub_100007590(&v132, *(const void **)v8, *(void *)(v8 + 8), (uint64_t)(*(void *)(v8 + 8) - *(void *)v8) >> 3);
  int v135 = *(_DWORD *)(v8 + 24);
  uint64_t v138 = 0LL;
  __int128 __p = 0LL;
  int v137 = 0LL;
  uint64_t v9 = sub_10001B72C( &__p,  *(const void **)(v8 + 32),  *(void *)(v8 + 40),  (uint64_t)(*(void *)(v8 + 40) - *(void *)(v8 + 32)) >> 2);
  sub_1000B2C20((uint64_t)v9, v2, @"localizationTopFiveChannels", (uint64_t)&v139, (uint64_t *)&v132);
  if (__p)
  {
    int v137 = __p;
    operator delete(__p);
  }

  if (v132)
  {
    int v133 = v132;
    operator delete(v132);
  }

  if (v139)
  {
    __int128 v140 = v139;
    operator delete(v139);
  }

  uint64_t v10 = *(const void **)(a1 + 128);
  uint64_t v11 = *(void *)(a1 + 136);
  int v130 = 0LL;
  uint64_t v129 = 0LL;
  uint64_t v131 = 0LL;
  sub_10001B72C(&v129, v10, v11, (v11 - (uint64_t)v10) >> 2);
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v124 = 0LL;
  unint64_t v122 = 0LL;
  __int128 v123 = 0LL;
  sub_100007590(&v122, *(const void **)v12, *(void *)(v12 + 8), (uint64_t)(*(void *)(v12 + 8) - *(void *)v12) >> 3);
  int v125 = *(_DWORD *)(v12 + 24);
  uint64_t v128 = 0LL;
  int64_t v126 = 0LL;
  int64_t v127 = 0LL;
  uint64_t v13 = sub_10001B72C( &v126,  *(const void **)(v12 + 32),  *(void *)(v12 + 40),  (uint64_t)(*(void *)(v12 + 40) - *(void *)(v12 + 32)) >> 2);
  sub_1000B2C20((uint64_t)v13, v2, @"localizationPopularThreeChannels", (uint64_t)&v129, (uint64_t *)&v122);
  if (v126)
  {
    int64_t v127 = v126;
    operator delete(v126);
  }

  if (v122)
  {
    __int128 v123 = v122;
    operator delete(v122);
  }

  if (v129)
  {
    int v130 = v129;
    operator delete(v129);
  }

  unint64_t v14 = sub_1000EF8BC(*(__int32 ***)(a1 + 40), a1 + 128);
  if ((v14 & 0xFF00000000LL) != 0)
  {
    int v15 = v14;
    __n128 v107 = 0LL;
    __int128 v108 = 0LL;
    unint64_t v109 = 0LL;
    sub_10001B72C( &v107,  *(const void **)(a1 + 128),  *(void *)(a1 + 136),  (uint64_t)(*(void *)(a1 + 136) - *(void *)(a1 + 128)) >> 2);
    uint64_t v16 = v108;
    if ((unint64_t)v108 >= v109)
    {
      uint64_t v18 = (char *)v107;
      uint64_t v19 = (v108 - (_BYTE *)v107) >> 2;
      unint64_t v20 = v19 + 1;
      uint64_t v21 = v109 - (void)v107;
      else {
        unint64_t v22 = v20;
      }
      if (v22)
      {
        __int16 v23 = (char *)sub_10000956C((uint64_t)&v109, v22);
        uint64_t v18 = (char *)v107;
        uint64_t v16 = v108;
      }

      else
      {
        __int16 v23 = 0LL;
      }

      char v24 = &v23[4 * v19];
      uint64_t v25 = &v23[4 * v22];
      *(_DWORD *)char v24 = v15;
      uint64_t v17 = (uint64_t)(v24 + 4);
      while (v16 != v18)
      {
        int v26 = *((_DWORD *)v16 - 1);
        v16 -= 4;
        *((_DWORD *)v24 - 1) = v26;
        v24 -= 4;
      }

      __n128 v107 = v24;
      __int128 v108 = (char *)v17;
      unint64_t v109 = (unint64_t)v25;
      if (v18) {
        operator delete(v18);
      }
    }

    else
    {
      *(_DWORD *)__int128 v108 = v15;
      uint64_t v17 = (uint64_t)(v16 + 4);
    }

    __int128 v108 = (char *)v17;
    uint64_t v121 = 0LL;
    __n128 v119 = 0LL;
    uint64_t v120 = 0LL;
    sub_10001B72C(&v119, v107, v17, (v17 - (uint64_t)v107) >> 2);
    uint64_t v27 = *(void *)(a1 + 40);
    uint64_t v114 = 0LL;
    __n128 v112 = 0LL;
    __n128 v113 = 0LL;
    sub_100007590( &v112,  *(const void **)v27,  *(void *)(v27 + 8),  (uint64_t)(*(void *)(v27 + 8) - *(void *)v27) >> 3);
    int v115 = *(_DWORD *)(v27 + 24);
    uint64_t v118 = 0LL;
    __int128 v116 = 0LL;
    uint64_t v117 = 0LL;
    uint64_t v28 = sub_10001B72C( &v116,  *(const void **)(v27 + 32),  *(void *)(v27 + 40),  (uint64_t)(*(void *)(v27 + 40) - *(void *)(v27 + 32)) >> 2);
    sub_1000B2C20( (uint64_t)v28,  v2,  @"localizationPopularThreeAndTopOneChannels",  (uint64_t)&v119,  (uint64_t *)&v112);
    if (v116)
    {
      uint64_t v117 = v116;
      operator delete(v116);
    }

    if (v112)
    {
      __n128 v113 = v112;
      operator delete(v112);
    }

    if (v119)
    {
      uint64_t v120 = v119;
      operator delete(v119);
    }

    if (v107)
    {
      __int128 v108 = (char *)v107;
      operator delete(v107);
    }
  }

  sub_1000EF828(&v107, *(void *)(a1 + 152));
  uint64_t v29 = sub_10008CFB4((uint64_t)&v107);
  objc_msgSend( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v29),  @"prevHistogramTotalChannelCount");
  uint64_t v30 = *(void *)(a1 + 160) - v29;
  objc_msgSend( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v30),  @"histogramDiffCount");
  if (v29)
  {
    *(float *)&double v31 = (float)v30 / (float)(unint64_t)v29;
    objc_msgSend( v2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v31),  @"histogramDiffCountPercentage");
  }

  sub_1000EF82C((uint64_t *)&v107, 3uLL, v106);
  uint64_t v32 = *(void *)(a1 + 40);
  uint64_t v100 = 0LL;
  uint64_t v101 = 0LL;
  uint64_t v99 = 0LL;
  sub_100007590(&v99, *(const void **)v32, *(void *)(v32 + 8), (uint64_t)(*(void *)(v32 + 8) - *(void *)v32) >> 3);
  int v102 = *(_DWORD *)(v32 + 24);
  __n128 v104 = 0LL;
  uint64_t v105 = 0LL;
  __n128 v103 = 0LL;
  __int128 v33 = sub_10001B72C( &v103,  *(const void **)(v32 + 32),  *(void *)(v32 + 40),  (uint64_t)(*(void *)(v32 + 40) - *(void *)(v32 + 32)) >> 2);
  sub_1000B2C20((uint64_t)v33, v2, @"localizationPrevTopThreeChannels", (uint64_t)v106, (uint64_t *)&v99);
  if (v103)
  {
    __n128 v104 = v103;
    operator delete(v103);
  }

  if (v99)
  {
    uint64_t v100 = v99;
    operator delete(v99);
  }

  if (v106[0])
  {
    v106[1] = v106[0];
    operator delete(v106[0]);
  }

  sub_1000EF82C((uint64_t *)&v107, 4uLL, v98);
  uint64_t v34 = *(void *)(a1 + 40);
  double v92 = 0LL;
  uint64_t v93 = 0LL;
  double v91 = 0LL;
  sub_100007590(&v91, *(const void **)v34, *(void *)(v34 + 8), (uint64_t)(*(void *)(v34 + 8) - *(void *)v34) >> 3);
  int v94 = *(_DWORD *)(v34 + 24);
  __int128 v96 = 0LL;
  uint64_t v97 = 0LL;
  double v95 = 0LL;
  __int128 v35 = sub_10001B72C( &v95,  *(const void **)(v34 + 32),  *(void *)(v34 + 40),  (uint64_t)(*(void *)(v34 + 40) - *(void *)(v34 + 32)) >> 2);
  sub_1000B2C20((uint64_t)v35, v2, @"localizationPrevTopFourChannels", (uint64_t)v98, (uint64_t *)&v91);
  if (v95)
  {
    __int128 v96 = v95;
    operator delete(v95);
  }

  if (v91)
  {
    double v92 = v91;
    operator delete(v91);
  }

  if (v98[0])
  {
    v98[1] = v98[0];
    operator delete(v98[0]);
  }

  sub_1000EF82C((uint64_t *)&v107, 5uLL, v90);
  uint64_t v36 = *(void *)(a1 + 40);
  __n128 v84 = 0LL;
  uint64_t v85 = 0LL;
  __int128 v83 = 0LL;
  sub_100007590(&v83, *(const void **)v36, *(void *)(v36 + 8), (uint64_t)(*(void *)(v36 + 8) - *(void *)v36) >> 3);
  int v86 = *(_DWORD *)(v36 + 24);
  unint64_t v88 = 0LL;
  uint64_t v89 = 0LL;
  double v87 = 0LL;
  double v37 = sub_10001B72C( &v87,  *(const void **)(v36 + 32),  *(void *)(v36 + 40),  (uint64_t)(*(void *)(v36 + 40) - *(void *)(v36 + 32)) >> 2);
  sub_1000B2C20((uint64_t)v37, v2, @"localizationPrevTopFiveChannels", (uint64_t)v90, (uint64_t *)&v83);
  if (v87)
  {
    unint64_t v88 = v87;
    operator delete(v87);
  }

  if (v83)
  {
    __n128 v84 = v83;
    operator delete(v83);
  }

  if (v90[0])
  {
    v90[1] = v90[0];
    operator delete(v90[0]);
  }

  unint64_t v38 = sub_1000EF8BC(*(__int32 ***)(a1 + 40), a1 + 128);
  int v39 = v38;
  if ((v38 & 0xFF00000000LL) != 0)
  {
    unint64_t v80 = 0LL;
    uint64_t v81 = 0LL;
    unint64_t v82 = 0LL;
    sub_10001B72C( &v80,  *(const void **)(a1 + 128),  *(void *)(a1 + 136),  (uint64_t)(*(void *)(a1 + 136) - *(void *)(a1 + 128)) >> 2);
    char v40 = v81;
    if ((unint64_t)v81 >= v82)
    {
      __n128 v42 = (char *)v80;
      uint64_t v43 = (v81 - (_BYTE *)v80) >> 2;
      unint64_t v44 = v43 + 1;
      uint64_t v45 = v82 - (void)v80;
      else {
        unint64_t v46 = v44;
      }
      if (v46)
      {
        __n128 v47 = (char *)sub_10000956C((uint64_t)&v82, v46);
        __n128 v42 = (char *)v80;
        char v40 = v81;
      }

      else
      {
        __n128 v47 = 0LL;
      }

      __int128 v48 = &v47[4 * v43];
      __n128 v49 = &v47[4 * v46];
      *(_DWORD *)__int128 v48 = v39;
      uint64_t v41 = (uint64_t)(v48 + 4);
      while (v40 != v42)
      {
        int v50 = *((_DWORD *)v40 - 1);
        v40 -= 4;
        *((_DWORD *)v48 - 1) = v50;
        v48 -= 4;
      }

      unint64_t v80 = v48;
      uint64_t v81 = (char *)v41;
      unint64_t v82 = (unint64_t)v49;
      if (v42) {
        operator delete(v42);
      }
    }

    else
    {
      *(_DWORD *)uint64_t v81 = v39;
      uint64_t v41 = (uint64_t)(v40 + 4);
    }

    uint64_t v81 = (char *)v41;
    uint64_t v78 = 0LL;
    uint64_t v79 = 0LL;
    uint64_t v77 = 0LL;
    sub_10001B72C(&v77, v80, v41, (v41 - (uint64_t)v80) >> 2);
    uint64_t v51 = *(void *)(a1 + 40);
    double v71 = 0LL;
    uint64_t v72 = 0LL;
    unint64_t v70 = 0LL;
    sub_100007590( &v70,  *(const void **)v51,  *(void *)(v51 + 8),  (uint64_t)(*(void *)(v51 + 8) - *(void *)v51) >> 3);
    int v73 = *(_DWORD *)(v51 + 24);
    uint64_t v75 = 0LL;
    uint64_t v76 = 0LL;
    __int128 v74 = 0LL;
    __n128 v52 = sub_10001B72C( &v74,  *(const void **)(v51 + 32),  *(void *)(v51 + 40),  (uint64_t)(*(void *)(v51 + 40) - *(void *)(v51 + 32)) >> 2);
    sub_1000B2C20( (uint64_t)v52,  v2,  @"localizationPopularThreeAndPrevOneTopChannels",  (uint64_t)&v77,  (uint64_t *)&v70);
    if (v74)
    {
      uint64_t v75 = v74;
      operator delete(v74);
    }

    if (v70)
    {
      double v71 = v70;
      operator delete(v70);
    }

    if (v77)
    {
      uint64_t v78 = v77;
      operator delete(v77);
    }

    for (unint64_t i = 3LL; i != 6; ++i)
    {
      sub_1000EF9C4(*(int ***)(a1 + 168), *(int ***)(a1 + 152), i, &v68);
      __int128 v54 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"localizationTop%dCommonChannels",  i);
      uint64_t v65 = 0LL;
      int64_t v66 = 0LL;
      uint64_t v67 = 0LL;
      sub_10001B72C(&v65, v68, (uint64_t)v69, (v69 - (_BYTE *)v68) >> 2);
      uint64_t v55 = *(void *)(a1 + 40);
      unint64_t v59 = 0LL;
      uint64_t v60 = 0LL;
      uint64_t v58 = 0LL;
      sub_100007590( &v58,  *(const void **)v55,  *(void *)(v55 + 8),  (uint64_t)(*(void *)(v55 + 8) - *(void *)v55) >> 3);
      int v61 = *(_DWORD *)(v55 + 24);
      uint64_t v63 = 0LL;
      uint64_t v64 = 0LL;
      uint64_t v62 = 0LL;
      __int128 v56 = sub_10001B72C( &v62,  *(const void **)(v55 + 32),  *(void *)(v55 + 40),  (uint64_t)(*(void *)(v55 + 40) - *(void *)(v55 + 32)) >> 2);
      sub_1000B2C20((uint64_t)v56, v2, v54, (uint64_t)&v65, (uint64_t *)&v58);
      if (v62)
      {
        uint64_t v63 = v62;
        operator delete(v62);
      }

      if (v58)
      {
        unint64_t v59 = v58;
        operator delete(v58);
      }

      if (v65)
      {
        int64_t v66 = v65;
        operator delete(v65);
      }

      if (v68)
      {
        uint64_t v69 = v68;
        operator delete(v68);
      }
    }

    if (v80)
    {
      uint64_t v81 = (char *)v80;
      operator delete(v80);
    }
  }

  if (v110)
  {
    __int128 v111 = v110;
    operator delete(v110);
  }

  if (v107)
  {
    __int128 v108 = (char *)v107;
    operator delete(v107);
  }

  return v2;
}

void sub_1000B3D14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *__p, uint64_t a31, uint64_t a32, void *a33, uint64_t a34, uint64_t a35, void *a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, void *a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (__p)
  {
    a31 = (uint64_t)__p;
    operator delete(__p);
  }

  if (a33)
  {
    a34 = (uint64_t)a33;
    operator delete(a33);
  }

  sub_1000B3FE0((uint64_t)&a66);
  _Unwind_Resume(a1);
}

uint64_t sub_1000B3FE0(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }

  return a1;
}

void *sub_1000B4020(void *a1, uint64_t a2)
{
  a1[7] = 0LL;
  a1[8] = 0LL;
  a1[9] = 0LL;
  sub_10001B72C( a1 + 7,  *(const void **)(a2 + 56),  *(void *)(a2 + 64),  (uint64_t)(*(void *)(a2 + 64) - *(void *)(a2 + 56)) >> 2);
  a1[10] = 0LL;
  a1[11] = 0LL;
  a1[12] = 0LL;
  sub_10001B72C( a1 + 10,  *(const void **)(a2 + 80),  *(void *)(a2 + 88),  (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 2);
  a1[13] = 0LL;
  a1[14] = 0LL;
  a1[15] = 0LL;
  sub_10001B72C( a1 + 13,  *(const void **)(a2 + 104),  *(void *)(a2 + 112),  (uint64_t)(*(void *)(a2 + 112) - *(void *)(a2 + 104)) >> 2);
  a1[16] = 0LL;
  a1[17] = 0LL;
  a1[18] = 0LL;
  return sub_10001B72C( a1 + 16,  *(const void **)(a2 + 128),  *(void *)(a2 + 136),  (uint64_t)(*(void *)(a2 + 136) - *(void *)(a2 + 128)) >> 2);
}

void sub_1000B40D0(_Unwind_Exception *exception_object)
{
  uint64_t v6 = *v4;
  if (*v4)
  {
    v1[14] = v6;
    operator delete(v6);
  }

  BOOL v7 = *v3;
  if (*v3)
  {
    v1[11] = v7;
    operator delete(v7);
  }

  uint64_t v8 = *v2;
  if (*v2)
  {
    v1[8] = v8;
    operator delete(v8);
  }

  _Unwind_Resume(exception_object);
}

void sub_1000B411C(void *a1)
{
  id v2 = (void *)a1[16];
  if (v2)
  {
    a1[17] = v2;
    operator delete(v2);
  }

  uint64_t v3 = (void *)a1[13];
  if (v3)
  {
    a1[14] = v3;
    operator delete(v3);
  }

  uint64_t v4 = (void *)a1[10];
  if (v4)
  {
    a1[11] = v4;
    operator delete(v4);
  }

  unint64_t v5 = (void *)a1[7];
  if (v5)
  {
    a1[8] = v5;
    operator delete(v5);
  }

void sub_1000B4180(uint64_t *a1, uint64_t a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)uint64_t v67 = 2082;
    *(void *)&v67[2] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:analyzing WiFi channels}",  buf,  0x12u);
  }

  sub_100029334(a1[1], &v62);
  if (v62 == v63)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    __n128 v42 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v67 = 2082;
      *(void *)&v67[2] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:no LOI ids found}",  buf,  0x12u);
    }
  }

  else
  {
    sub_1002F0B04(buf);
    CFStringRef v5 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsNumberDaysToAnalyzeWiFiChannels",  0x8000100u,  kCFAllocatorNull);
    int v6 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v5, &v52);
    CFRelease(v5);
    uint64_t data_low = LODWORD(v52.__r_.__value_.__l.__data_);
    uint64_t v8 = *(std::__shared_weak_count **)v67;
    if (*(void *)v67)
    {
      uint64_t v9 = (unint64_t *)(*(void *)v67 + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    if (v6) {
      uint64_t v11 = data_low;
    }
    else {
      uint64_t v11 = 2LL;
    }
    uint64_t v12 = +[NSDate date](&OBJC_CLASS___NSDate, "date");
    uint64_t v59 = 0LL;
    unint64_t v60 = 0LL;
    unint64_t v61 = 0LL;
    uint64_t v13 = v62;
    uint64_t v50 = v63;
    if (v62 == v63)
    {
LABEL_81:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      uint64_t v45 = qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68289026;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)uint64_t v67 = 2082;
        *(void *)&v67[2] = "";
        unint64_t v46 = "{msg%{public}.0s:Wifi Channel Histogram was not generated}";
        __n128 v47 = (os_log_s *)v45;
        uint32_t v48 = 18;
LABEL_85:
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, v46, buf, v48);
      }
    }

    else
    {
      uint64_t v14 = (uint64_t)v12;
      do
      {
        uint64_t v51 = v13;
        int v15 = (uint64_t *)(v13 + 24);
        memset(v57, 0, sizeof(v57));
        int v58 = 1065353216;
        if (v11)
        {
          uint64_t v16 = 0LL;
          while (1)
          {
            uint64_t v17 = *(void *)(a2 + 24);
            if (!v17) {
              sub_100008BDC();
            }
            double v18 = sub_10015AFB0(v14, ~(_DWORD)v16);
            std::to_string(&v52, v18);
            double v19 = sub_10015AFB0(v14, -(int)v16);
            std::to_string(&v53, v19);
            sub_100026B0C(a1[1], (uint64_t)v15, (uint64_t)&v52, (uint64_t)&v53, &v55);
            if (*(_OWORD *)v15 != 0LL)
            {
              uint64_t v20 = a1[1];
              *(_OWORD *)&v71.__r_.__value_.__l.__data_ = 0uLL;
              sub_100026B0C(v20, (uint64_t)&v71, (uint64_t)&v52, (uint64_t)&v53, buf);
              sub_1000BA964( (uint64_t *)&v55,  (uint64_t)v56,  *(uint64_t *)buf,  *(uint64_t *)v67,  0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)v67 - *(void *)buf) >> 3));
              v71.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
              sub_10003F8A8((void ***)&v71);
            }

            uint64_t v21 = v55;
            unint64_t v22 = v56;
            if (v55 != v56)
            {
              memset(&v71, 0, sizeof(v71));
              do
              {
                if (*((_DWORD *)v21 + 24) == 1)
                {
                  uint64_t v23 = v21[6];
                  if (!v23) {
                    uint64_t v23 = *(void *)(qword_1019A0818 + 16);
                  }
                  sub_100064FDC(buf, v23);
                  std::string::size_type size = v71.__r_.__value_.__l.__size_;
                  if (v71.__r_.__value_.__l.__size_ >= v71.__r_.__value_.__l.__cap_)
                  {
                    std::string::size_type v25 = sub_1000BB07C((uint64_t *)&v71, (uint64_t)buf);
                  }

                  else
                  {
                    sub_100064FDC(v71.__r_.__value_.__l.__size_, buf);
                    std::string::size_type v25 = size + 48;
                  }

                  v71.__r_.__value_.__l.__size_ = v25;
                  sub_100064FE0((wireless_diagnostics::google::protobuf::MessageLite *)buf);
                }

                v21 += 15;
              }

              while (v21 != v22);
              sub_1000ED690(v57, (uint64_t *)&v71);
              *(void *)uint64_t buf = &v71;
              sub_1000BAFF0((void ***)buf);
            }

            *(void *)uint64_t buf = &v55;
            sub_10003F8A8((void ***)buf);
            if (++v16 == v11) {
              goto LABEL_38;
            }
          }

          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181D000);
          }
          uint64_t v43 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)uint64_t v67 = 2082;
            *(void *)&v67[2] = "";
            __int16 v68 = 2082;
            uint64_t v69 = "MicroLocationAnalytics";
            _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:wifi channels analyitcs operation cancelled, Activity:%{public, location:escape_only}s}",  buf,  0x1Cu);
          }

          sub_100019CEC((uint64_t)v57);
          goto LABEL_86;
        }

LABEL_86:
    *(void *)uint64_t buf = &v59;
    sub_100050CAC((void ***)buf);
  }

  *(void *)uint64_t buf = &v62;
  sub_10003706C((void ***)buf);
}

        sub_100EDE8A8(v79);
        break;
    }
  }

  else
  {
    if (qword_101934830 != -1) {
      dispatch_once(&qword_101934830, &stru_101834AA8);
    }
    uint64_t v20 = (os_log_s *)qword_101934838;
    if (os_log_type_enabled((os_log_t)qword_101934838, OS_LOG_TYPE_DEBUG))
    {
      sub_100FE4F50((int *)a2, &buf);
      uint64_t v21 = SBYTE3(v87) >= 0 ? &buf : (void **)buf;
      *(_DWORD *)uint64_t v79 = 136315138;
      *(void *)&v79[4] = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "#locctl,#rec,recordMessage,CLMotionStateMediator_Type,unsupported message type,%s",  v79,  0xCu);
      if (SBYTE3(v87) < 0) {
        operator delete(buf);
      }
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_101934830 != -1) {
        dispatch_once(&qword_101934830, &stru_101834AA8);
      }
      unint64_t v22 = qword_101934838;
      sub_100FE4F50((int *)a2, v79);
      if (v80 >= 0) {
        uint64_t v23 = v79;
      }
      else {
        uint64_t v23 = *(uint8_t **)v79;
      }
      *(_DWORD *)unint64_t v70 = 136315138;
      *(void *)&v70[4] = v23;
      double v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v22,  2LL,  "#locctl,#rec,recordMessage,CLMotionStateMediator_Type,unsupported message type,%s",  v70);
      if (v80 < 0) {
        operator delete(*(void **)v79);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLLocationControllerRecorder::recordMessage(const CLLocationControllerRecorder_Types::MessageType &, const CLLocationControllerRecorder_Types::Silo &, const CLLocationControllerRecorder_Types::Silo &, const int &, const CLMotionStateMediator_Type::Notification &, const CLMotionStateMediator_Type::NotificationData &)",  "%s\n",  v19);
    }
  }

    double v91 = 0;
    goto LABEL_91;
  }

  memset(v455, 0, sizeof(v455));
  uint64_t v76 = v418;
  if (a2[1] != *a2)
  {
    uint64_t v77 = 0LL;
    uint64_t v78 = 0;
    while (1)
    {
      if (!a8)
      {
LABEL_124:
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10183C380);
        }
        uint64_t v93 = (os_log_s *)qword_101934A78;
        if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
        {
          sub_1003D1A48((unsigned int *)(*a2 + 32 * v77), buf);
          int v94 = buf;
          if (buf[23] < 0) {
            int v94 = *(_BYTE **)buf;
          }
          *(_DWORD *)v459 = 136315138;
          *(void *)&v459[4] = v94;
          _os_log_impl( (void *)&_mh_execute_header,  v93,  OS_LOG_TYPE_DEBUG,  "CELL_LOC: gsm cell, %s, re-querying",  v459,  0xCu);
          if ((buf[23] & 0x80000000) != 0) {
            operator delete(*(void **)buf);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_101934A70 != -1) {
            dispatch_once(&qword_101934A70, &stru_10183C380);
          }
          __n128 v110 = qword_101934A78;
          sub_1003D1A48((unsigned int *)(*a2 + 32 * v77), v459);
          __int128 v111 = v459;
          if (v459[23] < 0) {
            __int128 v111 = *(_BYTE **)v459;
          }
          LODWORD(__p) = 136315138;
          *(void *)((char *)&__p + 4) = v111;
          __n128 v112 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v110,  2LL,  "CELL_LOC: gsm cell, %s, re-querying",  (const char *)&__p);
          if ((v459[23] & 0x80000000) != 0) {
            operator delete(*(void **)v459);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLNetworkLocationProvider::queryLocations(const std::vector<CLTelephonyService_Type::Cell> &, const std: :vector<CLTelephonyService_Type::ScdmaCell> &, const std::vector<CLTelephonyService_Type::CdmaCell> &, const std::vector<CLTelephonyService_Type::LteCell> &, const std::vector<CLTelephonyService_Type::NrCell> &, cons t std::vector<CLMacAddress> &, BOOL, BOOL, const CLNetworkLocationRequest_Type::CLNetworkLocationRequestConfig &)",  "%s\n",  v112);
          if (v112 != buf) {
            free(v112);
          }
        }

        *(void *)v459 = *a2 + 32 * v77;
        double v95 = (_OWORD *)(*a2 + 32 * v77);
        __int128 v96 = (char *)v455[1];
        if (v455[1] >= v455[2])
        {
          uint64_t v99 = (char *)v455[0];
          uint64_t v100 = ((char *)v455[1] - (char *)v455[0]) >> 5;
          uint64_t v101 = v100 + 1;
          int v102 = (char *)v455[2] - (char *)v455[0];
          else {
            __n128 v103 = v101;
          }
          if (v103)
          {
            __n128 v104 = (char *)sub_10000835C((uint64_t)&v455[2], v103);
            uint64_t v99 = (char *)v455[0];
            __int128 v96 = (char *)v455[1];
          }

          else
          {
            __n128 v104 = 0LL;
          }

          uint64_t v105 = v95[1];
          __n128 v106 = &v104[32 * v100];
          *(_OWORD *)__n128 v106 = *v95;
          *((_OWORD *)v106 + 1) = v105;
          if (v96 == v99)
          {
            unint64_t v109 = &v104[32 * v100];
          }

          else
          {
            __n128 v107 = &v104[32 * v100];
            do
            {
              __int128 v108 = *((_OWORD *)v96 - 1);
              unint64_t v109 = v107 - 32;
              *((_OWORD *)v107 - 2) = *((_OWORD *)v96 - 2);
              *((_OWORD *)v107 - 1) = v108;
              v96 -= 32;
              v107 -= 32;
            }

            while (v96 != v99);
          }

          __int128 v98 = v106 + 32;
          v455[0] = v109;
          v455[1] = v106 + 32;
          v455[2] = &v104[32 * v103];
          if (v99) {
            operator delete(v99);
          }
        }

        else
        {
          uint64_t v97 = v95[1];
          *(_OWORD *)v455[1] = *v95;
          *((_OWORD *)v96 + 1) = v97;
          __int128 v98 = v96 + 32;
        }

        v455[1] = v98;
        goto LABEL_151;
      }

      uint64_t v79 = sub_1004A177C(v421);
      if (sub_10047E7E4(*(void *)(v79 + 32), *a2 + 32 * v77, (uint64_t)&v431))
      {
      }

      uint64_t v85 = sub_1004C2CAC(v421 + 168, (_DWORD *)(*a2 + 32 * v77));
      int v86 = v85;
      if (qword_101934A70 != -1) {
        dispatch_once(&qword_101934A70, &stru_10183C380);
      }
      double v87 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        sub_1003D1A48((unsigned int *)(*a2 + 32 * v77), v459);
        unint64_t v88 = v459;
        if (v459[23] < 0) {
          unint64_t v88 = *(_BYTE **)v459;
        }
        uint64_t v89 = Current - *(double *)(v86 + 64);
        *(_DWORD *)uint64_t buf = 136315650;
        *(void *)&uint8_t buf[4] = v88;
        *(_WORD *)&buf[12] = 2048;
        *(double *)&buf[14] = v89;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&buf[24] = 0x40AC200000000000LL;
        _os_log_impl( (void *)&_mh_execute_header,  v87,  OS_LOG_TYPE_DEBUG,  "CELL_LOC: gsm cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying",  buf,  0x20u);
        if ((v459[23] & 0x80000000) != 0) {
          operator delete(*(void **)v459);
        }
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934A70 != -1) {
          dispatch_once(&qword_101934A70, &stru_10183C380);
        }
        int v90 = qword_101934A78;
        sub_1003D1A48((unsigned int *)(*a2 + 32 * v77), &__p);
        double v91 = &__p;
        if (SHIBYTE(v458) < 0) {
          double v91 = (__int128 *)__p;
        }
        double v92 = Current - *(double *)(v86 + 64);
        *(_DWORD *)v459 = 136315650;
        *(void *)&v459[4] = v91;
        *(_WORD *)&v459[12] = 2048;
        *(double *)&v459[14] = v92;
        *(_WORD *)&v459[22] = 2048;
        *(void *)&v459[24] = 0x40AC200000000000LL;
        LODWORD(v417) = 32;
        __n128 v84 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v90,  2LL,  "CELL_LOC: gsm cell, %s, last queried %.3f ago (%.3fs minimum), not re-querying",  v459,  v417,  v418);
        if (SHIBYTE(v458) < 0) {
          operator delete((void *)__p);
        }
LABEL_122:
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "int CLNetworkLocationProvider::queryLocations(const std::vector<CLTelephonyService_Type::Cell> &, const std::v ector<CLTelephonyService_Type::ScdmaCell> &, const std::vector<CLTelephonyService_Type::CdmaCell> &, const std ::vector<CLTelephonyService_Type::LteCell> &, const std::vector<CLTelephonyService_Type::NrCell> &, const std: :vector<CLMacAddress> &, BOOL, BOOL, const CLNetworkLocationRequest_Type::CLNetworkLocationRequestConfig &)",  "%s\n",  v84);
        if (v84 != buf) {
          free(v84);
        }
      }

  double v31 = HIBYTE(v105);
  uint64_t v32 = HIBYTE(v105);
  if (v105 >= 0) {
    int v33 = HIBYTE(v105);
  }
  else {
    int v33 = *((void *)&__s1 + 1);
  }
  int v34 = qword_1019A16D8;
  if (byte_1019A16E7 >= 0) {
    int v34 = byte_1019A16E7;
  }
  if (v33 != v34) {
    goto LABEL_104;
  }
  if (byte_1019A16E7 >= 0) {
    uint64_t v35 = &qword_1019A16D0;
  }
  else {
    uint64_t v35 = (uint64_t *)qword_1019A16D0;
  }
  if (SHIBYTE(v105) < 0)
  {
    if (memcmp((const void *)__s1, v35, *((size_t *)&__s1 + 1)))
    {
      p_fInstance = (uint64_t *)&self->fInstance;
      unint64_t v37 = self->fInstance.__ptr_.__value_;
      goto LABEL_106;
    }

    goto LABEL_103;
  }

  if (!HIBYTE(v105))
  {
LABEL_103:
    sub_1007C90E4((uint64_t)self->fInstance.__ptr_.__value_);
    uint64_t v32 = HIBYTE(v105);
    goto LABEL_104;
  }

  uint64_t v36 = &__s1;
  while (*(unsigned __int8 *)v36 == *(unsigned __int8 *)v35)
  {
    uint64_t v36 = (__int128 *)((char *)v36 + 1);
    uint64_t v35 = (uint64_t *)((char *)v35 + 1);
    if (!--v31) {
      goto LABEL_103;
    }
  }

    goto LABEL_87;
  }

  if (v8 == 1 && *(double *)(v176 + 56) > 0.0 && v177 > 0.0 && vabdd_f64(v178, *(double *)(v176 + 48)) <= 10.0)
  {
    uint64_t v12 = objc_opt_new(&OBJC_CLASS___CLBarometerCalibrationAbsoluteAltitude);
    -[CLBarometerCalibrationAbsoluteAltitude setTimestamp:](v12, "setTimestamp:", *(double *)v176);
    -[CLBarometerCalibrationAbsoluteAltitude setAltitude:](v12, "setAltitude:", *(double *)(v176 + 48));
    -[CLContextManagerAbsoluteAltimeter capAccuracy:]( self,  "capAccuracy:",  vabdd_f64(*(double *)(v176 + 24), *(double *)(v176 + 48)));
    -[CLBarometerCalibrationAbsoluteAltitude setAccuracy:](v12, "setAccuracy:");
    -[CLBarometerCalibrationAbsoluteAltitude setPrecision:](v12, "setPrecision:", 5.0);
    -[CLBarometerCalibrationAbsoluteAltitude setStatusInfo:](v12, "setStatusInfo:", 2LL);
    unint64_t v70 = self->_lastAltitudeSentTimestamp;
    -[CLBarometerCalibrationAbsoluteAltitude timestamp](v12, "timestamp");
    if (v70 != v71)
    {
      -[CLBarometerCalibrationContextClient absoluteAltitudeUpdate:]( self->super._delegate,  "absoluteAltitudeUpdate:",  v12);
      -[CLBarometerCalibrationAbsoluteAltitude timestamp](v12, "timestamp");
      self->_lastAltitudeSentTimestamp = v72;
      self->_currentStatusInfo = 2LL;
      if (qword_1019346A0 != -1) {
        dispatch_once(&qword_1019346A0, &stru_10186C0F0);
      }
      int v73 = (os_log_s *)qword_1019346A8;
      if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_INFO))
      {
        -[CLBarometerCalibrationAbsoluteAltitude altitude](v12, "altitude");
        uint64_t v75 = v74;
        -[CLBarometerCalibrationAbsoluteAltitude accuracy](v12, "accuracy");
        uint64_t v77 = v76;
        -[CLBarometerCalibrationAbsoluteAltitude precision](v12, "precision");
        uint64_t v78 = self->_currentStatusInfo;
        uint64_t v79 = self->_lastAltitudeSentTimestamp;
        *(_DWORD *)uint64_t buf = 134219264;
        __int128 v197 = v75;
        __int16 v198 = 2048;
        __int128 v199 = v77;
        __int128 v200 = 2048;
        __int128 v201 = v80;
        unint64_t v202 = 1024;
        unint64_t v203 = v78;
        int v204 = 1024;
        int v205 = 1;
        __int128 v206 = 2048;
        __int128 v207 = v79;
        _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_INFO,  "absolute altitude sent to clients %f, accuracy %f, precision %f, status %d, altitude source %d, timestamp %f",  buf,  0x36u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019346A0 != -1) {
          dispatch_once(&qword_1019346A0, &stru_10186C0F0);
        }
        int v115 = qword_1019346A8;
        -[CLBarometerCalibrationAbsoluteAltitude altitude](v12, "altitude");
        uint64_t v117 = v116;
        -[CLBarometerCalibrationAbsoluteAltitude accuracy](v12, "accuracy");
        __n128 v119 = v118;
        -[CLBarometerCalibrationAbsoluteAltitude precision](v12, "precision");
        uint64_t v120 = self->_currentStatusInfo;
        uint64_t v121 = self->_lastAltitudeSentTimestamp;
        __int128 v184 = 134219264;
        uint64_t v185 = v117;
        unint64_t v186 = 2048;
        __int16 v187 = v119;
        unint64_t v188 = 2048;
        unint64_t v189 = v122;
        __int128 v190 = 1024;
        int v191 = v120;
        __int128 v192 = 1024;
        __int128 v193 = 1;
        __int128 v194 = 2048;
        __int128 v195 = v121;
        LODWORD(v175) = 54;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v115,  1LL,  "absolute altitude sent to clients %f, accuracy %f, precision %f, status %d, altitude source %d, timestamp %f",  COERCE_DOUBLE(&v184),  v175,  *(double *)&v176,  DWORD2(v176),  LODWORD(v177),  v178);
        uint64_t v124 = (uint8_t *)v123;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerAbsoluteAltimeter calculateAndSendAltitudeFromLocation]",  "%s\n",  v123);
        if (v124 != buf) {
          free(v124);
        }
      }

      if (vabdd_f64(self->_lastDefaultLevelLogTimestamp, CFAbsoluteTimeGetCurrent()) > 30.0)
      {
        if (qword_1019346A0 != -1) {
          dispatch_once(&qword_1019346A0, &stru_10186C0F0);
        }
        uint64_t v81 = (os_log_s *)qword_1019346A8;
        if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_DEFAULT))
        {
          -[CLBarometerCalibrationAbsoluteAltitude altitude](v12, "altitude");
          __int128 v83 = v82;
          -[CLBarometerCalibrationAbsoluteAltitude accuracy](v12, "accuracy");
          uint64_t v85 = v84;
          -[CLBarometerCalibrationAbsoluteAltitude precision](v12, "precision");
          int v86 = self->_currentStatusInfo;
          double v87 = self->_lastAltitudeSentTimestamp;
          *(_DWORD *)uint64_t buf = 134219264;
          __int128 v197 = v83;
          __int16 v198 = 2048;
          __int128 v199 = v85;
          __int128 v200 = 2048;
          __int128 v201 = v88;
          unint64_t v202 = 1024;
          unint64_t v203 = v86;
          int v204 = 1024;
          int v205 = 1;
          __int128 v206 = 2048;
          __int128 v207 = v87;
          _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_DEFAULT,  "absolute altitude sent to clients %f, accuracy %f, precision %f, status %d, altitude source %d, timestamp %f",  buf,  0x36u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019346A0 != -1) {
            dispatch_once(&qword_1019346A0, &stru_10186C0F0);
          }
          int v155 = qword_1019346A8;
          -[CLBarometerCalibrationAbsoluteAltitude altitude](v12, "altitude");
          __int128 v157 = v156;
          -[CLBarometerCalibrationAbsoluteAltitude accuracy](v12, "accuracy");
          __int128 v159 = v158;
          -[CLBarometerCalibrationAbsoluteAltitude precision](v12, "precision");
          __int128 v160 = self->_currentStatusInfo;
          uint64_t v161 = self->_lastAltitudeSentTimestamp;
          __int128 v184 = 134219264;
          uint64_t v185 = v157;
          unint64_t v186 = 2048;
          __int16 v187 = v159;
          unint64_t v188 = 2048;
          unint64_t v189 = v162;
          __int128 v190 = 1024;
          int v191 = v160;
          __int128 v192 = 1024;
          __int128 v193 = 1;
          __int128 v194 = 2048;
          __int128 v195 = v161;
          LODWORD(v175) = 54;
          _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v155,  0LL,  "absolute altitude sent to clients %f, accuracy %f, precision %f, status %d, altitude source %d, timestamp %f",  COERCE_DOUBLE(&v184),  v175,  *(double *)&v176,  DWORD2(v176),  LODWORD(v177),  v178);
          uint64_t v164 = (uint8_t *)v163;
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerAbsoluteAltimeter calculateAndSendAltitudeFromLocation]",  "%s\n",  v163);
          if (v164 != buf) {
            free(v164);
          }
        }

        self->_lastDefaultLevelLogTimestamp = CFAbsoluteTimeGetCurrent();
      }
    }

    goto LABEL_86;
  }

  if (qword_1019346A0 != -1) {
    dispatch_once(&qword_1019346A0, &stru_10186C0F0);
  }
  uint64_t v9 = (os_log_s *)qword_1019346A8;
  if (os_log_type_enabled((os_log_t)qword_1019346A8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "GPS too far from DEM, not updating altitude",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019346A0 != -1) {
      dispatch_once(&qword_1019346A0, &stru_10186C0F0);
    }
    LOWORD(v184) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019346A8,  1LL,  "GPS too far from DEM, not updating altitude",  &v184,  2);
    uint64_t v11 = (uint8_t *)v10;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "-[CLContextManagerAbsoluteAltimeter calculateAndSendAltitudeFromLocation]",  "%s\n",  v10);
    if (v11 != buf) {
      free(v11);
    }
  }

  *(_DWORD *)(a1 + 396) |= 0x4000u;
  int v33 = *(char **)(a1 + 112);
  if (!v33)
  {
    int v33 = (char *)operator new(0x28uLL);
    *(void *)int v33 = off_101875CA8;
    *(_OWORD *)(v33 + 8) = 0u;
    *(_OWORD *)(v33 + 24) = 0u;
    *(void *)(a1 + 112) = v33;
  }

  int v34 = *(void *)(a2 + 112);
  if (!v34) {
    int v34 = *(void *)(qword_1019A1D38 + 112);
  }
  sub_100BB92C4((uint64_t)v33, v34);
  BOOL v7 = *(_DWORD *)(a2 + 396);
  if ((v7 & 0x8000) != 0)
  {
LABEL_91:
    *(_DWORD *)(a1 + 396) |= 0x8000u;
    uint64_t v35 = *(void **)(a1 + 120);
    if (!v35)
    {
      uint64_t v35 = operator new(0x20uLL);
      void *v35 = off_101875528;
      v35[1] = &wireless_diagnostics::google::protobuf::internal::kEmptyString;
      v35[2] = 0LL;
      *((_DWORD *)v35 + 6) = 0;
      *(void *)(a1 + 120) = v35;
    }

    uint64_t v36 = *(void *)(a2 + 120);
    if (!v36) {
      uint64_t v36 = *(void *)(qword_1019A1D38 + 120);
    }
    sub_100BB93AC((uint64_t)v35, v36);
    BOOL v7 = *(_DWORD *)(a2 + 396);
  }

  uint64_t v23 = *(void *)(v5 + 168);
  if (!v23) {
    uint64_t v23 = *(void *)(qword_1019A1D48 + 168);
  }
  unint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x2B,  v23,  a2,  a4);
  int v6 = *(_DWORD *)(v5 + 224);
  if ((v6 & 0x800000) == 0)
  {
LABEL_25:
    if ((v6 & 0x1000000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_92;
  }

    goto LABEL_87;
  }

      ;
    }

    while (v8 != v30);
  }

  return result;
}

  unint64_t v44 = *(void *)(a2 + 152);
  v5 |= 0x40000uLL;
  *id v2 = v5;
  *(void *)(a1 + 152) = v44;
  uint64_t v4 = *v3;
  if ((*v3 & 0x20000) == 0)
  {
LABEL_44:
    if ((v4 & 0x80) == 0) {
      goto LABEL_45;
    }
    goto LABEL_88;
  }

  PB::TextFormatter::format(this, "sosConsideredIOSTime", *(double *)(a1 + 304));
  int v6 = *v5;
  if ((*v5 & 0x4000000000LL) == 0)
  {
LABEL_41:
    if ((v6 & 0x8000000000LL) == 0) {
      goto LABEL_42;
    }
    goto LABEL_88;
  }

  unint64_t result = PB::Writer::writeVarInt(this, *(void *)(v3 + 144), 0x57u);
  CFStringRef v5 = *v4;
  if ((*v4 & 0x80) == 0)
  {
LABEL_42:
    if ((v5 & 0x1000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_88;
  }

  unint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 394), 0x35u);
  uint64_t v4 = *(_DWORD *)(v3 + 396);
  if ((v4 & 0x200000) == 0)
  {
LABEL_27:
    if ((v4 & 0x800000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_88;
  }

  unint64_t result = *(float *)(a2 + 92);
  v3 |= 0x40000uLL;
  *(void *)(a1 + 216) = v3;
  *(float *)(a1 + 92) = result;
  id v2 = *(void *)(a2 + 216);
  if ((v2 & 0x20000000) == 0)
  {
LABEL_40:
    if ((v2 & 0x800000000LL) == 0) {
      goto LABEL_41;
    }
    goto LABEL_88;
  }

  PB::TextFormatter::format(this, "swingAngle", *(float *)(a1 + 156));
  CFStringRef v5 = *(void *)(a1 + 216);
  if ((v5 & 0x800000000LL) == 0)
  {
LABEL_37:
    if ((v5 & 0x1000000000LL) == 0) {
      goto LABEL_38;
    }
    goto LABEL_88;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 136), 0x24u);
  uint64_t v4 = *(void *)(v3 + 216);
  if ((v4 & 0x800000000LL) == 0)
  {
LABEL_38:
    if ((v4 & 0x400000000LL) == 0) {
      goto LABEL_39;
    }
    goto LABEL_88;
  }

  unint64_t result = *(float *)(a2 + 100);
  v5 |= 0x4000uLL;
  *id v2 = v5;
  *(_BYTE *)(a1 + 324) = v6;
  *(float *)(a1 + 100) = result;
  BOOL v7 = *v3;
  uint64_t v4 = *(_BYTE *)(a2 + 324);
  if ((*v3 & 0x400000) == 0)
  {
LABEL_21:
    if ((v7 & 0x2000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_88;
  }

  PB::TextFormatter::format(this, "deltaVZBiggestImpact", *(float *)(a1 + 132));
  int v6 = *v5;
  BOOL v7 = *(_BYTE *)(a1 + 324);
  if ((*v5 & 0x800000) == 0)
  {
LABEL_20:
    if ((v6 & 0x1000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_88;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 100), 0x10u);
  int v6 = *v4;
  CFStringRef v5 = *((_BYTE *)v4 + 8);
  if ((*v4 & 0x400000) == 0)
  {
LABEL_21:
    if ((v6 & 0x2000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_88;
  }

  int v15 = *(_DWORD *)(a2 + 84);
  v5 |= 0x40000uLL;
  *id v2 = v5;
  *(_WORD *)(a1 + 288) = v6;
  *(_DWORD *)(a1 + 84) = v15;
  uint64_t v4 = *v3;
  BOOL v7 = *(_WORD *)(a2 + 288);
  if ((v7 & 0x100) == 0)
  {
LABEL_13:
    if ((v7 & 8) == 0) {
      goto LABEL_14;
    }
    goto LABEL_88;
  }

  PB::TextFormatter::format(this, "audioDvEnergyThresholdCenter", *(float *)(a1 + 40));
  int v6 = *v5;
  BOOL v7 = *(_WORD *)(a1 + 288);
  if ((*v5 & 0x100) == 0)
  {
LABEL_12:
    if ((v6 & 0x200) == 0) {
      goto LABEL_13;
    }
    goto LABEL_88;
  }

  unint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 268), 7u);
  CFStringRef v5 = *v4;
  int v6 = *((_WORD *)v4 + 4);
  if ((*v4 & 0x40000) == 0)
  {
LABEL_12:
    if ((v6 & 0x100) == 0) {
      goto LABEL_13;
    }
    goto LABEL_88;
  }

  unint64_t result = *(float *)(a2 + 44);
  v3 |= 0x20uLL;
  *(void *)(a1 + 172) = v3;
  *(float *)(a1 + 44) = result;
  id v2 = *(void *)(a2 + 172);
  if ((v2 & 0x40) == 0)
  {
LABEL_43:
    if ((v2 & 0x80) == 0) {
      goto LABEL_44;
    }
    goto LABEL_88;
  }

  PB::TextFormatter::format(this, "passThru", *(_BYTE *)(a1 + 167));
  CFStringRef v5 = *(void *)(a1 + 172);
  if ((v5 & 0x10000000) == 0)
  {
LABEL_40:
    if ((v5 & 0x200000000000LL) == 0) {
      goto LABEL_41;
    }
    goto LABEL_88;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 48), 0xCFu);
  uint64_t v4 = *(void *)(v3 + 172);
  if ((v4 & 0x80) == 0)
  {
LABEL_41:
    if ((v4 & 1) == 0) {
      goto LABEL_42;
    }
    goto LABEL_88;
  }

  LODWORD(v4) = *(_DWORD *)(a2 + 56);
  v3 |= 0x200uLL;
  *(void *)(a1 + 184) = v3;
  *(_DWORD *)(a1 + 56) = v4;
  id v2 = *(void *)(a2 + 184);
  if ((v2 & 0x400000) == 0)
  {
LABEL_44:
    if ((v2 & 0x800000) == 0) {
      goto LABEL_45;
    }
    goto LABEL_88;
  }

  PB::TextFormatter::format(this, "terminationReason", *(_DWORD *)(a1 + 152));
  CFStringRef v5 = *(void *)(a1 + 184);
  if ((v5 & 0x400000000LL) == 0)
  {
LABEL_41:
    if ((v5 & 0x800000000LL) == 0) {
      goto LABEL_42;
    }
    goto LABEL_88;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 108), 0x28u);
  uint64_t v4 = *(void *)(v3 + 184);
  if ((v4 & 0x800000) == 0)
  {
LABEL_42:
    if ((v4 & 0x1000000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_88;
  }

  unint64_t v37 = *(_BYTE *)(a2 + 183);
  v3 |= 0x200000000000uLL;
  *(void *)(result + 188) = v3;
  *(_BYTE *)(result + 183) = v37;
  id v2 = *(void *)(a2 + 188);
  if ((v2 & 0x800) == 0)
  {
LABEL_39:
    if ((v2 & 0x1000) == 0) {
      goto LABEL_40;
    }
    goto LABEL_88;
  }

  PB::TextFormatter::format(this, "srcUserAccelInertial_Y", *(float *)(a1 + 120));
  CFStringRef v5 = *(void *)(a1 + 188);
  if ((v5 & 0x10000000) == 0)
  {
LABEL_36:
    if ((v5 & 0x20000000) == 0) {
      goto LABEL_37;
    }
    goto LABEL_88;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 56), 0x23u);
  uint64_t v4 = *(void *)(v3 + 188);
  if ((v4 & 0x1000) == 0)
  {
LABEL_37:
    if ((v4 & 0x100000000000LL) == 0) {
      goto LABEL_38;
    }
    goto LABEL_88;
  }

void sub_1000B4AD0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, void *__p, uint64_t a37, uint64_t a38, char a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char a45, uint64_t a46, uint64_t a47, char a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55)
{
  a17 = &a45;
  sub_100050CAC((void ***)&a17);
  a17 = &a48;
  sub_10003706C((void ***)&a17);
  _Unwind_Resume(a1);
}

void sub_1000B4C64(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  unsigned int v6 = *(_DWORD *)(a1 + 32);
  if (!sub_1000641E0(v6)) {
    __assert_rtn("set_type", "microlocation.pb.h", 21547, "::CLMicroLocationProto::ConfigurationType_IsValid(value)");
  }
  int v7 = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 40) = v6;
  *(_DWORD *)(a2 + 48) = v7 | 3;
  *(double *)(a2 + 8) = a3;
  sub_100101CF8(a2, a1);
}

void sub_1000B4CF4(_Unwind_Exception *a1)
{
}

void sub_1000B4D08(uint64_t a1, uint64_t a2)
{
  if ((sub_1000B31D4() & 1) != 0)
  {
    sub_10001A504((uint64_t)v20, a2);
    sub_1000B4F7C(a1, (uint64_t)v20, &v12);
    uint64_t v4 = v21;
    if (v21 == v20)
    {
      uint64_t v5 = 4LL;
      uint64_t v4 = v20;
    }

    else
    {
      if (!v21)
      {
LABEL_11:
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181D000);
        }
        int v7 = (os_log_s *)qword_1019348D8;
        BOOL v8 = os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT);
        uint64_t v9 = v12;
        unint64_t v10 = v13;
        if (v8)
        {
          *(_DWORD *)uint64_t buf = 68289282;
          int v15 = 0;
          __int16 v16 = 2082;
          uint64_t v17 = "";
          __int16 v18 = 2050;
          uint64_t v19 = v13 - v12;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:sending CoreAnalytics com.apple.MicroLocation.AssociatedState, num events:%{public}lu}",  buf,  0x1Cu);
        }

        if (v9 != v10)
        {
          uint64_t v11 = v9;
          do
            AnalyticsSendEvent(@"com.apple.MicroLocation.AssociatedState", *v11++);
          while (v11 != v10);
        }

        if (v9) {
          operator delete(v9);
        }
        return;
      }

      uint64_t v5 = 5LL;
    }

    (*(void (**)(void))(*v4 + 8 * v5))();
    goto LABEL_11;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  unsigned int v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289026;
    int v15 = 0;
    __int16 v16 = 2082;
    uint64_t v17 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:not analyzing associated state, since sending to core-analytics is disabled}",  buf,  0x12u);
  }

void sub_1000B4F28( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, char *a21)
{
  uint64_t v23 = a21;
  if (a21 == v21)
  {
    uint64_t v24 = 4LL;
    uint64_t v23 = &a18;
  }

  else
  {
    if (!a21) {
      goto LABEL_6;
    }
    uint64_t v24 = 5LL;
  }

  (*(void (**)(void))(*(void *)v23 + 8 * v24))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void sub_1000B4F7C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  unsigned int v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t buf = 68289026LL;
    *(_WORD *)uint64_t v85 = 2082;
    *(void *)&v85[2] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:analyzing associated state}",  buf,  0x12u);
  }

  sub_10002EF58(*(void *)(a1 + 8), &v80);
  if (v80 == v81)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    unint64_t v60 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(void *)uint64_t buf = 68289026LL;
      *(_WORD *)uint64_t v85 = 2082;
      *(void *)&v85[2] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:analyzeAssociationState, no LOI IDs found}",  buf,  0x12u);
    }

    *a3 = 0LL;
    a3[1] = 0LL;
    a3[2] = 0LL;
  }

  else
  {
    sub_1002F0B04(buf);
    CFStringRef v7 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsNumberDaysToAnalyzeAssociationState",  0x8000100u,  kCFAllocatorNull);
    int v8 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v7, &v65);
    CFRelease(v7);
    uint64_t data_low = LODWORD(v65.__r_.__value_.__l.__data_);
    unint64_t v10 = *(std::__shared_weak_count **)v85;
    if (*(void *)v85)
    {
      uint64_t v11 = (unint64_t *)(*(void *)v85 + 8LL);
      do
        unint64_t v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }

    if (v8) {
      uint64_t v13 = data_low;
    }
    else {
      uint64_t v13 = 7LL;
    }
    uint64_t v14 = +[NSDate date](&OBJC_CLASS___NSDate, "date");
    uint64_t v79 = 0LL;
    __int128 v15 = 0uLL;
    *(_OWORD *)uint64_t v78 = 0u;
    __int16 v16 = (char *)v80;
    uint64_t v64 = v81;
    if (v80 == v81)
    {
      uint64_t v62 = 0LL;
LABEL_136:
      *(_OWORD *)a3 = v15;
      a3[2] = v62;
    }

    else
    {
      uint64_t v17 = (uint64_t)v14;
      uint64_t v63 = a3;
      while (1)
      {
        uint64_t v75 = 0LL;
        uint64_t v76 = 0LL;
        uint64_t v77 = 0LL;
        uint64_t v72 = 0LL;
        int v73 = 0LL;
        uint64_t v74 = 0LL;
        if (v13) {
          break;
        }
        __int128 v83 = (void **)v16;
LABEL_55:
        if (v73 != v72)
        {
          sub_1000B5BF8((uint64_t)&v83, &v72, (uint64_t)&v65);
          if (v69)
          {
            uint64_t v32 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
            -[NSMutableDictionary setObject:forKeyedSubscript:]( v32,  "setObject:forKeyedSubscript:",  &off_1018D3038,  @"Band");
            if (!v69
              || ((v65.__r_.__value_.__s.__size_ & 0x80u) == 0
                ? (int v33 = &v65)
                : (int v33 = (std::string *)v65.__r_.__value_.__r.__words[0]),
                  (-[NSMutableDictionary setObject:forKeyedSubscript:]( v32,  "setObject:forKeyedSubscript:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v33),  @"rtLoiType"),  !v69)
               || (-[NSMutableDictionary setObject:forKeyedSubscript:]( v32,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v66),  @"NumberOfMacAddresses"),  !v69)
               || (-[NSMutableDictionary setObject:forKeyedSubscript:]( v32,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v67),  @"NumberOfChannels"),  !v69)))
            {
              sub_100036CD8();
            }

            -[NSMutableDictionary setObject:forKeyedSubscript:]( v32,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v68),  @"NumberOfMacAddressAppearingOnMultipleChannels");
            int v34 = (char *)v78[1];
            if (v78[1] >= v79)
            {
              int64_t v36 = ((char *)v78[1] - (char *)v78[0]) >> 3;
              unint64_t v37 = (v79 - (char *)v78[0]) >> 2;
              if (v37 <= v36 + 1) {
                unint64_t v37 = v36 + 1;
              }
              else {
                unint64_t v38 = v37;
              }
              if (v38) {
                double v39 = (char *)sub_1000071BC((uint64_t)&v79, v38);
              }
              else {
                double v39 = 0LL;
              }
              unint64_t v44 = (NSMutableDictionary **)&v39[8 * v36];
              os_log_s *v44 = v32;
              uint64_t v35 = v44 + 1;
              unint64_t v46 = (char *)v78[0];
              uint64_t v45 = (char *)v78[1];
              if (v78[1] != v78[0])
              {
                do
                {
                  __n128 v47 = (NSMutableDictionary *)*((void *)v45 - 1);
                  v45 -= 8;
                  *--unint64_t v44 = v47;
                }

                while (v45 != v46);
                uint64_t v45 = (char *)v78[0];
              }

              v78[0] = v44;
              v78[1] = v35;
              uint64_t v79 = &v39[8 * v38];
              if (v45) {
                operator delete(v45);
              }
            }

            else
            {
              *(void *)v78[1] = v32;
              uint64_t v35 = v34 + 8;
            }

            v78[1] = v35;
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181D000);
            }
            uint32_t v48 = (os_log_s *)qword_1019348D8;
            if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v49 = operator new(0x28uLL);
              __int128 __p = v49;
              __int128 v71 = xmmword_1012C8460;
              *uint64_t v49 = 0u;
              v49[1] = 0u;
              *(void *)((char *)v49 + 29) = 0LL;
              sub_10000AE6C((uint64_t)v16, v49);
              if (!v69) {
                sub_100036CD8();
              }
              if (v71 >= 0) {
                p_p = (const char *)&__p;
              }
              else {
                p_p = (const char *)__p;
              }
              uint64_t v51 = &v65;
              if ((v65.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                uint64_t v51 = (std::string *)v65.__r_.__value_.__r.__words[0];
              }
              *(void *)uint64_t buf = 68290563LL;
              *(_WORD *)uint64_t v85 = 2082;
              *(void *)&v85[2] = "";
              __int16 v86 = 2081;
              double v87 = p_p;
              __int16 v88 = 2082;
              uint64_t v89 = v51;
              __int16 v90 = 1026;
              int v91 = 5;
              __int16 v92 = 2050;
              uint64_t v93 = v66;
              __int16 v94 = 2050;
              uint64_t v95 = v67;
              __int16 v96 = 2050;
              uint64_t v97 = v68;
              _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationAnalytics, analyzeAssociationState, rtGroupLoiId:%{private, location:escape_only}s, rtLoiType:%{public, location:escape_only}s, Band:%{public}d, numberOfM acAddresses:%{public}llu, NumberOfChannels:%{public}llu, NumberOfMacAddressAppearingOnMultipleCh annels:%{public}llu}",  buf,  0x4Au);
              if (SHIBYTE(v71) < 0) {
                operator delete(__p);
              }
            }
          }
        }

        *(void *)uint64_t buf = &v72;
        sub_1000BB320((void ***)buf);
        *(void *)uint64_t buf = &v75;
        sub_1000BB320((void ***)buf);
        v16 += 16;
        if (v16 == v64)
        {
          __int128 v15 = *(_OWORD *)v78;
          uint64_t v62 = v79;
          a3 = v63;
          goto LABEL_136;
        }
      }

      uint64_t v18 = 0LL;
      while (1)
      {
        uint64_t v19 = *(void *)(a2 + 24);
        if (!v19) {
          sub_100008BDC();
        }
        double v20 = sub_10015AFB0(v17, ~(_DWORD)v18);
        std::to_string((std::string *)buf, v20);
        double v21 = sub_10015AFB0(v17, -(int)v18);
        std::to_string(&v65, v21);
        sub_10002F22C(*(void *)(a1 + 8), (uint64_t)buf, (uint64_t)&v65, *(void *)v16, *((void *)v16 + 1), &__p);
        uint64_t v23 = __p;
        unint64_t v22 = (_DWORD *)v71;
        if (__p != (void *)v71)
        {
          unint64_t v82 = &v75;
          do
          {
            if (*((_BYTE *)v23 + 48)) {
              BOOL v24 = v23[16] == 2;
            }
            else {
              BOOL v24 = 0;
            }
            if (v24) {
              sub_1000BB3AC((uint64_t **)&v82, (__int128 *)v23);
            }
            v23 += 18;
          }

          while (v23 != v22);
          uint64_t v26 = __p;
          std::string::size_type v25 = (_DWORD *)v71;
          unint64_t v82 = &v72;
          while (v26 != v25)
          {
            if (*((_BYTE *)v26 + 48)) {
              BOOL v27 = v26[16] == 5;
            }
            else {
              BOOL v27 = 0;
            }
            if (v27) {
              sub_1000BB3AC((uint64_t **)&v82, (__int128 *)v26);
            }
            v26 += 18;
          }
        }

        __int128 v83 = &__p;
        sub_1000BB320(&v83);
        if (SBYTE3(v87) < 0) {
          operator delete(*(void **)buf);
        }
        if (++v18 == v13)
        {
          __int128 v83 = (void **)v16;
          if (v76 != v75)
          {
            sub_1000B5BF8((uint64_t)&v83, &v75, (uint64_t)&v65);
            if (v69)
            {
              uint64_t v28 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
              -[NSMutableDictionary setObject:forKeyedSubscript:]( v28,  "setObject:forKeyedSubscript:",  &off_1018D3020,  @"Band");
              if (!v69
                || ((v65.__r_.__value_.__s.__size_ & 0x80u) == 0
                  ? (int v29 = &v65)
                  : (int v29 = (std::string *)v65.__r_.__value_.__r.__words[0]),
                    (-[NSMutableDictionary setObject:forKeyedSubscript:]( v28,  "setObject:forKeyedSubscript:",  +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v29),  @"rtLoiType"),  !v69)
                 || (-[NSMutableDictionary setObject:forKeyedSubscript:]( v28,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v66),  @"NumberOfMacAddresses"),  !v69)
                 || (-[NSMutableDictionary setObject:forKeyedSubscript:]( v28,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v67),  @"NumberOfChannels"),  !v69)))
              {
                sub_100036CD8();
              }

              -[NSMutableDictionary setObject:forKeyedSubscript:]( v28,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v68),  @"NumberOfMacAddressAppearingOnMultipleChannels");
              int v30 = (char *)v78[1];
              if (v78[1] >= v79)
              {
                int64_t v40 = ((char *)v78[1] - (char *)v78[0]) >> 3;
                unint64_t v41 = (v79 - (char *)v78[0]) >> 2;
                if (v41 <= v40 + 1) {
                  unint64_t v41 = v40 + 1;
                }
                else {
                  unint64_t v42 = v41;
                }
                if (v42) {
                  uint64_t v43 = (char *)sub_1000071BC((uint64_t)&v79, v42);
                }
                else {
                  uint64_t v43 = 0LL;
                }
                std::string v52 = (NSMutableDictionary **)&v43[8 * v40];
                void *v52 = v28;
                double v31 = v52 + 1;
                int v54 = (char *)v78[0];
                std::string v53 = (char *)v78[1];
                if (v78[1] != v78[0])
                {
                  do
                  {
                    uint64_t v55 = (NSMutableDictionary *)*((void *)v53 - 1);
                    v53 -= 8;
                    *--std::string v52 = v55;
                  }

                  while (v53 != v54);
                  std::string v53 = (char *)v78[0];
                }

                v78[0] = v52;
                v78[1] = v31;
                uint64_t v79 = &v43[8 * v42];
                if (v53) {
                  operator delete(v53);
                }
              }

              else
              {
                *(void *)v78[1] = v28;
                double v31 = v30 + 8;
              }

              v78[1] = v31;
              if (qword_1019348D0 != -1) {
                dispatch_once(&qword_1019348D0, &stru_10181D000);
              }
              __int128 v56 = (os_log_s *)qword_1019348D8;
              if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
              {
                BOOL v57 = operator new(0x28uLL);
                __int128 __p = v57;
                __int128 v71 = xmmword_1012C8460;
                *BOOL v57 = 0u;
                v57[1] = 0u;
                *(void *)((char *)v57 + 29) = 0LL;
                sub_10000AE6C((uint64_t)v16, v57);
                if (!v69) {
                  sub_100036CD8();
                }
                if (v71 >= 0) {
                  int v58 = (const char *)&__p;
                }
                else {
                  int v58 = (const char *)__p;
                }
                uint64_t v59 = &v65;
                if ((v65.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  uint64_t v59 = (std::string *)v65.__r_.__value_.__r.__words[0];
                }
                *(void *)uint64_t buf = 68290563LL;
                *(_WORD *)uint64_t v85 = 2082;
                *(void *)&v85[2] = "";
                __int16 v86 = 2081;
                double v87 = v58;
                __int16 v88 = 2082;
                uint64_t v89 = v59;
                __int16 v90 = 1026;
                int v91 = 2;
                __int16 v92 = 2050;
                uint64_t v93 = v66;
                __int16 v94 = 2050;
                uint64_t v95 = v67;
                __int16 v96 = 2050;
                uint64_t v97 = v68;
                _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationAnalytics, analyzeAssociationState, rtGroupLoiId:%{private , location:escape_only}s, rtLoiType:%{public, location:escape_only}s, Band:%{public}d, numbe rOfMacAddresses:%{public}llu, NumberOfChannels:%{public}llu, NumberOfMacAddressAppearingOnMult ipleChannels:%{public}llu}",  buf,  0x4Au);
                if (SHIBYTE(v71) < 0) {
                  operator delete(__p);
                }
              }
            }
          }

          goto LABEL_55;
        }
      }

      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      unint64_t v61 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)uint64_t buf = 68289282LL;
        *(_WORD *)uint64_t v85 = 2082;
        *(void *)&v85[2] = "";
        __int16 v86 = 2082;
        double v87 = "MicroLocationAnalytics";
        _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:analyzeAssociationState cancelled, Activity:%{public, location:escape_only}s}",  buf,  0x1Cu);
      }

      *uint64_t v63 = 0LL;
      v63[1] = 0LL;
      v63[2] = 0LL;
      *(void *)uint64_t buf = &v72;
      sub_1000BB320((void ***)buf);
      *(void *)uint64_t buf = &v75;
      sub_1000BB320((void ***)buf);
      if (v78[0])
      {
        v78[1] = v78[0];
        operator delete(v78[0]);
      }
    }
  }

  if (v80)
  {
    uint64_t v81 = (char *)v80;
    operator delete(v80);
  }

void sub_1000B5ACC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, char a33, uint64_t a34, uint64_t a35, char a36, uint64_t a37, uint64_t a38, void *a39, uint64_t a40, uint64_t a41, void *a42, uint64_t a43)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (a26 && a22 < 0) {
    operator delete(a17);
  }
  *(void *)(v43 - 192) = &a33;
  sub_1000BB320((void ***)(v43 - 192));
  *(void *)(v43 - 192) = &a36;
  sub_1000BB320((void ***)(v43 - 192));
  if (a39)
  {
    a40 = (uint64_t)a39;
    operator delete(a39);
  }

  if (a42)
  {
    a43 = (uint64_t)a42;
    operator delete(a42);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_1000B5BF8@<X0>(uint64_t result@<X0>, unsigned __int8 **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (v5 == *a2)
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 48) = 0;
  }

  else
  {
    unsigned int v6 = (uint64_t *)result;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    int v30 = 1065353216;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    int v27 = 1065353216;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    int v24 = 1065353216;
    do
    {
      sub_1000B9764((uint64_t)&v28, v4, (uint64_t)v4);
      CFStringRef v7 = (int *)(v4 + 56);
      __p.__r_.__value_.__r.__words[0] = sub_1005B46E8((uint64_t)v7);
      *(void *)uint64_t buf = &__p;
      int v8 = (uint64_t **)sub_1000B9A80((uint64_t)&v22, (unint64_t *)&__p, (uint64_t)&unk_1012CF090, (uint64_t **)buf);
      v7 += 3;
      sub_10004A8FC(v8 + 3, v7, v7);
      sub_1000B9D1C((uint64_t)&v25, v7, v7);
      uint64_t v4 = (unsigned __int8 *)(v7 + 1);
    }

    while (v4 != v5);
    if (*((void *)&v29 + 1) <= 1uLL)
    {
      else {
        std::string __p = *(std::string *)(v29 + 16);
      }
      uint64_t v17 = (void *)v23;
      if ((void)v23)
      {
        uint64_t v18 = 0LL;
        do
        {
          if (v17[5] > 1uLL) {
            ++v18;
          }
          uint64_t v17 = (void *)*v17;
        }

        while (v17);
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      uint64_t v19 = *((void *)&v23 + 1);
      uint64_t v20 = *((void *)&v26 + 1);
      else {
        *(std::string *)uint64_t buf = __p;
      }
      *(void *)&buf[24] = v19;
      *(void *)&buf[32] = v20;
      *(_OWORD *)a3 = *(_OWORD *)buf;
      *(void *)(a3 + 16) = *(void *)&buf[16];
      *(void *)(a3 + 40) = v18;
      *(_OWORD *)(a3 + 24) = *(_OWORD *)&buf[24];
      *(_BYTE *)(a3 + 48) = 1;
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      uint64_t v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = *v6;
        uint64_t v11 = (char *)operator new(0x28uLL);
        *(void *)(v11 + 29) = 0LL;
        *(_OWORD *)uint64_t v11 = 0u;
        *((_OWORD *)v11 + 1) = 0u;
        sub_10000AE6C(v10, v11);
        sub_1000B9644((uint64_t)&v28, ",", &__p);
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          p_p = &__p;
        }
        else {
          p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(void *)uint64_t buf = 68289538LL;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2082;
        *(void *)&buf[20] = v11;
        *(_WORD *)&_BYTE buf[28] = 2082;
        *(void *)&buf[30] = p_p;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:analyzeAssociationState, loiGroupId without unique rtLoiType, LoiGroupId:%{public , location:escape_only}s, LoiTypes:%{public, location:escape_only}s}",  buf,  0x26u);
        operator delete(v11);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181D000);
        }
      }

      uint64_t v13 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        uint64_t v14 = *v6;
        __int128 v15 = (char *)operator new(0x28uLL);
        *(void *)(v15 + 29) = 0LL;
        *(_OWORD *)__int128 v15 = 0u;
        *((_OWORD *)v15 + 1) = 0u;
        sub_10000AE6C(v14, v15);
        sub_1000B9644((uint64_t)&v28, ",", &__p);
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          __int16 v16 = &__p;
        }
        else {
          __int16 v16 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(void *)uint64_t buf = 68289538LL;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2082;
        *(void *)&buf[20] = v15;
        *(_WORD *)&_BYTE buf[28] = 2082;
        *(void *)&buf[30] = v16;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "analyzeAssociationState, loiGroupId without unique rtLoiType",  "{msg%{public}.0s:analyzeAssociationState, loiGroupId without unique rtLoiType, LoiGroupId:%{public , location:escape_only}s, LoiTypes:%{public, location:escape_only}s}",  buf,  0x26u);
        operator delete(v15);
      }

      *(_BYTE *)a3 = 0;
      *(_BYTE *)(a3 + 48) = 0;
    }

    sub_1000B9F34((uint64_t)&v22);
    sub_100019CEC((uint64_t)&v25);
    return sub_10004AD90((uint64_t)&v28);
  }

  return result;
}

void sub_1000B6014( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_1000B9F34((uint64_t)&a16);
  sub_100019CEC((uint64_t)&a22);
  sub_10004AD90((uint64_t)&a28);
  _Unwind_Resume(a1);
}

void sub_1000B6084(uint64_t a1, uint64_t a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v40 = 2082;
    unint64_t v41 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:analyzing LOI usage}",  buf,  0x12u);
  }

  if ((sub_1000B31D4() & 1) != 0)
  {
    uint64_t v5 = *(void *)(a2 + 24);
    if (!v5) {
      sub_100008BDC();
    }
    if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 48LL))(v5))
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      uint64_t v6 = qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v40 = 2082;
        unint64_t v41 = "";
        __int16 v42 = 2082;
        uint64_t v43 = "MicroLocationAnalytics";
        CFStringRef v7 = "{msg%{public}.0s:LOI usage analytics canceled, Activity:%{public, location:escape_only}s}";
        int v8 = (os_log_s *)v6;
        uint32_t v9 = 28;
LABEL_16:
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, buf, v9);
        return;
      }

      return;
    }

    id v11 = sub_1000B6680(a1);
    if (v11)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      unint64_t v12 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = (const char *)[@"com.apple.MicroLocation.Visit" UTF8String];
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v40 = 2082;
        unint64_t v41 = "";
        __int16 v42 = 2082;
        uint64_t v43 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Sending analytics event., Event name:%{public, location:escape_only}s}",  buf,  0x1Cu);
      }

      AnalyticsSendEvent(@"com.apple.MicroLocation.Visit", v11);
    }

    int64_t v36 = 0LL;
    unint64_t v37 = 0LL;
    unint64_t v38 = 0LL;
    sub_100029334(*(void *)(a1 + 8), &v34);
    uint64_t v14 = v34;
    uint64_t v15 = v35;
    if (v34 == v35)
    {
LABEL_45:
      *(void *)uint64_t buf = &v34;
      sub_10003706C((void ***)buf);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      __int128 v29 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        int v30 = (const char *)[@"com.apple.MicroLocation.Location" UTF8String];
        *(_DWORD *)uint64_t buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v40 = 2082;
        unint64_t v41 = "";
        __int16 v42 = 2082;
        uint64_t v43 = v30;
        __int16 v44 = 2050;
        uint64_t v45 = (v37 - v36) >> 3;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Sending analytics events., Event name:%{public, location:escape_only}s, Number of events:%{public}lu}",  buf,  0x26u);
      }

      double v31 = v36;
      uint64_t v32 = v37;
      if (v36 == v37) {
        goto LABEL_58;
      }
      do
      {
        AnalyticsSendEvent(@"com.apple.MicroLocation.Location", *(void *)v31);
        v31 += 8;
      }

      while (v31 != v32);
    }

    else
    {
      while (1)
      {
        uint64_t v16 = *(void *)(a2 + 24);
        if (!v16) {
          sub_100008BDC();
        }
        id v17 = sub_1000B6B54(a1, (uint64_t *)(v14 + 24));
        id v18 = v17;
        if (v17)
        {
          uint64_t v19 = v37;
          if (v37 >= v38)
          {
            uint64_t v21 = (v37 - v36) >> 3;
            unint64_t v22 = (v38 - v36) >> 2;
            if (v22 <= v21 + 1) {
              unint64_t v22 = v21 + 1;
            }
            else {
              unint64_t v23 = v22;
            }
            if (v23) {
              int v24 = (char *)sub_1000071BC((uint64_t)&v38, v23);
            }
            else {
              int v24 = 0LL;
            }
            __int128 v25 = &v24[8 * v21];
            *(void *)__int128 v25 = v18;
            uint64_t v20 = v25 + 8;
            int v27 = v36;
            __int128 v26 = v37;
            if (v37 != v36)
            {
              do
              {
                uint64_t v28 = *((void *)v26 - 1);
                v26 -= 8;
                *((void *)v25 - 1) = v28;
                v25 -= 8;
              }

              while (v26 != v27);
              __int128 v26 = v36;
            }

            int64_t v36 = v25;
            unint64_t v37 = v20;
            unint64_t v38 = &v24[8 * v23];
            if (v26) {
              operator delete(v26);
            }
          }

          else
          {
            *(void *)unint64_t v37 = v17;
            uint64_t v20 = v19 + 8;
          }

          unint64_t v37 = v20;
        }

        v14 += 64LL;
        if (v14 == v15) {
          goto LABEL_45;
        }
      }

      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      int v33 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v40 = 2082;
        unint64_t v41 = "";
        __int16 v42 = 2082;
        uint64_t v43 = "MicroLocationAnalytics";
        _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:LOI usage analytics canceled, Activity:%{public, location:escape_only}s}",  buf,  0x1Cu);
      }

      *(void *)uint64_t buf = &v34;
      sub_10003706C((void ***)buf);
    }

    double v31 = v36;
LABEL_58:
    if (v31)
    {
      unint64_t v37 = v31;
      operator delete(v31);
    }

    return;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  uint64_t v10 = qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v40 = 2082;
    unint64_t v41 = "";
    CFStringRef v7 = "{msg%{public}.0s:not analyzing Locations of Interest usage, since sending to core-analytics is disabled}";
    int v8 = (os_log_s *)v10;
    uint32_t v9 = 18;
    goto LABEL_16;
  }

void sub_1000B662C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

id sub_1000B6680(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  id v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 2082;
    *(void *)&buf[20] = [@"com.apple.MicroLocation.Visit" UTF8String];
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Creating analytics event., Event name:%{public, location:escape_only}s}",  buf,  0x1Cu);
  }

  sub_100029334(*(void *)(a1 + 8), (uint64_t *)&v28);
  uint64_t v3 = v28;
  uint64_t v4 = v29;
  if (v28 == v29)
  {
    BOOL v6 = 0LL;
    uint64_t v8 = (uint64_t)v28;
  }

  else
  {
    uint64_t v5 = v28 + 4;
    do
    {
      BOOL v6 = *(__int128 *)((char *)v5 - 40) == 0;
      BOOL v7 = *(__int128 *)((char *)v5 - 40) == 0 || v5 == v29;
      v5 += 4;
    }

    while (!v7);
    uint64_t v8 = (uint64_t)v28;
    while (*(_OWORD *)(v8 + 24) != 0LL)
    {
      v8 += 64LL;
      if ((__int128 *)v8 == v29)
      {
        uint64_t v3 = v29;
        uint64_t v8 = (uint64_t)v29;
        goto LABEL_26;
      }
    }

    if ((__int128 *)v8 == v29 || (uint64_t v9 = v8 + 64, (__int128 *)(v8 + 64) == v29))
    {
      uint64_t v3 = v29;
    }

    else
    {
      do
      {
        *(void *)uint64_t buf = 0LL;
        *(void *)&uint8_t buf[8] = 0LL;
        if (*(_OWORD *)(v9 + 24) != 0LL)
        {
          __int128 v10 = *(_OWORD *)v9;
          __int128 v11 = *(_OWORD *)(v9 + 16);
          *(void *)(v8 + 32) = *(void *)(v9 + 32);
          *(_OWORD *)uint64_t v8 = v10;
          *(_OWORD *)(v8 + 16) = v11;
          unint64_t v12 = (void **)(v8 + 40);
          __int128 v13 = *(_OWORD *)(v9 + 40);
          *(void *)(v8 + 56) = *(void *)(v9 + 56);
          *(_OWORD *)unint64_t v12 = v13;
          *(_BYTE *)(v9 + 63) = 0;
          *(_BYTE *)(v9 + 40) = 0;
          v8 += 64LL;
        }

        v9 += 64LL;
      }

      while ((__int128 *)v9 != v4);
      uint64_t v3 = v29;
    }
  }

void sub_1000B6AEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char *a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  sub_10004AD90((uint64_t)&a20);
  a20 = &a15;
  sub_10003706C((void ***)&a20);
  _Unwind_Resume(a1);
}

id sub_1000B6B54(uint64_t a1, uint64_t *a2)
{
  if ((sub_100013090((uint64_t)a2, &v40) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(void *)uint64_t buf = &off_101818CB0;
    sub_1000139B0((uint64_t)buf);
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = [@"com.apple.MicroLocation.Location" UTF8String];
    BOOL v6 = &v40;
    if ((v40.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      BOOL v6 = (std::string *)v40.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)__int16 v44 = 2082;
    *(void *)&v44[2] = "";
    *(_WORD *)&v44[10] = 2082;
    *(void *)&v44[12] = v5;
    __int16 v45 = 2082;
    unint64_t v46 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Creating analytics event., Event name:%{public, location:escape_only}s, LOI Group I D:%{public, location:escape_only}s}",  buf,  0x26u);
  }

  sub_10002C860(*(void *)(a1 + 8), (uint64_t)a2, &v38);
  uint64_t v8 = v38;
  BOOL v7 = v39;
  if (v39 == v38)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    uint64_t v24 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      memset(&v37, 0, sizeof(v37));
      if ((sub_100013090((uint64_t)a2, &v37) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)__p);
        __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101818CB0;
        sub_1000139B0((uint64_t)__p);
      }

      __int128 v25 = &v37;
      if ((v37.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int128 v25 = (std::string *)v37.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int16 v44 = 2082;
      *(void *)&v44[2] = "";
      *(_WORD *)&v44[10] = 2082;
      *(void *)&v44[12] = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:No LOI entries for specified LOI Group ID, LOIGroupId:%{public, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
    }

    __int128 v26 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      memset(&v37, 0, sizeof(v37));
      if ((sub_100013090((uint64_t)a2, &v37) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)__p);
        __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101818CB0;
        sub_1000139B0((uint64_t)__p);
      }

      char v27 = &v37;
      if ((v37.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        char v27 = (std::string *)v37.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int16 v44 = 2082;
      *(void *)&v44[2] = "";
      *(_WORD *)&v44[10] = 2082;
      *(void *)&v44[12] = v27;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v26,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "No LOI entries for specified LOI Group ID",  "{msg%{public}.0s:No LOI entries for specified LOI Group ID, LOIGroupId:%{public, location:escape_only}s}",  buf,  0x1Cu);
    }

    id v28 = 0LL;
  }

  else
  {
    memset(&v37, 0, sizeof(v37));
    uint64_t v34 = &v37;
    do
    {
      memset(__p, 0, 24);
      if ((sub_100013090((uint64_t)(v8 + 1), __p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)uint64_t buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      sub_1000936E8((uint64_t **)&v34, (__int128 *)__p);
      v8 += 8;
    }

    while (v8 != v7);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    uint64_t v9 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      int size = (char)v40.__r_.__value_.__s.__size_;
      std::string::size_type v11 = v40.__r_.__value_.__r.__words[0];
      sub_1000910EC(",", (uint64_t *)&v37, __p);
      unint64_t v12 = &v40;
      if (size < 0) {
        unint64_t v12 = (std::string *)v11;
      }
      if ((__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v13 = __p;
      }
      else {
        __int128 v13 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int16 v44 = 2082;
      *(void *)&v44[2] = "";
      *(_WORD *)&v44[10] = 2082;
      *(void *)&v44[12] = v12;
      __int16 v45 = 2082;
      unint64_t v46 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:LOIs for LOI Group Id, LOI Group ID:%{public, location:escape_only}s, LOI IDs:% {public, location:escape_only}s}",  buf,  0x26u);
    }

    sub_10002CB4C(*(void *)(a1 + 8), (uint64_t)a2, __p);
    if (v50) {
      double v14 = *(double *)&__p[0].__r_.__value_.__l.__cap_;
    }
    else {
      double v14 = -1.79769313e308;
    }
    uint64_t v34 = 0LL;
    uint64_t v35 = 0LL;
    uint64_t v36 = 0LL;
    uint64_t v15 = v38;
    uint64_t v16 = v39;
    __int16 v42 = &v34;
    if (v38 == v39)
    {
      uint64_t v17 = 0LL;
    }

    else
    {
      do
      {
        uint64_t v41 = *v15;
        sub_1000BBDB4((uint64_t *)&v42, &v41);
        v15 += 8;
      }

      while (v15 != v16);
      uint64_t v17 = (double *)v34;
      uint64_t v18 = (double *)((char *)v34 + 8);
      if (v34 != v35 && v18 != (double *)v35)
      {
        double v20 = *(double *)v34;
        int v21 = (double *)((char *)v34 + 8);
        do
        {
          double v22 = *v21++;
          double v23 = v22;
          if (v20 < v22)
          {
            double v20 = v23;
            uint64_t v17 = v18;
          }

          uint64_t v18 = v21;
        }

        while (v21 != (double *)v35);
      }
    }

    double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
    sub_1000289F0(*(void *)(a1 + 8), 0, *a2, a2[1], buf);
    id v28 = +[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary");
    if (*(_BYTE *)a2)
    {
      BOOL v30 = 0LL;
    }

    else
    {
      unint64_t v31 = 0LL;
      do
      {
        unint64_t v32 = v31;
        if (v31 == 15) {
          break;
        }
        ++v31;
      }

      while (!*((_BYTE *)a2 + v32 + 1));
      BOOL v30 = v32 > 0xE;
    }

    objc_msgSend( v28,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v30, v34),  @"isLoiLegacy");
    objc_msgSend( v28,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:]( NSNumber,  "numberWithUnsignedLong:",  (((char *)v39 - (char *)v38) >> 6) - 1),  @"deduplicatedLoiCount");
    if (v17 != (double *)v35) {
      objc_msgSend( v28,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", Current_1 - *v17),  @"lastSeenAge");
    }
    objc_msgSend( v28,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v50),  @"hasRecordings");
    if (v50) {
      objc_msgSend( v28,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", Current_1 - v14),  @"lastRecordingAge");
    }
    objc_msgSend( v28,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v48),  @"isModelExists");
    if (v48) {
      objc_msgSend( v28,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v47),  @"isModelStable");
    }
    sub_100019D34((uint64_t)buf);
    if (v34)
    {
      uint64_t v35 = (char *)v34;
      operator delete(v34);
    }

    sub_1000B9FAC((uint64_t)__p);
    *(void *)uint64_t buf = &v37;
    sub_1000129D4((void ***)buf);
  }

  *(void *)uint64_t buf = &v38;
  sub_10003706C((void ***)buf);
  return v28;
}

void sub_1000B72CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, uint64_t a28, std::bad_cast a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  a29.__vftable = (std::bad_cast_vtbl *)&a18;
  sub_10003706C((void ***)&a29);
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000B73C0(uint64_t a1, uint64_t a2, __int128 *a3)
{
  if ((__int128 *)a2 != a3)
  {
    sub_1000374E4((uint64_t)&v9, a3, *(__int128 **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        v7 -= 64LL;
      }

      while (v7 != v6);
    }

    *(void *)(a1 + 8) = v6;
  }

  return a2;
}

uint64_t sub_1000B7444(uint64_t a1)
{
  if (sub_1003C1048(a1 + 72)) {
    return sub_100024B0C(a1, "MiLoLoiTable");
  }
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  uint64_t v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "#Warning Attempt to get numEntries without a backing database",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    v5[0] = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Attempt to get numEntries without a backing database",  v5,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "uint32_t CLMicroLocationDatabase::numEntries() [Table = CLMiLoLoiTable]",  "%s\n",  v4);
  }

  return 0LL;
}

void sub_1000B7614(void *a1, uint64_t a2)
{
  if ((sub_1000B31D4() & 1) != 0)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    uint64_t v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 68289026;
      int v14 = 0;
      __int16 v15 = 2082;
      uint64_t v16 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:analyzing daily trigger usage}",  (uint8_t *)&v13,  0x12u);
    }

    sub_10001A504((uint64_t)v21, a2);
    uint64_t v5 = sub_1000B79BC(a1, (uint64_t)v21);
    uint64_t v6 = v22;
    if (v22 == v21)
    {
      uint64_t v7 = 4LL;
      uint64_t v6 = v21;
    }

    else
    {
      if (!v22) {
        goto LABEL_15;
      }
      uint64_t v7 = 5LL;
    }

    (*(void (**)(void))(*v6 + 8 * v7))();
LABEL_15:
    if (v5)
    {
      uint64_t v10 = *(void *)(a2 + 24);
      if (!v10) {
        sub_100008BDC();
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)v10 + 48LL))(v10))
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181D000);
        }
        uint64_t v8 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = 68289026;
          int v14 = 0;
          __int16 v15 = 2082;
          uint64_t v16 = "";
          char v9 = "{msg%{public}.0s:Trigger types analytics canceled}";
          goto LABEL_26;
        }
      }

      else
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181D000);
        }
        std::string::size_type v11 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          id v12 = [@"com.apple.microlocation.triggers.daily" UTF8String];
          int v13 = 68289539;
          int v14 = 0;
          __int16 v15 = 2082;
          uint64_t v16 = "";
          __int16 v17 = 2082;
          id v18 = v12;
          __int16 v19 = 2113;
          double v20 = v5;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Sending analytics event, Event name:%{public, location:escape_only}s, event :%{private, location:escape_only}@}",  (uint8_t *)&v13,  0x26u);
        }

        AnalyticsSendEvent(@"com.apple.microlocation.triggers.daily", v5);
      }
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      uint64_t v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = 68289026;
        int v14 = 0;
        __int16 v15 = 2082;
        uint64_t v16 = "";
        char v9 = "{msg%{public}.0s:daily trigger analytics event was not created.}";
        goto LABEL_26;
      }
    }

    return;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  uint64_t v8 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 68289026;
    int v14 = 0;
    __int16 v15 = 2082;
    uint64_t v16 = "";
    char v9 = "{msg%{public}.0s:not analyzing trigger types, since sending to core-analytics is disabled}";
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v13, 0x12u);
  }

void sub_1000B797C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  __int16 v19 = a17;
  if (a17 == v17)
  {
    uint64_t v20 = 4LL;
    __int16 v19 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_6;
    }
    uint64_t v20 = 5LL;
  }

  (*(void (**)(void))(*(void *)v19 + 8 * v20))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

NSMutableDictionary *sub_1000B79BC(void *a1, uint64_t a2)
{
  uint64_t v4 = +[NSDate date](&OBJC_CLASS___NSDate, "date");
  double v5 = sub_10015AFB0((uint64_t)v4, -1);
  double v6 = sub_10015AFB0((uint64_t)v4, 0);
  (*(void (**)(void))(*(void *)*a1 + 24LL))(*a1);
  uint64_t v7 = *(void *)(a2 + 24);
  if (!v7) {
    sub_100008BDC();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v7 + 48LL))(v7))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    uint64_t v8 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      buf.__r_.__value_.__r.__words[0] = 68289026LL;
      LOWORD(buf.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Trigger types analytics canceled}",  (uint8_t *)&buf,  0x12u);
    }

    return 0LL;
  }

  else
  {
    uint64_t v10 = a1[1];
    std::to_string(&buf, v5);
    std::to_string(&v39, v6);
    std::string::size_type v11 = operator new(4uLL);
    std::string __p = v11;
    _DWORD *v11 = 48;
    unint64_t v34 = (unint64_t)(v11 + 1);
    uint64_t v35 = v11 + 1;
    sub_10002B12C(v10, (uint64_t)&buf, (uint64_t)&v39, (uint64_t)&__p, &v36);
    if (__p)
    {
      unint64_t v34 = (unint64_t)__p;
      operator delete(__p);
    }

    std::string __p = 0LL;
    unint64_t v34 = 0LL;
    uint64_t v35 = 0LL;
    uint64_t v13 = v36;
    uint64_t v12 = v37;
    if (v36 != v37)
    {
      unint64_t v14 = 0LL;
      do
      {
        if (*(_DWORD *)(v13 + 24) == 48 && (*(_BYTE *)(v13 + 327) & 8) != 0)
        {
          uint64_t v15 = *(void *)(v13 + 256);
          if (!v15) {
            uint64_t v15 = *(void *)(qword_1019A0978 + 224);
          }
          if (v14 >= (unint64_t)v35)
          {
            unint64_t v14 = sub_1000BC3D0((uint64_t *)&__p, v15);
          }

          else
          {
            sub_100087F98(v14, v15);
            v14 += 88LL;
          }

          unint64_t v34 = v14;
          uint64_t v12 = v37;
        }

        v13 += 336LL;
      }

      while (v13 != v12);
    }

    sub_100159CCC(&buf, &__p);
    unint64_t v16 = sub_10015A008((uint64_t)&buf);
    unint64_t v32 = sub_10015A358((uint64_t)&buf);
    unint64_t v17 = sub_10015A284((uint64_t)&buf);
    unint64_t v18 = sub_10015A504((uint64_t)&buf, 1u, 1LL);
    uint64_t v19 = sub_10015A504((uint64_t)&buf, 0, 1LL);
    char v9 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  sub_100159D2C((uint64_t)&buf)),  @"TotalRecordings");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  sub_100159F34((uint64_t)&buf)),  @"TotalLocalizations");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v16),  @"TotalLegacyLocalizations");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  sub_10015A0DC((uint64_t)&buf)),  @"TotalCachedLegacyLocalizations");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  sub_10015A1B0((uint64_t)&buf)),  @"TotalNonCachedLegacyLocalizations");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v32),  @"TotalMotionLocalizations");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v19),  @"TotalMotionLocalizationsWhileDisplayOn");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v18),  @"TotalMotionLocalizationsWhenDisplayTurnedOn");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  sub_10015A504((uint64_t)&buf, 2u, 1LL)),  @"TotalMotionLocalizationsWhenRescheduled");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v17),  @"TotalNewLocalizations");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  sub_10015A42C((uint64_t)&buf, 1u)),  @"TotalLocalizationsWhenDisplayTurnedOn");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  sub_10015A42C((uint64_t)&buf, 2u)),  @"TotalLocalizationsWhenRescheduled");
    sub_1000B8EC8((uint64_t)a1, v9, v5, v6);
    sub_1000B92A0((uint64_t)a1, v9, v5, v6);
    sub_1002F0B04(&v39);
    CFStringRef v20 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsAnalyticsTriggerCountThreshold",  0x8000100u,  kCFAllocatorNull);
    unint64_t v21 = v19;
    int v22 = sub_1002A77CC((uint64_t)v39.__r_.__value_.__l.__data_, (uint64_t)v20, &v38);
    CFRelease(v20);
    unsigned int v23 = v38;
    int size = (std::__shared_weak_count *)v39.__r_.__value_.__l.__size_;
    if (v39.__r_.__value_.__l.__size_)
    {
      __int128 v25 = (unint64_t *)(v39.__r_.__value_.__l.__size_ + 8);
      do
        unint64_t v26 = __ldaxr(v25);
      while (__stlxr(v26 - 1, v25));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
        std::__shared_weak_count::__release_weak(size);
      }
    }

    if (v22) {
      unint64_t v27 = v23;
    }
    else {
      unint64_t v27 = 5LL;
    }
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    id v28 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      v39.__r_.__value_.__r.__words[0] = 68290050LL;
      LOWORD(v39.__r_.__value_.__r.__words[1]) = 2082;
      *(std::string::size_type *)((char *)&v39.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
      WORD1(v39.__r_.__value_.__r.__words[2]) = 1026;
      HIDWORD(v39.__r_.__value_.__r.__words[2]) = v27;
      __int16 v40 = 2050;
      unint64_t v41 = v16;
      __int16 v42 = 2050;
      unint64_t v43 = v32;
      __int16 v44 = 2050;
      unint64_t v45 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Adding ratios to trigger analytics if appropriate, TriggerThreshold:%{public}d, T otalLegacyLocalizations:%{public}lu, TotalMotionLocalizations:%{public}lu, TotalNewLocalizations:%{public}lu}",  (uint8_t *)&v39,  0x36u);
    }

    if (v16)
    {
      if (v32 >= v27 && v16 >= v27)
      {
        *(float *)&double v29 = (float)v32 / (float)v16;
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v29),  @"MotionLocalizationAndLegacyLocalizationsRatio");
      }

      if (v17 >= v27 && v16 >= v27)
      {
        *(float *)&double v29 = (float)v17 / (float)v16;
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v29),  @"NewLocalizationAndLegacyLocalizationsRatio");
      }
    }

    if (v18 && v21 >= v27 && v18 >= v27)
    {
      *(float *)&double v29 = (float)v21 / (float)v18;
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithFloat:](&OBJC_CLASS___NSNumber, "numberWithFloat:", v29),  @"MotionWhileDisplayOnAndWhenDisplayTurnedOnRatio");
    }

    *(double *)&v39.__r_.__value_.__l.__data_ = v6;
    int v30 = sub_1000B89D4((uint64_t)a1, (double *)&v39);
    if (v30 != 255) {
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v30 == 1),  @"isLowObservationLegacyClient");
    }
    sub_100019D7C(v48);
    v39.__r_.__value_.__r.__words[0] = (std::string::size_type)&v47;
    sub_1000BC344((void ***)&v39);
    if (buf.__r_.__value_.__r.__words[0])
    {
      buf.__r_.__value_.__l.__size_ = buf.__r_.__value_.__r.__words[0];
      operator delete(buf.__r_.__value_.__l.__data_);
    }

    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
    sub_1000BC344((void ***)&buf);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v36;
    sub_100043754((void ***)&buf);
  }

  return v9;
}

void sub_1000B8130( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char *p_p, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  p_p = (char *)&__p;
  sub_1000BC344((void ***)&p_p);
  p_p = &a13;
  sub_100043754((void ***)&p_p);
  _Unwind_Resume(a1);
}

uint64_t sub_1000B8200(uint64_t a1, double *a2, double *a3, uint64_t a4, uint64_t a5)
{
  if (*a3 >= *a2)
  {
    std::to_string(&v26, *a2);
    std::to_string(&v25, *a3);
    sub_10002B44C(*(void *)(a1 + 8), (uint64_t)&v26, a4, buf);
    if (v30)
    {
      uint64_t v12 = *(void *)(a5 + 24);
      if (!v12) {
        sub_100008BDC();
      }
      int v13 = (*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v12 + 48LL))(v12, buf);
      char v14 = v13;
      if (v13) {
        double v15 = *a2;
      }
      else {
        double v15 = 0.0;
      }
    }

    else
    {
      char v14 = 0;
      double v15 = 0.0;
    }

    sub_10002B12C(*(void *)(a1 + 8), (uint64_t)&v26, (uint64_t)&v25, a4, v24);
    uint64_t v16 = v24[0];
    uint64_t v17 = v24[1];
    double v18 = 0.0;
    while (v16 != v17)
    {
      uint64_t v19 = *(void *)(a5 + 24);
      if (!v19) {
        sub_100008BDC();
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v19 + 48LL))(v19, v16))
      {
        if (!v14)
        {
          double v15 = *(double *)(v16 + 16);
          char v14 = 1;
        }
      }

      else if (v14)
      {
        char v14 = 0;
        double v18 = v18 + *(double *)(v16 + 16) - v15;
      }

      else
      {
        char v14 = 0;
      }

      v16 += 336LL;
    }

    if (v14) {
      double v20 = *a3 - v15;
    }
    else {
      double v20 = -0.0;
    }
    unint64_t v27 = (void **)v24;
    sub_100043754(&v27);
    if (v30) {
      sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v29);
    }
    double v21 = v18 + v20;
    uint64_t v6 = (uint64_t)v21;
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    double v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "got start time bigger than end time while calculating milo spectating duration",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      LOWORD(v26.__r_.__value_.__l.__data_) = 0;
      unsigned int v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "got start time bigger than end time while calculating milo spectating duration",  &v26,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "cl::chrono::seconds CLMicroLocationAnalytics::getMiLoSpectatingDuration(const cl::chrono::time_point<cl::chrono: :CFAbsoluteTimeClock> &, const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &, const std::vector<CLMi croLocationProto::EventType> &, const std::function<BOOL (const CLMicroLocationLoggedEventsTable::Entry &)> &) const",  "%s\n",  v23);
    }

    return 0LL;
  }

  return v6;
}

void sub_1000B8528( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a69) {
    sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&a31);
  }
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(a1);
}

void sub_1000B85A0(uint64_t a1, void *a2, void *a3, uint64_t a4, double *a5)
{
  if (*a5 <= 0.0)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    unint64_t v27 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "Tried to add count per hour fields with duration equals 0.",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      LOWORD(v34) = 0;
      id v28 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Tried to add count per hour fields with duration equals 0.",  &v34,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMicroLocationAnalytics::addPerHoursFields(NSMutableDictionary *, NSArray<NSString *> *, NSString *, const cl::chrono::hoursf &) const",  "%s\n",  v28);
    }
  }

  else
  {
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    id v9 = [a3 countByEnumeratingWithState:&v30 objects:v42 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v31;
      do
      {
        uint64_t v12 = 0LL;
        do
        {
          if (*(void *)v31 != v11) {
            objc_enumerationMutation(a3);
          }
          int v13 = *(void **)(*((void *)&v30 + 1) + 8LL * (void)v12);
          id v14 = [a2 objectForKey:v13];
          if (v14)
          {
            [v14 doubleValue];
            double v16 = v15 / *a5;
            id v17 = [v13 stringByAppendingString:a4];
            *(float *)&double v18 = v16;
            objc_msgSend( a2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v18),  v17);
          }

          else
          {
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181D000);
            }
            uint64_t v19 = (os_log_s *)qword_1019348D8;
            if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
            {
              id v20 = [v13 UTF8String];
              id v21 = [@"com.apple.microlocation.triggers.daily" UTF8String];
              *(_DWORD *)std::string buf = 136315394;
              id v39 = v20;
              __int16 v40 = 2080;
              id v41 = v21;
              _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "no value found for key %s in %s CA event. Skipping it.",  buf,  0x16u);
            }

            if (sub_1002921D0(115, 0))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019348D0 != -1) {
                dispatch_once(&qword_1019348D0, &stru_10181D000);
              }
              uint64_t v22 = qword_1019348D8;
              id v23 = [v13 UTF8String];
              id v24 = [@"com.apple.microlocation.triggers.daily" UTF8String];
              int v34 = 136315394;
              id v35 = v23;
              __int16 v36 = 2080;
              id v37 = v24;
              LODWORD(v29) = 22;
              std::string v25 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v22,  16LL,  "no value found for key %s in %s CA event. Skipping it.",  (const char *)&v34,  v29);
              sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMicroLocationAnalytics::addPerHoursFields(NSMutableDictionary *, NSArray<NSString *> *, NSString *, const cl::chrono::hoursf &) const",  "%s\n",  v25);
            }
          }

          uint64_t v12 = (char *)v12 + 1;
        }

        while (v10 != v12);
        id v26 = [a3 countByEnumeratingWithState:&v30 objects:v42 count:16];
        id v10 = v26;
      }

      while (v26);
    }
  }

uint64_t sub_1000B89D4(uint64_t a1, double *a2)
{
  double v2 = *a2;
  uint64_t v3 = *(void *)(a1 + 8);
  std::to_string(&v19, *a2 + -172800.0);
  std::to_string(&v20, v2);
  uint64_t v4 = operator new(4uLL);
  std::string __p = v4;
  _DWORD *v4 = 49;
  double v15 = v4 + 1;
  double v16 = v4 + 1;
  sub_10002B12C(v3, (uint64_t)&v19, (uint64_t)&v20, (uint64_t)&__p, &v17);
  if (__p)
  {
    double v15 = __p;
    operator delete(__p);
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  double v5 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(v19.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)v19.__r_.__value_.__r.__words + 4) = 0xCF3CF3CF3CF3CF3DLL * ((v18 - v17) >> 4);
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "Selected %lu Legacy status updates",  (uint8_t *)&v19,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v19, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    LODWORD(v20.__r_.__value_.__l.__data_) = 134217984;
    *(std::string::size_type *)((char *)v20.__r_.__value_.__r.__words + 4) = 0xCF3CF3CF3CF3CF3DLL * ((v18 - v17) >> 4);
    uint64_t v12 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v19,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Selected %lu Legacy status updates",  &v20);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLMicroLocationProto::NumberOfObservationsStates CLMicroLocationAnalytics::getLegacyClientNumberOfObservationsStat e(const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &) const",  "%s\n",  (const char *)v12);
    if (v12 != &v19) {
      free(v12);
    }
  }

  uint64_t v6 = v18;
  while (v6 != v17)
  {
    uint64_t v7 = *(void *)(v6 - 72);
    if (!v7) {
      uint64_t v7 = *(void *)(qword_1019A0978 + 232);
    }
    uint64_t v8 = *(unsigned int *)(v7 + 12);
    v6 -= 336LL;
    if ((_DWORD)v8 != 255)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D000);
      }
      id v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        v19.__r_.__value_.__r.__words[0] = 68289282LL;
        LOWORD(v19.__r_.__value_.__r.__words[1]) = 2082;
        *(std::string::size_type *)((char *)&v19.__r_.__value_.__r.__words[1] + 2) = (std::string::size_type)"";
        WORD1(v19.__r_.__value_.__r.__words[2]) = 1026;
        HIDWORD(v19.__r_.__value_.__r.__words[2]) = v8 != 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:legacy client low number of observation status found, number of observation status:%{public}hhd}",  (uint8_t *)&v19,  0x18u);
      }

      goto LABEL_27;
    }
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  id v10 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Could not determine legacy client low number of observation status.",  (uint8_t *)&v19,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v19, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
    LOWORD(v20.__r_.__value_.__l.__data_) = 0;
    int v13 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v19,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Could not determine legacy client low number of observation status.",  &v20,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLMicroLocationProto::NumberOfObservationsStates CLMicroLocationAnalytics::getLegacyClientNumberOfObservationsStat e(const cl::chrono::time_point<cl::chrono::CFAbsoluteTimeClock> &) const",  "%s\n",  (const char *)v13);
    if (v13 != &v19) {
      free(v13);
    }
  }

  uint64_t v8 = 255LL;
LABEL_27:
  v19.__r_.__value_.__r.__words[0] = (std::string::size_type)&v17;
  sub_100043754((void ***)&v19);
  return v8;
}

void sub_1000B8E54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, char *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  a17 = &a14;
  sub_100043754((void ***)&a17);
  _Unwind_Resume(a1);
}

void *sub_1000B8EC8(uint64_t a1, void *a2, double a3, double a4)
{
  v37[0] = &off_10181D2B0;
  unsigned int v38 = v37;
  *(double *)&v30.__r_.__value_.__l.__data_ = a3;
  *(double *)&v29.__r_.__value_.__l.__data_ = a4;
  uint64_t v8 = operator new(0xCuLL);
  *(void *)__int128 v32 = v8 + 3;
  *(void *)&v32[8] = v8 + 3;
  *(void *)uint64_t v8 = 0x220000002CLL;
  v8[2] = 35;
  std::string __p = v8;
  uint64_t v9 = sub_1000B8200(a1, (double *)&v30, (double *)&v29, (uint64_t)&__p, (uint64_t)v37);
  if (__p)
  {
    *(void *)__int128 v32 = __p;
    operator delete(__p);
  }

  sub_1002F0B04(&__p);
  CFStringRef v10 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsAnalyticsTriggerMinimumSpectatingDuration",  0x8000100u,  kCFAllocatorNull);
  int v11 = sub_1002A77CC((uint64_t)__p, (uint64_t)v10, &v30);
  CFRelease(v10);
  double v12 = (double)v9 / 3600.0;
  unsigned int data = v30.__r_.__value_.__l.__data_;
  id v14 = *(std::__shared_weak_count **)v32;
  if (*(void *)v32)
  {
    double v15 = (unint64_t *)(*(void *)v32 + 8LL);
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  double v17 = (double)data;
  if (!v11) {
    double v17 = 1.0;
  }
  if (v12 >= v17)
  {
    id v18 = [a2 allKeys];
    std::string __p = *(void **)&v12;
    sub_1000B85A0((uint64_t)v18, a2, v18, (uint64_t)@"PerHour", (double *)&__p);
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  std::string v19 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    std::to_string(&v30, a3);
    int size = (char)v30.__r_.__value_.__s.__size_;
    std::string::size_type v22 = v30.__r_.__value_.__r.__words[0];
    std::to_string(&v29, a4);
    id v23 = &v30;
    if (size < 0) {
      id v23 = (std::string *)v22;
    }
    if ((v29.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      id v24 = &v29;
    }
    else {
      id v24 = (std::string *)v29.__r_.__value_.__r.__words[0];
    }
    float v25 = v12;
    std::string __p = (void *)68289795;
    *(_WORD *)__int128 v32 = 2082;
    *(void *)&v32[2] = "";
    *(_WORD *)&v32[10] = 2082;
    *(void *)&v32[12] = v23;
    __int16 v33 = 2082;
    int v34 = v24;
    __int16 v35 = 2049;
    double v36 = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Calculated microLocation spectating duration, startTime:%{public, location:escape_onl y}s, stopTime:%{public, location:escape_only}s, duration (hours):%{private}5f}",  (uint8_t *)&__p,  0x30u);
  }

  else
  {
    float v25 = v12;
  }

  *(float *)&double v20 = v25;
  objc_msgSend( a2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v20, v29.__r_.__value_.__r.__words[0]),  @"Duration");
  LODWORD(v26) = vcvtmd_s64_f64(v12);
  objc_msgSend( a2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v26),  @"DurationBounded");
  unint64_t result = v38;
  if (v38 == v37)
  {
    uint64_t v28 = 4LL;
    unint64_t result = v37;
  }

  else
  {
    if (!v38) {
      return result;
    }
    uint64_t v28 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v28))();
}

void sub_1000B9214( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, char *a28)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  std::string v29 = a28;
  if (a28 == &a25)
  {
    uint64_t v30 = 4LL;
    std::string v29 = &a25;
  }

  else
  {
    if (!a28) {
      goto LABEL_8;
    }
    uint64_t v30 = 5LL;
  }

  (*(void (**)(void))(*(void *)v29 + 8 * v30))();
LABEL_8:
  _Unwind_Resume(exception_object);
}

void *sub_1000B92A0(uint64_t a1, void *a2, double a3, double a4)
{
  v30[0] = &off_10181D340;
  __int128 v31 = v30;
  *(double *)&v23.__r_.__value_.__l.__data_ = a3;
  *(double *)&v22.__r_.__value_.__l.__data_ = a4;
  uint64_t v8 = operator new(8uLL);
  std::string __p = v8;
  *uint64_t v8 = 0x320000002CLL;
  *(void *)float v25 = v8 + 1;
  *(void *)&v25[8] = v8 + 1;
  uint64_t v9 = sub_1000B8200(a1, (double *)&v23, (double *)&v22, (uint64_t)&__p, (uint64_t)v30);
  if (__p)
  {
    *(void *)float v25 = __p;
    operator delete(__p);
  }

  double v10 = (double)v9;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  int v11 = (os_log_s *)qword_1019348D8;
  double v12 = v10 / 3600.0;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    std::to_string(&v23, a3);
    int size = (char)v23.__r_.__value_.__s.__size_;
    std::string::size_type v15 = v23.__r_.__value_.__r.__words[0];
    std::to_string(&v22, a4);
    unint64_t v16 = &v23;
    if (size < 0) {
      unint64_t v16 = (std::string *)v15;
    }
    if ((v22.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      double v17 = &v22;
    }
    else {
      double v17 = (std::string *)v22.__r_.__value_.__r.__words[0];
    }
    float v18 = v12;
    std::string __p = (void *)68289795;
    *(_WORD *)float v25 = 2082;
    *(void *)&_BYTE v25[2] = "";
    *(_WORD *)&v25[10] = 2082;
    *(void *)&v25[12] = v16;
    __int16 v26 = 2082;
    unint64_t v27 = v17;
    __int16 v28 = 2049;
    double v29 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Calculated microLocation motion spectating duration, startTime:%{public, location:esc ape_only}s, stopTime:%{public, location:escape_only}s, duration (hours):%{private}5f}",  (uint8_t *)&__p,  0x30u);
  }

  else
  {
    float v18 = v12;
  }

  *(float *)&double v13 = v18;
  objc_msgSend( a2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v13, v22.__r_.__value_.__r.__words[0]),  @"MotionDuration");
  LODWORD(v19) = vcvtmd_s64_f64(v12);
  objc_msgSend( a2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v19),  @"MotionDurationBounded");
  unint64_t result = v31;
  if (v31 == v30)
  {
    uint64_t v21 = 4LL;
    unint64_t result = v30;
  }

  else
  {
    if (!v31) {
      return result;
    }
    uint64_t v21 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v21))();
}

void sub_1000B9518( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, char *a28)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  double v29 = a28;
  if (a28 == &a25)
  {
    uint64_t v30 = 4LL;
    double v29 = &a25;
  }

  else
  {
    if (!a28) {
      goto LABEL_8;
    }
    uint64_t v30 = 5LL;
  }

  (*(void (**)(void))(*(void *)v29 + 8 * v30))();
LABEL_8:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000B9588(uint64_t a1)
{
  uint64_t v4 = (void **)(a1 + 24);
  sub_1000BC344(&v4);
  double v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }

  return a1;
}

void sub_1000B95D8(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_1000B9604()
{
  CFStringRef v0 = operator new(0x20uLL);
  sub_100063B44((uint64_t)v0);
  return v0;
}

void sub_1000B9630(_Unwind_Exception *a1)
{
}

uint64_t sub_1000B9644@<X0>(uint64_t result@<X0>, char *a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v3 = *(uint64_t ***)(result + 16);
  a3->__r_.__value_.__l.__size_ = 0LL;
  a3->__r_.__value_.__l.__cap_ = 0LL;
  a3->__r_.__value_.__r.__words[0] = 0LL;
  if (v3)
  {
    int v6 = *((char *)v3 + 39);
    uint64_t v7 = v6 >= 0 ? (char *)(v3 + 2) : (char *)v3[2];
    std::string::size_type v8 = v6 >= 0 ? *((unsigned __int8 *)v3 + 39) : (std::string::size_type)v3[3];
    unint64_t result = sub_10009382C(a3, (uint64_t)a3, v7, &v7[v8], v8);
    for (unint64_t i = *v3; i; unint64_t i = (uint64_t *)*i)
    {
      std::string::size_type size = a3->__r_.__value_.__s.__size_;
      if ((size & 0x80u) == 0LL) {
        int v11 = a3;
      }
      else {
        int v11 = (std::string *)a3->__r_.__value_.__r.__words[0];
      }
      if ((size & 0x80u) != 0LL) {
        std::string::size_type size = a3->__r_.__value_.__l.__size_;
      }
      uint64_t v12 = (uint64_t)v11 + size;
      size_t v13 = strlen(a2);
      sub_10009382C(a3, v12, a2, &a2[v13], v13);
      std::string::size_type v14 = a3->__r_.__value_.__s.__size_;
      if ((v14 & 0x80u) == 0LL) {
        std::string::size_type v15 = a3;
      }
      else {
        std::string::size_type v15 = (std::string *)a3->__r_.__value_.__r.__words[0];
      }
      if ((v14 & 0x80u) != 0LL) {
        std::string::size_type v14 = a3->__r_.__value_.__l.__size_;
      }
      int v16 = *((char *)i + 39);
      if (v16 >= 0) {
        double v17 = (char *)(i + 2);
      }
      else {
        double v17 = (char *)i[2];
      }
      if (v16 >= 0) {
        std::string::size_type v18 = *((unsigned __int8 *)i + 39);
      }
      else {
        std::string::size_type v18 = i[3];
      }
      unint64_t result = sub_10009382C(a3, (uint64_t)v15 + v14, v17, &v17[v18], v18);
    }
  }

  return result;
}

void sub_1000B9740(_Unwind_Exception *exception_object)
{
}

unsigned __int8 *sub_1000B9764(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    size_t v13 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      for (unint64_t i = *v13; i; unint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v15 = *((void *)i + 1);
        if (v15 == v9)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v12 > 1)
          {
            if (v15 >= v10) {
              v15 %= v10;
            }
          }

          else
          {
            v15 &= v10 - 1;
          }

          if (v15 != v3) {
            break;
          }
        }
      }
    }
  }

  sub_1000B99E0(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  std::string v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *std::string v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  unint64_t i = (unsigned __int8 *)v25[0];
  ++*v7;
  return i;
}

void sub_1000B99BC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **__p, uint64_t a11)
{
  if (__p) {
    sub_10004B64C((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000B99E0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x28uLL);
  *(void *)(a4 + 8) = v7;
  *(void *)a4 = v8;
  *(_BYTE *)(a4 + 16) = 0;
  *unint64_t v8 = 0LL;
  v8[1] = a2;
  unint64_t result = v8 + 2;
  if (*(char *)(a3 + 23) < 0)
  {
    unint64_t result = sub_1010DD48C(result, *(void **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)unint64_t result = *(_OWORD *)a3;
    result[2] = *(void *)(a3 + 16);
  }

  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1000B9A64(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0LL;
  sub_10004B64C(v3, v2);
  _Unwind_Resume(a1);
}

void *sub_1000B9A80(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }

    unint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (unint64_t i = *v10; i; unint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }

        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }

          else
          {
            v12 &= v8 - 1;
          }

          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }

  size_t v13 = (void *)(a1 + 16);
  unint64_t i = operator new(0x30uLL);
  *unint64_t i = 0LL;
  i[1] = v7;
  uint64_t v14 = **a4;
  i[5] = 0LL;
  i[4] = 0LL;
  i[2] = v14;
  i[3] = i + 4;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1LL;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_100019E10(a1, v20);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }

  uint64_t v21 = *(void *)a1;
  std::string v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *unint64_t i = *v22;
LABEL_38:
    *std::string v22 = i;
    goto LABEL_39;
  }

  *unint64_t i = *v13;
  void *v13 = i;
  *(void *)(v21 + 8 * v4) = v13;
  if (*i)
  {
    unint64_t v23 = *(void *)(*i + 8LL);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v23 >= v8) {
        v23 %= v8;
      }
    }

    else
    {
      v23 &= v8 - 1;
    }

    std::string v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }

void sub_1000B9CB8(_Unwind_Exception *a1)
{
}

void sub_1000B9CD4(uint64_t a1, void **a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    sub_100008390((uint64_t)(a2 + 3), a2[4]);
  }

  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

void *sub_1000B9D1C(uint64_t a1, int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }

    uint8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          unint64_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = 0LL;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_100019E10(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }

  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *unint64_t v10 = *v19;
LABEL_38:
    *unint64_t v19 = v10;
    goto LABEL_39;
  }

  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_1000B9F20(_Unwind_Exception *a1)
{
}

uint64_t sub_1000B9F34(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1000B9F6C(uint64_t a1, void **a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      unint64_t v3 = *v2;
      sub_100008390((uint64_t)(v2 + 3), v2[4]);
      operator delete(v2);
      uint64_t v2 = (void **)v3;
    }

    while (v3);
  }

uint64_t sub_1000B9FAC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 240))
  {
    sub_100086708(a1 + 80);
  }

  return a1;
}

void *sub_1000B9FF4(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181D030;
  result[1] = v3;
  return result;
}

uint64_t sub_1000BA028(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181D030;
  a2[1] = v2;
  return result;
}

void *sub_1000BA044(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  uint64_t v4 = (uint64_t)v10;
  if (!v10) {
    goto LABEL_4;
  }
  if (v10 != v9)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*v10 + 16LL))();
LABEL_4:
    float v12 = (_BYTE *)v4;
    goto LABEL_6;
  }

  float v12 = v11;
  (*(void (**)(void *, _BYTE *))(v9[0] + 24LL))(v9, v11);
LABEL_6:
  sub_1000B4180(v3, (uint64_t)v11);
  double v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    double v5 = v11;
  }

  else
  {
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  unint64_t result = v10;
  if (v10 == v9)
  {
    uint64_t v8 = 4LL;
    unint64_t result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v8 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1000BA150( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v18 = a13;
  if (a13 == &a10)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*(void *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000BA1C0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000BA1FC()
{
}

void *sub_1000BA210(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181D0B0;
  result[1] = v3;
  return result;
}

uint64_t sub_1000BA244(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181D0B0;
  a2[1] = v2;
  return result;
}

void *sub_1000BA260(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = (uint64_t)v10;
  if (!v10) {
    goto LABEL_4;
  }
  if (v10 != v9)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*v10 + 16LL))();
LABEL_4:
    float v12 = (_BYTE *)v4;
    goto LABEL_6;
  }

  float v12 = v11;
  (*(void (**)(void *, _BYTE *))(v9[0] + 24LL))(v9, v11);
LABEL_6:
  sub_1000B4D08(v3, (uint64_t)v11);
  double v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    double v5 = v11;
  }

  else
  {
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  unint64_t result = v10;
  if (v10 == v9)
  {
    uint64_t v8 = 4LL;
    unint64_t result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v8 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1000BA36C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v18 = a13;
  if (a13 == &a10)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*(void *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000BA3DC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000BA418()
{
}

void *sub_1000BA42C(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181D130;
  result[1] = v3;
  return result;
}

uint64_t sub_1000BA460(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181D130;
  a2[1] = v2;
  return result;
}

void *sub_1000BA47C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = (uint64_t)v10;
  if (!v10) {
    goto LABEL_4;
  }
  if (v10 != v9)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*v10 + 16LL))();
LABEL_4:
    float v12 = (_BYTE *)v4;
    goto LABEL_6;
  }

  float v12 = v11;
  (*(void (**)(void *, _BYTE *))(v9[0] + 24LL))(v9, v11);
LABEL_6:
  sub_1000B6084(v3, (uint64_t)v11);
  double v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    double v5 = v11;
  }

  else
  {
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  unint64_t result = v10;
  if (v10 == v9)
  {
    uint64_t v8 = 4LL;
    unint64_t result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v8 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1000BA588( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v18 = a13;
  if (a13 == &a10)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*(void *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000BA5F8(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000BA634()
{
}

void *sub_1000BA648(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181D1B0;
  result[1] = v3;
  return result;
}

uint64_t sub_1000BA67C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181D1B0;
  a2[1] = v2;
  return result;
}

void *sub_1000BA698(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a1 + 8);
  uint64_t v4 = (uint64_t)v10;
  if (!v10) {
    goto LABEL_4;
  }
  if (v10 != v9)
  {
    uint64_t v4 = (*(uint64_t (**)(void))(*v10 + 16LL))();
LABEL_4:
    float v12 = (_BYTE *)v4;
    goto LABEL_6;
  }

  float v12 = v11;
  (*(void (**)(void *, _BYTE *))(v9[0] + 24LL))(v9, v11);
LABEL_6:
  sub_1000B7614(v3, (uint64_t)v11);
  double v5 = v12;
  if (v12 == v11)
  {
    uint64_t v6 = 4LL;
    double v5 = v11;
  }

  else
  {
    if (!v12) {
      goto LABEL_11;
    }
    uint64_t v6 = 5LL;
  }

  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_11:
  unint64_t result = v10;
  if (v10 == v9)
  {
    uint64_t v8 = 4LL;
    unint64_t result = v9;
  }

  else
  {
    if (!v10) {
      return result;
    }
    uint64_t v8 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v8))();
}

void sub_1000BA7A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  uint64_t v18 = a13;
  if (a13 == &a10)
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*(void *)v18 + 8 * v19))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000BA814(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000BA850()
{
}

void *sub_1000BA864()
{
  unint64_t result = operator new(0x10uLL);
  void *result = &off_10181D230;
  return result;
}

void sub_1000BA888(uint64_t a1, void *a2)
{
  *a2 = &off_10181D230;
}

uint64_t sub_1000BA8A0()
{
  return 0LL;
}

uint64_t sub_1000BA8A8(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000BA8E4()
{
}

void *sub_1000BA8F0(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_10001B7A4(a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }

  return a1;
}

void sub_1000BA948(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1000BA964(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a2;
  if (a5 >= 1)
  {
    uint64_t v11 = a1[2];
    uint64_t v9 = (uint64_t)(a1 + 2);
    uint64_t v10 = v11;
    unint64_t v12 = *(void *)(v9 - 8);
    if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v11 - v12) >> 3)) >= a5)
    {
      uint64_t v20 = v12 - a2;
      if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v12 - a2) >> 3)) >= a5)
      {
        uint64_t v21 = a3 + 120 * a5;
      }

      else
      {
        uint64_t v21 = a3 + 8 * ((uint64_t)(v12 - a2) >> 3);
        a1[1] = sub_1000BACDC(v9, v21, a4, *(void *)(v9 - 8));
        if (v20 < 1) {
          return v5;
        }
      }

      sub_1000BAB6C((uint64_t)a1, v5, v12, v5 + 120 * a5);
      sub_10003FA50(a3, v21, v5);
    }

    else
    {
      uint64_t v13 = *a1;
      unint64_t v14 = a5 - 0x1111111111111111LL * ((uint64_t)(v12 - *a1) >> 3);
      if (v14 > 0x222222222222222LL) {
        sub_100007008();
      }
      unint64_t v15 = 0xEEEEEEEEEEEEEEEFLL * ((a2 - v13) >> 3);
      unint64_t v16 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v13) >> 3);
      uint64_t v17 = 2 * v16;
      if (2 * v16 <= v14) {
        uint64_t v17 = a5 - 0x1111111111111111LL * ((uint64_t)(v12 - *a1) >> 3);
      }
      if (v16 >= 0x111111111111111LL) {
        unint64_t v18 = 0x222222222222222LL;
      }
      else {
        unint64_t v18 = v17;
      }
      uint64_t v32 = v9;
      if (v18) {
        uint64_t v19 = (char *)sub_1000BAE04(v9, v18);
      }
      else {
        uint64_t v19 = 0LL;
      }
      uint64_t v22 = 0LL;
      unint64_t v23 = &v19[120 * v15];
      v29[0] = v19;
      v29[1] = v23;
      uint64_t v30 = v23;
      __int128 v31 = &v19[120 * v18];
      uint64_t v24 = 120 * a5;
      float v25 = &v23[120 * a5];
      do
      {
        __int16 v26 = &v23[v22];
        __int128 v27 = *(_OWORD *)(a3 + v22 + 16);
        *(_OWORD *)__int16 v26 = *(_OWORD *)(a3 + v22);
        *((_OWORD *)v26 + 1) = v27;
        sub_100068220(&v23[v22 + 32], a3 + v22 + 32);
        *((_DWORD *)v26 + 28) = *(_DWORD *)(a3 + v22 + 112);
        v22 += 120LL;
      }

      while (v24 != v22);
      uint64_t v30 = v25;
      uint64_t v5 = sub_1000BAC2C(a1, v29, v5);
      sub_1000BAFA0((uint64_t)v29);
    }
  }

  return v5;
}

void sub_1000BAB40( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  *(void *)(v12 + 8) = v13;
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000BAB6C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    uint64_t v10 = a2 + 8 * ((v6 - a4) >> 3) + 32;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      __int128 v11 = *(_OWORD *)(v10 - 16);
      *(_OWORD *)uint64_t v8 = *(_OWORD *)(v10 - 32);
      *(_OWORD *)(v8 + 16) = v11;
      sub_100068220(v8 + 32, v10);
      uint64_t v12 = v10 - 32;
      *(_DWORD *)(v8 + 112) = *(_DWORD *)(v10 + 80);
      v8 += 120LL;
      v10 += 120LL;
    }

    while (v12 + 120 < a3);
  }

  *(void *)(a1 + 8) = v8;
  return sub_1000BAD7C(a2, v7, v6);
}

void sub_1000BAC24(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1000BAC2C(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = (uint64_t)(a1 + 2);
  sub_1000BAE48((uint64_t)(a1 + 2), a3, a3, *a1, *a1, v6, v6);
  a2[1] = v8;
  a2[2] = sub_1000BAF00(v7, a3, a1[1], a2[2]);
  uint64_t v9 = *a1;
  *a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = a1[1];
  a1[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = a1[2];
  a1[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t sub_1000BACDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = a4 + v7;
      uint64_t v9 = a2 + v7;
      __int128 v10 = *(_OWORD *)(a2 + v7 + 16);
      *(_OWORD *)uint64_t v8 = *(_OWORD *)(a2 + v7);
      *(_OWORD *)(v8 + 16) = v10;
      sub_100068220(a4 + v7 + 32, a2 + v7 + 32);
      *(_DWORD *)(v8 + 112) = *(_DWORD *)(a2 + v7 + 112);
      v7 += 120LL;
    }

    while (v9 + 120 != a3);
    a4 += v7;
  }

  return a4;
}

void sub_1000BAD58(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 88;
    do
    {
      sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)(v4 + v2));
      v2 -= 120LL;
    }

    while (v2);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1000BAD7C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a1)
  {
    uint64_t v6 = 0LL;
    do
    {
      uint64_t v7 = a3 + v6;
      __int128 v8 = *(_OWORD *)(a2 + v6 - 120);
      *(_OWORD *)(v7 - 104) = *(_OWORD *)(a2 + v6 - 104);
      *(_OWORD *)(v7 - 120) = v8;
      sub_100069010(a3 + v6 - 88, a2 + v6 - 88);
      *(_DWORD *)(v7 - 8) = *(_DWORD *)(a2 + v6 - 8);
      v6 -= 120LL;
    }

    while (a2 + v6 != a1);
  }

  return a2;
}

void *sub_1000BAE04(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223LL) {
    sub_1000070D4();
  }
  return operator new(120 * a2);
}

uint64_t sub_1000BAE48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0LL;
    do
    {
      uint64_t v12 = a7 + v11;
      __int128 v13 = *(_OWORD *)(a3 + v11 - 120);
      *(_OWORD *)(v12 - 104) = *(_OWORD *)(a3 + v11 - 104);
      *(_OWORD *)(v12 - 120) = v13;
      sub_100068220(a7 + v11 - 88, a3 + v11 - 88);
      *(_DWORD *)(v12 - 8) = *(_DWORD *)(a3 + v11 - 8);
      v11 -= 120LL;
    }

    while (a3 + v11 != a5);
  }

  return a6;
}

void sub_1000BAEDC(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 + 32;
    do
    {
      sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)(v4 + v2));
      v2 += 120LL;
    }

    while (v2);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1000BAF00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = a4 + v7;
      uint64_t v9 = a2 + v7;
      __int128 v10 = *(_OWORD *)(a2 + v7 + 16);
      *(_OWORD *)uint64_t v8 = *(_OWORD *)(a2 + v7);
      *(_OWORD *)(v8 + 16) = v10;
      sub_100068220(a4 + v7 + 32, a2 + v7 + 32);
      *(_DWORD *)(v8 + 112) = *(_DWORD *)(a2 + v7 + 112);
      v7 += 120LL;
    }

    while (v9 + 120 != a3);
    a4 += v7;
  }

  return a4;
}

void sub_1000BAF7C(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 88;
    do
    {
      sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)(v4 + v2));
      v2 -= 120LL;
    }

    while (v2);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1000BAFA0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 120;
    sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)(i - 88));
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1000BAFF0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 48;
      uint64_t v7 = v4 - 48;
      do
      {
        uint64_t v8 = *(void (***)(char *))v7;
        v7 -= 48;
        (*v8)(v6);
        BOOL v9 = v6 == v2;
        uint64_t v6 = v7;
      }

      while (!v9);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_1000BB07C(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x555555555555555LL) {
    sub_100007008();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v9 = 0x555555555555555LL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    __int128 v10 = (char *)sub_1000BB1F4(v7, v9);
  }
  else {
    __int128 v10 = 0LL;
  }
  __int128 v13 = v10;
  unint64_t v14 = &v10[48 * v4];
  unint64_t v16 = &v10[48 * v9];
  sub_100064FDC(v14, a2);
  unint64_t v15 = v14 + 48;
  sub_1000BB180(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1000BB2D0((uint64_t)&v13);
  return v11;
}

void sub_1000BB16C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000BB180(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000BB238((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000BB1F4(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556LL) {
    sub_1000070D4();
  }
  return operator new(48 * a2);
}

uint64_t sub_1000BB238(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = a7 - 48;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = v11 + v10;
    v10 -= 48LL;
    sub_100064FDC(v12, v10 + a3);
  }

  return a6;
}

uint64_t sub_1000BB2D0(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    unint64_t v4 = *(void (***)(void))(i - 48);
    *(void *)(a1 + 16) = i - 48;
    (*v4)();
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1000BB320(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1000BB360((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_1000BB360(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 72LL)
  {
  }

  a1[1] = v2;
}

uint64_t **sub_1000BB3AC(uint64_t **a1, __int128 *a2)
{
  uint64_t v3 = *a1;
  unint64_t v5 = (*a1)[1];
  unint64_t v4 = (*a1)[2];
  uint64_t v6 = *a1;
  if (v5 >= v4)
  {
    uint64_t v7 = sub_1000BB478(v6, a2);
  }

  else
  {
    sub_1000BB3FC((uint64_t)v6, a2);
    uint64_t v7 = v5 + 72;
  }

  v3[1] = v7;
  return a1;
}

__n128 sub_1000BB3FC(uint64_t a1, __int128 *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(*(_BYTE **)(a1 + 8), *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v5 = *a2;
    *(void *)(v4 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v4 = v5;
  }

  __n128 result = *(__n128 *)((char *)a2 + 24);
  __int128 v7 = *(__int128 *)((char *)a2 + 40);
  *(_OWORD *)(v4 + 56) = *(__int128 *)((char *)a2 + 56);
  *(_OWORD *)(v4 + 40) = v7;
  *(__n128 *)(v4 + 24) = result;
  *(void *)(a1 + 8) = v4 + 72;
  return result;
}

void sub_1000BB470(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1000BB478(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x8E38E38E38E38E39LL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x38E38E38E38E38ELL) {
    sub_100007008();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x8E38E38E38E38E39LL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1C71C71C71C71C7LL) {
    unint64_t v9 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v21 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100046304(v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  uint64_t v11 = &v10[72 * v4];
  v18[0] = v10;
  v18[1] = v11;
  uint64_t v19 = v11;
  uint64_t v20 = &v10[72 * v9];
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(v11, *(void **)a2, *((void *)a2 + 1));
    uint64_t v11 = v19;
  }

  else
  {
    __int128 v12 = *a2;
    *((void *)v11 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v11 = v12;
  }

  __int128 v13 = &v10[72 * v4];
  __int128 v14 = *(__int128 *)((char *)a2 + 56);
  __int128 v15 = *(__int128 *)((char *)a2 + 24);
  *(_OWORD *)(v13 + 40) = *(__int128 *)((char *)a2 + 40);
  *(_OWORD *)(v13 + 24) = v15;
  *(_OWORD *)(v13 + 56) = v14;
  uint64_t v19 = v11 + 72;
  sub_1000BB5D0(a1, v18);
  uint64_t v16 = a1[1];
  sub_1000BB768((uint64_t)v18);
  return v16;
}

void sub_1000BB5BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000BB5D0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000BB644((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1000BB644(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v17 = a6;
  *((void *)&v17 + 1) = a7;
  __int128 v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  v14[2] = &v17;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      __int128 v10 = *(_OWORD *)(a3 - 72);
      *(void *)(v9 - 56) = *(void *)(a3 - 56);
      *(_OWORD *)(v9 - 72) = v10;
      *(void *)(a3 - 64) = 0LL;
      *(void *)(a3 - 56) = 0LL;
      *(void *)(a3 - 72) = 0LL;
      __int128 v11 = *(_OWORD *)(a3 - 48);
      __int128 v12 = *(_OWORD *)(a3 - 16);
      *(_OWORD *)(v9 - 32) = *(_OWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 16) = v12;
      *(_OWORD *)(v9 - 48) = v11;
      v9 -= 72LL;
      v7 -= 72LL;
      a3 -= 72LL;
    }

    while (a3 != a5);
    *((void *)&v17 + 1) = v9;
  }

  char v15 = 1;
  sub_1000BB6F0((uint64_t)v14);
  return a6;
}

uint64_t sub_1000BB6F0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1000BB724(a1);
  }
  return a1;
}

void sub_1000BB724(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    v1 += 72LL;
  }

uint64_t sub_1000BB768(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1000BB79C(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 9;
      *(void *)(a1 + 16) = v2 - 9;
      if (*((char *)v2 - 49) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }

      uint64_t v2 = v5;
    }

    while (v5 != a2);
  }

unsigned __int8 *sub_1000BB7F0(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }

    __int128 v14 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if ((sub_100022A24(a1 + 32, i + 16, a2) & 1) != 0) {
            return i;
          }
        }

        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }

          else
          {
            v16 &= v11 - 1;
          }

          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }

  sub_1000BBA84(a1, v10, a4, (uint64_t)v26);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1LL;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_100019E10(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }

  unint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v26[0] = *v23;
    *unint64_t v23 = v26[0];
  }

  else
  {
    *(void *)v26[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v26[0])
    {
      unint64_t v24 = *(void *)(*(void *)v26[0] + 8LL);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }

      else
      {
        v24 &= v11 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v24) = v26[0];
    }
  }

  uint64_t i = (unsigned __int8 *)v26[0];
  ++*v8;
  return i;
}

void sub_1000BBA60( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void **__p, uint64_t a13)
{
  if (__p) {
    sub_10004B64C((uint64_t)&a13, __p);
  }
  _Unwind_Resume(exception_object);
}

_BYTE *sub_1000BBA84@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __int128 **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint64_t v8 = operator new(0x30uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *uint64_t v8 = 0LL;
  v8[1] = a2;
  uint64_t result = v8 + 2;
  unint64_t v10 = *a3;
  if (*((char *)*a3 + 23) < 0)
  {
    uint64_t result = sub_1010DD48C(result, *(void **)v10, *((void *)v10 + 1));
  }

  else
  {
    __int128 v11 = *v10;
    v8[4] = *((void *)v10 + 2);
    *(_OWORD *)uint64_t result = v11;
  }

  v8[5] = 0LL;
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1000BBB10(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0LL;
  sub_10004B64C(v3, v2);
  _Unwind_Resume(a1);
}

void *sub_1000BBB2C(uint64_t a1, unsigned __int8 *a2, uint64_t a3, __int128 **a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = sub_10004B1A4(a1 + 24, (uint64_t)a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }

    __int128 v14 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(void **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
        }

        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }

          else
          {
            v16 &= v11 - 1;
          }

          if (v16 != v4) {
            break;
          }
        }
      }
    }
  }

  float v17 = (void *)(a1 + 16);
  uint64_t i = operator new(0x30uLL);
  *(void *)uint64_t i = 0LL;
  *((void *)i + 1) = v10;
  float v18 = *a4;
  __int128 v19 = **a4;
  *((void *)i + 4) = *((void *)*a4 + 2);
  *((_OWORD *)i + 1) = v19;
  *((void *)v18 + 1) = 0LL;
  *((void *)v18 + 2) = 0LL;
  *(void *)float v18 = 0LL;
  *((void *)i + 5) = 0LL;
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v21 = *(float *)(a1 + 32);
  if (!v11 || (float)(v21 * (float)v11) < v20)
  {
    BOOL v22 = 1LL;
    if (v11 >= 3) {
      BOOL v22 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v11);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    sub_100019E10(a1, v25);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }

  uint64_t v26 = *(void *)a1;
  __int128 v27 = *(void **)(*(void *)a1 + 8 * v4);
  if (v27)
  {
    *(void *)uint64_t i = *v27;
LABEL_38:
    *__int128 v27 = i;
    goto LABEL_39;
  }

  *(void *)uint64_t i = *v17;
  *float v17 = i;
  *(void *)(v26 + 8 * v4) = v17;
  if (*(void *)i)
  {
    unint64_t v28 = *(void *)(*(void *)i + 8LL);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v28 >= v11) {
        v28 %= v11;
      }
    }

    else
    {
      v28 &= v11 - 1;
    }

    __int128 v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_38;
  }

void sub_1000BBD98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

uint64_t *sub_1000BBDB4(uint64_t *a1, void *a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *(void **)(*a1 + 8);
  uint64_t v6 = (void *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    uint64_t v8 = *(void **)v4;
    uint64_t v9 = ((uint64_t)v5 - *(void *)v4) >> 3;
    unint64_t v10 = v9 + 1;
    uint64_t v11 = *v6 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      unint64_t v13 = (char *)sub_1000071BC((uint64_t)v6, v12);
      uint64_t v8 = *(void **)v4;
      uint64_t v5 = *(void **)(v4 + 8);
    }

    else
    {
      unint64_t v13 = 0LL;
    }

    __int128 v14 = &v13[8 * v9];
    char v15 = &v13[8 * v12];
    *(void *)__int128 v14 = *a2;
    uint64_t v7 = v14 + 8;
    while (v5 != v8)
    {
      uint64_t v16 = *--v5;
      *((void *)v14 - 1) = v16;
      v14 -= 8;
    }

    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }

  else
  {
    *uint64_t v5 = *a2;
    uint64_t v7 = v5 + 1;
  }

  *(void *)(v4 + 8) = v7;
  return a1;
}

void *sub_1000BBEA8()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &off_10181D2B0;
  return result;
}

void sub_1000BBECC(uint64_t a1, void *a2)
{
  *a2 = &off_10181D2B0;
}

BOOL sub_1000BBEE4(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 24);
  if (v2 == 34) {
    return 1LL;
  }
  if (v2 == 44 || v2 == 35) {
    return 0LL;
  }
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = *(unsigned int *)(a2 + 24);
    int v9 = 68289282;
    int v10 = 0;
    __int16 v11 = 2082;
    unint64_t v12 = "";
    __int16 v13 = 2050;
    uint64_t v14 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:got unexpected event type to indicate start/stop spectating, event type:%{public}lu}",  (uint8_t *)&v9,  0x1Cu);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
  }

  uint64_t v6 = (os_log_s *)qword_1019348D8;
  BOOL result = os_signpost_enabled((os_log_t)qword_1019348D8);
  if (result)
  {
    uint64_t v8 = *(unsigned int *)(a2 + 24);
    int v9 = 68289282;
    int v10 = 0;
    __int16 v11 = 2082;
    unint64_t v12 = "";
    __int16 v13 = 2050;
    uint64_t v14 = v8;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "got unexpected event type to indicate start/stop spectating",  "{msg%{public}.0s:got unexpected event type to indicate start/stop spectating, event type:%{public}lu}",  (uint8_t *)&v9,  0x1Cu);
    return 0LL;
  }

  return result;
}

uint64_t sub_1000BC09C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000BC0D8()
{
}

void *sub_1000BC0EC()
{
  BOOL result = operator new(0x10uLL);
  void *result = &off_10181D340;
  return result;
}

void sub_1000BC110(uint64_t a1, void *a2)
{
  *a2 = &off_10181D340;
}

BOOL sub_1000BC128(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 24);
  if (v2 == 44) {
    return 0LL;
  }
  if (v2 == 50)
  {
    if ((*(_BYTE *)(a2 + 327) & 0x20) != 0)
    {
      uint64_t v4 = *(void *)(a2 + 272);
      if (!v4) {
        uint64_t v4 = *(void *)(qword_1019A0978 + 240);
      }
      if (*(_BYTE *)(v4 + 12)) {
        return 1LL;
      }
    }

    return 0LL;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D000);
  }
  uint64_t v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
  {
    uint64_t v7 = *(unsigned int *)(a2 + 24);
    int v10 = 68289282;
    int v11 = 0;
    __int16 v12 = 2082;
    __int16 v13 = "";
    __int16 v14 = 2050;
    uint64_t v15 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:got unexpected event type to indicate start/stop motion spectating, event type:%{public}lu}",  (uint8_t *)&v10,  0x1Cu);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D000);
    }
  }

  uint64_t v8 = (os_log_s *)qword_1019348D8;
  BOOL result = os_signpost_enabled((os_log_t)qword_1019348D8);
  if (result)
  {
    uint64_t v9 = *(unsigned int *)(a2 + 24);
    int v10 = 68289282;
    int v11 = 0;
    __int16 v12 = 2082;
    __int16 v13 = "";
    __int16 v14 = 2050;
    uint64_t v15 = v9;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v8,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "got unexpected event type to indicate start/stop motion spectating",  "{msg%{public}.0s:got unexpected event type to indicate start/stop motion spectating, event type:%{public}lu}",  (uint8_t *)&v10,  0x1Cu);
    return 0LL;
  }

  return result;
}

uint64_t sub_1000BC2FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000BC338()
{
}

void sub_1000BC344(void ***a1)
{
  uint64_t v1 = *a1;
  int v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 88;
      uint64_t v7 = v4 - 88;
      do
      {
        uint64_t v8 = *(void (***)(char *))v7;
        v7 -= 88;
        (*v8)(v6);
        BOOL v9 = v6 == v2;
        uint64_t v6 = v7;
      }

      while (!v9);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_1000BC3D0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3LL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3LL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1745D1745D1745DLL) {
    unint64_t v9 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v9 = v5;
  }
  float v17 = a1 + 2;
  if (v9) {
    int v10 = (char *)sub_100023598(v7, v9);
  }
  else {
    int v10 = 0LL;
  }
  __int16 v13 = v10;
  __int16 v14 = &v10[88 * v4];
  uint64_t v16 = &v10[88 * v9];
  sub_100087F98(v14, a2);
  uint64_t v15 = v14 + 88;
  sub_1000BC4EC(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1000BC5F8((uint64_t)&v13);
  return v11;
}

void sub_1000BC4D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000BC4EC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000BC560((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1000BC560(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = a7 - 88;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = v11 + v10;
    v10 -= 88LL;
    sub_100087F98(v12, v10 + a3);
  }

  return a6;
}

uint64_t sub_1000BC5F8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 88);
    *(void *)(a1 + 16) = i - 88;
    (*v4)();
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1000BC648@<X0>(uint64_t a1@<X1>, float *a2@<X8>)
{
  CFStringRef v4 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsFingerprintDistanceFunctionType",  0x8000100u,  kCFAllocatorNull);
  int v5 = sub_1002A77CC(v33, (uint64_t)v4, v41);
  CFRelease(v4);
  int v6 = v41[0];
  uint64_t v7 = v34;
  if (v34)
  {
    p_shared_owners = (unint64_t *)&v34->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  if (v5) {
    int v10 = v6;
  }
  else {
    int v10 = 4;
  }
  sub_1000C7D20(v10, v38);
  sub_100019D9C((uint64_t)&v33, a1 + 16);
  __int128 v36 = *(_OWORD *)(a1 + 56);
  char v37 = 1;
  sub_1000412D8(v10);
  if (v37) {
    sub_100019CEC((uint64_t)&v33);
  }
  uint64_t v11 = (uint64_t)v42;
  if (!v42) {
    goto LABEL_14;
  }
  if (v42 != v41)
  {
    uint64_t v11 = (*(uint64_t (**)(void *))(*v42 + 16LL))(v42);
LABEL_14:
    __int16 v40 = (_BYTE *)v11;
    goto LABEL_16;
  }

  __int16 v40 = v39;
  (*(void (**)(void *, _BYTE *))(v41[0] + 24LL))(v41, v39);
LABEL_16:
  sub_100098FC8((void *)a1, (uint64_t)v39, (char **)&v33);
  uint64_t v12 = v40;
  if (v40 == v39)
  {
    uint64_t v13 = 4LL;
    uint64_t v12 = v39;
  }

  else
  {
    if (!v40) {
      goto LABEL_21;
    }
    uint64_t v13 = 5LL;
  }

  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_21:
  __int16 v14 = v34;
  if (v33)
  {
    unint64_t v15 = 0LL;
    float v16 = 0.0;
    float v17 = 3.4028e38;
    float v18 = 1.1755e-38;
    float v19 = 3.4028e38;
    float v20 = 1.1755e-38;
    float v21 = 0.0;
    do
    {
      BOOL v22 = (char *)(v15 + 1);
      double v23 = *((double *)&v34->__vftable + v15 + (((v15 + 1) * v15) >> 1));
      if (v23 > v18) {
        float v18 = v23;
      }
      if (v23 < v17) {
        float v17 = v23;
      }
      unint64_t v24 = (char *)(v15 + 1);
      if ((unint64_t)v22 < v33)
      {
        do
        {
          else {
            unint64_t v25 = v15;
          }
          else {
            uint64_t v26 = (char *)v15;
          }
          double v27 = *((double *)&v34->__vftable + (void)&v26[(v25 + v25 * v25) >> 1]);
          float v16 = v27 + v16;
          if (v27 > v20) {
            float v20 = v27;
          }
          if (v27 < v19) {
            float v19 = v27;
          }
          ++v24;
        }

        while ((char *)v33 != v24);
      }

      float v28 = v23 + v21;
      float v21 = v28 / (float)(unint64_t)v33;
      ++v15;
    }

    while (v22 != (char *)v33);
  }

  else
  {
    float v21 = 0.0;
    float v19 = 3.4028e38;
    float v20 = 1.1755e-38;
    float v16 = 0.0;
    float v17 = 3.4028e38;
    float v18 = 1.1755e-38;
  }

  float v29 = (float)((unint64_t)((v33 - 1) * v33) >> 1);
  *a2 = v17;
  a2[1] = v18;
  a2[2] = v21;
  a2[3] = v19;
  a2[4] = v20;
  a2[5] = v16 / v29;
  if (v14)
  {
    __int16 v35 = v14;
    operator delete(v14);
  }

  uint64_t v30 = v42;
  if (v42 == v41)
  {
    uint64_t v31 = 4LL;
    uint64_t v30 = v41;
    goto LABEL_48;
  }

  if (v42)
  {
    uint64_t v31 = 5LL;
LABEL_48:
    (*(void (**)(void))(*v30 + 8 * v31))();
  }

  return sub_1002A5554(v38);
}

void sub_1000BC974( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v12 = *(void **)(v10 - 64);
  if (v12 == (void *)(v10 - 88))
  {
    uint64_t v13 = 4LL;
    uint64_t v12 = (void *)(v10 - 88);
  }

  else
  {
    if (!v12) {
      goto LABEL_6;
    }
    uint64_t v13 = 5LL;
  }

  (*(void (**)(void))(*v12 + 8 * v13))();
LABEL_6:
  sub_1002A5554((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1000BCA28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_10008D588((void *)a1);
  void *v6 = off_10181D3C0;
  v6[7] = &off_10181D418;
  _WORD v6[8] = &off_10181D490;
  v6[9] = &off_10181D4E8;
  v6[10] = &off_10181D540;
  v6[11] = &off_10181D598;
  v6[12] = &off_10181D5F0;
  v6[13] = &off_10181D648;
  v6[14] = &off_10181D6A0;
  v6[15] = &off_10181D6F8;
  v6[16] = &off_10181D748;
  v6[17] = &off_10181D788;
  v6[19] = a2;
  v6[20] = a3;
  if (a3)
  {
    *(_WORD *)(a1 + 144) = 0;
    *(_DWORD *)(a1 + 148) = 0;
    *(void *)(a1 + 168) = 0LL;
    *(void *)(a1 + 176) = 0LL;
    sub_1000BD030(a1);
    sub_1000BD178(a1);
    sub_1000BD3B0(a1);
    sub_1000BD5E8(a1);
    sub_1010DDBC0(__p, "IdleState");
    sub_10008D7C4((void *)a1, (uint64_t *)__p);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
    return a1;
  }

  else
  {
    sub_101228E70();
    uint64_t result = abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMiLoCustomLoiRecordingManager.mm",  19,  "CLMiLoCustomLoiRecordingManager");
    __break(1u);
  }

  return result;
}

void sub_1000BCC04( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, _Unwind_Exception *exception_object, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  nullsub_10(v25);
  nullsub_10(v24);
  nullsub_10(v30);
  nullsub_10(v29);
  nullsub_10(v28);
  nullsub_10(v27);
  nullsub_10(v26);
  nullsub_10(a14);
  nullsub_10(a15);
  nullsub_10(a16);
  nullsub_10(a17);
  sub_10008D5F4(v23);
  _Unwind_Resume(a1);
}

void *sub_1000BCC8C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (*(_BYTE *)(a1 + 144) && !*(_BYTE *)(a1 + 145)) {
    CFStringRef v4 = "RecordingState";
  }
  else {
    CFStringRef v4 = "RecordingPendingState";
  }
  uint64_t result = sub_1010DDBC0((void *)a2, v4);
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

void sub_1000BCCF8(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(char *)(v4 + 31) < 0)
  {
    sub_1010DD48C(v13, *(void **)(v4 + 8), *(void *)(v4 + 16));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(v4 + 8);
    *(void *)&v13[16] = *(void *)(v4 + 24);
    *(_OWORD *)uint64_t v13 = v5;
  }

  if ((v13[23] & 0x80000000) == 0)
  {
    if (v13[23] != 21) {
      goto LABEL_28;
    }
    BOOL v6 = *(void *)v13 == 0x6E6964726F636552LL && *(void *)&v13[8] == 0x676E69646E655067LL;
    if (!v6 || *(void *)&v13[13] != 0x6574617453676E69LL) {
      goto LABEL_28;
    }
LABEL_26:
    sub_1010DDBC0((void *)a2, "RecordingState");
    goto LABEL_32;
  }

  if (*(void *)&v13[8] == 21LL)
  {
    BOOL v10 = **(void **)v13 != 0x6E6964726F636552LL
       || *(void *)(*(void *)v13 + 8LL) != 0x676E69646E655067LL
       || *(void *)(*(void *)v13 + 13LL) != 0x6574617453676E69LL;
    operator delete(*(void **)v13);
    if (v10) {
      goto LABEL_28;
    }
    goto LABEL_26;
  }

  operator delete(*(void **)v13);
LABEL_28:
  uint64_t v11 = *(void *)(a1 + 8);
  if (*(char *)(v11 + 31) < 0)
  {
    sub_1010DD48C(v13, *(void **)(v11 + 8), *(void *)(v11 + 16));
  }

  else
  {
    __int128 v12 = *(_OWORD *)(v11 + 8);
    *(void *)&v13[16] = *(void *)(v11 + 24);
    *(_OWORD *)uint64_t v13 = v12;
  }

  *(_OWORD *)a2 = *(_OWORD *)v13;
  *(void *)(a2 + 16) = *(void *)&v13[16];
LABEL_32:
  *(_BYTE *)(a2 + 24) = 1;
}

double sub_1000BCE68@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (*(char *)(v3 + 31) < 0)
  {
    sub_1010DD48C(&v6, *(void **)(v3 + 8), *(void *)(v3 + 16));
  }

  else
  {
    __int128 v4 = *(_OWORD *)(v3 + 8);
    uint64_t v7 = *(void *)(v3 + 24);
    __int128 v6 = v4;
  }

  double result = *(double *)&v6;
  *(_OWORD *)a2 = v6;
  *(void *)(a2 + 16) = v7;
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

void *sub_1000BCED0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v4 = *(_DWORD *)(a1 + 148) + 1;
  *(_DWORD *)(a1 + 148) = v4;
  sub_1002F0B04(&v15);
  CFStringRef v5 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsCustomLoiMaxRecordings", 0x8000100u, kCFAllocatorNull);
  int v6 = sub_1002A77CC(v15, (uint64_t)v5, &v14);
  CFRelease(v5);
  unsigned int v7 = v14;
  uint64_t v8 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  if (v6) {
    unsigned int v11 = v7;
  }
  else {
    unsigned int v11 = 10;
  }
  if (v4 >= v11)
  {
    (*(void (**)(void))(**(void **)(a1 + 152) + 24LL))(*(void *)(a1 + 152));
    __int128 v12 = "IdleState";
  }

  else
  {
    __int128 v12 = "RecordingThrottledState";
  }

  double result = sub_1010DDBC0((void *)a2, v12);
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

void sub_1000BCFE8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_1000BD030(uint64_t a1)
{
  int v2 = (char *)operator new(0x58uLL);
  sub_10008D438((uint64_t)v2, 0);
  std::string::assign((std::string *)(v2 + 8), "IdleState");
  *((void *)v2 + 5) = a1 + 120;
  sub_1010DDBC0(__p, "StartRecordingSessionEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 56;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(v5, "IdleState");
  uint64_t v4 = (uint64_t)v2;
  sub_10008D760(a1, (__int128 *)v5, &v4);
  uint64_t v3 = v4;
  uint64_t v4 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1000BD124( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000BD178(uint64_t a1)
{
  int v2 = (char *)operator new(0x58uLL);
  sub_10008D438((uint64_t)v2, 0);
  std::string::assign((std::string *)(v2 + 8), "RecordingState");
  *((void *)v2 + 5) = a1 + 128;
  sub_1010DDBC0(__p, "StopRecordingSessionEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 64;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "MaxRecordingTimerFiredEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 88;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "RecordingFenceBreachedEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 104;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "RecordingCompletedEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 112;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(v5, "RecordingState");
  uint64_t v4 = (uint64_t)v2;
  sub_10008D760(a1, (__int128 *)v5, &v4);
  uint64_t v3 = v4;
  uint64_t v4 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1000BD350( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000BD3B0(uint64_t a1)
{
  int v2 = (char *)operator new(0x58uLL);
  sub_10008D438((uint64_t)v2, 0);
  std::string::assign((std::string *)(v2 + 8), "RecordingThrottledState");
  *((void *)v2 + 5) = a1 + 136;
  sub_1010DDBC0(__p, "StopRecordingSessionEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 64;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "MaxRecordingTimerFiredEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 88;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "ThrottleTimerFiredEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 96;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "RecordingFenceBreachedEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 104;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(v5, "RecordingThrottledState");
  uint64_t v4 = (uint64_t)v2;
  sub_10008D760(a1, (__int128 *)v5, &v4);
  uint64_t v3 = v4;
  uint64_t v4 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1000BD588( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000BD5E8(uint64_t a1)
{
  int v2 = (char *)operator new(0x58uLL);
  sub_10008D438((uint64_t)v2, 0);
  std::string::assign((std::string *)(v2 + 8), "RecordingPendingState");
  sub_1010DDBC0(__p, "StopRecordingSessionEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 64;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "DeviceReadyEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 72;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "MaxRecordingTimerFiredEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 88;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "RecordingFenceBreachedEvent");
  char v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 104;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(v5, "RecordingPendingState");
  uint64_t v4 = (uint64_t)v2;
  sub_10008D760(a1, (__int128 *)v5, &v4);
  uint64_t v3 = v4;
  uint64_t v4 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1000BD7B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000BD820(uint64_t a1)
{
  *(void *)a1 = off_10181D3C0;
  *(_DWORD *)(a1 + 148) = 0;
  sub_1000BDCD0(a1);
  sub_1000BDA54(a1);
  (*(void (**)(void))(**(void **)(a1 + 152) + 16LL))(*(void *)(a1 + 152));
  nullsub_10(a1 + 136);
  nullsub_10(a1 + 128);
  nullsub_10(a1 + 120);
  nullsub_10(a1 + 112);
  nullsub_10(a1 + 104);
  nullsub_10(a1 + 96);
  nullsub_10(a1 + 88);
  nullsub_10(a1 + 80);
  nullsub_10(a1 + 72);
  nullsub_10(a1 + 64);
  nullsub_10(a1 + 56);
  return sub_10008D5F4((void *)a1);
}

void sub_1000BD8CC(uint64_t a1)
{
  uint64_t v1 = sub_1000BD820(a1);
  operator delete(v1);
}

void sub_1000BD8E0(uint64_t a1)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  v10[2] = sub_1000BDA88;
  v10[3] = &unk_10181D3D0;
  void v10[4] = a1;
  *(void *)(a1 + 168) = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, v10);
  sub_1002F0B04(&v12);
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsCustomLoiMaxRecordingWindow", 0x8000100u, kCFAllocatorNull);
  int v3 = sub_1002A77CC(v12, (uint64_t)v2, &v11);
  CFRelease(v2);
  unsigned int v4 = v11;
  CFStringRef v5 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  if (v3) {
    int64_t v8 = 1000000000LL * v4;
  }
  else {
    int64_t v8 = 3600000000000LL;
  }
  dispatch_time_t v9 = dispatch_time(0LL, v8);
  dispatch_after(v9, *(dispatch_queue_t *)(a1 + 160), *(dispatch_block_t *)(a1 + 168));
}

void sub_1000BDA0C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16)
  {
    p_shared_owners = (unint64_t *)&a16->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_1000BDA54(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 168);
  if (v2)
  {
    dispatch_block_cancel(v2);
    _Block_release(*(const void **)(a1 + 168));
    *(void *)(a1 + 168) = 0LL;
  }

void sub_1000BDA88(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1000C0314(v2);
  sub_10008DBE0((void *)v1, (uint64_t)v2);
  _Block_release(*(const void **)(v1 + 168));
  *(void *)(v1 + 168) = 0LL;
  v2[0] = &off_10181D7E8;
  if (v3 < 0) {
    operator delete((void *)v2[1]);
  }
}

void sub_1000BDAEC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000BDB18(uint64_t a1)
{
  *(void *)a1 = &off_10181D7E8;
  return a1;
}

void sub_1000BDB58(uint64_t a1)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  v10[2] = sub_1000BDD04;
  v10[3] = &unk_10181D3D0;
  void v10[4] = a1;
  *(void *)(a1 + 176) = dispatch_block_create(DISPATCH_BLOCK_ASSIGN_CURRENT, v10);
  sub_1002F0B04(&v12);
  CFStringRef v2 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsCustomLoiWaitBetweenRecordings",  0x8000100u,  kCFAllocatorNull);
  int v3 = sub_1002A77CC(v12, (uint64_t)v2, &v11);
  CFRelease(v2);
  unsigned int v4 = v11;
  CFStringRef v5 = v13;
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  if (v3) {
    int64_t v8 = 1000000000LL * v4;
  }
  else {
    int64_t v8 = 30000000000LL;
  }
  dispatch_time_t v9 = dispatch_time(0LL, v8);
  dispatch_after(v9, *(dispatch_queue_t *)(a1 + 160), *(dispatch_block_t *)(a1 + 176));
}

void sub_1000BDC88( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a16)
  {
    p_shared_owners = (unint64_t *)&a16->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(p_shared_owners);
    while (__stlxr(v18 - 1, p_shared_owners));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))a16->__on_zero_shared)(a16);
      std::__shared_weak_count::__release_weak(a16);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_1000BDCD0(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 176);
  if (v2)
  {
    dispatch_block_cancel(v2);
    _Block_release(*(const void **)(a1 + 176));
    *(void *)(a1 + 176) = 0LL;
  }

void sub_1000BDD04(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_1000C03A0(v2);
  sub_10008DBE0((void *)v1, (uint64_t)v2);
  _Block_release(*(const void **)(v1 + 176));
  *(void *)(v1 + 176) = 0LL;
  v2[0] = &off_10181D7E8;
  if (v3 < 0) {
    operator delete((void *)v2[1]);
  }
}

void sub_1000BDD68( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000BDD94@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_49;
    }
    while (1)
    {
      int64_t v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        dispatch_time_t v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }

        else
        {
          __int128 v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)__int128 __dst = v10;
        }

        int v11 = SHIBYTE(v31);
        uint64_t v12 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          unint64_t v14 = __p;
        }
        else {
          unint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        char v37 = v13;
        __int16 v38 = 2081;
        id v39 = v14;
        __int16 v40 = 2082;
        id v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v15 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        float v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }

        else
        {
          __int128 v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)__int128 __dst = v17;
        }

        int v18 = SHIBYTE(v31);
        float v19 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        char v37 = v20;
        __int16 v38 = 2081;
        id v39 = v21;
        __int16 v40 = 2082;
        id v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      BOOL v22 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        double v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }

        else
        {
          __int128 v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)__int128 __dst = v24;
        }

        int v25 = SHIBYTE(v31);
        p_vtable = (void **)__dst[0];
        a2 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v26 = __dst;
        if (v25 < 0) {
          uint64_t v26 = p_vtable;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        char v37 = v26;
        __int16 v38 = 2081;
        id v39 = v27;
        __int16 v40 = 2082;
        id v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1019348D0, &stru_10181D7B8);
    }
  }

  return sub_1000BCC8C((uint64_t)a2, a3);
}

void sub_1000BE1EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000BE218(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_10(a1);
  operator delete(v1);
}

void *sub_1000BE22C@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_49;
    }
    while (1)
    {
      int64_t v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        dispatch_time_t v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }

        else
        {
          __int128 v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)__int128 __dst = v10;
        }

        int v11 = SHIBYTE(v31);
        uint64_t v12 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          unint64_t v14 = __p;
        }
        else {
          unint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        char v37 = v13;
        __int16 v38 = 2081;
        id v39 = v14;
        __int16 v40 = 2082;
        id v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v15 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        float v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }

        else
        {
          __int128 v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)__int128 __dst = v17;
        }

        int v18 = SHIBYTE(v31);
        float v19 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        char v37 = v20;
        __int16 v38 = 2081;
        id v39 = v21;
        __int16 v40 = 2082;
        id v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      BOOL v22 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        double v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }

        else
        {
          __int128 v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)__int128 __dst = v24;
        }

        int v25 = SHIBYTE(v31);
        p_vtable = (void **)__dst[0];
        a2 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v26 = __dst;
        if (v25 < 0) {
          uint64_t v26 = p_vtable;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        char v37 = v26;
        __int16 v38 = 2081;
        id v39 = v27;
        __int16 v40 = 2082;
        id v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1019348D0, &stru_10181D7B8);
    }
  }

  (*(void (**)(void *))(*(void *)a2[19] + 24LL))(a2[19]);
  double result = sub_1010DDBC0((void *)a3, "IdleState");
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000BE6A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000BE6D0(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_49;
    }
    while (1)
    {
      unint64_t v7 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        int64_t v8 = (char *)a2[1];
        if (v8[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v8 + 1), *((void *)v8 + 2));
        }

        else
        {
          __int128 v9 = *(_OWORD *)(v8 + 8);
          uint64_t v30 = *((void *)v8 + 3);
          *(_OWORD *)__int128 __dst = v9;
        }

        int v10 = SHIBYTE(v30);
        int v11 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v12 = __dst;
        if (v10 < 0) {
          uint64_t v12 = v11;
        }
        if (v28 >= 0) {
          uint64_t v13 = __p;
        }
        else {
          uint64_t v13 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v32 = 0;
        __int16 v33 = 2082;
        __int16 v34 = "";
        __int16 v35 = 2081;
        __int16 v36 = v12;
        __int16 v37 = 2081;
        __int16 v38 = v13;
        __int16 v39 = 2082;
        __int16 v40 = "assert";
        __int16 v41 = 2081;
        __int16 v42 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v28 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v30) < 0) {
          operator delete(__dst[0]);
        }
      }

      unint64_t v14 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        uint64_t v15 = (char *)a2[1];
        if (v15[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v15 + 1), *((void *)v15 + 2));
        }

        else
        {
          __int128 v16 = *(_OWORD *)(v15 + 8);
          uint64_t v30 = *((void *)v15 + 3);
          *(_OWORD *)__int128 __dst = v16;
        }

        int v17 = SHIBYTE(v30);
        int v18 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        float v19 = __dst;
        if (v17 < 0) {
          float v19 = v18;
        }
        if (v28 >= 0) {
          float v20 = __p;
        }
        else {
          float v20 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v32 = 0;
        __int16 v33 = 2082;
        __int16 v34 = "";
        __int16 v35 = 2081;
        __int16 v36 = v19;
        __int16 v37 = 2081;
        __int16 v38 = v20;
        __int16 v39 = 2082;
        __int16 v40 = "assert";
        __int16 v41 = 2081;
        __int16 v42 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v14,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v28 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v30) < 0) {
          operator delete(__dst[0]);
        }
      }

      float v21 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        BOOL v22 = (char *)a2[1];
        if (v22[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v22 + 1), *((void *)v22 + 2));
        }

        else
        {
          __int128 v23 = *(_OWORD *)(v22 + 8);
          uint64_t v30 = *((void *)v22 + 3);
          *(_OWORD *)__int128 __dst = v23;
        }

        int v24 = SHIBYTE(v30);
        p_vtable = (void **)__dst[0];
        a2 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        int v25 = __dst;
        if (v24 < 0) {
          int v25 = p_vtable;
        }
        if (v28 >= 0) {
          uint64_t v26 = __p;
        }
        else {
          uint64_t v26 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v32 = 0;
        __int16 v33 = 2082;
        __int16 v34 = "";
        __int16 v35 = 2081;
        __int16 v36 = v25;
        __int16 v37 = 2081;
        __int16 v38 = v26;
        __int16 v39 = 2082;
        __int16 v40 = "assert";
        __int16 v41 = 2081;
        __int16 v42 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v28 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v30) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1019348D0, &stru_10181D7B8);
    }
  }

  sub_1000BCCF8((uint64_t)a2, a3);
}

void sub_1000BEB28( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000BEB54@<D0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_49;
    }
    while (1)
    {
      int64_t v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }

        else
        {
          __int128 v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)__int128 __dst = v10;
        }

        int v11 = SHIBYTE(v31);
        uint64_t v12 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          unint64_t v14 = __p;
        }
        else {
          unint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v15 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }

        else
        {
          __int128 v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)__int128 __dst = v17;
        }

        int v18 = SHIBYTE(v31);
        float v19 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      BOOL v22 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }

        else
        {
          __int128 v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)__int128 __dst = v24;
        }

        int v25 = SHIBYTE(v31);
        p_vtable = (void **)__dst[0];
        a2 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v26 = __dst;
        if (v25 < 0) {
          uint64_t v26 = p_vtable;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1019348D0, &stru_10181D7B8);
    }
  }

  return sub_1000BCE68((uint64_t)a2, a3);
}

void sub_1000BEFAC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000BEFD8@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_49;
    }
    while (1)
    {
      int64_t v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }

        else
        {
          __int128 v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)__int128 __dst = v10;
        }

        int v11 = SHIBYTE(v31);
        uint64_t v12 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          unint64_t v14 = __p;
        }
        else {
          unint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v15 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }

        else
        {
          __int128 v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)__int128 __dst = v17;
        }

        int v18 = SHIBYTE(v31);
        float v19 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      BOOL v22 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }

        else
        {
          __int128 v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)__int128 __dst = v24;
        }

        int v25 = SHIBYTE(v31);
        p_vtable = (void **)__dst[0];
        a2 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v26 = __dst;
        if (v25 < 0) {
          uint64_t v26 = p_vtable;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        unint64_t v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1019348D0, &stru_10181D7B8);
    }
  }

  (*(void (**)(void *))(*(void *)a2[19] + 24LL))(a2[19]);
  double result = sub_1010DDBC0((void *)a3, "IdleState");
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000BF450( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000BF47C@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_53;
    }
    while (1)
    {
      __int128 v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)a2[1];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)__int128 __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        unint64_t v14 = __dst;
        if (v12 < 0) {
          unint64_t v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __int16 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      __int128 v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)a2[1];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)__int128 __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        float v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        float v21 = __dst;
        if (v19 < 0) {
          float v21 = v20;
        }
        if (v30 >= 0) {
          BOOL v22 = __p;
        }
        else {
          BOOL v22 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __int16 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      __int128 v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)a2[1];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)__int128 __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        a2 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v27 = __dst;
        if (v26 < 0) {
          uint64_t v27 = p_vtable;
        }
        if (v30 >= 0) {
          char v28 = __p;
        }
        else {
          char v28 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __int16 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_53:
      dispatch_once(&qword_1019348D0, &stru_10181D7B8);
    }
  }

  if (*((_BYTE *)a2 + 144) && !*((_BYTE *)a2 + 145)) {
    char v6 = "RecordingState";
  }
  else {
    char v6 = "RecordingPendingState";
  }
  double result = sub_1010DDBC0((void *)a3, v6);
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000BF900( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000BF92C@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_49;
    }
    while (1)
    {
      int64_t v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }

        else
        {
          __int128 v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)__int128 __dst = v10;
        }

        int v11 = SHIBYTE(v31);
        int v12 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          unint64_t v14 = __p;
        }
        else {
          unint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v15 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }

        else
        {
          __int128 v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)__int128 __dst = v17;
        }

        int v18 = SHIBYTE(v31);
        int v19 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      BOOL v22 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }

        else
        {
          __int128 v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)__int128 __dst = v24;
        }

        int v25 = SHIBYTE(v31);
        p_vtable = (void **)__dst[0];
        a2 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        int v26 = __dst;
        if (v25 < 0) {
          int v26 = p_vtable;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1019348D0, &stru_10181D7B8);
    }
  }

  (*(void (**)(void *))(*(void *)a2[19] + 24LL))(a2[19]);
  double result = sub_1010DDBC0((void *)a3, "IdleState");
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000BFDA4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000BFDD0@<X0>(char *lpsrc@<X2>, void **a2@<X1>, uint64_t a3@<X8>)
{
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_49;
    }
    while (1)
    {
      int64_t v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v9 = (char *)a2[1];
        if (v9[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }

        else
        {
          __int128 v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)__int128 __dst = v10;
        }

        int v11 = SHIBYTE(v31);
        int v12 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          unint64_t v14 = __p;
        }
        else {
          unint64_t v14 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v15 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v16 = (char *)a2[1];
        if (v16[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }

        else
        {
          __int128 v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)__int128 __dst = v17;
        }

        int v18 = SHIBYTE(v31);
        int v19 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        float v20 = __dst;
        if (v18 < 0) {
          float v20 = v19;
        }
        if (v29 >= 0) {
          float v21 = __p;
        }
        else {
          float v21 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      BOOL v22 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v23 = (char *)a2[1];
        if (v23[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }

        else
        {
          __int128 v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)__int128 __dst = v24;
        }

        int v25 = SHIBYTE(v31);
        p_vtable = (void **)__dst[0];
        a2 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        int v26 = __dst;
        if (v25 < 0) {
          int v26 = p_vtable;
        }
        if (v29 >= 0) {
          uint64_t v27 = __p;
        }
        else {
          uint64_t v27 = (void **)__p[0];
        }
        *(_DWORD *)std::string buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_49:
      dispatch_once(&qword_1019348D0, &stru_10181D7B8);
    }
  }

  return sub_1000BCED0((uint64_t)a2, a3);
}

void sub_1000C0228( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000C0254(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 148) = 0;
  sub_1000BDCD0(a2);
  sub_1000BDA54(a2);
  return (*(uint64_t (**)(void))(**(void **)(a2 + 152) + 16LL))(*(void *)(a2 + 152));
}

uint64_t sub_1000C0290(uint64_t a1, uint64_t a2)
{
  return (***(uint64_t (****)(void))(a2 + 152))(*(void *)(a2 + 152));
}

void sub_1000C02A0(uint64_t a1, uint64_t a2)
{
}

void sub_1000C02A8(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1000C02D4(void **__p)
{
  void *__p = &off_10181D7E8;
  operator delete(__p);
}

void *sub_1000C0314(void *a1)
{
  *a1 = &off_10181D7E8;
  CFStringRef v2 = (std::string *)sub_1010DDBC0(a1 + 1, "No Name Given");
  *a1 = &off_10181D808;
  std::string::assign(v2, "MaxRecordingTimerFiredEvent");
  return a1;
}

void sub_1000C037C(_Unwind_Exception *exception_object)
{
  uint64_t v4 = v3;
  *(void *)uint64_t v1 = v4;
  _Unwind_Resume(exception_object);
}

void *sub_1000C03A0(void *a1)
{
  *a1 = &off_10181D7E8;
  CFStringRef v2 = (std::string *)sub_1010DDBC0(a1 + 1, "No Name Given");
  *a1 = &off_10181D828;
  std::string::assign(v2, "ThrottleTimerFiredEvent");
  return a1;
}

void sub_1000C0408(_Unwind_Exception *exception_object)
{
  uint64_t v4 = v3;
  *(void *)uint64_t v1 = v4;
  _Unwind_Resume(exception_object);
}

_OWORD *sub_1000C042C(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  char v6 = (void **)sub_1000227E8((uint64_t)a1, &v12, a2);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    int64_t v8 = (uint64_t **)v6;
    unint64_t v7 = operator new(0x40uLL);
    __int128 v9 = *a4;
    uint64_t v10 = *((void *)*a4 + 2);
    v7[2] = **a4;
    *((void *)v7 + 6) = v10;
    v9[1] = 0LL;
    v9[2] = 0LL;
    *__int128 v9 = 0LL;
    *((void *)v7 + 7) = 0LL;
    sub_1000085FC(a1, v12, v8, (uint64_t *)v7);
  }

  return v7;
}

uint64_t sub_1000C04C4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)double result = &off_10181D848;
  *(_BYTE *)(result + 8) = 0;
  *(_BYTE *)(result + 80) = 0;
  *(_BYTE *)(result + 90) = 0;
  *(_BYTE *)(result + 96) = 0;
  *(_BYTE *)(result + 104) = 0;
  *(_BYTE *)(result + 112) = 0;
  *(_BYTE *)(result + 120) = 0;
  *(void *)(result + 128) = a2;
  *(void *)(result + 136) = a3;
  *(_WORD *)(result + 184) = 0;
  *(_WORD *)(result + 201) = 0;
  *(void *)(result + 152) = 0LL;
  *(void *)(result + 160) = 0LL;
  *(void *)(result + 144) = a4;
  *(_BYTE *)(result + 168) = 0;
  *(_DWORD *)(result + 204) = 255;
  return result;
}

uint64_t sub_1000C0510(uint64_t a1, void *a2, _BYTE *a3, double *a4)
{
  if (v11[0])
  {
    char v6 = *(uint64_t **)(a1 + 144);
    int v10 = 0;
    sub_100018E34(&v10);
    *(void *)&__int128 v14 = sub_100017338((ssize_t)&v10);
    *((void *)&v14 + 1) = v7;
    uint64_t v8 = v13;
    if (!v13) {
      uint64_t v8 = *(void *)(qword_1019A0980 + 80);
    }
    sub_1000C064C(&v14, v8, (uint64_t)v15, *a4);
    sub_100042DF8(v6, v15);
    sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v16);
    sub_100019D7C((unsigned int *)&v10);
    sub_1000C06D4(a1, (uint64_t)v12);
  }

  return sub_100086708(v12);
}

void sub_1000C060C(_Unwind_Exception *a1)
{
}

void sub_1000C064C(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_1000C06C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000C06D4(uint64_t a1, uint64_t a2)
{
  int v4 = sub_1000C23BC(a1, a2);
  unsigned int v5 = sub_1000C2B08(a1, a2);
  if ((*(_BYTE *)(a2 + 128) & 4) == 0) {
    goto LABEL_5;
  }
  uint64_t v6 = *(void *)(a2 + 16);
  if (!v6) {
    uint64_t v6 = *(void *)(qword_1019A0980 + 16);
  }
  if ((*(_BYTE *)(v6 + 44) & 4) != 0)
  {
    __int128 v14 = *(__int128 **)(v6 + 16);
    if (*((char *)v14 + 23) < 0)
    {
      sub_1010DD48C(&__dst, *(void **)v14, *((void *)v14 + 1));
    }

    else
    {
      __int128 v15 = *v14;
      __dst.__r_.__value_.__l.__cap_ = *((void *)v14 + 2);
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v15;
    }
  }

  else
  {
LABEL_5:
    sub_1010DDBC0(&__dst, "");
  }

  sub_1010DDBC0(&__str, "localization");
  sub_1010DDBC0(v20, "home");
  if (v4) {
    uint64_t v7 = "success";
  }
  else {
    uint64_t v7 = "fail";
  }
  sub_1010DDBC0(__p, v7);
  uint64_t v8 = (unsigned __int8 *)(a1 + 90);
  char v9 = sub_100111E14(v8);
  sub_100091958(a2, (uint64_t)&__str, (uint64_t)&__dst, (uint64_t)v20, (uint64_t)__p, v9);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  if (v21 < 0) {
    operator delete(v20[0]);
  }
  if ((*(_BYTE *)(a2 + 129) & 4) == 0) {
    goto LABEL_19;
  }
  uint64_t v10 = *(void *)(a2 + 88);
  if (!v10) {
    uint64_t v10 = *(void *)(qword_1019A0980 + 88);
  }
  if ((*(_BYTE *)(v10 + 44) & 4) != 0)
  {
    uint64_t v16 = *(__int128 **)(v10 + 16);
    if (*((char *)v16 + 23) < 0)
    {
      sub_1010DD48C(&__str, *(void **)v16, *((void *)v16 + 1));
    }

    else
    {
      __int128 v17 = *v16;
      __str.__r_.__value_.__l.__cap_ = *((void *)v16 + 2);
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v17;
    }
  }

  else
  {
LABEL_19:
    sub_1010DDBC0(&__str, "");
  }

  std::string::operator=(&__dst, &__str);
  sub_1010DDBC0(&__str, "recording");
  sub_1010DDBC0(v20, "home");
  if (v5) {
    int v11 = "success";
  }
  else {
    int v11 = "fail";
  }
  sub_1010DDBC0(__p, v11);
  char v12 = sub_100111E14(v8);
  sub_100091958(a2, (uint64_t)&__str, (uint64_t)&__dst, (uint64_t)v20, (uint64_t)__p, v12);
  if (v19 < 0) {
    operator delete(__p[0]);
  }
  if (v21 < 0) {
    operator delete(v20[0]);
  }
  return v4 | v5;
}

void sub_1000C0940( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, void *__p, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000C09BC(uint64_t a1, void *a2, _BYTE *a3, double *a4)
{
  if (v11[0])
  {
    uint64_t v6 = *(uint64_t **)(a1 + 144);
    int v10 = 0;
    sub_100018E34(&v10);
    *(void *)&__int128 v14 = sub_100017338((ssize_t)&v10);
    *((void *)&v14 + 1) = v7;
    uint64_t v8 = v13;
    if (!v13) {
      uint64_t v8 = *(void *)(qword_1019A0980 + 24);
    }
    sub_1000C0AF8(&v14, v8, (uint64_t)v15, *a4);
    sub_100042DF8(v6, v15);
    sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v16);
    sub_100019D7C((unsigned int *)&v10);
    sub_1000C06D4(a1, (uint64_t)v12);
  }

  return sub_100086708(v12);
}

void sub_1000C0AB8(_Unwind_Exception *a1)
{
}

void sub_1000C0AF8(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_1000C0B6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000C0B80(uint64_t a1, uint64_t *a2, double *a3)
{
  if (v10[0])
  {
    unsigned int v5 = *(uint64_t **)(a1 + 144);
    int v9 = 0;
    sub_100018E34(&v9);
    *(void *)&__int128 v13 = sub_100017338((ssize_t)&v9);
    *((void *)&v13 + 1) = v6;
    uint64_t v7 = v12;
    if (!v12) {
      uint64_t v7 = *(void *)(qword_1019A0980 + 40);
    }
    sub_1000C0CBC(&v13, v7, (uint64_t)v14, *a3);
    sub_100042DF8(v5, v14);
    sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v15);
    sub_100019D7C((unsigned int *)&v9);
    sub_1000C06D4(a1, (uint64_t)v11);
  }

  return sub_100086708(v11);
}

void sub_1000C0C7C(_Unwind_Exception *a1)
{
}

void sub_1000C0CBC(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_1000C0D30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000C0D44(uint64_t a1, int a2, double *a3)
{
  unsigned int v5 = *(uint64_t **)(a1 + 144);
  int v9 = 0;
  sub_100018E34(&v9);
  *(void *)&__int128 v13 = sub_100017338((ssize_t)&v9);
  *((void *)&v13 + 1) = v6;
  uint64_t v7 = v12;
  if (!v12) {
    uint64_t v7 = *(void *)(qword_1019A0980 + 32);
  }
  sub_1000C0E80(&v13, v7, (uint64_t)v14, *a3);
  sub_100042DF8(v5, v14);
  sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v15);
  sub_100019D7C((unsigned int *)&v9);
  if (v10[0]) {
    sub_1000C06D4(a1, (uint64_t)v11);
  }
  return sub_100086708(v11);
}

void sub_1000C0E40(_Unwind_Exception *a1)
{
}

void sub_1000C0E80(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_1000C0EF4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000C0F08(uint64_t a1, void *a2, double *a3)
{
  if (v14[0])
  {
    if (v18 == 9)
    {
      int v9 = *(uint64_t **)(a1 + 144);
      int v13 = 0;
      sub_100018E34(&v13);
      *(void *)&__int128 v19 = sub_100017338((ssize_t)&v13);
      *((void *)&v19 + 1) = v10;
      uint64_t v11 = v16;
      if (!v16) {
        uint64_t v11 = *(void *)(qword_1019A0980 + 56);
      }
      sub_1000C1154(&v19, v11, (uint64_t)v20, *a3);
      sub_100042DF8(v9, v20);
    }

    else
    {
      if (v18 != 10)
      {
LABEL_12:
        uint64_t v8 = sub_1000C06D4(a1, (uint64_t)v15);
        goto LABEL_13;
      }

      unsigned int v5 = *(uint64_t **)(a1 + 144);
      int v13 = 0;
      sub_100018E34(&v13);
      *(void *)&__int128 v19 = sub_100017338((ssize_t)&v13);
      *((void *)&v19 + 1) = v6;
      uint64_t v7 = v17;
      if (!v17) {
        uint64_t v7 = *(void *)(qword_1019A0980 + 64);
      }
      sub_1000C10CC(&v19, v7, (uint64_t)v20, *a3);
      sub_100042DF8(v5, v20);
    }

    sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v21);
    sub_100019D7C((unsigned int *)&v13);
    goto LABEL_12;
  }

  uint64_t v8 = 0LL;
LABEL_13:
  sub_100086708(v15);
  return v8;
}

void sub_1000C1080( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned int a10)
{
}

void sub_1000C10CC(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_1000C1140( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1000C1154(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_1000C11C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000C11DC(uint64_t a1, double *a2)
{
  if (v9[0])
  {
    int v4 = *(uint64_t **)(a1 + 144);
    int v8 = 0;
    sub_100018E34(&v8);
    *(void *)&__int128 v12 = sub_100017338((ssize_t)&v8);
    *((void *)&v12 + 1) = v5;
    uint64_t v6 = v11;
    if (!v11) {
      uint64_t v6 = *(void *)(qword_1019A0980 + 48);
    }
    sub_1000C1318(&v12, v6, (uint64_t)v13, *a2);
    sub_100042DF8(v4, v13);
    sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v14);
    sub_100019D7C((unsigned int *)&v8);
    sub_1000C06D4(a1, (uint64_t)v10);
  }

  return sub_100086708(v10);
}

void sub_1000C12D8(_Unwind_Exception *a1)
{
}

void sub_1000C1318(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_1000C138C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000C13A0(uint64_t a1, void **a2, void *a3, double *a4)
{
  if (v12[0])
  {
    uint64_t v6 = *(uint64_t **)(a1 + 144);
    int v11 = 0;
    sub_100018E34(&v11);
    *(void *)&__int128 v15 = sub_100017338((ssize_t)&v11);
    *((void *)&v15 + 1) = v7;
    uint64_t v8 = v14;
    if (!v14) {
      uint64_t v8 = *(void *)(qword_1019A0980 + 88);
    }
    sub_1000C14EC(&v15, v8, (uint64_t)v16, *a4);
    sub_100042DF8(v6, v16);
    sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v17);
    sub_100019D7C((unsigned int *)&v11);
    uint64_t v9 = sub_1000C06D4(a1, (uint64_t)v13);
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  sub_100086708(v13);
  return v9;
}

void sub_1000C14AC(_Unwind_Exception *a1)
{
}

void sub_1000C14EC(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_1000C1560( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000C1574(uint64_t a1, const std::string *a2, double *a3)
{
  if (v11[0])
  {
    uint64_t v5 = *(uint64_t **)(a1 + 144);
    int v10 = 0;
    sub_100018E34(&v10);
    *(void *)&__int128 v14 = sub_100017338((ssize_t)&v10);
    *((void *)&v14 + 1) = v6;
    uint64_t v7 = v13;
    if (!v13) {
      uint64_t v7 = *(void *)(qword_1019A0980 + 16);
    }
    sub_1000C16C0(&v14, v7, (uint64_t)v15, *a3);
    sub_100042DF8(v5, v15);
    sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v16);
    sub_100019D7C((unsigned int *)&v10);
    uint64_t v8 = sub_1000C06D4(a1, (uint64_t)v12);
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  sub_100086708(v12);
  return v8;
}

void sub_1000C1680(_Unwind_Exception *a1)
{
}

void sub_1000C16C0(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_1000C1734( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000C1748(uint64_t a1, uint64_t *a2, void *a3, void *a4)
{
  int v5 = *((char *)a2 + 23);
  if (v5 < 0)
  {
    if (a2[1] != 10)
    {
LABEL_10:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D8B0);
      }
      int v10 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        else {
          int v11 = (uint64_t *)*a2;
        }
        *(_DWORD *)std::string buf = 136315138;
        __int128 v19 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "Legacy client do not support labels form any other client than focus-mode ClientReceived: %s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181D8B0);
        }
        else {
          uint64_t v13 = (uint64_t *)*a2;
        }
        int v16 = 136315138;
        uint64_t v17 = v13;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Legacy client do not support labels form any other client than focus-mode ClientReceived: %s",  (const char *)&v16);
        __int128 v15 = (uint8_t *)v14;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMicroLocationLegacyClient::donateTruthTagLabel(const std::string &, const boost::uuids::uuid &, const b oost::uuids::uuid &)",  "%s\n",  v14);
        if (v15 != buf) {
          free(v15);
        }
      }

      return 0LL;
    }

    uint64_t v6 = (uint64_t *)*a2;
  }

  else
  {
    uint64_t v6 = a2;
    if (v5 != 10) {
      goto LABEL_10;
    }
  }

  uint64_t v7 = *v6;
  int v8 = *((unsigned __int16 *)v6 + 4);
  if (v7 != 0x6F6D2D7375636F66LL || v8 != 25956) {
    goto LABEL_10;
  }
  if (!*(_BYTE *)(a1 + 201)) {
    return 0LL;
  }
  return (*(uint64_t (**)(void, void, void, void, void, void, void))(**(void **)(a1 + 128)
                                                                                           + 72LL))( *(void *)(a1 + 128),  *(void *)(a1 + 185),  *(void *)(a1 + 193),  *a4,  a4[1],  *a3,  a3[1]);
}

uint64_t sub_1000C19C8(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v9 = *((char *)a2 + 23);
  if (v9 < 0)
  {
    if (a2[1] != 10)
    {
LABEL_10:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D8B0);
      }
      __int128 v14 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        else {
          __int128 v15 = (uint64_t *)*a2;
        }
        LODWORD(buf[0]) = 136315138;
        *(void *)((char *)buf + 4) = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "Legacy client do not support labels form any other client than focus-mode ClientReceived: %s",  (uint8_t *)buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181D8B0);
        }
        else {
          BOOL v22 = (uint64_t *)*a2;
        }
        int v25 = 136315138;
        int v26 = v22;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Legacy client do not support labels form any other client than focus-mode ClientReceived: %s",  (const char *)&v25);
        __int128 v24 = (char *)v23;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMicroLocationLegacyClient::donateTruthTagLabelForRecordingEventsBetweenDates(const std::string &, const boost::uuids::uuid &, NSDate *, NSDate *)",  "%s\n",  v23);
      }

      return 0LL;
    }

    int v10 = (uint64_t *)*a2;
  }

  else
  {
    int v10 = a2;
    if (v9 != 10) {
      goto LABEL_10;
    }
  }

  uint64_t v11 = *v10;
  int v12 = *((unsigned __int16 *)v10 + 4);
  if (v11 != 0x6F6D2D7375636F66LL || v12 != 25956) {
    goto LABEL_10;
  }
  if (*(_BYTE *)(a1 + 201))
  {
    uint64_t v18 = *(void *)(a1 + 128);
    uint64_t v19 = *(void *)(a1 + 185);
    uint64_t v20 = *(void *)(a1 + 193);
    int v25 = 0;
    sub_100018E34(&v25);
    *(void *)&buf[0] = sub_100017338((ssize_t)&v25);
    *((void *)&buf[0] + 1) = v21;
    uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t))(*(void *)v18 + 88LL))( v18,  v19,  v20,  buf,  a3,  a4,  a5);
    sub_100019D7C((unsigned int *)&v25);
    return v16;
  }

  return 0LL;
}

void sub_1000C1C60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1000C1C7C(uint64_t a1)
{
  return sub_1000226E0(a1 + 8);
}

uint64_t sub_1000C1C84(uint64_t result, char a2)
{
  *(_BYTE *)(result + 202) = a2;
  return result;
}

BOOL sub_1000C1C8C(uint64_t a1, void *a2)
{
  return sub_1000E3B1C(a1 + 91, a2);
}

void sub_1000C1C94(uint64_t a1)
{
  CFStringRef v2 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsEnabled", 0x8000100u, kCFAllocatorNull);
  int v3 = sub_1002A6FD4((uint64_t)__p, (uint64_t)v2, (BOOL *)&v11);
  CFRelease(v2);
  int v4 = v11;
  int v5 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  if (v4) {
    int v8 = v3;
  }
  else {
    int v8 = 0;
  }
  if (v8 == 1)
  {
    if (!*(_BYTE *)(a1 + 184))
    {
      sub_1010DDBC0(&__p, "milo-internal-legacy-client-name-unsupervised");
      uint64_t v14 = 1LL;
      int v9 = operator new(8uLL);
      *int v9 = 0LL;
      int v12 = v9 + 1;
      uint64_t v13 = v9 + 1;
      uint64_t v11 = v9;
      sub_1000C1ED8((void *)a1, (uint64_t)&__p, &v14, (uint64_t)&v11, (uint64_t *)&v18);
      *(_OWORD *)(a1 + 168) = v18;
      *(_BYTE *)(a1 + 184) = v19;
      operator delete(v9);
      if (v17 < 0) {
        operator delete(__p);
      }
    }

    if (!*(_BYTE *)(a1 + 201))
    {
      sub_1010DDBC0(&__p, "focus-mode");
      uint64_t v14 = 2LL;
      int v10 = operator new(8uLL);
      *int v10 = 0LL;
      int v12 = v10 + 1;
      uint64_t v13 = v10 + 1;
      uint64_t v11 = v10;
      sub_1000C1ED8((void *)a1, (uint64_t)&__p, &v14, (uint64_t)&v11, (uint64_t *)&v18);
      *(_OWORD *)(a1 + 185) = v18;
      *(_BYTE *)(a1 + 201) = v19;
      operator delete(v10);
      if (v17 < 0) {
        operator delete(__p);
      }
    }
  }

void sub_1000C1E88( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1000C1ED8(void *a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  *(_BYTE *)a5 = 0;
  *((_BYTE *)a5 + 16) = 0;
  uint64_t v10 = a1[16];
  sub_1010DDBC0(__p, "");
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, _BYTE *))(*(void *)v10 + 32LL))(&v29, v10, a2, __p);
  if (SBYTE3(v40) < 0) {
    operator delete(*(void **)__p);
  }
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D8B0);
  }
  uint64_t v11 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint64_t v12 = *(void *)a2;
    }
    uint64_t v13 = *a3;
    *(void *)std::string __p = 68289538LL;
    *(_WORD *)&__p[8] = 2082;
    *(void *)&std::string __p[10] = "";
    __int16 v39 = 2082;
    uint64_t v40 = v12;
    __int16 v41 = 2050;
    uint64_t v42 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationLegacyClient: tryCreateServiceAndConnect, clientName:%{public, locatio n:escape_only}s, serviceType:%{public}lld}",  __p,  0x26u);
  }

  if (v29 != v30)
  {
    __int128 v14 = *(_OWORD *)v29;
LABEL_19:
    *(_OWORD *)a5 = v14;
    *((_BYTE *)a5 + 16) = 1;
    uint64_t v17 = a1[16];
    uint64_t v18 = *a5;
    uint64_t v19 = a5[1];
    uint64_t v20 = a1[19];
    uint64_t v21 = a1[20];
    sub_1010DDBC0(__p, "");
    uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *))(*(void *)v17 + 40LL))( v17,  a2,  v18,  v19,  v20,  v21,  __p);
    if (SBYTE3(v40) < 0) {
      operator delete(*(void **)__p);
    }
    if (v22 != -1)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D8B0);
      }
      __int128 v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)std::string __p = 68289282LL;
        *(_WORD *)&__p[8] = 2082;
        *(void *)&std::string __p[10] = "";
        __int16 v39 = 2050;
        uint64_t v40 = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to connect, errorId :%{public}lld}",  __p,  0x1Cu);
      }

      *((_BYTE *)a5 + 16) = 0;
    }

    goto LABEL_27;
  }

  uint64_t v15 = a1[16];
  uint64_t v16 = *a3;
  uint64_t v27 = 0LL;
  uint64_t v28 = 0LL;
  int v26 = 0LL;
  sub_100007590(&v26, *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
  sub_1010DDBC0(buf, "");
  (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t, uint64_t, void **, uint8_t *))(*(void *)v15 + 16LL))( __p,  v15,  a2,  v16,  &v26,  buf);
  if (SBYTE3(v35) < 0) {
    operator delete(*(void **)buf);
  }
  if (v26)
  {
    uint64_t v27 = v26;
    operator delete(v26);
  }

  if (v43 == -1 && BYTE2(v42))
  {
    __int128 v14 = *(_OWORD *)__p;
    goto LABEL_19;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D8B0);
  }
  __int128 v24 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)std::string buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v32 = 2082;
    int v33 = "";
    __int16 v34 = 2050;
    uint64_t v35 = v43;
    __int16 v36 = 1026;
    int v37 = BYTE2(v42);
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to create a new service, errorId:%{public}lld, descriptorHasValue:%{public}hhd}",  buf,  0x22u);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D8B0);
    }
  }

  int v25 = (os_log_s *)qword_1019348D8;
  if (os_signpost_enabled((os_log_t)qword_1019348D8))
  {
    *(_DWORD *)std::string buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v32 = 2082;
    int v33 = "";
    __int16 v34 = 2050;
    uint64_t v35 = v43;
    __int16 v36 = 1026;
    int v37 = BYTE2(v42);
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v25,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to create a new service",  "{msg%{public}.0s:CLMicroLocationLegacyClient: tryCreateServiceAndConnect: failed to create a new service, errorId:%{public}lld, descriptorHasValue:%{public}hhd}",  buf,  0x22u);
  }

void sub_1000C233C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a9) {
    operator delete(a9);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000C23BC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 96;
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 96LL))(*(void *)(a1 + 128));
  int v6 = sub_10012F858(v4, a2, v5);
  double v7 = *(double *)(a2 + 8);
  double v39 = v7;
  if (!v6) {
    return 0LL;
  }
  uint64_t v8 = sub_10012FEC0(v4);
  unsigned __int8 v10 = v9;
  sub_1002F0B04(buf);
  CFStringRef v11 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsLocalizingThrottleDuration", 0x8000100u, kCFAllocatorNull);
  int v12 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v11, &v43);
  CFRelease(v11);
  unsigned int v13 = v43;
  __int128 v14 = *(std::__shared_weak_count **)v47;
  if (*(void *)v47)
  {
    uint64_t v15 = (unint64_t *)(*(void *)v47 + 8LL);
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  double v17 = 300.0;
  if (v12) {
    double v17 = (double)v13;
  }
  if (sub_10012FD3C(v7, v17, v4, v6, v8, v10))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D8B0);
    }
    uint64_t v18 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Legacy throttled request", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D8B0);
      }
      LOWORD(v43) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Legacy throttled request",  &v43,  2);
      __int16 v38 = (uint8_t *)v37;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationLegacyClient::requestLocalizationIfPossible(const CLMicroLocationProto::RecordingEvent &)",  "%s\n",  v37);
      if (v38 != buf) {
        free(v38);
      }
    }

    sub_100063984((uint64_t)&v43);
    v45 |= 2u;
    uint64_t v19 = (std::string *)v44;
    if ((_UNKNOWN *)v44 == &wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v19 = (std::string *)operator new(0x18uLL);
      v19->__r_.__value_.__r.__words[0] = 0LL;
      v19->__r_.__value_.__l.__size_ = 0LL;
      v19->__r_.__value_.__l.__cap_ = 0LL;
      *(void *)&__int128 v44 = v19;
    }

    std::string::assign(v19, "");
    uint64_t v20 = *(uint64_t **)(a1 + 144);
    LODWORD(v42[0]) = 0;
    sub_100018E34((int *)v42);
    std::string __p = (void *)sub_100017338((ssize_t)v42);
    *(void *)&__int128 v41 = v21;
    double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
    sub_1000C2E94(&__p, (uint64_t)&v43, (uint64_t)buf, Current_1);
    sub_100042DF8(v20, (__int128 *)buf);
    sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)((char *)&v51 + 2));
    sub_100019D7C((unsigned int *)v42);
    sub_10007EF14((wireless_diagnostics::google::protobuf::MessageLite *)&v43);
    return 0LL;
  }

  if (*(_BYTE *)(a1 + 184))
  {
    *(_DWORD *)std::string buf = 0;
    sub_100018E34((int *)buf);
    v42[0] = sub_100017338((ssize_t)buf);
    v42[1] = v23;
    sub_100019D7C((unsigned int *)buf);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181D8B0);
    }
    __int128 v24 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      if (!*(_BYTE *)(a1 + 184)) {
        sub_100036CD8();
      }
      int v25 = operator new(0x28uLL);
      uint64_t v43 = v25;
      __int128 v44 = xmmword_1012C8460;
      _OWORD *v25 = 0u;
      v25[1] = 0u;
      *(void *)((char *)v25 + 29) = 0LL;
      sub_10000AE6C(a1 + 168, v25);
      if (v44 >= 0) {
        int v26 = (char *)&v43;
      }
      else {
        int v26 = (char *)v43;
      }
      uint64_t v27 = operator new(0x28uLL);
      std::string __p = v27;
      __int128 v41 = xmmword_1012C8460;
      *uint64_t v27 = 0u;
      v27[1] = 0u;
      *(void *)((char *)v27 + 29) = 0LL;
      sub_10000AE6C((uint64_t)v42, v27);
      p_p = (char *)&__p;
      if (v41 < 0) {
        p_p = (char *)__p;
      }
      *(_DWORD *)std::string buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v47 = 2082;
      *(void *)&v47[2] = "";
      __int16 v48 = 2082;
      uint64_t v49 = v26;
      __int16 v50 = 2082;
      uint64_t v51 = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationLegacyClient: request localization for legacy unsupervised, Service ID :%{public, location:escape_only}s, Request ID:%{public, location:escape_only}s}",  buf,  0x26u);
      if (SHIBYTE(v41) < 0) {
        operator delete(__p);
      }
      if (SHIBYTE(v44) < 0) {
        operator delete(v43);
      }
    }

    if (!*(_BYTE *)(a1 + 184)) {
      sub_100036CD8();
    }
    uint64_t v29 = (*(uint64_t (**)(void, void, void, void *, double *, BOOL))(**(void **)(a1 + 128) + 56LL))( *(void *)(a1 + 128),  *(void *)(a1 + 168),  *(void *)(a1 + 176),  v42,  &v39,  v6 == 1);
    uint64_t v30 = v29;
    uint64_t v31 = (_BYTE *)(a1 + 201);
    if (!*(_BYTE *)(a1 + 201))
    {
      if (!(_DWORD)v29) {
        return v30;
      }
LABEL_44:
      sub_10012FE88(v4, (uint64_t *)&v39);
      return 1LL;
    }

void sub_1000C2A54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, char a26)
{
}

uint64_t sub_1000C2B08(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 96;
  int v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 96LL))(*(void *)(a1 + 128));
  unint64_t v6 = sub_10012F858(v4, a2, v5);
  double v38 = *(double *)(a2 + 8);
  if (!*(_BYTE *)(a1 + 184)) {
    return 0LL;
  }
  unint64_t v7 = HIDWORD(v6);
  BOOL v8 = !*(_BYTE *)(a1 + 201) || HIDWORD(v6) == 0;
  if (v8 || *(_BYTE *)(a1 + 202)) {
    return 0LL;
  }
  sub_1002F0B04(&v42);
  CFStringRef v9 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsRecordingThrottleDuration", 0x8000100u, kCFAllocatorNull);
  int v10 = sub_1002A77CC(v42, (uint64_t)v9, &v39);
  CFRelease(v9);
  uint64_t v11 = v39;
  int v12 = v43;
  if (v43)
  {
    p_shared_owners = (unint64_t *)&v43->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  if (v10) {
    uint64_t v15 = v11;
  }
  else {
    uint64_t v15 = 1200LL;
  }
  if (*(_DWORD *)(a1 + 204) == 1)
  {
    sub_1002F0B04(&v42);
    CFStringRef v16 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsRecordingThrottleDurationUnstableModel",  0x8000100u,  kCFAllocatorNull);
    int v17 = sub_1002A77CC(v42, (uint64_t)v16, &v39);
    CFRelease(v16);
    uint64_t v18 = v39;
    uint64_t v19 = v43;
    if (v43)
    {
      uint64_t v20 = (unint64_t *)&v43->__shared_owners_;
      do
        unint64_t v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }

    if (v17) {
      uint64_t v15 = v18;
    }
    else {
      uint64_t v15 = 60LL;
    }
  }

  uint64_t v22 = sub_10012FECC(v4);
  if ((*(_BYTE *)(a2 + 129) & 4) == 0) {
    goto LABEL_31;
  }
  uint64_t v24 = *(void *)(a2 + 88);
  if (!v24) {
    uint64_t v24 = *(void *)(qword_1019A0980 + 88);
  }
  if ((*(_BYTE *)(v24 + 44) & 8) != 0 && (sub_1001014F0(*(uint64_t ***)(v24 + 24), &v42), v44))
  {
    uint64_t v25 = v42;
    int v26 = v43;
  }

  else
  {
LABEL_31:
    LODWORD(v42) = 0;
    sub_100018E34((int *)&v42);
    uint64_t v25 = sub_100017338((ssize_t)&v42);
    int v26 = v27;
    sub_100019D7C((unsigned int *)&v42);
  }

  if (*(_BYTE *)(a1 + 184))
  {
    uint64_t v28 = *(void *)(a1 + 128);
    uint64_t v29 = *(void *)(a1 + 168);
    uint64_t v30 = *(void *)(a1 + 176);
    LODWORD(v42) = 0;
    sub_100018E34((int *)&v42);
    uint64_t v31 = sub_100017338((ssize_t)&v42);
    v41[0] = 0;
    v41[16] = 0;
    int v33 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, double *))(*(void *)v28 + 64LL))( v28,  v29,  v30,  v31,  v32,  v41,  &v38);
    sub_100019D7C((unsigned int *)&v42);
    if (!*(_BYTE *)(a1 + 201))
    {
      if (!v33) {
        return 0LL;
      }
LABEL_39:
      sub_10012FEA4(v4, (uint64_t *)&v38);
      return 1LL;
    }

void sub_1000C2E58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000C2E94(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_1000C2F08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

id sub_1000C2F1C(uint64_t a1, double *a2)
{
  uint64_t v4 = *(id **)(a1 + 136);
  id v5 = sub_1006DBB28(a2);
  sub_100055A6C(v4, v5);
  uint64_t v6 = *(void *)(a1 + 136);
  id v7 = sub_1006DB6DC((uint64_t)a2);
  return sub_100055C98(v6, v7);
}

void sub_1000C2F70(uint64_t a1, void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = a4[18];
  uint64_t v7 = a4[19];
  if (v8 == v7)
  {
    BOOL v11 = 0;
  }

  else
  {
    uint64_t v9 = v8 + 4;
    do
    {
      int v10 = *(_DWORD *)(v9 - 4);
      BOOL v11 = v10 == 3;
      BOOL v12 = v10 == 3 || v9 == v7;
      v9 += 4LL;
    }

    while (!v12);
  }

  uint64_t v13 = *a4;
  uint64_t v14 = a4[1];
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D8B0);
  }
  uint64_t v15 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v26 = 2082;
    uint64_t v27 = "";
    __int16 v28 = 1026;
    BOOL v29 = v11;
    LOWORD(v30) = 1026;
    *(_DWORD *)((char *)&v30 + 2) = v13 == v14;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Not publishing to Legacy client, because test FP is invalid:%{public}hhd, because p robability vector is empty:%{public}hhd}",  buf,  0x1Eu);
  }

  char v16 = v13 == v14 || v11;
  if ((v16 & 1) == 0)
  {
    if (*(_BYTE *)(a1 + 184))
    {
      if (*(void *)(a1 + 168) == *a2 && *(void *)(a1 + 176) == a2[1])
      {
        unsigned __int8 v23 = 0LL;
        uint64_t v24 = 0LL;
        uint64_t v22 = (uint64_t *)&v23;
        CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
        sub_1000C3838(buf, &xmmword_1019A09F0, (uint64_t)a4);
        sub_1000C3AC0(&v22, (__int128 *)buf);
        if (__p)
        {
          double v38 = __p;
          operator delete(__p);
        }

        if (v36) {
          sub_10004AD90((uint64_t)v35);
        }
        if (v34 && v33 < 0) {
          operator delete(v32);
        }
        if (v30)
        {
          uint64_t v31 = v30;
          operator delete(v30);
        }

        if (SHIBYTE(v29) < 0) {
          operator delete(*(void **)buf);
        }
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181D8B0);
        }
        uint64_t v18 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)std::string buf = 68289026;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v26 = 2082;
          uint64_t v27 = "";
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Legacy client Publishing unsupervised localization results to Biome}",  buf,  0x12u);
        }

        sub_1000C2F1C(a1, &Current_1);
        sub_1000C39FC((uint64_t)&v22, v23);
      }
    }

    if (*(_BYTE *)(a1 + 201))
    {
      if (*(void *)(a1 + 185) == *a2 && *(void *)(a1 + 193) == a2[1])
      {
        unsigned __int8 v23 = 0LL;
        uint64_t v24 = 0LL;
        CFAbsoluteTime Current_1 = 0.0;
        uint64_t v22 = (uint64_t *)&v23;
        CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
        sub_1000C3838(buf, &xmmword_1019A0A08, (uint64_t)a4);
        sub_1000C3AC0(&v22, (__int128 *)buf);
        if (__p)
        {
          double v38 = __p;
          operator delete(__p);
        }

        if (v36) {
          sub_10004AD90((uint64_t)v35);
        }
        if (v34 && v33 < 0) {
          operator delete(v32);
        }
        if (v30)
        {
          uint64_t v31 = v30;
          operator delete(v30);
        }

        if (SHIBYTE(v29) < 0) {
          operator delete(*(void **)buf);
        }
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181D8B0);
        }
        uint64_t v20 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)std::string buf = 68289026;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v26 = 2082;
          uint64_t v27 = "";
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Legacy client Publishing focusMode localization results to Biome}",  buf,  0x12u);
        }

        sub_1000C2F1C(a1, &Current_1);
        sub_1000C39FC((uint64_t)&v22, v23);
      }
    }
  }

void sub_1000C3368( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
}

uint64_t sub_1000C33C0(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 168);
  if (v2)
  {
    *(void *)(a1 + 176) = v2;
    operator delete(v2);
  }

  if (*(_BYTE *)(a1 + 152)) {
    sub_10004AD90(a1 + 112);
  }
  int v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }

  return a1;
}

void sub_1000C3438(uint64_t a1, uint64_t *a2)
{
  if (*(_BYTE *)(a1 + 184))
  {
    if (*(void *)(a1 + 168) == a2[4] && *(void *)(a1 + 176) == a2[5])
    {
      uint64_t v6 = (void *)a2[1];
      id v5 = (void *)a2[2];
      if (v6 != v5)
      {
        while (*v6 != 1LL)
        {
          if (++v6 == v5)
          {
            uint64_t v6 = (void *)a2[2];
            break;
          }
        }
      }

      uint64_t v8 = (void *)a2[10];
      uint64_t v7 = (void *)a2[11];
      if (v8 != v7)
      {
        while (*v8 != 3LL)
        {
          if (++v8 == v7)
          {
            uint64_t v8 = (void *)a2[11];
            break;
          }
        }
      }

      uint64_t v9 = *a2;
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181D8B0);
      }
      int v10 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = a2[9];
        *(_DWORD *)std::string buf = 68290050;
        int v24 = 0;
        __int16 v25 = 2082;
        __int16 v26 = "";
        __int16 v27 = 1026;
        BOOL v28 = v9 == 1;
        __int16 v29 = 1026;
        BOOL v30 = v6 != v5;
        __int16 v31 = 1026;
        BOOL v32 = v8 != v7;
        __int16 v33 = 1026;
        int v34 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationLegacyClient Service Status update, isSuspended:%{public}hhd, is ReasonModelUnavailable:%{public}hhd, isQualityReasonLowObservations:%{public}hhd, service quality:%{public}d}",  buf,  0x2Au);
      }

      BOOL v12 = v6 != v5 && v9 == 1;
      if (v12 || v8 != v7)
      {
        int v13 = 1;
      }

      else if (*a2)
      {
        int v13 = 255;
      }

      else
      {
        int v13 = 2;
      }

      *(_DWORD *)(a1 + 204) = v13;
      sub_100063AEC((uint64_t)v19);
      int v14 = *(_DWORD *)(a1 + 204);
      if (!sub_1000641C4(v14)) {
        __assert_rtn( "set_numberofobservationsstate",  "microlocation.pb.h",  20901,  "::CLMicroLocationProto::NumberOfObservationsStates_IsValid(value)");
      }
      v21 |= 2u;
      int v20 = v14;
      uint64_t v15 = *(uint64_t **)(a1 + 144);
      int v18 = 0;
      sub_100018E34(&v18);
      *(void *)&__int128 v22 = sub_100017338((ssize_t)&v18);
      *((void *)&v22 + 1) = v16;
      double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
      sub_1000C36FC(&v22, (uint64_t)v19, (uint64_t)buf, Current_1);
      sub_100042DF8(v15, (__int128 *)buf);
      sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v32);
      sub_100019D7C((unsigned int *)&v18);
      sub_100088CFC((wireless_diagnostics::google::protobuf::MessageLite *)v19);
    }
  }

void sub_1000C36BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned int a10, char a11)
{
}

void sub_1000C36FC(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_1000C3770( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000C3794(uint64_t a1)
{
  *(void *)a1 = &off_10181D848;
  if (*(_BYTE *)(a1 + 80)) {
    sub_100078068(a1 + 8);
  }
  return a1;
}

void sub_1000C37D0(char *__p)
{
  *(void *)std::string __p = &off_10181D848;
  if (__p[80]) {
    sub_100078068(__p + 8);
  }
  operator delete(__p);
}

void sub_1000C380C(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_1000C3838(void *__dst, __int128 *a2, uint64_t a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v5 = *a2;
    __dst[2] = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }

  sub_1000C38B0((uint64_t)(__dst + 3), a3);
  return __dst;
}

void sub_1000C3894(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1000C38B0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  sub_10004B8FC( (void *)a1,  *(const void **)a2,  *(void *)(a2 + 8),  (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 5);
  __int128 v4 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
  *(_OWORD *)(a1 + 24) = v4;
  sub_10004B7D4(a1 + 56, (__int128 *)(a2 + 56));
  sub_1000C39A0((_BYTE *)(a1 + 88), a2 + 88);
  int v5 = *(_DWORD *)(a2 + 136);
  *(void *)(a1 + 144) = 0LL;
  *(_DWORD *)(a1 + 136) = v5;
  *(void *)(a1 + 152) = 0LL;
  *(void *)(a1 + 160) = 0LL;
  sub_10001B72C( (void *)(a1 + 144),  *(const void **)(a2 + 144),  *(void *)(a2 + 152),  (uint64_t)(*(void *)(a2 + 152) - *(void *)(a2 + 144)) >> 2);
  return a1;
}

void sub_1000C394C(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 128)) {
    sub_10004AD90(v3);
  }
  int v5 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(exception_object);
}

_BYTE *sub_1000C39A0(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[40] = 0;
  if (*(_BYTE *)(a2 + 40))
  {
    sub_10004AE0C((uint64_t)a1, a2);
    a1[40] = 1;
  }

  return a1;
}

void sub_1000C39E0(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 40)) {
    sub_10004AD90(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C39FC(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1000C39FC(a1, *a2);
    sub_1000C39FC(a1, a2[1]);
    sub_1000C3A44((uint64_t)(a2 + 4));
    operator delete(a2);
  }

void sub_1000C3A44(uint64_t a1)
{
  CFStringRef v2 = *(void **)(a1 + 168);
  if (v2)
  {
    *(void *)(a1 + 176) = v2;
    operator delete(v2);
  }

  if (*(_BYTE *)(a1 + 152)) {
    sub_10004AD90(a1 + 112);
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }

uint64_t *sub_1000C3AC0(uint64_t **a1, __int128 *a2)
{
  __int128 v4 = (uint64_t *)(a1 + 1);
  v9[0] = (uint64_t *)operator new(0xE0uLL);
  v9[1] = v4;
  sub_1000C3BE0((uint64_t)(v9[0] + 4), a2);
  char v10 = 1;
  int v5 = (uint64_t **)sub_1000C3B68((uint64_t)a1, &v8, (const void **)v9[0] + 4);
  sub_1000085FC(a1, v8, v5, v9[0]);
  uint64_t v6 = v9[0];
  v9[0] = 0LL;
  sub_1000C3CCC((uint64_t)v9, 0LL);
  return v6;
}

void sub_1000C3B50(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_1000C3B68(uint64_t a1, void *a2, const void **a3)
{
  int v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        int v5 = (void *)v4;
        uint64_t v4 = *v5;
        uint64_t result = v5;
        if (!*v5) {
          goto LABEL_9;
        }
      }

      uint64_t v4 = v5[1];
    }

    while (v4);
    uint64_t result = v5 + 1;
  }

  else
  {
    uint64_t result = (void *)(a1 + 8);
  }

uint64_t sub_1000C3BE0(uint64_t a1, __int128 *a2)
{
  __int128 v4 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((void *)a2 + 1) = 0LL;
  *((void *)a2 + 2) = 0LL;
  *(void *)a2 = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(_OWORD *)(a1 + 24) = *(__int128 *)((char *)a2 + 24);
  *(void *)(a1 + 40) = *((void *)a2 + 5);
  *((void *)a2 + 3) = 0LL;
  *((void *)a2 + 4) = 0LL;
  *((void *)a2 + 5) = 0LL;
  __int128 v5 = a2[3];
  __int128 v6 = *(__int128 *)((char *)a2 + 57);
  *(_BYTE *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 57) = v6;
  *(_OWORD *)(a1 + 48) = v5;
  *(_BYTE *)(a1 + 104) = 0;
  if (*((_BYTE *)a2 + 104))
  {
    __int128 v7 = a2[5];
    *(void *)(a1 + 96) = *((void *)a2 + 12);
    *(_OWORD *)(a1 + 80) = v7;
    *((void *)a2 + 11) = 0LL;
    *((void *)a2 + 12) = 0LL;
    *((void *)a2 + 10) = 0LL;
    *(_BYTE *)(a1 + 104) = 1;
  }

  *(_BYTE *)(a1 + 112) = 0;
  uint64_t v8 = a1 + 112;
  *(_BYTE *)(a1 + 152) = 0;
  if (*((_BYTE *)a2 + 152))
  {
    sub_10001B9CC(v8, (uint64_t *)a2 + 14);
    *(_BYTE *)(a1 + 152) = 1;
  }

  *(_DWORD *)(a1 + 160) = *((_DWORD *)a2 + 40);
  *(void *)(a1 + 176) = 0LL;
  *(void *)(a1 + 184) = 0LL;
  *(void *)(a1 + 168) = 0LL;
  *(_OWORD *)(a1 + 168) = *(__int128 *)((char *)a2 + 168);
  *(void *)(a1 + 184) = *((void *)a2 + 23);
  *((void *)a2 + 21) = 0LL;
  *((void *)a2 + 22) = 0LL;
  *((void *)a2 + 23) = 0LL;
  return a1;
}

void sub_1000C3CCC(uint64_t a1, uint64_t a2)
{
  CFStringRef v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_1000C3A44((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

id sub_1000C3D84(uint64_t a1)
{
  id result = objc_alloc_init(*(Class *)(a1 + 32));
  qword_101993A48 = (uint64_t)result;
  return result;
}

void sub_1000C3E10(const std::string *a1@<X1>, double *a2@<X2>, _BYTE *a3@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181D8D0);
  }
  __int128 v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    if ((a1->__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v7 = a1;
    }
    else {
      __int128 v7 = (const std::string *)a1->__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string buf = 68289282;
    int v20 = 0;
    __int16 v21 = 2082;
    __int128 v22 = "";
    __int16 v23 = 2082;
    int v24 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationLogic: client request localization scan, client:%{public, location:escape_only}s}",  buf,  0x1Cu);
  }

  sub_100063550(&v15);
  v18 |= 4u;
  uint64_t v8 = v17;
  if (v17 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
  {
    uint64_t v8 = (std::string *)operator new(0x18uLL);
    v8->__r_.__value_.__r.__words[0] = 0LL;
    v8->__r_.__value_.__l.__size_ = 0LL;
    v8->__r_.__value_.__l.__cap_ = 0LL;
    int v17 = v8;
  }

  std::string::operator=(v8, a1);
  int size = (char)a1->__r_.__value_.__s.__size_;
  if (size < 0)
  {
    if (a1->__r_.__value_.__l.__size_ != 18)
    {
LABEL_19:
      int v13 = 1;
      goto LABEL_26;
    }

    a1 = (const std::string *)a1->__r_.__value_.__r.__words[0];
  }

  else if (size != 18)
  {
    goto LABEL_19;
  }

  unint64_t v10 = 0x4E6F746966696361LL;
  unint64_t v11 = bswap64(a1->__r_.__value_.__r.__words[0]);
  if (v11 == 0x4E6F746966696361LL
    && (unint64_t v10 = 0x74696F6E43656E74LL, v11 = bswap64(a1->__r_.__value_.__l.__size_), v11 == 0x74696F6E43656E74LL)
    && (v11 = bswap32(LOWORD(a1->__r_.__value_.__r.__words[2])) >> 16, unint64_t v10 = 25970LL, (_DWORD)v11 == 25970))
  {
    int v12 = 0;
  }

  else if (v11 < v10)
  {
    int v12 = -1;
  }

  else
  {
    int v12 = 1;
  }

  if (v12) {
    int v13 = 1;
  }
  else {
    int v13 = 3;
  }
LABEL_26:
  if (!sub_10006417C(v13)) {
    __assert_rtn( "set_receivedeventactiontype",  "microlocation.pb.h",  12856,  "::CLMicroLocationProto::ReceivedEventActionType_IsValid(value)");
  }
  v18 |= 2u;
  int v16 = v13;
  sub_1000C40E8((uint64_t)&v15, 0, 0, 3u, (uint64_t)v14, *a2);
  buf[0] = 1;
  sub_1000865CC(&v21);
  *a3 = buf[0];
  sub_1000865CC(a3 + 8);
  sub_100086708(&v21);
  sub_100086708(v14);
  sub_100071810((wireless_diagnostics::google::protobuf::MessageLite *)&v15);
}

void sub_1000C40A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_1000C40E8( uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12 = *(_DWORD *)(a1 + 8);
  if (!sub_100064160(v12))
  {
    int v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    int v16 = "set_eventtype";
    goto LABEL_6;
  }

  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_100064130(a4) & 1) == 0)
  {
    int v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    int v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }

  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_100101B48(a5, a1);
}

void sub_1000C41CC(_Unwind_Exception *a1)
{
}

void sub_1000C41E0(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_1000C420C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_10181D900;
  *(void *)(a1 + 8) = off_10181D9E8;
  *(void *)(a1 + 16) = off_10181DA18;
  *(void *)(a1 + 24) = off_10181DA50;
  *(void *)(a1 + 32) = off_10181DAA0;
  *(void *)(a1 + 40) = off_10181DAD8;
  *(void *)(a1 + 48) = 0LL;
  *(_BYTE *)(a1 + 56) = 0;
  uint64_t v4 = a1 + 64;
  sub_1000C6980((_BYTE *)(a1 + 64), (uint64_t)&byte_1019A18B0);
  *(void *)(a1 + 160) = 0LL;
  *(void *)(a1 + 168) = 0LL;
  *(void *)(a1 + 176) = 0LL;
  __int128 v5 = operator new(0x68uLL);
  *(_OWORD *)(a1 + 184) = 0u;
  *(void *)(a1 + 176) = (char *)v5 + 104;
  *__int128 v5 = xmmword_1012CB930;
  v5[1] = xmmword_1012CB940;
  v5[2] = xmmword_1012CB950;
  void v5[3] = xmmword_1012CB960;
  v5[4] = xmmword_1012CB970;
  v5[5] = xmmword_1012CB980;
  *((void *)v5 + 12) = 13LL;
  *(void *)(a1 + 160) = v5;
  *(void *)(a1 + 168) = (char *)v5 + 104;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 209) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 264) = a2;
  uint64_t v14 = 0LL;
  uint64_t v15 = sub_1000C44DC();
  sub_1000C6C00((uint64_t)&v16, a1 + 160, v4, &v15, (double *)&v14, a1, &v17);
  sub_10005F550(a1 + 184, &v17);
  __int128 v6 = (std::__shared_weak_count *)*((void *)&v17 + 1);
  if (*((void *)&v17 + 1))
  {
    __int128 v7 = (unint64_t *)(*((void *)&v17 + 1) + 8LL);
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  uint64_t v9 = sub_1000C45B4();
  uint64_t v14 = 0LL;
  uint64_t v15 = v9;
  sub_1000C7158((uint64_t)&v16, a1 + 160, v4, &v15, (double *)&v14, a1, &v17);
  sub_10005F550(a1 + 200, &v17);
  unint64_t v10 = (std::__shared_weak_count *)*((void *)&v17 + 1);
  if (*((void *)&v17 + 1))
  {
    unint64_t v11 = (unint64_t *)(*((void *)&v17 + 1) + 8LL);
    do
      unint64_t v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }

  return a1;
}

void sub_1000C4404(_Unwind_Exception *a1)
{
  uint64_t v7 = *(void *)(v1 + 256);
  *(void *)(v1 + 256) = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  uint64_t v8 = *(void *)(v1 + 248);
  *(void *)(v1 + 248) = 0LL;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  uint64_t v9 = *(void *)(v1 + 240);
  *(void *)(v1 + 240) = 0LL;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8LL))(v9);
  }
  uint64_t v10 = *v5;
  *__int128 v5 = 0LL;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  sub_10000AE14(v4);
  sub_10000AE14(v3);
  unint64_t v11 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 168) = v11;
    operator delete(v11);
  }

  uint64_t v12 = *(void *)(v1 + 48);
  *(void *)(v1 + 48) = 0LL;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8LL))(v12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000C44DC()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsLocalizingDurationMinimum", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  uint64_t v2 = v7;
  uint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 1200LL;
  }
}

void sub_1000C459C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1000C45B4()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsRecordingDuration", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  uint64_t v2 = v7;
  uint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 3400LL;
  }
}

void sub_1000C4674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1000C4690(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0LL;
  uint64_t result = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = v3;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_1000C46B8(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0LL;
  uint64_t result = *(void *)(a1 + 232);
  *(void *)(a1 + 232) = v3;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_1000C46E0(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0LL;
  uint64_t result = *(void *)(a1 + 240);
  *(void *)(a1 + 240) = v3;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_1000C4708(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0LL;
  uint64_t result = *(void *)(a1 + 248);
  *(void *)(a1 + 248) = v3;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_1000C4730(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0LL;
  uint64_t result = *(void *)(a1 + 256);
  *(void *)(a1 + 256) = v3;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_1000C4758(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + sub_1000A7938(v46 - 224) = *(_BYTE *)a2;
  *(void *)(a1 + 216) = *(void *)(a2 + 8);
  uint64_t v3 = sub_1000C4B00(a1);
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 32LL))(*(void *)(a1 + 48), v3);
  sub_1002F0B04(buf);
  CFStringRef v4 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsScanWifiRSSIEnabled", 0x8000100u, kCFAllocatorNull);
  char v5 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v4, (BOOL *)v15);
  CFRelease(v4);
  int v6 = v15[0];
  unsigned int v7 = v17;
  if (v17)
  {
    p_shared_owners = (unint64_t *)&v17->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  if (v6) {
    char v10 = 0;
  }
  else {
    char v10 = v5;
  }
  if ((v10 & 1) != 0)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DBD8);
    }
    unint64_t v11 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "SensorsDriver, Not scanning Wifi RSSI because it's not enabled",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181DBD8);
      }
      *(_WORD *)uint64_t v15 = 0;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "SensorsDriver, Not scanning Wifi RSSI because it's not enabled",  v15,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsDriver::requestWifiScan(const CLMicroLocationSensorsDriver::WifiScanRequestParams &)",  "%s\n",  v12);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DBD8);
    }
    int v13 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "SensorsDriver, wifi, start scanning",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181DBD8);
      }
      *(_WORD *)uint64_t v15 = 0;
      uint64_t v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "SensorsDriver, wifi, start scanning",  v15,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsDriver::requestWifiScan(const CLMicroLocationSensorsDriver::WifiScanRequestParams &)",  "%s\n",  v14);
    }

    (*(void (**)(void, void))(**(void **)(a1 + 48) + 16LL))( *(void *)(a1 + 48),  *(unsigned __int8 *)(a1 + 224));
  }

void sub_1000C4AE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_1000C4B00(uint64_t result)
{
  int v1 = *(unsigned __int8 *)(result + 224);
  if (v1 == 1) {
    return sub_1000C44DC() + (uint64_t)(*(double *)(result + 216) * 1000.0);
  }
  if (v1 == 2) {
    return sub_1000C45B4();
  }
  if (!*(_BYTE *)(result + 224))
  {
    uint64_t result = sub_101229068(result);
    return sub_1000C44DC() + (uint64_t)(*(double *)(result + 216) * 1000.0);
  }

  return result;
}

uint64_t sub_1000C4B60(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 16LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C4B70(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 128LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C4B80(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 136LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C4B90(uint64_t result)
{
  *(void *)(result + 216) = 0LL;
  *(_BYTE *)(result + sub_1000A7938(v46 - 224) = 0;
  return result;
}

void sub_1000C4B9C(uint64_t a1, double a2)
{
  int v5 = *(unsigned __int8 *)(a1 + 224);
  if (v5 == 1)
  {
    int v6 = (uint64_t *)(a1 + 184);
  }

  else
  {
    if (v5 != 2)
    {
      if (*(_BYTE *)(a1 + 224))
      {
LABEL_8:
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181DBD8);
        }
        unsigned int v7 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
        {
          int v11 = 68289282;
          int v12 = 0;
          __int16 v13 = 2082;
          uint64_t v14 = "";
          __int16 v15 = 2050;
          double v16 = *(double *)&v2;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:SensorDriver, Wifi scan timer stopped but but scanned AP requirements not met, extend timer, by duration (ms):%{public}lld}",  (uint8_t *)&v11,  0x1Cu);
        }

        return;
      }

      sub_1012291CC();
      __break(1u);
    }

    int v6 = (uint64_t *)(a1 + 200);
  }

  uint64_t v2 = sub_1000209BC(*v6);
  if (v2) {
    goto LABEL_8;
  }
  uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 120LL))(*(void *)(a1 + 264));
  if (v8)
  {
    uint64_t v9 = v8;
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DBD8);
    }
    char v10 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 68289282;
      int v12 = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 2050;
      double v16 = (double)v9;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:SensorsLogic, WiFi scan extention due to backlight on, backlightOnExtention_s:%{public}.09f}",  (uint8_t *)&v11,  0x1Cu);
    }

    (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 40LL))(*(void *)(a1 + 48), v9);
  }

  else
  {
    (*(void (**)(void))(**(void **)(a1 + 264) + 152LL))(*(void *)(a1 + 264));
    (*(void (**)(void, void))(**(void **)(a1 + 48) + 24LL))( *(void *)(a1 + 48),  *(unsigned __int8 *)(a1 + 224));
    (*(void (**)(void, double))(**(void **)(a1 + 264) + 24LL))(*(void *)(a1 + 264), a2);
  }

uint64_t sub_1000C4E00(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 224))
  {
    uint64_t v1 = a1;
    if (qword_1019348D0 == -1) {
      goto LABEL_3;
    }
  }

  else
  {
    sub_101229338(qword_1019348D0 == -1);
    __break(1u);
  }

  dispatch_once(&qword_1019348D0, &stru_10181DBD8);
LABEL_3:
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    sub_1000946B0(*(_BYTE *)(v1 + 224), __p);
    if (v6 >= 0) {
      uint64_t v3 = __p;
    }
    else {
      uint64_t v3 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 68289282;
    int v8 = 0;
    __int16 v9 = 2082;
    char v10 = "";
    __int16 v11 = 2082;
    int v12 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:SensorsDriver, received cancel wifi scan, scan activity:%{public, location:escape_only}s}",  buf,  0x1Cu);
    if (v6 < 0) {
      operator delete(__p[0]);
    }
  }

  return (*(uint64_t (**)(void, void))(**(void **)(v1 + 48) + 24LL))( *(void *)(v1 + 48),  *(unsigned __int8 *)(v1 + 224));
}

uint64_t sub_1000C4F48(uint64_t result)
{
  *(_BYTE *)(result + 56) = 1;
  return result;
}

uint64_t sub_1000C4F54(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + 56) = 1;
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 264) + 40LL))(*(void *)(a1 + 264), a2);
}

uint64_t sub_1000C4F94@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 64LL))(a1);
  uint64_t v5 = a1[24];
  *a2 = a1[23];
  a2[1] = v5;
  if (v5)
  {
    char v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

uint64_t sub_1000C4FE0@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 64LL))(a1);
  uint64_t v5 = a1[26];
  *a2 = a1[25];
  a2[1] = v5;
  if (v5)
  {
    char v6 = (unint64_t *)(v5 + 8);
    do
      unint64_t v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }

  return result;
}

void sub_1000C502C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 56))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DBD8);
    }
    uint64_t v2 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Updating localizing scan strategy", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181DBD8);
      }
      v19[0] = 0;
      int v12 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Updating localizing scan strategy",  v19,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationSensorsDriver::updateWifiScanStrategiesIfNecessary()",  "%s\n",  v12);
    }

    uint64_t v3 = *(void *)(a1 + 184);
    __int128 v17 = 0LL;
    uint64_t v18 = 0LL;
    std::string __p = 0LL;
    sub_100007590( &__p,  *(const void **)(a1 + 160),  *(void *)(a1 + 168),  (uint64_t)(*(void *)(a1 + 168) - *(void *)(a1 + 160)) >> 3);
    sub_1000C5310(v3, &__p, a1 + 64);
    if (__p)
    {
      __int128 v17 = __p;
      operator delete(__p);
    }

    uint64_t v4 = *(void *)(a1 + 200);
    uint64_t v14 = 0LL;
    uint64_t v15 = 0LL;
    __int16 v13 = 0LL;
    sub_100007590( &v13,  *(const void **)(a1 + 160),  *(void *)(a1 + 168),  (uint64_t)(*(void *)(a1 + 168) - *(void *)(a1 + 160)) >> 3);
    sub_1000C559C(v4, &v13, a1 + 64);
    if (v13)
    {
      uint64_t v14 = v13;
      operator delete(v13);
    }

    *(_BYTE *)(a1 + 56) = 0;
  }

  uint64_t v5 = *(void *)(a1 + 184);
  uint64_t v6 = sub_1000C44DC();
  double v7 = *(double *)(a1 + 216);
  *(double *)(v5 + 192) = (v7 * 1000.0 + (double)v6) / 1000.0;
  sub_10001EE0C();
  *(_DWORD *)(v5 + 184) = v8;
  *(double *)(v5 + 176) = v7 + sub_10001F01C();
  sub_100020550(v5);
  uint64_t v9 = *(void *)(a1 + 200);
  *(double *)(v9 + 192) = (double)sub_1000C45B4() / 1000.0;
  sub_10001F3B4();
  *(_DWORD *)(v9 + 184) = v10;
  sub_10001F5C4();
  *(double *)(v9 + 176) = v11 + 0.0;
  sub_100020550(v9);
}

void sub_1000C52DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (__p)
  {
    void *v14 = __p;
    operator delete(__p);
  }

  _Unwind_Resume(exception_object);
}

void sub_1000C5310(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 280);
  *(void *)(a1 + 280) = *a2;
  *a2 = v5;
  uint64_t v6 = *(void *)(a1 + 288);
  *(void *)(a1 + 288) = a2[1];
  a2[1] = v6;
  uint64_t v7 = *(void *)(a1 + 296);
  *(void *)(a1 + 296) = a2[2];
  a2[2] = v7;
  sub_1000C7530((void *)(a1 + 216), (uint64_t)sub_10001EC8C);
  __int16 v23 = 0LL;
  uint64_t v24 = 0LL;
  std::string __p = 0LL;
  sub_100007590( &__p,  *(const void **)(a1 + 280),  *(void *)(a1 + 288),  (uint64_t)(*(void *)(a1 + 288) - *(void *)(a1 + 280)) >> 3);
  uint64_t v8 = *(void *)(a1 + 240);
  if (!v8) {
    sub_100008BDC();
  }
  (*(void (**)(void *__return_ptr, uint64_t, void **))(*(void *)v8 + 48LL))(v25, v8, &__p);
  sub_100021B50((void *)(a1 + 248), (uint64_t)v25);
  uint64_t v9 = v26;
  if (v26 == v25)
  {
    uint64_t v10 = 4LL;
    uint64_t v9 = v25;
  }

  else
  {
    if (!v26) {
      goto LABEL_7;
    }
    uint64_t v10 = 5LL;
  }

  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_7:
  if (__p)
  {
    __int16 v23 = __p;
    operator delete(__p);
  }

  int v11 = sub_10001EA7C();
  if (v11 == 2) {
    uint64_t v12 = 110LL;
  }
  else {
    uint64_t v12 = 50LL;
  }
  uint64_t v13 = sub_10001EF18();
  uint64_t v14 = operator new(0x60uLL);
  int v15 = sub_10001EB84();
  uint64_t v16 = *(void *)(a1 + 272);
  if (!v16) {
    sub_100008BDC();
  }
  (*(void (**)(void **__return_ptr))(*(void *)v16 + 48LL))(v21);
  char v17 = sub_10001ED08();
  sub_1010DDBC0(v19, "micro");
  sub_100B7691C((uint64_t)v14, 1, v11, v15, (uint64_t)v21, v12, v13, v17, 0, (uint64_t)v19);
  uint64_t v18 = *(void ***)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  if (v18) {
    sub_100020BB0(a1 + 16, v18);
  }
  if (v20 < 0) {
    operator delete(v19[0]);
  }
  if (v21[0])
  {
    v21[1] = v21[0];
    operator delete(v21[0]);
  }

  sub_1000C6A74(a1 + 48, a3);
}

void sub_1000C552C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  operator delete(v21);
  _Unwind_Resume(a1);
}

void sub_1000C559C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 280);
  *(void *)(a1 + 280) = *a2;
  *a2 = v5;
  uint64_t v6 = *(void *)(a1 + 288);
  *(void *)(a1 + 288) = a2[1];
  a2[1] = v6;
  uint64_t v7 = *(void *)(a1 + 296);
  *(void *)(a1 + 296) = a2[2];
  a2[2] = v7;
  sub_1000C7530((void *)(a1 + 216), (uint64_t)sub_10001F234);
  __int16 v23 = 0LL;
  uint64_t v24 = 0LL;
  std::string __p = 0LL;
  sub_100007590( &__p,  *(const void **)(a1 + 280),  *(void *)(a1 + 288),  (uint64_t)(*(void *)(a1 + 288) - *(void *)(a1 + 280)) >> 3);
  uint64_t v8 = *(void *)(a1 + 240);
  if (!v8) {
    sub_100008BDC();
  }
  (*(void (**)(void *__return_ptr, uint64_t, void **))(*(void *)v8 + 48LL))(v25, v8, &__p);
  sub_100021B50((void *)(a1 + 248), (uint64_t)v25);
  uint64_t v9 = v26;
  if (v26 == v25)
  {
    uint64_t v10 = 4LL;
    uint64_t v9 = v25;
  }

  else
  {
    if (!v26) {
      goto LABEL_7;
    }
    uint64_t v10 = 5LL;
  }

  (*(void (**)(void))(*v9 + 8 * v10))();
LABEL_7:
  if (__p)
  {
    __int16 v23 = __p;
    operator delete(__p);
  }

  int v11 = sub_10001F024();
  if (v11 == 2) {
    uint64_t v12 = 110LL;
  }
  else {
    uint64_t v12 = 50LL;
  }
  uint64_t v13 = sub_10001F4C0();
  uint64_t v14 = operator new(0x60uLL);
  int v15 = sub_10001F12C();
  uint64_t v16 = *(void *)(a1 + 272);
  if (!v16) {
    sub_100008BDC();
  }
  (*(void (**)(void **__return_ptr))(*(void *)v16 + 48LL))(v21);
  char v17 = sub_10001F2B0();
  sub_1010DDBC0(v19, "micro");
  sub_100B7691C((uint64_t)v14, 1, v11, v15, (uint64_t)v21, v12, v13, v17, 0, (uint64_t)v19);
  uint64_t v18 = *(void ***)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  if (v18) {
    sub_100020BB0(a1 + 16, v18);
  }
  if (v20 < 0) {
    operator delete(v19[0]);
  }
  if (v21[0])
  {
    v21[1] = v21[0];
    operator delete(v21[0]);
  }

  sub_1000C6A74(a1 + 48, a3);
}

void sub_1000C57B8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  operator delete(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_1000C5828(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 160);
  *(void *)(result + 160) = *a2;
  *a2 = v2;
  uint64_t v3 = *(void *)(result + 168);
  *(void *)(result + 168) = a2[1];
  a2[1] = v3;
  uint64_t v4 = *(void *)(result + 176);
  *(void *)(result + 176) = a2[2];
  a2[2] = v4;
  *(_BYTE *)(result + 56) = 1;
  return result;
}

uint64_t sub_1000C5864(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 32LL))(*(void *)(a1 + 264));
  if (v2) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 48) + 40LL))(*(void *)(a1 + 48), v2);
  }
  return v2;
}

uint64_t sub_1000C58B0(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 256) + 32LL))(*(void *)(a1 + 256));
  if (v2) {
    (*(void (**)(void, uint64_t))(**(void **)(a1 + 40) + 40LL))(*(void *)(a1 + 40), v2);
  }
  return v2;
}

uint64_t sub_1000C58FC(uint64_t a1)
{
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181DBD8);
  }
  uint64_t v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    v5[0] = 68289282;
    v5[1] = 0;
    __int16 v6 = 2082;
    uint64_t v7 = "";
    __int16 v8 = 2050;
    double v9 = Current_1;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CLMicroLocationSensorsDriver, stop wifi scan, now:%{public}.3f}",  (uint8_t *)v5,  0x1Cu);
  }

  (*(void (**)(void))(**(void **)(a1 + 264) + 152LL))(*(void *)(a1 + 264));
  (*(void (**)(void, void))(**(void **)(a1 + 48) + 24LL))( *(void *)(a1 + 48),  *(unsigned __int8 *)(a1 + 224));
  return (*(uint64_t (**)(void, double))(**(void **)(a1 + 264) + 24LL))(*(void *)(a1 + 264), Current_1);
}

uint64_t sub_1000C5A28(uint64_t a1)
{
  return sub_1000C58FC(a1 - 8);
}

uint64_t sub_1000C5A30(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 48LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C5A40(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 248) + 48LL))(*(void *)(a1 + 248));
}

uint64_t sub_1000C5A50(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 56LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C5A60(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 248) + 56LL))(*(void *)(a1 + 248));
}

uint64_t sub_1000C5A70(uint64_t a1, uint64_t a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181DBD8);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SensorsDriver, ble, start session", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DBD8);
    }
    v7[0] = 0;
    __int16 v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "SensorsDriver, ble, start session",  v7,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsDriver::startBleRssiSession(const CLMicroLocationUtils::BleScanConfiguration &)",  "%s\n",  v6);
  }

  if (!*(_BYTE *)(a2 + 9))
  {
    if (*(_BYTE *)(a1 + 224)) {
      sub_1012294C0();
    }
    *(_BYTE *)(a1 + sub_1000A7938(v46 - 224) = *(_BYTE *)(a2 + 8);
  }

  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 232) + 16LL))(*(void *)(a1 + 232), a2);
}

uint64_t sub_1000C5C34(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181DBD8);
  }
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, ble, stop session", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DBD8);
    }
    v5[0] = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "SensorsDriver, ble, stop session",  v5,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLMicroLocationSensorsDriver::stopBleRssiSession()", "%s\n", v4);
  }

  return (*(uint64_t (**)(void))(**(void **)(a1 + 232) + 32LL))(*(void *)(a1 + 232));
}

uint64_t sub_1000C5DD4(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181DBD8);
  }
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, ble, request timeout", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DBD8);
    }
    v5[0] = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "SensorsDriver, ble, request timeout",  v5,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationSensorsDriver::onBLEScanRequestTimeout()",  "%s\n",  v4);
  }

  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 64LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C5F74(uint64_t a1)
{
  return sub_1000C5DD4(a1 - 16);
}

uint64_t sub_1000C5F7C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 72LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C5F8C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 72LL))(*(void *)(a1 + 240));
}

uint64_t sub_1000C5F9C(uint64_t a1, uint64_t *a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181DBD8);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *a2;
    uint64_t v6 = a2[1];
    v8[0] = 68289538;
    v8[1] = 0;
    __int16 v9 = 2082;
    uint64_t v10 = "";
    __int16 v11 = 1026;
    int v12 = v5;
    __int16 v13 = 2050;
    uint64_t v14 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:SensorsDriver, uwb, set ranging rate, rate:%{public}d, duration:%{public}f}",  (uint8_t *)v8,  0x22u);
  }

  return (*(uint64_t (**)(void, uint64_t *))(**(void **)(a1 + 240) + 32LL))(*(void *)(a1 + 240), a2);
}

uint64_t sub_1000C60B0(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181DBD8);
  }
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "SensorsDriver, uwb, reset ranging rate",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DBD8);
    }
    v5[0] = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "SensorsDriver, uwb, reset ranging rate",  v5,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLMicroLocationSensorsDriver::resetRangingRate()", "%s\n", v4);
  }

  return (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 40LL))(*(void *)(a1 + 240));
}

uint64_t sub_1000C6250(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181DBD8);
  }
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, uwb, start session", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DBD8);
    }
    v5[0] = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "SensorsDriver, uwb, start session",  v5,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLMicroLocationSensorsDriver::startRanging()", "%s\n", v4);
  }

  return (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 16LL))(*(void *)(a1 + 240));
}

uint64_t sub_1000C63F0(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181DBD8);
  }
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SensorsDriver, uwb, stop session", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DBD8);
    }
    v5[0] = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "SensorsDriver, uwb, stop session",  v5,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLMicroLocationSensorsDriver::stopRanging()", "%s\n", v4);
  }

  return (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 24LL))(*(void *)(a1 + 240));
}

uint64_t sub_1000C6590(uint64_t a1)
{
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  return (*(uint64_t (**)(void, void, double))(**(void **)(a1 + 264) + 104LL))( *(void *)(a1 + 264),  0LL,  Current_1);
}

uint64_t sub_1000C65C0(uint64_t a1)
{
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  return (*(uint64_t (**)(void, void, double))(**(void **)(a1 + 240) + 104LL))( *(void *)(a1 + 240),  0LL,  Current_1);
}

uint64_t sub_1000C65F0(uint64_t a1)
{
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  return (*(uint64_t (**)(void, uint64_t, CFAbsoluteTime))(**(void **)(a1 + 264) + 104LL))( *(void *)(a1 + 264),  1LL,  Current_1);
}

uint64_t sub_1000C6620(uint64_t a1)
{
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  return (*(uint64_t (**)(void, uint64_t, CFAbsoluteTime))(**(void **)(a1 + 240) + 104LL))( *(void *)(a1 + 240),  1LL,  Current_1);
}

uint64_t sub_1000C6650(uint64_t a1)
{
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  return (*(uint64_t (**)(void, uint64_t, CFAbsoluteTime))(**(void **)(a1 + 264) + 104LL))( *(void *)(a1 + 264),  2LL,  Current_1);
}

uint64_t sub_1000C6680(uint64_t a1)
{
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  return (*(uint64_t (**)(void, uint64_t, CFAbsoluteTime))(**(void **)(a1 + 240) + 104LL))( *(void *)(a1 + 240),  2LL,  Current_1);
}

uint64_t sub_1000C66B0(uint64_t a1)
{
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  return (*(uint64_t (**)(void, uint64_t, CFAbsoluteTime))(**(void **)(a1 + 264) + 104LL))( *(void *)(a1 + 264),  1LL,  Current_1);
}

uint64_t sub_1000C66E0(uint64_t a1)
{
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  return (*(uint64_t (**)(void, uint64_t, CFAbsoluteTime))(**(void **)(a1 + 240) + 104LL))( *(void *)(a1 + 240),  1LL,  Current_1);
}

uint64_t sub_1000C6710(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 112LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C6720(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 240) + 112LL))(*(void *)(a1 + 240));
}

uint64_t sub_1000C6730(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 80LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C6740(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 232) + 80LL))(*(void *)(a1 + 232));
}

uint64_t sub_1000C6750(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 88LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C6760(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 232) + 88LL))(*(void *)(a1 + 232));
}

uint64_t sub_1000C6770(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 80LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C6780(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 224) + 80LL))(*(void *)(a1 + 224));
}

uint64_t sub_1000C6790(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 96LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C67A0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 224) + 96LL))(*(void *)(a1 + 224));
}

uint64_t sub_1000C67B0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 264) + 144LL))(*(void *)(a1 + 264));
}

uint64_t sub_1000C67C0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 232) + 144LL))(*(void *)(a1 + 232));
}

uint64_t sub_1000C67D0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 224) + 144LL))(*(void *)(a1 + 224));
}

uint64_t sub_1000C67E0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 248) + 16LL))(*(void *)(a1 + 248));
}

uint64_t sub_1000C67F0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 248) + 24LL))(*(void *)(a1 + 248));
}

uint64_t sub_1000C6800(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 256) + 32LL))(*(void *)(a1 + 256));
}

uint64_t sub_1000C6838(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 256) + 40LL))(*(void *)(a1 + 256));
}

uint64_t sub_1000C6870(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 256) + 24LL))(*(void *)(a1 + 256));
}

uint64_t sub_1000C6880(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 256) + 16LL))(*(void *)(a1 + 256));
}

uint64_t sub_1000C6890(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 224);
  if (v1 == 1)
  {
    uint64_t v2 = (uint64_t *)(a1 + 184);
    return sub_100019240(*v2);
  }

  if (v1 == 2)
  {
    uint64_t v2 = (uint64_t *)(a1 + 200);
    return sub_100019240(*v2);
  }

  uint64_t v4 = sub_101229624();
  return sub_1000C68C8(v4);
}

void sub_1000C68CC(uint64_t a1)
{
  int v1 = (void *)sub_1000C6B08(a1);
  operator delete(v1);
}

uint64_t sub_1000C68E0(uint64_t a1)
{
  return sub_1000C6B08(a1 - 8);
}

void sub_1000C68E8(uint64_t a1)
{
  int v1 = (void *)sub_1000C6B08(a1 - 8);
  operator delete(v1);
}

uint64_t sub_1000C6900(uint64_t a1)
{
  return sub_1000C6B08(a1 - 16);
}

void sub_1000C6908(uint64_t a1)
{
  int v1 = (void *)sub_1000C6B08(a1 - 16);
  operator delete(v1);
}

uint64_t sub_1000C6920(uint64_t a1)
{
  return sub_1000C6B08(a1 - 24);
}

void sub_1000C6928(uint64_t a1)
{
  int v1 = (void *)sub_1000C6B08(a1 - 24);
  operator delete(v1);
}

uint64_t sub_1000C6940(uint64_t a1)
{
  return sub_1000C6B08(a1 - 32);
}

void sub_1000C6948(uint64_t a1)
{
  int v1 = (void *)sub_1000C6B08(a1 - 32);
  operator delete(v1);
}

uint64_t sub_1000C6960(uint64_t a1)
{
  return sub_1000C6B08(a1 - 40);
}

void sub_1000C6968(uint64_t a1)
{
  int v1 = (void *)sub_1000C6B08(a1 - 40);
  operator delete(v1);
}

_BYTE *sub_1000C6980(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[88] = 0;
  if (*(_BYTE *)(a2 + 88))
  {
    sub_1000C69DC((uint64_t)a1, a2);
    a1[88] = 1;
  }

  return a1;
}

void sub_1000C69C0(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 88)) {
    sub_101229788(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000C69DC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  uint64_t v4 = a1 + 8;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_1010DD48C((_BYTE *)v4, *(void **)(a2 + 8), *(void *)(a2 + 16));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(a2 + 8);
    *(void *)(v4 + 16) = *(void *)(a2 + 24);
    *(_OWORD *)uint64_t v4 = v5;
  }

  __int128 v6 = *(_OWORD *)(a2 + 32);
  __int128 v7 = *(_OWORD *)(a2 + 48);
  __int128 v8 = *(_OWORD *)(a2 + 64);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(_OWORD *)(a1 + 48) = v7;
  *(_OWORD *)(a1 + 64) = v8;
  *(_OWORD *)(a1 + 32) = v6;
  return a1;
}

void sub_1000C6A48(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1000C6A74(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a2 + 88))
  {
    if (*(_BYTE *)(a1 + 88))
    {
      *(void *)a1 = *(void *)a2;
      std::string::operator=((std::string *)(a1 + 8), (const std::string *)(a2 + 8));
      __int128 v5 = *(_OWORD *)(a2 + 48);
      __int128 v4 = *(_OWORD *)(a2 + 64);
      __int128 v6 = *(_OWORD *)(a2 + 32);
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      *(_OWORD *)(a1 + 48) = v5;
      *(_OWORD *)(a1 + 64) = v4;
      *(_OWORD *)(a1 + 32) = v6;
    }
  }

  else if (*(_BYTE *)(a1 + 88))
  {
    *(_BYTE *)(a1 + 88) = 0;
  }

  else
  {
    sub_1000C69DC(a1, a2);
    *(_BYTE *)(a1 + 88) = 1;
  }

uint64_t sub_1000C6B08(uint64_t a1)
{
  *(void *)a1 = off_10181D900;
  *(void *)(a1 + 8) = off_10181D9E8;
  *(void *)(a1 + 16) = off_10181DA18;
  *(void *)(a1 + 24) = off_10181DA50;
  *(void *)(a1 + 32) = off_10181DAA0;
  *(void *)(a1 + 40) = off_10181DAD8;
  uint64_t v2 = *(void *)(a1 + 256);
  *(void *)(a1 + 256) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 248);
  *(void *)(a1 + 248) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 240);
  *(void *)(a1 + 240) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 232);
  *(void *)(a1 + 232) = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  sub_10000AE14(a1 + 200);
  sub_10000AE14(a1 + 184);
  __int128 v6 = *(void **)(a1 + 160);
  if (v6)
  {
    *(void *)(a1 + 168) = v6;
    operator delete(v6);
  }

  uint64_t v7 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0LL;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }
  return a1;
}

void *sub_1000C6C00@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t *a4@<X4>, double *a5@<X5>, uint64_t a6@<X6>, void *a7@<X8>)
{
  uint64_t v14 = operator new(0x148uLL);
  uint64_t result = sub_1000C6C90(v14, a1, a2, a3, a4, a5, a6);
  *a7 = v14 + 3;
  a7[1] = v14;
  return result;
}

void sub_1000C6C7C(_Unwind_Exception *a1)
{
}

void *sub_1000C6C90(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, double *a6, uint64_t a7)
{
  a1[2] = 0LL;
  *a1 = off_10181DC08;
  a1[1] = 0LL;
  sub_1000C6D4C((uint64_t)&v9, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7);
  return a1;
}

void sub_1000C6CF0(_Unwind_Exception *a1)
{
}

void sub_1000C6D04(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10181DC08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000C6D18(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10181DC08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000C6D3C(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void sub_1000C6D4C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, double *a7, uint64_t a8)
{
  std::string __p = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  sub_100007590(&__p, *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
  sub_1000C6DF4(a2, (uint64_t)&__p, a5, *a6, a8 + 8, *a7);
  if (__p)
  {
    uint64_t v14 = __p;
    operator delete(__p);
  }

void sub_1000C6DD8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000C6DF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)a1 = &off_101818EE8;
  *(void *)(a1 + 8) = a5;
  *(_BYTE *)(a1 + 136) = 0;
  *(void *)(a1 + 240) = 0LL;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_BYTE *)(a1 + 48) = 0;
  *(void *)(a1 + 200) = 0LL;
  *(void *)(a1 + 208) = 0LL;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  uint64_t v16 = "na";
  __int128 __src = xmmword_10181DC48;
  sub_1000C7020((char *)(a1 + 24), (char *)&__src, (uint64_t)&v17, 1uLL);
  *(_OWORD *)std::string __p = *(_OWORD *)a2;
  uint64_t v14 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(void *)a2 = 0LL;
  sub_1000C5310(a1, __p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  *(double *)(a1 + 192) = (double)a4 / 1000.0;
  sub_10001EE0C();
  *(_DWORD *)(a1 + 184) = v11;
  *(double *)(a1 + 176) = a6 + sub_10001F01C();
  sub_100020550(a1);
  return a1;
}

void sub_1000C6F48( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v14 = (void **)(v10 + 272);
  uint64_t v15 = *(void **)(v10 + 280);
  if (v15)
  {
    *(void *)(v10 + 288) = v15;
    operator delete(v15);
  }

  uint64_t v16 = *v14;
  if (*v14 == (void *)(v10 + 248))
  {
    uint64_t v17 = 4LL;
    uint64_t v16 = (void *)(v10 + 248);
  }

  else
  {
    if (!v16) {
      goto LABEL_10;
    }
    uint64_t v17 = 5LL;
  }

  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_10:
  uint64_t v18 = *(void **)(v10 + 240);
  if (v18 == (void *)(v10 + 216))
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = (void *)(v10 + 216);
  }

  else
  {
    if (!v18)
    {
LABEL_15:
      char v20 = *v12;
      if (*v12)
      {
        *(void *)(v10 + 32) = v20;
        operator delete(v20);
      }

      __int16 v21 = *v11;
      os_log_s *v11 = 0LL;
      if (v21) {
        sub_100020BB0((int)v11, v21);
      }
      _Unwind_Resume(exception_object);
    }

    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*v18 + 8 * v19))();
  goto LABEL_15;
}

char *sub_1000C7020(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  char v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *uint64_t v7 = 0LL;
      v7[1] = 0LL;
      v7[2] = 0LL;
    }

    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      sub_100007008();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x555555555555555LL) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t result = sub_100006E1C(v7, v12);
    uint64_t v14 = (char *)v7[1];
    __int16 v13 = (void **)(v7 + 1);
    char v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  __int16 v13 = (void **)(result + 8);
  uint64_t v15 = (_BYTE *)*((void *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v15 - v9);
    char v9 = (char *)*v13;
  }

  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }

void *sub_1000C7158@<X0>( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t *a4@<X4>, double *a5@<X5>, uint64_t a6@<X6>, void *a7@<X8>)
{
  uint64_t v14 = operator new(0x148uLL);
  uint64_t result = sub_1000C71E8(v14, a1, a2, a3, a4, a5, a6);
  *a7 = v14 + 3;
  a7[1] = v14;
  return result;
}

void sub_1000C71D4(_Unwind_Exception *a1)
{
}

void *sub_1000C71E8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, double *a6, uint64_t a7)
{
  a1[2] = 0LL;
  *a1 = off_10181DC08;
  a1[1] = 0LL;
  sub_1000C725C((uint64_t)&v9, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7);
  return a1;
}

void sub_1000C7248(_Unwind_Exception *a1)
{
}

void sub_1000C725C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, double *a7, uint64_t a8)
{
  std::string __p = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v15 = 0LL;
  sub_100007590(&__p, *(const void **)a4, *(void *)(a4 + 8), (uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3);
  sub_1000C7304(a2, (uint64_t)&__p, a5, *a6, a8 + 8, *a7);
  if (__p)
  {
    uint64_t v14 = __p;
    operator delete(__p);
  }

void sub_1000C72E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000C7304(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)a1 = &off_101818EE8;
  *(void *)(a1 + 8) = a5;
  *(_BYTE *)(a1 + 136) = 0;
  *(void *)(a1 + 240) = 0LL;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_BYTE *)(a1 + 48) = 0;
  *(void *)(a1 + 200) = 0LL;
  *(void *)(a1 + 208) = 0LL;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  size_t v17 = "na";
  __int128 __src = xmmword_10181DC48;
  sub_1000C7020((char *)(a1 + 24), (char *)&__src, (uint64_t)&v18, 1uLL);
  *(_OWORD *)std::string __p = *(_OWORD *)a2;
  uint64_t v15 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(void *)a2 = 0LL;
  sub_1000C559C(a1, __p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  *(double *)(a1 + 192) = (double)a4 / 1000.0;
  sub_10001F3B4();
  *(_DWORD *)(a1 + 184) = v11;
  sub_10001F5C4();
  *(double *)(a1 + 176) = a6 + v12;
  sub_100020550(a1);
  return a1;
}

void sub_1000C7458( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v14 = (void **)(v10 + 272);
  uint64_t v15 = *(void **)(v10 + 280);
  if (v15)
  {
    *(void *)(v10 + 288) = v15;
    operator delete(v15);
  }

  uint64_t v16 = *v14;
  if (*v14 == (void *)(v10 + 248))
  {
    uint64_t v17 = 4LL;
    uint64_t v16 = (void *)(v10 + 248);
  }

  else
  {
    if (!v16) {
      goto LABEL_10;
    }
    uint64_t v17 = 5LL;
  }

  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_10:
  uint64_t v18 = *(void **)(v10 + 240);
  if (v18 == (void *)(v10 + 216))
  {
    uint64_t v19 = 4LL;
    uint64_t v18 = (void *)(v10 + 216);
  }

  else
  {
    if (!v18)
    {
LABEL_15:
      char v20 = *v12;
      if (*v12)
      {
        *(void *)(v10 + 32) = v20;
        operator delete(v20);
      }

      __int16 v21 = *v11;
      os_log_s *v11 = 0LL;
      if (v21) {
        sub_100020BB0((int)v11, v21);
      }
      _Unwind_Resume(exception_object);
    }

    uint64_t v19 = 5LL;
  }

  (*(void (**)(void))(*v18 + 8 * v19))();
  goto LABEL_15;
}

void *sub_1000C7530(void *a1, uint64_t a2)
{
  v6[0] = &off_10181DC70;
  v6[1] = a2;
  uint64_t v7 = v6;
  sub_1000C76EC(v6, a1);
  uint64_t v3 = v7;
  if (v7 == v6)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v6;
    goto LABEL_5;
  }

  if (v7)
  {
    uint64_t v4 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v3 + 8 * v4))();
  }

  return a1;
}

void *sub_1000C75D4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181DC70;
  result[1] = v3;
  return result;
}

uint64_t sub_1000C760C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181DC70;
  a2[1] = v2;
  return result;
}

void sub_1000C762C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1000C7634(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000C7670()
{
  return &off_10181DCF0;
}

void sub_1000C767C(void (**a1)(void **), uint64_t a2)
{
  uint64_t v2 = *a1;
  *(_OWORD *)std::string __p = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(void *)a2 = 0LL;
  v2(__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

void sub_1000C76D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000C76EC(void *result, void *a2)
{
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = 0LL;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24LL))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
        a2[3] = 0LL;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24LL))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32LL))(v6);
      }

      else
      {
        (*(void (**)(void *, void *))(*result + 24LL))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32LL))(v3[3]);
        v3[3] = a2[3];
      }

      a2[3] = a2;
    }

    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24LL))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32LL))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }

    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }

  return result;
}

void sub_1000C7854(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

void sub_1000C7860(void *a1@<X0>, char **a2@<X8>)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = 0LL;
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  __int128 v6 = a2 + 2;
  do
  {
    if (((*a1 >> v5) & 1) != 0)
    {
      if ((unint64_t)v4 >= *v6)
      {
        uint64_t v8 = *a2;
        uint64_t v9 = (v4 - *a2) >> 2;
        unint64_t v10 = v9 + 1;
        uint64_t v11 = *v6 - (void)v8;
        if (v11 >> 1 > v10) {
          unint64_t v10 = v11 >> 1;
        }
        else {
          unint64_t v12 = v10;
        }
        if (v12)
        {
          __int16 v13 = (char *)sub_10000956C((uint64_t)v6, v12);
          uint64_t v8 = *a2;
          uint64_t v4 = a2[1];
        }

        else
        {
          __int16 v13 = 0LL;
        }

        uint64_t v14 = &v13[4 * v9];
        *(_DWORD *)uint64_t v14 = v5;
        uint64_t v7 = v14 + 4;
        while (v4 != v8)
        {
          int v15 = *((_DWORD *)v4 - 1);
          v4 -= 4;
          *((_DWORD *)v14 - 1) = v15;
          v14 -= 4;
        }

        *a2 = v14;
        a2[1] = v7;
        a2[2] = &v13[4 * v12];
        if (v8) {
          operator delete(v8);
        }
      }

      else
      {
        *(_DWORD *)uint64_t v4 = v5;
        uint64_t v7 = v4 + 4;
      }

      a2[1] = v7;
      uint64_t v4 = v7;
    }

    ++v5;
  }

  while (v5 != 56);
}

void sub_1000C7978(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1000C7998(unsigned int a1@<W0>, char **a2@<X8>)
{
  CFStringRef v4 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsRecordingEventsForModel", 0x8000100u, kCFAllocatorNull);
  BOOL v5 = sub_1002A8FFC(v15, (uint64_t)v4, v14);
  CFRelease(v4);
  if (v5)
  {
    sub_1002A5768(v13, (uint64_t)v14);
    sub_1000C8224((uint64_t)v13, &__p);
    sub_1002A5590(v13);
  }

  else
  {
    __int128 v6 = operator new(0x18uLL);
    unint64_t v12 = (char *)(v6 + 3);
    v6[2] = 30388LL;
    *(_OWORD *)__int128 v6 = xmmword_1012CCD58;
    std::string __p = v6;
    uint64_t v11 = v6 + 3;
  }

  sub_1002A5590(v14);
  uint64_t v7 = v16;
  if (v16)
  {
    p_shared_owners = (unint64_t *)&v16->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  if (a1 >= (unint64_t)((v11 - (_BYTE *)__p) >> 3))
  {
    sub_10122979C();
    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationSettings.mm",  68,  "getRecordingEventsForModelType");
    __break(1u);
  }

  else
  {
    uint64_t v15 = *((void *)__p + a1);
    sub_1000C7860(&v15, a2);
    if (__p)
    {
      uint64_t v11 = __p;
      operator delete(__p);
    }
  }

void sub_1000C7B24( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
}

uint64_t sub_1000C7B7C()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsUseAlternativeSetting", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A6FD4(v11, (uint64_t)v0, &v10);
  CFRelease(v0);
  BOOL v2 = v10;
  uint64_t v3 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v2) {
    int v6 = v1;
  }
  else {
    int v6 = 0;
  }
  if (v6 != 1) {
    return 1LL;
  }
  LODWORD(v11) = 0;
  uint64_t v7 = sub_1002F8DDC();
  uint64_t v8 = 1LL;
  if ((sub_1002A7D20(v7, (uint64_t)@"kMicroLocationConfigurationSelect", &v11) & 1) == 0)
  {
    if (arc4random_uniform(2u)) {
      uint64_t v8 = 2LL;
    }
    else {
      uint64_t v8 = 1LL;
    }
    LODWORD(v11) = v8;
    sub_1000C7CD4(v8);
  }

  return v8;
}

void sub_1000C7C8C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1000C7CD4(int a1)
{
  uint64_t v2 = sub_1002F8DDC();
  int v5 = a1;
  sub_1002AC288(v2, @"kMicroLocationConfigurationSelect", &v5);
  uint64_t v3 = sub_1002F8DDC();
  return (*(uint64_t (**)(uint64_t))(*(void *)v3 + 944LL))(v3);
}

void sub_1000C7D20(int a1@<W0>, void *a2@<X8>)
{
  switch(a1)
  {
    case 0:
    case 1:
      sub_1010DDBC0(__p, "");
      sub_10012F48C(a2, __p);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      return;
    case 2:
      sub_1002F0B04(&v20);
      sub_1002A5370(v19);
      CFStringRef v3 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsCombinedEuclideanJaccardParams",  0x8000100u,  kCFAllocatorNull);
      BOOL v4 = sub_1002A8FFC(v20, (uint64_t)v3, v19);
      CFRelease(v3);
      if (v4)
      {
        sub_1002A5768(__p, (uint64_t)v19);
        sub_1002A55A8(a2, (uint64_t)__p);
        *a2 = &off_1018201E0;
        sub_1002A5590(__p);
      }

      else
      {
        sub_1010DDBC0(__p, "{jaccard_threshold : 0.75, jaccard_scale_factor : 20.0}");
        sub_10012F48C(a2, __p);
        if (v18 < 0) {
          operator delete(__p[0]);
        }
      }

      sub_1002A5590(v19);
      uint64_t v11 = v21;
      if (!v21) {
        return;
      }
      p_shared_owners = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      break;
    case 3:
      sub_1002F0B04(&v20);
      sub_1002A5370(v19);
      CFStringRef v5 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsTanimotoBaseParams", 0x8000100u, kCFAllocatorNull);
      BOOL v6 = sub_1002A8FFC(v20, (uint64_t)v5, v19);
      CFRelease(v5);
      if (v6)
      {
        sub_1002A5768(__p, (uint64_t)v19);
        sub_1002A55A8(a2, (uint64_t)__p);
        *a2 = &off_1018201E0;
        sub_1002A5590(__p);
      }

      else
      {
        sub_1010DDBC0(__p, "{}");
        sub_10012F48C(a2, __p);
        if (v18 < 0) {
          operator delete(__p[0]);
        }
      }

      sub_1002A5590(v19);
      uint64_t v11 = v21;
      if (!v21) {
        return;
      }
      unint64_t v14 = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(v14);
      while (__stlxr(v13 - 1, v14));
      break;
    case 4:
      sub_1002F0B04(&v20);
      sub_1002A5370(v19);
      CFStringRef v7 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsWeightedEuclideanJaccardParams",  0x8000100u,  kCFAllocatorNull);
      BOOL v8 = sub_1002A8FFC(v20, (uint64_t)v7, v19);
      CFRelease(v7);
      if (v8)
      {
        sub_1002A5768(__p, (uint64_t)v19);
        sub_1002A55A8(a2, (uint64_t)__p);
        *a2 = &off_1018201E0;
        sub_1002A5590(__p);
      }

      else
      {
        sub_1010DDBC0( __p,  "{jaccard_scale_factor:1.0,e2j_kernel_thr:0.5,per_source_params: {value_scale_factor :{wifi :0.05,ble:0.025,uwb:0.15}, euclidean_weight:{wifi:3.0,ble:3.0,uwb:50.0}, jaccard_pos _weight:{wifi:2.0,ble:2.0,uwb:2.0},jaccard_neg_weight:{wifi:1.0,ble:5.0,uwb:10.0 },onesided_jaccard:{wifi:true,ble:false,uwb:false}}}");
        sub_10012F48C(a2, __p);
        if (v18 < 0) {
          operator delete(__p[0]);
        }
      }

      sub_1002A5590(v19);
      uint64_t v11 = v21;
      if (!v21) {
        return;
      }
      uint64_t v15 = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(v15);
      while (__stlxr(v13 - 1, v15));
      break;
    case 5:
      sub_1002F0B04(&v20);
      sub_1002A5370(v19);
      CFStringRef v9 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsWeightedEuclideanJaccardTwoSidedParams",  0x8000100u,  kCFAllocatorNull);
      BOOL v10 = sub_1002A8FFC(v20, (uint64_t)v9, v19);
      CFRelease(v9);
      if (v10)
      {
        sub_1002A5768(__p, (uint64_t)v19);
        sub_1002A55A8(a2, (uint64_t)__p);
        *a2 = &off_1018201E0;
        sub_1002A5590(__p);
      }

      else
      {
        sub_1010DDBC0( __p,  "{jaccard_scale_factor:1.0,e2j_kernel_thr:0.5,per_source_params: {value_scale_factor :{wifi :0.05,ble:0.025,uwb:0.15}, euclidean_weight:{wifi:3.0,ble:3.0,uwb:50.0}, jaccard_pos _weight:{wifi:2.0,ble:2.0,uwb:2.0},jaccard_neg_weight:{wifi:1.0,ble:5.0,uwb:10.0 },onesided_jaccard:{wifi:false,ble:false,uwb:false}}}");
        sub_10012F48C(a2, __p);
        if (v18 < 0) {
          operator delete(__p[0]);
        }
      }

      sub_1002A5590(v19);
      uint64_t v11 = v21;
      if (!v21) {
        return;
      }
      uint64_t v16 = (unint64_t *)&v21->__shared_owners_;
      do
        unint64_t v13 = __ldaxr(v16);
      while (__stlxr(v13 - 1, v16));
      break;
    default:
      sub_101229954();
  }

  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }

void sub_1000C8224(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  sub_1000C8360((uint64_t)a2, 4uLL);
  uint64_t v8 = 0LL;
  uint64_t v9 = 0LL;
  uint64_t v10 = 0LL;
  sub_1002A6CEC(a1, &v8);
  uint64_t v4 = v8;
  uint64_t v5 = v9;
  while (1)
  {
    if (v4 == v5)
    {
      unint64_t v11 = (unint64_t)&v8;
      sub_1000129D4((void ***)&v11);
      return;
    }

    unsigned int v6 = sub_1001036CC((uint64_t *)v4);
    unint64_t v11 = 0LL;
    CFStringRef v7 = (const char *)v4;
    if ((sub_1002A7F54(a1, v7, &v11) & 1) == 0) {
      break;
    }
    *(void *)(*a2 + 8LL * v6) = v11 & 0xFFFFFFFFFFFFFFLL;
    v4 += 24LL;
  }

  sub_101229B04((uint64_t *)v4);
  abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationSettings.h",  1388,  "primitiveTypeToSettingType");
  __break(1u);
}

void sub_1000C8320( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, void **a16)
{
  a16 = (void **)&a13;
  sub_1000129D4(&a16);
  char v18 = *(void **)v16;
  if (*(void *)v16)
  {
    *(void *)(v16 + 8) = v18;
    operator delete(v18);
  }

  _Unwind_Resume(a1);
}

void sub_1000C8360(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }

  else
  {
    sub_1000C8390((char **)a1, a2 - v2);
  }

void sub_1000C8390(char **a1, unint64_t a2)
{
  unsigned int v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  CFStringRef v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }

    a1[1] = v7;
  }

  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      sub_100007008();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v14 = (char *)sub_1000071BC(v4, v13);
      uint64_t v8 = *a1;
      CFStringRef v7 = a1[1];
    }

    else
    {
      unint64_t v14 = 0LL;
    }

    uint64_t v15 = &v14[8 * v11];
    uint64_t v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    uint64_t v17 = &v15[8 * a2];
    if (v7 != v8)
    {
      do
      {
        uint64_t v18 = *((void *)v7 - 1);
        v7 -= 8;
        *((void *)v15 - 1) = v18;
        v15 -= 8;
      }

      while (v7 != v8);
      uint64_t v8 = *a1;
    }

    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8) {
      operator delete(v8);
    }
  }

void sub_1000C84A0(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

  ;
}

  ;
}

void sub_1000C8514(uint64_t a1@<X8>)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_101934E50);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_101934E50))
  {
    sub_1000CC384((std::string *)&xmmword_101934E38);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_101934E38, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101934E50);
  }

  if (byte_101934E4F < 0)
  {
    sub_1010DD48C((_BYTE *)a1, (void *)xmmword_101934E38, *((unint64_t *)&xmmword_101934E38 + 1));
  }

  else
  {
    *(_OWORD *)a1 = xmmword_101934E38;
    *(void *)(a1 + 16) = unk_101934E48;
  }

void sub_1000C85C4(_Unwind_Exception *a1)
{
}

void sub_1000C85DC(uint64_t a1@<X8>)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_101934E70);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_101934E70))
  {
    sub_100050B58((std::string *)&xmmword_101934E58);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_101934E58, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101934E70);
  }

  if (byte_101934E6F < 0)
  {
    sub_1010DD48C((_BYTE *)a1, (void *)xmmword_101934E58, *((unint64_t *)&xmmword_101934E58 + 1));
  }

  else
  {
    *(_OWORD *)a1 = xmmword_101934E58;
    *(void *)(a1 + 16) = unk_101934E68;
  }

void sub_1000C868C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000C86A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(double *)(a1 + 16) = a7;
  *(void *)(a1 + 24) = a4;
  sub_100068220(a1 + 32, a5);
  if ((a6 & 0xFF00000000LL) != 0) {
    int v9 = a6;
  }
  else {
    int v9 = 0;
  }
  *(_DWORD *)(a1 + 112) = v9;
  return a1;
}

void sub_1000C86EC(uint64_t *a1)
{
  BOOL v2 = sub_1003C1048(*a1);
  *((_BYTE *)a1 + 8) = v2;
  if (v2)
  {
    __int128 v9 = off_10181DDA8;
    sub_1003B59A0( *a1,  "MicroLocationMeasurements",  (const char **)&off_10181DDD8,  (const std::string::value_type **)&v9,  0);
    char v3 = sub_1003B747C(*a1, "MicroLocationMeasurements");
    *((_BYTE *)a1 + 8) = v3;
    if ((v3 & 1) != 0)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181DDB8);
      }
      uint64_t v4 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)std::string buf = 136446210;
        unint64_t v13 = "MicroLocationMeasurements";
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Sucessfully created table if necessary: %{public}s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181DDB8);
        }
        int v10 = 136446210;
        uint64_t v11 = "MicroLocationMeasurements";
        uint64_t v5 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Sucessfully created table if necessary: %{public}s",  &v10,  12,  (void)v9);
LABEL_19:
        CFStringRef v7 = (uint8_t *)v5;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLMicroLocationMeasurementTable::initTable()", "%s\n");
LABEL_29:
        if (v7 != buf) {
          free(v7);
        }
      }
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181DDB8);
      }
      uint64_t v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)std::string buf = 136446210;
        unint64_t v13 = "MicroLocationMeasurements";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "Failed to create table: %{public}s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181DDB8);
        }
        int v10 = 136446210;
        uint64_t v11 = "MicroLocationMeasurements";
        CFStringRef v7 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Failed to create table: %{public}s",  &v10,  12);
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLMicroLocationMeasurementTable::initTable()", "%s\n");
        goto LABEL_29;
      }
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DDB8);
    }
    unsigned int v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Database is not connected so we can't intialize our table",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181DDB8);
      }
      LOWORD(v9) = 0;
      uint64_t v5 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Database is not connected so we can't intialize our table",  &v9,  2,  (void)v9);
      goto LABEL_19;
    }
  }

uint64_t sub_1000C8AE8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(_BYTE *)(a1 + 8) = 0;
  sub_1000C86EC((uint64_t *)a1);
  return a1;
}

uint64_t sub_1000C8B14(uint64_t a1, uint64_t *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    uint64_t v4 = *(void *)a1;
    if (byte_101993A6F >= 0) {
      uint64_t v5 = (char *)&xmmword_101993A58;
    }
    else {
      uint64_t v5 = (char *)xmmword_101993A58;
    }
    sub_1003C0D54(v4, v5, &v35);
    uint64_t v7 = *a2;
    uint64_t v6 = a2[1];
    if (*a2 != v6)
    {
      while (1)
      {
        uint64_t v8 = (sqlite3_stmt *)sub_100019240(v35);
        memset(&v34, 0, sizeof(v34));
        if ((sub_100013090(v7, &v34) & 1) == 0)
        {
          std::bad_cast::bad_cast((std::bad_cast *)&buf);
          *(void *)&__int128 buf = &off_101818CB0;
          sub_1000139B0((uint64_t)&buf);
        }

        double v9 = *(double *)(v7 + 16);
        int v10 = *(_DWORD *)(v7 + 112);
        std::string __p = 0LL;
        uint64_t v32 = 0LL;
        uint64_t v11 = v7 + 32;
        uint64_t v33 = 0LL;
        wireless_diagnostics::google::protobuf::MessageLite::SerializeToString(v7 + 32, &__p);
        uint64_t v12 = v33 >= 0 ? &__p : (void **)__p;
        uint64_t v13 = v33 >= 0 ? HIBYTE(v33) : v32;
        unint64_t v14 = +[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v12, v13);
        uint64_t v15 = (v34.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &v34 : (std::string *)v34.__r_.__value_.__r.__words[0];
        if (!sub_1003BC1F0(v8, 1, (char *)v15)
          || !sub_1003B7480(v8, 2, v9)
          || !sub_1003C2D24(v8, 3, *(void *)(v7 + 24))
          || !sub_1003C2F58(v8, 4, v14)
          || !sub_1003C28BC(v8, 5, (__int16)v10))
        {
          break;
        }

        if (!sub_1003BB2BC(*(void *)a1, v8))
        {
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181DDB8);
          }
          uint64_t v20 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
          {
            if (byte_101993A6F >= 0) {
              __int16 v21 = &xmmword_101993A58;
            }
            else {
              __int16 v21 = (__int128 *)xmmword_101993A58;
            }
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = v21;
            _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "Failed to execute statement. %{public}s",  (uint8_t *)&buf,  0xCu);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(&buf, 0x65CuLL);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181DDB8);
            }
            if (byte_101993A6F >= 0) {
              __int128 v22 = &xmmword_101993A58;
            }
            else {
              __int128 v22 = (__int128 *)xmmword_101993A58;
            }
            int v36 = 136446210;
            uint64_t v37 = v22;
            LODWORD(v30) = 12;
            __int16 v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Failed to execute statement. %{public}s",  &v36,  v30);
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMicroLocationMeasurementTable::insertOrReplace(const std::vector<Entry> &)",  "%s\n",  v23);
          }

void sub_1000C9178( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, std::bad_cast a33)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a29 < 0) {
    operator delete(a24);
  }
  if (a30) {
    (*(void (**)(uint64_t))(*(void *)a30 + 8LL))(a30);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000C91F4(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, std::string *a4@<X8>)
{
  v55.__r_.__value_.__s.__size_ = 14;
  strcpy((char *)&v55, "SELECT * FROM ");
  char v54 = 8;
  strcpy(__s, "(SELECT ");
  uint64_t v8 = std::string::append(&v55, __s, 8uLL);
  __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v56.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0LL;
  v8->__r_.__value_.__l.__cap_ = 0LL;
  v8->__r_.__value_.__r.__words[0] = 0LL;
  sub_1000C8514((uint64_t)__p);
  if ((v52 & 0x80u) == 0) {
    int v10 = __p;
  }
  else {
    int v10 = (void **)__p[0];
  }
  if ((v52 & 0x80u) == 0) {
    std::string::size_type v11 = v52;
  }
  else {
    std::string::size_type v11 = (std::string::size_type)__p[1];
  }
  uint64_t v12 = std::string::append(&v56, (const std::string::value_type *)v10, v11);
  __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v57.__r_.__value_.__l.__cap_ = v12->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0LL;
  v12->__r_.__value_.__l.__cap_ = 0LL;
  v12->__r_.__value_.__r.__words[0] = 0LL;
  unint64_t v14 = std::string::append(&v57, " FROM ");
  __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v58.__r_.__value_.__l.__cap_ = v14->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v58.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0LL;
  v14->__r_.__value_.__l.__cap_ = 0LL;
  v14->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v16 = std::string::append(&v58, "MicroLocationMeasurements");
  __int128 v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v59.__r_.__value_.__l.__cap_ = v16->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0LL;
  v16->__r_.__value_.__l.__cap_ = 0LL;
  v16->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v18 = std::string::append(&v59, " ");
  __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v60.__r_.__value_.__l.__cap_ = v18->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0LL;
  v18->__r_.__value_.__l.__cap_ = 0LL;
  v18->__r_.__value_.__r.__words[0] = 0LL;
  int v20 = *(char *)(a2 + 23);
  if (v20 >= 0) {
    __int16 v21 = (const std::string::value_type *)a2;
  }
  else {
    __int16 v21 = *(const std::string::value_type **)a2;
  }
  if (v20 >= 0) {
    std::string::size_type v22 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v22 = *(void *)(a2 + 8);
  }
  __int16 v23 = std::string::append(&v60, v21, v22);
  __int128 v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v61.__r_.__value_.__l.__cap_ = v23->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0LL;
  v23->__r_.__value_.__l.__cap_ = 0LL;
  v23->__r_.__value_.__r.__words[0] = 0LL;
  __int16 v25 = std::string::append(&v61, " ");
  __int128 v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v62.__r_.__value_.__l.__cap_ = v25->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v62.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0LL;
  v25->__r_.__value_.__l.__cap_ = 0LL;
  v25->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v27 = std::string::append(&v62, " ORDER BY ");
  __int128 v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  v63.__r_.__value_.__l.__cap_ = v27->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v63.__r_.__value_.__l.__data_ = v28;
  v27->__r_.__value_.__l.__size_ = 0LL;
  v27->__r_.__value_.__l.__cap_ = 0LL;
  v27->__r_.__value_.__r.__words[0] = 0LL;
  __int16 v29 = std::string::append(&v63, "ScanCFTimestamp");
  __int128 v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v64.__r_.__value_.__l.__cap_ = v29->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v64.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0LL;
  v29->__r_.__value_.__l.__cap_ = 0LL;
  v29->__r_.__value_.__r.__words[0] = 0LL;
  __int16 v31 = std::string::append(&v64, " DESC LIMIT ");
  __int128 v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v69.__r_.__value_.__l.__cap_ = v31->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v69.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0LL;
  v31->__r_.__value_.__l.__cap_ = 0LL;
  v31->__r_.__value_.__r.__words[0] = 0LL;
  std::to_string(&v50, a3);
  if ((v50.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v33 = &v50;
  }
  else {
    uint64_t v33 = (std::string *)v50.__r_.__value_.__r.__words[0];
  }
  if ((v50.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type size = v50.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type size = v50.__r_.__value_.__l.__size_;
  }
  uint64_t v35 = std::string::append(&v69, (const std::string::value_type *)v33, size);
  __int128 v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v65.__r_.__value_.__l.__cap_ = v35->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v65.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0LL;
  v35->__r_.__value_.__l.__cap_ = 0LL;
  v35->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v37 = std::string::append(&v65, ") ORDER BY ");
  __int128 v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  v68.__r_.__value_.__l.__cap_ = v37->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v68.__r_.__value_.__l.__data_ = v38;
  v37->__r_.__value_.__l.__size_ = 0LL;
  v37->__r_.__value_.__l.__cap_ = 0LL;
  v37->__r_.__value_.__r.__words[0] = 0LL;
  unsigned int v39 = std::string::append(&v68, "ScanCFTimestamp");
  __int128 v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
  int64_t cap = v39->__r_.__value_.__l.__cap_;
  *(_OWORD *)uint64_t v66 = v40;
  v39->__r_.__value_.__l.__size_ = 0LL;
  v39->__r_.__value_.__l.__cap_ = 0LL;
  v39->__r_.__value_.__r.__words[0] = 0LL;
  if (v54 < 0) {
    operator delete(*(void **)__s);
  }
  if (cap >= 0) {
    __int128 v41 = (char *)v66;
  }
  else {
    __int128 v41 = (char *)v66[0];
  }
  sub_1003C0D54(a1, v41, &v68);
  std::string::size_type v42 = v68.__r_.__value_.__r.__words[0];
  uint64_t v43 = (sqlite3_stmt *)sub_100019240((uint64_t)v68.__r_.__value_.__l.__data_);
  memset(&v65, 0, sizeof(v65));
  while (j__sqlite3_step(v43) == 100)
  {
    v69.__r_.__value_.__r.__words[0] = sub_100011C2C(v43, 0);
    v69.__r_.__value_.__l.__size_ = v44;
    v64.__r_.__value_.__r.__words[0] = sqlite3_column_double(v43, 1);
    v63.__r_.__value_.__r.__words[0] = sub_1000CC094(v43, 2);
    sub_1000CC0B0(v43, 3, (uint64_t)&v68);
    int v45 = sqlite3_column_int64(v43, 4);
    LODWORD(v62.__r_.__value_.__l.__data_) = v45;
    std::string::size_type v46 = v65.__r_.__value_.__l.__size_;
    if (v65.__r_.__value_.__l.__size_ >= v65.__r_.__value_.__l.__cap_)
    {
      std::string::size_type v49 = sub_1000CC1C0((uint64_t *)&v65, &v69, (uint64_t *)&v64, (uint64_t *)&v63, (uint64_t)&v68, (int *)&v62);
    }

    else
    {
      std::string::size_type v47 = v64.__r_.__value_.__r.__words[0];
      std::string::size_type v48 = v63.__r_.__value_.__r.__words[0];
      *(_OWORD *)v65.__r_.__value_.__l.__size_ = *(_OWORD *)&v69.__r_.__value_.__l.__data_;
      *(void *)(v46 + 16) = v47;
      *(void *)(v46 + 24) = v48;
      sub_100068220(v46 + 32, &v68);
      *(_DWORD *)(v46 + 112) = v45;
      std::string::size_type v49 = v46 + 120;
    }

    v65.__r_.__value_.__l.__size_ = v49;
    sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)&v68);
  }

  sqlite3_reset(v43);
  *a4 = v65;
  memset(&v65, 0, sizeof(v65));
  v68.__r_.__value_.__r.__words[0] = (std::string::size_type)&v65;
  sub_10003F8A8((void ***)&v68);
  if (v42) {
    (*(void (**)(std::string::size_type))(*(void *)v42 + 8LL))(v42);
  }
  if (SHIBYTE(cap) < 0) {
    operator delete(v66[0]);
  }
}

void sub_1000C9758( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, void *a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, uint64_t a37, uint64_t a38, void *a39, uint64_t a40, uint64_t a41, uint64_t a42, void *a43, uint64_t a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58,void *a59,uint64_t a60,uint64_t a61,uint64_t a62,void *__p)
{
  __int128 buf = &a59;
  sub_10003F8A8(&buf);
  if (v70) {
    (*(void (**)(uint64_t))(*(void *)v70 + 8LL))(v70);
  }
  if (a68 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1000C994C()
{
}

void sub_1000C9AF8()
{
}

void sub_1000C9B0C(void *a1, int a2)
{
  if (a2) {
    sub_100006BB8(a1);
  }
  JUMPOUT(0x1000C9944LL);
}

void sub_1000C9B1C( uint64_t a1@<X0>, _BYTE *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned int a5@<W4>, std::string *a6@<X8>)
{
  if (*(_BYTE *)(a1 + 8))
  {
    v79.__r_.__value_.__s.__size_ = 7;
    strcpy((char *)&v79, " WHERE ");
    uint64_t v12 = std::string::append(&v79, "RecordingUUID");
    __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v80.__r_.__value_.__l.__cap_ = v12->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v80.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0LL;
    v12->__r_.__value_.__l.__cap_ = 0LL;
    v12->__r_.__value_.__r.__words[0] = 0LL;
    unint64_t v14 = std::string::append(&v80, " in ");
    __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v81.__r_.__value_.__l.__cap_ = v14->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v81.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0LL;
    v14->__r_.__value_.__l.__cap_ = 0LL;
    v14->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v16 = std::string::append(&v81, "(SELECT ");
    __int128 v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v82.__r_.__value_.__l.__cap_ = v16->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v82.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0LL;
    v16->__r_.__value_.__l.__cap_ = 0LL;
    v16->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v18 = std::string::append(&v82, "RecordingUUID");
    __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v83.__r_.__value_.__l.__cap_ = v18->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v83.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    int v20 = std::string::append(&v83, " FROM ");
    __int128 v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v84.__r_.__value_.__l.__cap_ = v20->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v84.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0LL;
    v20->__r_.__value_.__l.__cap_ = 0LL;
    v20->__r_.__value_.__r.__words[0] = 0LL;
    std::string::size_type v22 = std::string::append(&v84, "MicroLocationRecordingEvents");
    __int128 v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v85.__r_.__value_.__l.__cap_ = v22->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v85.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0LL;
    v22->__r_.__value_.__l.__cap_ = 0LL;
    v22->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v24 = std::string::append(&v85, " WHERE ");
    __int128 v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v86.__r_.__value_.__l.__cap_ = v24->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v86.__r_.__value_.__l.__data_ = v25;
    v24->__r_.__value_.__l.__size_ = 0LL;
    v24->__r_.__value_.__l.__cap_ = 0LL;
    v24->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v26 = std::string::append(&v86, "EventType");
    __int128 v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
    v87.__r_.__value_.__l.__cap_ = v26->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v87.__r_.__value_.__l.__data_ = v27;
    v26->__r_.__value_.__l.__size_ = 0LL;
    v26->__r_.__value_.__l.__cap_ = 0LL;
    v26->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v28 = std::string::append(&v87, "=");
    __int128 v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v88.__r_.__value_.__l.__cap_ = v28->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v88.__r_.__value_.__l.__data_ = v29;
    v28->__r_.__value_.__l.__size_ = 0LL;
    v28->__r_.__value_.__l.__cap_ = 0LL;
    v28->__r_.__value_.__r.__words[0] = 0LL;
    std::to_string(&v78, 1);
    if ((v78.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v30 = &v78;
    }
    else {
      __int128 v30 = (std::string *)v78.__r_.__value_.__r.__words[0];
    }
    if ((v78.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = v78.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = v78.__r_.__value_.__l.__size_;
    }
    __int128 v32 = std::string::append(&v88, (const std::string::value_type *)v30, size);
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v89.__r_.__value_.__l.__cap_ = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v89.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    std::string v34 = std::string::append(&v89, " AND HEX(");
    __int128 v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
    v90.__r_.__value_.__l.__cap_ = v34->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v90.__r_.__value_.__l.__data_ = v35;
    v34->__r_.__value_.__l.__size_ = 0LL;
    v34->__r_.__value_.__l.__cap_ = 0LL;
    v34->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v36 = std::string::append(&v90, "Event");
    __int128 v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
    v91.__r_.__value_.__l.__cap_ = v36->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v91.__r_.__value_.__l.__data_ = v37;
    v36->__r_.__value_.__l.__size_ = 0LL;
    v36->__r_.__value_.__l.__cap_ = 0LL;
    v36->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v38 = std::string::append(&v91, ") LIKE ");
    __int128 v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
    v92.__r_.__value_.__l.__cap_ = v38->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v92.__r_.__value_.__l.__data_ = v39;
    v38->__r_.__value_.__l.__size_ = 0LL;
    v38->__r_.__value_.__l.__cap_ = 0LL;
    v38->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v40 = std::string::append(&v92, "'080111________________1A021002%'");
    __int128 v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
    v93.__r_.__value_.__l.__cap_ = v40->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v93.__r_.__value_.__l.__data_ = v41;
    v40->__r_.__value_.__l.__size_ = 0LL;
    v40->__r_.__value_.__l.__cap_ = 0LL;
    v40->__r_.__value_.__r.__words[0] = 0LL;
    std::string::size_type v42 = std::string::append(&v93, " AND ");
    __int128 v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
    v94.__r_.__value_.__l.__cap_ = v42->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v94.__r_.__value_.__l.__data_ = v43;
    v42->__r_.__value_.__l.__size_ = 0LL;
    v42->__r_.__value_.__l.__cap_ = 0LL;
    v42->__r_.__value_.__r.__words[0] = 0LL;
    std::string::size_type v44 = std::string::append(&v94, "RecordingTimestamp");
    __int128 v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    v95.__r_.__value_.__l.__cap_ = v44->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v95.__r_.__value_.__l.__data_ = v45;
    v44->__r_.__value_.__l.__size_ = 0LL;
    v44->__r_.__value_.__l.__cap_ = 0LL;
    v44->__r_.__value_.__r.__words[0] = 0LL;
    std::string::size_type v46 = std::string::append(&v95, " > ");
    __int128 v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
    v96.__r_.__value_.__l.__cap_ = v46->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v96.__r_.__value_.__l.__data_ = v47;
    v46->__r_.__value_.__l.__size_ = 0LL;
    v46->__r_.__value_.__l.__cap_ = 0LL;
    v46->__r_.__value_.__r.__words[0] = 0LL;
    int v48 = *(char *)(a3 + 23);
    if (v48 >= 0) {
      std::string::size_type v49 = (const std::string::value_type *)a3;
    }
    else {
      std::string::size_type v49 = *(const std::string::value_type **)a3;
    }
    if (v48 >= 0) {
      std::string::size_type v50 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      std::string::size_type v50 = *(void *)(a3 + 8);
    }
    uint64_t v51 = std::string::append(&v96, v49, v50);
    __int128 v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
    v97.__r_.__value_.__l.__cap_ = v51->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v97.__r_.__value_.__l.__data_ = v52;
    v51->__r_.__value_.__l.__size_ = 0LL;
    v51->__r_.__value_.__l.__cap_ = 0LL;
    v51->__r_.__value_.__r.__words[0] = 0LL;
    std::string v53 = std::string::append(&v97, " AND ");
    __int128 v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
    v98.__r_.__value_.__l.__cap_ = v53->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v98.__r_.__value_.__l.__data_ = v54;
    v53->__r_.__value_.__l.__size_ = 0LL;
    v53->__r_.__value_.__l.__cap_ = 0LL;
    v53->__r_.__value_.__r.__words[0] = 0LL;
    std::string v55 = std::string::append(&v98, "RecordingTimestamp");
    __int128 v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
    v99.__r_.__value_.__l.__cap_ = v55->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v99.__r_.__value_.__l.__data_ = v56;
    v55->__r_.__value_.__l.__size_ = 0LL;
    v55->__r_.__value_.__l.__cap_ = 0LL;
    v55->__r_.__value_.__r.__words[0] = 0LL;
    std::string v57 = std::string::append(&v99, "<= ");
    __int128 v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
    v100.__r_.__value_.__l.__cap_ = v57->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v100.__r_.__value_.__l.__data_ = v58;
    v57->__r_.__value_.__l.__size_ = 0LL;
    v57->__r_.__value_.__l.__cap_ = 0LL;
    v57->__r_.__value_.__r.__words[0] = 0LL;
    int v59 = *(char *)(a4 + 23);
    if (v59 >= 0) {
      std::string v60 = (const std::string::value_type *)a4;
    }
    else {
      std::string v60 = *(const std::string::value_type **)a4;
    }
    if (v59 >= 0) {
      std::string::size_type v61 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      std::string::size_type v61 = *(void *)(a4 + 8);
    }
    std::string v62 = std::string::append(&v100, v60, v61);
    __int128 v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
    v101.__r_.__value_.__l.__cap_ = v62->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v101.__r_.__value_.__l.__data_ = v63;
    v62->__r_.__value_.__l.__size_ = 0LL;
    v62->__r_.__value_.__l.__cap_ = 0LL;
    v62->__r_.__value_.__r.__words[0] = 0LL;
    std::string v64 = std::string::append(&v101, " AND ");
    __int128 v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v102.__r_.__value_.__l.__cap_ = v64->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v102.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0LL;
    v64->__r_.__value_.__l.__cap_ = 0LL;
    v64->__r_.__value_.__r.__words[0] = 0LL;
    sub_1010DDBC0(v74, "RtLoiGroupId");
    sub_100053C78((const void **)v74, a2, (uint64_t)__p);
    if ((v77 & 0x80u) == 0) {
      uint64_t v66 = __p;
    }
    else {
      uint64_t v66 = (void **)__p[0];
    }
    if ((v77 & 0x80u) == 0) {
      std::string::size_type v67 = v77;
    }
    else {
      std::string::size_type v67 = (std::string::size_type)__p[1];
    }
    std::string v68 = std::string::append(&v102, (const std::string::value_type *)v66, v67);
    __int128 v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
    v103.__r_.__value_.__l.__cap_ = v68->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v103.__r_.__value_.__l.__data_ = v69;
    v68->__r_.__value_.__l.__size_ = 0LL;
    v68->__r_.__value_.__l.__cap_ = 0LL;
    v68->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v70 = std::string::append(&v103, ")");
    __int128 v71 = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
    std::string::size_type cap = v70->__r_.__value_.__l.__cap_;
    *(_OWORD *)__int128 buf = v71;
    v70->__r_.__value_.__l.__size_ = 0LL;
    v70->__r_.__value_.__l.__cap_ = 0LL;
    v70->__r_.__value_.__r.__words[0] = 0LL;
    if (v75 < 0) {
      operator delete(v74[0]);
    }
    sub_1000C91F4(*(void *)a1, (uint64_t)buf, a5, a6);
    if (SHIBYTE(cap) < 0) {
      operator delete(*(void **)buf);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DDB8);
    }
    uint64_t v72 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so we can't select all",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181DDB8);
      }
      LOWORD(v103.__r_.__value_.__l.__data_) = 0;
      int v73 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Table is not valid so we can't select all",  &v103,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<CLMicroLocationMeasurementTable::Entry> CLMicroLocationMeasurementTable::selectLearningMeasurementsA tLoiBetweenTimes(const boost::uuids::uuid &, const std::string &, const std::string &, uint32_t)",  "%s\n",  v73);
    }

    a6->__r_.__value_.__r.__words[0] = 0LL;
    a6->__r_.__value_.__l.__size_ = 0LL;
    a6->__r_.__value_.__l.__cap_ = 0LL;
  }

void sub_1000CA340(_Unwind_Exception *a1)
{
}

void sub_1000CA560()
{
}

void sub_1000CA568()
{
}

void sub_1000CA570()
{
}

void sub_1000CA578()
{
}

void sub_1000CA580()
{
}

void sub_1000CA588()
{
}

void sub_1000CA590()
{
}

void sub_1000CA598()
{
}

void sub_1000CA5A0()
{
}

void sub_1000CA5A8()
{
}

void sub_1000CA5B0()
{
}

void sub_1000CA5B8()
{
}

void sub_1000CA5C0()
{
}

void sub_1000CA5C8()
{
}

void sub_1000CA5D0()
{
}

void sub_1000CA5D8()
{
}

void sub_1000CA5E0()
{
}

void sub_1000CA5E8()
{
}

void sub_1000CA5F0()
{
}

void sub_1000CA5F8()
{
}

void sub_1000CA600(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned int a3@<W2>, std::string *a4@<X8>)
{
  if (!*(_BYTE *)(a1 + 8))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DDB8);
    }
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    __int128 v39 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so we can't select all",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_66;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 == -1)
    {
LABEL_70:
      __int128 v40 = p_vtable[283];
      LOWORD(v47.__r_.__value_.__l.__data_) = 0;
      __int128 v41 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v40,  0LL,  "#Warning Table is not valid so we can't select all",  &v47,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<CLMicroLocationMeasurementTable::Entry> CLMicroLocationMeasurementTable::selectMeasurementsFromRecor dingUUIDs(const std::vector<boost::uuids::uuid> &, uint32_t)",  "%s\n",  v41);
LABEL_66:
      a4->__r_.__value_.__r.__words[0] = 0LL;
      a4->__r_.__value_.__l.__size_ = 0LL;
      a4->__r_.__value_.__l.__cap_ = 0LL;
      return;
    }

void sub_1000CABC4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, void *a37, uint64_t a38, int a39, __int16 a40, char a41, char a42, uint64_t a43, void *a44, uint64_t a45, int a46, __int16 a47, char a48, char a49, uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (a56 < 0) {
    operator delete(__p);
  }
  if (a16 < 0) {
    operator delete(a11);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1000CAD3C(uint64_t a1, unint64_t a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    v42.__r_.__value_.__s.__size_ = 12;
    strcpy((char *)&v42, "DELETE FROM ");
    uint64_t v4 = std::string::append(&v42, "MicroLocationMeasurements");
    __int128 v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v43.__r_.__value_.__l.__cap_ = v4->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0LL;
    v4->__r_.__value_.__l.__cap_ = 0LL;
    v4->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v6 = std::string::append(&v43, " WHERE ");
    __int128 v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v44.__r_.__value_.__l.__cap_ = v6->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0LL;
    v6->__r_.__value_.__l.__cap_ = 0LL;
    v6->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v8 = std::string::append(&v44, "ScanCFTimestamp");
    __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v45.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0LL;
    v8->__r_.__value_.__l.__cap_ = 0LL;
    v8->__r_.__value_.__r.__words[0] = 0LL;
    int v10 = std::string::append(&v45, " IN (");
    __int128 v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__l.__cap_ = v10->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0LL;
    v10->__r_.__value_.__l.__cap_ = 0LL;
    v10->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v12 = std::string::append(&v46, "SELECT ");
    __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__l.__cap_ = v12->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0LL;
    v12->__r_.__value_.__l.__cap_ = 0LL;
    v12->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v14 = std::string::append(&v47, "ScanCFTimestamp");
    __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v48.__r_.__value_.__l.__cap_ = v14->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0LL;
    v14->__r_.__value_.__l.__cap_ = 0LL;
    v14->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v16 = std::string::append(&v48, " FROM ");
    __int128 v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v49.__r_.__value_.__l.__cap_ = v16->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0LL;
    v16->__r_.__value_.__l.__cap_ = 0LL;
    v16->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v18 = std::string::append(&v49, "MicroLocationMeasurements");
    __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v50.__r_.__value_.__l.__cap_ = v18->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    std::string::size_type v20 = std::string::append(&v50, " ORDER BY ");
    __int128 v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__l.__cap_ = v20->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0LL;
    v20->__r_.__value_.__l.__cap_ = 0LL;
    v20->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v22 = std::string::append(&v51, "ScanCFTimestamp");
    __int128 v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__l.__cap_ = v22->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0LL;
    v22->__r_.__value_.__l.__cap_ = 0LL;
    v22->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v24 = std::string::append(&v52, " LIMIT ");
    __int128 v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__l.__cap_ = v24->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v25;
    v24->__r_.__value_.__l.__size_ = 0LL;
    v24->__r_.__value_.__l.__cap_ = 0LL;
    v24->__r_.__value_.__r.__words[0] = 0LL;
    std::to_string(&v41, a2);
    if ((v41.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v26 = &v41;
    }
    else {
      std::string::size_type v26 = (std::string *)v41.__r_.__value_.__r.__words[0];
    }
    if ((v41.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = v41.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = v41.__r_.__value_.__l.__size_;
    }
    __int128 v28 = std::string::append(&v53, (const std::string::value_type *)v26, size);
    __int128 v29 = *(_OWORD *)&v28->__r_.__value_.__l.__data_;
    v56.__r_.__value_.__l.__cap_ = v28->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v29;
    v28->__r_.__value_.__l.__size_ = 0LL;
    v28->__r_.__value_.__l.__cap_ = 0LL;
    v28->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v30 = std::string::append(&v56, ")");
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    int64_t cap = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)std::string __p = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    if (cap >= 0) {
      __int128 v32 = (char *)__p;
    }
    else {
      __int128 v32 = (char *)__p[0];
    }
    sub_1003C0D54(*(void *)a1, v32, &v56);
    std::string::size_type v33 = v56.__r_.__value_.__r.__words[0];
    std::string::size_type v34 = (sqlite3_stmt *)sub_100019240((uint64_t)v56.__r_.__value_.__l.__data_);
    if (v34)
    {
      BOOL v35 = sub_1003BB2BC(*(void *)a1, v34);
      if (!v33) {
        goto LABEL_42;
      }
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181DDB8);
      }
      __int128 v38 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v56.__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_ERROR,  "Error getting a prepared statement",  (uint8_t *)&v56,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(&v56, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181DDB8);
        }
        LOWORD(v53.__r_.__value_.__l.__data_) = 0;
        __int128 v40 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v56,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Error getting a prepared statement",  &v53,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMicroLocationMeasurementTable::deleteOldestRows(uint64_t)",  "%s\n",  (const char *)v40);
        if (v40 != &v56) {
          free(v40);
        }
      }

      BOOL v35 = 0LL;
      if (!v33) {
        goto LABEL_42;
      }
    }

    (*(void (**)(std::string::size_type))(*(void *)v33 + 8LL))(v33);
LABEL_42:
    if (SHIBYTE(cap) < 0) {
      operator delete(__p[0]);
    }
    return v35;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181DDB8);
  }
  __int128 v36 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v56.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so we can't deleteOldestRows",  (uint8_t *)&v56,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v56, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DDB8);
    }
    LOWORD(__p[0]) = 0;
    __int128 v39 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v56,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Table is not valid so we can't deleteOldestRows",  __p,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationMeasurementTable::deleteOldestRows(uint64_t)",  "%s\n",  (const char *)v39);
    if (v39 != &v56) {
      free(v39);
    }
  }

  return 0LL;
}

void sub_1000CB3B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, void *a33, uint64_t a34, uint64_t a35, uint64_t a36, void *a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, void *a45, uint64_t a46, uint64_t a47, uint64_t a48, void *a49, uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,uint64_t a60,void *__p,uint64_t a62,int a63)
{
  if (v66) {
    (*(void (**)(uint64_t))(*(void *)v66 + 8LL))(v66);
  }
  if (a66 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1000CB544(uint64_t a1, uint64_t *a2)
{
  if (!*(_BYTE *)(a1 + 8))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DDB8);
    }
    std::string v43 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v66.__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so we can't delete measurements",  (uint8_t *)&v66,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 0LL;
    }
    bzero(&v66, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DDB8);
    }
    LOWORD(v65.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v66,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Table is not valid so we can't delete measurements",  &v65,  2);
    std::string v45 = (std::string *)v44;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationMeasurementTable::deleteMeasurementsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &)",  "%s\n",  v44);
    goto LABEL_102;
  }

  uint64_t v4 = *a2;
  if (*a2 == a2[1])
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DDB8);
    }
    std::string v46 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v66.__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "#Warning No UUIDs are passed in to delete measurements entries",  (uint8_t *)&v66,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      return 0LL;
    }
    bzero(&v66, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DDB8);
    }
    LOWORD(v65.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v66,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning No UUIDs are passed in to delete measurements entries",  &v65,  2);
    std::string v45 = (std::string *)v49;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationMeasurementTable::deleteMeasurementsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &)",  "%s\n",  v49);
LABEL_102:
    if (v45 != &v66) {
      free(v45);
    }
    return 0LL;
  }

  v64.__r_.__value_.__s.__size_ = 1;
  LOWORD(v64.__r_.__value_.__l.__data_) = 34;
  memset(&__p, 0, sizeof(__p));
  if ((sub_100013090(v4, &__p) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)&v66);
    v66.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101818CB0;
    sub_1000139B0((uint64_t)&v66);
  }

  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type size = __p.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  __int128 v7 = std::string::append(&v64, (const std::string::value_type *)p_p, size);
  __int128 v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
  v65.__r_.__value_.__l.__cap_ = v7->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v65.__r_.__value_.__l.__data_ = v8;
  v7->__r_.__value_.__l.__size_ = 0LL;
  v7->__r_.__value_.__l.__cap_ = 0LL;
  v7->__r_.__value_.__r.__words[0] = 0LL;
  __int128 v9 = std::string::append(&v65, "");
  __int128 v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
  v60.__r_.__value_.__l.__cap_ = v9->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v10;
  v9->__r_.__value_.__l.__size_ = 0LL;
  v9->__r_.__value_.__l.__cap_ = 0LL;
  v9->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v11 = a2[1];
  for (uint64_t i = *a2 + 16; i != v11; i += 16LL)
  {
    v62.__r_.__value_.__s.__size_ = 1;
    LOWORD(v62.__r_.__value_.__l.__data_) = 44;
    __int128 v13 = std::string::append(&v62, "");
    __int128 v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__l.__cap_ = v13->__r_.__value_.__l.__cap_;
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0LL;
    v13->__r_.__value_.__l.__cap_ = 0LL;
    v13->__r_.__value_.__r.__words[0] = 0LL;
    memset(&v61, 0, sizeof(v61));
    if ((sub_100013090(i, &v61) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)&v66);
      v66.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101818CB0;
      sub_1000139B0((uint64_t)&v66);
    }

    if ((v61.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v15 = &v61;
    }
    else {
      __int128 v15 = (std::string *)v61.__r_.__value_.__r.__words[0];
    }
    if ((v61.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v16 = v61.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v16 = v61.__r_.__value_.__l.__size_;
    }
    __int128 v17 = std::string::append(&__p, (const std::string::value_type *)v15, v16);
    __int128 v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v64.__r_.__value_.__l.__cap_ = v17->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v64.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0LL;
    v17->__r_.__value_.__l.__cap_ = 0LL;
    v17->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v19 = std::string::append(&v64, "");
    __int128 v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v65.__r_.__value_.__l.__cap_ = v19->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v65.__r_.__value_.__l.__data_ = v20;
    v19->__r_.__value_.__l.__size_ = 0LL;
    v19->__r_.__value_.__l.__cap_ = 0LL;
    v19->__r_.__value_.__r.__words[0] = 0LL;
    if ((v65.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v21 = &v65;
    }
    else {
      __int128 v21 = (std::string *)v65.__r_.__value_.__r.__words[0];
    }
    if ((v65.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v22 = v65.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v22 = v65.__r_.__value_.__l.__size_;
    }
    std::string::append(&v60, (const std::string::value_type *)v21, v22);
  }

  v58.__r_.__value_.__s.__size_ = 12;
  strcpy((char *)&v58, "DELETE FROM ");
  __int128 v23 = std::string::append(&v58, "MicroLocationMeasurements");
  __int128 v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v59.__r_.__value_.__l.__cap_ = v23->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v59.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0LL;
  v23->__r_.__value_.__l.__cap_ = 0LL;
  v23->__r_.__value_.__r.__words[0] = 0LL;
  __int128 v25 = std::string::append(&v59, " WHERE ");
  __int128 v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v61.__r_.__value_.__l.__cap_ = v25->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0LL;
  v25->__r_.__value_.__l.__cap_ = 0LL;
  v25->__r_.__value_.__r.__words[0] = 0LL;
  __int128 v27 = std::string::append(&v61, "RecordingUUID");
  __int128 v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  v62.__r_.__value_.__l.__cap_ = v27->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v62.__r_.__value_.__l.__data_ = v28;
  v27->__r_.__value_.__l.__size_ = 0LL;
  v27->__r_.__value_.__l.__cap_ = 0LL;
  v27->__r_.__value_.__r.__words[0] = 0LL;
  char v57 = 4;
  strcpy(__s, " IN ");
  __int128 v29 = std::string::append(&v62, __s, 4uLL);
  __int128 v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__l.__cap_ = v29->__r_.__value_.__l.__cap_;
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0LL;
  v29->__r_.__value_.__l.__cap_ = 0LL;
  v29->__r_.__value_.__r.__words[0] = 0LL;
  char v55 = 1;
  strcpy(v54, "(");
  __int128 v31 = std::string::append(&__p, v54, 1uLL);
  __int128 v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v64.__r_.__value_.__l.__cap_ = v31->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v64.__r_.__value_.__l.__data_ = v32;
  v31->__r_.__value_.__l.__size_ = 0LL;
  v31->__r_.__value_.__l.__cap_ = 0LL;
  v31->__r_.__value_.__r.__words[0] = 0LL;
  if ((v60.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type v33 = &v60;
  }
  else {
    std::string::size_type v33 = (std::string *)v60.__r_.__value_.__r.__words[0];
  }
  if ((v60.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type v34 = v60.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type v34 = v60.__r_.__value_.__l.__size_;
  }
  BOOL v35 = std::string::append(&v64, (const std::string::value_type *)v33, v34);
  __int128 v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  v66.__r_.__value_.__l.__cap_ = v35->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v66.__r_.__value_.__l.__data_ = v36;
  v35->__r_.__value_.__l.__size_ = 0LL;
  v35->__r_.__value_.__l.__cap_ = 0LL;
  v35->__r_.__value_.__r.__words[0] = 0LL;
  char v53 = 1;
  strcpy(v52, ")");
  __int128 v37 = std::string::append(&v66, v52, 1uLL);
  __int128 v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  v65.__r_.__value_.__l.__cap_ = v37->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v65.__r_.__value_.__l.__data_ = v38;
  v37->__r_.__value_.__l.__size_ = 0LL;
  v37->__r_.__value_.__l.__cap_ = 0LL;
  v37->__r_.__value_.__r.__words[0] = 0LL;
  if (v53 < 0) {
    operator delete(*(void **)v52);
  }
  if (v55 < 0) {
    operator delete(*(void **)v54);
  }
  if (v57 < 0) {
    operator delete(*(void **)__s);
  }
  if ((v65.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    __int128 v39 = &v65;
  }
  else {
    __int128 v39 = (std::string *)v65.__r_.__value_.__r.__words[0];
  }
  sub_1003C0D54(*(void *)a1, (char *)v39, &v66);
  std::string::size_type v40 = v66.__r_.__value_.__r.__words[0];
  std::string v41 = (sqlite3_stmt *)sub_100019240((uint64_t)v66.__r_.__value_.__l.__data_);
  if (!v41)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DDB8);
    }
    std::string v48 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v66.__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_ERROR,  "Error getting a prepared statement",  (uint8_t *)&v66,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(&v66, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181DDB8);
      }
      LOWORD(v64.__r_.__value_.__l.__data_) = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &v66,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Error getting a prepared statement",  &v64,  2);
      std::string v51 = (std::string *)v50;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMicroLocationMeasurementTable::deleteMeasurementsFromRecordingUUIDs(const std::vector<boost::uuids::uuid> &)",  "%s\n",  v50);
      if (v51 != &v66) {
        free(v51);
      }
    }

    BOOL v42 = 0LL;
    if (!v40) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }

  BOOL v42 = sub_1003BB2BC(*(void *)a1, v41);
  if (v40) {
LABEL_72:
  }
    (*(void (**)(std::string::size_type))(*(void *)v40 + 8LL))(v40);
LABEL_73:
  return v42;
}

void sub_1000CBE70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, uint64_t a33, void *a34, uint64_t a35, uint64_t a36, uint64_t a37, void *a38, uint64_t a39, uint64_t a40, uint64_t a41, void *a42, uint64_t a43, uint64_t a44, uint64_t a45, void *a46, uint64_t a47, uint64_t a48, uint64_t a49, void *__p,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  if (v55) {
    (*(void (**)(uint64_t))(*(void *)v55 + 8LL))(v55);
  }
  if (a55 < 0) {
    operator delete(__p);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

void sub_1000CC068(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

sqlite3_int64 sub_1000CC094(sqlite3_stmt *a1, int a2)
{
  sqlite3_int64 result = sqlite3_column_int64(a1, a2);
  if (result < 0)
  {
    uint64_t v3 = sub_101229E5C();
    return sub_1000CC0B0(v3);
  }

  return result;
}

uint64_t sub_1000CC0B0@<X0>(sqlite3_stmt *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v6 = sqlite3_column_blob(a1, a2);
  uint64_t v7 = sqlite3_column_bytes(a1, a2);
  if (!v6)
  {
    sub_101229FBC(v7);
LABEL_5:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1010DDBC0(&v12, "Unable to parse protobuf");
    std::runtime_error::runtime_error(exception, &v12);
    exception->__vftable = (std::runtime_error_vtbl *)&off_101819400;
  }

  int v8 = v7;
  sub_10006332C(a3);
  uint64_t result = wireless_diagnostics::google::protobuf::MessageLite::ParseFromArray(v9, v6, v8);
  if ((result & 1) == 0) {
    goto LABEL_5;
  }
  return result;
}

void sub_1000CC178( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      sub_1000682D0(v15);
      _Unwind_Resume(a1);
    }
  }

  else if (!v17)
  {
    goto LABEL_6;
  }

  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t sub_1000CC1C0(uint64_t *a1, _OWORD *a2, uint64_t *a3, uint64_t *a4, uint64_t a5, int *a6)
{
  uint64_t v7 = *a1;
  unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
  unint64_t v9 = v8 + 1;
  if (v8 + 1 > 0x222222222222222LL) {
    sub_100007008();
  }
  uint64_t v15 = (uint64_t)(a1 + 2);
  unint64_t v16 = 0xEEEEEEEEEEEEEEEFLL * ((a1[2] - v7) >> 3);
  if (2 * v16 > v9) {
    unint64_t v9 = 2 * v16;
  }
  if (v16 >= 0x111111111111111LL) {
    unint64_t v17 = 0x222222222222222LL;
  }
  else {
    unint64_t v17 = v9;
  }
  __int128 v28 = a1 + 2;
  if (v17) {
    __int128 v18 = sub_1000BAE04(v15, v17);
  }
  else {
    __int128 v18 = 0LL;
  }
  __int128 v19 = (char *)&v18[30 * v8];
  v25[0] = v18;
  v25[1] = v19;
  __int128 v26 = v19;
  __int128 v27 = (char *)&v18[30 * v17];
  uint64_t v20 = *a3;
  uint64_t v21 = *a4;
  int v22 = *a6;
  *(_OWORD *)__int128 v19 = *a2;
  *((void *)v19 + 2) = v20;
  *((void *)v19 + 3) = v21;
  sub_100068220(v19 + 32, a5);
  v18[30 * v8 + 28] = v22;
  v26 += 120;
  sub_1000CC310(a1, v25);
  uint64_t v23 = a1[1];
  sub_1000BAFA0((uint64_t)v25);
  return v23;
}

void sub_1000CC2FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000CC310(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000BAE48((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

double sub_1000CC384@<D0>(std::string *a1@<X8>)
{
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_1000CC3C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000CC3E4(std::string *a1)
{
  return sub_100012E60(a1);
}

uint64_t sub_1000CC428(std::string *a1)
{
  v7.__r_.__value_.__s.__size_ = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  BOOL v2 = std::string::append(&v7, "RecordingUUID");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t cap = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (cap >= 0) {
    std::string::size_type v5 = HIBYTE(cap);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_1000CC4C4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000CC4F8(std::string *a1)
{
  v7.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&v7, ", ");
  BOOL v2 = std::string::append(&v7, "ScanCFTimestamp");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t cap = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (cap >= 0) {
    std::string::size_type v5 = HIBYTE(cap);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_1000CC5A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000CC5D4(std::string *a1)
{
  v7.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&v7, ", ");
  BOOL v2 = std::string::append(&v7, "ScanMCTimestamp");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t cap = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (cap >= 0) {
    std::string::size_type v5 = HIBYTE(cap);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_1000CC67C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000CC6B0(std::string *a1)
{
  v7.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&v7, ", ");
  BOOL v2 = std::string::append(&v7, "Data");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t cap = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (cap >= 0) {
    std::string::size_type v5 = HIBYTE(cap);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_1000CC758( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000CC78C(std::string *a1)
{
  v7.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&v7, ", ");
  BOOL v2 = std::string::append(&v7, "Flags");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t cap = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)std::string __p = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if (cap >= 0) {
    std::string::size_type v5 = HIBYTE(cap);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_1000CC834( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000CC868()
{
  v19.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x19uLL);
  *(_OWORD *)&v19.__r_.__value_.__r.__words[1] = xmmword_1012C8520;
  strcpy(v19.__r_.__value_.__l.__data_, "INSERT OR REPLACE INTO ");
  CFStringRef v0 = std::string::append(&v19, "MicroLocationMeasurements");
  __int128 v1 = *(_OWORD *)&v0->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__l.__cap_ = v0->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v1;
  v0->__r_.__value_.__l.__size_ = 0LL;
  v0->__r_.__value_.__l.__cap_ = 0LL;
  v0->__r_.__value_.__r.__words[0] = 0LL;
  BOOL v2 = std::string::append(&v20, " (");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__l.__cap_ = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  sub_1000C8514((uint64_t)v17);
  if ((v18 & 0x80u) == 0) {
    uint64_t v4 = v17;
  }
  else {
    uint64_t v4 = (void **)v17[0];
  }
  if ((v18 & 0x80u) == 0) {
    std::string::size_type v5 = v18;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)v17[1];
  }
  uint64_t v6 = std::string::append(&v21, (const std::string::value_type *)v4, v5);
  __int128 v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v22.__r_.__value_.__l.__cap_ = v6->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0LL;
  v6->__r_.__value_.__l.__cap_ = 0LL;
  v6->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v8 = std::string::append(&v22, ") ");
  __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0LL;
  v8->__r_.__value_.__l.__cap_ = 0LL;
  v8->__r_.__value_.__r.__words[0] = 0LL;
  sub_1000C85DC((uint64_t)__p);
  if ((v16 & 0x80u) == 0) {
    __int128 v10 = __p;
  }
  else {
    __int128 v10 = (void **)__p[0];
  }
  if ((v16 & 0x80u) == 0) {
    std::string::size_type v11 = v16;
  }
  else {
    std::string::size_type v11 = (std::string::size_type)__p[1];
  }
  std::string v12 = std::string::append(&v23, (const std::string::value_type *)v10, v11);
  __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  unk_101993A68 = v12->__r_.__value_.__l.__cap_;
  xmmword_101993A58 = v13;
  v12->__r_.__value_.__l.__size_ = 0LL;
  v12->__r_.__value_.__l.__cap_ = 0LL;
  v12->__r_.__value_.__r.__words[0] = 0LL;
  return __cxa_atexit( (void (*)(void *))&std::string::~string,  &xmmword_101993A58,  (void *)&_mh_execute_header);
}

void sub_1000CCA54( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, void *a35, uint64_t a36, int a37, __int16 a38, char a39, char a40)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000CCB00( uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, int a5@<W5>, uint64_t a6@<X8>)
{
  std::string v12 = std::string::insert(&v58, 0LL, "LocalizationProcessing_modelType_");
  __int128 v13 = (void *)v12->__r_.__value_.__r.__words[0];
  *(void *)&__int128 v56 = v12->__r_.__value_.__l.__size_;
  *(void *)((char *)&v56 + 7) = *(std::string::size_type *)((char *)&v12->__r_.__value_.__r.__words[1] + 7);
  unsigned __int8 size = v12->__r_.__value_.__s.__size_;
  v12->__r_.__value_.__l.__size_ = 0LL;
  v12->__r_.__value_.__l.__cap_ = 0LL;
  v12->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v15 = (void **)operator new(0x20uLL);
  __p[0] = v13;
  __p[1] = (void *)v56;
  *(void **)((char *)&__p[1] + 7) = *(void **)((char *)&v56 + 7);
  HIBYTE(__p[2]) = size;
  sub_10004A874((uint64_t)v15, (__int128 *)__p);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  *(void *)a6 = 0LL;
  *(void *)(a6 + 8) = 0LL;
  *(void *)(a6 + 16) = 0LL;
  *(_DWORD *)(a6 + 24) = 3;
  *(void *)(a6 + 32) = 0LL;
  *(_BYTE *)(a6 + 80) = 0;
  *(void *)(a6 + 40) = 0LL;
  *(void *)(a6 + sub_10000AE14(v17 - 48) = 0LL;
  *(_BYTE *)(a6 + 56) = 0;
  unint64_t v16 = sub_1000954B4(a1);
  sub_1000CD40C((void **)a6, v16);
  unsigned int v17 = sub_10000C6AC(a3);
  sub_100041008(v17, &v54);
  if (!sub_100097CA8(a1))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DF28);
    }
    __int128 v29 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      int v30 = *(_DWORD *)(a1 + 4);
      LODWORD(__p[0]) = 67174657;
      HIDWORD(__p[0]) = v30;
      _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "#Warning No results for model type %{private}d because it is invalid",  (uint8_t *)__p,  8u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181DF28);
      }
      int v31 = *(_DWORD *)(a1 + 4);
      LODWORD(v58.__r_.__value_.__l.__data_) = 67174657;
      HIDWORD(v58.__r_.__value_.__r.__words[0]) = v31;
      __int128 v32 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning No results for model type %{private}d because it is invalid",  &v58,  8);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLMicroLocationAlgorithms::LocalizerResults CLMicroLocationLocalizer::localize(const CLMicroLocationModel &, con st CLMicroLocationFingerprint &, const CLMicroLocationLocalizationSettings &, std::optional<boost::uuids::uuid> *, BOOL) const",  "%s\n",  v32);
    }

    goto LABEL_68;
  }

  v58.__r_.__value_.__s.__data_[0] = 0;
  char v60 = 0;
  if (v17 < 4)
  {
    std::string v51 = v15;
    int v18 = sub_10000C794(a3);
    sub_1000C7D20(v18, v53);
    sub_1002F0B04(__p);
    int v19 = a5;
    CFStringRef v20 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsAdaptiveAnchorsEnable", 0x8000100u, kCFAllocatorNull);
    uint64_t v50 = a4;
    char v21 = sub_1002A6FD4((uint64_t)__p[0], (uint64_t)v20, (BOOL *)&v56);
    CFRelease(v20);
    int v22 = v56;
    std::string v23 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
      __int128 v24 = (unint64_t *)((char *)__p[1] + 8);
      do
        unint64_t v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }

    if (v22) {
      char v26 = 0;
    }
    else {
      char v26 = v21;
    }
    if ((v26 & 1) != 0)
    {
      unsigned __int8 v27 = 0;
      LOBYTE(__p[0]) = 0;
      int v28 = v19;
    }

    else
    {
      sub_100019D9C((uint64_t)__p, a1 + 16);
      int v28 = v19;
      *(_OWORD *)&__p[5] = *(_OWORD *)(a1 + 56);
      unsigned __int8 v27 = 1;
    }

    v62.n128_u8[0] = v27;
    uint64_t v15 = v51;
    sub_1000412F0();
    sub_1002F0B04(&v56);
    CFStringRef v36 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsAdaptiveSensorsEnable", 0x8000100u, kCFAllocatorNull);
    sub_1002A6FD4(v56, (uint64_t)v36, &v55);
    CFRelease(v36);
    __int128 v37 = (std::__shared_weak_count *)*((void *)&v56 + 1);
    if (*((void *)&v56 + 1))
    {
      __int128 v38 = (unint64_t *)(*((void *)&v56 + 1) + 8LL);
      do
        unint64_t v39 = __ldaxr(v38);
      while (__stlxr(v39 - 1, v38));
      if (!v39)
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
    }

    sub_1000412E4(v18);
    sub_1000CD4B0((uint64_t)&v58, (uint64_t)&v56);
    uint64_t v40 = v57;
    if (v57 == &v56)
    {
      uint64_t v41 = 4LL;
      uint64_t v40 = &v56;
      a4 = v50;
    }

    else
    {
      a4 = v50;
      if (!v57)
      {
LABEL_46:
        if (v62.n128_u8[0]) {
          sub_100019CEC((uint64_t)__p);
        }
        sub_1002A5554(v53);
        int v33 = v28;
        goto LABEL_49;
      }

      uint64_t v41 = 5LL;
    }

    (*(void (**)(void))(*(void *)v40 + 8 * v41))();
    goto LABEL_46;
  }

  int v33 = 0;
  if (v17 != 4)
  {
    uint64_t v52 = a2;
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181DF28);
    }
    std::string::size_type v34 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      __p[0] = (void *)68289282;
      LOWORD(__p[1]) = 2082;
      *(void **)((char *)&__p[1] + 2) = "";
      WORD1(__p[2]) = 2050;
      *(void **)((char *)&__p[2] + 4) = (void *)v17;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Invalid localization algorithm! No localization done, Localization Algo:%{public}lu}",  (uint8_t *)__p,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181DF28);
      }
    }

    BOOL v35 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      __p[0] = (void *)68289282;
      LOWORD(__p[1]) = 2082;
      *(void **)((char *)&__p[1] + 2) = "";
      WORD1(__p[2]) = 2050;
      *(void **)((char *)&__p[2] + 4) = (void *)v17;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v35,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Invalid localization algorithm! No localization done",  "{msg%{public}.0s:Invalid localization algorithm! No localization done, Localization Algo:%{public}lu}",  (uint8_t *)__p,  0x1Cu);
    }

    int v33 = a5;
    a2 = v52;
  }

void sub_1000CD280( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, uint64_t a31, char a32, uint64_t a33, void *__p, uint64_t a35, int a36, __int16 a37, char a38, char a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, char a44)
{
  if (a19) {
    (*(void (**)(uint64_t))(*(void *)a19 + 8LL))(a19);
  }
  sub_10000AD5C(v45);
  uint64_t v47 = sub_10004B9B4(v44);
  operator delete(v47);
  _Unwind_Resume(a1);
}

void sub_1000CD40C(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 5)
  {
    if (a2 >> 59) {
      sub_100007008();
    }
    int64_t v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    uint64_t v6 = (char *)sub_10000835C(v3, a2);
    __int128 v7 = &v6[v5];
    __int128 v9 = &v6[32 * v8];
    std::string::size_type v11 = (char *)*a1;
    __int128 v10 = (char *)a1[1];
    std::string v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        __int128 v13 = *((_OWORD *)v10 - 2);
        *(_OWORD *)(v12 - 20) = *(_OWORD *)(v10 - 20);
        *((_OWORD *)v12 - 2) = v13;
        v12 -= 32;
        v10 -= 32;
      }

      while (v10 != v11);
      __int128 v10 = (char *)*a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

uint64_t sub_1000CD4B0(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 32))
  {
    sub_100021B50((void *)a1, a2);
  }

  else
  {
    sub_1000CD524(a1, a2);
    *(_BYTE *)(a1 + 32) = 1;
  }

  return a1;
}

void sub_1000CD4F8(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_1000CD524(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24LL))(*v3, a1);
      return a1;
    }

    *(void *)(a1 + 24) = v4;
  }

  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }

  void *v3 = 0LL;
  return a1;
}

uint64_t sub_1000CD588(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &off_10181E028;
  __int128 v7 = (void *)(a1 + 8);
  sub_10008D588((void *)(a1 + 8));
  *(void *)a1 = off_10181DF58;
  *(void *)(a1 + 8) = off_10181DFC0;
  *(void *)(a1 + 64) = &off_10181E090;
  *(void *)(a1 + 72) = &off_10181E0E8;
  *(void *)(a1 + 80) = &off_10181E140;
  *(void *)(a1 + 88) = &off_10181E198;
  *(void *)(a1 + 96) = &off_10181E1F0;
  *(void *)(a1 + 104) = &off_10181E248;
  *(void *)(a1 + 112) = &off_10181E2A0;
  *(void *)(a1 + 120) = &off_10181E2F8;
  *(void *)(a1 + 128) = &off_10181E350;
  *(void *)(a1 + 136) = &off_10181E390;
  *(void *)(a1 + 144) = &off_10181E3D0;
  *(void *)(a1 + 152) = &off_10181E410;
  *(void *)(a1 + 160) = &off_10181E468;
  *(void *)(a1 + 168) = &off_10181E4A8;
  *(void *)(a1 + 176) = &off_10181E4E8;
  *(void *)(a1 + 184) = &off_10181E528;
  *(void *)(a1 + 192) = &off_10181E568;
  *(void *)(a1 + 200) = &off_10181E5A8;
  *(void *)(a1 + 208) = &off_10181E5E8;
  *(void *)(a1 + 216) = &off_10181E640;
  *(void *)(a1 + sub_1000A7938(v46 - 224) = &off_10181E698;
  *(void *)(a1 + 232) = &off_10181E6F0;
  *(void *)(a1 + 240) = &off_10181E748;
  *(void *)(a1 + 2sub_10000AE14(v17 - 48) = &off_10181E7A0;
  *(void *)(a1 + 256) = &off_10181E7F8;
  *(void *)(a1 + 264) = &off_10181E838;
  *(void *)(a1 + 272) = &off_10181E878;
  *(void *)(a1 + 280) = &off_10181E8B8;
  *(void *)(a1 + 288) = &off_10181E910;
  *(void *)(a1 + 296) = &off_10181E968;
  *(void *)(a1 + 304) = &off_10181E9C0;
  *(void *)(a1 + 312) = a3;
  *(_BYTE *)(a1 + 472) = 0;
  *(_BYTE *)(a1 + 480) = 0;
  *(_BYTE *)(a1 + 484) = 0;
  *(void *)(a1 + 336) = 0LL;
  *(void *)(a1 + 344) = 0LL;
  *(void *)(a1 + 328) = a2;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 4sub_10000AE14(v17 - 48) = 0u;
  *(_BYTE *)(a1 + 464) = 0;
  *(_DWORD *)(a1 + 488) = 0;
  sub_1000D443C(a1);
  sub_1000D4710(a1);
  sub_1000D49E4(a1);
  sub_1000D4C18(a1);
  sub_1000D4F94(a1);
  sub_1010DDBC0(v8, "Not in Active Location State");
  sub_10008D7C4(v7, (uint64_t *)v8);
  if (v9 < 0) {
    operator delete(v8[0]);
  }
  *(void *)(a1 + 320) = 0LL;
  return a1;
}

void sub_1000CD90C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, _Unwind_Exception *exception_object, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28)
{
  __int128 v37 = *(void **)(v32 + 440);
  if (v37)
  {
    *(void *)(v32 + 4sub_10000AE14(v17 - 48) = v37;
    operator delete(v37);
  }

  nullsub_10(v32 + 304);
  nullsub_10(v32 + 296);
  nullsub_10(v32 + 288);
  nullsub_10(v32 + 280);
  nullsub_10(v32 + 272);
  nullsub_10(v32 + 264);
  nullsub_10(v32 + 256);
  nullsub_10(v34);
  nullsub_10(v33);
  nullsub_10(v31);
  nullsub_10(v30);
  nullsub_10(v29);
  nullsub_10(v28);
  nullsub_10(v35);
  nullsub_10(a15);
  nullsub_10(a16);
  nullsub_10(a17);
  nullsub_10(a18);
  nullsub_10(a19);
  nullsub_10(a20);
  nullsub_10(a21);
  nullsub_10(a22);
  nullsub_10(a23);
  nullsub_10(a24);
  nullsub_10(a25);
  nullsub_10(a26);
  nullsub_10(a27);
  nullsub_10(a28);
  nullsub_10(*(void *)(v36 - 144));
  nullsub_10(*(void *)(v36 - 136));
  nullsub_10(*(void *)(v36 - 128));
  sub_10008D5F4(*(void **)(v36 - 120));
  _Unwind_Resume(a1);
}

void *sub_1000CDA7C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:LOI Manager: handleVisitEntry}",  buf,  0x12u);
  }

  [*(id *)(a2 + 32) coordinate];
  double v8 = v7;
  [*(id *)(a2 + 32) coordinate];
  if (sub_1000D63A4(a1, v8, v9))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int128 v10 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "LOI Manager, requested LOI for current visit location",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      v22[0] = 0;
      char v21 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "LOI Manager, requested LOI for current visit location",  v22,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<std::string> CLMicroLocationLoiManager::VisitEntry(const CLMiLoLoiManagerLoiVisitEntryEvent *)",  "%s\n",  v21);
      if (v21 != buf) {
        free(v21);
      }
    }

    uint64_t v11 = *(void *)(a1 + 16);
    if (*(char *)(v11 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v11 + 8), *(void *)(v11 + 16));
    }

    else
    {
      __int128 v12 = *(_OWORD *)(v11 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v11 + 24);
      *(_OWORD *)__int128 buf = v12;
    }

    if ((buf[23] & 0x80000000) != 0)
    {
      if (*(void *)&buf[8] != 17LL)
      {
        operator delete(*(void **)buf);
        goto LABEL_48;
      }

      BOOL v20 = **(void **)buf != 0x20656D6F48206E49LL
         || *(void *)(*(void *)buf + 8LL) != 0x7461745320494F4CLL
         || *(_BYTE *)(*(void *)buf + 16LL) != 101;
      operator delete(*(void **)buf);
      if (v20) {
        goto LABEL_48;
      }
    }

    else
    {
      if (buf[23] != 17) {
        goto LABEL_48;
      }
      BOOL v16 = *(void *)buf == 0x20656D6F48206E49LL && *(void *)&buf[8] == 0x7461745320494F4CLL;
      if (!v16 || buf[16] != 101) {
        goto LABEL_48;
      }
    }

    sub_1000D6770(a1, 1LL);
LABEL_48:
    double result = sub_1010DDBC0(buf, "In the process of entering Home LOI");
    goto LABEL_49;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  __int128 v13 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Failed To request LOI for current visit location}",  buf,  0x12u);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  __int128 v14 = (os_log_s *)qword_1019348D8;
  if (os_signpost_enabled((os_log_t)qword_1019348D8))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v14,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Failed To request LOI for current visit location",  "{msg%{public}.0s:LOI Manager, Failed To request LOI for current visit location}",  buf,  0x12u);
  }

  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 4sub_10000AE14(v17 - 48) = *(void *)(a1 + 440);
  if (*(_BYTE *)(a1 + 484)) {
    *(_BYTE *)(a1 + 484) = 0;
  }
  double result = sub_1010DDBC0(buf, "Not in Active Location State");
LABEL_49:
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_1000CDF20@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = a2 + 32;
  if ((sub_1000D6870(a1, *(void *)(a2 + 32), *(void *)(a2 + 40)) & 1) != 0)
  {
    sub_1000D58F4(a1, *(void *)(a2 + 32), *(void *)(a2 + 40), buf);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    double v7 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, received geofence entry for an invalid fence, this should never happen... i gnoring, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    double v9 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      __int128 v10 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int128 v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v10;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring",  "{msg%{public}.0s:#LOI Manager, received geofence entry for an invalid fence, this should never happen... i gnoring, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
    }

    sub_1000D691C(a1, (uint64_t)@"Generic Failure", (uint64_t)@"Invalid Geofence Entry");
    uint64_t v11 = *(void *)(a1 + 16);
    if (*(char *)(v11 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v11 + 8), *(void *)(v11 + 16));
    }

    else
    {
      __int128 v12 = *(_OWORD *)(v11 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v11 + 24);
      *(_OWORD *)__int128 buf = v12;
    }
  }

  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000CE220( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

void *sub_1000CE260@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:LOI Manager: handle leeched location notification}",  buf,  0x12u);
  }

  [*(id *)(a2 + 32) coordinate];
  double v8 = v7;
  [*(id *)(a2 + 32) coordinate];
  if (sub_1000D63A4(a1, v8, v9))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int128 v10 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "LOI Manager, requested LOI for current visit location",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      v15[0] = 0;
      __int128 v14 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "LOI Manager, requested LOI for current visit location",  v15,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<std::string> CLMicroLocationLoiManager::HandleLeechedLocation(const CLMiLoLoiManagerLeechedLocationEvent *)",  "%s\n",  v14);
      if (v14 != buf) {
        free(v14);
      }
    }

    double result = sub_1010DDBC0(buf, "In the process of entering Home LOI");
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int128 v12 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Failed To request LOI for current visit location}",  buf,  0x12u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    __int128 v13 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Failed To request LOI for current visit location",  "{msg%{public}.0s:LOI Manager, Failed To request LOI for current visit location}",  buf,  0x12u);
    }

    double result = sub_1010DDBC0(buf, "Not in Active Location State");
  }

  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_1000CE5F4@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (*(_BYTE *)(a1 + 472))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      *(void *)double v9 = 68289026LL;
      *(_WORD *)&_BYTE v9[8] = 2082;
      *(void *)&v9[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:LOI Manager, refreshing location on XPC trigger}",  v9,  0x12u);
    }

    *(_DWORD *)(a1 + 480) = 5;
    *(_BYTE *)(a1 + 484) = 1;
    sub_1000D63A4(a1, *(double *)(a1 + 336), *(double *)(a1 + 344));
    sub_1010DDBC0(v9, "In the process of entering Home LOI");
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    int64_t v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      *(void *)double v9 = 68289026LL;
      *(_WORD *)&_BYTE v9[8] = 2082;
      *(void *)&v9[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:refreshRoutineStateAtLastLocation, won't run, last location not set}",  v9,  0x12u);
    }

    uint64_t v6 = *(void *)(a1 + 16);
    if (*(char *)(v6 + 31) < 0)
    {
      sub_1010DD48C(v9, *(void **)(v6 + 8), *(void *)(v6 + 16));
    }

    else
    {
      __int128 v7 = *(_OWORD *)(v6 + 8);
      *(void *)&v9[16] = *(void *)(v6 + 24);
      *(_OWORD *)double v9 = v7;
    }
  }

  double result = *(double *)v9;
  *(_OWORD *)a2 = *(_OWORD *)v9;
  *(void *)(a2 + 16) = *(void *)&v9[16];
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

double sub_1000CE7D4@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_DWORD *)(a1 + 480) = *(_DWORD *)(a2 + 32);
  *(_BYTE *)(a1 + 484) = 1;
  if (sub_1000D69E8(a1))
  {
    sub_1010DDBC0(&v8, "In the process of entering Home LOI");
    double result = *(double *)&v8;
    *(_OWORD *)a3 = v8;
    *(void *)(a3 + 16) = v9;
    *(_BYTE *)(a3 + 24) = 1;
  }

  else
  {
    if (*(_BYTE *)(a1 + 484)) {
      *(_BYTE *)(a1 + 484) = 0;
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (*(char *)(v6 + 31) < 0)
    {
      sub_1010DD48C(&v8, *(void **)(v6 + 8), *(void *)(v6 + 16));
    }

    else
    {
      __int128 v7 = *(_OWORD *)(v6 + 8);
      uint64_t v9 = *(void *)(v6 + 24);
      __int128 v8 = v7;
    }

    double result = *(double *)&v8;
    *(_OWORD *)a3 = v8;
    *(void *)(a3 + 16) = v9;
    *(_BYTE *)(a3 + 24) = 1;
  }

  return result;
}

double sub_1000CE894@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v6 = 68289026LL;
    *(_WORD *)&_WORD v6[8] = 2082;
    *(void *)&v6[10] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:LOI Manager: handleVisitExit}",  v6,  0x12u);
  }

  sub_1000D6770(a1, 2LL);
  sub_1010DDBC0(v6, "Not in Active Location State");
  double result = *(double *)v6;
  *(_OWORD *)a2 = *(_OWORD *)v6;
  *(void *)(a2 + 16) = *(void *)&v6[16];
  *(_BYTE *)(a2 + 24) = 1;
  return result;
}

double sub_1000CE9B0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#LOI Manager, In Home LOI, exit it before creating custom LOI process",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    v9[0] = 0;
    __int128 v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#LOI Manager, In Home LOI, exit it before creating custom LOI process",  v9,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<std::string> CLMicroLocationLoiManager::EnableCustomLoiWhileInHomeLoi(const CLMiLoLoiManagerEnableCustomLoiEvent *)",  "%s\n",  v8);
  }

  sub_1000D6770(a1, 9LL);
  sub_1000D5B78(a1, *(void *)(a2 + 32), *(void *)(a2 + 40), buf);
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = v11;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_1000CEB88@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = a2 + 32;
  if ((sub_1000D6870(a1, *(void *)(a2 + 32), *(void *)(a2 + 40)) & 1) != 0)
  {
    sub_1000D6770(a1, 10LL);
    sub_1000D58F4(a1, *(void *)(a2 + 32), *(void *)(a2 + 40), buf);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int128 v7 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, received geofence entry for an invalid fence, this should never happen... i gnoring, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    uint64_t v9 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      __int128 v10 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int128 v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v10;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring",  "{msg%{public}.0s:#LOI Manager, received geofence entry for an invalid fence, this should never happen... i gnoring, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
    }

    sub_1000D691C(a1, (uint64_t)@"Generic Failure", (uint64_t)@"Invalid Geofence Entry");
    uint64_t v11 = *(void *)(a1 + 16);
    if (*(char *)(v11 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v11 + 8), *(void *)(v11 + 16));
    }

    else
    {
      __int128 v12 = *(_OWORD *)(v11 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v11 + 24);
      *(_OWORD *)__int128 buf = v12;
    }
  }

  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000CEE94( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

double sub_1000CEED4@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (*(_DWORD *)(a2 + 32) == 3)
  {
    *(_DWORD *)(a1 + 480) = 3;
    *(_BYTE *)(a1 + 484) = 1;
    if (sub_1000D69E8(a1))
    {
      sub_1010DDBC0(&v8, "In the process of entering Home LOI");
      double result = *(double *)&v8;
      *(_OWORD *)a3 = v8;
      *(void *)(a3 + 16) = v9;
      *(_BYTE *)(a3 + 24) = 1;
      return result;
    }

    if (*(_BYTE *)(a1 + 484)) {
      *(_BYTE *)(a1 + 484) = 0;
    }
  }

  uint64_t v6 = *(void *)(a1 + 16);
  if (*(char *)(v6 + 31) < 0)
  {
    sub_1010DD48C(&v8, *(void **)(v6 + 8), *(void *)(v6 + 16));
  }

  else
  {
    __int128 v7 = *(_OWORD *)(v6 + 8);
    uint64_t v9 = *(void *)(v6 + 24);
    __int128 v8 = v7;
  }

  double result = *(double *)&v8;
  *(_OWORD *)a3 = v8;
  *(void *)(a3 + 16) = v9;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_1000CEFA0@<D0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v21 = *(_OWORD *)(a2 + 32);
  if ((sub_1000D6870((uint64_t)a1, v21, *((uint64_t *)&v21 + 1)) & 1) == 0)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v11 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, received geofence entry for an invalid fence, this should never happen... i gnoring, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    __int128 v13 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      __int128 v14 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int128 v14 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v14;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring",  "{msg%{public}.0s:#LOI Manager, received geofence entry for an invalid fence, this should never happen... i gnoring, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
    }

    sub_1000D691C((uint64_t)a1, (uint64_t)@"Generic Failure", (uint64_t)@"Invalid Geofence Exit");
    uint64_t v10 = a1[2];
LABEL_41:
    __int128 v15 = *(_OWORD *)(v10 + 8);
    *(void *)&uint8_t buf[16] = *(void *)(v10 + 24);
    *(_OWORD *)__int128 buf = v15;
    goto LABEL_52;
  }

  if (a1[49] != (void)v21 || a1[50] != *((void *)&v21 + 1))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      __int128 v7 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int128 v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, thi s may happen if we jumped from one geofence to another and the entry for the new geofence arrived first, reg ionID:%{private, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    __int128 v8 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      uint64_t v9 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v9 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v9;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v8,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, this may happen if we jump ed from one geofence to another and the entry for the new geofence arrived first",  "{msg%{public}.0s:#LOI Manager, got geofence exit for an LOI which is not the currently the active LOI, thi s may happen if we jumped from one geofence to another and the entry for the new geofence arrived first, reg ionID:%{private, location:escape_only}s}",  buf,  0x1Cu);
    }

    uint64_t v10 = a1[2];
    if (*(char *)(v10 + 31) < 0)
    {
LABEL_51:
      sub_1010DD48C(buf, *(void **)(v10 + 8), *(void *)(v10 + 16));
      goto LABEL_52;
    }

    goto LABEL_41;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  BOOL v16 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_100013090((uint64_t)&v21, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)__int128 buf = &off_101818CB0;
      sub_1000139B0((uint64_t)buf);
    }

    unsigned int v17 = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      unsigned int v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 buf = 68289283;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 2081;
    *(void *)&buf[20] = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LOI Manager, got geofence exit for active LOI, regionID:%{private, location:escape_only}s}",  buf,  0x1Cu);
  }

  sub_1000D6770((uint64_t)a1, 11LL);
  sub_1010DDBC0(buf, "Not in Active Location State");
LABEL_52:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000CF5F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

double sub_1000CF64C@<D0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v21 = *(_OWORD *)(a2 + 32);
  if ((sub_1000D6870((uint64_t)a1, v21, *((uint64_t *)&v21 + 1)) & 1) == 0)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    int64_t v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, received geofence entry for an invalid fence, this should never happen... i gnoring, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    __int128 v7 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      __int128 v8 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int128 v8 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v8;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, received geofence entry for an invalid fence, this should never happen... ignoring",  "{msg%{public}.0s:#LOI Manager, received geofence entry for an invalid fence, this should never happen... i gnoring, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
    }

    sub_1000D691C((uint64_t)a1, (uint64_t)@"Generic Failure", (uint64_t)@"Invalid Geofence Entry");
  }

  if (a1[49] == (void)v21 && a1[50] == *((void *)&v21 + 1))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int128 v12 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      __int128 v13 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int128 v13 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ign oring, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    __int128 v14 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      __int128 v15 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int128 v15 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v15;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v14,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ignoring",  "{msg%{public}.0s:#LOI Manager, got geofence entry for the current active LOI which shouldn't happen... ign oring, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v10 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)&v21, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      uint64_t v11 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LOI Manager, got geofence entry for different valid LOI, entering it, LOI ID:%{pri vate, location:escape_only}s}",  buf,  0x1Cu);
    }

    sub_1000D6770((uint64_t)a1, 11LL);
    sub_1000D5AC8((uint64_t)a1, v21, *((uint64_t *)&v21 + 1), 10LL);
  }

  uint64_t v16 = a1[2];
  if (*(char *)(v16 + 31) < 0)
  {
    sub_1010DD48C(buf, *(void **)(v16 + 8), *(void *)(v16 + 16));
  }

  else
  {
    __int128 v17 = *(_OWORD *)(v16 + 8);
    *(void *)&uint8_t buf[16] = *(void *)(v16 + 24);
    *(_OWORD *)__int128 buf = v17;
  }

  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000CFC78( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

double sub_1000CFCD0@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a1 + 16);
  if (*(char *)(v5 + 31) < 0)
  {
    sub_1010DD48C(&v8, *(void **)(v5 + 8), *(void *)(v5 + 16));
  }

  else
  {
    __int128 v6 = *(_OWORD *)(v5 + 8);
    uint64_t v9 = *(void *)(v5 + 24);
    __int128 v8 = v6;
  }

  double result = *(double *)&v8;
  *(_OWORD *)a3 = v8;
  *(void *)(a3 + 16) = v9;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_1000CFD70@<D0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  if (v12 < 0) {
    operator delete(__p);
  }
  BOOL v6 = a1[49] == a2[4] && a1[50] == a2[5];
  if (v6 && sub_1000D6320((uint64_t)a1, a2[4], a2[5]))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int128 v7 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LOI Manager, Since we are in the LOI exit LOI}",  buf,  0x12u);
    }

    sub_1000D6770((uint64_t)a1, 9LL);
    sub_1010DDBC0(buf, "Not in Active Location State");
  }

  else
  {
    uint64_t v8 = a1[2];
    if (*(char *)(v8 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v8 + 8), *(void *)(v8 + 16));
    }

    else
    {
      __int128 v9 = *(_OWORD *)(v8 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v8 + 24);
      *(_OWORD *)__int128 buf = v9;
    }
  }

  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_1000CFF08@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(void *)(a2 + 32);
  uint64_t v6 = *(void *)(a2 + 40);
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 4sub_10000AE14(v17 - 48) = *(void *)(a1 + 440);
  if (*(_BYTE *)(a1 + 484)) {
    *(_BYTE *)(a1 + 484) = 0;
  }
  sub_1000D5B78(a1, v5, v6, &v8);
  double result = *(double *)&v8;
  *(_OWORD *)a3 = v8;
  *(void *)(a3 + 16) = v9;
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

double sub_1000CFF98@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(_BYTE *)(a1 + 488))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int128 v15 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *(void *)(a1 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v16 + 8), *(void *)(v16 + 16));
      }

      else
      {
        __int128 v17 = *(_OWORD *)(v16 + 8);
        uint64_t v45 = *(void *)(v16 + 24);
        *(_OWORD *)std::string __dst = v17;
      }

      int v23 = SHIBYTE(v45);
      __int128 v24 = (void **)__dst[0];
      sub_10008D2C8((char *)a2, (uint64_t)__p);
      unint64_t v25 = __dst;
      if (v23 < 0) {
        unint64_t v25 = v24;
      }
      if (v43 >= 0) {
        char v26 = __p;
      }
      else {
        char v26 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v25;
      __int16 v47 = 2081;
      uint64_t v48 = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v43 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v45) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    unsigned __int8 v27 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      uint64_t v28 = *(void *)(a1 + 16);
      if (*(char *)(v28 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v28 + 8), *(void *)(v28 + 16));
      }

      else
      {
        __int128 v29 = *(_OWORD *)(v28 + 8);
        uint64_t v45 = *(void *)(v28 + 24);
        *(_OWORD *)std::string __dst = v29;
      }

      int v30 = SHIBYTE(v45);
      uint64_t v31 = (void **)__dst[0];
      sub_10008D2C8((char *)a2, (uint64_t)__p);
      uint64_t v32 = __dst;
      if (v30 < 0) {
        uint64_t v32 = v31;
      }
      if (v43 >= 0) {
        uint64_t v33 = __p;
      }
      else {
        uint64_t v33 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v32;
      __int16 v47 = 2081;
      uint64_t v48 = v33;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v27,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Got event when not expecting it",  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v43 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v45) < 0) {
        operator delete(__dst[0]);
      }
    }

    uint64_t v34 = *(void *)(a1 + 16);
    if (*(char *)(v34 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v34 + 8), *(void *)(v34 + 16));
      goto LABEL_80;
    }

    goto LABEL_78;
  }

  uint64_t v6 = *(void **)(a2 + 32);
  if (!v6)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    int v18 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "#LOIManager, Received nil object in eventData, this shouldn't happen",  buf,  2u);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_44;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    LOWORD(__dst[0]) = 0;
    int v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "#LOIManager, Received nil object in eventData, this shouldn't happen",  __dst,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "std::optional<std::string> CLMicroLocationLoiManager::LoiForGivenLocation(const CLMiLoLoiManagerReceivedLoiForLocationEvent *)",  "%s\n",  v19);
    goto LABEL_104;
  }

  if (![v6 loiIdentifier])
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    BOOL v20 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "LOI Manager, got nil LOI for current Location.. perhaps not in an LOI",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_44;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    LOWORD(__dst[0]) = 0;
    int v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "LOI Manager, got nil LOI for current Location.. perhaps not in an LOI",  __dst,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<std::string> CLMicroLocationLoiManager::LoiForGivenLocation(const CLMiLoLoiManagerReceivedLoiForLocationEvent *)",  "%s\n",  v19);
    goto LABEL_104;
  }

  sub_1000D6E8C((uint64_t)[*(id *)(a2 + 32) type], buf);
  __int128 v7 = (void **)(a1 + 368);
  *(_OWORD *)__int128 v7 = *(_OWORD *)buf;
  *(void *)(a1 + 384) = *(void *)&buf[16];
  __int128 v8 = (char *)objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a2 + 32), "loiIdentifier"), "UUIDString"), "UTF8String");
  size_t v9 = strlen(v8);
  *(void *)(a1 + 408) = sub_1000E20CC((uint64_t)buf, (unsigned __int8 *)v8, (unsigned __int8 *)&v8[v9]);
  *(void *)(a1 + 416) = v10;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v11 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    id v12 = objc_msgSend(objc_msgSend(*(id *)(a2 + 32), "loiIdentifier"), "description");
    __int128 v13 = (void **)(a1 + 368);
    *(_DWORD *)__int128 buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 2113;
    *(void *)&buf[20] = v12;
    __int16 v47 = 2081;
    uint64_t v48 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:LOI Manager, Retrieved location of interest, LOI ID:%{private, location:escape_only}@ , LOI TYPE:%{private, location:escape_only}s}",  buf,  0x26u);
  }

  int v14 = *(char *)(a1 + 391);
  if ((v14 & 0x80000000) == 0)
  {
    if (v14 != 4) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }

  if (*(void *)(a1 + 376) == 4LL)
  {
    __int128 v7 = (void **)*v7;
LABEL_38:
    if (*(_DWORD *)v7 != 1701670760) {
      goto LABEL_39;
    }
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int128 v37 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_INFO,  "LOI Manager, fetching related LOIs for LOI",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      LOWORD(__dst[0]) = 0;
      uint64_t v40 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  1LL,  "LOI Manager, fetching related LOIs for LOI",  __dst,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<std::string> CLMicroLocationLoiManager::LoiForGivenLocation(const CLMiLoLoiManagerReceivedLoiForLocationEvent *)",  "%s\n",  v40);
      if (v40 != buf) {
        free(v40);
      }
    }

    if (!sub_1000D7130(a1, (uint64_t)[*(id *)(a2 + 32) loiIdentifier]))
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      __int128 v38 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_ERROR,  "LOI Manager, Failed To request related LOIs",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_44;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      LOWORD(__dst[0]) = 0;
      LODWORD(v41) = 2;
      int v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "LOI Manager, Failed To request related LOIs",  __dst,  v41);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "std::optional<std::string> CLMicroLocationLoiManager::LoiForGivenLocation(const CLMiLoLoiManagerReceivedLoiForLocationEvent *)",  "%s\n",  v19);
      goto LABEL_104;
    }

    *(_WORD *)(a1 + 488) = 256;
    uint64_t v34 = *(void *)(a1 + 16);
    if (*(char *)(v34 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v34 + 8), *(void *)(v34 + 16));
      goto LABEL_80;
    }

void sub_1000D0B3C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000D0B64@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(_BYTE *)(a1 + 488))
  {
    sub_1000D691C(a1, (uint64_t)@"Home LOI Entry Failure", (uint64_t)@"LOI Fetch Failure");
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(void *)(a1 + 4sub_10000AE14(v17 - 48) = *(void *)(a1 + 440);
    if (*(_BYTE *)(a1 + 484)) {
      *(_BYTE *)(a1 + 484) = 0;
    }
    sub_1010DDBC0(buf, "Not in Active Location State");
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(a1 + 16);
      if (*(char *)(v7 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v7 + 8), *(void *)(v7 + 16));
      }

      else
      {
        __int128 v8 = *(_OWORD *)(v7 + 8);
        uint64_t v26 = *(void *)(v7 + 24);
        *(_OWORD *)std::string __dst = v8;
      }

      int v9 = SHIBYTE(v26);
      uint64_t v10 = (void **)__dst[0];
      sub_10008D2C8(a2, (uint64_t)__p);
      uint64_t v11 = __dst;
      if (v9 < 0) {
        uint64_t v11 = v10;
      }
      if (v24 >= 0) {
        id v12 = __p;
      }
      else {
        id v12 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v11;
      __int16 v28 = 2081;
      __int128 v29 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v26) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    __int128 v13 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      uint64_t v14 = *(void *)(a1 + 16);
      if (*(char *)(v14 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v14 + 8), *(void *)(v14 + 16));
      }

      else
      {
        __int128 v15 = *(_OWORD *)(v14 + 8);
        uint64_t v26 = *(void *)(v14 + 24);
        *(_OWORD *)std::string __dst = v15;
      }

      int v16 = SHIBYTE(v26);
      __int128 v17 = (void **)__dst[0];
      sub_10008D2C8(a2, (uint64_t)__p);
      int v18 = __dst;
      if (v16 < 0) {
        int v18 = v17;
      }
      if (v24 >= 0) {
        int v19 = __p;
      }
      else {
        int v19 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v18;
      __int16 v28 = 2081;
      __int128 v29 = v19;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Got event when not expecting it",  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v26) < 0) {
        operator delete(__dst[0]);
      }
    }

    uint64_t v20 = *(void *)(a1 + 16);
    if (*(char *)(v20 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v20 + 8), *(void *)(v20 + 16));
    }

    else
    {
      __int128 v21 = *(_OWORD *)(v20 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v20 + 24);
      *(_OWORD *)__int128 buf = v21;
    }
  }

  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000D0EC4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D0EEC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(_BYTE *)(a1 + 488))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    int v18 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = *(void *)(a1 + 16);
      if (*(char *)(v19 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v19 + 8), *(void *)(v19 + 16));
      }

      else
      {
        __int128 v20 = *(_OWORD *)(v19 + 8);
        uint64_t v47 = *(void *)(v19 + 24);
        *(_OWORD *)std::string __dst = v20;
      }

      int v27 = SHIBYTE(v47);
      __int16 v28 = (void **)__dst[0];
      sub_10008D2C8((char *)a2, (uint64_t)__p);
      __int128 v29 = __dst;
      if (v27 < 0) {
        __int128 v29 = v28;
      }
      if (v45 >= 0) {
        int v30 = __p;
      }
      else {
        int v30 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v29;
      __int16 v49 = 2081;
      uint64_t v50 = v30;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v45 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v47) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    uint64_t v31 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      uint64_t v32 = *(void *)(a1 + 16);
      if (*(char *)(v32 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v32 + 8), *(void *)(v32 + 16));
      }

      else
      {
        __int128 v33 = *(_OWORD *)(v32 + 8);
        uint64_t v47 = *(void *)(v32 + 24);
        *(_OWORD *)std::string __dst = v33;
      }

      int v34 = SHIBYTE(v47);
      __int128 v35 = (void **)__dst[0];
      sub_10008D2C8((char *)a2, (uint64_t)__p);
      uint64_t v36 = __dst;
      if (v34 < 0) {
        uint64_t v36 = v35;
      }
      if (v45 >= 0) {
        __int128 v37 = __p;
      }
      else {
        __int128 v37 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v36;
      __int16 v49 = 2081;
      uint64_t v50 = v37;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v31,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Got event when not expecting it",  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v45 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v47) < 0) {
        operator delete(__dst[0]);
      }
    }

    uint64_t v26 = *(void *)(a1 + 16);
    if (*(char *)(v26 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v26 + 8), *(void *)(v26 + 16));
      goto LABEL_81;
    }

    goto LABEL_79;
  }

  if ([*(id *)(a2 + 32) _loiIdentifier])
  {
    objc_msgSend(objc_msgSend(*(id *)(a2 + 32), "referenceLocation"), "coordinate");
    double v7 = v6;
    objc_msgSend(objc_msgSend(*(id *)(a2 + 32), "referenceLocation"), "coordinate");
    sub_1000D7224(a1, v7, v8);
    sub_1000D7290((uint64_t)[*(id *)(a2 + 32) userType], buf);
    int v9 = (void **)(a1 + 368);
    *(_OWORD *)int v9 = *(_OWORD *)buf;
    *(void *)(a1 + 384) = *(void *)&buf[16];
    uint64_t v10 = (char *)objc_msgSend( objc_msgSend(objc_msgSend(*(id *)(a2 + 32), "_loiIdentifier"), "UUIDString"),  "UTF8String");
    size_t v11 = strlen(v10);
    *(void *)(a1 + 408) = sub_1000E20CC((uint64_t)buf, (unsigned __int8 *)v10, (unsigned __int8 *)&v10[v11]);
    *(void *)(a1 + 416) = v12;
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int128 v13 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      id v14 = objc_msgSend(objc_msgSend(objc_msgSend(*(id *)(a2 + 32), "_loiIdentifier"), "UUIDString"), "UTF8String");
      __int128 v15 = (void **)(a1 + 368);
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v14;
      __int16 v49 = 2081;
      uint64_t v50 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:LOI Manager, Retrieved place infernce, LOI ID:%{private, location:escape_only}s,  LOI TYPE:%{private, location:escape_only}s}",  buf,  0x26u);
    }

    int v16 = *(char *)(a1 + 391);
    if (v16 < 0)
    {
      if (*(void *)(a1 + 376) != 4LL)
      {
LABEL_32:
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181EA08);
        }
        int v23 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "LOI Manager, Not a Home LOI", buf, 2u);
        }

        if (!sub_1002921D0(115, 2)) {
          goto LABEL_37;
        }
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181EA08);
        }
        LOWORD(__dst[0]) = 0;
        uint64_t v40 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  1LL,  "LOI Manager, Not a Home LOI",  __dst,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManager FetchedPlaceInference *)",  "%s\n",  v40);
LABEL_97:
        if (v40 != buf) {
          free(v40);
        }
LABEL_37:
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181EA08);
        }
        char v24 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_INFO,  "LOI Manager, Returning to Inactive Location State",  buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181EA08);
          }
          LOWORD(__dst[0]) = 0;
          LODWORD(v43) = 2;
          uint64_t v41 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  1LL,  "LOI Manager, Returning to Inactive Location State",  __dst,  v43);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManag erFetchedPlaceInference *)",  "%s\n",  v41);
          if (v41 != buf) {
            free(v41);
          }
        }

        std::string::assign((std::string *)(a1 + 368), "unknown");
        *(_OWORD *)(a1 + 392) = 0u;
        *(_OWORD *)(a1 + 408) = 0u;
        *(void *)(a1 + 4sub_10000AE14(v17 - 48) = *(void *)(a1 + 440);
        if (*(_BYTE *)(a1 + 484)) {
          *(_BYTE *)(a1 + 484) = 0;
        }
        (*(void (**)(void))(**(void **)(a1 + 328) + 32LL))(*(void *)(a1 + 328));
        sub_1010DDBC0(buf, "Not in Active Location State");
        goto LABEL_81;
      }

      __int128 v17 = *v9;
    }

    else
    {
      __int128 v17 = (_DWORD *)(a1 + 368);
      if (v16 != 4) {
        goto LABEL_32;
      }
    }

    if (*v17 != 1701670760) {
      goto LABEL_32;
    }
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    unint64_t v25 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_INFO,  "LOI Manager, fetching related LOIs for LOI",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      LOWORD(__dst[0]) = 0;
      BOOL v42 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  1LL,  "LOI Manager, fetching related LOIs for LOI",  __dst,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFe tchedPlaceInference *)",  "%s\n",  v42);
      if (v42 != buf) {
        free(v42);
      }
    }

    if (!sub_1000D7130(a1, (uint64_t)[*(id *)(a2 + 32) _loiIdentifier]))
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      unint64_t v39 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_ERROR,  "LOI Manager, Failed To request related LOIs",  buf,  2u);
      }

      if (!sub_1002921D0(115, 0)) {
        goto LABEL_37;
      }
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      LOWORD(__dst[0]) = 0;
      LODWORD(v43) = 2;
      uint64_t v40 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "LOI Manager, Failed To request related LOIs",  __dst,  v43);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "std::optional<std::string> CLMicroLocationLoiManager::SuccessfullyFetchedPlaceInference(const CLMiLoLoiManagerFe tchedPlaceInference *)",  "%s\n",  v40);
      goto LABEL_97;
    }

    *(_WORD *)(a1 + 488) = 256;
    uint64_t v26 = *(void *)(a1 + 16);
    if (*(char *)(v26 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v26 + 8), *(void *)(v26 + 16));
      goto LABEL_81;
    }

void sub_1000D1A10( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000D1A38@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  double v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_INFO,  "LOI Manager, Failed To fetch place inferences",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    LOWORD(__dst[0]) = 0;
    char v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  1LL,  "LOI Manager, Failed To fetch place inferences",  __dst,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<std::string> CLMicroLocationLoiManager::FailedToFetchedPlaceInference(const CLMiLoLoiManagerFailedTo FetchPlaceInference *)",  "%s\n",  v24);
    if (v24 != buf) {
      free(v24);
    }
  }

  if (*(_BYTE *)(a1 + 488))
  {
    sub_1000D691C(a1, (uint64_t)@"Home LOI Entry Failure", (uint64_t)@"Place Inference Fetch Failure");
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(void *)(a1 + 4sub_10000AE14(v17 - 48) = *(void *)(a1 + 440);
    if (*(_BYTE *)(a1 + 484)) {
      *(_BYTE *)(a1 + 484) = 0;
    }
    (*(void (**)(void))(**(void **)(a1 + 328) + 32LL))(*(void *)(a1 + 328));
    sub_1010DDBC0(buf, "Not in Active Location State");
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    double v7 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *(void *)(a1 + 16);
      if (*(char *)(v8 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v8 + 8), *(void *)(v8 + 16));
      }

      else
      {
        __int128 v9 = *(_OWORD *)(v8 + 8);
        uint64_t v28 = *(void *)(v8 + 24);
        *(_OWORD *)std::string __dst = v9;
      }

      int v10 = SHIBYTE(v28);
      size_t v11 = (void **)__dst[0];
      sub_10008D2C8(a2, (uint64_t)__p);
      uint64_t v12 = __dst;
      if (v10 < 0) {
        uint64_t v12 = v11;
      }
      if (v26 >= 0) {
        __int128 v13 = __p;
      }
      else {
        __int128 v13 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v12;
      __int16 v30 = 2081;
      uint64_t v31 = v13;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    id v14 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      uint64_t v15 = *(void *)(a1 + 16);
      if (*(char *)(v15 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v15 + 8), *(void *)(v15 + 16));
      }

      else
      {
        __int128 v16 = *(_OWORD *)(v15 + 8);
        uint64_t v28 = *(void *)(v15 + 24);
        *(_OWORD *)std::string __dst = v16;
      }

      int v17 = SHIBYTE(v28);
      int v18 = (void **)__dst[0];
      sub_10008D2C8(a2, (uint64_t)__p);
      uint64_t v19 = __dst;
      if (v17 < 0) {
        uint64_t v19 = v18;
      }
      if (v26 >= 0) {
        __int128 v20 = __p;
      }
      else {
        __int128 v20 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v19;
      __int16 v30 = 2081;
      uint64_t v31 = v20;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v14,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Got event when not expecting it",  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
    }

    uint64_t v21 = *(void *)(a1 + 16);
    if (*(char *)(v21 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v21 + 8), *(void *)(v21 + 16));
    }

    else
    {
      __int128 v22 = *(_OWORD *)(v21 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v21 + 24);
      *(_OWORD *)__int128 buf = v22;
    }
  }

  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000D1ED0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000D1EF8@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(_BYTE *)(a1 + 489))
  {
    double v6 = (_OWORD *)(a1 + 368);
    *(void *)(a1 + 392) = (*(uint64_t (**)(void, uint64_t, uint64_t, char *))(**(void **)(a1 + 328) + 24LL))( *(void *)(a1 + 328),  a1 + 368,  a1 + 408,  a2 + 32);
    *(void *)(a1 + 400) = v7;
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v8 = (_OWORD *)(a1 + 392);
    __int128 v9 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090(a1 + 392, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:LOI Manager, Fetched LOI Group ID, LOI Group ID :%{private, location:escape_only}s}",  buf,  0x1Cu);
    }

    if (*(_BYTE *)v8)
    {
LABEL_11:
      (*(void (**)(void))(**(void **)(a1 + 328) + 40LL))(*(void *)(a1 + 328));
      if (*(_BYTE *)(a1 + 484))
      {
        uint64_t v11 = *(unsigned int *)(a1 + 480);
        *(_BYTE *)(a1 + 484) = 0;
      }

      else
      {
        uint64_t v11 = 1LL;
      }

      uint64_t v17 = *(void *)(a1 + 328);
      if (*(char *)(a1 + 391) < 0)
      {
        sub_1010DD48C(v32, *(void **)(a1 + 368), *(void *)(a1 + 376));
      }

      else
      {
        *(_OWORD *)uint64_t v32 = *v6;
        uint64_t v33 = *(void *)(a1 + 384);
      }

      (*(void (**)(uint64_t, void **, void, void, uint64_t))(*(void *)v17 + 16LL))( v17,  v32,  *(void *)(a1 + 392),  *(void *)(a1 + 400),  v11);
      if (SHIBYTE(v33) < 0) {
        operator delete(v32[0]);
      }
      sub_1010DDBC0(buf, "In Home LOI State");
    }

    else
    {
      uint64_t v15 = 0LL;
      while (v15 != 15)
      {
        if (*(unsigned __int8 *)(a1 + 393 + v15++))
        {
          break;
        }
      }

      std::string::assign((std::string *)(a1 + 368), "unknown");
      *uint64_t v8 = 0u;
      *(_OWORD *)(a1 + 408) = 0u;
      *(void *)(a1 + 4sub_10000AE14(v17 - 48) = *(void *)(a1 + 440);
      if (*(_BYTE *)(a1 + 484)) {
        *(_BYTE *)(a1 + 484) = 0;
      }
      sub_1010DDBC0(buf, "Not in Active Location State");
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v12 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = *(void *)(a1 + 16);
      if (*(char *)(v13 + 31) < 0)
      {
        sub_1010DD48C(&__p, *(void **)(v13 + 8), *(void *)(v13 + 16));
      }

      else
      {
        __int128 v14 = *(_OWORD *)(v13 + 8);
        __p.__r_.__value_.__l.__cap_ = *(void *)(v13 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v14;
      }

      int size = (char)__p.__r_.__value_.__s.__size_;
      std::string::size_type v19 = __p.__r_.__value_.__r.__words[0];
      sub_10008D2C8(a2, (uint64_t)v34);
      __int128 v20 = &__p;
      if (size < 0) {
        __int128 v20 = (std::string *)v19;
      }
      if (v35 >= 0) {
        uint64_t v21 = v34;
      }
      else {
        uint64_t v21 = (void **)v34[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v38 = 2081;
      unint64_t v39 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v35 < 0) {
        operator delete(v34[0]);
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    __int128 v22 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      uint64_t v23 = *(void *)(a1 + 16);
      if (*(char *)(v23 + 31) < 0)
      {
        sub_1010DD48C(&__p, *(void **)(v23 + 8), *(void *)(v23 + 16));
      }

      else
      {
        __int128 v24 = *(_OWORD *)(v23 + 8);
        __p.__r_.__value_.__l.__cap_ = *(void *)(v23 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v24;
      }

      int v25 = (char)__p.__r_.__value_.__s.__size_;
      std::string::size_type v26 = __p.__r_.__value_.__r.__words[0];
      sub_10008D2C8(a2, (uint64_t)v34);
      int v27 = &__p;
      if (v25 < 0) {
        int v27 = (std::string *)v26;
      }
      if (v35 >= 0) {
        uint64_t v28 = v34;
      }
      else {
        uint64_t v28 = (void **)v34[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v27;
      __int16 v38 = 2081;
      unint64_t v39 = v28;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v22,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Got event when not expecting it",  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v35 < 0) {
        operator delete(v34[0]);
      }
    }

    uint64_t v29 = *(void *)(a1 + 16);
    if (*(char *)(v29 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v29 + 8), *(void *)(v29 + 16));
    }

    else
    {
      __int128 v30 = *(_OWORD *)(v29 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v29 + 24);
      *(_OWORD *)__int128 buf = v30;
    }
  }

  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000D2430( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, std::bad_cast a25)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000D2480@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (*(_BYTE *)(a1 + 489))
  {
    sub_1000D691C(a1, (uint64_t)@"Home LOI Entry Failure", (uint64_t)@"Related LOI Fetch Failure");
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(void *)(a1 + 4sub_10000AE14(v17 - 48) = *(void *)(a1 + 440);
    if (*(_BYTE *)(a1 + 484)) {
      *(_BYTE *)(a1 + 484) = 0;
    }
    sub_1010DDBC0(buf, "Not in Active Location State");
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    double v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(a1 + 16);
      if (*(char *)(v7 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v7 + 8), *(void *)(v7 + 16));
      }

      else
      {
        __int128 v8 = *(_OWORD *)(v7 + 8);
        uint64_t v26 = *(void *)(v7 + 24);
        *(_OWORD *)std::string __dst = v8;
      }

      int v9 = SHIBYTE(v26);
      int v10 = (void **)__dst[0];
      sub_10008D2C8(a2, (uint64_t)__p);
      uint64_t v11 = __dst;
      if (v9 < 0) {
        uint64_t v11 = v10;
      }
      if (v24 >= 0) {
        uint64_t v12 = __p;
      }
      else {
        uint64_t v12 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v11;
      __int16 v28 = 2081;
      uint64_t v29 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v26) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    uint64_t v13 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      uint64_t v14 = *(void *)(a1 + 16);
      if (*(char *)(v14 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v14 + 8), *(void *)(v14 + 16));
      }

      else
      {
        __int128 v15 = *(_OWORD *)(v14 + 8);
        uint64_t v26 = *(void *)(v14 + 24);
        *(_OWORD *)std::string __dst = v15;
      }

      int v16 = SHIBYTE(v26);
      uint64_t v17 = (void **)__dst[0];
      sub_10008D2C8(a2, (uint64_t)__p);
      int v18 = __dst;
      if (v16 < 0) {
        int v18 = v17;
      }
      if (v24 >= 0) {
        std::string::size_type v19 = __p;
      }
      else {
        std::string::size_type v19 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v18;
      __int16 v28 = 2081;
      uint64_t v29 = v19;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Got event when not expecting it",  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v24 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v26) < 0) {
        operator delete(__dst[0]);
      }
    }

    uint64_t v20 = *(void *)(a1 + 16);
    if (*(char *)(v20 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v20 + 8), *(void *)(v20 + 16));
    }

    else
    {
      __int128 v21 = *(_OWORD *)(v20 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v20 + 24);
      *(_OWORD *)__int128 buf = v21;
    }
  }

  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000D27E0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000D2808@<D0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v6 = (__int128 *)a1[55];
  uint64_t v7 = (__int128 *)a1[56];
  if (v6 == v7)
  {
LABEL_8:
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    int v10 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090(a2 + 32, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:LOI Manager, Adding new service to list of servies that have requested to enable custom L OI, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
    }

    uint64_t v12 = (_OWORD *)(a2 + 32);
    uint64_t v14 = (_OWORD *)a1[56];
    unint64_t v13 = a1[57];
    if ((unint64_t)v14 >= v13)
    {
      uint64_t v16 = a1[55];
      uint64_t v17 = ((uint64_t)v14 - v16) >> 4;
      unint64_t v18 = v17 + 1;
      uint64_t v19 = v13 - v16;
      if (v19 >> 3 > v18) {
        unint64_t v18 = v19 >> 3;
      }
      else {
        unint64_t v20 = v18;
      }
      if (v20) {
        __int128 v21 = (char *)sub_100037038((uint64_t)(a1 + 57), v20);
      }
      else {
        __int128 v21 = 0LL;
      }
      int v27 = &v21[16 * v17];
      __int16 v28 = &v21[16 * v20];
      *(_OWORD *)int v27 = *v12;
      __int128 v15 = v27 + 16;
      __int128 v30 = (char *)a1[55];
      uint64_t v29 = (char *)a1[56];
      if (v29 != v30)
      {
        do
        {
          *((_OWORD *)v27 - 1) = *((_OWORD *)v29 - 1);
          v27 -= 16;
          v29 -= 16;
        }

        while (v29 != v30);
        uint64_t v29 = (char *)a1[55];
      }

      a1[55] = v27;
      a1[56] = v15;
      a1[57] = v28;
      if (v29) {
        operator delete(v29);
      }
    }

    else
    {
      _OWORD *v14 = *v12;
      __int128 v15 = v14 + 1;
    }

    a1[56] = v15;
    uint64_t v26 = a1[2];
    if (*(char *)(v26 + 31) < 0)
    {
LABEL_52:
      sub_1010DD48C(buf, *(void **)(v26 + 8), *(void *)(v26 + 16));
      goto LABEL_53;
    }
  }

  else
  {
    __int128 v8 = (void *)(a2 + 32);
    while (1)
    {
      __int128 v35 = *v6;
      if ((void)v35 == *v8 && *((void *)&v35 + 1) == *(void *)(a2 + 40)) {
        break;
      }
      if (++v6 == v7) {
        goto LABEL_8;
      }
    }

    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int128 v22 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)v8, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      uint64_t v23 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, got enable custom LOI request from the same service, ignoring, LOI ID :%{private, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    char v24 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)v8, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      int v25 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v25 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v25;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v24,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, got enable custom LOI request from the same service, ignoring",  "{msg%{public}.0s:#LOI Manager, got enable custom LOI request from the same service, ignoring, LOI ID :%{private, location:escape_only}s}",  buf,  0x1Cu);
    }

    uint64_t v26 = a1[2];
  }

  __int128 v31 = *(_OWORD *)(v26 + 8);
  *(void *)&uint8_t buf[16] = *(void *)(v26 + 24);
  *(_OWORD *)__int128 buf = v31;
LABEL_53:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000D2CF8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

double sub_1000D2D40@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v24 = *(_OWORD *)(a2 + 32);
  if ((void)v24 == *(void *)(a1 + 408) && *((void *)&v24 + 1) == *(void *)(a1 + 416))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v11 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090((uint64_t)&v24, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LOI Manager, got geofence entry for LOI, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
    }

    sub_1000D7530(a1);
    unint64_t v13 = *(_OWORD **)(a1 + 440);
    uint64_t v14 = *(_OWORD **)(a1 + 448);
    while (v13 != v14)
    {
      *(_OWORD *)__int128 buf = *v13;
      sub_1000D6C4C(a1, v24, *((uint64_t *)&v24 + 1), (uint64_t)buf);
      ++v13;
    }

    uint64_t v15 = -1LL;
  }

  else
  {
    uint64_t v6 = a1 + 408;
    if (*(_BYTE *)(a1 + 408))
    {
LABEL_6:
      memset(&__p, 0, sizeof(__p));
      if ((sub_100013090(v6, &__p) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)buf);
        *(void *)__int128 buf = &off_101818CB0;
        sub_1000139B0((uint64_t)buf);
      }

      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v7 = &__p;
      }
      else {
        uint64_t v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      __int128 v8 = -[NSString uppercaseString]( +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v7),  "uppercaseString");
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = &__p;
        if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          int v10 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)__int128 buf = 68289283;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2081;
        *(void *)&buf[20] = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LOI Manager, Disabling geofence that we were trying to enable for custom LOI since we are failing the request, loiID:%{private, location:escape_only}s}",  buf,  0x1Cu);
      }

      [*(id *)(a1 + 320) removeGeofenceWithRegionId:v8];
    }

    else
    {
      unint64_t v16 = 0LL;
      while (v16 != 15)
      {
        unint64_t v17 = v16;
        if (*(unsigned __int8 *)(a1 + 409 + v16++))
        {
          if (v17 <= 0xE) {
            goto LABEL_6;
          }
          break;
        }
      }
    }

    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v19 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, Error: tried to enable custom LOI at an active custom LOI}",  buf,  0x12u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    unint64_t v20 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, Error: tried to enable custom LOI at an active custom LOI",  "{msg%{public}.0s:#LOI Manager, Error: tried to enable custom LOI at an active custom LOI}",  buf,  0x12u);
    }

    uint64_t v15 = 35LL;
  }

  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 4sub_10000AE14(v17 - 48) = *(void *)(a1 + 440);
  if (*(_BYTE *)(a1 + 484)) {
    *(_BYTE *)(a1 + 484) = 0;
  }
  sub_1000D5AC8(a1, v24, *((uint64_t *)&v24 + 1), 10LL);
  (***(void (****)(void, uint64_t))(a1 + 328))(*(void *)(a1 + 328), v15);
  sub_1010DDBC0(buf, "In Custom LOI State");
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000D3204( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

double sub_1000D3244@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(_BYTE *)(a1 + 490))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v15 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *(void *)(a1 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v16 + 8), *(void *)(v16 + 16));
      }

      else
      {
        __int128 v17 = *(_OWORD *)(v16 + 8);
        uint64_t v34 = *(void *)(v16 + 24);
        *(_OWORD *)std::string __dst = v17;
      }

      int v18 = SHIBYTE(v34);
      uint64_t v19 = (void **)__dst[0];
      sub_10008D2C8((char *)a2, (uint64_t)__p);
      unint64_t v20 = __dst;
      if (v18 < 0) {
        unint64_t v20 = v19;
      }
      if (v32 >= 0) {
        __int128 v21 = __p;
      }
      else {
        __int128 v21 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v36 = 2081;
      __int128 v37 = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v32 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v34) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    __int128 v22 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      uint64_t v23 = *(void *)(a1 + 16);
      if (*(char *)(v23 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v23 + 8), *(void *)(v23 + 16));
      }

      else
      {
        __int128 v24 = *(_OWORD *)(v23 + 8);
        uint64_t v34 = *(void *)(v23 + 24);
        *(_OWORD *)std::string __dst = v24;
      }

      int v25 = SHIBYTE(v34);
      uint64_t v26 = (void **)__dst[0];
      sub_10008D2C8((char *)a2, (uint64_t)__p);
      int v27 = __dst;
      if (v25 < 0) {
        int v27 = v26;
      }
      if (v32 >= 0) {
        __int16 v28 = __p;
      }
      else {
        __int16 v28 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v27;
      __int16 v36 = 2081;
      __int128 v37 = v28;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v22,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Got event when not expecting it",  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v32 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v34) < 0) {
        operator delete(__dst[0]);
      }
    }

    uint64_t v14 = *(void *)(a1 + 16);
    if (*(char *)(v14 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v14 + 8), *(void *)(v14 + 16));
      goto LABEL_40;
    }

    goto LABEL_39;
  }

  uint64_t v6 = *(void **)(a2 + 32);
  [v6 coordinate];
  *(void *)(a1 + 336) = v7;
  [v6 coordinate];
  *(void *)(a1 + 344) = v8;
  objc_msgSend(*(id *)(a1 + 320), "removeGeofencesNearLocationWithLatitude:andLongitude:", *(double *)(a1 + 336));
  [v6 horizontalAccuracy];
  *(void *)(a1 + 352) = v9;
  [v6 verticalAccuracy];
  *(void *)(a1 + 360) = v10;
  *(void *)(a1 + 408) = 0LL;
  *(void *)(a1 + 416) = 0LL;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v11 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(a1 + 336);
    unint64_t v13 = *(void ***)(a1 + 344);
    *(_DWORD *)__int128 buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 2049;
    *(void *)&buf[20] = v12;
    __int16 v36 = 2049;
    __int128 v37 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LOI Manager, got location update to enable custom geofence, latitude:%{private}7f , longitude:%{private}7f}",  buf,  0x26u);
  }

  [*(id *)(a1 + 320) setGeofenceAtLocation:v6];
  *(_WORD *)(a1 + 490) = 256;
  uint64_t v14 = *(void *)(a1 + 16);
  if ((*(char *)(v14 + 31) & 0x80000000) == 0)
  {
LABEL_39:
    __int128 v29 = *(_OWORD *)(v14 + 8);
    *(void *)&uint8_t buf[16] = *(void *)(v14 + 24);
    *(_OWORD *)__int128 buf = v29;
    goto LABEL_40;
  }

  sub_1010DD48C(buf, *(void **)(v14 + 8), *(void *)(v14 + 16));
LABEL_40:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000D3654( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000D367C@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, failed to get current location to enable MiLo... aborting request}",  buf,  0x12u);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  uint64_t v7 = (os_log_s *)qword_1019348D8;
  if (os_signpost_enabled((os_log_t)qword_1019348D8))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, failed to get current location to enable MiLo... aborting request",  "{msg%{public}.0s:#LOI Manager, failed to get current location to enable MiLo... aborting request}",  buf,  0x12u);
  }

  if (*(_BYTE *)(a1 + 490))
  {
    sub_1000D691C(a1, (uint64_t)@"Custom LOI Entry Failure", (uint64_t)@"Failed to get current Location");
    (***(void (****)(void, uint64_t))(a1 + 328))(*(void *)(a1 + 328), 35LL);
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(void *)(a1 + 4sub_10000AE14(v17 - 48) = *(void *)(a1 + 440);
    if (*(_BYTE *)(a1 + 484)) {
      *(_BYTE *)(a1 + 484) = 0;
    }
    sub_1010DDBC0(buf, "Not in Active Location State");
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v8 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *(void *)(a1 + 16);
      if (*(char *)(v9 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v9 + 8), *(void *)(v9 + 16));
      }

      else
      {
        __int128 v10 = *(_OWORD *)(v9 + 8);
        uint64_t v28 = *(void *)(v9 + 24);
        *(_OWORD *)std::string __dst = v10;
      }

      int v11 = SHIBYTE(v28);
      uint64_t v12 = (void **)__dst[0];
      sub_10008D2C8(a2, (uint64_t)__p);
      unint64_t v13 = __dst;
      if (v11 < 0) {
        unint64_t v13 = v12;
      }
      if (v26 >= 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v13;
      __int16 v30 = 2081;
      __int128 v31 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    uint64_t v15 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      uint64_t v16 = *(void *)(a1 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v16 + 8), *(void *)(v16 + 16));
      }

      else
      {
        __int128 v17 = *(_OWORD *)(v16 + 8);
        uint64_t v28 = *(void *)(v16 + 24);
        *(_OWORD *)std::string __dst = v17;
      }

      int v18 = SHIBYTE(v28);
      uint64_t v19 = (void **)__dst[0];
      sub_10008D2C8(a2, (uint64_t)__p);
      unint64_t v20 = __dst;
      if (v18 < 0) {
        unint64_t v20 = v19;
      }
      if (v26 >= 0) {
        __int128 v21 = __p;
      }
      else {
        __int128 v21 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v30 = 2081;
      __int128 v31 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Got event when not expecting it",  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
    }

    uint64_t v22 = *(void *)(a1 + 16);
    if (*(char *)(v22 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v22 + 8), *(void *)(v22 + 16));
    }

    else
    {
      __int128 v23 = *(_OWORD *)(v22 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v22 + 24);
      *(_OWORD *)__int128 buf = v23;
    }
  }

  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000D3AFC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000D3B24@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(_BYTE *)(a1 + 491))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v9 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = *(void *)(a1 + 16);
      if (*(char *)(v10 + 31) < 0)
      {
        sub_1010DD48C(&__p, *(void **)(v10 + 8), *(void *)(v10 + 16));
      }

      else
      {
        __int128 v11 = *(_OWORD *)(v10 + 8);
        __p.__r_.__value_.__l.__cap_ = *(void *)(v10 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v11;
      }

      int size = (char)__p.__r_.__value_.__s.__size_;
      std::string::size_type v13 = __p.__r_.__value_.__r.__words[0];
      sub_10008D2C8((char *)a2, (uint64_t)v25);
      p_p = &__p;
      if (size < 0) {
        p_p = (std::string *)v13;
      }
      if (v26 >= 0) {
        uint64_t v15 = v25;
      }
      else {
        uint64_t v15 = (void **)v25[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = p_p;
      __int16 v29 = 2081;
      __int16 v30 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v26 < 0) {
        operator delete(v25[0]);
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    uint64_t v16 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      uint64_t v17 = *(void *)(a1 + 16);
      if (*(char *)(v17 + 31) < 0)
      {
        sub_1010DD48C(&__p, *(void **)(v17 + 8), *(void *)(v17 + 16));
      }

      else
      {
        __int128 v18 = *(_OWORD *)(v17 + 8);
        __p.__r_.__value_.__l.__cap_ = *(void *)(v17 + 24);
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v18;
      }

      int v19 = (char)__p.__r_.__value_.__s.__size_;
      std::string::size_type v20 = __p.__r_.__value_.__r.__words[0];
      sub_10008D2C8((char *)a2, (uint64_t)v25);
      __int128 v21 = &__p;
      if (v19 < 0) {
        __int128 v21 = (std::string *)v20;
      }
      if (v26 >= 0) {
        uint64_t v22 = v25;
      }
      else {
        uint64_t v22 = (void **)v25[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v21;
      __int16 v29 = 2081;
      __int16 v30 = v22;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Got event when not expecting it",  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v26 < 0) {
        operator delete(v25[0]);
      }
    }

    uint64_t v8 = *(void *)(a1 + 16);
    if (*(char *)(v8 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v8 + 8), *(void *)(v8 + 16));
      goto LABEL_44;
    }

    goto LABEL_43;
  }

  *(_OWORD *)(a1 + 408) = *(_OWORD *)(a2 + 32);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_100013090(a1 + 408, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)__int128 buf = &off_101818CB0;
      sub_1000139B0((uint64_t)buf);
    }

    uint64_t v7 = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      uint64_t v7 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 buf = 68289283;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 2081;
    *(void *)&buf[20] = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LOI Manager, successfully set geofence, now waiting on fence entry update, geofenceId :%{private, location:escape_only}s}",  buf,  0x1Cu);
  }

  uint64_t v8 = *(void *)(a1 + 16);
  if ((*(char *)(v8 + 31) & 0x80000000) == 0)
  {
LABEL_43:
    __int128 v23 = *(_OWORD *)(v8 + 8);
    *(void *)&uint8_t buf[16] = *(void *)(v8 + 24);
    *(_OWORD *)__int128 buf = v23;
    goto LABEL_44;
  }

  sub_1010DD48C(buf, *(void **)(v8 + 8), *(void *)(v8 + 16));
LABEL_44:
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000D3F58( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, std::bad_cast a20)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000D3F94@<D0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request}",  buf,  0x12u);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  uint64_t v7 = (os_log_s *)qword_1019348D8;
  if (os_signpost_enabled((os_log_t)qword_1019348D8))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request",  "{msg%{public}.0s:#LOI Manager, failed to set geofence at current location to enable MiLo, failing custom loi request}",  buf,  0x12u);
  }

  if (*(_BYTE *)(a1 + 491))
  {
    sub_1000D691C(a1, (uint64_t)@"Custom LOI Entry Failure", (uint64_t)@"Failed to set geofence");
    (***(void (****)(void, uint64_t))(a1 + 328))(*(void *)(a1 + 328), 35LL);
    std::string::assign((std::string *)(a1 + 368), "unknown");
    *(_OWORD *)(a1 + 392) = 0u;
    *(_OWORD *)(a1 + 408) = 0u;
    *(void *)(a1 + 4sub_10000AE14(v17 - 48) = *(void *)(a1 + 440);
    if (*(_BYTE *)(a1 + 484)) {
      *(_BYTE *)(a1 + 484) = 0;
    }
    sub_1010DDBC0(buf, "Not in Active Location State");
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v8 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *(void *)(a1 + 16);
      if (*(char *)(v9 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v9 + 8), *(void *)(v9 + 16));
      }

      else
      {
        __int128 v10 = *(_OWORD *)(v9 + 8);
        uint64_t v28 = *(void *)(v9 + 24);
        *(_OWORD *)std::string __dst = v10;
      }

      int v11 = SHIBYTE(v28);
      uint64_t v12 = (void **)__dst[0];
      sub_10008D2C8(a2, (uint64_t)__p);
      std::string::size_type v13 = __dst;
      if (v11 < 0) {
        std::string::size_type v13 = v12;
      }
      if (v26 >= 0) {
        uint64_t v14 = __p;
      }
      else {
        uint64_t v14 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v13;
      __int16 v30 = 2081;
      __int128 v31 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    uint64_t v15 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      uint64_t v16 = *(void *)(a1 + 16);
      if (*(char *)(v16 + 31) < 0)
      {
        sub_1010DD48C(__dst, *(void **)(v16 + 8), *(void *)(v16 + 16));
      }

      else
      {
        __int128 v17 = *(_OWORD *)(v16 + 8);
        uint64_t v28 = *(void *)(v16 + 24);
        *(_OWORD *)std::string __dst = v17;
      }

      int v18 = SHIBYTE(v28);
      int v19 = (void **)__dst[0];
      sub_10008D2C8(a2, (uint64_t)__p);
      std::string::size_type v20 = __dst;
      if (v18 < 0) {
        std::string::size_type v20 = v19;
      }
      if (v26 >= 0) {
        __int128 v21 = __p;
      }
      else {
        __int128 v21 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v20;
      __int16 v30 = 2081;
      __int128 v31 = v21;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Got event when not expecting it",  "{msg%{public}.0s:LOI Manager, Got event when not expecting it, State:%{private, location:escape_only }s, Event:%{private, location:escape_only}s}",  buf,  0x26u);
      if (v26 < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v28) < 0) {
        operator delete(__dst[0]);
      }
    }

    uint64_t v22 = *(void *)(a1 + 16);
    if (*(char *)(v22 + 31) < 0)
    {
      sub_1010DD48C(buf, *(void **)(v22 + 8), *(void *)(v22 + 16));
    }

    else
    {
      __int128 v23 = *(_OWORD *)(v22 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(v22 + 24);
      *(_OWORD *)__int128 buf = v23;
    }
  }

  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000D4414( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D443C(uint64_t a1)
{
  BOOL v2 = (char *)operator new(0x58uLL);
  sub_10008D438((uint64_t)v2, 0);
  std::string::assign((std::string *)(v2 + 8), "Not in Active Location State");
  sub_1010DDBC0(__p, "LOI Visit Entry");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 64;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Enable Custom LOI");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 72;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Disable Custom LOI");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 80;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Geofence Entry");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 88;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Fetch Place Inference For Reason");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 112;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Leeched Location Update");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 96;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(v5, "Not in Active Location State");
  uint64_t v4 = (uint64_t)v2;
  sub_10008D760(a1 + 8, (__int128 *)v5, &v4);
  uint64_t v3 = v4;
  uint64_t v4 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1000D46A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D4710(uint64_t a1)
{
  BOOL v2 = (char *)operator new(0x58uLL);
  sub_10008D438((uint64_t)v2, 0);
  std::string::assign((std::string *)(v2 + 8), "In Home LOI State");
  sub_1010DDBC0(__p, "LOI Visit Entry");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 64;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "LOI Visit Exit");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 120;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Enable Custom LOI");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 128;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Disable Custom LOI");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 80;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Geofence Entry");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 136;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Fetch Place Inference For Reason");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 144;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(v5, "In Home LOI State");
  uint64_t v4 = (uint64_t)v2;
  sub_10008D760(a1 + 8, (__int128 *)v5, &v4);
  uint64_t v3 = v4;
  uint64_t v4 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1000D497C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D49E4(uint64_t a1)
{
  BOOL v2 = (char *)operator new(0x58uLL);
  sub_10008D438((uint64_t)v2, 0);
  std::string::assign((std::string *)(v2 + 8), "In Custom LOI State");
  sub_1010DDBC0(__p, "Geofence Entry");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 160;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Geofence Exit");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 152;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Enable Custom LOI");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 168;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Disable Custom LOI");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 176;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(v5, "In Custom LOI State");
  uint64_t v4 = (uint64_t)v2;
  sub_10008D760(a1 + 8, (__int128 *)v5, &v4);
  uint64_t v3 = v4;
  uint64_t v4 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1000D4BB8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D4C18(uint64_t a1)
{
  BOOL v2 = (char *)operator new(0x58uLL);
  sub_10008D438((uint64_t)v2, 0);
  std::string::assign((std::string *)(v2 + 8), "In the process of entering Home LOI");
  *((void *)v2 + 5) = a1 + 184;
  sub_1010DDBC0(__p, "Enable Custom LOI");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 192;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Geofence Entry");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 200;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Got LOI Event");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 208;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Failed to Get LOI Event");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 216;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Fetched Place Inference For Current Location");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 224;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Failed To Fetched Place Inference");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 232;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Got Related LOIs");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 240;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Failed to Get Related LOIs");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 248;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(v5, "In the process of entering Home LOI");
  uint64_t v4 = (uint64_t)v2;
  sub_10008D760(a1 + 8, (__int128 *)v5, &v4);
  uint64_t v3 = v4;
  uint64_t v4 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1000D4F24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D4F94(uint64_t a1)
{
  BOOL v2 = (char *)operator new(0x58uLL);
  sub_10008D438((uint64_t)v2, 0);
  std::string::assign((std::string *)(v2 + 8), "In the process of entering Custom LOI");
  *((void *)v2 + 5) = a1 + 256;
  sub_1010DDBC0(__p, "Enable Custom LOI");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 264;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Geofence Entry");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 272;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Got Location Update");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 280;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Failed To Get Location Update");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 288;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Started Process of Activaing Geofence");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 296;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(__p, "Failed To Set Geofence");
  uint64_t v9 = __p;
  *((void *)sub_1000C042C((uint64_t **)v2 + 6, (const void **)__p, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 7) = a1 + 304;
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  sub_1010DDBC0(v5, "In the process of entering Custom LOI");
  uint64_t v4 = (uint64_t)v2;
  sub_10008D760(a1 + 8, (__int128 *)v5, &v4);
  uint64_t v3 = v4;
  uint64_t v4 = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v6 < 0) {
    operator delete(v5[0]);
  }
}

void sub_1000D5208( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D5274(uint64_t a1)
{
  *(void *)a1 = off_10181DF58;
  *(void *)(a1 + 8) = off_10181DFC0;
  BOOL v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 440);
  if (v3)
  {
    *(void *)(a1 + 4sub_10000AE14(v17 - 48) = v3;
    operator delete(v3);
  }

  nullsub_10(a1 + 304);
  nullsub_10(a1 + 296);
  nullsub_10(a1 + 288);
  nullsub_10(a1 + 280);
  nullsub_10(a1 + 272);
  nullsub_10(a1 + 264);
  nullsub_10(a1 + 256);
  nullsub_10(a1 + 248);
  nullsub_10(a1 + 240);
  nullsub_10(a1 + 232);
  nullsub_10(a1 + 224);
  nullsub_10(a1 + 216);
  nullsub_10(a1 + 208);
  nullsub_10(a1 + 200);
  nullsub_10(a1 + 192);
  nullsub_10(a1 + 184);
  nullsub_10(a1 + 176);
  nullsub_10(a1 + 168);
  nullsub_10(a1 + 160);
  nullsub_10(a1 + 152);
  nullsub_10(a1 + 144);
  nullsub_10(a1 + 136);
  nullsub_10(a1 + 128);
  nullsub_10(a1 + 120);
  nullsub_10(a1 + 112);
  nullsub_10(a1 + 104);
  nullsub_10(a1 + 96);
  nullsub_10(a1 + 88);
  nullsub_10(a1 + 80);
  nullsub_10(a1 + 72);
  nullsub_10(a1 + 64);
  sub_10008D5F4(v2);
  return a1;
}

uint64_t sub_1000D53D0(uint64_t a1)
{
  return sub_1000D5274(a1 - 8);
}

void sub_1000D53D8(uint64_t a1)
{
  __int128 v1 = (void *)sub_1000D5274(a1);
  operator delete(v1);
}

void sub_1000D53EC(uint64_t a1)
{
  __int128 v1 = (void *)sub_1000D5274(a1 - 8);
  operator delete(v1);
}

id sub_1000D5404(uint64_t a1, void *a2)
{
  if (!a2)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_FAULT,  "FAULT: Tried to initialize LOI Manager with a nil LOI Bridge Object",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      v9[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  17LL,  "FAULT: Tried to initialize LOI Manager with a nil LOI Bridge Object",  v9,  2);
      char v8 = (uint8_t *)v7;
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "void CLMicroLocationLoiManager::setupWithLoiBridge(id<CLMicroLocationLoiBridgeProtocol>)",  "%s\n",  v7);
      if (v8 != buf) {
        free(v8);
      }
    }
  }

  id v5 = a2;
  *(void *)(a1 + 320) = v5;
  return [v5 setMicroLocationLoiClient:a1];
}

void sub_1000D55AC(uint64_t a1, __int128 *a2)
{
  uint64_t v4 = (std::string *)sub_1010DDBC0(&__p, "No Name Given");
  id v5 = &off_10181EA38;
  __int128 v8 = *a2;
  std::string::assign(v4, "Enable Custom LOI");
  sub_10008DBE0((void *)(a1 + 8), (uint64_t)&v5);
  id v5 = &off_10181D7E8;
  if (v7 < 0) {
    operator delete(__p);
  }
}

void sub_1000D5674( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D56A4(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v8 = (std::string *)sub_1010DDBC0(&__p, "No Name Given");
  uint64_t v9 = &off_10181EA58;
  uint64_t v12 = a2;
  uint64_t v13 = a3;
  __int128 v14 = *a4;
  std::string::assign(v8, "Disable Custom LOI");
  sub_10008DBE0((void *)(a1 + 8), (uint64_t)&v9);
  uint64_t v9 = &off_10181D7E8;
  if (v11 < 0) {
    operator delete(__p);
  }
}

void sub_1000D5780( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D57B0(uint64_t a1, void *a2)
{
  uint64_t v4 = (std::string *)sub_1010DDBC0(v7, "No Name Given");
  char v6 = off_10181EA78;
  std::string::assign(v4, "Leeched Location Update");
  v7[3] = a2;
  sub_10008DBE0((void *)(a1 + 8), (uint64_t)&v6);
  return sub_1000E1FE4((uint64_t)&v6);
}

void sub_1000D583C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
}

void sub_1000D5870(uint64_t a1)
{
  v2[0] = &off_10181D7E8;
  if (v3 < 0) {
    operator delete((void *)v2[1]);
  }
}

void sub_1000D58C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000D58F4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  uint64_t v14 = a2;
  uint64_t v15 = a3;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  __int128 v8 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_100013090((uint64_t)&v14, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)__int128 buf = &off_101818CB0;
      sub_1000139B0((uint64_t)buf);
    }

    p_p = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 buf = 68289283;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)uint64_t v13 = 2082;
    *(void *)&void v13[2] = "";
    *(_WORD *)&v13[10] = 2081;
    *(void *)&v13[12] = p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LOI Manager, got geofence entry event for valid LOI, LOI ID:%{private, location:escape_only}s}",  buf,  0x1Cu);
    uint64_t v5 = v14;
    uint64_t v4 = v15;
  }

  sub_1000D5AC8(a1, v5, v4, 10LL);
  return sub_1010DDBC0(a4, "In Custom LOI State");
}

void sub_1000D5A94( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, std::bad_cast a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1000D5AC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1000D5B5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000D5B78@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  __int128 v8 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "#LOI Manager, kick off creating custom LOI process",  buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    v24[0] = 0;
    __int128 v23 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#LOI Manager, kick off creating custom LOI process",  v24,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::string CLMicroLocationLoiManager::handleEnableCustomLoi(CLMiLoService::ServiceUuid)",  "%s\n",  v23);
  }

  [*(id *)(a1 + 320) getCurrentLocation];
  __int128 v10 = *(void **)(a1 + 448);
  unint64_t v9 = *(void *)(a1 + 456);
  if ((unint64_t)v10 >= v9)
  {
    uint64_t v12 = *(void *)(a1 + 440);
    uint64_t v13 = ((uint64_t)v10 - v12) >> 4;
    unint64_t v14 = v13 + 1;
    uint64_t v15 = v9 - v12;
    if (v15 >> 3 > v14) {
      unint64_t v14 = v15 >> 3;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16) {
      __int128 v17 = (char *)sub_100037038(a1 + 456, v16);
    }
    else {
      __int128 v17 = 0LL;
    }
    int v18 = &v17[16 * v13];
    int v19 = &v17[16 * v16];
    *(void *)int v18 = a2;
    *((void *)v18 + 1) = a3;
    char v11 = v18 + 16;
    __int128 v21 = *(char **)(a1 + 440);
    std::string::size_type v20 = *(char **)(a1 + 448);
    if (v20 != v21)
    {
      do
      {
        *((_OWORD *)v18 - 1) = *((_OWORD *)v20 - 1);
        v18 -= 16;
        v20 -= 16;
      }

      while (v20 != v21);
      std::string::size_type v20 = *(char **)(a1 + 440);
    }

    *(void *)(a1 + 440) = v18;
    *(void *)(a1 + 4sub_10000AE14(v17 - 48) = v11;
    *(void *)(a1 + 456) = v19;
    if (v20) {
      operator delete(v20);
    }
  }

  else
  {
    *__int128 v10 = a2;
    v10[1] = a3;
    char v11 = v10 + 2;
  }

  *(void *)(a1 + 4sub_10000AE14(v17 - 48) = v11;
  *(void *)(a1 + 408) = 0LL;
  *(void *)(a1 + 416) = 0LL;
  return sub_1010DDBC0(a4, "In the process of entering Custom LOI");
}

void *sub_1000D5E00@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  v25[0] = a2;
  v25[1] = a3;
  v24[0] = a4;
  v24[1] = a5;
  sub_1000D60E0(a1, a2, a3, (uint64_t)v24);
  if (sub_1000D6320(a1, a2, a3))
  {
    memset(&v19, 0, sizeof(v19));
    if ((sub_100013090((uint64_t)v25, &v19) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)__int128 buf = &off_101818CB0;
      sub_1000139B0((uint64_t)buf);
    }

    memset(&__p, 0, sizeof(__p));
    if ((sub_100013090((uint64_t)v24, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)buf);
      *(void *)__int128 buf = &off_101818CB0;
      sub_1000139B0((uint64_t)buf);
    }

    if ((v19.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v10 = &v19;
    }
    else {
      __int128 v10 = (std::string *)v19.__r_.__value_.__r.__words[0];
    }
    char v11 = -[NSString uppercaseString]( +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v10),  "uppercaseString");
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v12 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = &v19;
      if ((v19.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v13 = (std::string *)v19.__r_.__value_.__r.__words[0];
      }
      p_p = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int128 v21 = 2082;
      *(void *)&void v21[2] = "";
      *(_WORD *)&v21[10] = 2081;
      *(void *)&v21[12] = v13;
      __int16 v22 = 2081;
      __int128 v23 = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LOI Manager, No More services monitoring this LOI, disable geofence for LOI, loiID :%{private, location:escape_only}s, Service Id:%{private, location:escape_only}s}",  buf,  0x26u);
    }

    [*(id *)(a1 + 320) removeGeofenceWithRegionId:v11];
  }

  double result = (void *)(*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 328) + 8LL))( *(void *)(a1 + 328),  -1LL);
  uint64_t v16 = *(void *)(a1 + 16);
  __int128 v17 = *(_OWORD *)(v16 + 8);
  *(void *)(a6 + 16) = *(void *)(v16 + 24);
  *(_OWORD *)a6 = v17;
  return result;
}

void sub_1000D6080( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, std::bad_cast a21)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(a1);
}

void sub_1000D60E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v17[0] = a2;
  v17[1] = a3;
  memset(&v9, 0, sizeof(v9));
  if ((sub_100013090(a4, &v9) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(void *)__int128 buf = &off_101818CB0;
    sub_1000139B0((uint64_t)buf);
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v5 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_100013090((uint64_t)v17, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v10);
      v10.__vftable = (std::bad_cast_vtbl *)&off_101818CB0;
      sub_1000139B0((uint64_t)&v10);
    }

    p_p = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    char v7 = &v9;
    if ((v9.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      char v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)unint64_t v14 = 2082;
    *(void *)&void v14[2] = "";
    *(_WORD *)&v14[10] = 2081;
    *(void *)&v14[12] = p_p;
    __int16 v15 = 2081;
    uint64_t v16 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#LOI Manager, Removing LOI to Service ID mapping, Location ID:%{private, location:esc ape_only}s, Service ID:%{private, location:escape_only}s}",  buf,  0x26u);
  }

  sub_10002D38C(*(void *)(a1 + 312), (uint64_t)&v9, (uint64_t)v17);
}

void sub_1000D62C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, std::bad_cast a22, uint64_t a23, uint64_t a24, std::bad_cast a25)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1000D6320(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[0] = a2;
  v7[1] = a3;
  sub_10002D3A4(*(void *)(a1 + 312), (uint64_t)v7, v5);
  BOOL v3 = v5[1] == v5[0];
  char v6 = (void **)v5;
  sub_1000129D4(&v6);
  return v3;
}

BOOL sub_1000D63A4(uint64_t a1, double a2, double a3)
{
  if (sub_100031790(*(void *)(a1 + 312)))
  {
    double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
    if (!*(_BYTE *)(a1 + 472)) {
      goto LABEL_30;
    }
    double v7 = Current_1;
    double v8 = *(double *)(a1 + 464);
    sub_1002F0B04(buf);
    CFStringRef v9 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsRefreshRoutineStateThrottle", 0x8000100u, kCFAllocatorNull);
    int v10 = sub_1002A832C(*(uint64_t *)buf, (uint64_t)v9, v21);
    CFRelease(v9);
    double v11 = v7 - v8;
    double v12 = *(double *)v21;
    uint64_t v13 = v23;
    if (v23)
    {
      p_shared_owners = (unint64_t *)&v23->__shared_owners_;
      do
        unint64_t v15 = __ldaxr(p_shared_owners);
      while (__stlxr(v15 - 1, p_shared_owners));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }

    double v16 = 0.1;
    if (v10) {
      double v16 = v12;
    }
    if (v11 >= v16)
    {
LABEL_30:
      sub_1000D7224(a1, a2, a3);
      return sub_1000D788C(a1);
    }

    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int128 v17 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Ignoring refreshRoutineStateAtLocation request since last request was too recent",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      LOWORD(v21[0]) = 0;
      std::string v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Ignoring refreshRoutineStateAtLocation request since last request was too recent",  v21,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationLoiManager::refreshRoutineStateAtLocation(double, double)",  "%s\n",  v19);
LABEL_27:
      return 0LL;
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    std::string::size_type v20 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Ignoring refreshRoutineStateAtLocation request since keybag is not unlocked",  buf,  2u);
    }

    BOOL result = sub_1002921D0(115, 2);
    if (result)
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      LOWORD(v21[0]) = 0;
      std::string v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Ignoring refreshRoutineStateAtLocation request since keybag is not unlocked",  v21,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationLoiManager::refreshRoutineStateAtLocation(double, double)",  "%s\n",  v19);
      goto LABEL_27;
    }
  }

  return result;
}

void sub_1000D6750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_1000D6770(uint64_t a1, uint64_t a2)
{
  if ((_DWORD)a2 == 11) {
    sub_1000D76B0(a1, (uint64_t)@"Custom Loi", (uint64_t)@"Exit");
  }
  std::string::assign((std::string *)(a1 + 368), "unknown");
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(void *)(a1 + 4sub_10000AE14(v17 - 48) = *(void *)(a1 + 440);
  if (*(_BYTE *)(a1 + 484)) {
    *(_BYTE *)(a1 + 484) = 0;
  }
  uint64_t v4 = *(void *)(a1 + 328);
  if (*(char *)(a1 + 391) < 0)
  {
    sub_1010DD48C(__p, *(void **)(a1 + 368), *(void *)(a1 + 376));
    uint64_t v6 = *(void *)(a1 + 392);
    uint64_t v5 = *(void *)(a1 + 400);
  }

  else
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 0LL;
    *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 368);
    uint64_t v8 = *(void *)(a1 + 384);
  }

  (*(void (**)(uint64_t, void **, uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16LL))(v4, __p, v6, v5, a2);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1000D6854( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D6870(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a2;
  uint64_t v13 = a3;
  sub_10002D640(*(void *)(a1 + 312), &v10);
  if (v10 == v11)
  {
    char v3 = 0;
    if (!v10) {
      return v3 & 1;
    }
    goto LABEL_11;
  }

  char v3 = 0;
  uint64_t v4 = v10;
  do
  {
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1];
    v4 += 2;
    BOOL v8 = v12 == v5 && v13 == v6;
    v3 |= v8;
  }

  while (v4 != v11);
  if (v10) {
LABEL_11:
  }
    operator delete(v10);
  return v3 & 1;
}

void sub_1000D691C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v6[0] = @"loiRelatedFailureOccurred";
  v6[1] = @"failureType";
  v7[0] = &off_1018D3050;
  v7[1] = a2;
  void v7[2] = a3;
  v6[2] = @"failureReason";
  void v6[3] = @"fsmStateDuringFailure";
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = (void *)(v3 + 8);
  v7[3] = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v4);
  uint64_t v5 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v7,  v6,  4LL);
  sub_1000D799C((uint64_t)v5, @"com.apple.MicroLocation.LOIFailures", (uint64_t)v5);
}

BOOL sub_1000D69E8(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  BOOL v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    if (!*(_BYTE *)(a1 + 484)) {
      sub_100036CD8();
    }
    sub_1001013B8(*(_DWORD *)(a1 + 480), __p);
    if (v9 >= 0) {
      uint64_t v3 = __p;
    }
    else {
      uint64_t v3 = (void **)__p[0];
    }
    *(_DWORD *)__int128 buf = 68289283;
    int v11 = 0;
    __int16 v12 = 2082;
    uint64_t v13 = "";
    __int16 v14 = 2081;
    unint64_t v15 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:LOI Manager, Attempting to fetch place inference, Reason::%{private, location:escape_only}s}",  buf,  0x1Cu);
    if (v9 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v4 = *(void *)(a1 + 320);
  if (v4)
  {
    (*(void (**)(void))(**(void **)(a1 + 328) + 40LL))(*(void *)(a1 + 328));
    [*(id *)(a1 + 320) fetchPlaceInferenceAtCurrentLocation];
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Warning LOI Bridge not setup.}",  buf,  0x12u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    uint64_t v6 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)__int128 buf = 68289026;
      int v11 = 0;
      __int16 v12 = 2082;
      uint64_t v13 = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Warning LOI Bridge not setup.",  "{msg%{public}.0s:#Warning LOI Bridge not setup.}",  buf,  0x12u);
    }
  }

  return v4 != 0;
}

void sub_1000D6C4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v17[0] = a2;
  v17[1] = a3;
  memset(&v9, 0, sizeof(v9));
  if ((sub_100013090(a4, &v9) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)buf);
    *(void *)__int128 buf = &off_101818CB0;
    sub_1000139B0((uint64_t)buf);
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v5 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    memset(&__p, 0, sizeof(__p));
    if ((sub_100013090((uint64_t)v17, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast(&v10);
      v10.__vftable = (std::bad_cast_vtbl *)&off_101818CB0;
      sub_1000139B0((uint64_t)&v10);
    }

    p_p = &__p;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    double v7 = &v9;
    if ((v9.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      double v7 = (std::string *)v9.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 buf = 68289539;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)__int16 v14 = 2082;
    *(void *)&void v14[2] = "";
    *(_WORD *)&v14[10] = 2081;
    *(void *)&v14[12] = p_p;
    __int16 v15 = 2081;
    double v16 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#LOI Manager, Adding LOI to Service ID mapping, Location ID:%{private, location:escap e_only}s, Service ID:%{private, location:escape_only}s}",  buf,  0x26u);
  }

  sub_10002D0F0(*(void *)(a1 + 312), (uint64_t)&v9, (uint64_t)v17);
}

void sub_1000D6E34( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, std::bad_cast a22, uint64_t a23, uint64_t a24, std::bad_cast a25)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  _Unwind_Resume(a1);
}

void *sub_1000D6E8C@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  switch(a1)
  {
    case -1LL:
      uint64_t v3 = "other";
      goto LABEL_13;
    case 0LL:
      uint64_t v3 = "home";
      goto LABEL_13;
    case 1LL:
      uint64_t v3 = "work";
      goto LABEL_13;
    case 2LL:
      uint64_t v3 = "school";
      goto LABEL_13;
    case 3LL:
      uint64_t v3 = "gym";
LABEL_13:
      BOOL result = sub_1010DDBC0(a2, v3);
      break;
    default:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      uint64_t v4 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#Warning Please update this switch statement.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181EA08);
        }
        v7[0] = 0;
        uint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Please update this switch statement.",  v7,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::string CLMicroLocationLoiManager::convertRTLocationOfInterestTypeToString(RTLocationOfInterestType)",  "%s\n",  v6);
      }

      BOOL result = sub_1010DDBC0(a2, "none");
      break;
  }

  return result;
}

BOOL sub_1000D7130(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 320);
  if (v2)
  {
    [*(id *)(a1 + 320) fetchRelatedLoisForLoi:a2];
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v3 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 68289026;
      v5[1] = 0;
      __int16 v6 = 2082;
      double v7 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning LOI Bridge not setup.}",  (uint8_t *)v5,  0x12u);
    }
  }

  return v2 != 0;
}

void sub_1000D7224(uint64_t a1, double a2, double a3)
{
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  if (!*(_BYTE *)(a1 + 472)) {
    *(_BYTE *)(a1 + 472) = 1;
  }
  *(double *)(a1 + 464) = Current_1;
  *(double *)(a1 + 336) = a2;
  *(double *)(a1 + 344) = a3;
  if (*(char *)(a1 + 391) < 0)
  {
    **(_BYTE **)(a1 + 368) = 0;
    *(void *)(a1 + 376) = 0LL;
  }

  else
  {
    *(_BYTE *)(a1 + 368) = 0;
    *(_BYTE *)(a1 + 391) = 0;
  }

  *(void *)(a1 + 392) = 0LL;
  *(void *)(a1 + 400) = 0LL;
}

void *sub_1000D7290@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  switch(a1)
  {
    case 0LL:
      uint64_t v3 = "other";
      goto LABEL_13;
    case 1LL:
      uint64_t v3 = "home";
      goto LABEL_13;
    case 2LL:
      uint64_t v3 = "work";
      goto LABEL_13;
    case 3LL:
      uint64_t v3 = "school";
      goto LABEL_13;
    case 4LL:
      uint64_t v3 = "gym";
LABEL_13:
      BOOL result = sub_1010DDBC0(a2, v3);
      break;
    default:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      uint64_t v4 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#Warning Please update this switch statement.",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181EA08);
        }
        v7[0] = 0;
        __int16 v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Please update this switch statement.",  v7,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::string CLMicroLocationLoiManager::convertPlaceInferenceUserPlaceTypeToString(_CLPlaceInferenceUserSpecificPlaceType)",  "%s\n",  v6);
      }

      BOOL result = sub_1010DDBC0(a2, "none");
      break;
  }

  return result;
}

void sub_1000D7530(uint64_t a1)
{
  v4[0] = &off_1018D3050;
  v3[0] = @"createdCustomLoi";
  v3[1] = @"geofenceLocationHorizontalAccuracy";
  v4[1] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 352));
  v3[2] = @"geofenceLocationVerticalAccuracy";
  v4[2] = +[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(a1 + 360));
  uint64_t v2 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v4,  v3,  3LL);
  sub_1000D799C((uint64_t)v2, @"com.apple.MicroLocation.CustomLoiCreation", (uint64_t)v2);
}

void sub_1000D75F8(uint64_t a1, uint64_t a2, uint64_t a3, std::string *__str, uint64_t a5)
{
  *(void *)(a1 + 392) = a2;
  *(void *)(a1 + 400) = a3;
  uint64_t v7 = a1 + 368;
  std::string::operator=((std::string *)(a1 + 368), __str);
  uint64_t v8 = *(void *)(a1 + 328);
  if (*(char *)(a1 + 391) < 0)
  {
    sub_1010DD48C(__p, *(void **)(a1 + 368), *(void *)(a1 + 376));
  }

  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v7;
    uint64_t v10 = *(void *)(v7 + 16);
  }

  (*(void (**)(uint64_t, void **, void, void, uint64_t))(*(void *)v8 + 16LL))( v8,  __p,  *(void *)(a1 + 392),  *(void *)(a1 + 400),  a5);
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1000D7694( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D76B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = @"customLoiVisitOccurred";
  v4[1] = @"loiType";
  v5[0] = &off_1018D3050;
  v5[1] = a2;
  v4[2] = @"visitEventType";
  _DWORD v5[2] = a3;
  uint64_t v3 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v5,  v4,  3LL);
  sub_1000D799C((uint64_t)v3, @"com.apple.MicroLocation.CustomLoiVisitEvent", (uint64_t)v3);
}

void sub_1000D774C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)&__int128 v16 = a2;
  *((void *)&v16 + 1) = a3;
  uint64_t v13 = 0LL;
  __int16 v14 = 0LL;
  __int16 v15 = 0LL;
  uint64_t v4 = (char *)sub_100037038((uint64_t)&v15, 1uLL);
  __int16 v6 = &v4[16 * v5];
  *(_OWORD *)uint64_t v4 = v16;
  uint64_t v7 = v4 + 16;
  std::string v9 = (char *)v13;
  uint64_t v8 = v14;
  if (v14 != v13)
  {
    do
    {
      *((_OWORD *)v4 - 1) = *((_OWORD *)v8 - 1);
      v4 -= 16;
      v8 -= 16;
    }

    while (v8 != v9);
    uint64_t v8 = (char *)v13;
  }

  uint64_t v13 = v4;
  __int16 v14 = v7;
  __int16 v15 = v6;
  if (v8) {
    operator delete(v8);
  }
  __int16 v14 = v7;
  uint64_t v10 = *(void *)(a1 + 312);
  sub_1010DDBC0(__p, "custom");
  sub_10002FB48(v10, (uint64_t)&v16, (uint64_t)&v13, (uint64_t)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  if (v13)
  {
    __int16 v14 = (char *)v13;
    operator delete(v13);
  }

void sub_1000D7854( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1000D788C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 320);
  if (v1)
  {
    objc_msgSend( *(id *)(a1 + 320),  "fetchLocationOfInterestAtLocation:",   -[CLLocation initWithLatitude:longitude:]( [CLLocation alloc],  "initWithLatitude:longitude:",  *(double *)(a1 + 336),  *(double *)(a1 + 344)));
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v2 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 68289026;
      v4[1] = 0;
      __int16 v5 = 2082;
      __int16 v6 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning LOI Bridge not setup.}",  (uint8_t *)v4,  0x12u);
    }
  }

  return v1 != 0;
}

void sub_1000D799C(uint64_t a1, void *a2, uint64_t a3)
{
  CFStringRef v5 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsAnalyticsSendEventEnabled", 0x8000100u, kCFAllocatorNull);
  char v6 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v5, (BOOL *)v16);
  CFRelease(v5);
  int v7 = v16[0];
  uint64_t v8 = *(std::__shared_weak_count **)v18;
  if (*(void *)v18)
  {
    std::string v9 = (unint64_t *)(*(void *)v18 + 8LL);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  if (v7) {
    char v11 = 0;
  }
  else {
    char v11 = v6;
  }
  if ((v11 & 1) != 0)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    char v12 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "#LOI Manager, CoreAnalytics Disabled",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      *(_WORD *)__int128 v16 = 0;
      uint64_t v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#LOI Manager, CoreAnalytics Disabled",  v16,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationLoiManager::sendCoreAnalyticsEvent(NSString *, NSDictionary *)",  "%s\n",  v13);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    __int16 v14 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      id v15 = [a2 UTF8String];
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)int v18 = 2082;
      *(void *)&void v18[2] = "";
      __int16 v19 = 2081;
      id v20 = v15;
      __int16 v21 = 2113;
      uint64_t v22 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:#LOI Manager, sending core analytics, event:%{private, location:escape_only}s, ev entFields:%{private, location:escape_only}@}",  buf,  0x26u);
    }

    AnalyticsSendEvent(a2, a3);
  }

void sub_1000D7C70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

void sub_1000D7C90(uint64_t a1, void *a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "LOI Manager, handleVisitNotification", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    v11[0] = 0;
    int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "LOI Manager, handleVisitNotification",  v11,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationLoiManager::handleVisitNotification(CLVisit *)",  "%s\n",  v7);
  }

  if ([a2 hasDepartureDate])
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    CFStringRef v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "LOI Manager, Received visit exit", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      v11[0] = 0;
      LODWORD(sub_10004B64C(v11, v10) = 2;
      uint64_t v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "LOI Manager, Received visit exit",  v11,  v10);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationLoiManager::handleVisitNotification(CLVisit *)",  "%s\n",  v8);
    }

    *(void *)__int128 buf = &off_10181D7E8;
    sub_1010DDBC0(&__p, "No Name Given");
    *(void *)__int128 buf = off_10181EAB8;
    id v14 = a2;
    std::string::assign(&__p, "LOI Visit Exit");
    sub_10008DBE0((void *)(a1 + 8), (uint64_t)buf);
    *(void *)__int128 buf = off_10181EAB8;
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    char v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "LOI Manager, Received visit entry", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      v11[0] = 0;
      LODWORD(sub_10004B64C(v11, v10) = 2;
      std::string v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "LOI Manager, Received visit entry",  v11,  v10);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationLoiManager::handleVisitNotification(CLVisit *)",  "%s\n",  v9);
    }

    *(void *)__int128 buf = &off_10181D7E8;
    sub_1010DDBC0(&__p, "No Name Given");
    *(void *)__int128 buf = off_10181EAD8;
    id v14 = a2;
    std::string::assign(&__p, "LOI Visit Entry");
    sub_10008DBE0((void *)(a1 + 8), (uint64_t)buf);
    *(void *)__int128 buf = off_10181EAD8;
  }

  *(void *)__int128 buf = &off_10181D7E8;
}

void sub_1000D8174( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D81D8(uint64_t a1)
{
  *(void *)a1 = off_10181EAB8;

  *(void *)a1 = &off_10181D7E8;
  return a1;
}

uint64_t sub_1000D8234(uint64_t a1)
{
  *(void *)a1 = off_10181EAD8;

  *(void *)a1 = &off_10181D7E8;
  return a1;
}

void sub_1000D8290(uint64_t a1, void *a2, void *a3)
{
  if (a3)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    char v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(__p.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(__p.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 4) = (std::string::size_type)objc_msgSend(objc_msgSend(a3, "description"), "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Bridge, Failed To fetch place inferences, Error::%{private, location:escape_only}s}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    int v7 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      id v8 = objc_msgSend(objc_msgSend(a3, "description"), "UTF8String");
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(__p.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(__p.__r_.__value_.__r.__words[1]) = 2081;
      *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 4) = (std::string::size_type)v8;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Bridge, Failed To fetch place inferences",  "{msg%{public}.0s:LOI Bridge, Failed To fetch place inferences, Error::%{private, location:escape_only}s}",  buf,  0x1Cu);
    }
  }

  if (![a2 count])
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v10 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "LOI Bridge, received no place inferences, we will start leeching and wait for next location update",  buf,  2u);
    }

    if (!sub_1002921D0(115, 2)) {
      goto LABEL_25;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    v13[0] = 0;
    char v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "LOI Bridge, received no place inferences, we will start leeching and wait for next location update",  v13,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationLoiManager::handleFetchedPlaceInferences(NSArray<_CLPlaceInference *> *, NSError *)",  "%s\n",  v11);
    goto LABEL_31;
  }

  id v9 = [a2 objectAtIndexedSubscript:0];
  if ([v9 _loiIdentifier])
  {
    *(void *)__int128 buf = &off_10181D7E8;
    sub_1010DDBC0(&__p, "No Name Given");
    *(void *)__int128 buf = off_10181EB18;
    id v16 = v9;
    std::string::assign(&__p, "Fetched Place Inference For Current Location");
    sub_10008DBE0((void *)(a1 + 8), (uint64_t)buf);
    sub_1000E23C0((uint64_t)buf);
    return;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EA08);
  }
  char v12 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "LOI Bridge, received nil LOI Identifier, possibly because there is no active user on macOS, we will start leeching and wait for next location update",  buf,  2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    v13[0] = 0;
    char v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "LOI Bridge, received nil LOI Identifier, possibly because there is no active user on macOS, we will start leeching and wait for next location update",  v13,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLMicroLocationLoiManager::handleFetchedPlaceInferences(NSArray<_CLPlaceInference *> *, NSError *)",  "%s\n",  v11);
LABEL_31:
  }

void sub_1000D875C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
}

void sub_1000D87B0(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  if (a4)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    char v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136380675;
      *(void *)((char *)&buf + 4) = objc_msgSend(objc_msgSend(a4, "description"), "UTF8String");
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "#Warning LOI Manager, Error retrieving the current LOI. %{private}s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
      uint64_t v8 = qword_1019348D8;
      int v10 = 136380675;
      id v11 = objc_msgSend(objc_msgSend(a4, "description"), "UTF8String");
      id v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  v8,  0LL,  "#Warning LOI Manager, Error retrieving the current LOI. %{private}s",  &v10,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationLoiManager::handleFetchedLocationOfInterestAtLocation(CLMicroLocationLoi *, CLLocati on *, NSError *)",  "%s\n",  v9);
    }

    sub_1000E241C(&buf);
    sub_10008DBE0((void *)(a1 + 8), (uint64_t)&buf);
  }

  else
  {
    sub_1010DDBC0((void *)&buf + 1, "No Name Given");
    *(void *)&__int128 buf = off_10181EB58;
    id v14 = a2;
    std::string::assign((std::string *)((char *)&buf + 8), "Got LOI Event");
    sub_10008DBE0((void *)(a1 + 8), (uint64_t)&buf);
    *(void *)&__int128 buf = off_10181EB58;
  }

  *(void *)&__int128 buf = &off_10181D7E8;
  if (v13 < 0) {
    operator delete(*((void **)&buf + 1));
  }
}

void sub_1000D8A28( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a2) {
    sub_100006BB8(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D8A88(uint64_t a1)
{
  *(void *)a1 = off_10181EB58;

  *(void *)a1 = &off_10181D7E8;
  return a1;
}

void sub_1000D8AE4(uint64_t a1, void *a2, std::string::size_type a3)
{
  if (a3)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    CFStringRef v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(v38.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)v38.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(v38.__r_.__value_.__r.__words[1]) = 2113;
      *(std::string::size_type *)((char *)&v38.__r_.__value_.__r.__words[1] + 4) = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#Warning LOI Manager, Error retrieving related LOIs for Loi, error:%{private, locat ion:escape_only}@}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    char v6 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)__int128 buf = 68289283;
      *(_DWORD *)&uint8_t buf[4] = 0;
      LOWORD(v38.__r_.__value_.__l.__data_) = 2082;
      *(std::string::size_type *)((char *)v38.__r_.__value_.__r.__words + 2) = (std::string::size_type)"";
      WORD1(v38.__r_.__value_.__r.__words[1]) = 2113;
      *(std::string::size_type *)((char *)&v38.__r_.__value_.__r.__words[1] + 4) = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#Warning LOI Manager, Error retrieving related LOIs for Loi",  "{msg%{public}.0s:#Warning LOI Manager, Error retrieving related LOIs for Loi, error:%{private, locat ion:escape_only}@}",  buf,  0x1Cu);
    }

    sub_1000E2504(buf);
    sub_10008DBE0((void *)(a1 + 8), (uint64_t)buf);
    *(void *)__int128 buf = &off_10181D7E8;
    if ((char)v38.__r_.__value_.__s.__size_ < 0)
    {
      int v7 = (void *)v38.__r_.__value_.__r.__words[0];
LABEL_36:
      operator delete(v7);
    }
  }

  else
  {
    std::string __p = 0LL;
    __int128 v35 = 0LL;
    unint64_t v36 = 0LL;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    id v9 = [a2 countByEnumeratingWithState:&v30 objects:v40 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v31;
      do
      {
        for (uint64_t i = 0LL; i != v9; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v31 != v10) {
            objc_enumerationMutation(a2);
          }
          char v12 = (char *)objc_msgSend( objc_msgSend(*(id *)(*((void *)&v30 + 1) + 8 * (void)i), "UUIDString"),  "UTF8String");
          size_t v13 = strlen(v12);
          uint64_t v14 = sub_1000E20CC((uint64_t)buf, (unsigned __int8 *)v12, (unsigned __int8 *)&v12[v13]);
          uint64_t v16 = v14;
          uint64_t v17 = v15;
          int v18 = v35;
          if ((unint64_t)v35 >= v36)
          {
            uint64_t v20 = ((char *)v35 - (_BYTE *)__p) >> 4;
            unint64_t v21 = v20 + 1;
            uint64_t v22 = v36 - (void)__p;
            else {
              unint64_t v23 = v21;
            }
            if (v23) {
              __int128 v24 = (char *)sub_100037038((uint64_t)&v36, v23);
            }
            else {
              __int128 v24 = 0LL;
            }
            int v25 = (uint64_t *)&v24[16 * v20];
            uint64_t *v25 = v16;
            v25[1] = v17;
            int v27 = __p;
            char v26 = v35;
            uint64_t v28 = (char *)v25;
            if (v35 != __p)
            {
              do
              {
                *((_OWORD *)v28 - 1) = *((_OWORD *)v26 - 1);
                v28 -= 16;
                v26 -= 2;
              }

              while (v26 != v27);
              char v26 = __p;
            }

            __int16 v19 = v25 + 2;
            std::string __p = v28;
            __int128 v35 = v25 + 2;
            unint64_t v36 = (unint64_t)&v24[16 * v23];
            if (v26) {
              operator delete(v26);
            }
          }

          else
          {
            uint64_t *v35 = v14;
            v18[1] = v15;
            __int16 v19 = v18 + 2;
          }

          __int128 v35 = v19;
        }

        id v9 = [a2 countByEnumeratingWithState:&v30 objects:v40 count:16];
      }

      while (v9);
    }

    *(void *)__int128 buf = &off_10181D7E8;
    sub_1010DDBC0(&v38, "No Name Given");
    *(void *)__int128 buf = off_10181EB98;
    memset(v39, 0, 24);
    sub_10009B244((char *)v39, (char *)__p, (uint64_t)v35, ((char *)v35 - (_BYTE *)__p) >> 4);
    std::string::assign(&v38, "Got Related LOIs");
    sub_10008DBE0((void *)(a1 + 8), (uint64_t)buf);
    sub_1000E25A4((uint64_t)buf);
    int v7 = __p;
    if (__p)
    {
      __int128 v35 = (uint64_t *)__p;
      goto LABEL_36;
    }
  }

void sub_1000D8ED0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1000D8F70(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    CFStringRef v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)std::string __p = 2082;
      *(void *)&__p[2] = "";
      __int16 v21 = 2114;
      uint64_t v22 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, failed to get current location to enable MiLo, Error:%{public, locati on:escape_only}@}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    char v6 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)std::string __p = 2082;
      *(void *)&__p[2] = "";
      __int16 v21 = 2114;
      uint64_t v22 = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, failed to get current location to enable MiLo",  "{msg%{public}.0s:#LOI Manager, failed to get current location to enable MiLo, Error:%{public, locati on:escape_only}@}",  buf,  0x1Cu);
    }

    sub_1000E2604(buf);
    sub_10008DBE0((void *)(a1 + 8), (uint64_t)buf);
    *(void *)__int128 buf = &off_10181D7E8;
    if (v23 < 0) {
      operator delete(*(void **)__p);
    }
  }

  else
  {
    sub_1000E2690(buf, a2);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v8 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      [a2 coordinate];
      uint64_t v10 = v9;
      [a2 coordinate];
      v12[0] = 68289539;
      v12[1] = 0;
      __int16 v13 = 2082;
      uint64_t v14 = "";
      __int16 v15 = 2049;
      uint64_t v16 = v10;
      __int16 v17 = 2049;
      uint64_t v18 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LOI Manager, got location update, latitude:%{private}7f, longitude:%{private}7f}",  (uint8_t *)v12,  0x26u);
    }

    sub_10008DBE0((void *)(a1 + 8), (uint64_t)buf);
    sub_1000E273C((uint64_t)buf);
  }

void sub_1000D9214( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
}

void sub_1000D9268(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5)
  {
    sub_1000E2798(&v12);
    sub_10008DBE0((void *)(a1 + 8), (uint64_t)&v12);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    int v7 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v18 = 0;
      __int16 v19 = 2082;
      uint64_t v20 = "";
      __int16 v21 = 2114;
      uint64_t v22 = a5;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, failed to set geofence at current location to enable MiLo, Error:%{pu blic, location:escape_only}@}",  buf,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    uint64_t v8 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v18 = 0;
      __int16 v19 = 2082;
      uint64_t v20 = "";
      __int16 v21 = 2114;
      uint64_t v22 = a5;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v8,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, failed to set geofence at current location to enable MiLo",  "{msg%{public}.0s:#LOI Manager, failed to set geofence at current location to enable MiLo, Error:%{pu blic, location:escape_only}@}",  buf,  0x1Cu);
    }
  }

  else
  {
    uint64_t v11 = (std::string *)sub_1010DDBC0(&__p, "No Name Given");
    char v12 = &off_10181EC18;
    uint64_t v15 = a3;
    uint64_t v16 = a4;
    std::string::assign(v11, "Started Process of Activaing Geofence");
    sub_10008DBE0((void *)(a1 + 8), (uint64_t)&v12);
  }

  char v12 = &off_10181D7E8;
  if (v14 < 0) {
    operator delete(__p);
  }
}

void sub_1000D9488( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D94CC(uint64_t a1, void *a2, uint64_t a3)
{
  if (SBYTE3(v21) < 0) {
    operator delete(__p);
  }
  if (v27)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    char v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = [a2 UTF8String];
      std::string __p = (void *)68289539;
      *(_WORD *)__int16 v19 = 2082;
      *(void *)&void v19[2] = "";
      __int16 v20 = 2081;
      id v21 = v7;
      __int16 v22 = 1025;
      *(_DWORD *)char v23 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:LOI Manager, Got Geofence update, Geofence Id:%{private, location:escape_only}s,  State:%{private}d}",  (uint8_t *)&__p,  0x22u);
    }

    if (a3 == 1)
    {
      if (!v27) {
        sub_100036CD8();
      }
      uint64_t v8 = v25;
      uint64_t v9 = v26;
      std::string __p = &off_10181D7E8;
      uint64_t v10 = (std::string *)sub_1010DDBC0(v19, "No Name Given");
      std::string __p = &off_10181EC38;
      *(void *)&void v23[2] = v8;
      uint64_t v24 = v9;
      std::string::assign(v10, "Geofence Entry");
      sub_10008DBE0((void *)(a1 + 8), (uint64_t)&__p);
    }

    else
    {
      if (!v27) {
        sub_100036CD8();
      }
      uint64_t v15 = v25;
      uint64_t v16 = v26;
      std::string __p = &off_10181D7E8;
      __int16 v17 = (std::string *)sub_1010DDBC0(v19, "No Name Given");
      std::string __p = &off_10181EC58;
      *(void *)&void v23[2] = v15;
      uint64_t v24 = v16;
      std::string::assign(v17, "Geofence Exit");
      sub_10008DBE0((void *)(a1 + 8), (uint64_t)&__p);
    }

    std::string __p = &off_10181D7E8;
    if ((v23[1] & 0x80000000) != 0) {
      operator delete(*(void **)v19);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    uint64_t v11 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      id v12 = [a2 UTF8String];
      std::string __p = (void *)68289539;
      *(_WORD *)__int16 v19 = 2082;
      *(void *)&void v19[2] = "";
      __int16 v20 = 2081;
      id v21 = v12;
      __int16 v22 = 1025;
      *(_DWORD *)char v23 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:LOI Manager, Got invalid geofence ID, Geofence Id:%{private, location:escape_only}s , State:%{private}d}",  (uint8_t *)&__p,  0x22u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    __int16 v13 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      id v14 = [a2 UTF8String];
      std::string __p = (void *)68289539;
      *(_WORD *)__int16 v19 = 2082;
      *(void *)&void v19[2] = "";
      __int16 v20 = 2081;
      id v21 = v14;
      __int16 v22 = 1025;
      *(_DWORD *)char v23 = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "LOI Manager, Got invalid geofence ID",  "{msg%{public}.0s:LOI Manager, Got invalid geofence ID, Geofence Id:%{private, location:escape_only}s , State:%{private}d}",  (uint8_t *)&__p,  0x22u);
    }
  }

void sub_1000D984C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000D9898(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    CFStringRef v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      int v8 = 68289539;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2113;
      uint64_t v13 = a2;
      __int16 v14 = 2113;
      uint64_t v15 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:#LOI Manager, Failed to RemoveGeofence, regionId:%{private, location:escape_only}@, error:%{private, location:escape_only}@}",  (uint8_t *)&v8,  0x26u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EA08);
      }
    }

    char v6 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      int v8 = 68289539;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2113;
      uint64_t v13 = a2;
      __int16 v14 = 2113;
      uint64_t v15 = a3;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v6,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "#LOI Manager, Failed to RemoveGeofence",  "{msg%{public}.0s:#LOI Manager, Failed to RemoveGeofence, regionId:%{private, location:escape_only}@, error:%{private, location:escape_only}@}",  (uint8_t *)&v8,  0x26u);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
    id v7 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 68289539;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2113;
      uint64_t v13 = a2;
      __int16 v14 = 2113;
      uint64_t v15 = 0LL;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#LOI Manager, didRemoveGeofenceWithId, regionId:%{private, location:escape_only}@, error:%{private, location:escape_only}@}",  (uint8_t *)&v8,  0x26u);
    }
  }

void *sub_1000D9AD4@<X0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int16 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        unint64_t v36 = "";
        __int16 v37 = 2081;
        std::string v38 = v14;
        __int16 v39 = 2081;
        uint64_t v40 = v15;
        __int16 v41 = 2082;
        BOOL v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int16 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        unint64_t v36 = "";
        __int16 v37 = 2081;
        std::string v38 = v21;
        __int16 v39 = 2081;
        uint64_t v40 = v22;
        __int16 v41 = 2082;
        BOOL v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        uint64_t v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        unint64_t v36 = "";
        __int16 v37 = 2081;
        std::string v38 = v27;
        __int16 v39 = 2081;
        uint64_t v40 = v28;
        __int16 v41 = 2082;
        BOOL v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CDA7C((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000D9F38( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000D9F64@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int16 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2081;
        *(void *)&buf[20] = v14;
        __int16 v34 = 2081;
        __int16 v35 = v15;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int16 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2081;
        *(void *)&buf[20] = v21;
        __int16 v34 = 2081;
        __int16 v35 = v22;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        uint64_t v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2081;
        *(void *)&buf[20] = v27;
        __int16 v34 = 2081;
        __int16 v35 = v28;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  sub_1000D5B78((uint64_t)v5, v6[4], v6[5], buf);
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000DA3E4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DA410@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int16 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2081;
        *(void *)&buf[20] = v14;
        __int16 v34 = 2081;
        __int16 v35 = v15;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int16 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2081;
        *(void *)&buf[20] = v21;
        __int16 v34 = 2081;
        __int16 v35 = v22;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        uint64_t v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2081;
        *(void *)&buf[20] = v27;
        __int16 v34 = 2081;
        __int16 v35 = v28;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  sub_1000D5E00((uint64_t)v5, v6[4], v6[5], v6[6], v6[7], (uint64_t)buf);
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000DA894( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DA8C0@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int16 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        uint64_t v40 = v15;
        __int16 v41 = 2082;
        BOOL v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int16 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        uint64_t v40 = v22;
        __int16 v41 = 2082;
        BOOL v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        uint64_t v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        uint64_t v40 = v28;
        __int16 v41 = 2082;
        BOOL v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CDF20((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000DAD24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000DAD50@<X0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int16 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        uint64_t v40 = v15;
        __int16 v41 = 2082;
        BOOL v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int16 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        uint64_t v40 = v22;
        __int16 v41 = 2082;
        BOOL v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        uint64_t v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        uint64_t v40 = v28;
        __int16 v41 = 2082;
        BOOL v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CE260((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000DB1B4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DB1E0@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        int v9 = (char *)v5[2];
        if (v9[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }

        else
        {
          __int128 v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)std::string __dst = v10;
        }

        int v11 = SHIBYTE(v31);
        int v12 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          __int16 v14 = __p;
        }
        else {
          __int16 v14 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v15 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        uint64_t v16 = (char *)v5[2];
        if (v16[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }

        else
        {
          __int128 v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)std::string __dst = v17;
        }

        int v18 = SHIBYTE(v31);
        int v19 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v20 = __dst;
        if (v18 < 0) {
          __int16 v20 = v19;
        }
        if (v29 >= 0) {
          id v21 = __p;
        }
        else {
          id v21 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      __int16 v22 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        char v23 = (char *)v5[2];
        if (v23[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }

        else
        {
          __int128 v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)std::string __dst = v24;
        }

        int v25 = SHIBYTE(v31);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        int v26 = __dst;
        if (v25 < 0) {
          int v26 = p_vtable;
        }
        if (v29 >= 0) {
          char v27 = __p;
        }
        else {
          char v27 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CE5F4((uint64_t)v5, a3);
}

void sub_1000DB640( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DB66C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CE7D4((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000DBAD0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DBAFC@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        int v9 = (char *)v5[2];
        if (v9[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }

        else
        {
          __int128 v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)std::string __dst = v10;
        }

        int v11 = SHIBYTE(v31);
        int v12 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          __int16 v14 = __p;
        }
        else {
          __int16 v14 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v15 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        uint64_t v16 = (char *)v5[2];
        if (v16[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }

        else
        {
          __int128 v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)std::string __dst = v17;
        }

        int v18 = SHIBYTE(v31);
        int v19 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v20 = __dst;
        if (v18 < 0) {
          __int16 v20 = v19;
        }
        if (v29 >= 0) {
          id v21 = __p;
        }
        else {
          id v21 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      __int16 v22 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        char v23 = (char *)v5[2];
        if (v23[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }

        else
        {
          __int128 v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)std::string __dst = v24;
        }

        int v25 = SHIBYTE(v31);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        int v26 = __dst;
        if (v25 < 0) {
          int v26 = p_vtable;
        }
        if (v29 >= 0) {
          char v27 = __p;
        }
        else {
          char v27 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CE894((uint64_t)v5, a3);
}

void sub_1000DBF5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DBF88@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CE9B0((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000DC3EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DC418@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CEB88((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000DC87C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DC8A8@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CEED4((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000DCD0C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DCD38@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CEFA0(v5, (uint64_t)v6, a3);
}

void sub_1000DD19C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DD1C8@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CF64C(v5, (uint64_t)v6, a3);
}

void sub_1000DD62C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DD658@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CFCD0((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000DDABC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DDAE8@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CFD70(v5, v6, a3);
}

void sub_1000DDF4C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000DDF78(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2 - 8;
  if (!a2) {
    uint64_t v2 = 0LL;
  }
  *(_WORD *)(v2 + 488) = 1;
}

double sub_1000DDF90@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CFF08((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000DE3F4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DE420@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2081;
        *(void *)&buf[20] = v14;
        __int16 v34 = 2081;
        __int16 v35 = v15;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2081;
        *(void *)&buf[20] = v21;
        __int16 v34 = 2081;
        __int16 v35 = v22;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2081;
        *(void *)&buf[20] = v27;
        __int16 v34 = 2081;
        __int16 v35 = v28;
        __int16 v36 = 2082;
        __int16 v37 = "assert";
        __int16 v38 = 2081;
        __int16 v39 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  sub_1000D58F4((uint64_t)v5, v6[4], v6[5], buf);
  double result = *(double *)buf;
  *(_OWORD *)a3 = *(_OWORD *)buf;
  *(void *)(a3 + 16) = *(void *)&buf[16];
  *(_BYTE *)(a3 + 24) = 1;
  return result;
}

void sub_1000DE8A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DE8CC@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000CFF98((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000DED30( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DED5C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000D0B64((uint64_t)v5, v6, a3);
}

void sub_1000DF1C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000DF1EC(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        int v9 = (char *)v5[2];
        if (v9[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v9 + 1), *((void *)v9 + 2));
        }

        else
        {
          __int128 v10 = *(_OWORD *)(v9 + 8);
          uint64_t v31 = *((void *)v9 + 3);
          *(_OWORD *)std::string __dst = v10;
        }

        int v11 = SHIBYTE(v31);
        int v12 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        uint64_t v13 = __dst;
        if (v11 < 0) {
          uint64_t v13 = v12;
        }
        if (v29 >= 0) {
          __int16 v14 = __p;
        }
        else {
          __int16 v14 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v13;
        __int16 v38 = 2081;
        __int16 v39 = v14;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v15 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        uint64_t v16 = (char *)v5[2];
        if (v16[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v16 + 1), *((void *)v16 + 2));
        }

        else
        {
          __int128 v17 = *(_OWORD *)(v16 + 8);
          uint64_t v31 = *((void *)v16 + 3);
          *(_OWORD *)std::string __dst = v17;
        }

        int v18 = SHIBYTE(v31);
        int v19 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v20 = __dst;
        if (v18 < 0) {
          __int16 v20 = v19;
        }
        if (v29 >= 0) {
          id v21 = __p;
        }
        else {
          id v21 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v20;
        __int16 v38 = 2081;
        __int16 v39 = v21;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      __int16 v22 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        char v23 = (char *)v5[2];
        if (v23[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v23 + 1), *((void *)v23 + 2));
        }

        else
        {
          __int128 v24 = *(_OWORD *)(v23 + 8);
          uint64_t v31 = *((void *)v23 + 3);
          *(_OWORD *)std::string __dst = v24;
        }

        int v25 = SHIBYTE(v31);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        int v26 = __dst;
        if (v25 < 0) {
          int v26 = p_vtable;
        }
        if (v29 >= 0) {
          char v27 = __p;
        }
        else {
          char v27 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v33 = 0;
        __int16 v34 = 2082;
        __int16 v35 = "";
        __int16 v36 = 2081;
        __int16 v37 = v26;
        __int16 v38 = 2081;
        __int16 v39 = v27;
        __int16 v40 = 2082;
        __int16 v41 = "assert";
        __int16 v42 = 2081;
        __int16 v43 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v29 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v31) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  sub_1000D0EEC((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000DF650( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DF67C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000D1A38((uint64_t)v5, v6, a3);
}

void sub_1000DFAE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DFB0C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000D1EF8((uint64_t)v5, v6, a3);
}

void sub_1000DFF70( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000DFF9C@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000D2480((uint64_t)v5, v6, a3);
}

void sub_1000E0400( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000E042C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2 - 8;
  if (!a2) {
    uint64_t v2 = 0LL;
  }
  *(_WORD *)(v2 + 490) = 1;
}

double sub_1000E0444@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000D2808(v5, (uint64_t)v6, a3);
}

void sub_1000E08A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000E08D4@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000D2D40((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000E0D38( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000E0D64@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000D3244((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000E11C8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000E11F4@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000D367C((uint64_t)v5, v6, a3);
}

void sub_1000E1658( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000E1684@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000D3B24((uint64_t)v5, (uint64_t)v6, a3);
}

void sub_1000E1AE8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000E1B14@<D0>(char *lpsrc@<X2>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2) {
    CFStringRef v5 = (void **)(a2 - 8);
  }
  else {
    CFStringRef v5 = 0LL;
  }
  if (!lpsrc
  {
    p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
    if (qword_1019348D0 != -1) {
      goto LABEL_52;
    }
    while (1)
    {
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        __int128 v10 = (char *)v5[2];
        if (v10[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v10 + 1), *((void *)v10 + 2));
        }

        else
        {
          __int128 v11 = *(_OWORD *)(v10 + 8);
          uint64_t v32 = *((void *)v10 + 3);
          *(_OWORD *)std::string __dst = v11;
        }

        int v12 = SHIBYTE(v32);
        uint64_t v13 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        __int16 v14 = __dst;
        if (v12 < 0) {
          __int16 v14 = v13;
        }
        if (v30 >= 0) {
          uint64_t v15 = __p;
        }
        else {
          uint64_t v15 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v14;
        __int16 v39 = 2081;
        __int16 v40 = v15;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        __int128 v17 = (char *)v5[2];
        if (v17[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v17 + 1), *((void *)v17 + 2));
        }

        else
        {
          __int128 v18 = *(_OWORD *)(v17 + 8);
          uint64_t v32 = *((void *)v17 + 3);
          *(_OWORD *)std::string __dst = v18;
        }

        int v19 = SHIBYTE(v32);
        __int16 v20 = (void **)__dst[0];
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        id v21 = __dst;
        if (v19 < 0) {
          id v21 = v20;
        }
        if (v30 >= 0) {
          __int16 v22 = __p;
        }
        else {
          __int16 v22 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v21;
        __int16 v39 = 2081;
        __int16 v40 = v22;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Received unsupported event in state event handler",  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      char v23 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        __int128 v24 = (char *)v5[2];
        if (v24[31] < 0)
        {
          sub_1010DD48C(__dst, *((void **)v24 + 1), *((void *)v24 + 2));
        }

        else
        {
          __int128 v25 = *(_OWORD *)(v24 + 8);
          uint64_t v32 = *((void *)v24 + 3);
          *(_OWORD *)std::string __dst = v25;
        }

        int v26 = SHIBYTE(v32);
        p_vtable = (void **)__dst[0];
        CFStringRef v5 = __p;
        sub_10008D2C8(lpsrc, (uint64_t)__p);
        char v27 = __dst;
        if (v26 < 0) {
          char v27 = p_vtable;
        }
        if (v30 >= 0) {
          uint64_t v28 = __p;
        }
        else {
          uint64_t v28 = (void **)__p[0];
        }
        *(_DWORD *)__int128 buf = 68290051;
        int v34 = 0;
        __int16 v35 = 2082;
        __int16 v36 = "";
        __int16 v37 = 2081;
        __int16 v38 = v27;
        __int16 v39 = 2081;
        __int16 v40 = v28;
        __int16 v41 = 2082;
        __int16 v42 = "assert";
        __int16 v43 = 2081;
        __n128 v44 = "derivedEventData != __null";
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received unsupported event in state event handler, State:%{private, location:esca pe_only}s, Received Event:%{private, location:escape_only}s, event:%{public, location:escape_only}s,  condition:%{private, location:escape_only}s}",  buf,  0x3Au);
        if (v30 < 0) {
          operator delete(__p[0]);
        }
        if (SHIBYTE(v32) < 0) {
          operator delete(__dst[0]);
        }
      }

      sub_101229034();
      __break(1u);
LABEL_52:
      dispatch_once(&qword_1019348D0, &stru_10181EA08);
    }
  }

  return sub_1000D3F94((uint64_t)v5, v6, a3);
}

void sub_1000E1F78( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000E1FA4(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1000E1FD0(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000E1FE4(a1);
  operator delete(v1);
}

uint64_t sub_1000E1FE4(uint64_t a1)
{
  *(void *)a1 = off_10181EA78;

  *(void *)a1 = &off_10181D7E8;
  return a1;
}

void *sub_1000E2040(void *a1)
{
  *a1 = &off_10181D7E8;
  uint64_t v2 = (std::string *)sub_1010DDBC0(a1 + 1, "No Name Given");
  *a1 = &off_10181EA98;
  std::string::assign(v2, "Refresh Location on regular interval");
  return a1;
}

void sub_1000E20A8(_Unwind_Exception *exception_object)
{
  uint64_t v4 = v3;
  *(void *)uint64_t v1 = v4;
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000E20CC(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    goto LABEL_32;
  }
  CFStringRef v5 = (signed __int8 *)(a2 + 1);
  int v6 = *a2;
  if (v6 == 123)
  {
    CFStringRef v5 = (signed __int8 *)(a2 + 2);
    signed __int8 v7 = a2[1];
  }

  else
  {
    signed __int8 v7 = *a2;
  }

  int v8 = 0;
  uint64_t v9 = 0LL;
  while (1)
  {
    do
    {
      if ((_DWORD)v9 == 4)
      {
        if (v7 == 45)
        {
          int v8 = 1;
LABEL_22:
          signed __int8 v12 = *v5++;
          signed __int8 v7 = v12;
          goto LABEL_24;
        }

        int v8 = 0;
      }

      else
      {
        BOOL v11 = (v9 & 0x7FFFFFFD) == 8 || (_DWORD)v9 == 6;
        if (v11 && ((v8 ^ 1) & 1) == 0)
        {
          goto LABEL_22;
        }
      }

void sub_1000E2268(id *a1)
{
  *a1 = off_10181EAB8;

  *a1 = &off_10181D7E8;
  operator delete(a1);
}

void sub_1000E22C4(id *a1)
{
  *a1 = off_10181EAD8;

  *a1 = &off_10181D7E8;
  operator delete(a1);
}

void *sub_1000E2320(void *a1)
{
  *a1 = &off_10181D7E8;
  uint64_t v2 = (std::string *)sub_1010DDBC0(a1 + 1, "No Name Given");
  *a1 = &off_10181EAF8;
  std::string::assign(v2, "Failed To Fetched Place Inference");
  return a1;
}

void sub_1000E2388(_Unwind_Exception *exception_object)
{
  uint64_t v4 = v3;
  *(void *)uint64_t v1 = v4;
  _Unwind_Resume(exception_object);
}

void sub_1000E23AC(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000E23C0(a1);
  operator delete(v1);
}

uint64_t sub_1000E23C0(uint64_t a1)
{
  *(void *)a1 = off_10181EB18;

  *(void *)a1 = &off_10181D7E8;
  return a1;
}

void *sub_1000E241C(void *a1)
{
  *a1 = &off_10181D7E8;
  uint64_t v2 = (std::string *)sub_1010DDBC0(a1 + 1, "No Name Given");
  *a1 = &off_10181EB38;
  std::string::assign(v2, "Failed to Get LOI Event");
  return a1;
}

void sub_1000E2484(_Unwind_Exception *exception_object)
{
  uint64_t v4 = v3;
  *(void *)uint64_t v1 = v4;
  _Unwind_Resume(exception_object);
}

void sub_1000E24A8(id *a1)
{
  *a1 = off_10181EB58;

  *a1 = &off_10181D7E8;
  operator delete(a1);
}

void *sub_1000E2504(void *a1)
{
  *a1 = &off_10181D7E8;
  uint64_t v2 = (std::string *)sub_1010DDBC0(a1 + 1, "No Name Given");
  *a1 = &off_10181EB78;
  std::string::assign(v2, "Failed to Get Related LOIs");
  return a1;
}

void sub_1000E256C(_Unwind_Exception *exception_object)
{
  uint64_t v4 = v3;
  *(void *)uint64_t v1 = v4;
  _Unwind_Resume(exception_object);
}

void sub_1000E2590(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000E25A4(a1);
  operator delete(v1);
}

uint64_t sub_1000E25A4(uint64_t a1)
{
  *(void *)a1 = off_10181EB98;
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(void *)(a1 + 40) = v2;
    operator delete(v2);
  }

  *(void *)a1 = &off_10181D7E8;
  return a1;
}

void *sub_1000E2604(void *a1)
{
  *a1 = &off_10181D7E8;
  uint64_t v2 = (std::string *)sub_1010DDBC0(a1 + 1, "No Name Given");
  *a1 = &off_10181EBB8;
  std::string::assign(v2, "Failed To Get Location Update");
  return a1;
}

void sub_1000E266C(_Unwind_Exception *exception_object)
{
  uint64_t v4 = v3;
  *(void *)uint64_t v1 = v4;
  _Unwind_Resume(exception_object);
}

void *sub_1000E2690(void *a1, void *a2)
{
  *a1 = &off_10181D7E8;
  uint64_t v4 = (std::string *)(a1 + 1);
  sub_1010DDBC0(a1 + 1, "No Name Given");
  *a1 = off_10181EBD8;
  a1[4] = a2;
  std::string::assign(v4, "Got Location Update");
  return a1;
}

void sub_1000E2708(_Unwind_Exception *exception_object)
{
  *(void *)uint64_t v1 = v3;
  _Unwind_Resume(exception_object);
}

void sub_1000E2728(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1000E273C(a1);
  operator delete(v1);
}

uint64_t sub_1000E273C(uint64_t a1)
{
  *(void *)a1 = off_10181EBD8;

  *(void *)a1 = &off_10181D7E8;
  return a1;
}

void *sub_1000E2798(void *a1)
{
  *a1 = &off_10181D7E8;
  uint64_t v2 = (std::string *)sub_1010DDBC0(a1 + 1, "No Name Given");
  *a1 = &off_10181EBF8;
  std::string::assign(v2, "Failed To Set Geofence");
  return a1;
}

void sub_1000E2800(_Unwind_Exception *exception_object)
{
  uint64_t v4 = v3;
  *(void *)uint64_t v1 = v4;
  _Unwind_Resume(exception_object);
}

std::runtime_error *sub_1000E2824(std::runtime_error *a1, const std::string *a2)
{
  double result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&off_10181CC18;
  return result;
}

void *sub_1000E2848@<X0>( unsigned int a1@<W0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  if (a1 >= 2) {
    sub_10122A124();
  }
  if (a1) {
    double result = sub_1000E2A44(a2, a3, a4, a5, &v8);
  }
  else {
    double result = sub_1000E28B4(a2, a3, a4, a5, &v8);
  }
  *a6 = v8;
  return result;
}

void *sub_1000E28B4@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  signed __int8 v10 = operator new(0x148uLL);
  sub_10001A504((uint64_t)v17, a1);
  sub_10001A504((uint64_t)v15, a2);
  sub_10003EF40((uint64_t)v10, (uint64_t)v17, (uint64_t)v15, a3, a4);
  *a5 = v10;
  BOOL v11 = v16;
  if (v16 == v15)
  {
    uint64_t v12 = 4LL;
    BOOL v11 = v15;
  }

  else
  {
    if (!v16) {
      goto LABEL_6;
    }
    uint64_t v12 = 5LL;
  }

  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_6:
  double result = v18;
  if (v18 == v17)
  {
    uint64_t v14 = 4LL;
    double result = v17;
  }

  else
  {
    if (!v18) {
      return result;
    }
    uint64_t v14 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v14))();
}

void sub_1000E29C4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  __int16 v20 = a13;
  if (a13 == v18)
  {
    uint64_t v21 = 4LL;
    __int16 v20 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v21 = 5LL;
  }

  (*(void (**)(void))(*(void *)v20 + 8 * v21))();
LABEL_6:
  __int16 v22 = a17;
  if (a17 == &a14)
  {
    uint64_t v23 = 4LL;
    __int16 v22 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_11;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void))(*(void *)v22 + 8 * v23))();
LABEL_11:
  operator delete(v17);
  _Unwind_Resume(a1);
}

void *sub_1000E2A44@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  signed __int8 v10 = operator new(0x20uLL);
  sub_10001A504((uint64_t)v17, a1);
  sub_10001A504((uint64_t)v15, a2);
  sub_100149C58(v10, v17, v15, a3, a4);
  *a5 = v10;
  BOOL v11 = v16;
  if (v16 == v15)
  {
    uint64_t v12 = 4LL;
    BOOL v11 = v15;
  }

  else
  {
    if (!v16) {
      goto LABEL_6;
    }
    uint64_t v12 = 5LL;
  }

  (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_6:
  double result = v18;
  if (v18 == v17)
  {
    uint64_t v14 = 4LL;
    double result = v17;
  }

  else
  {
    if (!v18) {
      return result;
    }
    uint64_t v14 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v14))();
}

void sub_1000E2B54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, char a14, uint64_t a15, uint64_t a16, char *a17)
{
  __int16 v20 = a13;
  if (a13 == v18)
  {
    uint64_t v21 = 4LL;
    __int16 v20 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v21 = 5LL;
  }

  (*(void (**)(void))(*(void *)v20 + 8 * v21))();
LABEL_6:
  __int16 v22 = a17;
  if (a17 == &a14)
  {
    uint64_t v23 = 4LL;
    __int16 v22 = &a14;
  }

  else
  {
    if (!a17) {
      goto LABEL_11;
    }
    uint64_t v23 = 5LL;
  }

  (*(void (**)(void))(*(void *)v22 + 8 * v23))();
LABEL_11:
  operator delete(v17);
  _Unwind_Resume(a1);
}

void sub_1000E2BD4(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1000E2C00(void **a1@<X1>, void *a2@<X2>, double *a3@<X3>, _BYTE *a4@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EC88);
  }
  uint64_t v8 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint64_t v9 = *a1;
    }
    *(_DWORD *)__int128 buf = 68289282;
    int v15 = 0;
    __int16 v16 = 2082;
    uint64_t v17 = "";
    __int16 v18 = 2082;
    int v19 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMicroLocationLegacyEventRecordingRequest: client request recording scan, client:%{p ublic, location:escape_only}s}",  buf,  0x1Cu);
  }

  else {
    std::string __p = *(std::string *)a1;
  }
  char v12 = 1;
  sub_100102D00(&__p, a2, (uint64_t)v13);
  sub_1000E2E30((uint64_t)v13, 0, 0, 3u, (uint64_t)v10, *a3);
  buf[0] = 1;
  sub_1000865CC(&v16);
  *a4 = buf[0];
  sub_1000865CC(a4 + 8);
  sub_100086708(&v16);
  sub_100086708(v10);
  sub_1000721B8((wireless_diagnostics::google::protobuf::MessageLite *)v13);
}

void sub_1000E2DD4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_1000E2E10( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32, char a33)
{
  if (a33)
  {
    if (a32 < 0) {
      operator delete(__p);
    }
  }

  JUMPOUT(0x1000E2E08LL);
}

void sub_1000E2E30( uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12 = *(_DWORD *)(a1 + 8);
  if (!sub_100064160(v12))
  {
    uint64_t v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    __int16 v16 = "set_eventtype";
    goto LABEL_6;
  }

  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_100064130(a4) & 1) == 0)
  {
    uint64_t v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    __int16 v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }

  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_100101F14(a5, a1);
}

void sub_1000E2F14(_Unwind_Exception *a1)
{
}

void sub_1000E2F28(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1000E2F54(void *a1@<X1>, double *a2@<X2>, _BYTE *a3@<X8>)
{
  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetUUID"]) {
    sub_1000E2FB4(a1, a2, a3);
  }
  else {
    sub_1000E34EC(a1, a2, a3);
  }
}

void sub_1000E2FB4(void *a1@<X1>, double *a2@<X2>, _BYTE *a3@<X8>)
{
  if ([a1 objectForKeyedSubscript:@"shouldTriggerLocalizationScan"])
  {
    unsigned __int8 v6 = objc_msgSend( objc_msgSend(a1, "objectForKeyedSubscript:", @"shouldTriggerLocalizationScan"),  "BOOLValue");
    v37 |= 0x100u;
    unsigned __int8 v33 = v6;
  }

  if ([a1 objectForKeyedSubscript:@"shouldTriggerRecordingScan"])
  {
    unsigned __int8 v7 = objc_msgSend( objc_msgSend(a1, "objectForKeyedSubscript:", @"shouldTriggerRecordingScan"),  "BOOLValue");
    v37 |= 0x200u;
    unsigned __int8 v34 = v7;
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetUUID"])
  {
    uint64_t v8 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.scene.actionSetUUID"),  "UTF8String");
    v37 |= 2u;
    uint64_t v9 = v29;
    if (v29 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v9 = (std::string *)operator new(0x18uLL);
      v9->__r_.__value_.__r.__words[0] = 0LL;
      v9->__r_.__value_.__l.__size_ = 0LL;
      v9->__r_.__value_.__l.__cap_ = 0LL;
      char v29 = v9;
    }

    std::string::assign(v9, v8);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetName"])
  {
    signed __int8 v10 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.scene.actionSetName"),  "UTF8String");
    v37 |= 4u;
    BOOL v11 = v30;
    if (v30 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      BOOL v11 = (std::string *)operator new(0x18uLL);
      v11->__r_.__value_.__r.__words[0] = 0LL;
      v11->__r_.__value_.__l.__size_ = 0LL;
      v11->__r_.__value_.__l.__cap_ = 0LL;
      char v30 = v11;
    }

    std::string::assign(v11, v10);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetType"])
  {
    unsigned int v12 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.scene.actionSetType"),  "UTF8String");
    v37 |= 8u;
    int v13 = v31;
    if (v31 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      int v13 = (std::string *)operator new(0x18uLL);
      v13->__r_.__value_.__r.__words[0] = 0LL;
      v13->__r_.__value_.__l.__size_ = 0LL;
      v13->__r_.__value_.__l.__cap_ = 0LL;
      uint64_t v31 = v13;
    }

    std::string::assign(v13, v12);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.clientName"])
  {
    uint64_t v14 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.scene.clientName"),  "UTF8String");
    v37 |= 0x20u;
    int v15 = v32;
    if (v32 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      int v15 = (std::string *)operator new(0x18uLL);
      v15->__r_.__value_.__r.__words[0] = 0LL;
      v15->__r_.__value_.__l.__size_ = 0LL;
      v15->__r_.__value_.__l.__cap_ = 0LL;
      uint64_t v32 = v15;
    }

    std::string::assign(v15, v14);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.source"])
  {
    __int16 v16 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.scene.source"),  "UTF8String");
    v37 |= 0x80u;
    uint64_t v17 = v35;
    if (v35 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v17 = (std::string *)operator new(0x18uLL);
      v17->__r_.__value_.__r.__words[0] = 0LL;
      v17->__r_.__value_.__l.__size_ = 0LL;
      v17->__r_.__value_.__l.__cap_ = 0LL;
      __int16 v35 = v17;
    }

    std::string::assign(v17, v16);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.scene.homeName"])
  {
    __int16 v18 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.scene.homeName"),  "UTF8String");
    v37 |= 0x400u;
    int v19 = v36;
    if (v36 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      int v19 = (std::string *)operator new(0x18uLL);
      v19->__r_.__value_.__r.__words[0] = 0LL;
      v19->__r_.__value_.__l.__size_ = 0LL;
      v19->__r_.__value_.__l.__cap_ = 0LL;
      __int16 v36 = v19;
    }

    std::string::assign(v19, v18);
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181ECA8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    __int16 v20 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v21 = v29;
      __int16 v22 = v30;
      uint64_t v23 = v31;
      __int128 v24 = v32;
      __int128 v25 = v35;
      int v26 = v36;
      uint64_t buf = 68291075LL;
      __int16 v39 = 2082;
      __int16 v40 = "";
      __int16 v41 = 2081;
      __int16 v42 = v21;
      __int16 v43 = 2081;
      __n128 v44 = v22;
      __int16 v45 = 2081;
      std::string v46 = v23;
      __int16 v47 = 2081;
      uint64_t v48 = v24;
      __int16 v49 = 2081;
      uint64_t v50 = v25;
      __int16 v51 = 2081;
      uint64_t v52 = v26;
      __int16 v53 = 1025;
      int v54 = v33;
      __int16 v55 = 1025;
      int v56 = v34;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:HomeKit Scene, actionSetUUID:%{private, location:escape_only}s, actionSetName:% {private, location:escape_only}s, actionSetType:%{private, location:escape_only}s, clientName:%{private, location:escape_only}s, source:%{private, location:escape_only}s, homeName:%{private, location:escape_o nly}s, triggerLocalization:%{private}hhd, triggerRecording:%{private}hhd}",  (uint8_t *)&buf,  0x5Au);
    }
  }

  sub_1000E3B80((uint64_t)v28, 0, 0, 3u, (uint64_t)v27, *a2);
  LOBYTE(buf) = 1;
  sub_1000865CC(&v39);
  *a3 = buf;
  sub_1000865CC(a3 + 8);
  sub_100086708(&v39);
  sub_100086708(v27);
  sub_100076868((wireless_diagnostics::google::protobuf::MessageLite *)v28);
}

void sub_1000E34AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

void sub_1000E34EC(void *a1@<X1>, double *a2@<X2>, _BYTE *a3@<X8>)
{
  if ([a1 objectForKeyedSubscript:@"shouldTriggerLocalizationScan"])
  {
    unsigned __int8 v6 = objc_msgSend( objc_msgSend(a1, "objectForKeyedSubscript:", @"shouldTriggerLocalizationScan"),  "BOOLValue");
    v45 |= 0x400u;
    unsigned __int8 v38 = v6;
  }

  if ([a1 objectForKeyedSubscript:@"shouldTriggerRecordingScan"])
  {
    unsigned __int8 v7 = objc_msgSend( objc_msgSend(a1, "objectForKeyedSubscript:", @"shouldTriggerRecordingScan"),  "BOOLValue");
    v45 |= 0x800u;
    unsigned __int8 v39 = v7;
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.accessoryUUID"])
  {
    uint64_t v8 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.accessory.accessoryUUID"),  "UTF8String");
    v45 |= 2u;
    uint64_t v9 = v35;
    if (v35 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v9 = (std::string *)operator new(0x18uLL);
      v9->__r_.__value_.__r.__words[0] = 0LL;
      v9->__r_.__value_.__l.__size_ = 0LL;
      v9->__r_.__value_.__l.__cap_ = 0LL;
      __int16 v35 = v9;
    }

    std::string::assign(v9, v8);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceType"])
  {
    signed __int8 v10 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.accessory.serviceType"),  "UTF8String");
    v45 |= 0x10u;
    BOOL v11 = v36;
    if (v36 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      BOOL v11 = (std::string *)operator new(0x18uLL);
      v11->__r_.__value_.__r.__words[0] = 0LL;
      v11->__r_.__value_.__l.__size_ = 0LL;
      v11->__r_.__value_.__l.__cap_ = 0LL;
      __int16 v36 = v11;
    }

    std::string::assign(v11, v10);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.characteristicType"])
  {
    unsigned int v12 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.accessory.characteristicType"),  "UTF8String");
    v45 |= 0x20u;
    int v13 = v37;
    if (v37 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      int v13 = (std::string *)operator new(0x18uLL);
      v13->__r_.__value_.__r.__words[0] = 0LL;
      v13->__r_.__value_.__l.__size_ = 0LL;
      v13->__r_.__value_.__l.__cap_ = 0LL;
      int v37 = v13;
    }

    std::string::assign(v13, v12);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.source"])
  {
    uint64_t v14 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.accessory.source"),  "UTF8String");
    v45 |= 0x100u;
    int v15 = v40;
    if (v40 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      int v15 = (std::string *)operator new(0x18uLL);
      v15->__r_.__value_.__r.__words[0] = 0LL;
      v15->__r_.__value_.__l.__size_ = 0LL;
      v15->__r_.__value_.__l.__cap_ = 0LL;
      __int16 v40 = v15;
    }

    std::string::assign(v15, v14);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.stateString"])
  {
    __int16 v16 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.accessory.stateString"),  "UTF8String");
    v45 |= 0x1000u;
    uint64_t v17 = v42;
    if (v42 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v17 = (std::string *)operator new(0x18uLL);
      v17->__r_.__value_.__r.__words[0] = 0LL;
      v17->__r_.__value_.__l.__size_ = 0LL;
      v17->__r_.__value_.__l.__cap_ = 0LL;
      __int16 v42 = v17;
    }

    std::string::assign(v17, v16);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceUUID"])
  {
    __int16 v18 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.accessory.serviceUUID"),  "UTF8String");
    v45 |= 0x200u;
    int v19 = v41;
    if (v41 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      int v19 = (std::string *)operator new(0x18uLL);
      v19->__r_.__value_.__r.__words[0] = 0LL;
      v19->__r_.__value_.__l.__size_ = 0LL;
      v19->__r_.__value_.__l.__cap_ = 0LL;
      __int16 v41 = v19;
    }

    std::string::assign(v19, v18);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.serviceGroupUUID"])
  {
    __int16 v20 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.accessory.serviceGroupUUID"),  "UTF8String");
    v45 |= 0x2000u;
    uint64_t v21 = v43;
    if (v43 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v21 = (std::string *)operator new(0x18uLL);
      v21->__r_.__value_.__r.__words[0] = 0LL;
      v21->__r_.__value_.__l.__size_ = 0LL;
      v21->__r_.__value_.__l.__cap_ = 0LL;
      __int16 v43 = v21;
    }

    std::string::assign(v21, v20);
  }

  if ([a1 objectForKeyedSubscript:@"private.HomeKit.accessory.roomUUID"])
  {
    __int16 v22 = (const std::string::value_type *)objc_msgSend( objc_msgSend( a1,  "objectForKeyedSubscript:",  @"private.HomeKit.accessory.roomUUID"),  "UTF8String");
    v45 |= 0x4000u;
    uint64_t v23 = v44;
    if (v44 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v23 = (std::string *)operator new(0x18uLL);
      v23->__r_.__value_.__r.__words[0] = 0LL;
      v23->__r_.__value_.__l.__size_ = 0LL;
      v23->__r_.__value_.__l.__cap_ = 0LL;
      __n128 v44 = v23;
    }

    std::string::assign(v23, v22);
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181ECA8);
  }
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    __int128 v24 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      __int128 v25 = v35;
      uint64_t v26 = v42;
      char v27 = v41;
      uint64_t v28 = v43;
      char v29 = v36;
      char v30 = v37;
      uint64_t v31 = v40;
      uint64_t v32 = v44;
      *(_DWORD *)uint64_t buf = 68291587;
      __int16 v48 = 2082;
      int v47 = 0;
      __int16 v49 = "";
      __int16 v50 = 2081;
      __int16 v51 = v25;
      __int16 v52 = 2081;
      __int16 v53 = v26;
      __int16 v54 = 2081;
      __int16 v55 = v27;
      __int16 v56 = 2081;
      char v57 = v28;
      __int16 v58 = 2081;
      std::string v59 = v29;
      __int16 v60 = 2081;
      std::string v61 = v30;
      __int16 v62 = 2081;
      char v63 = v31;
      __int16 v64 = 2081;
      std::string v65 = v32;
      __int16 v66 = 1025;
      int v67 = v38;
      __int16 v68 = 1025;
      int v69 = v39;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:HomeKit Accessory, accessoryUUID:%{private, location:escape_only}s, accessoryStat e:%{private, location:escape_only}s, serviceUUID:%{private, location:escape_only}s, serviceGroupUUID:% {private, location:escape_only}s, serviceType:%{private, location:escape_only}s, characteristicType:%{pr ivate, location:escape_only}s, source:%{private, location:escape_only}s, roomUUID:%{private, location:es cape_only}s, triggerLocalization:%{private}hhd, triggerRecording:%{private}hhd}",  buf,  0x6Eu);
    }
  }

  sub_1000E3C78((uint64_t)v34, 0, 0, 3u, (uint64_t)v33, *a2);
  buf[0] = 1;
  sub_1000865CC(&v48);
  *a3 = buf[0];
  sub_1000865CC(a3 + 8);
  sub_100086708(&v48);
  sub_100086708(v33);
  sub_10007510C((wireless_diagnostics::google::protobuf::MessageLite *)v34);
}

void sub_1000E3ADC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

BOOL sub_1000E3B1C(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0LL;
  }
  if ([a2 objectForKeyedSubscript:@"private.HomeKit.accessory.accessoryUUID"]) {
    return 1LL;
  }
  return [a2 objectForKeyedSubscript:@"private.HomeKit.scene.actionSetUUID"] != 0;
}

void sub_1000E3B80( uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12 = *(_DWORD *)(a1 + 48);
  if (!sub_100064160(v12))
  {
    uint64_t v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    __int16 v16 = "set_eventtype";
    goto LABEL_6;
  }

  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_100064130(a4) & 1) == 0)
  {
    uint64_t v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    __int16 v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }

  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_100101C8C(a5, a1);
}

void sub_1000E3C64(_Unwind_Exception *a1)
{
}

void sub_1000E3C78( uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12 = *(_DWORD *)(a1 + 64);
  if (!sub_100064160(v12))
  {
    uint64_t v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    __int16 v16 = "set_eventtype";
    goto LABEL_6;
  }

  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 128) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_100064130(a4) & 1) == 0)
  {
    uint64_t v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    __int16 v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }

  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_100101C20(a5, a1);
}

void sub_1000E3D5C(_Unwind_Exception *a1)
{
}

void sub_1000E3D70(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

double sub_1000E3D9C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = off_10181ECD8;
  *(_WORD *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = a1 + 40;
  *(void *)(a1 + sub_10000AE14(v17 - 48) = a1 + 40;
  double result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0LL;
  *(_DWORD *)(a1 + 96) = 1065353216;
  *(void *)(a1 + 104) = a3;
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = a2;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 1065353216;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + sub_1000A7938(v46 - 224) = 0u;
  return result;
}

void sub_1000E3DFC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void **a4@<X8>)
{
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EDA0);
  }
  unsigned __int8 v6 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    else {
      uint64_t v7 = *(void *)a2;
    }
    *(_DWORD *)uint64_t buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    __int16 v25 = 2082;
    uint64_t v26 = "";
    __int16 v27 = 2082;
    uint64_t v28 = v7;
    __int16 v29 = 2050;
    uint64_t v30 = 0x2E8BA2E8BA2E8BA3LL * (v22 - v21);
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoServiceManager Client queried services, ClientId:%{public, location:escape_only }s, NumServicesFound:%{public}llu}",  buf,  0x26u);
  }

  uint64_t v9 = v21;
  uint64_t v8 = v22;
  if (v21 != v22)
  {
    __int16 v18 = a4;
    do
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EDA0);
      }
      signed __int8 v10 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        else {
          uint64_t v11 = *(void *)a2;
        }
        uint64_t v12 = *v9;
        int v13 = operator new(0x28uLL);
        std::string __p = v13;
        __int128 v20 = xmmword_1012C8460;
        _OWORD *v13 = 0u;
        v13[1] = 0u;
        *(void *)((char *)v13 + 29) = 0LL;
        sub_10000AE6C((uint64_t)(v9 + 1), v13);
        p_p = &__p;
        if (v20 < 0) {
          p_p = __p;
        }
        *(_DWORD *)uint64_t buf = 68289794;
        *(_DWORD *)&uint8_t buf[4] = 0;
        __int16 v25 = 2082;
        uint64_t v26 = "";
        __int16 v27 = 2082;
        uint64_t v28 = v11;
        __int16 v29 = 2050;
        uint64_t v30 = v12;
        __int16 v31 = 2082;
        uint64_t v32 = p_p;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoServiceManager Client query result, ClientId:%{public, location:escape_only }s, ServiceType:%{public}llu, ServiceUuid:%{public, location:escape_only}s}",  buf,  0x30u);
        if (SHIBYTE(v20) < 0) {
          operator delete(__p);
        }
      }

      v9 += 11;
    }

    while (v9 != v8);
    int v15 = v21;
    __int16 v16 = v22;
    uint64_t v23 = v18;
    while (v15 != v16)
    {
      uint64_t v17 = v15 + 1;
      sub_1000F0BA8((__n128 *)buf, (__n128 *)(v15 + 1), *v15, *((unsigned int *)v15 + 14));
      sub_1000EAB6C(&v23, buf);
      int v15 = v17 + 10;
    }
  }

  *(void *)uint64_t buf = &v21;
  sub_1000AA544((void ***)buf);
}

void sub_1000E40D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

void sub_1000E4128( uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  if (sub_100031790(*(void *)(a1 + 104)))
  {
    sub_10002D914(*(void *)(a1 + 104), a2, a5, &v36);
    unint64_t v12 = sub_1000F84B0(a4);
    unint64_t v35 = v12;
    int v13 = v36;
    uint64_t v14 = v37;
    if (v36 == v37)
    {
      unint64_t v15 = 0LL;
    }

    else
    {
      unint64_t v15 = 0LL;
      do
      {
        *(void *)uint64_t buf = sub_1000F0D94(v13[7]);
        unint64_t v12 = sub_1000EAC60(&v35, 0, (uint64_t)&v35, 0x20u, buf);
        uint64_t v16 = *v13;
        v13 += 11;
        if (v16 == a3) {
          uint64_t v17 = v12;
        }
        else {
          uint64_t v17 = 0LL;
        }
        v15 += v17;
      }

      while (v13 != v14);
    }

    if (sub_1000E4668(v12, a3, v15))
    {
      *(_DWORD *)uint64_t buf = 0;
      sub_100018E34((int *)buf);
      unint64_t v20 = sub_100017338((ssize_t)buf);
      uint64_t v22 = v21;
      v46.n128_u64[0] = v20;
      v46.n128_u64[1] = v21;
      sub_100019D7C((unsigned int *)buf);
      uint64_t v23 = *(void *)(a1 + 104);
      double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
      sub_1000F98E0((uint64_t)buf, v20, v22, a3, (__int128 *)a2, v35, (__int128 *)a5, Current_1);
      uint64_t v32 = 0LL;
      uint64_t v33 = 0LL;
      unsigned __int8 v34 = 0LL;
      unsigned __int8 v38 = &v32;
      char v39 = 0;
      uint64_t v32 = (char *)operator new(0x58uLL);
      uint64_t v33 = (uint64_t)v32;
      unsigned __int8 v34 = v32 + 88;
      uint64_t v33 = sub_1000EAD2C((uint64_t)&v34, (uint64_t)buf, (uint64_t)&v46, (uint64_t)v32);
      sub_1000E4B58(v23, &v32);
      unsigned __int8 v38 = &v32;
      sub_1000AA544((void ***)&v38);
      if (v45 < 0) {
        operator delete(__p);
      }
      if (SBYTE5(v43) < 0) {
        operator delete(*(void **)&buf[32]);
      }
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EDA0);
      }
      __int16 v25 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        else {
          uint64_t v26 = *(void *)a2;
        }
        __int16 v27 = (char *)operator new(0x28uLL);
        *(void *)(v27 + 29) = 0LL;
        *(_OWORD *)__int16 v27 = 0u;
        *((_OWORD *)v27 + 1) = 0u;
        sub_10000AE6C((uint64_t)&v46, v27);
        *(_DWORD *)uint64_t buf = 68290050;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2082;
        *(void *)&buf[20] = v26;
        *(_WORD *)&_BYTE buf[28] = 2082;
        *(void *)&buf[30] = a5;
        *(_WORD *)&_BYTE buf[38] = 2050;
        unint64_t v41 = a3;
        __int16 v42 = 2082;
        __int16 v43 = v27;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MiLoServiceManager new service created for client, ClientId:%{public, location:es cape_only}s, UserId:%{public, location:escape_only}s, ServiceType:%{public}llu, ServiceUuid:%{publ ic, location:escape_only}s}",  buf,  0x3Au);
        operator delete(v27);
      }

      sub_1000F0BA8((__n128 *)buf, &v46, a3, v35);
      __int128 v28 = *(_OWORD *)&buf[16];
      *(_OWORD *)a6 = *(_OWORD *)buf;
      *(_OWORD *)(a6 + 16) = v28;
      *(_BYTE *)(a6 + 32) = 1;
      uint64_t v29 = -1LL;
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EDA0);
      }
      uint64_t v30 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        else {
          uint64_t v31 = *(void *)a2;
        }
        *(_DWORD *)uint64_t buf = 68289794;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2082;
        *(void *)&buf[20] = v31;
        *(_WORD *)&_BYTE buf[28] = 2050;
        *(void *)&buf[30] = a3;
        *(_WORD *)&_BYTE buf[38] = 2050;
        unint64_t v41 = v15;
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MiLoServiceManager Client tried to create service, failed since not allowed, Client Id:%{public, location:escape_only}s, ServiceType:%{public}llu, NumIdenticalServices:%{public}llu}",  buf,  0x30u);
      }

      *(_BYTE *)a6 = 0;
      *(_BYTE *)(a6 + 32) = 0;
      uint64_t v29 = 21LL;
    }

    *(void *)(a6 + 40) = v29;
    *(void *)uint64_t buf = &v36;
    sub_1000AA544((void ***)buf);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EDA0);
    }
    __int16 v18 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      else {
        uint64_t v19 = *(void *)a2;
      }
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2082;
      *(void *)&buf[20] = v19;
      *(_WORD *)&_BYTE buf[28] = 2050;
      *(void *)&buf[30] = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MiLoServiceManager cannot create service since database is not available, ClientId: %{public, location:escape_only}s, ServiceType:%{public}llu}",  buf,  0x26u);
    }

    *(_BYTE *)a6 = 0;
    *(_BYTE *)(a6 + 32) = 0;
    *(void *)(a6 + 40) = 22LL;
  }

void sub_1000E45CC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char *a19)
{
  a19 = &a14;
  sub_1000AA544((void ***)&a19);
  _Unwind_Resume(a1);
}

BOOL sub_1000E4668(uint64_t a1, uint64_t a2, unint64_t a3)
{
  switch(a2)
  {
    case 1LL:
      sub_1002F0B04(buf);
      CFStringRef v5 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfCreatedUnsupervisedServicesPerClient",  0x8000100u,  kCFAllocatorNull);
      int v6 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v5, &v25);
      CFRelease(v5);
      unint64_t v7 = v25;
      uint64_t v8 = *(std::__shared_weak_count **)v27;
      if (!*(void *)v27) {
        goto LABEL_15;
      }
      uint64_t v9 = (unint64_t *)(*(void *)v27 + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      break;
    case 2LL:
      sub_1002F0B04(buf);
      CFStringRef v11 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfCreatedBinaryRoiServicesPerClient",  0x8000100u,  kCFAllocatorNull);
      int v6 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v11, &v25);
      CFRelease(v11);
      unint64_t v7 = v25;
      uint64_t v8 = *(std::__shared_weak_count **)v27;
      if (!*(void *)v27) {
        goto LABEL_15;
      }
      unint64_t v12 = (unint64_t *)(*(void *)v27 + 8LL);
      do
        unint64_t v10 = __ldaxr(v12);
      while (__stlxr(v10 - 1, v12));
      break;
    case 3LL:
      sub_1002F0B04(buf);
      CFStringRef v13 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfCreatedMulticlassServicesPerClient",  0x8000100u,  kCFAllocatorNull);
      int v6 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v13, &v25);
      CFRelease(v13);
      unint64_t v7 = v25;
      uint64_t v8 = *(std::__shared_weak_count **)v27;
      if (!*(void *)v27) {
        goto LABEL_15;
      }
      uint64_t v14 = (unint64_t *)(*(void *)v27 + 8LL);
      do
        unint64_t v10 = __ldaxr(v14);
      while (__stlxr(v10 - 1, v14));
      break;
    case 4LL:
      sub_1002F0B04(buf);
      CFStringRef v15 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfCreatedSimilarityListServicesPerClient",  0x8000100u,  kCFAllocatorNull);
      int v16 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v15, &v25);
      CFRelease(v15);
      unint64_t v7 = v25;
      uint64_t v17 = *(std::__shared_weak_count **)v27;
      if (*(void *)v27)
      {
        __int16 v18 = (unint64_t *)(*(void *)v27 + 8LL);
        do
          unint64_t v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }

      if (!v16) {
        unint64_t v7 = 50LL;
      }
      goto LABEL_25;
    default:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EDA0);
      }
      uint64_t v22 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)__int16 v27 = 2082;
        *(void *)&v27[2] = "";
        __int16 v28 = 2050;
        uint64_t v29 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:unhandled serviceType, ServiceType:%{public}lu}",  buf,  0x1Cu);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181EDA0);
        }
      }

      uint64_t v23 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)__int16 v27 = 2082;
        *(void *)&v27[2] = "";
        __int16 v28 = 2050;
        uint64_t v29 = a2;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v23,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "unhandled serviceType",  "{msg%{public}.0s:unhandled serviceType, ServiceType:%{public}lu}",  buf,  0x1Cu);
      }

      return 0LL;
  }

  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }

void sub_1000E4B10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1000E4B58(uint64_t a1, void *a2)
{
  uint64_t v4 = a1 + 72;
  if (sub_1003C1048(a1 + 72))
  {
    CFStringRef v5 = *(void **)(a1 + 264);
    if (!v5)
    {
      CFStringRef v5 = operator new(0x10uLL);
      sub_1000F9800((uint64_t)v5, v4);
      int v6 = *(void **)(a1 + 264);
      *(void *)(a1 + 264) = v5;
      if (v6)
      {
        operator delete(v6);
        CFStringRef v5 = *(void **)(a1 + 264);
      }
    }

    uint64_t v7 = sub_1000FA1E0((uint64_t)v5, a2);
    sub_1000EAF08(a1);
    return v7;
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EDA0);
    }
    uint64_t v9 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning Can't insert because the database is invalid",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EDA0);
      }
      v12[0] = 0;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Can't insert because the database is invalid",  v12,  2);
      CFStringRef v11 = (uint8_t *)v10;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMiLoServiceTable::Entry]",  "%s\n",  v10);
      if (v11 != buf) {
        free(v11);
      }
    }

    return 0LL;
  }

void sub_1000E4D68(_Unwind_Exception *a1)
{
}

uint64_t sub_1000E4D84(uint64_t a1)
{
  return a1;
}

unint64_t sub_1000E4DC4@<X0>( uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, unsigned __int8 *a5@<X4>, __n128 *a6@<X8>)
{
  v32.n128_u64[0] = a3;
  v32.n128_u64[1] = a4;
  unint64_t result = sub_1000E5024(a1, a3, a4);
  if (v13)
  {
    a6->n128_u8[0] = 0;
    a6[2].n128_u8[0] = 0;
    a6[2].n128_u64[1] = 23LL;
    return result;
  }

  sub_10002DF00(*(void *)(a1 + 104), a3, a4, v25);
  if (v31)
  {
    uint64_t v14 = a2[23];
    if ((v14 & 0x80u) == 0LL) {
      uint64_t v15 = a2[23];
    }
    else {
      uint64_t v15 = *((void *)a2 + 1);
    }
    uint64_t v16 = v27;
    if ((v27 & 0x80u) != 0) {
      uint64_t v16 = v26[1];
    }
    if (v15 != v16) {
      goto LABEL_35;
    }
    if ((v27 & 0x80u) == 0) {
      uint64_t v17 = (unsigned __int8 *)v26;
    }
    else {
      uint64_t v17 = (unsigned __int8 *)v26[0];
    }
    if ((v14 & 0x80) != 0)
    {
    }

    else if (a2[23])
    {
      while (*a2 == *v17)
      {
        ++a2;
        ++v17;
        if (!--v14) {
          goto LABEL_20;
        }
      }

      goto LABEL_35;
    }

void sub_1000E5004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

unint64_t sub_1000E5024(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1 + 40;
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5 == a1 + 40) {
    return 0LL;
  }
  unsigned __int8 v6 = 0;
  do
  {
    uint64_t v7 = sub_1000F0EE0(v5 + 16);
    if (v7 == a2 && v8 == a3)
    {
      unsigned __int8 v6 = v5 + 16;
      unint64_t v3 = (unint64_t)(v5 + 16) >> 8;
    }

    uint64_t v5 = *(void *)(v5 + 8);
  }

  while (v5 != v4);
  return v6 | (v3 << 8);
}

uint64_t sub_1000E50F4( uint64_t *a1, size_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void **a7)
{
  *(void *)&__int128 v116 = a3;
  *((void *)&v116 + 1) = a4;
  *(void *)&__int128 v115 = a5;
  *((void *)&v115 + 1) = a6;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EDA0);
  }
  unint64_t v10 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    else {
      CFStringRef v11 = (size_t *)*a2;
    }
    unint64_t v12 = operator new(0x28uLL);
    __n128 v107 = (void **)v12;
    __int128 v108 = xmmword_1012C8460;
    _OWORD *v12 = 0u;
    v12[1] = 0u;
    *(void *)((char *)v12 + 29) = 0LL;
    sub_10000AE6C((uint64_t)&v116, v12);
    if (v108 >= 0) {
      char v13 = (void **)&v107;
    }
    else {
      char v13 = v107;
    }
    else {
      uint64_t v14 = (void **)*a7;
    }
    uint64_t v15 = operator new(0x28uLL);
    std::string __p = v15;
    *(_OWORD *)__n = xmmword_1012C8460;
    _OWORD *v15 = 0u;
    v15[1] = 0u;
    *(void *)((char *)v15 + 29) = 0LL;
    sub_10000AE6C((uint64_t)&v115, v15);
    p_p = &__p;
    if ((__n[1] & 0x8000000000000000LL) != 0LL) {
      p_p = __p;
    }
    *(_DWORD *)uint64_t buf = 68290050;
    int v94 = 0;
    __int16 v95 = 2082;
    std::string v96 = "";
    __int16 v97 = 2082;
    std::string v98 = v11;
    __int16 v99 = 2082;
    std::string v100 = v13;
    __int16 v101 = 2082;
    std::string v102 = v14;
    __int16 v103 = 2082;
    __n128 v104 = p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MiLoServiceManager connection parameters: , ClientId:%{public, location:escape_only}s , ServiceUuid:%{public, location:escape_only}s, UserID:%{public, location:escape_only}s, connectionToken :%{public, location:escape_only}s}",  buf,  0x3Au);
    if (SHIBYTE(__n[1]) < 0) {
      operator delete(__p);
    }
    if (SHIBYTE(v108) < 0) {
      operator delete(v107);
    }
  }

  else {
    size_t v17 = (size_t)a7[1];
  }
  uint64_t v18 = &__p;
  sub_1000392EC((uint64_t)&__p, v17 + 20);
  if ((__n[1] & 0x8000000000000000LL) != 0LL) {
    uint64_t v18 = __p;
  }
  if (v17)
  {
    else {
      uint64_t v19 = *a7;
    }
    memmove(v18, v19, v17);
  }

  strcpy((char *)v18 + v17, ":com.apple.locationd");
  sub_1000E5024((uint64_t)a1, v116, *((uint64_t *)&v116 + 1));
  if (v20)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EDA0);
    }
    uint64_t v21 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = (char *)operator new(0x28uLL);
      *(void *)(v22 + 29) = 0LL;
      *(_OWORD *)uint64_t v22 = 0u;
      *((_OWORD *)v22 + 1) = 0u;
      sub_10000AE6C((uint64_t)&v116, v22);
      *(_DWORD *)uint64_t buf = 68289538;
      int v94 = 0;
      __int16 v95 = 2082;
      std::string v96 = "";
      __int16 v97 = 2082;
      std::string v98 = a2;
      __int16 v99 = 2082;
      std::string v100 = (void **)v22;
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MiLoServiceManager cannot connect to service since service already has active connection , ClientId:%{public, location:escape_only}s, ServiceUuid:%{public, location:escape_only}s}",  buf,  0x26u);
      operator delete(v22);
    }

    uint64_t v23 = 18LL;
    goto LABEL_132;
  }

  if (sub_100031790(a1[13]))
  {
    sub_10002DF00(a1[13], v116, *((uint64_t *)&v116 + 1), &v107);
    if (!v114)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EDA0);
      }
      __n128 v32 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v33 = (char *)operator new(0x28uLL);
        *(void *)(v33 + 29) = 0LL;
        *(_OWORD *)uint64_t v33 = 0u;
        *((_OWORD *)v33 + 1) = 0u;
        sub_10000AE6C((uint64_t)&v116, v33);
        *(_DWORD *)uint64_t buf = 68289538;
        int v94 = 0;
        __int16 v95 = 2082;
        std::string v96 = "";
        __int16 v97 = 2082;
        std::string v98 = a2;
        __int16 v99 = 2082;
        std::string v100 = (void **)v33;
        _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MiLoServiceManager cannot connect to service since service not found in database, C lientId:%{public, location:escape_only}s, ServiceUuid:%{public, location:escape_only}s}",  buf,  0x26u);
        operator delete(v33);
      }

      uint64_t v23 = 19LL;
      goto LABEL_131;
    }

    uint64_t v24 = *((unsigned __int8 *)a2 + 23);
    if ((v24 & 0x80u) == 0LL) {
      size_t v25 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v25 = a2[1];
    }
    int v26 = (char)v111;
    if ((v111 & 0x80u) == 0) {
      uint64_t v27 = v111;
    }
    else {
      uint64_t v27 = v110;
    }
    if (v25 == v27)
    {
      if ((v111 & 0x80u) == 0) {
        unsigned int v28 = &v109;
      }
      else {
        unsigned int v28 = (unsigned __int8 **)v109;
      }
      if ((v24 & 0x80) != 0)
      {
      }

      else
      {
        if (!*((_BYTE *)a2 + 23)) {
          goto LABEL_97;
        }
        uint64_t v29 = a2;
        while (*(unsigned __int8 *)v29 == *(unsigned __int8 *)v28)
        {
          uint64_t v29 = (size_t *)((char *)v29 + 1);
          unsigned int v28 = (unsigned __int8 **)((char *)v28 + 1);
          if (!--v24) {
            goto LABEL_97;
          }
        }
      }
    }

    uint64_t v34 = HIBYTE(__n[1]);
    if ((__n[1] & 0x8000000000000000LL) == 0LL) {
      size_t v35 = HIBYTE(__n[1]);
    }
    else {
      size_t v35 = __n[0];
    }
    if (v35 == v27)
    {
      if (v26 >= 0) {
        __int16 v36 = &v109;
      }
      else {
        __int16 v36 = (unsigned __int8 **)v109;
      }
      if ((__n[1] & 0x8000000000000000LL) == 0)
      {
        if (HIBYTE(__n[1]))
        {
          int v37 = &__p;
          while (*(unsigned __int8 *)v37 == *(unsigned __int8 *)v36)
          {
            int v37 = (void **)((char *)v37 + 1);
            __int16 v36 = (unsigned __int8 **)((char *)v36 + 1);
            if (!--v34) {
              goto LABEL_97;
            }
          }

          goto LABEL_84;
        }

LABEL_152:
            __int16 v60 = (void **)sub_1000F0F50((uint64_t)(v53 + 2));
            v54 += v60 == v107;
            goto LABEL_153;
          }
        }

          *(_DWORD *)(a1 + 88) = v34;
          goto LABEL_176;
        case 3u:
          int v37 = operator new(0x18uLL);
          sub_101103644((uint64_t)v37);
          __int16 v40 = *(void *)(a1 + 56);
          *(void *)(a1 + 56) = v37;
          if (v40)
          {
            (*(void (**)(uint64_t))(*(void *)v40 + 8LL))(v40);
            int v37 = *(void **)(a1 + 56);
          }

          goto LABEL_39;
        case 4u:
          int v37 = operator new(0x18uLL);
          sub_101103644((uint64_t)v37);
          unint64_t v41 = *(void *)(a1 + 64);
          *(void *)(a1 + 64) = v37;
          if (v41)
          {
            (*(void (**)(uint64_t))(*(void *)v41 + 8LL))(v41);
            int v37 = *(void **)(a1 + 64);
          }

          *(_DWORD *)(a1 + 124) = v42;
          goto LABEL_101;
        case 3u:
          sub_10109B308(v15);
          int v47 = *(void *)(a1 + 80);
          goto LABEL_97;
        case 4u:
          if ((_DWORD)v28 != 2)
          {
            __int16 v97 = *(char **)(a1 + 40);
            std::string v96 = *(void *)(a1 + 48);
            if ((unint64_t)v97 >= v96)
            {
              __int16 v101 = (char *)*v13;
              std::string v102 = (v97 - (_BYTE *)*v13) >> 2;
              __int16 v103 = v102 + 1;
              if ((unint64_t)(v102 + 1) >> 62) {
LABEL_176:
              }
                sub_100007008();
              __n128 v104 = v96 - (void)v101;
              if (v104 >> 1 > v103) {
                __int16 v103 = v104 >> 1;
              }
              else {
                __int16 v105 = v103;
              }
              if (v105)
              {
                __n128 v106 = (char *)sub_10000956C(v14, v105);
                __int16 v101 = *(char **)(a1 + 32);
                __int16 v97 = *(char **)(a1 + 40);
              }

              else
              {
                __n128 v106 = 0LL;
              }

              unsigned __int8 v113 = &v106[4 * v102];
              *(_DWORD *)unsigned __int8 v113 = 0;
              std::string v98 = v113 + 4;
              while (v97 != v101)
              {
                char v114 = *((_DWORD *)v97 - 1);
                v97 -= 4;
                *((_DWORD *)v113 - 1) = v114;
                v113 -= 4;
              }

              *(void *)(a1 + 32) = v113;
              *(void *)(a1 + 40) = v98;
              *(void *)(a1 + sub_10000AE14(v17 - 48) = &v106[4 * v105];
              if (v101) {
                operator delete(v101);
              }
            }

            else
            {
              *(_DWORD *)__int16 v97 = 0;
              std::string v98 = v97 + 4;
            }

            *(void *)(a1 + 40) = v98;
            goto LABEL_167;
          }

          if ((PB::Reader::placeMark(this, v119, v28, a4) & 1) != 0) {
            return 0LL;
          }
          __int16 v48 = *((void *)this + 1);
          __int16 v49 = *((void *)this + 2);
          while (v48 < v49 && !*((_BYTE *)this + 24))
          {
            __int16 v51 = *(char **)(a1 + 40);
            __int16 v50 = *(void *)(a1 + 48);
            if ((unint64_t)v51 >= v50)
            {
              __int16 v53 = (char *)*v13;
              uint64_t v54 = (v51 - (_BYTE *)*v13) >> 2;
              __int16 v55 = v54 + 1;
              uint64_t v56 = v50 - (void)v53;
              if (v56 >> 1 > v55) {
                __int16 v55 = v56 >> 1;
              }
              else {
                uint64_t v57 = v55;
              }
              if (v57)
              {
                uint64_t v58 = (char *)sub_10000956C(v14, v57);
                __int16 v53 = *(char **)(a1 + 32);
                __int16 v51 = *(char **)(a1 + 40);
              }

              else
              {
                uint64_t v58 = 0LL;
              }

              std::string v59 = &v58[4 * v54];
              *(_DWORD *)std::string v59 = 0;
              __int16 v52 = v59 + 4;
              while (v51 != v53)
              {
                __int16 v60 = *((_DWORD *)v51 - 1);
                v51 -= 4;
                *((_DWORD *)v59 - 1) = v60;
                v59 -= 4;
              }

              *(void *)(a1 + 32) = v59;
              *(void *)(a1 + 40) = v52;
              *(void *)(a1 + sub_10000AE14(v17 - 48) = &v58[4 * v57];
              if (v53) {
                operator delete(v53);
              }
            }

            else
            {
              *(_DWORD *)__int16 v51 = 0;
              __int16 v52 = v51 + 4;
            }

            *(void *)(a1 + 40) = v52;
            unint64_t v61 = *((void *)this + 1);
            if (v61 > 0xFFFFFFFFFFFFFFFBLL || v61 + 4 > *((void *)this + 2)) {
              goto LABEL_128;
            }
            *(v52 - 1) = *(_DWORD *)(*(void *)this + v61);
            __int16 v49 = *((void *)this + 2);
            __int16 v48 = *((void *)this + 1) + 4LL;
            *((void *)this + 1) = v48;
          }

          goto LABEL_100;
        case 5u:
          if ((_DWORD)v28 == 2)
          {
            if ((PB::Reader::placeMark(this, v119, v28, a4) & 1) != 0) {
              return 0LL;
            }
            __int16 v62 = *((void *)this + 1);
            char v63 = *((void *)this + 2);
            while (v62 < v63 && !*((_BYTE *)this + 24))
            {
              std::string v65 = *(char **)(a1 + 16);
              int v64 = *(void *)(a1 + 24);
              if ((unint64_t)v65 >= v64)
              {
                int v67 = (char *)*v11;
                __int16 v68 = (v65 - (_BYTE *)*v11) >> 2;
                int v69 = v68 + 1;
                uint64_t v70 = v64 - (void)v67;
                if (v70 >> 1 > v69) {
                  int v69 = v70 >> 1;
                }
                else {
                  __int128 v71 = v69;
                }
                if (v71)
                {
                  uint64_t v72 = (char *)sub_10000956C(v12, v71);
                  int v67 = *(char **)(a1 + 8);
                  std::string v65 = *(char **)(a1 + 16);
                }

                else
                {
                  uint64_t v72 = 0LL;
                }

                int v73 = &v72[4 * v68];
                *(_DWORD *)int v73 = 0;
                __int16 v66 = v73 + 4;
                while (v65 != v67)
                {
                  char v74 = *((_DWORD *)v65 - 1);
                  v65 -= 4;
                  *((_DWORD *)v73 - 1) = v74;
                  v73 -= 4;
                }

                *(void *)(a1 + 8) = v73;
                *(void *)(a1 + 16) = v66;
                *(void *)(a1 + 24) = &v72[4 * v71];
                if (v67) {
                  operator delete(v67);
                }
              }

              else
              {
                *(_DWORD *)std::string v65 = 0;
                __int16 v66 = v65 + 4;
              }

              *(void *)(a1 + 16) = v66;
              char v75 = *((void *)this + 1);
              if (v75 > 0xFFFFFFFFFFFFFFFBLL || v75 + 4 > *((void *)this + 2))
              {
LABEL_128:
                *((_BYTE *)this + 24) = 1;
                break;
              }

              *(v66 - 1) = *(_DWORD *)(*(void *)this + v75);
              char v63 = *((void *)this + 2);
              __int16 v62 = *((void *)this + 1) + 4LL;
              *((void *)this + 1) = v62;
            }

  unint64_t result = *(float *)(a2 + 260);
  v5 |= 0x4000000000000000uLL;
  *uint64_t v2 = v5;
  *(_WORD *)(a1 + 288) = v6;
  *(float *)(a1 + 260) = result;
  uint64_t v4 = *v3;
  if ((*v3 & 0x8000000000000000LL) == 0)
  {
LABEL_79:
    if ((v4 & 0x2000000000000000LL) == 0) {
      return result;
    }
LABEL_154:
    unint64_t result = *(float *)(a2 + 256);
    *uint64_t v2 = v5 | 0x2000000000000000LL;
    *(_WORD *)(a1 + 288) = v6;
    *(float *)(a1 + 256) = result;
    return result;
  }

  PB::TextFormatter::format(this, "shortAudioNumThreshold", *(float *)(a1 + 260));
  unsigned __int8 v6 = *v5;
  uint64_t v7 = *(_WORD *)(a1 + 288);
  if ((*v5 & 0x8000000000000000LL) == 0)
  {
LABEL_78:
    if ((v7 & 0x800) == 0) {
      goto LABEL_79;
    }
LABEL_154:
    PB::TextFormatter::format(this, "strongerAudio", *(_BYTE *)(a1 + 279));
    if ((*v5 & 1) == 0) {
      return PB::TextFormatter::endObject(this);
    }
    goto LABEL_80;
  }

  unint64_t result = *(float *)(a2 + 188);
  v5 |= 0x100000000000uLL;
  *uint64_t v2 = v5;
  *(_WORD *)(a1 + 324) = v6;
  *(_BYTE *)(a1 + 326) = BYTE2(v6);
  *(float *)(a1 + 188) = result;
  LOWORD(v8) = *(_WORD *)(a2 + 324);
  uint64_t v4 = *v3;
  if ((*v3 & 0x80000000000LL) == 0)
  {
LABEL_72:
    if ((v4 & 0x1000000000000LL) == 0) {
      goto LABEL_73;
    }
    goto LABEL_154;
  }

  PB::TextFormatter::format(this, "lowSenseWithoutAudiodvThreshold2", *(float *)(a1 + 244));
  uint64_t v7 = *(unsigned __int16 *)(a1 + 324) | (*(unsigned __int8 *)(a1 + 326) << 16);
  unsigned __int8 v6 = *v5;
  if ((*v5 & 0x800000000000000LL) == 0)
  {
LABEL_71:
    if ((v6 & 0x1000000000000000LL) == 0) {
      goto LABEL_72;
    }
    goto LABEL_154;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 188), 0x106u);
  LOWORD(v7) = *((_WORD *)v4 + 4);
  uint64_t v5 = *v4;
  if ((*v4 & 0x80000000000LL) == 0)
  {
LABEL_72:
    if ((v5 & 0x1000000000000LL) == 0) {
      goto LABEL_73;
    }
    goto LABEL_154;
  }

  unint64_t v41 = *(_BYTE *)(a2 + 326);
  v6 |= 0x8000uLL;
  *uint64_t v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(_BYTE *)(a1 + 326) = v41;
  uint64_t v4 = *v3;
  uint64_t v7 = *(void *)(a2 + 364);
  if ((v7 & 0x8000000000LL) == 0)
  {
LABEL_47:
    if ((v7 & 0x800000000LL) == 0) {
      goto LABEL_48;
    }
    goto LABEL_154;
  }

  PB::TextFormatter::format(this, "movingCountThreshold", *(_DWORD *)(a1 + 136));
  uint64_t v7 = *v5;
  unsigned __int8 v6 = *(void *)(a1 + 364);
  if ((*v5 & 0x2000000) == 0)
  {
LABEL_51:
    if ((v7 & 0x4000000) == 0) {
      goto LABEL_52;
    }
    goto LABEL_154;
  }

  unint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 326), 0x136u);
  uint64_t v5 = *v4;
  unsigned __int8 v6 = v4[1];
  if ((v6 & 0x8000000000LL) == 0)
  {
LABEL_47:
    if ((v6 & 0x800000000LL) == 0) {
      goto LABEL_48;
    }
    goto LABEL_154;
  }

  std::string v87 = *(_BYTE *)(a2 + 168);
  v3 |= 0x200000000000uLL;
  *(void *)(result + 204) = v3;
  *(_WORD *)(result + 212) = v4;
  *(_BYTE *)(result + 214) = BYTE2(v4);
  *(_BYTE *)(result + 168) = v87;
  LOWORD(v5) = *(_WORD *)(a2 + 212);
  uint64_t v2 = *(void *)(a2 + 204);
  if ((v2 & 0x200000000LL) == 0)
  {
LABEL_74:
    if ((v5 & 0x2000) == 0) {
      goto LABEL_75;
    }
    goto LABEL_154;
  }

  PB::TextFormatter::format(this, "maxSaturation1", *(float *)(a1 + 148));
  unsigned __int8 v6 = *(unsigned __int16 *)(a1 + 212) | (*(unsigned __int8 *)(a1 + 214) << 16);
  uint64_t v5 = *(void *)(a1 + 204);
  if ((v5 & 0x100000000LL) == 0)
  {
LABEL_73:
    if ((v6 & 0x200) == 0) {
      goto LABEL_74;
    }
    goto LABEL_154;
  }

  unint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 203), 0x4BAu);
  LOWORD(v5) = *(_WORD *)(v3 + 212);
  uint64_t v4 = *(void *)(v3 + 204);
  if ((v4 & 0x10000000000LL) == 0)
  {
LABEL_74:
    if ((v4 & 0x100000000000LL) == 0) {
      goto LABEL_75;
    }
    goto LABEL_154;
  }

LABEL_113:
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181EDA0);
        }
        int v47 = (os_log_s *)qword_1019348D8;
        if (!os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_130;
        }
        __int16 v48 = (char *)operator new(0x28uLL);
        *(void *)(v48 + 29) = 0LL;
        *(_OWORD *)__int16 v48 = 0u;
        *((_OWORD *)v48 + 1) = 0u;
        sub_10000AE6C((uint64_t)&v116, v48);
        if (!v114) {
          sub_100036CD8();
        }
        if ((v111 & 0x80u) == 0) {
          __int16 v49 = (void **)&v109;
        }
        else {
          __int16 v49 = (void **)v109;
        }
        else {
          __int16 v50 = (void *)*a7;
        }
        if ((v113 & 0x80u) == 0) {
          __int16 v51 = v112;
        }
        else {
          __int16 v51 = (void *)v112[0];
        }
        *(_DWORD *)uint64_t buf = 68290306;
        int v94 = 0;
        __int16 v95 = 2082;
        std::string v96 = "";
        __int16 v97 = 2082;
        std::string v98 = a2;
        __int16 v99 = 2082;
        std::string v100 = (void **)v48;
        __int16 v101 = 2082;
        std::string v102 = v49;
        __int16 v103 = 2082;
        __n128 v104 = v50;
        __int16 v105 = 2082;
        __n128 v106 = v51;
        _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MiLoServiceManager cannot connect to service because client's user mismatched with serv ice, ClientId:%{public, location:escape_only}s, ServiceUuid:%{public, location:escape_only}s, Expe ctedClientId:%{public, location:escape_only}s, UserID:%{public, location:escape_only}s, ExpectedUserID :%{public, location:escape_only}s}",  buf,  0x44u);
        unint64_t v41 = v48;
LABEL_129:
        operator delete(v41);
LABEL_130:
        uint64_t v23 = 20LL;
LABEL_131:
        sub_1000EA040((uint64_t)&v107);
        goto LABEL_132;
      }

      if (!memcmp(__p, v36, __n[0])) {
        goto LABEL_97;
      }
    }

  unint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x2A,  (int)a2,  *(double *)(v5 + 256),  a3);
  uint64_t v7 = *(_DWORD *)(v5 + 368);
  if ((v7 & 0x400) == 0)
  {
LABEL_44:
    if ((v7 & 0x800) == 0) {
      goto LABEL_45;
    }
    goto LABEL_115;
  }

  *(float *)&unsigned __int8 v6 = self->_maxGoodCatherine;
  objc_msgSend( v3,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v6),  @"maxGoodCatherine");
  has = self->_has;
  if ((*(_BYTE *)&has & 0x20) == 0)
  {
LABEL_91:
    if ((*(_BYTE *)&has & 0x40) == 0) {
      goto LABEL_92;
    }
    goto LABEL_115;
  }

  if ((v3 & 0x200000) != 0) {
    v5 += 10;
  }
  if ((v3 & 0x400000) != 0)
  {
    unsigned __int8 v38 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 164);
    if ((v38 & 0x80000000) != 0)
    {
      char v39 = 12;
    }

    else if (v38 >= 0x80)
    {
      char v39 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v38, a2) + 2;
    }

    else
    {
      char v39 = 3;
    }

    v5 += v39;
  }

  unint64_t result = *(float *)(a2 + 156);
  v5 |= 0x10000000uLL;
  *uint64_t v2 = v5;
  *(_BYTE *)(a1 + 324) = v6;
  *(float *)(a1 + 156) = result;
  uint64_t v7 = *v3;
  if ((*v3 & 0x20000000) == 0)
  {
LABEL_48:
    if ((v7 & 0x20000000000LL) == 0) {
      goto LABEL_49;
    }
    goto LABEL_115;
  }

  PB::TextFormatter::format(this, "hgDurationZBiggestImpact", *(float *)(a1 + 224));
  unsigned __int8 v6 = *v5;
  uint64_t v7 = *(_BYTE *)(a1 + 324);
  if ((*v5 & 0x400000000000LL) == 0)
  {
LABEL_47:
    if ((v7 & 8) == 0) {
      goto LABEL_48;
    }
    goto LABEL_115;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 156), 0x2Bu);
  unsigned __int8 v6 = *v4;
  if ((*v4 & 0x20000000) == 0)
  {
LABEL_48:
    if ((v6 & 0x20000000000LL) == 0) {
      goto LABEL_49;
    }
    goto LABEL_115;
  }

  uint64_t v19 = *(_BYTE *)(a2 + 270);
  v6 |= 4u;
  *uint64_t v2 = v5;
  *(_WORD *)(a1 + 288) = v6;
  *(_BYTE *)(a1 + 270) = v19;
  uint64_t v4 = *v3;
  uint64_t v7 = *(_WORD *)(a2 + 288);
  if ((*v3 & 0x80) == 0)
  {
LABEL_40:
    if ((v4 & 0x400) == 0) {
      goto LABEL_41;
    }
    goto LABEL_115;
  }

  PB::TextFormatter::format(this, "detectorRegimeDeltaVThreshold3WithoutAudio", *(float *)(a1 + 148));
  unsigned __int8 v6 = *v5;
  uint64_t v7 = *(_WORD *)(a1 + 288);
  if ((*v5 & 0x800000000LL) == 0)
  {
LABEL_39:
    if ((v6 & 0x1000000000LL) == 0) {
      goto LABEL_40;
    }
    goto LABEL_115;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 52), 0x22u);
  uint64_t v5 = *v4;
  unsigned __int8 v6 = *((_WORD *)v4 + 4);
  if ((*v4 & 0x200) == 0)
  {
LABEL_39:
    if ((v5 & 0x100) == 0) {
      goto LABEL_40;
    }
    goto LABEL_115;
  }

  unint64_t result = *(float *)(a2 + 20);
  v5 |= 4uLL;
  *uint64_t v2 = v5;
  *(_WORD *)(a1 + 324) = v6;
  *(_BYTE *)(a1 + 326) = BYTE2(v6);
  *(float *)(a1 + 20) = result;
  LOWORD(v8) = *(_WORD *)(a2 + 324);
  uint64_t v4 = *v3;
  if ((*v3 & 0x1000000000000000LL) == 0)
  {
LABEL_33:
    if ((v8 & 0x40) == 0) {
      goto LABEL_34;
    }
    goto LABEL_115;
  }

  PB::TextFormatter::format(this, "kBaroEscalateMaxAccelNormThresholdRO", *(float *)(a1 + 100));
  uint64_t v7 = *(unsigned __int16 *)(a1 + 324) | (*(unsigned __int8 *)(a1 + 326) << 16);
  unsigned __int8 v6 = *v5;
  if ((*v5 & 0x800000) == 0)
  {
LABEL_32:
    if ((v7 & 0x4000) == 0) {
      goto LABEL_33;
    }
    goto LABEL_115;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 20), 0xCBu);
  LOWORD(v7) = *((_WORD *)v4 + 4);
  uint64_t v5 = *v4;
  if ((*v4 & 0x1000000000000000LL) == 0)
  {
LABEL_33:
    if ((v7 & 0x40) == 0) {
      goto LABEL_34;
    }
    goto LABEL_115;
  }

  PB::TextFormatter::format(this, "deltaSteps", *(_DWORD *)(a1 + 96));
  uint64_t v7 = *v5;
  unsigned __int8 v6 = *(void *)(a1 + 364);
  if ((*v5 & 0x8000) == 0)
  {
LABEL_12:
    if ((v7 & 0x10000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_115;
  }

  __int16 v40 = *(_DWORD *)(a2 + 148);
  v3 |= 0x80000000uLL;
  *(void *)(result + 204) = v3;
  *(_WORD *)(result + 212) = v4;
  *(_BYTE *)(result + 214) = BYTE2(v4);
  *(_DWORD *)(result + 1sub_10000AE14(v17 - 48) = v40;
  uint64_t v5 = *(unsigned __int16 *)(a2 + 212) | (*(unsigned __int8 *)(a2 + 214) << 16);
  uint64_t v2 = *(void *)(a2 + 204);
  if ((v2 & 0x800000000000LL) == 0)
  {
LABEL_35:
    if ((v2 & 0x800000000LL) == 0) {
      goto LABEL_36;
    }
    goto LABEL_115;
  }

  PB::TextFormatter::format(this, "kEnergyAndChaosOrSaturationMetRO2", *(_BYTE *)(a1 + 183));
  unsigned __int8 v6 = *(unsigned __int16 *)(a1 + 212) | (*(unsigned __int8 *)(a1 + 214) << 16);
  uint64_t v5 = *(void *)(a1 + 204);
  if ((v5 & 0x2000000000000000LL) == 0)
  {
LABEL_34:
    if ((v5 & 0x4000000000000000LL) == 0) {
      goto LABEL_35;
    }
    goto LABEL_115;
  }

  unint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 161), 0x3F3u);
  uint64_t v5 = *(unsigned __int16 *)(v3 + 212) | (*(unsigned __int8 *)(v3 + 214) << 16);
  uint64_t v4 = *(void *)(v3 + 204);
  if ((v4 & 0x40000000000LL) == 0)
  {
LABEL_35:
    if ((v5 & 0x400) == 0) {
      goto LABEL_36;
    }
    goto LABEL_115;
  }

          *(_DWORD *)(a1 + 72) = v52;
          goto LABEL_131;
        case 0xAu:
          *(_WORD *)(a1 + 76) |= 0x20u;
          __int16 v55 = *((void *)this + 1);
          uint64_t v56 = *((void *)this + 2);
          uint64_t v57 = *(void *)this;
          if (v55 <= 0xFFFFFFFFFFFFFFF5LL && v55 + 10 <= v56)
          {
            uint64_t v58 = 0;
            std::string v59 = 0;
            __int16 v60 = 0LL;
            do
            {
              unint64_t v61 = v55 + 1;
              *((void *)this + 1) = v55 + 1;
              __int16 v62 = *(_BYTE *)(v57 + v55);
              v60 |= (unint64_t)(v62 & 0x7F) << v58;
              if ((v62 & 0x80) == 0) {
                goto LABEL_116;
              }
              v58 += 7;
              __int16 v55 = v61;
              uint64_t v18 = v59++ > 8;
            }

            while (!v18);
LABEL_100:
            LODWORD(v60) = 0;
            goto LABEL_116;
          }

          uint64_t v70 = 0;
          __int128 v71 = 0;
          __int16 v60 = 0LL;
          if (v56 <= v55) {
            uint64_t v56 = *((void *)this + 1);
          }
          while (2)
          {
            if (v56 == v55)
            {
              LODWORD(v60) = 0;
              *((_BYTE *)this + 24) = 1;
            }

            else
            {
              uint64_t v72 = v55 + 1;
              int v73 = *(_BYTE *)(v57 + v55);
              *((void *)this + 1) = v72;
              v60 |= (unint64_t)(v73 & 0x7F) << v70;
              if (v73 < 0)
              {
                v70 += 7;
                __int16 v55 = v72;
                uint64_t v18 = v71++ > 8;
                if (v18) {
                  goto LABEL_100;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v60) = 0;
              }
            }

            break;
          }

            PB::Reader::recallMark(this, v105);
          }

          else
          {
            std::string v85 = *(char **)(a1 + 40);
            std::string v84 = *(void *)(a1 + 48);
            if ((unint64_t)v85 >= v84)
            {
              std::string v92 = (char *)*v10;
              std::string v93 = (v85 - (_BYTE *)*v10) >> 2;
              int v94 = v93 + 1;
              if ((unint64_t)(v93 + 1) >> 62) {
LABEL_167:
              }
                sub_100007008();
              __int16 v95 = v84 - (void)v92;
              if (v95 >> 1 > v94) {
                int v94 = v95 >> 1;
              }
              else {
                std::string v96 = v94;
              }
              if (v96)
              {
                __int16 v97 = (char *)sub_10000956C(v11, v96);
                std::string v92 = *(char **)(a1 + 32);
                std::string v85 = *(char **)(a1 + 40);
              }

              else
              {
                __int16 v97 = 0LL;
              }

              std::string v100 = &v97[4 * v93];
              *(_DWORD *)std::string v100 = 0;
              int v83 = v100 + 4;
              while (v85 != v92)
              {
                __int16 v101 = *((_DWORD *)v85 - 1);
                v85 -= 4;
                *((_DWORD *)v100 - 1) = v101;
                v100 -= 4;
              }

              *(void *)(a1 + 32) = v100;
              *(void *)(a1 + 40) = v83;
              *(void *)(a1 + sub_10000AE14(v17 - 48) = &v97[4 * v96];
              if (v92) {
                operator delete(v92);
              }
            }

            else
            {
              *(_DWORD *)std::string v85 = 0;
              int v83 = v85 + 4;
            }

            *(void *)(a1 + 40) = v83;
LABEL_152:
            std::string v102 = *((void *)this + 1);
            if (v102 <= 0xFFFFFFFFFFFFFFFBLL && v102 + 4 <= *((void *)this + 2))
            {
              *(v83 - 1) = *(_DWORD *)(*(void *)this + v102);
              *((void *)this + 1) += 4LL;
            }

            else
            {
LABEL_154:
              *((_BYTE *)this + 24) = 1;
            }
          }

LABEL_84:
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EDA0);
    }
    unsigned __int8 v38 = (os_log_s *)qword_1019348D8;
    if (!os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_130;
    }
    sub_10009FEA0((uint64_t)&v116, (uint64_t)v89);
    if (!v114) {
      sub_100036CD8();
    }
    char v39 = v89;
    if (v90 < 0) {
      char v39 = (void **)v89[0];
    }
    __int16 v40 = (v111 & 0x80u) == 0 ? (void **)&v109 : (void **)v109;
    *(_DWORD *)uint64_t buf = 68289794;
    int v94 = 0;
    __int16 v95 = 2082;
    std::string v96 = "";
    __int16 v97 = 2082;
    std::string v98 = a2;
    __int16 v99 = 2082;
    std::string v100 = v39;
    __int16 v101 = 2082;
    std::string v102 = v40;
    _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MiLoServiceManager cannot connect to service since client unauthorised to connect, Clie ntId:%{public, location:escape_only}s, ServiceUuid:%{public, location:escape_only}s, ExpectedClientId:%{ public, location:escape_only}s}",  buf,  0x30u);
    if ((v90 & 0x80000000) == 0) {
      goto LABEL_130;
    }
    unint64_t v41 = v89[0];
    goto LABEL_129;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EDA0);
  }
  unsigned __int8 v30 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    char v31 = (char *)operator new(0x28uLL);
    *(void *)(v31 + 29) = 0LL;
    *(_OWORD *)char v31 = 0u;
    *((_OWORD *)v31 + 1) = 0u;
    sub_10000AE6C((uint64_t)&v116, v31);
    *(_DWORD *)uint64_t buf = 68289538;
    int v94 = 0;
    __int16 v95 = 2082;
    std::string v96 = "";
    __int16 v97 = 2082;
    std::string v98 = a2;
    __int16 v99 = 2082;
    std::string v100 = (void **)v31;
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:MiLoServiceManager cannot connect to service since database is not available, ClientId :%{public, location:escape_only}s, ServiceUuid:%{public, location:escape_only}s}",  buf,  0x26u);
    operator delete(v31);
  }

  uint64_t v23 = 33LL;
LABEL_132:
  if (SHIBYTE(__n[1]) < 0) {
    operator delete(__p);
  }
  return v23;
}

  unint64_t v12 = *(void *)(v5 + 104);
  if (!v12) {
    unint64_t v12 = *(void *)(qword_1019A0BA0 + 104);
  }
  unint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x13,  v12,  a2,  a4);
  unsigned __int8 v6 = *(_DWORD *)(v5 + 364);
  if ((v6 & 0x80000) == 0)
  {
LABEL_21:
    if ((v6 & 0x100000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_88;
  }

      if (qword_101934890 != -1) {
        dispatch_once(&qword_101934890, &stru_10184E040);
      }
      int v37 = (os_log_s *)qword_101934898;
      if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_ERROR,  "#EED2,sendAdr,failed to send",  (uint8_t *)&buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(&buf, 0x65CuLL);
        if (qword_101934890 != -1) {
          dispatch_once(&qword_101934890, &stru_10184E040);
        }
        v44[0] = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_101934898,  16LL,  "#EED2,sendAdr,failed to send",  v44,  2);
        unint64_t v41 = (char *)v40;
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLEmergencyEED2::sendAdr()", "%s\n", v40);
      }

      goto LABEL_89;
    }
  }

  if (qword_101934890 != -1) {
    dispatch_once(&qword_101934890, &stru_10184E040);
  }
  size_t v17 = (os_log_s *)qword_101934898;
  if (os_log_type_enabled((os_log_t)qword_101934898, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t buf = 68289026LL;
    __int16 v50 = 2082;
    __int16 v51 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#EED2,sendAdr,not configured for ADR encryption}",  (uint8_t *)&buf,  0x12u);
  }

      unsigned __int8 v30 = (uint64_t *)*v30;
      if (!v30) {
        return 1LL;
      }
    }

    char v39 = fabs(v38);
    __int16 v40 = fmax(v39 - *(double *)(a1 + 2136), 0.0);
    unint64_t v41 = v40 * 50.0;
    uint64_t v42 = fmax(v82 + v40 * 50.0, 1.0);
    __int16 v43 = v37 / v42;
    if (v37 / v42 > 1.0) {
      goto LABEL_51;
    }
    if ((sub_10044B5B8(a1 + 1840, &dbl_101347860) & 1) != 0) {
      goto LABEL_51;
    }
    __int16 v50 = *(_DWORD *)(a1 + 1912);
    if (v39 <= 6.0 || *(_BYTE *)(a1 + 2096) == 0)
    {
      int v26 = v81;
      if (*(_BYTE *)(a1 + 2096)) {
        goto LABEL_53;
      }
LABEL_78:
      __int16 v52 = *(_DWORD *)(a1 + 1912);
      if ((v52 - 3) < 8 || !v52)
      {
        if ((sub_10044B5B8(a1 + 1840, &dbl_101347860) & 1) != 0
          || (*(void *)uint64_t buf = 0xBFF0000000000000LL, sub_10044B330((void *)(a1 + 1840), (double *)buf)))
        {
          __int16 v53 = v30[6] + v30[5] - 1;
          __n128 v44 = 1.0;
          if (sub_100E8C200(*(void *)(v30[2] + 8 * (v53 / 0x17)) + 176 * (v53 % 0x17), v80) < 30.0) {
            __n128 v44 = 3.0;
          }
          goto LABEL_54;
        }
      }

  __int16 v43 = *(void *)(a1 + 88);
  if (!v43) {
    __int16 v43 = *(void *)(qword_1019A1C80 + 88);
  }
  __n128 v44 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1001E09F4(v43, a2);
  __n128 v46 = (int)v44;
  else {
    int v47 = 1;
  }
  uint64_t v5 = (v5 + v46 + v47 + 1);
  if ((*(_DWORD *)(a1 + 112) & 0x2000) != 0)
  {
LABEL_90:
    __int16 v48 = *(void *)(a1 + 96);
    if (!v48) {
      __int16 v48 = *(void *)(qword_1019A1C80 + 96);
    }
    __int16 v49 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1001E0DA4(v48);
    __int16 v51 = (int)v49;
    else {
      __int16 v52 = 1;
    }
    uint64_t v5 = (v5 + v51 + v52 + 1);
  }

  unint64_t v41 = *(void *)(a1 + 88);
  if (!v41) {
    unint64_t v41 = *(void *)(qword_1019A1D48 + 88);
  }
  uint64_t v42 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_1005063DC(v41, a2);
  __int16 v43 = (int)v42;
  else {
    __n128 v44 = 1;
  }
  uint64_t v4 = (v4 + v43 + v44 + 2);
  unint64_t v3 = *(_DWORD *)(a1 + 224);
  if ((v3 & 0x1000) == 0)
  {
LABEL_62:
    if ((v3 & 0x2000) == 0) {
      goto LABEL_63;
    }
    goto LABEL_96;
  }

      int v67 = 0LL;
      *(_BYTE *)(a1 + 296) = 0;
      goto LABEL_91;
    }

    if (*(_BYTE *)(a3 + 8)) {
      goto LABEL_84;
    }
    *(int8x8_t *)&int v69 = sub_10098329C((uint64_t)v45, (uint64_t)v45);
    (*(void (**)(uint64_t, char *, double))(*(void *)a1 + 152LL))(a1, v45, v69);
    if (*(_BYTE *)(a3 + 8))
    {
      uint64_t v70 = (os_log_s *)qword_101934A78;
      if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_DEBUG,  "TILE: headers only, avoid reading the APs",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        __int128 v71 = p_vtable;
        LOWORD(v172) = 0;
        LODWORD(v153) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934A78,  2LL,  "TILE: headers only, avoid reading the APs",  &v172,  v153);
        int v73 = (char *)v72;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLWifiTileFile::traverseTileFile(FILE *, const TraverseDetails &)",  "%s\n",  v72);
        goto LABEL_130;
      }

      goto LABEL_90;
    }

    std::string v79 = *((unsigned int *)v45 + 1);
    std::string v80 = *v46;
    std::string v81 = sub_1005B46E8((uint64_t)v160);
    std::string v82 = (uint64_t)v46 + v79;
    if (*(_BYTE *)(a3 + 9))
    {
      int v67 = 0LL;
      if (!v81 || !v159)
      {
        LODWORD(v84) = v80;
LABEL_142:
        sub_100C4B858(a1, v82, v84, a3, (uint64_t)v45);
        goto LABEL_91;
      }

      if (v158) {
        std::string v80 = (*(_DWORD *)(v158 + 6) + 1);
      }
      int v83 = *(unsigned int *)(v159 + 6);
      std::string v84 = v80 - v83;
      std::string v85 = *((_DWORD *)v45 + 4);
      int v155 = *((unsigned int *)v45 + 3);
      int v67 = malloc(v85 * ((_DWORD)v80 - (_DWORD)v83));
      if (!v67)
      {
        uint64_t v16 = 0LL;
LABEL_145:
        p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
        goto LABEL_92;
      }

      fseek(a2, v85 * (unint64_t)v83, 1);
      fread(v67, 1uLL, v84 * *((unsigned int *)v45 + 4), a2);
      fseek(a2, (v155 - v80) * *((unsigned int *)v45 + 4), 1);
      __int16 v43 = 0LL;
      std::string v82 = (uint64_t)v67;
      p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
      if (*(_BYTE *)(a3 + 9)) {
        goto LABEL_142;
      }
    }

    else
    {
      int v67 = 0LL;
    }

    if (v80)
    {
      __int16 v97 = 1LL;
      while (1)
      {
        std::string v98 = (int *)(v82 + (v97 - 1) * *((unsigned int *)v45 + 4));
        sub_1009832F0(v98, (uint64_t)v98);
        (*(void (**)(uint64_t, int *))(*(void *)a1 + 160LL))(a1, v98);
        *(void *)uint64_t buf = sub_1007EC028((unsigned __int8 *)v98);
        if (sub_1007EC0B0(v160, buf)) {
          break;
        }
        uint64_t v16 = 1LL;
        if (!*(_BYTE *)(a3 + 9) && v97++ < v80) {
          continue;
        }
        goto LABEL_145;
      }

      uint64_t v16 = 1LL;
      goto LABEL_145;
    }

    [v3 setObject:v7 forKey:@"workoutType"];
  }

  sessionId = self->_sessionId;
  if (sessionId) {
    [v3 setObject:sessionId forKey:@"sessionId"];
  }
  return v3;
}

  __n128 v44 = 0LL;
LABEL_85:
  ++*(_DWORD *)(a1 + 104);
LABEL_361:
  __int128 v199 = v247;
  if (v247)
  {
    __int128 v200 = (unint64_t *)&v247->__shared_owners_;
    do
      __int128 v201 = __ldaxr(v200);
    while (__stlxr(v201 - 1, v200));
    if (!v201)
    {
      ((void (*)(std::__shared_weak_count *))v199->__on_zero_shared)(v199);
      std::__shared_weak_count::__release_weak(v199);
    }
  }

  return v44;
}

  uint64_t v42 = *(void *)(a2 + 136);
  v5 |= 0x10000uLL;
  *uint64_t v2 = v5;
  *(void *)(a1 + 136) = v42;
  uint64_t v4 = *v3;
  if ((*v3 & 4) == 0)
  {
LABEL_42:
    if ((v4 & 0x40000) == 0) {
      goto LABEL_43;
    }
    goto LABEL_86;
  }

  PB::TextFormatter::format(this, "sosCanceledBecauseOfSteps", *(void *)(a1 + 288));
  unsigned __int8 v6 = *v5;
  if ((*v5 & 0x1000000000LL) == 0)
  {
LABEL_39:
    if ((v6 & 0x2000000000LL) == 0) {
      goto LABEL_40;
    }
    goto LABEL_86;
  }

  unint64_t result = PB::Writer::writeVarInt(this, *(void *)(v3 + 24), 0x55u);
  uint64_t v5 = *v4;
  if ((*v4 & 0x40000) == 0)
  {
LABEL_40:
    if ((v5 & 0x20000) == 0) {
      goto LABEL_41;
    }
    goto LABEL_86;
  }

  PB::TextFormatter::format(this, "lastMotionStateEndTime", *(void *)(a1 + 336));
  if ((*(_DWORD *)(a1 + 396) & 0x8000) != 0) {
LABEL_36:
  }
    PB::TextFormatter::format(this, "lastMotionStateStartTime", *(void *)(a1 + 344));
LABEL_37:
  uint64_t v16 = *(double **)(a1 + 80);
  size_t v17 = *(double **)(a1 + 88);
  while (v16 != v17)
  {
    uint64_t v18 = *v16++;
    PB::TextFormatter::format(this, "lockStateHistoryEndTimestamp", v18);
  }

  uint64_t v19 = *(double **)(a1 + 104);
  char v20 = *(double **)(a1 + 112);
  while (v19 != v20)
  {
    uint64_t v21 = *v19++;
    PB::TextFormatter::format(this, "lockStateHistoryStartTimestamp", v21);
  }

  uint64_t v22 = *(double **)(a1 + 128);
  uint64_t v23 = *(double **)(a1 + 136);
  while (v22 != v23)
  {
    uint64_t v24 = *v22++;
    PB::TextFormatter::format(this, "lockStateHistoryState", v24);
  }

  size_t v25 = *(_DWORD *)(a1 + 396);
  if ((v25 & 0x10000) != 0)
  {
    PB::TextFormatter::format(this, "motionLookbackBeforeImpactEndOfInterval", *(void *)(a1 + 352));
    size_t v25 = *(_DWORD *)(a1 + 396);
  }

  if ((v25 & 0x20000) != 0) {
    PB::TextFormatter::format(this, "motionLookbackBeforeImpactStartOfInterval", *(void *)(a1 + 360));
  }
  int v26 = *(double **)(a1 + 152);
  uint64_t v27 = *(double **)(a1 + 160);
  while (v26 != v27)
  {
    unsigned int v28 = *v26++;
    PB::TextFormatter::format(this, "motionStateHistoryEndTimestamp", v28);
  }

  uint64_t v29 = *(double **)(a1 + 176);
  unsigned __int8 v30 = *(double **)(a1 + 184);
  while (v29 != v30)
  {
    char v31 = *v29++;
    PB::TextFormatter::format(this, "motionStateHistoryStartTimestamp", v31);
  }

  __n128 v32 = *(double **)(a1 + 200);
  uint64_t v33 = *(double **)(a1 + 208);
  while (v32 != v33)
  {
    uint64_t v34 = *v32++;
    PB::TextFormatter::format(this, "motionStateHistoryState", v34);
  }

  size_t v35 = *(_DWORD *)(a1 + 396);
  if ((v35 & 0x40000) != 0)
  {
    PB::TextFormatter::format(this, "relativeTimestampToImpact", *(double *)(a1 + 368));
    size_t v35 = *(_DWORD *)(a1 + 396);
  }

  if ((v35 & 0x80000) != 0) {
    PB::TextFormatter::format(this, "timestamp", *(void *)(a1 + 376));
  }
  return PB::TextFormatter::endObject(this);
}

  unint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 384), 0x33u);
  uint64_t v4 = *(_DWORD *)(v3 + 396);
  if ((v4 & 0x400000) == 0)
  {
LABEL_25:
    if ((v4 & 0x40000000) == 0) {
      goto LABEL_26;
    }
    goto LABEL_86;
  }

  unint64_t result = *(float *)(a2 + 60);
  v3 |= 0x400uLL;
  *(void *)(a1 + 216) = v3;
  *(float *)(a1 + 60) = result;
  uint64_t v2 = *(void *)(a2 + 216);
  if ((v2 & 0x200000) == 0)
  {
LABEL_38:
    if ((v2 & 0x40000) == 0) {
      goto LABEL_39;
    }
    goto LABEL_86;
  }

  PB::TextFormatter::format(this, "simulated", *(_DWORD *)(a1 + 148));
  uint64_t v5 = *(void *)(a1 + 216);
  if ((v5 & 0x200000000LL) == 0)
  {
LABEL_35:
    if ((v5 & 0x400000000LL) == 0) {
      goto LABEL_36;
    }
    goto LABEL_86;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 104), 0x22u);
  uint64_t v4 = *(void *)(v3 + 216);
  if ((v4 & 0x40000) == 0)
  {
LABEL_36:
    if ((v4 & 0x20000000) == 0) {
      goto LABEL_37;
    }
    goto LABEL_86;
  }

  unint64_t result = *(float *)(a2 + 84);
  v5 |= 0x400uLL;
  *uint64_t v2 = v5;
  *(_BYTE *)(a1 + 324) = v6;
  *(float *)(a1 + 84) = result;
  uint64_t v7 = *v3;
  uint64_t v4 = *(_BYTE *)(a2 + 324);
  if ((*v3 & 0x800000) == 0)
  {
LABEL_19:
    if ((v7 & 0x4000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_86;
  }

  PB::TextFormatter::format(this, "deltaVXYZOverEpoch", *(float *)(a1 + 124));
  unsigned __int8 v6 = *v5;
  uint64_t v7 = *(_BYTE *)(a1 + 324);
  if ((*v5 & 0x200000) == 0)
  {
LABEL_18:
    if ((v6 & 0x400000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_86;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 84), 0xEu);
  unsigned __int8 v6 = *v4;
  uint64_t v5 = *((_BYTE *)v4 + 8);
  if ((*v4 & 0x800000) == 0)
  {
LABEL_19:
    if ((v6 & 0x4000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_86;
  }

  char v13 = *(_BYTE *)(a2 + 269);
  v6 |= 2u;
  *uint64_t v2 = v5;
  *(_WORD *)(a1 + 288) = v6;
  *(_BYTE *)(a1 + 269) = v13;
  uint64_t v4 = *v3;
  uint64_t v7 = *(_WORD *)(a2 + 288);
  if ((v7 & 1) == 0)
  {
LABEL_11:
    if ((v4 & 0x40000) == 0) {
      goto LABEL_12;
    }
    goto LABEL_86;
  }

  PB::TextFormatter::format(this, "audioDvChaosThresholdStretch", *(float *)(a1 + 32));
  unsigned __int8 v6 = *v5;
  uint64_t v7 = *(_WORD *)(a1 + 288);
  if ((*v5 & 0x40) == 0)
  {
LABEL_10:
    if ((v6 & 0x80) == 0) {
      goto LABEL_11;
    }
    goto LABEL_86;
  }

  unint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 272), 5u);
  uint64_t v5 = *v4;
  unsigned __int8 v6 = *((_WORD *)v4 + 4);
  if ((v6 & 2) == 0)
  {
LABEL_10:
    if ((v6 & 1) == 0) {
      goto LABEL_11;
    }
    goto LABEL_86;
  }

  uint64_t v24 = *(void *)(a2 + 32);
  v3 |= 8uLL;
  *(void *)(a1 + 172) = v3;
  *(void *)(a1 + 32) = v24;
  uint64_t v2 = *(void *)(a2 + 172);
  if ((v2 & 0x10) == 0)
  {
LABEL_41:
    if ((v2 & 0x20) == 0) {
      goto LABEL_42;
    }
    goto LABEL_86;
  }

  PB::TextFormatter::format(this, "parameterRollingPercentileWindowSize", *(_DWORD *)(a1 + 128));
  uint64_t v5 = *(void *)(a1 + 172);
  if ((v5 & 0x8000000) == 0)
  {
LABEL_38:
    if ((v5 & 0x100000000000LL) == 0) {
      goto LABEL_39;
    }
    goto LABEL_86;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 40), 0xCDu);
  uint64_t v4 = *(void *)(v3 + 172);
  if ((v4 & 0x20) == 0)
  {
LABEL_39:
    if ((v4 & 0x40) == 0) {
      goto LABEL_40;
    }
    goto LABEL_86;
  }

            PB::Reader::recallMark(this, v80);
          }

          else
          {
            unint64_t v61 = *(char **)(a1 + 40);
            __int16 v60 = *(void *)(a1 + 48);
            if ((unint64_t)v61 >= v60)
            {
              __int16 v68 = (char *)*v10;
              int v69 = (v61 - (_BYTE *)*v10) >> 3;
              uint64_t v70 = v69 + 1;
              if ((unint64_t)(v69 + 1) >> 61) {
LABEL_128:
              }
                sub_100007008();
              __int128 v71 = v60 - (void)v68;
              if (v71 >> 2 > v70) {
                uint64_t v70 = v71 >> 2;
              }
              else {
                uint64_t v72 = v70;
              }
              if (v72)
              {
                int v73 = (char *)sub_1000071BC(v11, v72);
                __int16 v68 = *(char **)(a1 + 32);
                unint64_t v61 = *(char **)(a1 + 40);
              }

              else
              {
                int v73 = 0LL;
              }

              uint64_t v76 = &v73[8 * v69];
              *(void *)uint64_t v76 = 0LL;
              std::string v59 = v76 + 8;
              while (v61 != v68)
              {
                unsigned __int8 v77 = *((void *)v61 - 1);
                v61 -= 8;
                *((void *)v76 - 1) = v77;
                v76 -= 8;
              }

              *(void *)(a1 + 32) = v76;
              *(void *)(a1 + 40) = v59;
              *(void *)(a1 + sub_10000AE14(v17 - 48) = &v73[8 * v72];
              if (v68) {
                operator delete(v68);
              }
            }

            else
            {
              *(void *)unint64_t v61 = 0LL;
              std::string v59 = v61 + 8;
            }

            *(void *)(a1 + 40) = v59;
LABEL_115:
            int v78 = *((void *)this + 1);
            if (v78 <= 0xFFFFFFFFFFFFFFF7LL && v78 + 8 <= *((void *)this + 2))
            {
              *(v59 - 1) = *(void *)(*(void *)this + v78);
LABEL_119:
              *((void *)this + 1) += 8LL;
            }

            else
            {
LABEL_117:
              *((_BYTE *)this + 24) = 1;
            }
          }

  LODWORD(v4) = *(_DWORD *)(a2 + 44);
  v3 |= 0x40uLL;
  *(void *)(a1 + 184) = v3;
  *(_DWORD *)(a1 + 44) = v4;
  uint64_t v2 = *(void *)(a2 + 184);
  if ((v2 & 0x100) == 0)
  {
LABEL_42:
    if ((v2 & 0x200) == 0) {
      goto LABEL_43;
    }
    goto LABEL_86;
  }

  PB::TextFormatter::format(this, "swingIndexOfHarmonicityML", *(float *)(a1 + 144));
  uint64_t v5 = *(void *)(a1 + 184);
  if ((v5 & 0x100000000LL) == 0)
  {
LABEL_39:
    if ((v5 & 0x200000000LL) == 0) {
      goto LABEL_40;
    }
    goto LABEL_86;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 52), 0x26u);
  uint64_t v4 = *(void *)(v3 + 184);
  if ((v4 & 0x200) == 0)
  {
LABEL_40:
    if ((v4 & 0x400000) == 0) {
      goto LABEL_41;
    }
    goto LABEL_86;
  }

          *(_DWORD *)(a1 + sub_10000AE14(v17 - 48) = v31;
          goto LABEL_96;
        case 3u:
          if ((_DWORD)v24 == 2)
          {
            if ((PB::Reader::placeMark(this, v68, v24, a4) & 1) != 0) {
              return 0LL;
            }
            uint64_t v34 = *((void *)this + 1);
            size_t v35 = *((void *)this + 2);
            while (v34 < v35 && !*((_BYTE *)this + 24))
            {
              int v37 = *(char **)(a1 + 16);
              __int16 v36 = *(void *)(a1 + 24);
              if ((unint64_t)v37 >= v36)
              {
                char v39 = (char *)*v10;
                __int16 v40 = (v37 - (_BYTE *)*v10) >> 2;
                unint64_t v41 = v40 + 1;
                uint64_t v42 = v36 - (void)v39;
                if (v42 >> 1 > v41) {
                  unint64_t v41 = v42 >> 1;
                }
                else {
                  __int16 v43 = v41;
                }
                if (v43)
                {
                  __n128 v44 = (char *)sub_10000956C(v11, v43);
                  char v39 = *(char **)(a1 + 8);
                  int v37 = *(char **)(a1 + 16);
                }

                else
                {
                  __n128 v44 = 0LL;
                }

                char v45 = &v44[4 * v40];
                *(_DWORD *)char v45 = 0;
                unsigned __int8 v38 = v45 + 4;
                while (v37 != v39)
                {
                  __n128 v46 = *((_DWORD *)v37 - 1);
                  v37 -= 4;
                  *((_DWORD *)v45 - 1) = v46;
                  v45 -= 4;
                }

                *(void *)(a1 + 8) = v45;
                *(void *)(a1 + 16) = v38;
                *(void *)(a1 + 24) = &v44[4 * v43];
                if (v39) {
                  operator delete(v39);
                }
              }

              else
              {
                *(_DWORD *)int v37 = 0;
                unsigned __int8 v38 = v37 + 4;
              }

              *(void *)(a1 + 16) = v38;
              int v47 = *((void *)this + 1);
              if (v47 > 0xFFFFFFFFFFFFFFFBLL || v47 + 4 > *((void *)this + 2))
              {
                *((_BYTE *)this + 24) = 1;
                break;
              }

              *(v38 - 1) = *(_DWORD *)(*(void *)this + v47);
              size_t v35 = *((void *)this + 2);
              uint64_t v34 = *((void *)this + 1) + 4LL;
              *((void *)this + 1) = v34;
            }

            PB::Reader::recallMark(this, v68);
          }

          else
          {
            __int16 v55 = *(char **)(a1 + 16);
            uint64_t v54 = *(void *)(a1 + 24);
            if ((unint64_t)v55 >= v54)
            {
              uint64_t v57 = (char *)*v10;
              uint64_t v58 = (v55 - (_BYTE *)*v10) >> 2;
              std::string v59 = v58 + 1;
              if ((unint64_t)(v58 + 1) >> 62) {
LABEL_107:
              }
                sub_100007008();
              __int16 v60 = v54 - (void)v57;
              if (v60 >> 1 > v59) {
                std::string v59 = v60 >> 1;
              }
              else {
                unint64_t v61 = v59;
              }
              if (v61)
              {
                __int16 v62 = (char *)sub_10000956C(v11, v61);
                uint64_t v57 = *(char **)(a1 + 8);
                __int16 v55 = *(char **)(a1 + 16);
              }

              else
              {
                __int16 v62 = 0LL;
              }

              char v63 = &v62[4 * v58];
              *(_DWORD *)char v63 = 0;
              uint64_t v56 = v63 + 4;
              while (v55 != v57)
              {
                int v64 = *((_DWORD *)v55 - 1);
                v55 -= 4;
                *((_DWORD *)v63 - 1) = v64;
                v63 -= 4;
              }

              *(void *)(a1 + 8) = v63;
              *(void *)(a1 + 16) = v56;
              *(void *)(a1 + 24) = &v62[4 * v61];
              if (v57) {
                operator delete(v57);
              }
            }

            else
            {
              *(_DWORD *)__int16 v55 = 0;
              uint64_t v56 = v55 + 4;
            }

            *(void *)(a1 + 16) = v56;
            std::string v65 = *((void *)this + 1);
            if (v65 <= 0xFFFFFFFFFFFFFFFBLL && v65 + 4 <= *((void *)this + 2))
            {
              *(v56 - 1) = *(_DWORD *)(*(void *)this + v65);
              __int16 v49 = *((void *)this + 1) + 4LL;
LABEL_61:
              *((void *)this + 1) = v49;
            }

            else
            {
LABEL_95:
              *((_BYTE *)this + 24) = 1;
            }
          }

          *(_DWORD *)(a1 + sub_10000AE14(v17 - 48) = v31;
          goto LABEL_96;
        case 3u:
          if ((_DWORD)v24 == 2)
          {
            if ((PB::Reader::placeMark(this, v68, v24, a4) & 1) != 0) {
              return 0LL;
            }
            uint64_t v34 = *((void *)this + 1);
            size_t v35 = *((void *)this + 2);
            while (v34 < v35 && !*((_BYTE *)this + 24))
            {
              int v37 = *(char **)(a1 + 16);
              __int16 v36 = *(void *)(a1 + 24);
              if ((unint64_t)v37 >= v36)
              {
                char v39 = (char *)*v10;
                __int16 v40 = (v37 - (_BYTE *)*v10) >> 2;
                unint64_t v41 = v40 + 1;
                uint64_t v42 = v36 - (void)v39;
                if (v42 >> 1 > v41) {
                  unint64_t v41 = v42 >> 1;
                }
                else {
                  __int16 v43 = v41;
                }
                if (v43)
                {
                  __n128 v44 = (char *)sub_10000956C(v11, v43);
                  char v39 = *(char **)(a1 + 8);
                  int v37 = *(char **)(a1 + 16);
                }

                else
                {
                  __n128 v44 = 0LL;
                }

                char v45 = &v44[4 * v40];
                *(_DWORD *)char v45 = 0;
                unsigned __int8 v38 = v45 + 4;
                while (v37 != v39)
                {
                  __n128 v46 = *((_DWORD *)v37 - 1);
                  v37 -= 4;
                  *((_DWORD *)v45 - 1) = v46;
                  v45 -= 4;
                }

                *(void *)(a1 + 8) = v45;
                *(void *)(a1 + 16) = v38;
                *(void *)(a1 + 24) = &v44[4 * v43];
                if (v39) {
                  operator delete(v39);
                }
              }

              else
              {
                *(_DWORD *)int v37 = 0;
                unsigned __int8 v38 = v37 + 4;
              }

              *(void *)(a1 + 16) = v38;
              int v47 = *((void *)this + 1);
              if (v47 > 0xFFFFFFFFFFFFFFFBLL || v47 + 4 > *((void *)this + 2))
              {
                *((_BYTE *)this + 24) = 1;
                break;
              }

              *(v38 - 1) = *(_DWORD *)(*(void *)this + v47);
              size_t v35 = *((void *)this + 2);
              uint64_t v34 = *((void *)this + 1) + 4LL;
              *((void *)this + 1) = v34;
            }

            PB::Reader::recallMark(this, v68);
          }

          else
          {
            __int16 v55 = *(char **)(a1 + 16);
            uint64_t v54 = *(void *)(a1 + 24);
            if ((unint64_t)v55 >= v54)
            {
              uint64_t v57 = (char *)*v10;
              uint64_t v58 = (v55 - (_BYTE *)*v10) >> 2;
              std::string v59 = v58 + 1;
              if ((unint64_t)(v58 + 1) >> 62) {
LABEL_107:
              }
                sub_100007008();
              __int16 v60 = v54 - (void)v57;
              if (v60 >> 1 > v59) {
                std::string v59 = v60 >> 1;
              }
              else {
                unint64_t v61 = v59;
              }
              if (v61)
              {
                __int16 v62 = (char *)sub_10000956C(v11, v61);
                uint64_t v57 = *(char **)(a1 + 8);
                __int16 v55 = *(char **)(a1 + 16);
              }

              else
              {
                __int16 v62 = 0LL;
              }

              char v63 = &v62[4 * v58];
              *(_DWORD *)char v63 = 0;
              uint64_t v56 = v63 + 4;
              while (v55 != v57)
              {
                int v64 = *((_DWORD *)v55 - 1);
                v55 -= 4;
                *((_DWORD *)v63 - 1) = v64;
                v63 -= 4;
              }

              *(void *)(a1 + 8) = v63;
              *(void *)(a1 + 16) = v56;
              *(void *)(a1 + 24) = &v62[4 * v61];
              if (v57) {
                operator delete(v57);
              }
            }

            else
            {
              *(_DWORD *)__int16 v55 = 0;
              uint64_t v56 = v55 + 4;
            }

            *(void *)(a1 + 16) = v56;
            std::string v65 = *((void *)this + 1);
            if (v65 <= 0xFFFFFFFFFFFFFFFBLL && v65 + 4 <= *((void *)this + 2))
            {
              *(v56 - 1) = *(_DWORD *)(*(void *)this + v65);
              __int16 v49 = *((void *)this + 1) + 4LL;
LABEL_61:
              *((void *)this + 1) = v49;
            }

            else
            {
LABEL_95:
              *((_BYTE *)this + 24) = 1;
            }
          }

  size_t v35 = *(_DWORD *)(a2 + 168);
  v3 |= 0x8000000000uLL;
  *(void *)(result + 188) = v3;
  *(_DWORD *)(result + 168) = v35;
  uint64_t v2 = *(void *)(a2 + 188);
  if ((v2 & 0x80000) == 0)
  {
LABEL_37:
    if ((v2 & 0x200000000000LL) == 0) {
      goto LABEL_38;
    }
    goto LABEL_86;
  }

  PB::TextFormatter::format(this, "srcOmegaInertial_Z", *(float *)(a1 + 112));
  uint64_t v5 = *(void *)(a1 + 188);
  if ((v5 & 0x4000000) == 0)
  {
LABEL_34:
    if ((v5 & 0x8000000) == 0) {
      goto LABEL_35;
    }
    goto LABEL_86;
  }

  unint64_t result = PB::Writer::write(this, *(float *)(v3 + 88), 0x21u);
  uint64_t v4 = *(void *)(v3 + 188);
  if ((v4 & 0x200000000000LL) == 0)
  {
LABEL_35:
    if ((v4 & 0x800) == 0) {
      goto LABEL_36;
    }
    goto LABEL_86;
  }

void sub_1000E5F6C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, char a27)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_1000EA040(v27 - 224);
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000E607C()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfConnectedUnsupervisedServicesPerClient",  0x8000100u,  kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  uint64_t v2 = v7;
  unint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 1LL;
  }
}

void sub_1000E6138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1000E6150()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfConnectedBinaryRoiServicesPerClient",  0x8000100u,  kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  uint64_t v2 = v7;
  unint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 1LL;
  }
}

void sub_1000E620C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1000E6224()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfConnectedMulticlassServicesPerClient",  0x8000100u,  kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  uint64_t v2 = v7;
  unint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 1LL;
  }
}

void sub_1000E62E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1000E62F8()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfConnectedSimilarityListServicesPerClient",  0x8000100u,  kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  uint64_t v2 = v7;
  unint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 10LL;
  }
}

void sub_1000E63B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void *sub_1000E63D0(uint64_t *a1, __int128 *a2)
{
  unint64_t v3 = sub_1000EB488((uint64_t)a1, 0LL, 0LL, a2);
  uint64_t v4 = *a1;
  void *v3 = *a1;
  v3[1] = a1;
  *(void *)(v4 + 8) = v3;
  *a1 = (uint64_t)v3;
  ++a1[2];
  return v3 + 2;
}

uint64_t sub_1000E641C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1000E647C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 104);
  uint64_t v3 = sub_1000F0EE0(a2);
  uint64_t v5 = v4;
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  return sub_10002E988(v2, v3, v5, Current_1);
}

void sub_1000E64C0(uint64_t a1, void *a2)
{
  uint64_t v4 = (unint64_t *)(a1 + 112);
  if (!*(_BYTE *)(a1 + 136)) {
    sub_100036CD8();
  }
  if (*v4 != 2)
  {
    __int128 v42 = 0uLL;
    goto LABEL_19;
  }

  sub_1002F0B04(&v42);
  CFStringRef v5 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsEnableServiceInCustomLOI", 0x8000100u, kCFAllocatorNull);
  char v6 = sub_1002A6FD4(v42, (uint64_t)v5, (BOOL *)&v41);
  CFRelease(v5);
  int v7 = v41;
  uint64_t v8 = (std::__shared_weak_count *)*((void *)&v42 + 1);
  if (*((void *)&v42 + 1))
  {
    uint64_t v9 = (unint64_t *)(*((void *)&v42 + 1) + 8LL);
    do
      unint64_t v10 = __ldaxr(v9);
    while (__stlxr(v10 - 1, v9));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }

  char v11 = v7 ? v6 : 0;
  if ((v11 & 1) == 0)
  {
LABEL_16:
    sub_1000E6F98(a1, (uint64_t)a2);
LABEL_17:
    sub_1000F7264(a2, v4);
    return;
  }

  int v12 = *(unsigned __int8 *)(a1 + 136);
  __int128 v42 = 0uLL;
  if (!v12) {
    sub_100036CD8();
  }
LABEL_19:
  sub_1000E8CD8(a1, (uint64_t)a2, &v41);
  __int128 v13 = v41;
  __int128 v41 = 0uLL;
  uint64_t v14 = (std::__shared_weak_count *)*((void *)&v42 + 1);
  __int128 v42 = v13;
  if (v14)
  {
    p_shared_owners = (unint64_t *)&v14->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  size_t v17 = (std::__shared_weak_count *)*((void *)&v41 + 1);
  if (*((void *)&v41 + 1))
  {
    uint64_t v18 = (unint64_t *)(*((void *)&v41 + 1) + 8LL);
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  uint64_t v20 = v42;
  if ((void)v42) {
    goto LABEL_42;
  }
  if (!*(_BYTE *)(a1 + 136)) {
    sub_100036CD8();
  }
  sub_1000E7A74((uint64_t)a2, *(void *)(a1 + 104), a1 + 152, (uint64_t *)v4, &v41);
  __int128 v21 = v41;
  __int128 v41 = 0uLL;
  uint64_t v22 = (std::__shared_weak_count *)*((void *)&v42 + 1);
  __int128 v42 = v21;
  if (v22)
  {
    uint64_t v23 = (unint64_t *)&v22->__shared_owners_;
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  size_t v25 = (std::__shared_weak_count *)*((void *)&v41 + 1);
  if (*((void *)&v41 + 1))
  {
    int v26 = (unint64_t *)(*((void *)&v41 + 1) + 8LL);
    do
      unint64_t v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }

  sub_1000E8F38((char **)(a1 + 16), &v42);
  uint64_t v20 = v42;
  if ((void)v42)
  {
LABEL_42:
    uint64_t v39 = v20;
    __int16 v40 = (std::__shared_weak_count *)*((void *)&v42 + 1);
    if (*((void *)&v42 + 1))
    {
      unsigned int v28 = (unint64_t *)(*((void *)&v42 + 1) + 8LL);
      do
        unint64_t v29 = __ldxr(v28);
      while (__stxr(v29 + 1, v28));
    }

    sub_1000F2D54((uint64_t)a2, &v39);
    unsigned __int8 v30 = v40;
    if (v40)
    {
      char v31 = (unint64_t *)&v40->__shared_owners_;
      do
        unint64_t v32 = __ldaxr(v31);
      while (__stlxr(v32 - 1, v31));
      if (!v32)
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }

    uint64_t v33 = (std::__shared_weak_count *)*((void *)&v42 + 1);
    __int128 v42 = 0uLL;
    if (v33)
    {
      uint64_t v34 = (unint64_t *)&v33->__shared_owners_;
      do
        unint64_t v35 = __ldaxr(v34);
      while (__stlxr(v35 - 1, v34));
      if (!v35)
      {
        ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
        std::__shared_weak_count::__release_weak(v33);
      }

      __int16 v36 = (std::__shared_weak_count *)*((void *)&v42 + 1);
      if (*((void *)&v42 + 1))
      {
        int v37 = (unint64_t *)(*((void *)&v42 + 1) + 8LL);
        do
          unint64_t v38 = __ldaxr(v37);
        while (__stlxr(v38 - 1, v37));
        if (!v38)
        {
          ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
          std::__shared_weak_count::__release_weak(v36);
        }
      }
    }

    goto LABEL_17;
  }

  sub_10122A2FC();
  abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/ServiceManager/CLMiLoServiceManager.mm",  679,  "enterLocationPerService");
  __break(1u);
}

void sub_1000E684C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_1000E688C(uint64_t a1)
{
  uint64_t v2 = a1 + 40;
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3 == a1 + 40)
  {
    LOBYTE(v4) = 0;
  }

  else
  {
    int v4 = 0;
    do
    {
      v4 |= sub_1000F50E0(v3 + 16);
      uint64_t v3 = *(void *)(v3 + 8);
    }

    while (v3 != v2);
  }

  return (*(uint64_t (**)(uint64_t, void))(*(void *)(*(void *)(a1 + 144) + 8LL) + 64LL))( *(void *)(a1 + 144) + 8LL,  v4 & 1);
}

uint64_t sub_1000E68F4(void *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  v78[0] = a3;
  v78[1] = a4;
  unint64_t v8 = sub_1000E5024((uint64_t)a1, a3, a4);
  if (v9)
  {
    uint64_t v10 = v8;
    char v11 = (unsigned __int8 *)sub_1000F0EEC(v8);
    uint64_t v12 = v11[23];
    if ((v12 & 0x80u) == 0LL) {
      uint64_t v13 = v11[23];
    }
    else {
      uint64_t v13 = *((void *)v11 + 1);
    }
    uint64_t v14 = a2[23];
    int v15 = (char)v14;
    if ((v14 & 0x80u) != 0LL) {
      uint64_t v14 = *((void *)a2 + 1);
    }
    if (v13 == v14)
    {
      if (v15 >= 0) {
        unint64_t v16 = a2;
      }
      else {
        unint64_t v16 = *(unsigned __int8 **)a2;
      }
      if ((v12 & 0x80) == 0)
      {
        if (v11[23])
        {
          while (*v11 == *v16)
          {
            ++v11;
            ++v16;
            if (!--v12) {
              goto LABEL_32;
            }
          }

          goto LABEL_22;
        }

void sub_1000E6F24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  char v6 = va_arg(va1, void **);
  uint64_t v8 = va_arg(va1, void);
  sub_1000AA544((void ***)va);
  sub_1000E4D84((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1000E6F98(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 24);
  int v4 = (uint64_t *)(a1 + 16);
  sub_1000F3710(a2);
  uint64_t v8 = *v4;
  uint64_t v7 = v4[1];
  if (*v4 == v7)
  {
    uint64_t v7 = *v4;
  }

  else
  {
    uint64_t v9 = v8 + 16;
    while (1)
    {
      uint64_t v10 = *(void *)(v9 - 8);
      if (v10)
      {
        if (!*(void *)(v10 + 8)) {
          break;
        }
      }

      BOOL v11 = v9 == v7;
      v9 += 16LL;
      if (v11)
      {
        uint64_t v8 = v4[1];
        goto LABEL_16;
      }
    }

    uint64_t v8 = v9 - 16;
    if (v9 - 16 != v7 && v9 != v7)
    {
      do
      {
        uint64_t v12 = *(void *)(v9 + 8);
        if (!v12 || *(void *)(v12 + 8))
        {
          sub_10005F550(v8, (__int128 *)v9);
          v8 += 16LL;
        }

        v9 += 16LL;
      }

      while (v9 != v7);
      uint64_t v7 = *(void *)(a1 + 24);
    }
  }

void sub_1000E719C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1000E71B0(void *a1, uint64_t a2, uint64_t a3)
{
  v10[0] = a2;
  v10[1] = a3;
  int v4 = a1 + 5;
  uint64_t v5 = (uint64_t *)a1[6];
  uint64_t v11 = a2;
  uint64_t v12 = a3;
  while (v5 != v4)
  {
    if (sub_1000F0EE0((uint64_t)(v5 + 2)) == v11 && v6 == v12)
    {
      int v4 = v5;
      break;
    }

    uint64_t v5 = (uint64_t *)v5[1];
  }

  uint64_t v8 = *v4;
  *(void *)(v8 + 8) = v4[1];
  *(void *)v4[1] = v8;
  --a1[7];
  sub_1000EAB08((uint64_t)(v4 + 2));
  operator delete(v4);
  return sub_10005BE44(a1 + 8, v10);
}

void sub_1000E7280(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_1000E72E8(a2);
  if (v8)
  {
    int v9 = *(unsigned __int8 *)(a1 + 136);
    *(void *)(a1 + 112) = v7;
    *(void *)(a1 + 120) = a3;
    *(void *)(a1 + 128) = a4;
    if (!v9) {
      *(_BYTE *)(a1 + 136) = 1;
    }
  }

  else if (*(_BYTE *)(a1 + 136))
  {
    *(_BYTE *)(a1 + 136) = 0;
  }

  sub_1000E741C((void *)a1);
}

uint64_t sub_1000E72E8(uint64_t *a1)
{
  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    int v1 = *((unsigned __int8 *)a1 + 23);
    if (v1 != 4)
    {
      if (v1 != 6) {
        return 30LL;
      }
      if (*(_DWORD *)a1 != 1953723747 || *((_WORD *)a1 + 2) != 28015)
      {
LABEL_25:
        if (v1 == 4) {
          goto LABEL_26;
        }
        return 30LL;
      }

      return 2LL;
    }

    if (*(_DWORD *)a1 != 1701670760)
    {
      if (*(_DWORD *)a1 != 1802661751) {
        goto LABEL_25;
      }
      return 1LL;
    }

    return 0LL;
  }

  uint64_t v3 = a1[1];
  if (v3 == 4)
  {
    if (*(_DWORD *)*a1 == 1701670760) {
      return 0LL;
    }
    if (*(_DWORD *)*a1 == 1802661751) {
      return 1LL;
    }
    uint64_t v3 = a1[1];
  }

  if (v3 == 6)
  {
    if (*(_DWORD *)*a1 == 1953723747 && *(_WORD *)(*a1 + 4) == 28015) {
      return 2LL;
    }
    uint64_t v3 = a1[1];
  }

  if (v3 != 4) {
    return 30LL;
  }
  a1 = (uint64_t *)*a1;
LABEL_26:
  if (*(_DWORD *)a1 != 1701736302) {
    return 30LL;
  }
  return 0LL;
}

void sub_1000E741C(void *a1)
{
  uint64_t v3 = -[CLOSTransaction initWithDescription:]( objc_alloc(&OBJC_CLASS___CLOSTransaction),  "initWithDescription:",  "com.apple.locationd.microlocation-update-all-models");
  sub_1000E749C(a1);
  for (uint64_t i = (void *)a1[6]; i != a1 + 5; uint64_t i = (void *)i[1])
    sub_1000E64C0((uint64_t)a1, i + 2);
  sub_1000E688C((uint64_t)a1);
}

uint64_t sub_1000E749C(void *a1)
{
  uint64_t v2 = a1 + 5;
  for (uint64_t i = (void *)a1[6]; i != v2; uint64_t i = (void *)i[1])
    sub_1000E6F98((uint64_t)a1, (uint64_t)(i + 2));
  uint64_t v5 = a1[2];
  uint64_t result = a1[3];
  if (v5 != result)
  {
    uint64_t v6 = a1[2];
    do
    {
      uint64_t v7 = *(void *)(v6 + 8);
      if (!v7 || *(void *)(v7 + 8)) {
        sub_10122A47C();
      }
      v6 += 16LL;
    }

    while (v6 != result);
    for (; result != v5; uint64_t result = sub_10000AE14(result - 16))
      ;
  }

  a1[3] = v5;
  return result;
}

uint64_t sub_1000E7530(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, uint64_t a5, int a6)
{
  int v9 = (uint64_t *)sub_1000E5024(a1, a2, a3);
  if (v10) {
    return sub_1000F5A08(v9, a4, a5, a6);
  }
  else {
    return 0LL;
  }
}

BOOL sub_1000E7588(uint64_t a1, uint64_t *a2, int a3)
{
  int v4 = (void *)sub_1000E5024(a1, *a2, a2[1]);
  uint64_t v6 = v5;
  if (v5) {
    sub_1000F8348(v4, a3);
  }
  return v6 != 0;
}

BOOL sub_1000E75C8(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (_BYTE *)sub_1000E5024(a1, *a2, a2[1]);
  uint64_t v4 = v3;
  if (v3) {
    sub_1000F8360(v2);
  }
  return v4 != 0;
}

void sub_1000E7600(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (int64x2_t *)(a1 + 40);
  uint64_t v7 = *(int64x2_t **)(a1 + 48);
  if (v7 != (int64x2_t *)(a1 + 40))
  {
    do
    {
      v5 &= 0xFFFFFFFFFFFFFF00LL;
      v4 &= 0xFFFFFFFFFFFFFF00LL;
      uint64_t v11 = sub_1000F2D44((uint64_t)v7[1].i64);
      if (v12)
      {
        for (uint64_t i = *a2; i != a2[1]; i += 216LL)
        {
          if (*(_OWORD *)(i + 168) == *(_OWORD *)(v11 + 352))
          {
            uint64_t v5 = i;
            unint64_t v4 = v4 & 0xFFFFFFFFFFFFFF00LL | 1;
          }
        }
      }

      sub_1000F14CC(v7 + 1, v5, v4, a3, a4);
      uint64_t v7 = (int64x2_t *)v7->i64[1];
    }

    while (v7 != v6);
  }

void sub_1000E7704(uint64_t a1)
{
  uint64_t v1 = a1 + 40;
  for (uint64_t i = *(void *)(a1 + 48); i != v1; uint64_t i = *(void *)(i + 8))
    sub_1000F27C0(i + 16);
}

void sub_1000E773C(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 40;
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3 != a1 + 40)
  {
    do
    {
      sub_1000F27C8((uint64_t *)(v3 + 16), a2);
      uint64_t v3 = *(void *)(v3 + 8);
    }

    while (v3 != v2);
  }

uint64_t sub_1000E7788(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)&__int128 v12 = a4;
  *((void *)&v12 + 1) = a5;
  int v9 = (uint64_t *)sub_1000E5024(a1, a2, a3);
  if (v10) {
    return sub_1000F5E84(v9, &v12, a6, a7);
  }
  else {
    return 0LL;
  }
}

BOOL sub_1000E7804(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v12[0] = a4;
  v12[1] = a5;
  v11[0] = a6;
  v11[1] = a7;
  uint64_t v7 = (void *)sub_1000E5024(a1, a2, a3);
  uint64_t v9 = v8;
  if (v8) {
    sub_1000F731C(v7, v12, v11);
  }
  return v9 != 0;
}

BOOL sub_1000E7878(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = (void *)sub_1000E5024(a1, a2, a3);
  uint64_t v13 = v12;
  if (v12) {
    sub_1000F806C(v11, a4, a5, a6, a7);
  }
  return v13 != 0;
}

uint64_t sub_1000E78D8(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(a1 + 144) + 8LL) + 32LL))(*(void *)(a1 + 144) + 8LL);
}

uint64_t sub_1000E78E8(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(a1 + 144) + 8LL) + 48LL))(*(void *)(a1 + 144) + 8LL);
}

uint64_t sub_1000E78F8(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(a1 + 144) + 8LL) + 56LL))(*(void *)(a1 + 144) + 8LL);
}

uint64_t sub_1000E7908(uint64_t a1)
{
  return a1 + 16;
}

uint64_t sub_1000E7910@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = result + 40;
  for (uint64_t i = *(void *)(result + 48); ; uint64_t i = *(void *)(i + 8))
  {
    if (i == v5)
    {
      *a4 = 0LL;
      a4[1] = 0LL;
      return result;
    }

    uint64_t result = sub_1000F0EE0(i + 16);
    if (result == a2 && v7 == a3) {
      break;
    }
  }

  return sub_1000F2D20(i + 16, a4);
}

uint64_t sub_1000E79D8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v5 = a3;
    uint64_t v6 = *(void *)(a1 + 8);
    if (a3 == v6)
    {
      uint64_t v8 = a2;
    }

    else
    {
      uint64_t v7 = 16 * ((a3 - a2) >> 4);
      uint64_t v8 = a2;
      do
      {
        sub_10005F550(v8, (__int128 *)(v8 + v7));
        v8 += 16LL;
      }

      while (v8 + v7 != v6);
      uint64_t v5 = *(void *)(a1 + 8);
    }

    while (v5 != v8)
      uint64_t v5 = sub_10000AE14(v5 - 16);
    *(void *)(a1 + 8) = v8;
  }

  return a2;
}

uint64_t sub_1000E7A74@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X3>, void *a5@<X8>)
{
  LOBYTE(v102) = 0;
  char v109 = 0;
  if (sub_1000F0F50(a1) == 1)
  {
    sub_1000289F0(a2, 0, a4[1], a4[2], __p);
    sub_1000A88B8((uint64_t)&v102, (uint64_t)__p);
    sub_100019D34((uint64_t)__p);
    if (!v109) {
      goto LABEL_15;
    }
    if (!v107)
    {
      sub_1000F0F40(a1, __p);
      if (!v109) {
        sub_100036CD8();
      }
      sub_1000EA1D8(&v106, (const std::string *)__p);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      if (!v109) {
        sub_100036CD8();
      }
      sub_1000A83A0(__p, &v102);
      memset(&v89, 0, sizeof(v89));
      LOBYTE(v63) = 0;
      v89.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x118uLL);
      v89.__r_.__value_.__l.__size_ = v89.__r_.__value_.__r.__words[0];
      v89.__r_.__value_.__l.__cap_ = v89.__r_.__value_.__r.__words[0] + 280;
      v89.__r_.__value_.__l.__size_ = (std::string::size_type)sub_1000A841C( (uint64_t)&v89.__r_.__value_.__l.__cap_,  (__int128 *)__p,  &v84,  v89.__r_.__value_.__l.__data_);
      sub_1000A7EA8(a2, (uint64_t *)&v89);
      char v62 = &v89;
      sub_1000A8578((void ***)&v62);
      if (v83[0] && v82 < 0) {
        operator delete(v81);
      }
      sub_10006F50C((char *)&v72 + 2);
    }
  }

  else
  {
    sub_1000F61C4(a1, &v89);
    sub_1000292D0(a2, (uint64_t)&v89, a4[1], a4[2], __p);
    sub_1000A88B8((uint64_t)&v102, (uint64_t)__p);
    sub_100019D34((uint64_t)__p);
  }

  if (v109)
  {
LABEL_97:
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EDA0);
    }
    uint64_t v33 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      if (!v109 || !v107) {
        sub_100036CD8();
      }
      if ((v106.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v34 = &v106;
      }
      else {
        uint64_t v34 = (std::string *)v106.__r_.__value_.__r.__words[0];
      }
      unint64_t v35 = operator new(0x28uLL);
      char v62 = v35;
      __int128 v63 = xmmword_1012C8460;
      _OWORD *v35 = 0u;
      v35[1] = 0u;
      *(void *)((char *)v35 + 29) = 0LL;
      sub_10000AE6C((uint64_t)&v102, v35);
      if (v63 >= 0) {
        __int16 v36 = (std::string *)&v62;
      }
      else {
        __int16 v36 = (std::string *)v62;
      }
      if (!v109) {
        sub_100036CD8();
      }
      uint64_t v37 = (char *)v104;
      memset(v57, 0, 24);
      if ((sub_100013090((uint64_t)v108, v57) & 1) == 0)
      {
        std::bad_cast::bad_cast((std::bad_cast *)&v89);
        v89.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101818CB0;
        sub_1000139B0((uint64_t)&v89);
      }

      int v38 = v57;
      if ((v57[0].__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v38 = (std::string *)v57[0].__r_.__value_.__r.__words[0];
      }
      *(void *)std::string __p = 68290051LL;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&_BYTE __p[10] = "";
      *(_WORD *)&_BYTE __p[18] = 2082;
      *(void *)&__p[20] = v34;
      __int16 v71 = 2082;
      __int16 v72 = v36;
      __int16 v73 = 2050;
      __int16 v74 = v37;
      __int16 v75 = 2081;
      char v76 = v38;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoServiceManager loaded model from DB:, ClientId:%{public, location:escape_only }s, ModelUuid:%{public, location:escape_only}s, ModelType:%{public}lld, LOI ID:%{private, location:escape_only}s}",  __p,  0x3Au);
      if (SHIBYTE(v63) < 0) {
        operator delete(v62);
      }
    }

    if (!v109) {
      sub_100036CD8();
    }
    sub_100095AF0((uint64_t)&v105, a3, (uint64_t)__p);
    if (!v109) {
      sub_100036CD8();
    }
    sub_1000F0F40(a1, &v89);
    if (!v109) {
      sub_100036CD8();
    }
    sub_1000F0BB8(a1, (uint64_t)&v62);
    if (!v109) {
      sub_100036CD8();
    }
    sub_1000EB9AC((unsigned int *)__p, (uint64_t *)&v102, (__int128 *)&v89, v108, (__int128 *)&v62, &v103, a5);
    if (SHIBYTE(v63) < 0) {
      operator delete(v62);
    }
    if (v88 < 0) {
      operator delete(v87);
    }
    if (v85)
    {
      std::string v86 = v85;
      operator delete(v85);
    }

    uint64_t v39 = (std::string *)__p;
    sub_100019B90((uint64_t)v83);
    v89.__r_.__value_.__r.__words[0] = (std::string::size_type)&v81;
    int v40 = (void ***)&v89;
    goto LABEL_129;
  }

void sub_1000E8988( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, void *a46, uint64_t a47, uint64_t a48, uint64_t a49, void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a55 < 0) {
    operator delete(a50);
  }
  sub_100019D34((uint64_t)&STACK[0x488]);
  sub_100019D34((uint64_t)&STACK[0x5E8]);
  _Unwind_Resume(a1);
}

void *sub_1000E8CD8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  int v22 = v21;
  v19[0] = &off_10181EEB0;
  v19[1] = a2;
  int v20 = v19;
  v21[0] = &off_10181EE20;
  uint64_t v5 = *(void **)(a1 + 16);
  uint64_t v6 = *(void **)(a1 + 24);
  if (sub_1000F0F50(a2) == 1) {
    uint64_t v7 = v21;
  }
  else {
    uint64_t v7 = v19;
  }
  sub_10001A504((uint64_t)v17, (uint64_t)v7);
  if (v5 != v6)
  {
    while (1)
    {
      if (!v18) {
        sub_100008BDC();
      }
      v5 += 2;
      if (v5 == v6)
      {
        uint64_t v5 = v6;
        break;
      }
    }
  }

  uint64_t v8 = v18;
  if (v18 == v17)
  {
    uint64_t v9 = 4LL;
    uint64_t v8 = v17;
  }

  else
  {
    if (!v18) {
      goto LABEL_14;
    }
    uint64_t v9 = 5LL;
  }

  (*(void (**)(void))(*v8 + 8 * v9))();
LABEL_14:
  if (v5 == *(void **)(a1 + 24))
  {
    *a3 = 0LL;
    a3[1] = 0LL;
  }

  else
  {
    *a3 = *v5;
    uint64_t v10 = v5[1];
    a3[1] = v10;
    if (v10)
    {
      uint64_t v11 = (unint64_t *)(v10 + 8);
      do
        unint64_t v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
    }
  }

  uint64_t v13 = v20;
  if (v20 == v19)
  {
    uint64_t v14 = 4LL;
    uint64_t v13 = v19;
  }

  else
  {
    if (!v20) {
      goto LABEL_25;
    }
    uint64_t v14 = 5LL;
  }

  (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_25:
  uint64_t result = v22;
  if (v22 == v21)
  {
    uint64_t v16 = 4LL;
    uint64_t result = v21;
  }

  else
  {
    if (!v22) {
      return result;
    }
    uint64_t v16 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v16))();
}

void sub_1000E8E88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char *a19, char a20, uint64_t a21, uint64_t a22, char *a23)
{
  uint64_t v24 = a19;
  if (a19 == &a16)
  {
    uint64_t v25 = 4LL;
    uint64_t v24 = &a16;
  }

  else
  {
    if (!a19) {
      goto LABEL_6;
    }
    uint64_t v25 = 5LL;
  }

  (*(void (**)(void))(*(void *)v24 + 8 * v25))();
LABEL_6:
  uint64_t v26 = a23;
  if (a23 == &a20)
  {
    uint64_t v27 = 4LL;
    uint64_t v26 = &a20;
  }

  else
  {
    if (!a23) {
      goto LABEL_11;
    }
    uint64_t v27 = 5LL;
  }

  (*(void (**)(void))(*(void *)v26 + 8 * v27))();
LABEL_11:
  sub_10000AE14((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E8F38(char **a1, __int128 *a2)
{
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v12 = (v7 - *a1) >> 4;
    unint64_t v13 = v12 + 1;
    uint64_t v14 = v5 - (void)*a1;
    if (v14 >> 3 > v13) {
      unint64_t v13 = v14 >> 3;
    }
    else {
      unint64_t v15 = v13;
    }
    uint64_t v31 = result;
    uint64_t v16 = (char *)sub_100037038(result, v15);
    std::string::size_type v18 = &v16[16 * v12];
    __int128 v19 = *a2;
    *(_OWORD *)std::string::size_type v18 = *a2;
    if (*((void *)&v19 + 1))
    {
      int v20 = (unint64_t *)(*((void *)&v19 + 1) + 8LL);
      do
        unint64_t v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }

    __int16 v23 = *a1;
    int v22 = a1[1];
    if (v22 == *a1)
    {
      int64x2_t v26 = vdupq_n_s64((unint64_t)v22);
      uint64_t v24 = &v16[16 * v12];
    }

    else
    {
      uint64_t v24 = &v16[16 * v12];
      do
      {
        __int128 v25 = *((_OWORD *)v22 - 1);
        v22 -= 16;
        *((_OWORD *)v24 - 1) = v25;
        v24 -= 16;
        *(void *)int v22 = 0LL;
        *((void *)v22 + 1) = 0LL;
      }

      while (v22 != v23);
      int64x2_t v26 = *(int64x2_t *)a1;
    }

    uint64_t v11 = v18 + 16;
    *a1 = v24;
    a1[1] = v18 + 16;
    int64x2_t v29 = v26;
    uint64_t v27 = a1[2];
    a1[2] = &v16[16 * v17];
    uint64_t v30 = v27;
    uint64_t v28 = v26.i64[0];
    uint64_t result = sub_1000EC3DC((uint64_t)&v28);
  }

  else
  {
    *(void *)uint64_t v7 = *(void *)a2;
    uint64_t v8 = *((void *)a2 + 1);
    *((void *)v7 + 1) = v8;
    if (v8)
    {
      uint64_t v9 = (unint64_t *)(v8 + 8);
      do
        unint64_t v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }

    uint64_t v11 = v7 + 16;
  }

  a1[1] = v11;
  return result;
}

void sub_1000E9078(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 40;
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3 != a1 + 40)
  {
    do
    {
      sub_1000F6220((void *)(v3 + 16), a2);
      uint64_t v3 = *(void *)(v3 + 8);
    }

    while (v3 != v2);
  }

uint64_t sub_1000E90C4(uint64_t a1, uint64_t a2, uint64_t *a3, __int128 *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(a1 + 144);
  uint64_t v7 = *a3;
  uint64_t v8 = a3[1];
  __int128 v10 = *a4;
  char v11 = *((_BYTE *)a4 + 16);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, uint64_t, uint64_t))(*(void *)(v6 + 8) + 24LL))( v6 + 8,  a2,  v7,  v8,  &v10,  a5,  a6);
}

uint64_t sub_1000E9140(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)&__int128 v9 = a2;
  __int128 v9 = *((_OWORD *)sub_10001D174(a1 + 64, a2, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 2);
  return (*(uint64_t (**)(void, void *, uint64_t, uint64_t, __int128 *))(**(void **)(a1 + 144) + 40LL))( *(void *)(a1 + 144),  a2,  a3,  a4,  &v9);
}

uint64_t sub_1000E91E8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)&__int128 v9 = a2;
  __int128 v9 = *((_OWORD *)sub_10001D174(a1 + 64, a2, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 2);
  return (*(uint64_t (**)(void, void *, uint64_t, uint64_t, __int128 *))(**(void **)(a1 + 144) + 24LL))( *(void *)(a1 + 144),  a2,  a3,  a4,  &v9);
}

uint64_t sub_1000E9290(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)&__int128 v9 = a2;
  __int128 v9 = *((_OWORD *)sub_10001D174(a1 + 64, a2, (uint64_t)&unk_1012CF090, (_OWORD **)&v9) + 2);
  return (*(uint64_t (**)(void, void *, uint64_t, uint64_t, __int128 *))(**(void **)(a1 + 144) + 32LL))( *(void *)(a1 + 144),  a2,  a3,  a4,  &v9);
}

uint64_t sub_1000E9338(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  *(void *)&__int128 v8 = a2;
  __int128 v8 = *((_OWORD *)sub_10001D174(a1 + 64, a2, (uint64_t)&unk_1012CF090, (_OWORD **)&v8) + 2);
  return (*(uint64_t (**)(void, uint64_t, uint64_t, __int128 *))(**(void **)(a1 + 144) + 48LL))( *(void *)(a1 + 144),  a3,  a4,  &v8);
}

uint64_t sub_1000E93D8(uint64_t a1, uint64_t a2, uint64_t *a3, __int128 *a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 144);
  uint64_t v6 = *a3;
  uint64_t v7 = a3[1];
  char v10 = *((_BYTE *)a4 + 16);
  __int128 v9 = *a4;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, __int128 *, uint64_t))(*(void *)(v5 + 8) + 16LL))( v5 + 8,  a2,  v6,  v7,  &v9,  a5);
}

uint64_t sub_1000E9450(uint64_t a1, uint64_t a2)
{
  *(void *)&__int128 v5 = a2 + 32;
  __int128 v5 = *((_OWORD *)sub_10001D174(a1 + 64, (void *)(a2 + 32), (uint64_t)&unk_1012CF090, (_OWORD **)&v5) + 2);
  return (*(uint64_t (**)(void, uint64_t, __int128 *))(**(void **)(a1 + 144) + 16LL))( *(void *)(a1 + 144),  a2,  &v5);
}

uint64_t sub_1000E94E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v6 = a4;
  uint64_t v7 = a3;
  uint64_t v22 = a3;
  uint64_t v23 = a4;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EDA0);
  }
  __int128 v9 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    char v10 = (char *)operator new(0x28uLL);
    *(_OWORD *)char v10 = 0u;
    *((_OWORD *)v10 + 1) = 0u;
    *(void *)(v10 + 29) = 0LL;
    sub_10000AE6C((uint64_t)&v22, v10);
    char v11 = (char *)operator new(0x28uLL);
    *(void *)(v11 + 29) = 0LL;
    *(_OWORD *)char v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    sub_10000AE6C((uint64_t)a5, v11);
    v15[0] = 68289538;
    v15[1] = 0;
    __int16 v16 = 2082;
    uint64_t v17 = "";
    __int16 v18 = 2082;
    __int128 v19 = v10;
    __int16 v20 = 2082;
    unint64_t v21 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoServiceManager::requestMicroLocationLearning, serviceId:%{public, location:esca pe_only}s, requestId:%{public, location:escape_only}s}",  (uint8_t *)v15,  0x26u);
    operator delete(v11);
    operator delete(v10);
    uint64_t v7 = v22;
    uint64_t v6 = v23;
  }

  uint64_t v12 = (void *)sub_1000E5024(a1, v7, v6);
  if (v13) {
    return sub_1000F850C(v12, a5);
  }
  else {
    return 0LL;
  }
}

void sub_1000E9670(_Unwind_Exception *a1)
{
}

void sub_1000E96A0(void *a1)
{
  for (uint64_t i = (void *)a1[6]; i != a1 + 5; uint64_t i = (void *)i[1])
  {
    sub_1000E647C((uint64_t)a1, (uint64_t)(i + 2));
    sub_1000F8700((uint64_t)(i + 2));
  }

void sub_1000E96F8(uint64_t a1)
{
  uint64_t v1 = a1 + 40;
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2 != a1 + 40)
  {
    uint64_t v3 = (_OWORD *)(a1 + 112);
    do
    {
      sub_1000F6384(v2 + 16, v3, &v4);
      if (__p)
      {
        char v10 = __p;
        operator delete(__p);
      }

      if (v7)
      {
        __int128 v8 = v7;
        operator delete(v7);
      }

      if (v5)
      {
        uint64_t v6 = v5;
        operator delete(v5);
      }

      uint64_t v2 = *(void *)(v2 + 8);
    }

    while (v2 != v1);
  }

void sub_1000E97B0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1 + 40;
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4 != a1 + 40)
  {
    do
    {
      sub_1000F8890((uint64_t *)(v4 + 16), a2, a3);
      uint64_t v4 = *(void *)(v4 + 8);
    }

    while (v4 != v3);
  }

uint64_t sub_1000E9804(uint64_t a1, char a2, char a3)
{
  *(_BYTE *)(a1 + 8) = a2;
  *(_BYTE *)(a1 + 9) = a3;
  uint64_t v4 = a1 + 40;
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5 != a1 + 40)
  {
    do
    {
      sub_1000F8508(v5 + 16);
      sub_1000F7264((void *)(v5 + 16), (_OWORD *)(a1 + 112));
      uint64_t v5 = *(void *)(v5 + 8);
    }

    while (v5 != v4);
  }

  return sub_1000E688C(a1);
}

uint64_t sub_1000E9874(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EDA0);
  }
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 68289026;
    v4[1] = 0;
    __int16 v5 = 2082;
    uint64_t v6 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoServiceManager::triggerLearning}",  (uint8_t *)v4,  0x12u);
  }

  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(a1 + 144) + 8LL) + 40LL))(*(void *)(a1 + 144) + 8LL);
}

void sub_1000E995C(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
}

uint64_t sub_1000E9964(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(a1 + 144) + 8LL) + 72LL))(*(void *)(a1 + 144) + 8LL);
}

uint64_t sub_1000E9974(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(*(void *)(a1 + 144) + 8LL) + 80LL))(*(void *)(a1 + 144) + 8LL);
}

void sub_1000E9984(uint64_t a1@<X0>, uint64_t a2@<X1>, const void **a3@<X2>, void *a4@<X8>, double a5@<D0>)
{
}

void sub_1000E9994(uint64_t a1@<X0>, void *a2@<X1>, _BYTE *a3@<X8>)
{
}

uint64_t sub_1000E999C(void *a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  v20[0] = a2;
  v20[1] = a3;
  uint64_t v4 = a1 + 5;
  __int16 v5 = (void *)a1[6];
  *(void *)__int128 v19 = a2;
  *(void *)&_WORD v19[8] = a3;
  if (v5 == a1 + 5) {
    goto LABEL_7;
  }
  while (*(void *)v19 != sub_1000F0EE0((uint64_t)(v5 + 2)) || *(void *)&v19[8] != v8)
  {
    __int16 v5 = (void *)v5[1];
    if (v5 == v4) {
      goto LABEL_7;
    }
  }

  if (v5 == v4) {
LABEL_7:
  }
    sub_10122A60C();
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EDA0);
  }
  char v10 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    char v11 = (char *)operator new(0x28uLL);
    *(_OWORD *)char v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    *(void *)(v11 + 29) = 0LL;
    sub_10000AE6C((uint64_t)v20, v11);
    *(void *)__int128 v19 = 68289282LL;
    *(_WORD *)&_WORD v19[8] = 2082;
    *(void *)&_BYTE v19[10] = "";
    *(_WORD *)&v19[18] = 2082;
    *(void *)&v19[20] = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:enableMiLoAtCurrentLocation for service, serviceId:%{public, location:escape_only}s}",  v19,  0x1Cu);
    operator delete(v11);
  }

  *(_OWORD *)__int128 v19 = *a4;
  *(_OWORD *)&v19[16] = *(_OWORD *)v20;
  sub_1000EC5C0(a1 + 24, (uint64_t)v19);
  unint64_t v12 = sub_1000E5024((uint64_t)a1, v20[0], v20[1]);
  if (v13)
  {
    uint64_t v14 = v12;
    if ((sub_1000F0F60(v12, 2uLL) & 1) == 0)
    {
      sub_1000F0F90(v14, 2uLL);
      uint64_t v15 = a1[13];
      __int128 v16 = *(_OWORD *)v20;
      uint64_t v17 = sub_1000F0F58(v14);
      sub_10002EC70(v15, v16, *((uint64_t *)&v16 + 1), v17);
    }
  }

  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)(a1[18] + 8LL) + 88LL))(a1[18] + 8LL, v20);
}

void sub_1000E9B88(_Unwind_Exception *a1)
{
}

void sub_1000E9BA4(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 232))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EDA0);
    }
    uint64_t v4 = (os_log_s *)qword_1019348D8;
    BOOL v5 = os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT);
    uint64_t v6 = *(void *)(a1 + 232);
    if (v5)
    {
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      __int16 v25 = 2082;
      int64x2_t v26 = "";
      __int16 v27 = 1026;
      *(_DWORD *)uint64_t v28 = v6 != 0;
      *(_WORD *)&v28[4] = 1026;
      *(_DWORD *)&v28[6] = a2 == -1;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoServiceManager releasing create custom LOI at current location requests: , NumR equests:%{public}hhd, Success:%{public}hhd}",  buf,  0x1Eu);
      uint64_t v6 = *(void *)(a1 + 232);
    }

    if (v6)
    {
      uint64_t v7 = a1 + 192;
      do
      {
        uint64_t v8 = *(void *)(*(void *)(a1 + 200) + ((*(void *)(a1 + 224) >> 4) & 0xFFFFFFFFFFFFFF8LL));
        uint64_t v9 = *(void *)(a1 + 224) & 0x7FLL;
        uint64_t v10 = v8 + 32 * v9;
        *(void *)uint64_t buf = v10 + 16;
        __int128 v30 = *((_OWORD *)sub_10001D174(a1 + 64, (void *)(v10 + 16), (uint64_t)&unk_1012CF090, (_OWORD **)buf) + 2);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181EDA0);
        }
        char v11 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
        {
          unint64_t v12 = operator new(0x28uLL);
          uint64_t v13 = v7;
          uint64_t v14 = a2;
          uint64_t v22 = v12;
          __int128 v23 = xmmword_1012C8460;
          _OWORD *v12 = 0u;
          v12[1] = 0u;
          *(void *)((char *)v12 + 29) = 0LL;
          sub_10000AE6C(v10 + 16, v12);
          if (v23 >= 0) {
            uint64_t v15 = &v22;
          }
          else {
            uint64_t v15 = v22;
          }
          __int128 v16 = operator new(0x28uLL);
          std::string __p = v16;
          __int128 v21 = xmmword_1012C8460;
          _OWORD *v16 = 0u;
          v16[1] = 0u;
          *(void *)((char *)v16 + 29) = 0LL;
          sub_10000AE6C(v10, v16);
          p_p = &__p;
          if (v21 < 0) {
            p_p = __p;
          }
          *(_DWORD *)uint64_t buf = 68289538;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v25 = 2082;
          int64x2_t v26 = "";
          __int16 v27 = 2082;
          *(void *)uint64_t v28 = v15;
          *(_WORD *)&char v28[8] = 2082;
          int64x2_t v29 = p_p;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:enableMiLoAtCurrentLocation completed for service, serviceId:%{public, location :escape_only}s, requestId:%{public, location:escape_only}s}",  buf,  0x26u);
          if (SHIBYTE(v21) < 0) {
            operator delete(__p);
          }
          a2 = v14;
          if (SHIBYTE(v23) < 0) {
            operator delete(v22);
          }
          uint64_t v7 = v13;
        }

        __int16 v18 = (uint64_t *)sub_1000E5024(a1, *(void *)(v10 + 16), *(void *)(v8 + 32 * v9 + 24));
        if (v19) {
          sub_1000F2A84(v18);
        }
        (*(void (**)(void, uint64_t, uint64_t, __int128 *))(**(void **)(a1 + 144) + 56LL))( *(void *)(a1 + 144),  a2,  v10,  &v30);
        *(int64x2_t *)(a1 + sub_1000A7938(v46 - 224) = vaddq_s64(*(int64x2_t *)(a1 + 224), (int64x2_t)xmmword_1012CE4D0);
        sub_1000ECDBC(v7, 1);
      }

      while (*(void *)(a1 + 232));
    }
  }

void sub_1000E9F08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *sub_1000E9F48(void *a1)
{
  *a1 = off_10181ECD8;
  uint64_t v2 = (void **)(a1 + 2);
  sub_1000EAA04(a1 + 24);
  sub_1000A8814((uint64_t)(a1 + 19));
  sub_100019CEC((uint64_t)(a1 + 8));
  sub_1000EAA98(a1 + 5);
  uint64_t v4 = v2;
  sub_10004CC28(&v4);
  return a1;
}

void sub_1000E9FAC(void *a1)
{
  *a1 = off_10181ECD8;
  uint64_t v2 = (void **)(a1 + 2);
  sub_1000EAA04(a1 + 24);
  sub_1000A8814((uint64_t)(a1 + 19));
  sub_100019CEC((uint64_t)(a1 + 8));
  sub_1000EAA98(a1 + 5);
  uint64_t v3 = v2;
  sub_10004CC28(&v3);
  operator delete(a1);
}

void sub_1000EA014(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_1000EA040(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 88))
  {
  }

  return a1;
}

uint64_t sub_1000EA088(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 62LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 124LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

uint64_t sub_1000EA11C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_1000EA168(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 184))
  {
    uint64_t v2 = *(void **)(a1 + 144);
    if (v2)
    {
      *(void *)(a1 + 152) = v2;
      operator delete(v2);
    }

    if (*(_BYTE *)(a1 + 128)) {
      sub_10004AD90(a1 + 88);
    }
    uint64_t v3 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v3;
      operator delete(v3);
    }
  }

  return a1;
}

std::string *sub_1000EA1D8(std::string *__dst, const std::string *a2)
{
  if (__dst[1].__r_.__value_.__s.__data_[0])
  {
    std::string::operator=(__dst, a2);
  }

  else
  {
    if ((char)a2->__r_.__value_.__s.__size_ < 0)
    {
      sub_1010DD48C(__dst, a2->__r_.__value_.__l.__data_, a2->__r_.__value_.__l.__size_);
    }

    else
    {
      __int128 v3 = *(_OWORD *)&a2->__r_.__value_.__l.__data_;
      __dst->__r_.__value_.__l.__cap_ = a2->__r_.__value_.__l.__cap_;
      *(_OWORD *)&__dst->__r_.__value_.__l.__data_ = v3;
    }

    __dst[1].__r_.__value_.__s.__data_[0] = 1;
  }

  return __dst;
}

uint64_t sub_1000EA240( uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6, uint64_t a7, __int128 *a8, double a9)
{
  uint64_t v18 = sub_1000EA36C(a1, (uint64_t)a2);
  *(void *)(v18 + 352) = a3;
  *(void *)(v18 + 360) = a4;
  if (*((char *)a5 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(v18 + 368), *(void **)a5, *((void *)a5 + 1));
  }

  else
  {
    __int128 v19 = *a5;
    *(void *)(v18 + 384) = *((void *)a5 + 2);
    *(_OWORD *)(v18 + 368) = v19;
  }

  *(_BYTE *)(a1 + 392) = 1;
  *(void *)(a1 + 400) = a6;
  *(void *)(a1 + 408) = a7;
  sub_10000C120(a1 + 416, (unsigned __int8 *)a8, *a2);
  __int16 v20 = (_BYTE *)(a1 + 464);
  if (*((char *)a8 + 23) < 0)
  {
    sub_1010DD48C(v20, *(void **)a8, *((void *)a8 + 1));
  }

  else
  {
    __int128 v21 = *a8;
    *(void *)(a1 + 480) = *((void *)a8 + 2);
    *(_OWORD *)__int16 v20 = v21;
  }

  *(double *)(a1 + 488) = a9;
  *(_BYTE *)(a1 + 496) = 0;
  *(_BYTE *)(a1 + 536) = 0;
  return a1;
}

void sub_1000EA328(_Unwind_Exception *a1)
{
  if (*(_BYTE *)(v1 + 392))
  {
  }

  sub_1000173AC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000EA36C(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  sub_100019D9C(a1 + 16, a2 + 16);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  sub_1000EA4CC((_BYTE *)(a1 + 72), a2 + 72);
  __int128 v4 = *(_OWORD *)(a2 + 200);
  __int128 v5 = *(_OWORD *)(a2 + 212);
  *(void *)(a1 + 232) = 0LL;
  *(_OWORD *)(a1 + 212) = v5;
  *(_OWORD *)(a1 + 200) = v4;
  *(void *)(a1 + 240) = 0LL;
  *(void *)(a1 + 2sub_10000AE14(v17 - 48) = 0LL;
  sub_1000EA520( (char *)(a1 + 232),  *(void *)(a2 + 232),  *(void *)(a2 + 240),  (uint64_t)(*(void *)(a2 + 240) - *(void *)(a2 + 232)) >> 5);
  sub_1000EA5C8(a1 + 256, a2 + 256);
  *(void *)(a1 + 296) = *(void *)(a2 + 296);
  *(void *)(a1 + 304) = 0LL;
  *(void *)(a1 + 312) = 0LL;
  *(void *)(a1 + 320) = 0LL;
  sub_10001B72C( (void *)(a1 + 304),  *(const void **)(a2 + 304),  *(void *)(a2 + 312),  (uint64_t)(*(void *)(a2 + 312) - *(void *)(a2 + 304)) >> 2);
  uint64_t v6 = (_BYTE *)(a1 + 328);
  if (*(char *)(a2 + 351) < 0)
  {
    sub_1010DD48C(v6, *(void **)(a2 + 328), *(void *)(a2 + 336));
  }

  else
  {
    __int128 v7 = *(_OWORD *)(a2 + 328);
    *(void *)(a1 + 344) = *(void *)(a2 + 344);
    *(_OWORD *)uint64_t v6 = v7;
  }

  return a1;
}

void sub_1000EA46C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v8 = *v6;
  if (*v6)
  {
    *(void *)(v4 + 312) = v8;
    operator delete(v8);
  }

  sub_100019B90(v5);
  sub_100019C0C((void ***)va);
  sub_100019C7C(v3);
  sub_100019CEC(v2);
  _Unwind_Resume(a1);
}

_BYTE *sub_1000EA4CC(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[120] = 0;
  if (*(_BYTE *)(a2 + 120))
  {
    sub_10009B3B8((uint64_t)a1, a2);
    a1[120] = 1;
  }

  return a1;
}

void sub_1000EA50C(_Unwind_Exception *a1)
{
}

char *sub_1000EA520(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_10004B974(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      *(void *)uint64_t v7 = *(void *)a2;
      uint64_t v8 = *(void *)(a2 + 8);
      *(void *)(v7 + 8) = v8;
      if (v8)
      {
        uint64_t v9 = (unint64_t *)(v8 + 8);
        do
          unint64_t v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }

      *(_OWORD *)(v7 + 16) = *(_OWORD *)(a2 + 16);
      a2 += 32LL;
      v7 += 32LL;
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

void sub_1000EA5B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_1000EA5C8(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_100019E10(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
    sub_1000EA63C(a1, i + 2, (uint64_t)(i + 2));
  return a1;
}

void sub_1000EA624(_Unwind_Exception *a1)
{
}

void *sub_1000EA63C(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v5 = 0LL;
  for (uint64_t i = 0LL; i != 16; ++i)
    v5 ^= (v5 << 6) + (v5 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + i);
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = v5;
      if (v5 >= v7) {
        unint64_t v3 = v5 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v5;
    }

    uint64_t v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t result = (void *)*v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = result[1];
          if (v11 == v5)
          {
            if (result[2] == *a2 && result[3] == a2[1]) {
              return result;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          uint64_t result = (void *)*result;
        }

        while (result);
      }
    }
  }

  sub_1000EA8A8(a1, v5, a3, (uint64_t)&v21);
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1LL;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100019E10(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v5 >= v7) {
        unint64_t v3 = v5 % v7;
      }
      else {
        unint64_t v3 = v5;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v5;
    }
  }

  __int128 v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *__int128 v21 = *v19;
    *__int128 v19 = v21;
  }

  else
  {
    *__int128 v21 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v21;
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*v21)
    {
      unint64_t v20 = *(void *)(*v21 + 8LL);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v20 >= v7) {
          v20 %= v7;
        }
      }

      else
      {
        v20 &= v7 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v20) = v21;
    }
  }

  uint64_t result = v21;
  ++*(void *)(a1 + 24);
  return result;
}

void sub_1000EA884( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    sub_10009B798((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1000EA8A8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint8x8_t v8 = operator new(0x38uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *uint8x8_t v8 = 0LL;
  v8[1] = a2;
  *((_OWORD *)v8 + 1) = *(_OWORD *)a3;
  v8[5] = 0LL;
  v8[6] = 0LL;
  v8[4] = 0LL;
  uint64_t result = sub_1000577B4( v8 + 4,  *(const void **)(a3 + 16),  *(void *)(a3 + 24),  (uint64_t)(*(void *)(a3 + 24) - *(void *)(a3 + 16)) >> 4);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1000EA928(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0LL;
  sub_10009B798(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1000EA944(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 536)) {
    sub_1000A8728(a1 + 496);
  }
  sub_1002A5554((void *)(a1 + 440));
  sub_100008390(a1 + 416, *(void **)(a1 + 424));
  uint64_t v2 = *(void **)(a1 + 304);
  if (v2)
  {
    *(void *)(a1 + 312) = v2;
    operator delete(v2);
  }

  sub_100019B90(a1 + 256);
  uint64_t v4 = (void **)(a1 + 232);
  sub_100019C0C(&v4);
  sub_100019C7C(a1 + 72);
  sub_100019CEC(a1 + 16);
  return a1;
}

uint64_t sub_1000EAA04(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 64LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 128LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return sub_1000EA11C((uint64_t)a1);
}

void sub_1000EAA98(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0LL;
    if (v3 != a1)
    {
      do
      {
        unint64_t v5 = (uint64_t *)v3[1];
        sub_1000EAB08((uint64_t)(v3 + 2));
        operator delete(v3);
        uint64_t v3 = v5;
      }

      while (v5 != a1);
    }
  }

void sub_1000EAB08(uint64_t a1)
{
}

void ***sub_1000EAB6C(void ***a1, _OWORD *a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = (*a1)[1];
  uint64_t v6 = *a1;
  unint64_t v9 = (unint64_t)v6[2];
  uint64_t v7 = (uint64_t)(v6 + 2);
  unint64_t v8 = v9;
  if ((unint64_t)v5 >= v9)
  {
    uint64_t v12 = ((char *)v5 - (_BYTE *)*v4) >> 5;
    unint64_t v13 = v12 + 1;
    uint64_t v14 = v8 - (void)*v4;
    if (v14 >> 4 > v13) {
      unint64_t v13 = v14 >> 4;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15) {
      unint64_t v16 = (char *)sub_10000835C(v7, v15);
    }
    else {
      unint64_t v16 = 0LL;
    }
    unint64_t v17 = &v16[32 * v12];
    size_t v18 = &v16[32 * v15];
    __int128 v19 = a2[1];
    *(_OWORD *)unint64_t v17 = *a2;
    *((_OWORD *)v17 + 1) = v19;
    unint64_t v11 = v17 + 32;
    __int128 v21 = (char *)*v4;
    unint64_t v20 = (char *)v4[1];
    if (v20 != *v4)
    {
      do
      {
        __int128 v22 = *((_OWORD *)v20 - 1);
        *((_OWORD *)v17 - 2) = *((_OWORD *)v20 - 2);
        *((_OWORD *)v17 - 1) = v22;
        v17 -= 32;
        v20 -= 32;
      }

      while (v20 != v21);
      unint64_t v20 = (char *)*v4;
    }

    void *v4 = v17;
    v4[1] = v11;
    _DWORD v4[2] = v18;
    if (v20) {
      operator delete(v20);
    }
  }

  else
  {
    __int128 v10 = a2[1];
    *unint64_t v5 = *a2;
    v5[1] = v10;
    unint64_t v11 = v5 + 2;
  }

  v4[1] = v11;
  return a1;
}

uint64_t sub_1000EAC60(void *a1, unsigned int a2, uint64_t a3, unsigned int a4, void *a5)
{
  int64_t v5 = a4 - (unint64_t)a2 + 8 * (a3 - (void)a1);
  if (v5 >= 1)
  {
    if (a2)
    {
      else {
        unint64_t v6 = a4 - (unint64_t)a2 + 8 * (a3 - (void)a1);
      }
      v5 -= v6;
      ++a5;
      ++a1;
    }

    if (v5 >= 64)
    {
      while (*a5 == *a1)
      {
        uint64_t v7 = v5 - 64;
        ++a1;
        ++a5;
        BOOL v8 = v5 <= 127;
        v5 -= 64LL;
        if (v8) {
          goto LABEL_14;
        }
      }

      return 0LL;
    }

    uint64_t v7 = v5;
LABEL_14:
  }

  return 1LL;
}

uint64_t sub_1000EAD2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_1000EADD4(a1, v4, v6);
      v6 += 88LL;
      uint64_t v4 = v12 + 88;
      v12 += 88LL;
    }

    while (v6 != a3);
  }

  char v10 = 1;
  sub_1000EAE84((uint64_t)v9);
  return v4;
}

void sub_1000EADC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

_BYTE *sub_1000EADD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v5 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v5;
  uint64_t v6 = (_BYTE *)(a2 + 32);
  if (*(char *)(a3 + 55) < 0)
  {
    sub_1010DD48C(v6, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }

  else
  {
    __int128 v7 = *(_OWORD *)(a3 + 32);
    *(void *)(a2 + sub_10000AE14(v17 - 48) = *(void *)(a3 + 48);
    *(_OWORD *)uint64_t v6 = v7;
  }

  *(void *)(a2 + 56) = *(void *)(a3 + 56);
  uint64_t result = (_BYTE *)(a2 + 64);
  __int128 v9 = *(_OWORD *)(a3 + 64);
  *(void *)(a2 + 80) = *(void *)(a3 + 80);
  *(_OWORD *)uint64_t result = v9;
  return result;
}

void sub_1000EAE68(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1000EAE84(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1000EAEB8((uint64_t *)a1);
  }
  return a1;
}

void sub_1000EAEB8(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 88LL;
      sub_1000AA5C8(v5, v3);
    }

    while (v3 != v4);
  }

uint64_t sub_1000EAF08(uint64_t a1)
{
  unsigned int v2 = sub_1000B0A38(a1);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181EDA0);
  }
  uint64_t v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 136446210;
    uint64_t v11 = "MiLoServices";
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicate s a serious problem",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EDA0);
    }
    int v8 = 136446210;
    __int128 v9 = "MiLoServices";
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicate s a serious problem",  &v8,  12);
    __int128 v7 = (uint8_t *)v6;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMiLoServiceTable]",  "%s\n",  v6);
    if (v7 != buf) {
      free(v7);
    }
  }

  uint64_t result = sub_1000EB0FC(a1);
  if ((_DWORD)result)
  {
    else {
      uint64_t v5 = *(void *)(a1 + 160);
    }
    sub_1003C1EC0(a1 + 72, v5);
    return 1LL;
  }

  return result;
}

uint64_t sub_1000EB0FC(uint64_t a1)
{
  unsigned int v2 = sub_1000B0A38(a1);
  if (sub_1000EB290() <= v2)
  {
    unsigned int v4 = sub_1000B0A38(a1);
    unint64_t v5 = v4 - (unint64_t)sub_1000EB290();
    unint64_t v6 = v5 + sub_1000EB368();
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EDA0);
    }
    __int128 v7 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      v10[0] = 68289538;
      v10[1] = 0;
      __int16 v11 = 2082;
      uint64_t v12 = "";
      __int16 v13 = 2050;
      unint64_t v14 = v6;
      __int16 v15 = 2082;
      unint64_t v16 = "MiLoServices";
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Free up database space, Rows to delete:%{public}llu, Table name:%{public, locat ion:escape_only}s}",  (uint8_t *)v10,  0x26u);
    }

    if (!*(void *)(a1 + 264))
    {
      int v8 = operator new(0x10uLL);
      sub_1000F9800((uint64_t)v8, a1 + 72);
      __int128 v9 = *(void **)(a1 + 264);
      *(void *)(a1 + 264) = v8;
      if (v9) {
        operator delete(v9);
      }
    }

    sub_1000FEE7C();
  }

  return 1LL;
}

void sub_1000EB274(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EB290()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsServicesTableMaxRows", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  unsigned int v2 = v7;
  uint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 256LL;
  }
}

void sub_1000EB350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1000EB368()
{
  unsigned int v0 = sub_1000EB290();
  sub_1000EB3AC();
  if (v1 < 0.0 || v1 > 1.0) {
    sub_10122A79C();
  }
  return (float)(v1 * (float)v0);
}

void sub_1000EB3AC()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsDatabaseFreeSpacePercentage", 0x8000100u, kCFAllocatorNull);
  sub_1002A827C(v5, (uint64_t)v0, (float *)&v4);
  CFRelease(v0);
  float v1 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }

void sub_1000EB470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void *sub_1000EB488(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  unsigned int v7 = operator new(0x1E0uLL);
  *unsigned int v7 = a2;
  v7[1] = a3;
  sub_1000EB4E4((uint64_t)(v7 + 2), a4);
  return v7;
}

void sub_1000EB4D0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EB4E4(uint64_t a1, __int128 *a2)
{
  __int128 v4 = *a2;
  __int128 v5 = a2[1];
  *(void *)(a1 + 32) = *((void *)a2 + 4);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  if (*((char *)a2 + 63) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 40), *((void **)a2 + 5), *((void *)a2 + 6));
  }

  else
  {
    __int128 v6 = *(__int128 *)((char *)a2 + 40);
    *(void *)(a1 + 56) = *((void *)a2 + 7);
    *(_OWORD *)(a1 + 40) = v6;
  }

  unsigned int v7 = (_BYTE *)(a1 + 64);
  if (*((char *)a2 + 87) < 0)
  {
    sub_1010DD48C(v7, *((void **)a2 + 8), *((void *)a2 + 9));
  }

  else
  {
    __int128 v8 = a2[4];
    *(void *)(a1 + 80) = *((void *)a2 + 10);
    *(_OWORD *)unsigned int v7 = v8;
  }

  *(void *)(a1 + 88) = *((void *)a2 + 11);
  *(_OWORD *)(a1 + 96) = a2[6];
  *((void *)a2 + 12) = 0LL;
  *((void *)a2 + 13) = 0LL;
  *(_BYTE *)(a1 + 112) = 0;
  *(_BYTE *)(a1 + 296) = 0;
  if (*((_BYTE *)a2 + 296))
  {
    sub_1000EB670(a1 + 112, (uint64_t)(a2 + 7));
    *(_BYTE *)(a1 + 296) = 1;
  }

  *(void *)(a1 + 304) = *((void *)a2 + 38);
  *(void *)(a1 + 312) = *((void *)a2 + 39);
  *(void *)(a1 + 320) = *((void *)a2 + 40);
  *(void *)(a1 + 328) = *((void *)a2 + 41);
  a2[19] = 0u;
  a2[20] = 0u;
  *(void *)(a1 + 336) = *((void *)a2 + 42);
  *(void *)(a1 + 344) = *((void *)a2 + 43);
  *((void *)a2 + 42) = 0LL;
  *((void *)a2 + 43) = 0LL;
  __int128 v9 = a2[22];
  *(_BYTE *)(a1 + 368) = *((_BYTE *)a2 + 368);
  *(_OWORD *)(a1 + 352) = v9;
  *(void *)(a1 + 376) = *((void *)a2 + 47);
  *(void *)(a1 + 384) = *((void *)a2 + 48);
  *(void *)(a1 + 392) = *((void *)a2 + 49);
  *(void *)(a1 + 400) = *((void *)a2 + 50);
  *(__int128 *)((char *)a2 + 376) = 0u;
  *(__int128 *)((char *)a2 + 392) = 0u;
  *(void *)(a1 + 408) = *((void *)a2 + 51);
  *(void *)(a1 + 416) = *((void *)a2 + 52);
  *((void *)a2 + 51) = 0LL;
  *((void *)a2 + 52) = 0LL;
  __int128 v10 = *(__int128 *)((char *)a2 + 424);
  __int128 v11 = *(__int128 *)((char *)a2 + 440);
  *(_WORD *)(a1 + 456) = *((_WORD *)a2 + 228);
  *(_OWORD *)(a1 + 424) = v10;
  *(_OWORD *)(a1 + 440) = v11;
  return a1;
}

void sub_1000EB654(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1000EB670(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  __int128 v4 = *(_OWORD *)(a2 + 24);
  __int128 v5 = *(_OWORD *)(a2 + 33);
  *(_BYTE *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 33) = v5;
  *(_OWORD *)(a1 + 24) = v4;
  *(_BYTE *)(a1 + 80) = 0;
  if (*(_BYTE *)(a2 + 80))
  {
    __int128 v6 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_OWORD *)(a1 + 56) = v6;
    *(void *)(a2 + 64) = 0LL;
    *(void *)(a2 + 72) = 0LL;
    *(void *)(a2 + 56) = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
  }

  *(_BYTE *)(a1 + 88) = 0;
  uint64_t v7 = a1 + 88;
  *(_BYTE *)(a1 + 128) = 0;
  if (*(_BYTE *)(a2 + 128))
  {
    sub_10001B9CC(v7, (uint64_t *)(a2 + 88));
    *(_BYTE *)(a1 + 128) = 1;
  }

  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  *(void *)(a1 + 152) = 0LL;
  *(void *)(a1 + 160) = 0LL;
  *(void *)(a1 + 144) = 0LL;
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  *(void *)(a2 + 144) = 0LL;
  *(void *)(a2 + 152) = 0LL;
  *(void *)(a2 + 160) = 0LL;
  *(_OWORD *)(a1 + 168) = *(_OWORD *)(a2 + 168);
  return a1;
}

void *sub_1000EB74C(uint64_t a1, void *a2, _OWORD *a3, __int128 *a4)
{
  unint64_t v8 = 0LL;
  for (uint64_t i = 0LL; i != 16; ++i)
    v8 ^= (v8 << 6) + (v8 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + i);
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
    }

    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }

    uint64_t v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      __int16 v13 = *v12;
      if (*v12)
      {
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v8)
          {
            if (v13[2] == *a2 && v13[3] == a2[1]) {
              return v13;
            }
          }

          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v14 >= v10) {
                v14 %= v10;
              }
            }

            else
            {
              v14 &= v10 - 1;
            }

            if (v14 != v4) {
              break;
            }
          }

          __int16 v13 = (void *)*v13;
        }

        while (v13);
      }
    }
  }

  __int16 v13 = operator new(0x30uLL);
  void *v13 = 0LL;
  v13[1] = v8;
  __int128 v16 = *a4;
  *((_OWORD *)v13 + 1) = *a3;
  *((_OWORD *)v13 + 2) = v16;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1LL;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_100019E10(a1, v22);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v8 >= v10) {
        unint64_t v4 = v8 % v10;
      }
      else {
        unint64_t v4 = v8;
      }
    }

    else
    {
      unint64_t v4 = (v10 - 1) & v8;
    }
  }

  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v4);
  if (v24)
  {
    void *v13 = *v24;
LABEL_44:
    void *v24 = v13;
    goto LABEL_45;
  }

  void *v13 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v13;
  *(void *)(v23 + 8 * v4) = a1 + 16;
  if (*v13)
  {
    unint64_t v25 = *(void *)(*v13 + 8LL);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10) {
        v25 %= v10;
      }
    }

    else
    {
      v25 &= v10 - 1;
    }

    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_44;
  }

void sub_1000EB998(_Unwind_Exception *a1)
{
}

void *sub_1000EB9AC@<X0>( unsigned int *a1@<X1>, uint64_t *a2@<X2>, __int128 *a3@<X3>, uint64_t *a4@<X4>, __int128 *a5@<X5>, double *a6@<X6>, void *a7@<X8>)
{
  unint64_t v14 = operator new(0x238uLL);
  uint64_t result = sub_1000EBA3C(v14, a1, a2, a3, a4, a5, a6);
  *a7 = v14 + 3;
  a7[1] = v14;
  return result;
}

void sub_1000EBA28(_Unwind_Exception *a1)
{
}

void *sub_1000EBA3C( void *a1, unsigned int *a2, uint64_t *a3, __int128 *a4, uint64_t *a5, __int128 *a6, double *a7)
{
  a1[2] = 0LL;
  *a1 = off_10181EDD0;
  a1[1] = 0LL;
  sub_1000EA240((uint64_t)(a1 + 3), a2, *a3, a3[1], a4, *a5, a5[1], a6, *a7);
  return a1;
}

void sub_1000EBA94(_Unwind_Exception *a1)
{
}

void sub_1000EBAA8(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_10181EDD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000EBABC(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_10181EDD0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000EBAE0(uint64_t a1)
{
  return sub_1000EA944(a1 + 24);
}

void *sub_1000EBAEC@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x238uLL);
  uint64_t result = sub_1000EBB44(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000EBB30(_Unwind_Exception *a1)
{
}

void *sub_1000EBB44(void *a1, uint64_t a2)
{
  a1[2] = 0LL;
  *a1 = off_10181EDD0;
  a1[1] = 0LL;
  sub_1000EBB90((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1000EBB7C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EBB90(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1000EA36C(a1, a2);
  *(_OWORD *)(v4 + 352) = *(_OWORD *)(a2 + 352);
  sub_10004B7D4(v4 + 368, (__int128 *)(a2 + 368));
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a2 + 400);
  sub_1000EBCD0((uint64_t *)(a1 + 416), a2 + 416);
  sub_1002A55A8((void *)(a1 + 440), a2 + 440);
  *(void *)(a1 + 440) = &off_1018201E0;
  *(void *)(a1 + 456) = *(void *)(a2 + 456);
  if (*(char *)(a2 + 487) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 464), *(void **)(a2 + 464), *(void *)(a2 + 472));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(a2 + 464);
    *(void *)(a1 + 480) = *(void *)(a2 + 480);
    *(_OWORD *)(a1 + 464) = v5;
  }

  *(void *)(a1 + 488) = *(void *)(a2 + 488);
  sub_1000EBFD4((_BYTE *)(a1 + 496), a2 + 496);
  return a1;
}

void sub_1000EBC60(_Unwind_Exception *a1)
{
  if (*(_BYTE *)(v1 + 392))
  {
  }

  sub_1000173AC(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_1000EBCD0(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_1000EBD24(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_1000EBD0C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1000EBD24(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    __int128 v5 = (uint64_t **)result;
    __int128 v6 = result + 1;
    do
    {
      uint64_t result = sub_1000EBDA8(v5, v6, v4 + 8, (_OWORD *)v4 + 2);
      uint64_t v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          uint64_t v7 = *(int **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          unint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_1000EBDA8(uint64_t **a1, uint64_t *a2, int *a3, _OWORD *a4)
{
  __int128 v6 = sub_1000EBE2C(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    unint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_1000085FC(a1, (uint64_t)v11, v8, v7);
  }

  return v7;
}

uint64_t *sub_1000EBE2C(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int *a5)
{
  __int128 v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, int v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    unint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      BOOL v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (uint64_t *)v9[1];
      }

      while (v9);
    }

    else
    {
      __int16 v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        __int16 v13 = v10;
      }

      while (v14);
    }

    int v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          float v17 = (uint64_t *)v16;
          int v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          __int128 v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }

        if (v18 >= v15) {
          break;
        }
        __int128 v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }

      while (v16);
    }

    else
    {
      float v17 = a1 + 1;
    }

_BYTE *sub_1000EBFD4(_BYTE *a1, uint64_t a2)
{
  *a1 = 0;
  a1[40] = 0;
  if (*(_BYTE *)(a2 + 40))
  {
    sub_1000EC030((uint64_t)a1, a2);
    a1[40] = 1;
  }

  return a1;
}

void sub_1000EC014(_Unwind_Exception *exception_object)
{
  if (*(_BYTE *)(v1 + 40)) {
    sub_1000A8728(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000EC030(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_100019E10(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
    sub_1000EC0A4(a1, i + 2, (_OWORD *)i + 1);
  return a1;
}

void sub_1000EC08C(_Unwind_Exception *a1)
{
}

void *sub_1000EC0A4(uint64_t a1, void *a2, _OWORD *a3)
{
  unint64_t v5 = 0LL;
  for (uint64_t i = 0LL; i != 16; ++i)
    v5 ^= (v5 << 6) + (v5 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + i);
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = v5;
      if (v5 >= v7) {
        unint64_t v3 = v5 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v5;
    }

    BOOL v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = (void *)*v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v5)
          {
            if (v10[2] == *a2 && v10[3] == a2[1]) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          uint64_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  sub_1000EC320(a1, v5, a3, (uint64_t)v22);
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1LL;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100019E10(a1, v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v5 >= v7) {
        unint64_t v3 = v5 % v7;
      }
      else {
        unint64_t v3 = v5;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v5;
    }
  }

  BOOL v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *(void *)v22[0] = *v19;
    *BOOL v19 = v22[0];
  }

  else
  {
    *(void *)v22[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v22[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v22[0])
    {
      unint64_t v20 = *(void *)(*(void *)v22[0] + 8LL);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v20 >= v7) {
          v20 %= v7;
        }
      }

      else
      {
        v20 &= v7 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v20) = v22[0];
    }
  }

  uint64_t v10 = (void *)v22[0];
  v22[0] = 0LL;
  ++*(void *)(a1 + 24);
  sub_1000EC398((uint64_t)v22, 0LL);
  return v10;
}

void sub_1000EC308(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000EC320@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint8x8_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *uint8x8_t v8 = 0LL;
  v8[1] = a2;
  *((_OWORD *)v8 + 1) = *a3;
  uint64_t result = sub_10004AE0C((uint64_t)(v8 + 4), (uint64_t)(a3 + 1));
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1000EC380(_Unwind_Exception *a1)
{
}

void sub_1000EC398(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_10004AD90((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

uint64_t sub_1000EC3DC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
    sub_10000AE14(i - 16);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1000EC430()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &off_10181EE20;
  return result;
}

void sub_1000EC454(uint64_t a1, void *a2)
{
  *a2 = &off_10181EE20;
}

BOOL sub_1000EC46C(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(*(void *)a2 + 4LL) == 0;
}

uint64_t sub_1000EC480(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000EC4BC()
{
}

void *sub_1000EC4D0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181EEB0;
  result[1] = v3;
  return result;
}

uint64_t sub_1000EC504(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181EEB0;
  a2[1] = v2;
  return result;
}

BOOL sub_1000EC520(uint64_t a1, void *a2)
{
  uint64_t v2 = (unsigned __int8 *)(*a2 + 368LL);
  sub_1000F61C4(*(void *)(a1 + 8), &__p);
  BOOL v3 = sub_10008E5A8(v2, (unsigned __int8 *)&__p);
  return v3;
}

uint64_t sub_1000EC578(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000EC5B4()
{
}

__n128 sub_1000EC5C0(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 16 * (v4 - v5) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1000EC64C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  uint8x8_t v8 = (_OWORD *)(*(void *)(v5 + ((v7 >> 4) & 0xFFFFFFFFFFFFFF8LL)) + 32 * (v7 & 0x7F));
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  *uint8x8_t v8 = *(_OWORD *)a2;
  v8[1] = v10;
  ++a1[5];
  return result;
}

void sub_1000EC64C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x80;
  unint64_t v4 = v2 - 128;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    uint8x8_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    BOOL v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)uint8x8_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_1000071BC(v5, v33);
      unint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      int v38 = (uint64_t *)a1[1];
      uint8x8_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        uint8x8_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        __int128 v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)__int128 v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1000EC914( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1000EC960(void *a1, void *a2)
{
  uint64_t v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  uint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    unint64_t v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      BOOL v19 = (char *)sub_1000071BC(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      unint64_t v22 = (uint64_t *)a1[1];
      uint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        uint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v24 = 8 * (v23 >> 3);
        unint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)unint64_t v25 = v26;
          v25 += 8;
          v24 -= 8LL;
        }

        while (v24);
      }

      __int16 v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        uint64_t v6 = (char *)a1[2];
      }
    }

    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        uint64_t v6 = (char *)a1[1];
      }

      uint64_t v17 = &v6[8 * v13];
      uint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }

  *(void *)uint64_t v6 = *a2;
  a1[2] += 8LL;
}

void sub_1000ECA74(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    unint64_t v7 = *(_BYTE **)(a1 + 24);
    uint64_t v8 = *(_BYTE **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1LL;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)sub_1000071BC(v6, v12);
      uint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8LL];
      int64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v19 = 8 * (v18 >> 3);
        uint64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)uint64_t v20 = v21;
          v20 += 8;
          v19 -= 8LL;
        }

        while (v19);
      }

      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }

    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      uint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }

      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }

  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }

  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8LL;
}

void sub_1000ECB90(void *a1, void *a2)
{
  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    uint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)sub_1000071BC(a1[4], v16);
      uint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8LL;
        }

        while (v22);
      }

      unint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }

    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }

      uint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }

  *(void *)uint64_t v4 = *a2;
  a1[2] += 8LL;
}

void sub_1000ECCA4(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(_BYTE **)(a1 + 16);
    uint64_t v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)sub_1000071BC(*(void *)(a1 + 32), v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8LL];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      unint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        unint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8LL;
        }

        while (v18);
      }

      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }

    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }

      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }

  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }

  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8LL;
}

uint64_t sub_1000ECDBC(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x80) {
    a2 = 1;
  }
  if (v2 < 0x100) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 128LL;
  }

  return v4 ^ 1u;
}

BOOL sub_1000ECE18()
{
  return os_signpost_enabled(v0);
}

void sub_1000ECE20(uint64_t a1, xpc_object_t xdict)
{
}

void sub_1000ECE34(uint64_t a1, xpc_object_t xdict)
{
}

void sub_1000ECE44(const char **a1, xpc_object_t xdict)
{
}

uint64_t sub_1000ECE54(uint64_t result, char a2)
{
  *(_BYTE *)__n128 result = a2;
  *(void *)(result + 8) = XPC_ACTIVITY_ALLOW_BATTERY;
  return result;
}

uint64_t sub_1000ECE6C(uint64_t result, char a2)
{
  *(_BYTE *)__n128 result = a2;
  *(void *)(result + 8) = XPC_ACTIVITY_REQUIRE_SCREEN_SLEEP;
  return result;
}

void *sub_1000ECE84(void *result, uint64_t a2)
{
  void *result = a2;
  result[1] = XPC_ACTIVITY_INTERVAL;
  return result;
}

void *sub_1000ECE98(void *result, uint64_t a2)
{
  void *result = a2;
  result[1] = XPC_ACTIVITY_PRIORITY;
  return result;
}

void **sub_1000ECEAC(void **a1)
{
  unint64_t v2 = *a1;
  if (v2) {
    xpc_release(v2);
  }
  return a1;
}

uint64_t sub_1000ECEE0(uint64_t a1, __int128 *a2, void **a3, uint64_t a4)
{
  __int128 v7 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v7;
  *((void *)a2 + 1) = 0LL;
  *((void *)a2 + 2) = 0LL;
  *(void *)a2 = 0LL;
  v23.__r_.__value_.__s.__size_ = 20;
  strcpy((char *)&v23, "com.apple.locationd.");
  int v8 = *(char *)(a1 + 23);
  if (v8 >= 0) {
    uint64_t v9 = (const std::string::value_type *)a1;
  }
  else {
    uint64_t v9 = *(const std::string::value_type **)a1;
  }
  if (v8 >= 0) {
    std::string::size_type v10 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    std::string::size_type v10 = *(void *)(a1 + 8);
  }
  unint64_t v11 = std::string::append(&v23, v9, v10);
  __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  int64_t cap = v11->__r_.__value_.__l.__cap_;
  *(_OWORD *)std::string __p = v12;
  v11->__r_.__value_.__l.__size_ = 0LL;
  v11->__r_.__value_.__l.__cap_ = 0LL;
  v11->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    uint64_t v13 = __p;
  }
  else {
    uint64_t v13 = (void **)__p[0];
  }
  uint64_t v14 = *a3;
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3321888768LL;
  handler[2] = sub_1000ED1B0;
  handler[3] = &unk_10181EF20;
  uint64_t v26 = a1;
  uint64_t v15 = v27;
  sub_10001A504((uint64_t)v27, a4);
  uint64_t v18 = (uint64_t)v28;
  handler[4] = v26;
  uint64_t v19 = v30;
  if (!v28) {
    goto LABEL_13;
  }
  if (v28 != v27)
  {
    uint64_t v18 = (*(uint64_t (**)(void *, uint64_t, uint64_t))(*v28 + 16LL))(v28, v16, v17);
LABEL_13:
    __int128 v31 = (_BYTE *)v18;
    goto LABEL_15;
  }

  __int128 v31 = v30;
  (*(void (**)(void *, _BYTE *))(v27[0] + 24LL))(v27, v30);
LABEL_15:
  xpc_activity_register((const char *)v13, v14, handler);
  if (v28 == v27)
  {
    uint64_t v20 = 4LL;
  }

  else
  {
    if (!v28) {
      goto LABEL_20;
    }
    uint64_t v20 = 5LL;
    uint64_t v15 = v28;
  }

  (*(void (**)(void *))(*v15 + 8 * v20))(v15);
LABEL_20:
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  if (v31 == v30)
  {
    uint64_t v21 = 4LL;
    goto LABEL_28;
  }

  if (v31)
  {
    uint64_t v21 = 5LL;
    uint64_t v19 = v31;
LABEL_28:
    (*(void (**)(void *))(*v19 + 8 * v21))(v19);
  }

  return a1;
}

void sub_1000ED0FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35)
{
  if (a26 == v36)
  {
    uint64_t v38 = 4LL;
  }

  else
  {
    if (!a26) {
      goto LABEL_6;
    }
    uint64_t v38 = 5LL;
    uint64_t v36 = a26;
  }

  (*(void (**)(void *))(*v36 + 8 * v38))(v36);
LABEL_6:
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000ED1B0(uint64_t a1, xpc_activity_t activity)
{
  int v4 = *(uint64_t **)(a1 + 32);
  xpc_activity_t v10 = activity;
  xpc_activity_state_t state = xpc_activity_get_state(activity);
  if (state == 2)
  {
    sub_1000ED454(&v10, 4LL);
    *(void *)uint64_t buf = activity;
    uint64_t v9 = *(void *)(a1 + 64);
    if (!v9) {
      sub_100008BDC();
    }
    (*(void (**)(uint64_t, uint8_t *))(*(void *)v9 + 48LL))(v9, buf);
  }

  else if (!state)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EF50);
    }
    uint64_t v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      __int128 v7 = v4;
      *(_DWORD *)uint64_t buf = 136446210;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Checking in for %{public}s", buf, 0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EF50);
      }
      int v11 = 136446210;
      __int128 v12 = v4;
      int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Checking in for %{public}s",  &v11,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "auto CLMicroLocationXPCActivityHelpers::XPCRegistration::XPCRegistration(std::string, const XPCCriteria &, XPCAc tivityHandler)::(anonymous class)::operator()(xpc_activity_t) const",  "%s\n",  v8);
    }
  }

uint64_t sub_1000ED3C0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  return sub_10001A504(a1 + 40, a2 + 40);
}

void *sub_1000ED3D4(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 40);
  __n128 result = *(void **)(a1 + 64);
  if (result == v1)
  {
    uint64_t v3 = 4LL;
    __n128 result = v1;
  }

  else
  {
    if (!result) {
      return result;
    }
    uint64_t v3 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

const char *sub_1000ED40C(const char *a1)
{
  uint64_t v1 = a1;
  if (a1[23] < 0) {
    a1 = *(const char **)a1;
  }
  xpc_activity_unregister(a1);
  if (v1[23] < 0) {
    operator delete(*(void **)v1);
  }
  return v1;
}

void sub_1000ED454(xpc_activity_t *a1, xpc_activity_state_t a2)
{
  if (!xpc_activity_set_state(*a1, a2))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EF50);
    }
    int v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      xpc_activity_state_t state = xpc_activity_get_state(*a1);
      *(_DWORD *)uint64_t buf = 134349312;
      xpc_activity_state_t v14 = a2;
      __int16 v15 = 2050;
      xpc_activity_state_t v16 = state;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "#Warning Unable to mark activity as %{public}ld. current state is %{public}ld",  buf,  0x16u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EF50);
      }
      uint64_t v6 = qword_1019348D8;
      xpc_activity_state_t v7 = xpc_activity_get_state(*a1);
      int v9 = 134349312;
      xpc_activity_state_t v10 = a2;
      __int16 v11 = 2050;
      xpc_activity_state_t v12 = v7;
      int v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v6,  0LL,  "#Warning Unable to mark activity as %{public}ld. current state is %{public}ld",  &v9,  22);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationXPCActivityHelpers::XPCActivity::setState(xpc_activity_state_t)",  "%s\n",  v8);
    }
  }

BOOL sub_1000ED638(xpc_activity_t *a1)
{
  return xpc_activity_should_defer(*a1);
}

void sub_1000ED640(xpc_activity_t *a1)
{
}

void sub_1000ED648(xpc_activity_t *a1)
{
}

void sub_1000ED650(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

BOOL sub_1000ED67C(uint64_t a1, uint64_t a2)
{
  return HIDWORD(a1) > HIDWORD(a2);
}

void *sub_1000ED690(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    int v4 = result;
    do
    {
      unsigned int v5 = *(_DWORD *)(v2 + 32);
      if (!sub_10001A29C(v4, &v5))
      {
        uint64_t v6 = &v5;
        *((_DWORD *)sub_1000EDB74((uint64_t)v4, &v5, (uint64_t)&unk_1012CF090, &v6) + 5) = 0;
      }

      uint64_t v6 = &v5;
      __n128 result = sub_1000EDB74((uint64_t)v4, &v5, (uint64_t)&unk_1012CF090, &v6);
      ++*((_DWORD *)result + 5);
      v2 += 48LL;
    }

    while (v2 != v3);
  }

  return result;
}

BOOL sub_1000ED748(uint64_t a1)
{
  return *(void *)(a1 + 24) == 0LL;
}

uint64_t sub_1000ED758@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3)
  {
    int v4 = 0LL;
    unsigned int v5 = a2 + 2;
    do
    {
      if ((unint64_t)v4 >= *v5)
      {
        uint64_t v6 = ((uint64_t)v4 - *a2) >> 3;
        uint64_t v7 = *v5 - *a2;
        uint64_t v8 = v7 >> 2;
        else {
          unint64_t v9 = v8;
        }
        xpc_activity_state_t v10 = (char *)sub_1000071BC((uint64_t)(a2 + 2), v9);
        xpc_activity_state_t v12 = &v10[8 * v6];
        *(void *)xpc_activity_state_t v12 = v3[2];
        int v4 = (uint64_t *)(v12 + 8);
        xpc_activity_state_t v14 = (char *)*a2;
        uint64_t v13 = (char *)a2[1];
        if (v13 != (char *)*a2)
        {
          do
          {
            uint64_t v15 = *((void *)v13 - 1);
            v13 -= 8;
            *((void *)v12 - 1) = v15;
            v12 -= 8;
          }

          while (v13 != v14);
          uint64_t v13 = (char *)*a2;
        }

        *a2 = (uint64_t)v12;
        a2[1] = (uint64_t)v4;
        a2[2] = (uint64_t)&v10[8 * v11];
        if (v13) {
          operator delete(v13);
        }
      }

      else
      {
        *v4++ = v3[2];
      }

      a2[1] = (uint64_t)v4;
      uint64_t v3 = (void *)*v3;
    }

    while (v3);
  }

  else
  {
    int v4 = 0LL;
  }

  xpc_activity_state_t v16 = a2 + 2;
  for (int i = 1; i != 14; ++i)
  {
    uint64_t v18 = *a2;
    uint64_t v19 = (uint64_t *)*a2;
    if ((uint64_t *)*a2 == v4)
    {
LABEL_23:
      if ((unint64_t)v4 >= *v16)
      {
        uint64_t v20 = ((uint64_t)v4 - v18) >> 3;
        uint64_t v21 = *v16 - v18;
        uint64_t v22 = v21 >> 2;
        else {
          unint64_t v23 = v22;
        }
        uint64_t v24 = (char *)sub_1000071BC((uint64_t)(a2 + 2), v23);
        uint64_t v26 = (int *)&v24[8 * v20];
        *uint64_t v26 = i;
        v26[1] = 0;
        uint64_t v28 = (char *)*a2;
        __int16 v27 = (char *)a2[1];
        int64x2_t v29 = v26;
        if (v27 != (char *)*a2)
        {
          do
          {
            uint64_t v30 = *((void *)v27 - 1);
            v27 -= 8;
            *((void *)v29 - 1) = v30;
            v29 -= 2;
          }

          while (v27 != v28);
          __int16 v27 = (char *)*a2;
        }

        int v4 = (uint64_t *)(v26 + 2);
        *a2 = (uint64_t)v29;
        a2[1] = (uint64_t)(v26 + 2);
        a2[2] = (uint64_t)&v24[8 * v25];
        if (v27) {
          operator delete(v27);
        }
      }

      else
      {
        *(_DWORD *)int v4 = i;
        *((_DWORD *)v4++ + 1) = 0;
      }

      a2[1] = (uint64_t)v4;
    }

    else
    {
      while (*(_DWORD *)v19 != i)
      {
        if (++v19 == v4) {
          goto LABEL_23;
        }
      }
    }
  }

  uint64_t v31 = *a2;
  unint64_t v32 = 126 - 2 * __clz(((uint64_t)v4 - *a2) >> 3);
  BOOL v33 = v4 == (uint64_t *)*a2;
  uint64_t v36 = sub_1000ED67C;
  if (v33) {
    uint64_t v34 = 0LL;
  }
  else {
    uint64_t v34 = v32;
  }
  return sub_1000EDD94(v31, v4, (uint64_t (**)(uint64_t, uint64_t))&v36, v34, 1);
}

void sub_1000ED984(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_1000ED9B0(uint64_t a1@<X0>, void **a2@<X8>)
{
  if (*(_DWORD *)(a1 + 40)) {
    sub_10122A924();
  }
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    uint64_t v3 = *(void *)(qword_1019A09E0 + 16);
  }
  uint64_t v4 = *(int *)(v3 + 16);
  if ((_DWORD)v4)
  {
    unsigned int v5 = *(uint64_t **)(v3 + 8);
    uint64_t v6 = &v5[v4];
    do
    {
      sub_10008A5B0((uint64_t)v23, *v5);
      int v7 = v24;
      if ((v24 - 14) >= 0xFFFFFFF3)
      {
        int v8 = v23[2];
        xpc_activity_state_t v10 = a2[1];
        unint64_t v9 = (unint64_t)a2[2];
        if ((unint64_t)v10 >= v9)
        {
          uint64_t v12 = ((char *)v10 - (_BYTE *)*a2) >> 3;
          unint64_t v13 = v12 + 1;
          uint64_t v14 = v9 - (void)*a2;
          if (v14 >> 2 > v13) {
            unint64_t v13 = v14 >> 2;
          }
          else {
            unint64_t v15 = v13;
          }
          xpc_activity_state_t v16 = (char *)sub_1000071BC((uint64_t)(a2 + 2), v15);
          uint64_t v18 = &v16[8 * v12];
          *(_DWORD *)uint64_t v18 = v7;
          *((_DWORD *)v18 + 1) = v8;
          uint64_t v20 = (char *)*a2;
          uint64_t v19 = (char *)a2[1];
          uint64_t v21 = v18;
          if (v19 != *a2)
          {
            do
            {
              uint64_t v22 = *((void *)v19 - 1);
              v19 -= 8;
              *((void *)v21 - 1) = v22;
              v21 -= 8;
            }

            while (v19 != v20);
            uint64_t v19 = (char *)*a2;
          }

          uint64_t v11 = v18 + 8;
          *a2 = v21;
          a2[1] = v18 + 8;
          a2[2] = &v16[8 * v17];
          if (v19) {
            operator delete(v19);
          }
        }

        else
        {
          *xpc_activity_state_t v10 = v24;
          v10[1] = v8;
          uint64_t v11 = v10 + 2;
        }

        a2[1] = v11;
      }

      sub_10008A5B4((wireless_diagnostics::google::protobuf::MessageLite *)v23);
      ++v5;
    }

    while (v5 != v6);
  }

void sub_1000EDB18( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v11 = *(void **)v9;
  if (*(void *)v9)
  {
    *(void *)(v9 + 8) = v11;
    operator delete(v11);
  }

  _Unwind_Resume(a1);
}

void sub_1000EDB48(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_1000EDB74(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }

    else
    {
      unint64_t v4 = ((_DWORD)v8 - 1) & v7;
    }

    xpc_activity_state_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7) {
              return v11;
            }
          }

          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }

            else
            {
              v12 &= v8 - 1;
            }

            if (v12 != v4) {
              break;
            }
          }

          uint64_t v11 = (void *)*v11;
        }

        while (v11);
      }
    }
  }

  uint64_t v11 = operator new(0x18uLL);
  void *v11 = 0LL;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_DWORD *)v11 + 5) = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1LL;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100019E10(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = ((_DWORD)v8 - 1) & v7;
    }
  }

  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    void *v11 = *v20;
LABEL_38:
    *uint64_t v20 = v11;
    goto LABEL_39;
  }

  void *v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8LL);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }

    else
    {
      v21 &= v8 - 1;
    }

    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }

void sub_1000EDD80(_Unwind_Exception *a1)
{
}

uint64_t sub_1000EDD94( uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  unint64_t v8 = (uint64_t *)result;
LABEL_2:
  uint8x8_t v9 = v8;
LABEL_3:
  uint64_t v10 = 1 - a4;
  while (2)
  {
    unint64_t v8 = v9;
    uint64_t v11 = v10;
    uint64_t v12 = (char *)a2 - (char *)v9;
    unint64_t v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        __n128 result = (*a3)(*(a2 - 1), *v9);
        if ((_DWORD)result)
        {
          uint64_t v20 = *v9;
          *uint8x8_t v9 = *(a2 - 1);
          *(a2 - 1) = v20;
        }

        return result;
      case 3uLL:
        return sub_1000EE228(v9, v9 + 1, a2 - 1, (unsigned int (**)(void))a3);
      case 4uLL:
        return sub_1000EE6DC(v9, v9 + 1, v9 + 2, a2 - 1, (unsigned int (**)(void))a3);
      case 5uLL:
        return sub_1000EE78C(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1, (unsigned int (**)(void))a3);
      default:
        if (v12 <= 191)
        {
          if ((a5 & 1) != 0) {
            return sub_1000EE0D4((uint64_t)v9, a2, a3);
          }
          else {
            return sub_1000EE194((uint64_t)v9, a2, a3);
          }
        }

        if (v11 != 1)
        {
          unint64_t v14 = v13 >> 1;
          BOOL v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x401)
          {
            sub_1000EE228(&v9[v13 >> 1], v9, a2 - 1, (unsigned int (**)(void))a3);
            if ((a5 & 1) != 0) {
              goto LABEL_12;
            }
          }

          else
          {
            sub_1000EE228(v9, &v9[v13 >> 1], a2 - 1, (unsigned int (**)(void))a3);
            sub_1000EE228(v9 + 1, v15 - 1, a2 - 2, (unsigned int (**)(void))a3);
            sub_1000EE228(v9 + 2, &v9[v14 + 1], a2 - 3, (unsigned int (**)(void))a3);
            sub_1000EE228(v15 - 1, v15, &v9[v14 + 1], (unsigned int (**)(void))a3);
            uint64_t v16 = *v9;
            *uint8x8_t v9 = *v15;
            uint64_t *v15 = v16;
            if ((a5 & 1) != 0) {
              goto LABEL_12;
            }
          }

          if (((*a3)(*(v9 - 1), *v9) & 1) == 0)
          {
            __n128 result = (uint64_t)sub_1000EE314(v9, a2, a3);
            uint8x8_t v9 = (uint64_t *)result;
            goto LABEL_17;
          }

uint64_t sub_1000EE0D4(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((uint64_t *)result != a2)
  {
    unint64_t v4 = (void *)result;
    unsigned int v5 = (uint64_t *)(result + 8);
    if ((uint64_t *)(result + 8) != a2)
    {
      uint64_t v7 = 0LL;
      unint64_t v8 = (uint64_t *)result;
      do
      {
        uint64_t v10 = *v8;
        uint64_t v9 = v8[1];
        unint64_t v8 = v5;
        __n128 result = (*a3)(v9, v10);
        if ((_DWORD)result)
        {
          uint64_t v11 = *v8;
          uint64_t v12 = v7;
          while (1)
          {
            *(void *)((char *)v4 + v12 + 8) = *(void *)((char *)v4 + v12);
            if (!v12) {
              break;
            }
            __n128 result = (*a3)(v11, *(void *)((char *)v4 + v12 - 8));
            v12 -= 8LL;
            if ((result & 1) == 0)
            {
              unint64_t v13 = (void *)((char *)v4 + v12 + 8);
              goto LABEL_10;
            }
          }

          unint64_t v13 = v4;
LABEL_10:
          void *v13 = v11;
        }

        unsigned int v5 = v8 + 1;
        v7 += 8LL;
      }

      while (v8 + 1 != a2);
    }
  }

  return result;
}

uint64_t sub_1000EE194(uint64_t result, void *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((void *)result != a2)
  {
    unint64_t v4 = (void *)result;
    for (int i = (void *)(result + 8); v4 + 1 != a2; int i = v4 + 1)
    {
      uint64_t v8 = *v4;
      uint64_t v7 = v4[1];
      unint64_t v4 = i;
      __n128 result = (*a3)(v7, v8);
      if ((_DWORD)result)
      {
        uint64_t v9 = *v4;
        uint64_t v10 = v4;
        do
        {
          uint64_t v11 = v10;
          uint64_t v12 = *--v10;
          void *v11 = v12;
          __n128 result = (*a3)(v9, *(v11 - 2));
        }

        while ((result & 1) != 0);
        *uint64_t v10 = v9;
      }
    }
  }

  return result;
}

uint64_t sub_1000EE228(void *a1, void *a2, void *a3, unsigned int (**a4)(void))
{
  char v8 = ((uint64_t (*)(void, void))*a4)(*a2, *a1);
  uint64_t result = ((uint64_t (*)(void, void))*a4)(*a3, *a2);
  if ((v8 & 1) == 0)
  {
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    uint64_t v12 = *a1;
    *a1 = *a2;
    *a2 = v12;
    return 2LL;
  }

  uint64_t v10 = *a1;
  if (!(_DWORD)result)
  {
    *a1 = *a2;
    *a2 = v10;
    if (!(*a4)(*a3)) {
      return 1LL;
    }
    uint64_t v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    return 2LL;
  }

  *a1 = *a3;
  *a3 = v10;
  return 1LL;
}

uint64_t *sub_1000EE314(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  unint64_t v4 = a2;
  uint64_t v6 = *a1;
  if (((*a3)(*a1, *(a2 - 1)) & 1) != 0)
  {
    uint64_t v7 = a1;
    do
    {
      uint64_t v8 = v7[1];
      ++v7;
    }

    while (((*a3)(v6, v8) & 1) == 0);
  }

  else
  {
    uint64_t v9 = a1 + 1;
    do
    {
      uint64_t v7 = v9;
      if (v9 >= v4) {
        break;
      }
      ++v9;
    }

    while (!(*a3)(v6, *v7));
  }

  if (v7 < v4)
  {
    do
      uint64_t v10 = *--v4;
    while (((*a3)(v6, v10) & 1) != 0);
  }

  while (v7 < v4)
  {
    uint64_t v11 = *v7;
    *uint64_t v7 = *v4;
    uint64_t *v4 = v11;
    do
    {
      uint64_t v12 = v7[1];
      ++v7;
    }

    while (!(*a3)(v6, v12));
    do
      uint64_t v13 = *--v4;
    while (((*a3)(v6, v13) & 1) != 0);
  }

  if (v7 - 1 != a1) {
    *a1 = *(v7 - 1);
  }
  *(v7 - 1) = v6;
  return v7;
}

uint64_t *sub_1000EE420(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t v6 = 0LL;
  uint64_t v7 = *a1;
  do
    char v8 = (*a3)(a1[++v6], v7);
  while ((v8 & 1) != 0);
  uint64_t v9 = &a1[v6];
  uint64_t v10 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v9 >= a2) {
        break;
      }
      uint64_t v12 = *--a2;
    }

    while (((*a3)(v12, v7) & 1) == 0);
  }

  else
  {
    do
      uint64_t v11 = *--a2;
    while (!(*a3)(v11, v7));
  }

  if (v9 < a2)
  {
    uint64_t v13 = &a1[v6];
    unint64_t v14 = a2;
    do
    {
      uint64_t v15 = *v13;
      uint64_t *v13 = *v14;
      uint64_t *v14 = v15;
      do
      {
        uint64_t v16 = v13[1];
        ++v13;
      }

      while (((*a3)(v16, v7) & 1) != 0);
      do
        uint64_t v17 = *--v14;
      while (!(*a3)(v17, v7));
    }

    while (v13 < v14);
    uint64_t v10 = v13 - 1;
  }

  if (v10 != a1) {
    *a1 = *v10;
  }
  *uint64_t v10 = v7;
  return v10;
}

BOOL sub_1000EE538(void *a1, void *a2, unsigned int (**a3)(void))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1LL;
  switch(v6)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }

      return 1LL;
    case 3LL:
      sub_1000EE228(a1, a1 + 1, a2 - 1, a3);
      return 1LL;
    case 4LL:
      sub_1000EE6DC(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1LL;
    case 5LL:
      sub_1000EE78C(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1LL;
    default:
      uint64_t v9 = a1 + 2;
      sub_1000EE228(a1, a1 + 1, a1 + 2, a3);
      uint64_t v10 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1LL;
      }
      uint64_t v11 = 0LL;
      int v12 = 0;
      break;
  }

  while (1)
  {
    if (((unsigned int (*)(void, void))*a3)(*v10, *v9))
    {
      uint64_t v13 = *v10;
      uint64_t v14 = v11;
      while (1)
      {
        uint64_t v15 = (char *)a1 + v14;
        *(void *)((char *)a1 + v14 + 24) = *(void *)((char *)a1 + v14 + 16);
        if (v14 == -16) {
          break;
        }
        v14 -= 8LL;
        if ((((uint64_t (*)(uint64_t, void))*a3)(v13, *((void *)v15 + 1)) & 1) == 0)
        {
          uint64_t v16 = (void *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }

      uint64_t v16 = a1;
LABEL_12:
      void *v16 = v13;
      if (++v12 == 8) {
        return v10 + 1 == a2;
      }
    }

    uint64_t v9 = v10;
    v11 += 8LL;
    if (++v10 == a2) {
      return 1LL;
    }
  }

uint64_t sub_1000EE6DC( void *a1, void *a2, void *a3, void *a4, unsigned int (**a5)(void))
{
  uint64_t result = ((uint64_t (*)(void, void))*a5)(*a4, *a3);
  if ((_DWORD)result)
  {
    uint64_t v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    uint64_t result = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
    if ((_DWORD)result)
    {
      uint64_t v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      uint64_t result = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
      if ((_DWORD)result)
      {
        uint64_t v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }

  return result;
}

uint64_t sub_1000EE78C( void *a1, void *a2, void *a3, void *a4, void *a5, unsigned int (**a6)(void))
{
  uint64_t result = ((uint64_t (*)(void, void))*a6)(*a5, *a4);
  if ((_DWORD)result)
  {
    uint64_t v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    uint64_t result = ((uint64_t (*)(void, void))*a6)(*a4, *a3);
    if ((_DWORD)result)
    {
      uint64_t v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      uint64_t result = ((uint64_t (*)(void, void))*a6)(*a3, *a2);
      if ((_DWORD)result)
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        uint64_t result = ((uint64_t (*)(void, void))*a6)(*a2, *a1);
        if ((_DWORD)result)
        {
          uint64_t v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }

  return result;
}

uint64_t *sub_1000EE864(char *a1, char *a2, uint64_t *a3, uint64_t (**a4)(uint64_t, uint64_t))
{
  if (a1 != a2)
  {
    uint64_t v8 = a2 - a1;
    uint64_t v9 = (a2 - a1) >> 3;
    if (a2 - a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[8 * v10];
      do
      {
        sub_1000EE9B8((uint64_t)a1, (unsigned int (**)(void, void))a4, v9, v12);
        v12 -= 8;
        --v11;
      }

      while (v11);
    }

    uint64_t v13 = a2;
    if (a2 != (char *)a3)
    {
      uint64_t v14 = (uint64_t *)a2;
      do
      {
        if ((*a4)(*v14, *(void *)a1))
        {
          uint64_t v15 = *v14;
          uint64_t *v14 = *(void *)a1;
          *(void *)a1 = v15;
          sub_1000EE9B8((uint64_t)a1, (unsigned int (**)(void, void))a4, v9, a1);
        }

        ++v14;
      }

      while (v14 != a3);
      uint64_t v13 = (char *)a3;
    }

    if (v8 >= 9)
    {
      uint64_t v16 = (unint64_t)v8 >> 3;
      uint64_t v17 = a2 - 8;
      do
      {
        uint64_t v18 = *(void *)a1;
        BOOL v19 = (char *)sub_1000EEAD8(a1, (unsigned int (**)(void, void))a4, v16);
        if (v17 == v19)
        {
          *(void *)BOOL v19 = v18;
        }

        else
        {
          *(void *)BOOL v19 = *(void *)v17;
          *(void *)uint64_t v17 = v18;
          sub_1000EEB84((uint64_t)a1, (uint64_t)(v19 + 8), a4, (v19 + 8 - a1) >> 3);
        }

        v17 -= 8;
      }

      while (v16-- > 2);
    }

    return (uint64_t *)v13;
  }

  return a3;
}

uint64_t sub_1000EE9B8( uint64_t result, unsigned int (**a2)(void, void), uint64_t a3, void *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    unsigned int v5 = a4;
    uint64_t v6 = result;
    int64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v10 = ((uint64_t)a4 - result) >> 2;
      uint64_t v11 = v10 + 1;
      uint64_t v12 = (void *)(result + 8 * (v10 + 1));
      uint64_t v13 = v10 + 2;
      if (v10 + 2 < a3 && (*a2)(*v12, v12[1]))
      {
        ++v12;
        uint64_t v11 = v13;
      }

      uint64_t result = ((uint64_t (*)(void, void))*a2)(*v12, *v5);
      if ((result & 1) == 0)
      {
        uint64_t v14 = *v5;
        do
        {
          uint64_t v15 = v12;
          *unsigned int v5 = *v12;
          if (v7 < v11) {
            break;
          }
          uint64_t v16 = (2 * v11) | 1;
          uint64_t v12 = (void *)(v6 + 8 * v16);
          if (2 * v11 + 2 < a3)
          {
            if ((*a2)(*v12, v12[1]))
            {
              ++v12;
              uint64_t v16 = 2 * v11 + 2;
            }
          }

          uint64_t result = ((uint64_t (*)(void, uint64_t))*a2)(*v12, v14);
          unsigned int v5 = v15;
          uint64_t v11 = v16;
        }

        while (!(_DWORD)result);
        void *v15 = v14;
      }
    }
  }

  return result;
}

void *sub_1000EEAD8(void *a1, unsigned int (**a2)(void, void), uint64_t a3)
{
  uint64_t v6 = 0LL;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = &a1[v6 + 1];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(a1[v6 + 1], a1[v6 + 2]))
    {
      ++v9;
      uint64_t v10 = v11;
    }

    *a1 = *v9;
    a1 = v9;
    uint64_t v6 = v10;
  }

  while (v10 <= v8);
  return v9;
}

uint64_t sub_1000EEB84(uint64_t result, uint64_t a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v6 = result;
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (uint64_t *)(result + 8 * (v4 >> 1));
    uint64_t v9 = (uint64_t *)(a2 - 8);
    uint64_t result = (*a3)(*v8, *(void *)(a2 - 8));
    if ((_DWORD)result)
    {
      uint64_t v10 = *v9;
      do
      {
        uint64_t v11 = v8;
        *uint64_t v9 = *v8;
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (uint64_t *)(v6 + 8 * v7);
        uint64_t result = (*a3)(*v8, v10);
        uint64_t v9 = v11;
      }

      while ((result & 1) != 0);
      uint64_t *v11 = v10;
    }
  }

  return result;
}

double sub_1000EEC20(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)) {
    sub_10122AAF8();
  }
  return (float)(*(float *)(a1 + 12) - *(float *)(a2 + 12));
}

void sub_1000EEC54( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v12 = *a3;
  if (*((_BYTE *)a3 + 8)) {
    uint64_t v12 = (~*(_BYTE *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v12 & 0x7F;
  }
  uint64_t v22 = v12;
  uint64_t v13 = *(void **)(a1 + 16);
  if (v13)
  {
    uint64_t v14 = 0LL;
    double v15 = 0.0;
    double v16 = 0.0;
    do
    {
      uint64_t v17 = (double *)sub_1000EF678((void *)a2, (uint64_t)(v13 + 2));
      if (v17)
      {
        uint64_t v18 = (uint64_t)(v17 + 2);
        if (sub_1000EEF08(&v22, a6, (uint64_t)(v13 + 2), v17[2]))
        {
          double v19 = (*(double (**)(uint64_t, void *))(*(void *)a5 + 16LL))(a5, v13 + 2);
          double v20 = (*(double (**)(uint64_t, void *))(*(void *)a4 + 16LL))(a4, v13 + 2);
          double v21 = sub_1000EEC20((uint64_t)(v13 + 2), v18);
          double v16 = v16 + v20 * v21 * (v20 * v21) * v19;
          ++v14;
          double v15 = v15 + v19;
        }
      }

      uint64_t v13 = (void *)*v13;
    }

    while (v13);
  }

  else
  {
    uint64_t v14 = 0LL;
    double v16 = 0.0;
    double v15 = 0.0;
  }

  *(double *)a7 = v16;
  *(double *)(a7 + 8) = v15;
  *(void *)(a7 + 16) = v14;
}

uint64_t sub_1000EED94(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = *a3;
  if (*((_BYTE *)a3 + 8)) {
    uint64_t v6 = (~*(_BYTE *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v6 & 0x7F;
  }
  uint64_t v11 = v6;
  unint64_t v7 = *(void **)(a1 + 16);
  if (!v7) {
    return 0LL;
  }
  uint64_t v8 = 0LL;
  do
  {
    uint64_t v9 = (double *)sub_1000EF678((void *)a2, (uint64_t)(v7 + 2));
    if (v9) {
      v8 += sub_1000EEF08(&v11, a4, (uint64_t)(v7 + 2), v9[2]);
    }
    unint64_t v7 = (void *)*v7;
  }

  while (v7);
  return v8;
}

uint64_t sub_1000EEE40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v9 = *a4;
  if (*((_BYTE *)a4 + 8)) {
    uint64_t v9 = (~*(_BYTE *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v9 & 0x7F;
  }
  uint64_t v14 = v9;
  uint64_t v10 = *(void **)(a1 + 16);
  if (v10)
  {
    uint64_t v11 = 0LL;
    do
    {
      v11 += sub_1000EEF08(&v14, a5, (uint64_t)(v10 + 2), *(double *)(a2 + 144));
      uint64_t v10 = (void *)*v10;
    }

    while (v10);
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  for (int i = *(void **)(a2 + 16); i; int i = (void *)*i)
    v11 += sub_1000EEF08(&v14, a5, (uint64_t)(i + 2), *(double *)(a1 + 144));
  return v11 - a3;
}

BOOL sub_1000EEF08(void *a1, uint64_t a2, uint64_t a3, double a4)
{
  double v6 = a4;
  unsigned int v4 = *(_DWORD *)(a3 + 8);
  if (v4 >= 7) {
    sub_10000C918("bitset test argument out of range");
  }
  return ((*a1 >> v4) & 1) != 0 && (!*(_BYTE *)(a2 + 56) || (sub_10014CD6C(a2, a3, &v6) & 1) != 0);
}

double sub_1000EEF74(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = *a3;
  if (*((_BYTE *)a3 + 8)) {
    uint64_t v13 = (~*(_BYTE *)(a1 + 56) & ~*(_DWORD *)(a2 + 56)) & v13 & 0x7F;
  }
  uint64_t v19 = v13;
  uint64_t v14 = *(void **)(a1 + 16);
  if (v14)
  {
    double v15 = 0.0;
    double v16 = 0.0;
    do
    {
      if (sub_1000EEF08(&v19, a7, (uint64_t)(v14 + 2), *(double *)(a2 + 144)))
      {
        else {
          double v15 = v15 + (*(double (**)(uint64_t, void *))(*(void *)a5 + 16LL))(a5, v14 + 2);
        }
      }

      uint64_t v14 = (void *)*v14;
    }

    while (v14);
  }

  else
  {
    double v15 = 0.0;
  }

  for (int i = *(void **)(a2 + 16); i; int i = (void *)*i)
  {
    if (sub_1000EEF08(&v19, a7, (uint64_t)(i + 2), *(double *)(a1 + 144))
      && !sub_1000EF678((void *)a1, (uint64_t)(i + 2))
      && ((*(uint64_t (**)(uint64_t, void *))(*(void *)a6 + 16LL))(a6, i + 2) & 1) == 0)
    {
      double v15 = v15 + (*(double (**)(uint64_t, void *))(*(void *)a5 + 16LL))(a5, i + 2);
    }
  }

  return v15;
}

double sub_1000EF0EC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (v6) {
    return sqrt(v5[0] / (double)v6);
  }
  else {
    return 1.79769313e308;
  }
}

double sub_1000EF144(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = sub_1000EED94(a1, a2, a3, a4);
  uint64_t v9 = sub_1000EEE40(a1, a2, v8, a3, a4);
  if (v9) {
    return (double)(unint64_t)(v9 - v8) / (double)(unint64_t)v9;
  }
  else {
    return 1.79769313e308;
  }
}

uint64_t sub_1000EF1BC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  return sub_1000EEE40(a1, a2, v9[2], a3, a4);
}

double sub_1000EF2A8( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, double a9, double a10, uint64_t a11)
{
  if (!(*(void *)(a1 + 24) | *(void *)(a2 + 24))) {
    return 1.79769313e308;
  }
  sub_1000EEC54(a1, a2, a8, a3, a4, a11, (uint64_t)&v26);
  if (!v28) {
    return a9;
  }
  double v19 = sub_1000EEF74(a1, a2, a8, a5, a6, a7, a11);
  if (v27 == 0.0 || v20 == 0.0)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181EF90);
    }
    uint64_t v22 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "euclidean denominator or jaccardDenominator are 0, this can only happen if weights are 0, check configuration!",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181EF90);
      }
      __int16 v25 = 0;
      int v24 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "euclidean denominator or jaccardDenominator are 0, this can only happen if weights are 0, check configuration!",  &v25,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "double CLMicroLocationFingerprintDistanceFunction::weightedEuclideanJaccardDistance(const CLMicroLocationFingerp rint &, const CLMicroLocationFingerprint &, double, double, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUtils::Weights<double> &, const CLMicroLocationUt ils::Weights<double> &, const CLMicroLocationUtils::Weights<BOOL> &, const EnabledTechnologiesConfig &, const st d::optional<CLMicroLocationAnchorAppearanceMap> &)",  "%s\n",  v24);
    }

    return 1.79769313e308;
  }

  if (a10 <= 0.0 || a10 > 1.0) {
    sub_10122AC64();
  }
  double v21 = v27 / (v27 + v20);
  if (a10 < 1.0) {
    double v21 = fmin(v21 / a10, 1.0);
  }
  return v19 / v20 * a9 * (1.0 - v21) + sqrt(v26 / (double)(unint64_t)v27) * v21;
}

void sub_1000EF538(void *a1, void *a2, double a3)
{
  unint64_t v6 = (float *)a1[2];
  if (v6)
  {
    double v7 = 0.0;
    double v8 = 0.0;
    double v9 = 0.0;
    do
    {
      double v10 = pow(a3, v6[7]);
      uint64_t v11 = (float *)sub_1000EF678(a2, (uint64_t)(v6 + 4));
      if (v11)
      {
        double v12 = pow(a3, v11[7]);
        double v8 = v8 + v10 * v12;
        double v9 = v9 + v12 * v12;
      }

      double v7 = v7 + v10 * v10;
      unint64_t v6 = *(float **)v6;
    }

    while (v6);
  }

  else
  {
    double v9 = 0.0;
  }

  for (int i = (float *)a2[2]; i; int i = *(float **)i)
  {
    if (!sub_1000EF678(a1, (uint64_t)(i + 4)))
    {
      double v14 = pow(a3, i[7]);
      double v9 = v9 + v14 * v14;
    }
  }

void sub_1000EF64C(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_1000EF678(void *a1, uint64_t a2)
{
  unint64_t v4 = sub_100138790((uint64_t)(a1 + 3), a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0LL;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }

  else
  {
    unint64_t v9 = (*(void *)&v5 - 1LL) & v4;
  }

  double v10 = *(void **)(*a1 + 8 * v9);
  if (!v10) {
    return 0LL;
  }
  uint64_t v11 = (void *)*v10;
  if (*v10)
  {
    uint64_t v12 = (uint64_t)(a1 + 4);
    do
    {
      unint64_t v13 = v11[1];
      if (v6 == v13)
      {
      }

      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(void *)&v5) {
            v13 %= *(void *)&v5;
          }
        }

        else
        {
          v13 &= *(void *)&v5 - 1LL;
        }

        if (v13 != v9) {
          return 0LL;
        }
      }

      uint64_t v11 = (void *)*v11;
    }

    while (v11);
  }

  return v11;
}

uint64_t sub_1000EF778(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  sub_100007590( (void *)a1,  *(const void **)a2,  *(void *)(a2 + 8),  (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  *(_DWORD *)(a1 + 24) = 0;
  unint64_t v4 = sub_1000BA8F0((void *)(a1 + 32), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  uint64_t v5 = *(void *)(a2 + 8) - *(void *)a2;
  if (v5)
  {
    unint64_t v6 = v5 >> 3;
    uint8x8_t v7 = (_DWORD *)*v4;
    if (v6 <= 1) {
      unint64_t v6 = 1LL;
    }
    unint64_t v8 = (int *)(*(void *)a2 + 4LL);
    do
    {
      int v9 = *v8;
      v8 += 2;
      int v10 = *(_DWORD *)(a1 + 24) + v9;
      *(_DWORD *)(a1 + 24) = v10;
      *v7++ = v10;
      --v6;
    }

    while (v6);
  }

  return a1;
}

void sub_1000EF80C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t *sub_1000EF82C@<X0>(uint64_t *result@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  unint64_t v4 = (int *)*result;
  unint64_t v5 = (result[1] - *result) >> 3;
  if (v5 >= a2) {
    unint64_t v5 = a2;
  }
  unint64_t v8 = a3;
  if (v5)
  {
    uint64_t v6 = 8 * v5;
    do
    {
      int v7 = *v4;
      uint64_t result = sub_10009CA94((uint64_t *)&v8, &v7);
      v4 += 2;
      v6 -= 8LL;
    }

    while (v6);
  }

  return result;
}

void sub_1000EF8A0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

unint64_t sub_1000EF8BC(__int32 **a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 == v3)
  {
LABEL_8:
    unint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
  }

  else
  {
    unint64_t v5 = *(__int32 **)(a2 + 8);
    while (1)
    {
      uint64_t v6 = wmemchr(*(const __int32 **)a2, *v2, ((uint64_t)v5 - *(void *)a2) >> 2);
      int v7 = v6 ? v6 : v5;
      unint64_t v5 = *(__int32 **)(a2 + 8);
      if (v7 == v5) {
        break;
      }
      v2 += 2;
      if (v2 == v3) {
        goto LABEL_8;
      }
    }

    uint64_t v9 = *v2;
    unint64_t v8 = &_mh_execute_header;
  }

  return v9 | (unint64_t)v8;
}

uint64_t sub_1000EF93C(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (*a1 == v3) {
    return 0LL;
  }
  uint64_t v5 = 0LL;
  uint64_t v6 = *(__int32 **)(a2 + 8);
  do
  {
    int v7 = wmemchr(*(const __int32 **)a2, *(_DWORD *)v2, ((uint64_t)v6 - *(void *)a2) >> 2);
    if (v7) {
      unint64_t v8 = v7;
    }
    else {
      unint64_t v8 = v6;
    }
    uint64_t v6 = *(__int32 **)(a2 + 8);
    if (v8 == v6) {
      uint64_t v9 = 0LL;
    }
    else {
      uint64_t v9 = *(unsigned int *)(v2 + 4);
    }
    v5 += v9;
    v2 += 8LL;
  }

  while (v2 != v3);
  return v5;
}

void sub_1000EF9C4(int **a1@<X0>, int **a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  double v15 = 0LL;
  double v16 = 0LL;
  uint64_t v17 = 0LL;
  std::string __p = 0LL;
  unint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  *a4 = 0LL;
  uint64_t v5 = *a1;
  else {
    unint64_t v6 = ((char *)a2[1] - (char *)*a2) >> 3;
  }
  if (v6 >= a3) {
    unint64_t v7 = a3;
  }
  else {
    unint64_t v7 = v6;
  }
  v19[0] = (uint64_t *)&v15;
  if (v7)
  {
    uint64_t v9 = 8 * v7;
    uint64_t v10 = 8 * v7;
    do
    {
      int v18 = *v5;
      sub_10009CA94((uint64_t *)v19, &v18);
      v5 += 2;
      v10 -= 8LL;
    }

    while (v10);
    uint64_t v11 = *a2;
    v19[0] = (uint64_t *)&__p;
    do
    {
      int v18 = *v11;
      sub_10009CA94((uint64_t *)v19, &v18);
      v11 += 2;
      v9 -= 8LL;
    }

    while (v9);
  }

  std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>(v15, v16, v19);
  std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>(__p, v13, v19);
  sub_1000EFB7C((uint64_t *)v15, v16, (uint64_t *)__p, v13, (uint64_t)a4, v19);
  if (__p)
  {
    unint64_t v13 = (uint64_t *)__p;
    operator delete(__p);
  }

  if (v15)
  {
    double v16 = (uint64_t *)v15;
    operator delete(v15);
  }

void sub_1000EFAF0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  double v15 = *(void **)v13;
  if (*(void *)v13)
  {
    *(void *)(v13 + 8) = v15;
    operator delete(v15);
  }

  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1000EFB38(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1000EF93C((uint64_t *)a1, a2);
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v4) {
    return COERCE_UNSIGNED_INT((float)(unint64_t)v3 / (float)v4) | (unint64_t)&_mh_execute_header;
  }
  else {
    return 0LL;
  }
}

uint64_t *sub_1000EFB7C@<X0>( uint64_t *result@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t **a6@<X8>)
{
  uint64_t v11 = a5;
  if (result != a2)
  {
    uint64_t v9 = a3;
    if (a3 != a4)
    {
      uint64_t v10 = result;
      do
      {
        if (*(_DWORD *)v10 >= *(_DWORD *)v9)
        {
          if (*(_DWORD *)v9 >= *(_DWORD *)v10)
          {
            uint64_t result = sub_10009CA94(&v11, v10);
            uint64_t v10 = (uint64_t *)((char *)v10 + 4);
          }

          uint64_t v9 = (uint64_t *)((char *)v9 + 4);
        }

        else
        {
          uint64_t v10 = (uint64_t *)((char *)v10 + 4);
        }
      }

      while (v10 != a2 && v9 != a4);
      a5 = v11;
    }
  }

  *a6 = a2;
  a6[1] = a4;
  a6[2] = (uint64_t *)a5;
  return result;
}

BOOL sub_1000EFC24(void *a1, void *a2)
{
  return *a1 != *a2 || a1[1] != a2[1];
}

uint64_t sub_1000EFC50(void *a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)*a1 + 24LL))(*a1, a1[1]);
}

uint64_t sub_1000EFC64(uint64_t result)
{
  return result;
}

void *sub_1000EFC74(void *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0LL;
  void *result = v2;
  return result;
}

uint64_t sub_1000EFC84(void *a1, unint64_t a2)
{
  return (*(uint64_t (**)(void, unint64_t))(*(void *)*a1 + 24LL))(*a1, a2);
}

uint64_t sub_1000EFCD4(void *a1)
{
  return (*(uint64_t (**)(void))(*(void *)*a1 + 16LL))(*a1);
}

BOOL sub_1000EFCE4(void *a1)
{
  return (*(uint64_t (**)(void))(*(void *)*a1 + 16LL))(*a1) == 0;
}

uint64_t sub_1000EFD0C(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t sub_1000EFD18(void *a1)
{
  uint64_t v1 = *a1;
  (*(void (**)(void))(*(void *)*a1 + 16LL))(*a1);
  return v1;
}

void sub_1000EFD4C(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

  ;
}

void sub_1000EFDB0(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, char **a5@<X8>)
{
  if (sub_100097CA8(a1))
  {
    if (*(_BYTE *)(a3 + 32))
    {
      *a5 = 0LL;
      a5[1] = 0LL;
      a5[2] = 0LL;
      *((_DWORD *)a5 + 6) = 3;
      *((_BYTE *)a5 + 80) = 0;
      a5[5] = 0LL;
      a5[6] = 0LL;
      a5[4] = 0LL;
      *((_BYTE *)a5 + 56) = 0;
      v61[0] = 0LL;
      v61[1] = 0LL;
      char v60 = (uint64_t *)v61;
      uint64_t v11 = *(void **)(a1 + 232);
      uint64_t v10 = *(void **)(a1 + 240);
      while (v11 != v10)
      {
        uint64_t v12 = *(void *)(a3 + 24);
        if (!v12) {
          sub_100008BDC();
        }
        uint64_t v62 = (*(double (**)(uint64_t, void, uint64_t))(*(void *)v12 + 48LL))(v12, *v11, a2);
        sub_1000F0468(&v60, (double *)&v62);
        v11 += 4;
      }

      double v13 = sub_10000C6B4(a4);
      double v14 = sub_10000C730(a4);
      sub_1002F0B04(&v62);
      CFStringRef v15 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsNullSpaceDistanceReductionFunction",  0x8000100u,  kCFAllocatorNull);
      int v16 = sub_1002A77CC(v62, (uint64_t)v15, v58);
      CFRelease(v15);
      unsigned int v17 = v58[0];
      int v18 = v63;
      if (v63)
      {
        p_shared_owners = (unint64_t *)&v63->__shared_owners_;
        do
          unint64_t v20 = __ldaxr(p_shared_owners);
        while (__stlxr(v20 - 1, p_shared_owners));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }

      if (v16) {
        uint64_t v21 = v17;
      }
      else {
        uint64_t v21 = 5LL;
      }
      sub_1000F02F0(v21, 0, (uint64_t)&v62, v13, v14);
      sub_10000C75C(a4, v58);
      sub_1000410B8((uint64_t)v58, &v59);
      sub_1002A5554(v58);
      sub_1000F0A4C((uint64_t)v57, (uint64_t)&v60);
      if (!v64) {
        sub_100008BDC();
      }
      double v22 = (*(double (**)(uint64_t *, void **))(*v64 + 48))(v64, v57);
      sub_100008390((uint64_t)v57, v57[1]);
      double v23 = (*(double (**)(double *, double))(*(void *)v59 + 24LL))(v59, v22);
      if (v23 >= 0.999) {
        double v24 = 1.0;
      }
      else {
        double v24 = v23;
      }
      int v25 = *(_DWORD *)(a2 + 160);
      double v26 = 1.0 - v24;
      double v27 = a5[2];
      uint64_t v28 = a5[1];
      if (v28 >= v27)
      {
        uint64_t v30 = (v28 - *a5) >> 5;
        unint64_t v31 = v30 + 1;
        uint64_t v32 = v27 - *a5;
        if (v32 >> 4 > v31) {
          unint64_t v31 = v32 >> 4;
        }
        else {
          unint64_t v33 = v31;
        }
        uint64_t v34 = (char *)sub_10000835C((uint64_t)(a5 + 2), v33);
        uint64_t v35 = &v34[32 * v30];
        uint64_t v37 = &v34[32 * v36];
        *(void *)uint64_t v35 = 0LL;
        *((void *)v35 + 1) = 0LL;
        *((double *)v35 + 2) = v26;
        *((_DWORD *)v35 + 6) = v25;
        int64x2_t v29 = v35 + 32;
        uint64_t v39 = *a5;
        uint64_t v38 = a5[1];
        if (v38 != *a5)
        {
          do
          {
            __int128 v40 = *((_OWORD *)v38 - 2);
            *(_OWORD *)(v35 - 20) = *(_OWORD *)(v38 - 20);
            *((_OWORD *)v35 - 2) = v40;
            v35 -= 32;
            v38 -= 32;
          }

          while (v38 != v39);
          uint64_t v38 = *a5;
        }

        *a5 = v35;
        a5[1] = v29;
        a5[2] = v37;
        if (v38) {
          operator delete(v38);
        }
      }

      else
      {
        *(void *)uint64_t v28 = 0LL;
        *((void *)v28 + 1) = 0LL;
        *((double *)v28 + 2) = v26;
        int64x2_t v29 = v28 + 32;
        *((_DWORD *)v28 + 6) = v25;
      }

      a5[1] = v29;
      __int128 v41 = a5[2];
      if (v29 >= v41)
      {
        uint64_t v43 = (v29 - *a5) >> 5;
        uint64_t v44 = v41 - *a5;
        uint64_t v45 = v44 >> 4;
        else {
          unint64_t v46 = v45;
        }
        uint64_t v47 = (char *)sub_10000835C((uint64_t)(a5 + 2), v46);
        uint64_t v48 = (double *)&v47[32 * v43];
        uint64_t v50 = &v47[32 * v49];
        *(_OWORD *)uint64_t v48 = xmmword_1012CE830;
        v48[2] = v24;
        *((_DWORD *)v48 + 6) = v25;
        uint64_t v42 = (char *)(v48 + 4);
        uint64_t v52 = *a5;
        uint64_t v51 = a5[1];
        if (v51 != *a5)
        {
          do
          {
            __int128 v53 = *((_OWORD *)v51 - 2);
            *(_OWORD *)((char *)v48 - 20) = *(_OWORD *)(v51 - 20);
            *((_OWORD *)v48 - 2) = v53;
            v48 -= 4;
            v51 -= 32;
          }

          while (v51 != v52);
          uint64_t v51 = *a5;
        }

        *a5 = (char *)v48;
        a5[1] = v42;
        a5[2] = v50;
        if (v51) {
          operator delete(v51);
        }
      }

      else
      {
        *(_OWORD *)int64x2_t v29 = xmmword_1012CE830;
        *((double *)v29 + 2) = v24;
        *((_DWORD *)v29 + 6) = v25;
        uint64_t v42 = v29 + 32;
      }

      a5[1] = v42;
      __int128 v54 = v59;
      uint64_t v59 = 0LL;
      if (v54) {
        (*(void (**)(double *))(*(void *)v54 + 8LL))(v54);
      }
      __int128 v55 = v64;
      if (v64 == &v62)
      {
        uint64_t v56 = 4LL;
        __int128 v55 = &v62;
      }

      else
      {
        if (!v64)
        {
LABEL_52:
          sub_100008390((uint64_t)&v60, v61[0]);
          return;
        }

        uint64_t v56 = 5LL;
      }

      (*(void (**)(void))(*v55 + 8 * v56))();
      goto LABEL_52;
    }

    sub_10122AFA0();
  }

  else
  {
    sub_10122B10C();
  }

  __break(1u);
}

void sub_1000F0218( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, void *a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, char *a21)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 8LL))(a14);
  }
  double v23 = a21;
  if (a21 == &a18)
  {
    uint64_t v24 = 4LL;
    double v23 = &a18;
  }

  else
  {
    if (!a21) {
      goto LABEL_8;
    }
    uint64_t v24 = 5LL;
  }

  (*(void (**)(void))(*(void *)v23 + 8 * v24))();
LABEL_8:
  sub_100008390((uint64_t)&a15, a16);
  sub_10000AD5C(v21);
  _Unwind_Resume(a1);
}

void sub_1000F02F0(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>, double a4@<D0>, double a5@<D1>)
{
  switch((int)a1)
  {
    case 0:
      if (a2 == 1)
      {
        uint64_t v5 = sub_1000F0518;
      }

      else if (a2)
      {
LABEL_5:
        uint64_t v5 = sub_1000F0594;
      }

      else
      {
        uint64_t v5 = sub_1000F04F4;
      }

      goto LABEL_23;
    case 1:
      goto LABEL_5;
    case 2:
      if (a2 == 1)
      {
        uint64_t v5 = sub_1000F0658;
      }

      else
      {
        if (a2) {
          goto LABEL_17;
        }
        uint64_t v5 = sub_1000F060C;
      }

      goto LABEL_23;
    case 3:
      if (!a2)
      {
        uint64_t v5 = sub_1000F06D4;
LABEL_23:
        *(void *)a3 = &off_10181F080;
        *(void *)(a3 + ++*(void *)(result + 8) = v5;
        goto LABEL_24;
      }

      if (a2 != 1)
      {
LABEL_17:
        *(void *)(a3 + 24) = 0LL;
        return;
      }

      a1 = sub_10122B450();
LABEL_12:
      if (!a2)
      {
        uint64_t v5 = sub_1000F0720;
        goto LABEL_23;
      }

      if (a2 != 1) {
        goto LABEL_17;
      }
      a1 = sub_10122B5BC(a1);
LABEL_15:
      if (!a2)
      {
        *(void *)a3 = &off_10181F130;
        *(double *)(a3 + ++*(void *)(result + 8) = a4;
        *(double *)(a3 + 16) = a5;
LABEL_24:
        *(void *)(a3 + 24) = a3;
        return;
      }

      if (a2 != 1) {
        goto LABEL_17;
      }
      unint64_t v6 = (void *)sub_10122B728(a1);
      sub_1000F043C(v6);
      return;
    case 4:
      goto LABEL_12;
    case 5:
      goto LABEL_15;
    default:
      sub_10122B278();
  }

void sub_1000F043C(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t *sub_1000F0468(uint64_t **a1, double *a2)
{
  unsigned int v4 = (uint64_t *)operator new(0x28uLL);
  double v5 = *a2;
  v4[4] = *(void *)a2;
  unint64_t v6 = a1 + 1;
  unint64_t v7 = a1[1];
  if (v7)
  {
    do
    {
      while (1)
      {
        unint64_t v6 = (uint64_t **)v7;
        unint64_t v7 = (uint64_t *)*v7;
        unint64_t v8 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }

      unint64_t v7 = (uint64_t *)v7[1];
    }

    while (v7);
    unint64_t v8 = v6 + 1;
  }

  else
  {
    unint64_t v8 = a1 + 1;
  }

double sub_1000F04F4(void *a1)
{
  if (!a1[2]) {
    sub_10122B894();
  }
  return *(double *)(*a1 + 32LL);
}

double sub_1000F0518(void *a1)
{
  if (!a1[2]) {
    sub_10122B8BC();
  }
  uint64_t v3 = (double *)*a1;
  uint64_t v1 = (double *)(a1 + 1);
  uint64_t v2 = v3;
  if (v3 != v1)
  {
    unsigned int v4 = v2;
    while (1)
    {
      double v5 = (double *)*((void *)v4 + 1);
      unint64_t v6 = v4;
      if (v5)
      {
        do
        {
          unsigned int v4 = v5;
          double v5 = *(double **)v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          unsigned int v4 = (double *)*((void *)v6 + 2);
          BOOL v7 = *(void *)v4 == (void)v6;
          unint64_t v6 = v4;
        }

        while (!v7);
      }

      if (v4 == v1) {
        break;
      }
      if (v4[4] < v2[4]) {
        uint64_t v2 = v4;
      }
    }
  }

  return v2[4];
}

double sub_1000F0594(void *a1)
{
  unint64_t v1 = a1[2];
  if (!v1) {
    sub_10122B8E4();
  }
  unsigned int v4 = (void *)*a1;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = v4;
  double v5 = 0.0;
  if (v4 != v2)
  {
    do
    {
      unint64_t v6 = (void *)v3[1];
      BOOL v7 = v3;
      if (v6)
      {
        do
        {
          unint64_t v8 = v6;
          unint64_t v6 = (void *)*v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          unint64_t v8 = (void *)v7[2];
          BOOL v9 = *v8 == (void)v7;
          BOOL v7 = v8;
        }

        while (!v9);
      }

      double v5 = v5 + *((double *)v3 + 4);
      uint64_t v3 = v8;
    }

    while (v8 != v2);
  }

  return v5 / (double)v1;
}

double sub_1000F060C(uint64_t a1)
{
  if (!*(void *)(a1 + 16)) {
    sub_10122B90C();
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  uint64_t v2 = v3;
  if (v3)
  {
    do
    {
      uint64_t v4 = v2;
      uint64_t v2 = *(void *)(v2 + 8);
    }

    while (v2);
  }

  else
  {
    do
    {
      uint64_t v4 = *(void *)(v1 + 16);
      BOOL v5 = *(void *)v4 == v1;
      uint64_t v1 = v4;
    }

    while (v5);
  }

  return *(double *)(v4 + 32);
}

double sub_1000F0658(void *a1)
{
  if (!a1[2]) {
    sub_10122B934();
  }
  uint64_t v3 = (double *)*a1;
  uint64_t v1 = (double *)(a1 + 1);
  uint64_t v2 = v3;
  if (v3 != v1)
  {
    uint64_t v4 = v2;
    while (1)
    {
      BOOL v5 = (double *)*((void *)v4 + 1);
      unint64_t v6 = v4;
      if (v5)
      {
        do
        {
          uint64_t v4 = v5;
          BOOL v5 = *(double **)v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          uint64_t v4 = (double *)*((void *)v6 + 2);
          BOOL v7 = *(void *)v4 == (void)v6;
          unint64_t v6 = v4;
        }

        while (!v7);
      }

      if (v4 == v1) {
        break;
      }
      if (v2[4] < v4[4]) {
        uint64_t v2 = v4;
      }
    }
  }

  return v2[4];
}

double sub_1000F06D4(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    sub_10122B95C();
  }
  uint64_t v3 = *(double **)a1;
  sub_1000F0818((void **)&v3, llround((double)v1 * 0.25));
  return v3[4];
}

double sub_1000F0720(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    sub_10122B984();
  }
  uint64_t v3 = *(double **)a1;
  sub_1000F0818((void **)&v3, llround((double)v1 * 0.5));
  return v3[4];
}

void *sub_1000F076C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_10181F080;
  result[1] = v3;
  return result;
}

uint64_t sub_1000F07A4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_10181F080;
  a2[1] = v2;
  return result;
}

uint64_t sub_1000F07C4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a1 + 8))(a2);
}

uint64_t sub_1000F07D0(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_1000F080C()
{
  return &off_10181F100;
}

void **sub_1000F0818(void **result, uint64_t a2)
{
  if (a2 < 0)
  {
    BOOL v7 = *result;
    do
    {
      unint64_t v8 = (void *)*v7;
      if (*v7)
      {
        do
        {
          uint64_t v4 = v8;
          unint64_t v8 = (void *)v8[1];
        }

        while (v8);
      }

      else
      {
        do
        {
          uint64_t v4 = (void *)v7[2];
          BOOL v5 = *v4 == (void)v7;
          BOOL v7 = v4;
        }

        while (v5);
      }

      BOOL v7 = v4;
    }

    while (!__CFADD__(a2++, 1LL));
  }

  else
  {
    if (!a2) {
      return result;
    }
    uint64_t v2 = *result;
    do
    {
      uint64_t v3 = (void *)v2[1];
      if (v3)
      {
        do
        {
          uint64_t v4 = v3;
          uint64_t v3 = (void *)*v3;
        }

        while (v3);
      }

      else
      {
        do
        {
          uint64_t v4 = (void *)v2[2];
          BOOL v5 = *v4 == (void)v2;
          uint64_t v2 = v4;
        }

        while (!v5);
      }

      uint64_t v2 = v4;
    }

    while (a2-- > 1);
  }

  void *result = v4;
  return result;
}

__n128 sub_1000F08A4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &off_10181F130;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++*(void *)(result + 8) = result;
  return result;
}

__n128 sub_1000F08E0(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_10181F130;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + ++*(void *)(result + 8) = result;
  return result;
}

double sub_1000F0904(uint64_t a1, uint64_t a2)
{
  return sub_1000F0958(a2, *(double *)(a1 + 8), *(double *)(a1 + 16));
}

uint64_t sub_1000F0910(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1000F094C()
{
}

double sub_1000F0958(uint64_t a1, double a2, double a3)
{
  unint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    sub_10122B9AC();
  }
  if (a3 > 1.0 || (a2 >= 0.0 ? (v4 = a2 > 1.0) : (v4 = 1), !v4 ? (BOOL v5 = a3 < a2) : (BOOL v5 = 1), v5)) {
    sub_10122B9D4();
  }
  uint64_t v6 = llround(floor((double)v3 * a2));
  int64_t v7 = llround(ceil((double)v3 * a3));
  uint64_t v8 = v7 - v6;
  if (v7 <= v6) {
    sub_10122B9FC();
  }
  int v16 = *(double **)a1;
  sub_1000F0818((void **)&v16, v6);
  BOOL v9 = v16;
  sub_1000F0818((void **)&v16, v8);
  double v10 = 0.0;
  if (v9 != v16)
  {
    do
    {
      uint64_t v11 = (double *)*((void *)v9 + 1);
      uint64_t v12 = v9;
      if (v11)
      {
        do
        {
          double v13 = v11;
          uint64_t v11 = *(double **)v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          double v13 = (double *)*((void *)v12 + 2);
          BOOL v14 = *(void *)v13 == (void)v12;
          uint64_t v12 = v13;
        }

        while (!v14);
      }

      double v10 = v10 + v9[4];
      BOOL v9 = v13;
    }

    while (v13 != v16);
  }

  return v10 / (double)v8;
}

uint64_t sub_1000F0A4C(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + ++*(void *)(result + 8) = 0LL;
  *(void *)a1 = a1 + 8;
  sub_1000F0AA0((char *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1000F0A88(_Unwind_Exception *a1)
{
}

char *sub_1000F0AA0(char *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    BOOL v4 = a2;
    BOOL v5 = (uint64_t **)result;
    uint64_t v6 = (double *)(result + 8);
    do
    {
      __n128 result = (char *)sub_1000F0B20(v5, v6, v4 + 4);
      int64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          int64_t v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          BOOL v4 = v8;
        }

        while (!v9);
      }

      BOOL v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

void *sub_1000F0B20(uint64_t **a1, double *a2, void *a3)
{
  uint64_t v6 = operator new(0x28uLL);
  *((void *)v6 + 4) = *a3;
  int64_t v7 = sub_10009BC40(a1, a2, &v9, (double *)v6 + 4);
  sub_1000085FC(a1, (uint64_t)v9, (uint64_t **)v7, (uint64_t *)v6);
  return v6;
}

void sub_1000F0B94(_Unwind_Exception *a1)
{
}

__n128 sub_1000F0BA8(__n128 *a1, __n128 *a2, unint64_t a3, unint64_t a4)
{
  __n128 result = *a2;
  *a1 = *a2;
  a1[1].n128_u64[0] = a3;
  a1[1].n128_u64[1] = a4;
  return result;
}

void *sub_1000F0BB8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(a1 + 24);
  __n128 result = (void *)(a1 + 24);
  switch(v3)
  {
    case 1LL:
      BOOL v4 = &xmmword_1019A09F0;
      break;
    case 2LL:
    case 3LL:
      BOOL v4 = &xmmword_1019A0A08;
      break;
    case 4LL:
      BOOL v4 = &xmmword_1019A0A38;
      break;
    default:
      sub_10122BA24();
  }

  *(_OWORD *)a2 = *v4;
  *(void *)(a2 + 16) = *((void *)v4 + 2);
  return result;
}

uint64_t sub_1000F0C3C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, __int128 *a8, uint64_t a9)
{
  *(void *)a1 = a2;
  *(void *)(a1 + ++*(void *)(result + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a5;
  *(void *)(a1 + 32) = a6;
  if (*((char *)a7 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 40), *(void **)a7, *((void *)a7 + 1));
  }

  else
  {
    __int128 v11 = *a7;
    *(void *)(a1 + 56) = *((void *)a7 + 2);
    *(_OWORD *)(a1 + 40) = v11;
  }

  uint64_t v12 = (_BYTE *)(a1 + 64);
  if (*((char *)a8 + 23) < 0)
  {
    sub_1010DD48C(v12, *(void **)a8, *((void *)a8 + 1));
  }

  else
  {
    __int128 v13 = *a8;
    *(void *)(a1 + 80) = *((void *)a8 + 2);
    *(_OWORD *)uint64_t v12 = v13;
  }

  *(_BYTE *)(a1 + 296) = 0;
  *(_BYTE *)(a1 + 36++*(void *)(result + 8) = 0;
  *(_BYTE *)(a1 + 440) = 0;
  *(void *)(a1 + 104) = 0LL;
  *(_BYTE *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0LL;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_BYTE *)(a1 + 352) = 0;
  *(_BYTE *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 40++*(void *)(result + 8) = 0u;
  *(void *)(a1 + 4sub_10000AE14(v17 - 48) = a9;
  *(_WORD *)(a1 + 456) = 0;
  *(void *)(a1 + 8++*(void *)(result + 8) = 1LL;
  sub_1000F0D38((void *)(a1 + 96));
  return a1;
}

void sub_1000F0D1C(_Unwind_Exception *exception_object)
{
}

void sub_1000F0D38(void *a1)
{
  uint64_t v1 = (std::__shared_weak_count *)a1[1];
  *a1 = 0LL;
  a1[1] = 0LL;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      unint64_t v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }

unint64_t sub_1000F0D94(unint64_t result)
{
  if (HIDWORD(result)) {
    sub_10122BBA0();
  }
  return result;
}

uint64_t sub_1000F0DAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = *(void *)(a3 + 8);
  uint64_t v8 = *(void *)(a3 + 16);
  uint64_t v10 = *(void *)a3;
  unint64_t v11 = *(void *)(a3 + 56);
  sub_1000F0D94(v11);
  if (*(char *)(a3 + 55) < 0)
  {
    sub_1010DD48C(__dst, *(void **)(a3 + 32), *(void *)(a3 + 40));
  }

  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)(a3 + 32);
    uint64_t v16 = *(void *)(a3 + 48);
  }

  if (*(char *)(a3 + 87) < 0)
  {
    sub_1010DD48C(__p, *(void **)(a3 + 64), *(void *)(a3 + 72));
  }

  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)(a3 + 64);
    uint64_t v14 = *(void *)(a3 + 80);
  }

  sub_1000F0C3C(a1, a2, v9, v8, v10, v11, (__int128 *)__dst, (__int128 *)__p, a4);
  if (SHIBYTE(v14) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v16) < 0) {
    operator delete(__dst[0]);
  }
  return a1;
}

void sub_1000F0EAC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000F0EE0(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_1000F0EEC(uint64_t a1)
{
  return a1 + 40;
}

uint64_t sub_1000F0EF4(uint64_t a1)
{
  return a1 + 64;
}

void *sub_1000F0EFC@<X0>(void *result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (result == (void *)1) {
    return sub_1010DDBC0(a3, "kMiLoClientIdentifierUnsupervisedShared");
  }
  *(_OWORD *)a3 = *(_OWORD *)a2;
  a3[2] = *(void *)(a2 + 16);
  return result;
}

void *sub_1000F0F40@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_1000F0EFC(*(void **)(a1 + 24), a1 + 40, a2);
}

uint64_t sub_1000F0F50(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_1000F0F58(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_1000F0F60(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x20) {
    sub_10000C918("bitset test argument out of range");
  }
  return (*(void *)(a1 + 32) >> a2) & 1LL;
}

uint64_t sub_1000F0F90(uint64_t result, unint64_t a2)
{
  if (a2 >= 0x20) {
    sub_10000C918("bitset set argument out of range");
  }
  *(void *)(result + 32) |= 1LL << a2;
  return result;
}

void sub_1000F0FC8(char *a1, _OWORD *a2)
{
  if (a1[296])
  {
    BOOL v4 = a1 + 40;
    int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 88LL))();
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    uint64_t v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      int64_t v7 = operator new(0x28uLL);
      std::string __p = v7;
      __int128 v21 = xmmword_1012C8460;
      *int64_t v7 = 0u;
      v7[1] = 0u;
      *(void *)((char *)v7 + 29) = 0LL;
      sub_10000AE6C((uint64_t)(a1 + 8), v7);
      if (v21 >= 0) {
        p_p = (char *)&__p;
      }
      else {
        p_p = (char *)__p;
      }
      if (a1[63] < 0) {
        BOOL v4 = (void *)*v4;
      }
      if (!a1[296]) {
        sub_100036CD8();
      }
      uint64_t v9 = (char *)operator new(0x28uLL);
      *(void *)(v9 + 29) = 0LL;
      *(_OWORD *)uint64_t v9 = 0u;
      *((_OWORD *)v9 + 1) = 0u;
      sub_10000AE6C((uint64_t)(a1 + 280), v9);
      uint64_t v10 = (char *)operator new(0x28uLL);
      *(void *)(v10 + 29) = 0LL;
      *(_OWORD *)uint64_t v10 = 0u;
      *((_OWORD *)v10 + 1) = 0u;
      sub_10000AE6C((uint64_t)a2, v10);
      *(_DWORD *)uint64_t buf = 68290306;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      __int16 v23 = 2082;
      uint64_t v24 = p_p;
      __int16 v25 = 2082;
      double v26 = v4;
      __int16 v27 = 2082;
      uint64_t v28 = v9;
      __int16 v29 = 2082;
      uint64_t v30 = v10;
      __int16 v31 = 1026;
      int v32 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService sending cached results to client: , ServiceId:%{public, location:esca pe_only}s, ClientId:%{public, location:escape_only}s, Cached LocalizationId:%{public, location:escape_on ly}s, RequestId:%{public, location:escape_only}s, Succeeded to save trigger:%{public}hhd}",  buf,  0x40u);
      operator delete(v10);
      operator delete(v9);
      if (SHIBYTE(v21) < 0) {
        operator delete(__p);
      }
    }

    uint64_t v11 = *(void *)a1;
    *(_OWORD *)uint64_t buf = *a2;
    uint8_t buf[16] = 1;
    if (!a1[296]) {
      sub_100036CD8();
    }
    (*(void (**)(uint64_t, char *, _BYTE *, char *))(*(void *)v11 + 32LL))(v11, a1 + 8, buf, a1 + 112);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    uint64_t v12 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      __int128 v13 = (char *)operator new(0x28uLL);
      *(_OWORD *)__int128 v13 = 0u;
      *((_OWORD *)v13 + 1) = 0u;
      *(void *)(v13 + 29) = 0LL;
      sub_10000AE6C((uint64_t)(a1 + 8), v13);
      uint64_t v14 = a1 + 40;
      if (a1[63] < 0) {
        uint64_t v14 = (void *)*v14;
      }
      CFStringRef v15 = (char *)operator new(0x28uLL);
      *(void *)(v15 + 29) = 0LL;
      *(_OWORD *)CFStringRef v15 = 0u;
      *((_OWORD *)v15 + 1) = 0u;
      sub_10000AE6C((uint64_t)a2, v15);
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      __int16 v23 = 2082;
      uint64_t v24 = v13;
      __int16 v25 = 2082;
      double v26 = v14;
      __int16 v27 = 2082;
      uint64_t v28 = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CLMiLoService tried to send cached results to client but no cache available:, Service Id:%{public, location:escape_only}s, ClientId:%{public, location:escape_only}s, RequestId:%{public, lo cation:escape_only}s}",  buf,  0x30u);
      operator delete(v15);
      operator delete(v13);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
    }

    uint64_t v16 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      unsigned int v17 = (char *)operator new(0x28uLL);
      *(void *)(v17 + 29) = 0LL;
      *(_OWORD *)unsigned int v17 = 0u;
      *((_OWORD *)v17 + 1) = 0u;
      sub_10000AE6C((uint64_t)(a1 + 8), v17);
      int v18 = a1 + 40;
      if (a1[63] < 0) {
        int v18 = (void *)*v18;
      }
      double v19 = (char *)operator new(0x28uLL);
      *(void *)(v19 + 29) = 0LL;
      *(_OWORD *)double v19 = 0u;
      *((_OWORD *)v19 + 1) = 0u;
      sub_10000AE6C((uint64_t)a2, v19);
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      __int16 v23 = 2082;
      uint64_t v24 = v17;
      __int16 v25 = 2082;
      double v26 = v18;
      __int16 v27 = 2082;
      uint64_t v28 = v19;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CLMiLoService tried to send cached results to client but no cache available:",  "{msg%{public}.0s:CLMiLoService tried to send cached results to client but no cache available:, Service Id:%{public, location:escape_only}s, ClientId:%{public, location:escape_only}s, RequestId:%{public, lo cation:escape_only}s}",  buf,  0x30u);
      operator delete(v19);
      operator delete(v17);
    }
  }

void sub_1000F1444( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void sub_1000F14CC(int64x2_t *a1, uint64_t a2, unsigned __int8 a3, uint64_t a4, uint64_t a5)
{
  *(void *)&__int128 v70 = a4;
  *((void *)&v70 + 1) = a5;
  if (!a1[5].i64[1])
  {
    uint64_t v7 = a3;
    if (a3 && (!a1[28].i8[9] || !a1[28].i8[8] || (sub_1000F1EB0() & 1) == 0))
    {
      sub_1000C38B0((uint64_t)v49, a2);
      __int128 v8 = v70;
      sub_1000C38B0((uint64_t)buf, (uint64_t)v49);
      __int128 v69 = v8;
      sub_1000F1F88((uint64_t)a1[7].i64, (uint64_t)buf);
      if (__p)
      {
        __int128 v68 = __p;
        operator delete(__p);
      }

      if (v66[40]) {
        sub_10004AD90((uint64_t)v66);
      }
      if (v65 && v64 < 0) {
        operator delete(v63);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }

      if (v53)
      {
        __int128 v54 = v53;
        operator delete(v53);
      }

      if (v52[40]) {
        sub_10004AD90((uint64_t)v52);
      }
      if (v51 && v50 < 0) {
        operator delete(v49[7]);
      }
      if (v49[0])
      {
        v49[1] = v49[0];
        operator delete(v49[0]);
      }
    }

    uint64_t i64 = (uint64_t)a1[22].i64;
    if (a1[23].i8[0] && (a1[22].i64[0] == (void)v70 ? (BOOL v9 = a1[22].i64[1] == *((void *)&v70 + 1)) : (BOOL v9 = 0), v9))
    {
      a1[23].i8[0] = 0;
      if (v7)
      {
        if (a1[21].i64[1])
        {
          uint64_t v27 = (uint64_t)a1[19].i64;
          p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
          __int16 v29 = &OBJC_METACLASS___CLPrivacyManager.vtable;
          do
          {
            __int128 v55 = *(_OWORD *)(*(void *)(a1[19].i64[1] + 8 * (a1[21].i64[0] / 0x7CuLL)) + 33
                                                                                         * (a1[21].i64[0] % 0x7CuLL));
            uint64_t v30 = (os_log_s *)v29[283];
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v31 = operator new(0x28uLL);
              uint64_t v32 = v27;
              uint64_t v33 = a2;
              uint64_t v47 = v31;
              __int128 v48 = xmmword_1012C8460;
              _OWORD *v31 = 0u;
              v31[1] = 0u;
              *(void *)((char *)v31 + 29) = 0LL;
              sub_10000AE6C((uint64_t)&a1->i64[1], v31);
              uint64_t v34 = v29;
              if (v48 >= 0) {
                uint64_t v35 = (char *)&v47;
              }
              else {
                uint64_t v35 = (char *)v47;
              }
              uint64_t v36 = operator new(0x28uLL);
              uint64_t v37 = p_vtable;
              uint64_t v45 = v36;
              __int128 v46 = xmmword_1012C8460;
              *uint64_t v36 = 0u;
              v36[1] = 0u;
              *(void *)((char *)v36 + 29) = 0LL;
              sub_10000AE6C((uint64_t)&v70, v36);
              if (v46 >= 0) {
                uint64_t v38 = (char *)&v45;
              }
              else {
                uint64_t v38 = (char *)v45;
              }
              uint64_t v39 = operator new(0x28uLL);
              uint64_t v43 = v39;
              __int128 v44 = xmmword_1012C8460;
              *uint64_t v39 = 0u;
              v39[1] = 0u;
              *(void *)((char *)v39 + 29) = 0LL;
              sub_10000AE6C((uint64_t)&v55, v39);
              __int128 v40 = (char *)&v43;
              if (v44 < 0) {
                __int128 v40 = (char *)v43;
              }
              *(_DWORD *)uint64_t buf = 68289794;
              *(_DWORD *)&uint8_t buf[4] = 0;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = "";
              __int16 v57 = 2082;
              int v58 = v35;
              __int16 v59 = 2082;
              char v60 = v38;
              __int16 v61 = 2082;
              uint64_t v62 = v40;
              _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService received localization results, sending results to client: , Ser viceId:%{public, location:escape_only}s, LocalizationId:%{public, location:escape_only}s, Reques tId:%{public, location:escape_only}s}",  buf,  0x30u);
              if (SHIBYTE(v44) < 0) {
                operator delete(v43);
              }
              p_vtable = v37;
              if (SHIBYTE(v46) < 0) {
                operator delete(v45);
              }
              __int16 v29 = v34;
              if (SHIBYTE(v48) < 0) {
                operator delete(v47);
              }
              a2 = v33;
              uint64_t v27 = v32;
            }

            uint64_t v41 = a1->i64[0];
            *(_OWORD *)uint64_t buf = v55;
            uint8_t buf[16] = 1;
            (*(void (**)(uint64_t, uint64_t *, _BYTE *, uint64_t))(*(void *)v41 + 32LL))( v41,  &a1->i64[1],  buf,  a2);
            a1[21] = vaddq_s64(a1[21], (int64x2_t)xmmword_1012CE4D0);
            sub_1000F8BA8(v27, 1);
          }

          while (a1[21].i64[1]);
        }
      }

      else
      {
        sub_1000F2024(a1, 3);
      }
    }

    else if (v7 && a1[28].i8[9])
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      uint64_t v10 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = operator new(0x28uLL);
        uint64_t v47 = v11;
        __int128 v48 = xmmword_1012C8460;
        _OWORD *v11 = 0u;
        v11[1] = 0u;
        *(void *)((char *)v11 + 29) = 0LL;
        sub_10000AE6C((uint64_t)&a1->i64[1], v11);
        if (v48 >= 0) {
          uint64_t v12 = (char *)&v47;
        }
        else {
          uint64_t v12 = (char *)v47;
        }
        __int128 v13 = operator new(0x28uLL);
        uint64_t v45 = v13;
        __int128 v46 = xmmword_1012C8460;
        _OWORD *v13 = 0u;
        v13[1] = 0u;
        *(void *)((char *)v13 + 29) = 0LL;
        sub_10000AE6C((uint64_t)&v70, v13);
        uint64_t v14 = (char *)&v45;
        if (v46 < 0) {
          uint64_t v14 = (char *)v45;
        }
        *(_DWORD *)uint64_t buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v57 = 2082;
        int v58 = v12;
        __int16 v59 = 2082;
        char v60 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService received localization results, reporting to client with service updating params, ServiceId:%{public, location:escape_only}s, LocalizationId:%{public, location:escape_only}s}",  buf,  0x26u);
        if (SHIBYTE(v46) < 0) {
          operator delete(v45);
        }
        if (SHIBYTE(v48) < 0) {
          operator delete(v47);
        }
      }

      uint64_t v15 = a1->i64[0];
      *(_OWORD *)uint64_t buf = v70;
      uint8_t buf[16] = 1;
      (*(void (**)(uint64_t, uint64_t *, _BYTE *, uint64_t))(*(void *)v15 + 32LL))(v15, &a1->i64[1], buf, a2);
    }

    if (a1[23].i8[0])
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      uint64_t v16 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        unsigned int v17 = operator new(0x28uLL);
        uint64_t v47 = v17;
        __int128 v48 = xmmword_1012C8460;
        *unsigned int v17 = 0u;
        v17[1] = 0u;
        *(void *)((char *)v17 + 29) = 0LL;
        sub_10000AE6C((uint64_t)&a1->i64[1], v17);
        if (v48 >= 0) {
          int v18 = (char *)&v47;
        }
        else {
          int v18 = (char *)v47;
        }
        if (!a1[23].i8[0]) {
          sub_100036CD8();
        }
        double v19 = operator new(0x28uLL);
        uint64_t v45 = v19;
        __int128 v46 = xmmword_1012C8460;
        *double v19 = 0u;
        v19[1] = 0u;
        *(void *)((char *)v19 + 29) = 0LL;
        sub_10000AE6C(i64, v19);
        if (v46 >= 0) {
          unint64_t v20 = (char *)&v45;
        }
        else {
          unint64_t v20 = (char *)v45;
        }
        __int128 v21 = operator new(0x28uLL);
        uint64_t v43 = v21;
        __int128 v44 = xmmword_1012C8460;
        *__int128 v21 = 0u;
        v21[1] = 0u;
        *(void *)((char *)v21 + 29) = 0LL;
        sub_10000AE6C((uint64_t)&v70, v21);
        double v22 = (char *)&v43;
        if (v44 < 0) {
          double v22 = (char *)v43;
        }
        *(_DWORD *)uint64_t buf = 68289794;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v57 = 2082;
        int v58 = v18;
        __int16 v59 = 2082;
        char v60 = v20;
        __int16 v61 = 2082;
        uint64_t v62 = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CLMiLoService received localization results with unexpected / unmatching ID, Servic eId:%{public, location:escape_only}s, Expected localization ID:%{public, location:escape_only}s, Recei ved trigger ID:%{public, location:escape_only}s}",  buf,  0x30u);
        if (SHIBYTE(v44) < 0) {
          operator delete(v43);
        }
        if (SHIBYTE(v46) < 0) {
          operator delete(v45);
        }
        if (SHIBYTE(v48) < 0) {
          operator delete(v47);
        }
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F1A0);
        }
      }

      __int16 v23 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        uint64_t v24 = (char *)operator new(0x28uLL);
        *(void *)(v24 + 29) = 0LL;
        *(_OWORD *)uint64_t v24 = 0u;
        *((_OWORD *)v24 + 1) = 0u;
        sub_10000AE6C((uint64_t)&a1->i64[1], v24);
        if (!a1[23].i8[0]) {
          sub_100036CD8();
        }
        __int16 v25 = (char *)operator new(0x28uLL);
        *(void *)(v25 + 29) = 0LL;
        *(_OWORD *)__int16 v25 = 0u;
        *((_OWORD *)v25 + 1) = 0u;
        sub_10000AE6C(i64, v25);
        double v26 = (char *)operator new(0x28uLL);
        *(void *)(v26 + 29) = 0LL;
        *(_OWORD *)double v26 = 0u;
        *((_OWORD *)v26 + 1) = 0u;
        sub_10000AE6C((uint64_t)&v70, v26);
        *(_DWORD *)uint64_t buf = 68289794;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v57 = 2082;
        int v58 = v24;
        __int16 v59 = 2082;
        char v60 = v25;
        __int16 v61 = 2082;
        uint64_t v62 = v26;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v23,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CLMiLoService received localization results with unexpected / unmatching ID",  "{msg%{public}.0s:CLMiLoService received localization results with unexpected / unmatching ID, Servic eId:%{public, location:escape_only}s, Expected localization ID:%{public, location:escape_only}s, Recei ved trigger ID:%{public, location:escape_only}s}",  buf,  0x30u);
        operator delete(v26);
        operator delete(v25);
        operator delete(v24);
      }

      if (a1[23].i8[0]) {
        a1[23].i8[0] = 0;
      }
      sub_1000F2024(a1, 3);
    }

    sub_1000F24B4(a1);
  }

void sub_1000F1DB0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, void *__p, uint64_t a27, int a28, __int16 a29, char a30, char a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  if (a31 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000F1EB0()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsForcePredictionForLowLatencyServiceEnabled",  0x8000100u,  kCFAllocatorNull);
  int v1 = sub_1002A6FD4(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  BOOL v2 = v7;
  unint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v2) {
    return 1LL;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_1000F1F70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1000F1F88(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 184))
  {
    sub_100007664(a1, (__n128 *)a2);
    __int128 v4 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
    *(_OWORD *)(a1 + 24) = v4;
    sub_1000F8B0C(a1 + 56, (__n128 *)(a2 + 56));
    sub_10004B698(a1 + 88, a2 + 88);
    *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
    sub_100007664(a1 + 144, (__n128 *)(a2 + 144));
    *(_OWORD *)(a1 + 16++*(void *)(result + 8) = *(_OWORD *)(a2 + 168);
  }

  else
  {
    sub_1000EB670(a1, a2);
    *(_BYTE *)(a1 + 184) = 1;
  }

  return a1;
}

void sub_1000F2024(int64x2_t *a1, int a2)
{
  uint64_t v4 = 29LL;
  if (!a2) {
    uint64_t v4 = -1LL;
  }
  uint64_t v19 = v4;
  if (a1[21].i64[1])
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    unint64_t v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = (char *)operator new(0x28uLL);
      *(void *)std::string __p = v6;
      *(_OWORD *)&__p[8] = xmmword_1012C8460;
      *(_OWORD *)uint64_t v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      *(void *)(v6 + 29) = 0LL;
      sub_10000AE6C((uint64_t)&a1->i64[1], v6);
      BOOL v7 = __p;
      if (__p[23] < 0) {
        BOOL v7 = *(_BYTE **)__p;
      }
      BOOL v8 = a1[21].i64[1] != 0;
      *(_DWORD *)uint64_t buf = 68289794;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v34 = 2082;
      *(void *)&v34[2] = "";
      __int16 v35 = 2082;
      uint64_t v36 = v7;
      __int16 v37 = 1026;
      BOOL v38 = v8;
      __int16 v39 = 1026;
      BOOL v40 = a2 == 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService releasing prediction requsts: , ServiceId:%{public, location:escape_o nly}s, NumRequests:%{public}hhd, Success:%{public}hhd}",  buf,  0x28u);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }
  }

  if ((sub_100094860(a2) & 0xFF00000000LL) != 0)
  {
    unint64_t v9 = sub_100094860(a2);
    int v10 = v9;
    if ((v9 & 0xFF00000000LL) == 0) {
      sub_100036CD8();
    }
    uint64_t v11 = operator new(4uLL);
    _DWORD *v11 = v10;
    uint64_t v12 = (uint64_t)(v11 + 1);
  }

  else
  {
    uint64_t v12 = 0LL;
    uint64_t v11 = 0LL;
  }

  while (a1[21].i64[1])
  {
    unint64_t v13 = a1[21].u64[0];
    uint64_t v14 = *(void *)(a1[19].i64[1] + 8 * (v13 / 0x7C));
    unint64_t v15 = v13 % 0x7C;
    if (!a2)
    {
      uint64_t v16 = v14 + 33 * v15;
      if (*(_BYTE *)(v16 + 32))
      {
        sub_1000F5440(a1->i64, (void *)v16, (_OWORD *)(v16 + 16));
        unint64_t v17 = a1[21].u64[0];
        uint64_t v14 = *(void *)(a1[19].i64[1] + 8 * (v17 / 0x7C));
        unint64_t v15 = v17 % 0x7C;
      }
    }

    (*(void (**)(uint64_t, uint64_t *, unint64_t, uint64_t))(*(void *)a1->i64[0] + 40LL))( a1->i64[0],  &a1->i64[1],  v14 + 33 * v15,  v19);
    __int16 v29 = 0LL;
    uint64_t v30 = 0LL;
    uint64_t v27 = 0LL;
    uint64_t v28 = 0LL;
    __int128 v26 = 0uLL;
    LOBYTE(v23) = 0;
    char v25 = 0;
    __p[0] = 0;
    char v32 = 0;
    __int128 v21 = 0LL;
    uint64_t v22 = 0LL;
    unint64_t v20 = 0LL;
    sub_10001B72C(&v20, v11, v12, (v12 - (uint64_t)v11) >> 2);
    sub_10004B81C((uint64_t)buf, (uint64_t)&v28, &v26, 0, &v23, (uint64_t)__p, 0, (uint64_t)&v20);
    if (v20)
    {
      __int128 v21 = v20;
      operator delete(v20);
    }

    if (v32) {
      sub_10004AD90((uint64_t)__p);
    }
    if (v25 && v24 < 0) {
      operator delete((void *)v23);
    }
    if (v28)
    {
      __int16 v29 = v28;
      operator delete(v28);
    }

    uint64_t v18 = a1->i64[0];
    *(_OWORD *)std::string __p = *(_OWORD *)(*(void *)(a1[19].i64[1] + 8 * (a1[21].i64[0] / 0x7CuLL))
                               + 33 * (a1[21].i64[0] % 0x7CuLL));
    __p[16] = 1;
    (*(void (**)(uint64_t, uint64_t *, _BYTE *, uint8_t *))(*(void *)v18 + 32LL))(v18, &a1->i64[1], __p, buf);
    a1[21] = vaddq_s64(a1[21], (int64x2_t)xmmword_1012CE4D0);
    sub_1000F8BA8((uint64_t)a1[19].i64, 1);
    if (v45)
    {
      __int128 v46 = v45;
      operator delete(v45);
    }

    if (v44[40]) {
      sub_10004AD90((uint64_t)v44);
    }
    if (v43 && v42 < 0) {
      operator delete(v41);
    }
    if (*(void *)buf)
    {
      *(void *)uint64_t v34 = *(void *)buf;
      operator delete(*(void **)buf);
    }
  }

  if (v11) {
    operator delete(v11);
  }
}

void sub_1000F2434( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33, int a34, __int16 a35, char a36, char a37)
{
}

void sub_1000F24B4(void *a1)
{
  unint64_t v1 = a1[3];
  if (v1 >= 4)
  {
    if (v1 == 4)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      uint64_t v6 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v7 = (char *)operator new(0x28uLL);
        *(_OWORD *)BOOL v7 = 0u;
        *((_OWORD *)v7 + 1) = 0u;
        *(void *)(v7 + 29) = 0LL;
        sub_10000AE6C((uint64_t)(a1 + 1), v7);
        int v8 = 68289283;
        int v9 = 0;
        __int16 v10 = 2082;
        uint64_t v11 = "";
        __int16 v12 = 2081;
        unint64_t v13 = v7;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:applying model with recent changes, ServiceUUID:%{private, location:escape_only}s}",  (uint8_t *)&v8,  0x1Cu);
        operator delete(v7);
      }

      sub_1000F3758(a1);
    }

    else if (v1 == 5)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      unint64_t v3 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        uint64_t v11 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:applyRecentChangesToModel, received invalid serviceType = CLMiLoServiceTypeMax}",  (uint8_t *)&v8,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F1A0);
        }
      }

      uint64_t v4 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        uint64_t v11 = "";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "applyRecentChangesToModel, received invalid serviceType = CLMiLoServiceTypeMax",  "{msg%{public}.0s:applyRecentChangesToModel, received invalid serviceType = CLMiLoServiceTypeMax}",  (uint8_t *)&v8,  0x12u);
      }
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    BOOL v2 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      int v8 = 68289282;
      int v9 = 0;
      __int16 v10 = 2082;
      uint64_t v11 = "";
      __int16 v12 = 2050;
      unint64_t v13 = (char *)v1;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:applying model with recent changes is not applicable, Service Type:%{public}lu}",  (uint8_t *)&v8,  0x1Cu);
    }
  }

void sub_1000F27A4(_Unwind_Exception *a1)
{
}

void sub_1000F27C0(uint64_t a1)
{
}

void sub_1000F27C8(uint64_t *a1, int a2)
{
  if (!a1[11] && *((_BYTE *)a1 + 457))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    uint64_t v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v5 = operator new(0x28uLL);
      std::string __p = v5;
      __int128 v22 = xmmword_1012C8460;
      *unint64_t v5 = 0u;
      v5[1] = 0u;
      *(void *)((char *)v5 + 29) = 0LL;
      sub_10000AE6C((uint64_t)(a1 + 1), v5);
      p_p = __p;
      if (v22 >= 0) {
        p_p = &__p;
      }
      BOOL v7 = a1 + 5;
      *(_DWORD *)uint64_t buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)char v25 = 2082;
      *(void *)&void v25[2] = "";
      __int16 v26 = 2082;
      uint64_t v27 = p_p;
      __int16 v28 = 2082;
      __int16 v29 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService sending invalid confidence empty results to client: , ServiceId:%{pub lic, location:escape_only}s, ClientId:%{public, location:escape_only}s}",  buf,  0x26u);
      if (SHIBYTE(v22) < 0) {
        operator delete(__p);
      }
    }

    uint64_t v19 = 0LL;
    uint64_t v20 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    __int128 v16 = 0uLL;
    LOBYTE(v13) = 0;
    char v15 = 0;
    LOBYTE(__p) = 0;
    char v23 = 0;
    int v8 = operator new(4uLL);
    __int16 v10 = v8;
    *int v8 = a2;
    uint64_t v11 = v8 + 1;
    __int16 v12 = v8 + 1;
    sub_10004B81C((uint64_t)buf, (uint64_t)&v18, &v16, 0, &v13, (uint64_t)&__p, 0, (uint64_t)&v10);
    if (v10)
    {
      uint64_t v11 = v10;
      operator delete(v10);
    }

    if (v23) {
      sub_10004AD90((uint64_t)&__p);
    }
    if (v15 && v14 < 0) {
      operator delete((void *)v13);
    }
    if (v18)
    {
      uint64_t v19 = v18;
      operator delete(v18);
    }

    uint64_t v9 = *a1;
    std::string __p = 0LL;
    *(void *)&__int128 v22 = 0LL;
    BYTE8(v22) = 1;
    (*(void (**)(uint64_t, uint64_t *, void **, uint8_t *))(*(void *)v9 + 32LL))(v9, a1 + 1, &__p, buf);
    if (v34)
    {
      __int16 v35 = v34;
      operator delete(v34);
    }

    if (v33[40]) {
      sub_10004AD90((uint64_t)v33);
    }
    if (v32 && v31 < 0) {
      operator delete(v30);
    }
    if (*(void *)buf)
    {
      *(void *)char v25 = *(void *)buf;
      operator delete(*(void **)buf);
    }
  }

void sub_1000F2A58( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

void sub_1000F2A84(uint64_t *a1)
{
  if (!a1[11])
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    BOOL v2 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v3 = (char *)operator new(0x28uLL);
      *(_OWORD *)unint64_t v3 = 0u;
      *((_OWORD *)v3 + 1) = 0u;
      *(void *)(v3 + 29) = 0LL;
      sub_10000AE6C((uint64_t)(a1 + 1), v3);
      uint64_t v4 = a1 + 5;
      uint64_t buf = (void *)68289538;
      *(_WORD *)char v23 = 2082;
      *(void *)&void v23[2] = "";
      __int16 v24 = 2082;
      char v25 = v3;
      __int16 v26 = 2082;
      uint64_t v27 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService sending initial empty prediction to BlueAtlas client: , ServiceId:%{p ublic, location:escape_only}s, ClientId:%{public, location:escape_only}s}",  (uint8_t *)&buf,  0x26u);
      operator delete(v3);
    }

    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    uint64_t v15 = 0LL;
    __int128 v16 = 0LL;
    __int128 v14 = 0uLL;
    LOBYTE(v11) = 0;
    char v13 = 0;
    LOBYTE(v19[0]) = 0;
    char v21 = 0;
    uint64_t v9 = 0LL;
    uint64_t v10 = 0LL;
    std::string __p = 0LL;
    sub_10004B81C((uint64_t)&buf, (uint64_t)&v16, &v14, 0, &v11, (uint64_t)v19, 1, (uint64_t)&__p);
    if (__p)
    {
      uint64_t v9 = __p;
      operator delete(__p);
    }

    if (v21) {
      sub_10004AD90((uint64_t)v19);
    }
    if (v13 && v12 < 0) {
      operator delete((void *)v11);
    }
    if (v16)
    {
      uint64_t v17 = v16;
      operator delete(v16);
    }

    uint64_t v5 = *a1;
    int v7 = 0;
    sub_100018E34(&v7);
    v19[0] = sub_100017338((ssize_t)&v7);
    v19[1] = v6;
    char v20 = 1;
    (*(void (**)(uint64_t, uint64_t *, void *, void **))(*(void *)v5 + 32LL))(v5, a1 + 1, v19, &buf);
    sub_100019D7C((unsigned int *)&v7);
    if (v32)
    {
      uint64_t v33 = v32;
      operator delete(v32);
    }

    if (v31[40]) {
      sub_10004AD90((uint64_t)v31);
    }
    if (v30 && v29 < 0) {
      operator delete(v28);
    }
    if (buf)
    {
      *(void *)char v23 = buf;
      operator delete(buf);
    }
  }

void sub_1000F2CEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
}

uint64_t sub_1000F2D20@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 104);
  *a2 = *(void *)(result + 96);
  a2[1] = v2;
  if (v2)
  {
    unint64_t v3 = (unint64_t *)(v2 + 8);
    do
      unint64_t v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }

  return result;
}

uint64_t sub_1000F2D44(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

void sub_1000F2D54(uint64_t a1, uint64_t *a2)
{
  if (!*a2) {
    sub_10122BD44(qword_1019348D0 == -1);
  }
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  unint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)uint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(void *)(v5 + 29) = 0LL;
    sub_10000AE6C(a1 + 8, v5);
    uint64_t v6 = *a2;
    int v7 = (char *)operator new(0x28uLL);
    *(void *)(v7 + 29) = 0LL;
    *(_OWORD *)int v7 = 0u;
    *((_OWORD *)v7 + 1) = 0u;
    sub_10000AE6C(v6 + 352, v7);
    v8[0] = 68289538;
    v8[1] = 0;
    __int16 v9 = 2082;
    uint64_t v10 = "";
    __int16 v11 = 2082;
    char v12 = v5;
    __int16 v13 = 2082;
    __int128 v14 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Model updated: , ServiceId:%{public, location:escape_only}s, ModelId:%{public, lo cation:escape_only}s}",  (uint8_t *)v8,  0x26u);
    operator delete(v7);
    operator delete(v5);
  }

  sub_1000F2F30((void *)(a1 + 96), a2);
  sub_1000F24B4((void *)a1);
  sub_1000F2FA8((void *)a1);
  sub_1000F3478(a1);
  if (*(_BYTE *)(a1 + 457)) {
    sub_1000F34FC((void *)a1, *(unsigned __int8 *)(a1 + 456));
  }
}

void sub_1000F2F00(_Unwind_Exception *a1)
{
}

void *sub_1000F2F30(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3)
  {
    uint64_t v5 = (unint64_t *)(v3 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  int v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  return a1;
}

void *sub_1000F2FA8(void *result)
{
  uint64_t v1 = result[12];
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = v1 + 352;
    (*(void (**)(void *__return_ptr, void, uint64_t))(*(void *)*result + 120LL))(v18, *result, v1 + 352);
    if (v21)
    {
      if ((v20 & 0x10) == 0)
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F1A0);
        }
        uint64_t v4 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "ClusterAnchorValueStatistics has no data",  buf,  2u);
        }

        if (!sub_1002921D0(115, 0)) {
          return (void *)sub_1000A7938((uint64_t)v18);
        }
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 == -1) {
          goto LABEL_24;
        }
LABEL_33:
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
LABEL_24:
        v11[0] = 0;
        uint64_t v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "ClusterAnchorValueStatistics has no data",  v11,  2);
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLMiLoService::loadAnchorValueStatistics()", "%s\n", v10);
        return (void *)sub_1000A7938((uint64_t)v18);
      }

      uint64_t v8 = v19;
      if (!v19) {
        uint64_t v8 = *(void *)(qword_1019A09E0 + 32);
      }
      if ((*(_BYTE *)(v8 + 32) & 2) == 0)
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F1A0);
        }
        unint64_t v9 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "ClusterAnchorValueStatistics has no data",  buf,  2u);
        }

        if (!sub_1002921D0(115, 0)) {
          return (void *)sub_1000A7938((uint64_t)v18);
        }
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 == -1) {
          goto LABEL_24;
        }
        goto LABEL_33;
      }

      sub_1000F4BE0(v2[12] + 496LL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      uint64_t v5 = (os_log_s *)qword_1019348D8;
      if (!os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT)) {
        return (void *)sub_1000A7938((uint64_t)v18);
      }
      unint64_t v6 = (char *)operator new(0x28uLL);
      *(void *)(v6 + 29) = 0LL;
      *(_OWORD *)unint64_t v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      sub_10000AE6C(v3, v6);
      *(_DWORD *)uint64_t buf = 68289282;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = v6;
      int v7 = "{msg%{public}.0s:ClusterAnchorValueStatistics loaded for model, ModelUUID:%{public, location:escape_only}s}";
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      uint64_t v5 = (os_log_s *)qword_1019348D8;
      if (!os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT)) {
        return (void *)sub_1000A7938((uint64_t)v18);
      }
      unint64_t v6 = (char *)operator new(0x28uLL);
      *(void *)(v6 + 29) = 0LL;
      *(_OWORD *)unint64_t v6 = 0u;
      *((_OWORD *)v6 + 1) = 0u;
      sub_10000AE6C(v3, v6);
      *(_DWORD *)uint64_t buf = 68289282;
      int v13 = 0;
      __int16 v14 = 2082;
      uint64_t v15 = "";
      __int16 v16 = 2082;
      uint64_t v17 = v6;
      int v7 = "{msg%{public}.0s:no AnchorValueStatistics for model, ModelUUID:%{public, location:escape_only}s}";
    }

    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v7, buf, 0x1Cu);
    operator delete(v6);
    return (void *)sub_1000A7938((uint64_t)v18);
  }

  return result;
}

void sub_1000F3430(_Unwind_Exception *a1)
{
}

void sub_1000F3478(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  if (v1 != 2)
  {
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3 && sub_100097CA8(v3) && **(_BYTE **)(a1 + 448))
    {
      *(void *)(a1 + 8++*(void *)(result + 8) = 0LL;
      if (v1) {
        sub_1000F5110(a1, v1);
      }
    }

    else
    {
      *(void *)(a1 + 8++*(void *)(result + 8) = 1LL;
      if (v1 != 1) {
        sub_1000F5258((int64x2_t *)a1, v1);
      }
    }
  }

void sub_1000F34FC(void *a1, int a2)
{
  if (*((_BYTE *)a1 + 457))
  {
    if (a2 && !a1[11])
    {
      uint64_t v6 = (uint64_t)(a1 + 1);
      (*(void (**)(void, void *))(*(void *)*a1 + 128LL))(*a1, a1 + 1);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      uint64_t v3 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = (char *)operator new(0x28uLL);
        *(_OWORD *)uint64_t v4 = 0u;
        *((_OWORD *)v4 + 1) = 0u;
        *(void *)(v4 + 29) = 0LL;
        sub_10000AE6C(v6, v4);
        int v7 = 68289283;
        int v8 = 0;
        __int16 v9 = 2082;
        uint64_t v10 = "";
        __int16 v11 = 2081;
        char v12 = v4;
        uint64_t v5 = "{msg%{public}.0s:Enabling Low Latency updates for Service:, ServiceId:%{private, location:escape_only}s}";
        goto LABEL_8;
      }
    }

    else
    {
      uint64_t v2 = (uint64_t)(a1 + 1);
      (*(void (**)(void, void *))(*(void *)*a1 + 136LL))(*a1, a1 + 1);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      uint64_t v3 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        uint64_t v4 = (char *)operator new(0x28uLL);
        *(_OWORD *)uint64_t v4 = 0u;
        *((_OWORD *)v4 + 1) = 0u;
        *(void *)(v4 + 29) = 0LL;
        sub_10000AE6C(v2, v4);
        int v7 = 68289283;
        int v8 = 0;
        __int16 v9 = 2082;
        uint64_t v10 = "";
        __int16 v11 = 2081;
        char v12 = v4;
        uint64_t v5 = "{msg%{public}.0s:Enabling Legacy updates for Service:, ServiceId:%{private, location:escape_only}s}";
LABEL_8:
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, v5, (uint8_t *)&v7, 0x1Cu);
        operator delete(v4);
      }
    }
  }

void sub_1000F36F8(_Unwind_Exception *a1)
{
}

void sub_1000F3710(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 457)) {
    sub_1000F34FC((void *)a1, 0);
  }
}

void sub_1000F3758(void *a1)
{
  uint64_t v1 = a1[12];
  if (v1)
  {
    if (*(_BYTE *)(v1 + 192))
    {
      uint64_t v3 = 176LL;
      if (!*(_BYTE *)(v1 + 184)) {
        uint64_t v3 = 488LL;
      }
      double v4 = *(double *)(v1 + v3);
      uint64_t v5 = *a1;
      *(_OWORD *)uint64_t buf = *(_OWORD *)(a1 + 1);
      uint64_t v6 = (char *)(a1 + 5);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, _BYTE *, void *, double))(*(void *)v5 + 112LL))( &v117,  v5,  buf,  a1 + 5,  v4);
      if (v117 == v118)
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F1A0);
        }
        uint64_t v56 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          *(void *)uint64_t buf = 68289026LL;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          _os_log_impl( (void *)&_mh_execute_header,  v56,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:applyRecentLabelsToLSL, no label entries for model}",  buf,  0x12u);
        }

        goto LABEL_186;
      }

      double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
      uint64_t v8 = a1[12];
      if (!*(_BYTE *)(v8 + 184)) {
        *(_BYTE *)(v8 + 184) = 1;
      }
      *(double *)(v8 + 176) = Current_1;
      uint64_t v102 = a1[12];
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      __int16 v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = (uint64_t)(*(void *)(v102 + 104) - *(void *)(v102 + 96)) >> 4;
        *(void *)uint64_t buf = 68289282LL;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v121 = 2050;
        uint64_t v122 = v10;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:applyRecentLabelsToLSL, number of LSL items, before update:%{public}lu}",  buf,  0x1Cu);
      }

      char v114 = 0LL;
      __int128 v115 = 0LL;
      __int128 v116 = 0LL;
      unsigned __int8 v111 = 0LL;
      __n128 v112 = 0LL;
      unsigned __int8 v113 = 0LL;
      uint64_t v11 = v117;
      uint64_t v12 = v118;
      int v13 = &OBJC_INSTANCE_METHODS_TRANSITPbTransitMacTile;
      char v101 = a1;
      if (v117 != v118)
      {
        do
        {
          uint64_t v15 = *(void **)(v102 + 96);
          __int16 v14 = *(void **)(v102 + 104);
          __int16 v16 = (void *)(v11 + 40);
          if (v15 != v14)
          {
            while (*v15 != *v16 || v15[1] != *(void *)(v11 + 48))
            {
              v15 += 2;
              if (v15 == v14)
              {
                uint64_t v15 = *(void **)(v102 + 104);
                break;
              }
            }
          }

          if (v15 == v14)
          {
            __int16 v28 = v115;
            if (v115 >= v116)
            {
              uint64_t v30 = (v115 - (_BYTE *)v114) >> 4;
              unint64_t v31 = v30 + 1;
              uint64_t v32 = v116 - (_BYTE *)v114;
              if ((v116 - (_BYTE *)v114) >> 3 > v31) {
                unint64_t v31 = v32 >> 3;
              }
              else {
                unint64_t v33 = v31;
              }
              if (v33) {
                uint64_t v34 = (char *)sub_100037038((uint64_t)&v116, v33);
              }
              else {
                uint64_t v34 = 0LL;
              }
              __int16 v35 = &v34[16 * v30];
              *(_OWORD *)__int16 v35 = *(_OWORD *)v16;
              __int16 v37 = (char *)v114;
              uint64_t v36 = v115;
              BOOL v38 = v35;
              if (v115 != v114)
              {
                do
                {
                  *((_OWORD *)v38 - 1) = *((_OWORD *)v36 - 1);
                  v38 -= 16;
                  v36 -= 16;
                }

                while (v36 != v37);
                uint64_t v36 = (char *)v114;
              }

              char v29 = v35 + 16;
              char v114 = v38;
              __int128 v115 = v35 + 16;
              __int128 v116 = &v34[16 * v33];
              if (v36) {
                operator delete(v36);
              }
            }

            else
            {
              *(_OWORD *)__int128 v115 = *(_OWORD *)v16;
              char v29 = v28 + 16;
            }

            __int128 v115 = v29;
            __int16 v39 = v112;
            if (v112 >= v113)
            {
              uint64_t v41 = (v112 - (_BYTE *)v111) >> 4;
              unint64_t v42 = v41 + 1;
              if ((unint64_t)(v41 + 1) >> 60) {
LABEL_188:
              }
                sub_100007008();
              uint64_t v43 = v113 - (_BYTE *)v111;
              if ((v113 - (_BYTE *)v111) >> 3 > v42) {
                unint64_t v42 = v43 >> 3;
              }
              else {
                unint64_t v44 = v42;
              }
              if (v44) {
                uint64_t v45 = (char *)sub_100037038((uint64_t)&v113, v44);
              }
              else {
                uint64_t v45 = 0LL;
              }
              __int128 v46 = &v45[16 * v41];
              *(_OWORD *)__int128 v46 = *(_OWORD *)v11;
              __int128 v48 = (char *)v111;
              uint64_t v47 = v112;
              uint64_t v49 = v46;
              if (v112 != v111)
              {
                do
                {
                  *((_OWORD *)v49 - 1) = *((_OWORD *)v47 - 1);
                  v49 -= 16;
                  v47 -= 16;
                }

                while (v47 != v48);
                uint64_t v47 = (char *)v111;
              }

              BOOL v40 = v46 + 16;
              unsigned __int8 v111 = v49;
              __n128 v112 = v46 + 16;
              unsigned __int8 v113 = &v45[16 * v44];
              if (v47) {
                operator delete(v47);
              }
            }

            else
            {
              *(_OWORD *)__n128 v112 = *(_OWORD *)v11;
              BOOL v40 = v39 + 16;
            }

            __n128 v112 = v40;
          }

          else
          {
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181F1A0);
            }
            uint64_t v18 = (os_log_s *)qword_1019348D8;
            if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
            {
              uint64_t v19 = (char *)operator new(0x28uLL);
              *(void *)uint64_t v129 = v19;
              *(_OWORD *)&v129[8] = xmmword_1012C8460;
              *(_OWORD *)uint64_t v19 = 0u;
              *((_OWORD *)v19 + 1) = 0u;
              *(void *)(v19 + 29) = 0LL;
              sub_10000AE6C(v11 + 40, v19);
              if (v129[23] >= 0) {
                char v20 = v129;
              }
              else {
                char v20 = *(_BYTE **)v129;
              }
              char v21 = operator new(0x28uLL);
              std::string __p = v21;
              __int128 v110 = xmmword_1012C8460;
              *char v21 = 0u;
              v21[1] = 0u;
              *(void *)((char *)v21 + 29) = 0LL;
              sub_10000AE6C(v11, v21);
              if (v110 >= 0) {
                p_p = (char *)&__p;
              }
              else {
                p_p = (char *)__p;
              }
              *(void *)uint64_t buf = 68289538LL;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = "";
              __int16 v121 = 2082;
              uint64_t v122 = (uint64_t)v20;
              __int16 v123 = 2082;
              uint64_t v124 = p_p;
              _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CLMiLoService::applyRecentLabelsToLSL, tried to apply a label which is already in the LSL, LabelUUID:%{public, location:escape_only}s, TriggerUUID:%{public, location:escape_only}s}",  buf,  0x26u);
              if (SHIBYTE(v110) < 0) {
                operator delete(__p);
              }
              if ((v129[23] & 0x80000000) != 0) {
                operator delete(*(void **)v129);
              }
              if (qword_1019348D0 != -1) {
                dispatch_once(&qword_1019348D0, &stru_10181F1A0);
              }
            }

            char v23 = (os_log_s *)qword_1019348D8;
            if (os_signpost_enabled((os_log_t)qword_1019348D8))
            {
              __int16 v24 = (char *)operator new(0x28uLL);
              *(void *)uint64_t v129 = v24;
              *(_OWORD *)&v129[8] = xmmword_1012C8460;
              *(_OWORD *)__int16 v24 = 0u;
              *((_OWORD *)v24 + 1) = 0u;
              *(void *)(v24 + 29) = 0LL;
              sub_10000AE6C(v11 + 40, v24);
              if (v129[23] >= 0) {
                char v25 = v129;
              }
              else {
                char v25 = *(_BYTE **)v129;
              }
              __int16 v26 = operator new(0x28uLL);
              std::string __p = v26;
              __int128 v110 = xmmword_1012C8460;
              *__int16 v26 = 0u;
              v26[1] = 0u;
              *(void *)((char *)v26 + 29) = 0LL;
              sub_10000AE6C(v11, v26);
              if (v110 >= 0) {
                uint64_t v27 = (char *)&__p;
              }
              else {
                uint64_t v27 = (char *)__p;
              }
              *(void *)uint64_t buf = 68289538LL;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = "";
              __int16 v121 = 2082;
              uint64_t v122 = (uint64_t)v25;
              __int16 v123 = 2082;
              uint64_t v124 = v27;
              _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v23,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CLMiLoService::applyRecentLabelsToLSL, tried to apply a label which is already in the LSL",  "{msg%{public}.0s:CLMiLoService::applyRecentLabelsToLSL, tried to apply a label which is already in the LSL, LabelUUID:%{public, location:escape_only}s, TriggerUUID:%{public, location:escape_only}s}",  buf,  0x26u);
              if (SHIBYTE(v110) < 0) {
                operator delete(__p);
              }
              if ((v129[23] & 0x80000000) != 0) {
                operator delete(*(void **)v129);
              }
            }
          }

          v11 += 64LL;
        }

        while (v11 != v12);
        uint64_t v11 = v117;
        uint64_t v55 = v118;
        uint64_t v6 = (char *)(a1 + 5);
        if (v118 == v117)
        {
          int v13 = &OBJC_INSTANCE_METHODS_TRANSITPbTransitMacTile;
        }

        else
        {
          int v13 = &OBJC_INSTANCE_METHODS_TRANSITPbTransitMacTile;
          do
          {
            v55 -= 64LL;
          }

          while (v55 != v11);
        }
      }

      uint64_t v118 = v11;
      sub_1000F8A08(&v117);
      if (v115 == v114)
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F1A0);
        }
        char v97 = (os_log_s *)qword_1019348D8;
        if (!os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_180;
        }
        *(_OWORD *)uint64_t v129 = *(_OWORD *)(a1 + 1);
        std::string v98 = (char *)operator new(0x28uLL);
        *(void *)(v98 + 29) = 0LL;
        *(_OWORD *)std::string v98 = 0u;
        *((_OWORD *)v98 + 1) = 0u;
        sub_10000AE6C((uint64_t)v129, v98);
        *(void *)uint64_t buf = 68289539LL;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v121 = 2081;
        uint64_t v122 = (uint64_t)v6;
        __int16 v123 = 2081;
        uint64_t v124 = v98;
        _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:applyRecentLabelsToLSL, no labels from database to apply to LSL, ClientID:%{priva te, location:escape_only}s, ClientUUID:%{private, location:escape_only}s}",  buf,  0x26u);
        operator delete(v98);
      }

      else
      {
        (*(void (**)(_BYTE *__return_ptr, void, void **))(*(void *)*a1 + 104LL))(v129, *a1, &v111);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F1A0);
        }
        __int16 v57 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v59 = v114;
          int v58 = v115;
          *(_OWORD *)__n128 v119 = *(_OWORD *)(a1 + 1);
          char v60 = operator new(0x28uLL);
          std::string __p = v60;
          __int128 v103 = *(_OWORD *)&v13[140].entrysize;
          __int128 v110 = v103;
          _OWORD *v60 = 0u;
          v60[1] = 0u;
          *(void *)((char *)v60 + 29) = 0LL;
          sub_10000AE6C((uint64_t)v119, v60);
          if (v110 >= 0) {
            __int16 v61 = &__p;
          }
          else {
            __int16 v61 = __p;
          }
          uint64_t v62 = a1[12];
          __int128 v63 = operator new(0x28uLL);
          char v107 = v63;
          __int128 v108 = v103;
          *__int128 v63 = 0u;
          v63[1] = 0u;
          *(void *)((char *)v63 + 29) = 0LL;
          sub_10000AE6C(v62 + 352, v63);
          char v64 = &v107;
          if (v108 < 0) {
            char v64 = v107;
          }
          *(_DWORD *)uint64_t buf = 68290051;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = "";
          __int16 v121 = 2050;
          uint64_t v122 = (v58 - v59) >> 4;
          __int16 v123 = 2081;
          uint64_t v124 = v6;
          __int16 v125 = 2081;
          int64_t v126 = v61;
          __int16 v127 = 2081;
          uint64_t v128 = v64;
          _os_log_impl( (void *)&_mh_execute_header,  v57,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:applyRecentLabelsToLSL, found labels from database to apply to LSL, NumLabels:% {public}lu, ClientID:%{private, location:escape_only}s, ClientUUID:%{private, location:escape_only}s , ModelUUID:%{private, location:escape_only}s}",  buf,  0x3Au);
          if (SHIBYTE(v108) < 0) {
            operator delete(v107);
          }
          if (SHIBYTE(v110) < 0) {
            operator delete(__p);
          }
        }

        std::string __p = 0LL;
        __int128 v110 = 0uLL;
        char v107 = 0LL;
        __int128 v108 = 0uLL;
        sub_1002F0B04(buf);
        CFStringRef v65 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsSimilarityListMaxNumberOfItems",  0x8000100u,  kCFAllocatorNull);
        int v66 = sub_1002A7D20(*(uint64_t *)buf, (uint64_t)v65, v119);
        CFRelease(v65);
        unsigned int v67 = *(_DWORD *)v119;
        __int128 v68 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8])
        {
          __int128 v69 = (unint64_t *)(*(void *)&buf[8] + 8LL);
          do
            unint64_t v70 = __ldaxr(v69);
          while (__stlxr(v70 - 1, v69));
          if (!v70)
          {
            ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
            std::__shared_weak_count::__release_weak(v68);
          }
        }

        if (v66) {
          unsigned int v71 = v67;
        }
        else {
          unsigned int v71 = 1000;
        }
        __int16 v72 = (char *)v114;
        if (v115 != v114)
        {
          uint64_t v73 = 0LL;
          unsigned int v74 = 0;
          unsigned int v75 = 0;
          __int128 v104 = *(_OWORD *)&v13[140].entrysize;
          while (1)
          {
            char v76 = (char *)v111 + 16 * v73;
            __int16 v77 = sub_10001A7B8(v129, v76);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181F1A0);
            }
            int v78 = &v72[16 * v73];
            __int16 v79 = (os_log_s *)qword_1019348D8;
            if (!os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_144;
            }
            std::string v80 = (char *)operator new(0x28uLL);
            *(void *)__n128 v119 = v80;
            *(_OWORD *)&v119[8] = v104;
            *(_OWORD *)std::string v80 = 0u;
            *((_OWORD *)v80 + 1) = 0u;
            *(void *)(v80 + 29) = 0LL;
            sub_10000AE6C((uint64_t)v78, v80);
            if (v119[23] >= 0) {
              std::string v81 = v119;
            }
            else {
              std::string v81 = *(_BYTE **)v119;
            }
            char v82 = operator new(0x28uLL);
            uint64_t v105 = v82;
            __int128 v106 = v104;
            *char v82 = 0u;
            v82[1] = 0u;
            *(void *)((char *)v82 + 29) = 0LL;
            sub_10000AE6C((uint64_t)v76, v82);
            int v83 = (char *)&v105;
            if (v106 < 0) {
              int v83 = (char *)v105;
            }
            *(void *)uint64_t buf = 68289795LL;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = "";
            __int16 v121 = 2081;
            uint64_t v122 = (uint64_t)v81;
            __int16 v123 = 2081;
            uint64_t v124 = v83;
            __int16 v125 = 1026;
            LODWORD(v126) = v77 != 0LL;
            _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:applyRecentLabelsToLSL, per label info, LabelUUID:%{private, location:escape_ only}s, TriggerUUID:%{private, location:escape_only}s, validFingerprint:%{public}hhd}",  buf,  0x2Cu);
            if (SHIBYTE(v106) < 0) {
              operator delete(v105);
            }
            if ((v119[23] & 0x80000000) != 0)
            {
              operator delete(*(void **)v119);
              if (v77)
              {
LABEL_145:
                uint64_t v84 = v110;
                if ((unint64_t)v110 >= *((void *)&v110 + 1))
                {
                  uint64_t v85 = sub_10001DCCC((uint64_t *)&__p, (uint64_t)(v77 + 4));
                }

                else
                {
                  sub_10001DDD8((uint64_t)&v110 + 8, v110, (uint64_t)(v77 + 4));
                  uint64_t v85 = v84 + 192;
                }

                *(void *)&__int128 v110 = v85;
                uint64_t v86 = v108;
                if ((unint64_t)v108 >= *((void *)&v108 + 1))
                {
                  uint64_t v88 = (uint64_t)(v108 - (void)v107) >> 4;
                  unint64_t v89 = v88 + 1;
                  uint64_t v90 = *((void *)&v108 + 1) - (void)v107;
                  else {
                    unint64_t v91 = v89;
                  }
                  if (v91) {
                    uint64_t v92 = (char *)sub_100037038((uint64_t)&v108 + 8, v91);
                  }
                  else {
                    uint64_t v92 = 0LL;
                  }
                  int v93 = &v92[16 * v88];
                  *(_OWORD *)int v93 = *(_OWORD *)v78;
                  uint64_t v95 = (char *)v107;
                  __int128 v94 = (char *)v108;
                  std::string v96 = v93;
                  if ((void *)v108 != v107)
                  {
                    do
                    {
                      *((_OWORD *)v96 - 1) = *((_OWORD *)v94 - 1);
                      v96 -= 16;
                      v94 -= 16;
                    }

                    while (v94 != v95);
                    __int128 v94 = (char *)v107;
                  }

                  std::string v87 = v93 + 16;
                  char v107 = v96;
                  *(void *)&__int128 v108 = v93 + 16;
                  *((void *)&v108 + 1) = &v92[16 * v91];
                  if (v94) {
                    operator delete(v94);
                  }
                }

                else
                {
                  *(_OWORD *)__int128 v108 = *(_OWORD *)v78;
                  std::string v87 = (_OWORD *)(v86 + 16);
                }

                *(void *)&__int128 v108 = v87;
                ++v74;
              }
            }

            else
            {
LABEL_144:
              if (v77) {
                goto LABEL_145;
              }
            }

            if (v74 < v71)
            {
              __int16 v72 = (char *)v114;
              uint64_t v73 = ++v75;
            }

            break;
          }
        }

        sub_100099DF4(v101[12] + 72LL, v101[12], &__p, (uint64_t *)&v107);
        if (v107)
        {
          *(void *)&__int128 v108 = v107;
          operator delete(v107);
        }

        *(void *)uint64_t buf = &__p;
        sub_10001D978((void ***)buf);
        sub_1000615C0((uint64_t)v129);
      }

      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
LABEL_180:
      __int16 v99 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v100 = (uint64_t)(*(void *)(v102 + 104) - *(void *)(v102 + 96)) >> 4;
        *(void *)uint64_t buf = 68289282LL;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v121 = 2050;
        uint64_t v122 = v100;
        _os_log_impl( (void *)&_mh_execute_header,  v99,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:applyRecentLabelsToLSL, number of LSL items, after update:%{public}lu}",  buf,  0x1Cu);
      }

      if (v111)
      {
        __n128 v112 = (char *)v111;
        operator delete(v111);
      }

      if (v114)
      {
        __int128 v115 = (char *)v114;
        operator delete(v114);
      }

void sub_1000F47F8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, void *__p, uint64_t a32, uint64_t a33, void *a34, uint64_t a35, uint64_t a36, char a37, uint64_t a38, uint64_t a39, void *a40, uint64_t a41, int a42, __int16 a43, char a44, char a45)
{
  if (__p) {
    operator delete(__p);
  }
  if (a34) {
    operator delete(a34);
  }
  *(void *)(v46 - 144) = &a37;
  sub_100012948((void ***)(v46 - 144));
  _Unwind_Resume(a1);
}

uint64_t sub_1000F4970(int a1, int a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  double v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t buf = 68289538;
    int v13 = 0;
    __int16 v14 = 2082;
    uint64_t v15 = "";
    __int16 v16 = 1026;
    int v17 = a1;
    __int16 v18 = 1026;
    int v19 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:internalToExternalServiceQuality, qualityLevel:%{public}d, candidateQualityLevel:%{public}d}",  buf,  0x1Eu);
  }

  if (a1 == 3)
  {
    uint64_t v5 = 29LL;
    if (a2 != 3) {
      uint64_t v5 = 30LL;
    }
    BOOL v6 = a2 == 1;
    uint64_t v7 = 28LL;
    goto LABEL_13;
  }

  if (a1 == 1)
  {
    uint64_t v5 = 9LL;
    if (a2 != 3) {
      uint64_t v5 = 10LL;
    }
    BOOL v6 = a2 == 1;
    uint64_t v7 = 8LL;
LABEL_13:
    if (v6) {
      return v7;
    }
    else {
      return v5;
    }
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  __int16 v9 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Service Quality is invalid", buf, 2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    v11[0] = 0;
    uint64_t v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Service Quality is invalid",  v11,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static CLMiLoServiceQuality CLMiLoService::internalToExternalServiceQuality(CLMicroLocationProto::Model_ModelQuali tyLevel, CLMicroLocationProto::Model_ModelQualityLevel)",  "%s\n",  v10);
  }

  return 0LL;
}

uint64_t sub_1000F4BE0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40)) {
    *(_BYTE *)(sub_1000A8728(a1) + 40) = 0;
  }
  uint64_t result = sub_10014D46C();
  *(_BYTE *)(result + 40) = 1;
  return result;
}

uint64_t sub_1000F4C1C(uint64_t a1, uint64_t a2)
{
  if (a1 == 1) {
    return 0LL;
  }
  if (a1 != 4) {
    sub_10122BEE8();
  }
  if (a2 == 2) {
    return 3LL;
  }
  else {
    return 2LL;
  }
}

uint64_t sub_1000F4C64(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 - 1;
  uint64_t result = 4LL;
  switch(v2)
  {
    case 0LL:
      goto LABEL_12;
    case 1LL:
      return result;
    case 2LL:
      uint64_t result = 3LL;
      break;
    case 3LL:
      if (a2 == 2)
      {
        uint64_t result = 5LL;
      }

      else
      {
LABEL_12:
        int v6 = sub_1000F500C();
        uint64_t result = sub_1000F4E70(v6);
      }

      break;
    default:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      double v4 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Get generation algorithm: Unknown service type",  buf,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F1A0);
        }
        v8[0] = 0;
        uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Get generation algorithm: Unknown service type",  v8,  2);
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "static CLMicroLocationProto::Model_GenerationAlgorithm CLMiLoService::generationAlgorithmByServiceAndLocationT ype(CLMiLoServiceType, CLMiLoLocationTypeEnum)",  "%s\n",  v7);
      }

      int v5 = sub_1000F500C();
      uint64_t result = sub_1000F4E70(v5);
      break;
  }

  return result;
}

uint64_t sub_1000F4E70(int a1)
{
  if (a1 == 1) {
    return 2LL;
  }
  if (a1)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    uint64_t v1 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_ERROR,  "Get generation algorithm: Unknown learner type",  buf,  2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      v4[0] = 0;
      uint64_t v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Get generation algorithm: Unknown learner type",  v4,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "auto CLMiLoService::generationAlgorithmByServiceAndLocationType(CLMiLoServiceType, CLMiLoLocationTypeEnum)::(ano nymous class)::operator()(CLMicroLocationAlgorithms::LearnerType) const",  "%s\n",  v3);
    }
  }

  return 1LL;
}

uint64_t sub_1000F500C()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsLearnerAlgorithm", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  unsigned int v2 = v7;
  uint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void sub_1000F50C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

BOOL sub_1000F50E0(uint64_t a1)
{
  return *(void *)(a1 + 96) && *(void *)(a1 + 88) != 2LL && **(_BYTE **)(a1 + 448) != 0;
}

void sub_1000F5110(uint64_t a1, int a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  double v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)unint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(void *)(v5 + 29) = 0LL;
    sub_10000AE6C(a1 + 8, v5);
    v6[0] = 68289538;
    v6[1] = 0;
    __int16 v7 = 2082;
    uint64_t v8 = "";
    __int16 v9 = 2082;
    uint64_t v10 = v5;
    __int16 v11 = 1026;
    int v12 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService state changed to running: , ServiceId:%{public, location:escape_only}s, Previous state:%{public}u}",  (uint8_t *)v6,  0x22u);
    operator delete(v5);
  }

  *(void *)(a1 + 8++*(void *)(result + 8) = 0LL;
}

void sub_1000F5244(_Unwind_Exception *a1)
{
}

void sub_1000F5258(int64x2_t *a1, int a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  double v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)unint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(void *)(v5 + 29) = 0LL;
    sub_10000AE6C((uint64_t)&a1->i64[1], v5);
    v6[0] = 68289538;
    v6[1] = 0;
    __int16 v7 = 2082;
    uint64_t v8 = "";
    __int16 v9 = 2082;
    uint64_t v10 = v5;
    __int16 v11 = 1026;
    int v12 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService state changed to suspended: , ServiceId:%{public, location:escape_only} s, Previous state:%{public}u}",  (uint8_t *)v6,  0x22u);
    operator delete(v5);
  }

  sub_1000F53AC(a1);
}

void sub_1000F5390(_Unwind_Exception *a1)
{
}

void sub_1000F53AC(int64x2_t *a1)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  memset(v3, 0, sizeof(v3));
  double v4 = (uint64_t *)v5;
  int v6 = 2;
  int v2 = 2;
  sub_10004A8FC(&v4, &v2, &v2);
  sub_1000F57A8(a1, (uint64_t)v3);
  sub_100008390((uint64_t)&v4, v5[0]);
}

void sub_1000F5424( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void sub_1000F5440(uint64_t *a1, void *a2, _OWORD *a3)
{
  unint64_t v4 = a1[3];
  if (v4 >= 4)
  {
    if (v4 == 4)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      __int16 v11 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = (char *)operator new(0x28uLL);
        *(_OWORD *)int v12 = 0u;
        *((_OWORD *)v12 + 1) = 0u;
        *(void *)(v12 + 29) = 0LL;
        sub_10000AE6C((uint64_t)a2, v12);
        int v13 = (char *)operator new(0x28uLL);
        *(void *)(v13 + 29) = 0LL;
        *(_OWORD *)int v13 = 0u;
        *((_OWORD *)v13 + 1) = 0u;
        sub_10000AE6C((uint64_t)a3, v13);
        int v14 = 68289538;
        int v15 = 0;
        __int16 v16 = 2082;
        int v17 = "";
        __int16 v18 = 2082;
        int v19 = v12;
        __int16 v20 = 2082;
        char v21 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:adding a label to the LSL out of learning flow, Trigger UUID:%{public, location:e scape_only}s, Label UUID:%{public, location:escape_only}s}",  (uint8_t *)&v14,  0x26u);
        operator delete(v13);
        operator delete(v12);
      }

      sub_1000F75E4(a1, a2, a3);
    }

    else if (v4 == 5)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      __int16 v7 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        int v14 = 68289026;
        int v15 = 0;
        __int16 v16 = 2082;
        int v17 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:should not call addNewTruthLabelToModelIfAppropriate with CLMiLoServiceTypeMax}",  (uint8_t *)&v14,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F1A0);
        }
      }

      uint64_t v8 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        int v14 = 68289026;
        int v15 = 0;
        __int16 v16 = 2082;
        int v17 = "";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v8,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "should not call addNewTruthLabelToModelIfAppropriate with CLMiLoServiceTypeMax",  "{msg%{public}.0s:should not call addNewTruthLabelToModelIfAppropriate with CLMiLoServiceTypeMax}",  (uint8_t *)&v14,  0x12u);
      }
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    unint64_t v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      int v6 = (char *)*((unsigned int *)a1 + 6);
      int v14 = 68289282;
      int v15 = 0;
      __int16 v16 = 2082;
      int v17 = "";
      __int16 v18 = 2050;
      int v19 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:not adding new truth label out of learning flow, ServiceType:%{public}lu}",  (uint8_t *)&v14,  0x1Cu);
    }
  }

void sub_1000F5778(_Unwind_Exception *a1)
{
}

void sub_1000F57A8(void *a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 48);
  if (v2) {
    uint64_t v3 = 12LL;
  }
  else {
    uint64_t v3 = -1LL;
  }
  if (a1[52])
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    int v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v7 = (char *)operator new(0x28uLL);
      *(_OWORD *)__int16 v7 = 0u;
      *((_OWORD *)v7 + 1) = 0u;
      *(void *)(v7 + 29) = 0LL;
      sub_10000AE6C((uint64_t)(a1 + 1), v7);
      BOOL v8 = a1[52] != 0LL;
      *(_DWORD *)uint64_t buf = 68289794;
      int v11 = 0;
      __int16 v12 = 2082;
      int v13 = "";
      __int16 v14 = 2082;
      int v15 = v7;
      __int16 v16 = 1026;
      BOOL v17 = v8;
      __int16 v18 = 1026;
      BOOL v19 = v2 == 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService releasing observation requsts: , ServiceId:%{public, location:escape_ only}s, NumRequests:%{public}hhd, Success:%{public}hhd}",  buf,  0x28u);
      operator delete(v7);
    }

    while (a1[52])
    {
      unint64_t v9 = *(void *)(a1[48] + 8 * (a1[51] / 0x7CuLL)) + 33 * (a1[51] % 0x7CuLL);
      if (!v2)
      {
        if (*(_BYTE *)(v9 + 32)) {
          sub_1000F5440( a1,  (void *)(*(void *)(a1[48] + 8 * (a1[51] / 0x7CuLL)) + 33 * (a1[51] % 0x7CuLL)),  (_OWORD *)(v9 + 16));
        }
      }

      (*(void (**)(void, void *, unint64_t, uint64_t))(*(void *)*a1 + 40LL))(*a1, a1 + 1, v9, v3);
      (*(void (**)(void, void *, unint64_t, uint64_t))(*(void *)*a1 + 48LL))(*a1, a1 + 1, v9, a2);
      *(int64x2_t *)(a1 + 51) = vaddq_s64(*(int64x2_t *)(a1 + 51), (int64x2_t)xmmword_1012CE4D0);
      sub_1000F8BA8((uint64_t)(a1 + 47), 1);
    }
  }

void sub_1000F59EC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F5A08(uint64_t *a1, _OWORD *a2, uint64_t a3, int a4)
{
  BOOL v8 = (a4 & 1) != 0 || *((_BYTE *)a1 + 296) == 0;
  if (sub_1000F1EB0())
  {
    int v9 = *((unsigned __int8 *)a1 + 457);
    if (*((_BYTE *)a1 + 457)) {
      int v9 = *((unsigned __int8 *)a1 + 456);
    }
    v8 |= v9;
  }

  if (a1[11]) {
    goto LABEL_9;
  }
  if (!*((_BYTE *)a1 + 368))
  {
    uint64_t v23 = *a1;
    v25[0] = 0;
    v25[16] = 0;
    (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t *, _OWORD *, _BYTE *, uint64_t, BOOL))(*(void *)v23 + 16LL))( __p,  v23,  a1 + 5,  a2,  v25,  a3,  v8);
    if (__p[17])
    {
      sub_1000F0FC8((char *)a1, a2);
    }

    else
    {
      if (!__p[16])
      {
LABEL_9:
        uint64_t v10 = 0LL;
        goto LABEL_10;
      }

      int v24 = *((unsigned __int8 *)a1 + 368);
      *((_OWORD *)a1 + 22) = *(_OWORD *)__p;
      if (!v24) {
        *((_BYTE *)a1 + 36++*(void *)(result + 8) = 1;
      }
      *(_OWORD *)char v25 = *a2;
      v25[16] = 0;
      BYTE2(v29) = 0;
      sub_1000F8C74(a1 + 38, (uint64_t)v25);
    }

    uint64_t v10 = 1LL;
LABEL_10:
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    goto LABEL_12;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  __int16 v16 = (os_log_s *)qword_1019348D8;
  uint64_t v10 = 0LL;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    if (*((_BYTE *)a1 + 368))
    {
      BOOL v17 = (char *)operator new(0x28uLL);
      *(void *)std::string __p = v17;
      *(_OWORD *)&__p[8] = xmmword_1012C8460;
      *(_OWORD *)BOOL v17 = 0u;
      *((_OWORD *)v17 + 1) = 0u;
      *(void *)(v17 + 29) = 0LL;
      sub_10000AE6C((uint64_t)(a1 + 44), v17);
      __int16 v18 = __p;
      if (__p[23] < 0) {
        __int16 v18 = *(const char **)__p;
      }
      *(void *)char v25 = 68289282LL;
      *(_WORD *)&v25[8] = 2082;
      *(void *)&_BYTE v25[10] = "";
      __int16 v26 = 2082;
      uint64_t v27 = v18;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService reject prediction request because other request in progress, Localizati onId:%{public, location:escape_only}s}",  v25,  0x1Cu);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
    }

    else
    {
      *(void *)char v25 = 68289282LL;
      *(_WORD *)&v25[8] = 2082;
      *(void *)&_BYTE v25[10] = "";
      __int16 v26 = 2082;
      uint64_t v27 = "None";
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService reject prediction request because other request in progress, Localizati onId:%{public, location:escape_only}s}",  v25,  0x1Cu);
    }

    goto LABEL_9;
  }

void sub_1000F5E34(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F5E84(uint64_t *a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  if (!a1[12] || a1[11] == 2 || !*(_BYTE *)a1[56])
  {
    uint64_t v10 = 0LL;
    goto LABEL_8;
  }

  BOOL v8 = (const void *)*a1;
  __int128 v26 = *(_OWORD *)(a1 + 1);
  sub_100060440((const void **)a1 + 5, (uint64_t)&v26, (std::string *)__p);
  uint64_t v9 = (*(uint64_t (**)(const void *, _BYTE *, _OWORD *, uint64_t, uint64_t))(*(void *)v8 + 24LL))( v8,  __p,  a2,  a3,  a4);
  uint64_t v10 = v9;
  if ((__p[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__p);
    if (!(_DWORD)v10) {
      goto LABEL_8;
    }
  }

  else if (!(_DWORD)v9)
  {
    goto LABEL_8;
  }

  __int128 v18 = *(_OWORD *)a3;
  *(_OWORD *)std::string __p = *a2;
  *(_OWORD *)&__p[16] = v18;
  __p[32] = *(_BYTE *)(a3 + 16);
  sub_1000F8C74(a1 + 47, (uint64_t)__p);
  uint64_t v10 = 1LL;
LABEL_8:
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  int v11 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v12 = (char *)operator new(0x28uLL);
    *(void *)(v12 + 29) = 0LL;
    *(_OWORD *)__int16 v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    sub_10000AE6C((uint64_t)(a1 + 1), v12);
    int v13 = (char *)operator new(0x28uLL);
    *(void *)(v13 + 29) = 0LL;
    *(_OWORD *)int v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    sub_10000AE6C((uint64_t)a2, v13);
    if (*(_BYTE *)(a3 + 16))
    {
      int v14 = (char *)operator new(0x28uLL);
      *(void *)(v14 + 29) = 0LL;
      *(_OWORD *)int v14 = 0u;
      *((_OWORD *)v14 + 1) = 0u;
      sub_10000AE6C(a3, v14);
      uint64_t v15 = a1[11];
      *(void *)std::string __p = 68290306LL;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&_BYTE __p[10] = "";
      *(_WORD *)&_BYTE __p[18] = 2082;
      *(void *)&__p[20] = v12;
      *(_WORD *)&_BYTE __p[28] = 2082;
      *(void *)&__p[30] = v13;
      __int16 v20 = 2082;
      int v21 = v14;
      __int16 v22 = 1026;
      int v23 = v15;
      __int16 v24 = 1026;
      int v25 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService received observation request: , ServiceId:%{public, location:escape_o nly}s, RequestId:%{public, location:escape_only}s, PlaceId:%{public, location:escape_only}s, State:% {public}u, Success:%{public}hhd}",  __p,  0x3Cu);
      operator delete(v14);
    }

    else
    {
      uint64_t v16 = a1[11];
      *(void *)std::string __p = 68290306LL;
      *(_WORD *)&__p[8] = 2082;
      *(void *)&_BYTE __p[10] = "";
      *(_WORD *)&_BYTE __p[18] = 2082;
      *(void *)&__p[20] = v12;
      *(_WORD *)&_BYTE __p[28] = 2082;
      *(void *)&__p[30] = v13;
      __int16 v20 = 2082;
      int v21 = "None";
      __int16 v22 = 1026;
      int v23 = v16;
      __int16 v24 = 1026;
      int v25 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService received observation request: , ServiceId:%{public, location:escape_o nly}s, RequestId:%{public, location:escape_only}s, PlaceId:%{public, location:escape_only}s, State:% {public}u, Success:%{public}hhd}",  __p,  0x3Cu);
    }

    operator delete(v13);
    operator delete(v12);
  }

  return v10;
}

void sub_1000F616C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F61C4(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  __int128 v2 = *(_OWORD *)(a1 + 8);
  sub_100060440((const void **)(a1 + 40), (uint64_t)&v2, a2);
}

void sub_1000F6220(void *a1, uint64_t a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  unint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v5 = (char *)operator new(0x28uLL);
    *(_OWORD *)unint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    *(void *)(v5 + 29) = 0LL;
    sub_10000AE6C((uint64_t)(a1 + 1), v5);
    BOOL v6 = *(_DWORD *)(a2 + 48) == 0;
    v7[0] = 68289538;
    v7[1] = 0;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 2082;
    int v11 = v5;
    __int16 v12 = 1026;
    BOOL v13 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService received recording stop: , ServiceId:%{public, location:escape_only}s, Success:%{public}hhd}",  (uint8_t *)v7,  0x22u);
    operator delete(v5);
  }

  sub_1000F57A8(a1, a2);
}

void sub_1000F6368(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F6384@<X0>(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t *a3@<X8>)
{
  a3[1] = 0LL;
  BOOL v6 = (void **)(a3 + 1);
  a3[2] = 0LL;
  a3[3] = 0LL;
  a3[7] = 0LL;
  *((_BYTE *)a3 + 64) = 0;
  *((_BYTE *)a3 + 6++*(void *)(result + 8) = 0;
  uint64_t v8 = *(void *)(a1 + 88);
  __int16 v7 = *(void **)(a1 + 96);
  *a3 = v8;
  *((_OWORD *)a3 + 5) = 0u;
  uint64_t v9 = (void **)(a3 + 10);
  *((_BYTE *)a3 + 152) = 0;
  *((_OWORD *)a3 + 6) = 0u;
  *((_OWORD *)a3 + 7) = 0u;
  *((_BYTE *)a3 + 12++*(void *)(result + 8) = 0;
  *(_OWORD *)((char *)a3 + 164) = 0u;
  *(_OWORD *)((char *)a3 + 180) = 0u;
  *((_DWORD *)a3 + 49) = 0;
  if (!v7)
  {
    uint64_t v15 = sub_1000071BC((uint64_t)(a3 + 3), 1uLL);
    uint64_t v16 = (char *)a3[1];
    BOOL v17 = (char *)a3[2];
    int v19 = &v15[v18];
    void *v15 = 0LL;
    int v14 = v15 + 1;
    while (v17 != v16)
    {
      uint64_t v20 = *((void *)v17 - 1);
      v17 -= 8;
      *--uint64_t v15 = v20;
    }

    a3[1] = (uint64_t)v15;
    a3[2] = (uint64_t)v14;
    a3[3] = (uint64_t)v19;
    if (!v16) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  sub_100097BC8(v7, (uint64_t)buf);
  __int16 v10 = (void *)a3[13];
  if (v10)
  {
    a3[14] = (uint64_t)v10;
    operator delete(v10);
    a3[13] = 0LL;
    a3[14] = 0LL;
    a3[15] = 0LL;
  }

  *(_OWORD *)(a3 + 13) = *(_OWORD *)buf;
  a3[15] = *(void *)&buf[16];
  uint64_t v11 = *(void *)(a1 + 96);
  if (!v11 || !sub_100097CA8(v11))
  {
    unint64_t v12 = a3[3];
    BOOL v13 = (char *)a3[2];
    if ((unint64_t)v13 < v12)
    {
      *(void *)BOOL v13 = 1LL;
      int v14 = v13 + 8;
LABEL_13:
      a3[2] = (uint64_t)v14;
      goto LABEL_14;
    }

    uint64_t v16 = (char *)*v6;
    uint64_t v25 = (v13 - (_BYTE *)*v6) >> 3;
    unint64_t v26 = v25 + 1;
    uint64_t v27 = v12 - (void)v16;
    if (v27 >> 2 > v26) {
      unint64_t v26 = v27 >> 2;
    }
    else {
      unint64_t v28 = v26;
    }
    if (v28)
    {
      char v29 = (char *)sub_1000071BC((uint64_t)(a3 + 3), v28);
      uint64_t v16 = (char *)a3[1];
      BOOL v13 = (char *)a3[2];
    }

    else
    {
      char v29 = 0LL;
    }

    __int16 v36 = &v29[8 * v25];
    int v37 = &v29[8 * v28];
    *(void *)__int16 v36 = 1LL;
    int v14 = v36 + 8;
    while (v13 != v16)
    {
      uint64_t v38 = *((void *)v13 - 1);
      v13 -= 8;
      *((void *)v36 - 1) = v38;
      v36 -= 8;
    }

    a3[1] = (uint64_t)v36;
    a3[2] = (uint64_t)v14;
    a3[3] = (uint64_t)v37;
    if (!v16) {
      goto LABEL_13;
    }
LABEL_12:
    operator delete(v16);
    goto LABEL_13;
  }

void sub_1000F6FC0(_Unwind_Exception *a1)
{
}

void *sub_1000F7124@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, (&off_10181F1E0)[a1]);
}

void *sub_1000F7138@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, (&off_10181F208)[a1]);
}

void *sub_1000F714C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v4 = "Home";
  unint64_t v5 = "Custom";
  if (a1 != 2) {
    unint64_t v5 = "Other";
  }
  if (a1) {
    unint64_t v4 = "Work";
  }
  if (a1 <= 1) {
    BOOL v6 = (char *)v4;
  }
  else {
    BOOL v6 = (char *)v5;
  }
  return sub_1010DDBC0(a2, v6);
}

void *sub_1000F7190@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v4 = "Low";
  unint64_t v5 = "HighCandidateHigh";
  if (a1 != 29) {
    unint64_t v5 = "High";
  }
  BOOL v6 = "Medium";
  if (a1 != 20) {
    BOOL v6 = "HighCandidateLow";
  }
  if (a1 <= 28) {
    unint64_t v5 = v6;
  }
  if (a1 == 9) {
    unint64_t v4 = "LowCandidateHigh";
  }
  __int16 v7 = "Invalid";
  if (a1) {
    __int16 v7 = "LowCandidateLow";
  }
  if (a1 <= 8) {
    unint64_t v4 = v7;
  }
  if (a1 <= 19) {
    uint64_t v8 = (char *)v4;
  }
  else {
    uint64_t v8 = (char *)v5;
  }
  return sub_1010DDBC0(a2, v8);
}

void *sub_1000F7214(void *a1)
{
  __int128 v2 = (void *)a1[13];
  if (v2)
  {
    a1[14] = v2;
    operator delete(v2);
  }

  uint64_t v3 = (void *)a1[10];
  if (v3)
  {
    a1[11] = v3;
    operator delete(v3);
  }

  unint64_t v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }

  return a1;
}

void sub_1000F7264(void *a1, _OWORD *a2)
{
  if (__p)
  {
    uint64_t v9 = __p;
    operator delete(__p);
  }

  if (v6)
  {
    __int16 v7 = v6;
    operator delete(v6);
  }

  if (v4)
  {
    unint64_t v5 = v4;
    operator delete(v4);
  }

void sub_1000F7300( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000F731C(void *a1, void *a2, void *a3)
{
  if ((unint64_t)(a1[3] - 2LL) <= 2 && a1[12] && a1[11] != 2LL && *(_BYTE *)a1[56])
  {
    uint64_t v6 = *a1;
    __int128 v30 = *(_OWORD *)(a1 + 1);
    sub_100060440((const void **)a1 + 5, (uint64_t)&v30, (std::string *)&__p);
    int v7 = (*(uint64_t (**)(uint64_t, void **, void, void, void, void))(*(void *)v6 + 72LL))( v6,  &__p,  *a2,  a2[1],  *a3,  a3[1]);
    int v8 = v7;
    if (SBYTE3(v21) < 0)
    {
      operator delete(__p);
      if (v8) {
        goto LABEL_7;
      }
    }

    else if (v7)
    {
LABEL_7:
      sub_1000F5440(a1, a2, a3);
      int v9 = 1;
      goto LABEL_10;
    }
  }

  int v9 = 0;
LABEL_10:
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  __int16 v10 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = (char *)operator new(0x28uLL);
    *(void *)(v11 + 29) = 0LL;
    *(_OWORD *)uint64_t v11 = 0u;
    *((_OWORD *)v11 + 1) = 0u;
    sub_10000AE6C((uint64_t)(a1 + 1), v11);
    unint64_t v12 = (char *)operator new(0x28uLL);
    *(void *)(v12 + 29) = 0LL;
    *(_OWORD *)unint64_t v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    sub_10000AE6C((uint64_t)a2, v12);
    BOOL v13 = (char *)operator new(0x28uLL);
    *(void *)(v13 + 29) = 0LL;
    *(_OWORD *)BOOL v13 = 0u;
    *((_OWORD *)v13 + 1) = 0u;
    sub_10000AE6C((uint64_t)a3, v13);
    uint64_t v14 = a1[11];
    std::string __p = (void *)68290306;
    __int16 v18 = 2082;
    int v19 = "";
    __int16 v20 = 2082;
    unint64_t v21 = v11;
    __int16 v22 = 2082;
    int v23 = v12;
    __int16 v24 = 2082;
    uint64_t v25 = v13;
    __int16 v26 = 1026;
    int v27 = v14;
    __int16 v28 = 1026;
    int v29 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService label observation request: , ServiceId:%{public, location:escape_only}s , RequestId:%{public, location:escape_only}s, PlaceId:%{public, location:escape_only}s, State:%{public }u, Success:%{public}hhd}",  (uint8_t *)&__p,  0x3Cu);
    operator delete(v13);
    operator delete(v12);
    operator delete(v11);
  }

  if (v9) {
    uint64_t v15 = -1LL;
  }
  else {
    uint64_t v15 = 13LL;
  }
  return (*(uint64_t (**)(void, void *, void *, uint64_t))(*(void *)*a1 + 40LL))(*a1, a1 + 1, a2, v15);
}

void sub_1000F758C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F75E4(uint64_t *a1, void *a2, _OWORD *a3)
{
  if (*((_BYTE *)a1 + 368))
  {
    if (a1[44] == *a2 && a1[45] == a2[1])
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      int v7 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = operator new(0x28uLL);
        std::string __p = v8;
        __int128 v39 = xmmword_1012C8460;
        *int v8 = 0u;
        v8[1] = 0u;
        *(void *)((char *)v8 + 29) = 0LL;
        sub_10000AE6C((uint64_t)a2, v8);
        p_p = &__p;
        if (v39 < 0) {
          p_p = __p;
        }
        *(_DWORD *)uint64_t buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v45 = 2082;
        *(void *)&void v45[2] = "";
        *(_WORD *)&v45[10] = 2082;
        *(void *)&v45[12] = p_p;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:Attempting to apply truth label for a currently running localization, TriggerUUID :%{public, location:escape_only}s}",  buf,  0x1Cu);
        if (SHIBYTE(v39) < 0) {
          operator delete(__p);
        }
      }
    }
  }

  uint64_t v10 = a1[12];
  if (v10)
  {
    if (*(_BYTE *)(v10 + 192))
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      uint64_t v11 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v12 = operator new(0x28uLL);
        std::string __p = v12;
        __int128 v39 = xmmword_1012C8460;
        _OWORD *v12 = 0u;
        v12[1] = 0u;
        *(void *)((char *)v12 + 29) = 0LL;
        sub_10000AE6C((uint64_t)(a1 + 1), v12);
        if (v39 >= 0) {
          BOOL v13 = &__p;
        }
        else {
          BOOL v13 = __p;
        }
        uint64_t v14 = operator new(0x28uLL);
        __int16 v42 = v14;
        __int128 v43 = xmmword_1012C8460;
        _OWORD *v14 = 0u;
        v14[1] = 0u;
        *(void *)((char *)v14 + 29) = 0LL;
        sub_10000AE6C((uint64_t)a2, v14);
        if (v43 >= 0) {
          uint64_t v15 = (char *)&v42;
        }
        else {
          uint64_t v15 = (char *)v42;
        }
        uint64_t v16 = operator new(0x28uLL);
        __int16 v40 = v16;
        __int128 v41 = xmmword_1012C8460;
        _OWORD *v16 = 0u;
        v16[1] = 0u;
        *(void *)((char *)v16 + 29) = 0LL;
        sub_10000AE6C((uint64_t)a3, v16);
        BOOL v17 = &v40;
        if (v41 < 0) {
          BOOL v17 = v40;
        }
        *(_DWORD *)uint64_t buf = 68289795;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v45 = 2082;
        *(void *)&void v45[2] = "";
        *(_WORD *)&v45[10] = 2081;
        *(void *)&v45[12] = v13;
        __int16 v46 = 2082;
        unint64_t v47 = v15;
        __int16 v48 = 2082;
        *(void *)&__int128 v49 = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:service is appending an event to similarity list, ServiceUUID:%{private, location :escape_only}s, TriggerUUID:%{public, location:escape_only}s, LabelUUID:%{public, location:escape_only}s}",  buf,  0x30u);
        if (SHIBYTE(v41) < 0) {
          operator delete(v40);
        }
        if (SHIBYTE(v43) < 0) {
          operator delete(v42);
        }
        if (SHIBYTE(v39) < 0) {
          operator delete(__p);
        }
      }

      uint64_t v18 = *a1;
      int v19 = operator new(0x10uLL);
      *(void *)uint64_t buf = v19;
      *(void *)&v45[8] = v19 + 1;
      *int v19 = *(_OWORD *)a2;
      *(void *)unint64_t v45 = v19 + 1;
      (*(void (**)(void **__return_ptr, uint64_t, uint8_t *))(*(void *)v18 + 104LL))(&__p, v18, buf);
      if (*(void *)buf)
      {
        *(void *)unint64_t v45 = *(void *)buf;
        operator delete(*(void **)buf);
      }

      __int16 v20 = sub_10001A7B8(&__p, a2);
      unint64_t v21 = v20;
      if (v20)
      {
        uint64_t v22 = a1[12];
        sub_10001AD40((uint64_t)buf, (uint64_t)(v20 + 4));
        __int128 v49 = *(_OWORD *)(v21 + 9);
        uint64_t v50 = v21[11];
        sub_10001B204((uint64_t)v51, (uint64_t)(v21 + 12));
        sub_10001B494((uint64_t)v52, (uint64_t)(v21 + 17));
        *(_OWORD *)&v52[40] = *((_OWORD *)v21 + 11);
        int v53 = *((_DWORD *)v21 + 48);
        uint64_t v55 = 0LL;
        uint64_t v56 = 0LL;
        __int128 v54 = 0LL;
        sub_10001B72C(&v54, (const void *)v21[25], v21[26], (uint64_t)(v21[26] - v21[25]) >> 2);
        __int16 v42 = 0LL;
        __int128 v43 = 0uLL;
        __int16 v40 = &v42;
        LOBYTE(v41) = 0;
        __int16 v42 = operator new(0xC0uLL);
        *(void *)&__int128 v43 = v42;
        *((void *)&v43 + 1) = (char *)v42 + 192;
        *(void *)&__int128 v43 = sub_1000F9148((uint64_t)&v43 + 8, (uint64_t)buf, (uint64_t)&v57, (uint64_t)v42);
        int v23 = operator new(0x10uLL);
        *(void *)&__int128 v41 = v23 + 1;
        *((void *)&v41 + 1) = v23 + 1;
        *int v23 = *a3;
        __int16 v40 = v23;
        sub_100099DF4(v22 + 72, v22, &v42, (uint64_t *)&v40);
        if (v40)
        {
          *(void *)&__int128 v41 = v40;
          operator delete(v40);
        }

        __int16 v40 = &v42;
        sub_10001D978((void ***)&v40);
        if (v54)
        {
          uint64_t v55 = v54;
          operator delete(v54);
        }

        sub_100019CEC((uint64_t)v52);
        sub_100019CEC((uint64_t)v51);
        sub_10001AA60((uint64_t)buf);
      }

      else
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F1A0);
        }
        unint64_t v34 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v35 = (char *)operator new(0x28uLL);
          *(void *)(v35 + 29) = 0LL;
          *(_OWORD *)BOOL v35 = 0u;
          *((_OWORD *)v35 + 1) = 0u;
          sub_10000AE6C((uint64_t)(a1 + 1), v35);
          __int16 v36 = (char *)operator new(0x28uLL);
          *(void *)(v36 + 29) = 0LL;
          *(_OWORD *)__int16 v36 = 0u;
          *((_OWORD *)v36 + 1) = 0u;
          sub_10000AE6C((uint64_t)a2, v36);
          int v37 = (char *)operator new(0x28uLL);
          *(void *)(v37 + 29) = 0LL;
          *(_OWORD *)int v37 = 0u;
          *((_OWORD *)v37 + 1) = 0u;
          sub_10000AE6C((uint64_t)a3, v37);
          *(_DWORD *)uint64_t buf = 68289795;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)unint64_t v45 = 2082;
          *(void *)&void v45[2] = "";
          *(_WORD *)&v45[10] = 2081;
          *(void *)&v45[12] = v35;
          __int16 v46 = 2082;
          unint64_t v47 = v36;
          __int16 v48 = 2082;
          *(void *)&__int128 v49 = v37;
          _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:event not appended to similarity list, fingerprint not created!, ServiceUUID:%{ private, location:escape_only}s, TriggerUUID:%{public, location:escape_only}s, LabelUUID:%{public, l ocation:escape_only}s}",  buf,  0x30u);
          operator delete(v37);
          operator delete(v36);
          operator delete(v35);
        }
      }

      sub_1000615C0((uint64_t)&__p);
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
      __int16 v26 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        int v27 = (char *)operator new(0x28uLL);
        *(void *)(v27 + 29) = 0LL;
        *(_OWORD *)int v27 = 0u;
        *((_OWORD *)v27 + 1) = 0u;
        sub_10000AE6C((uint64_t)(a1 + 1), v27);
        uint64_t v28 = a1[12];
        int v29 = (char *)operator new(0x28uLL);
        *(void *)(v29 + 29) = 0LL;
        *(_OWORD *)int v29 = 0u;
        *((_OWORD *)v29 + 1) = 0u;
        sub_10000AE6C(v28 + 352, v29);
        *(_DWORD *)uint64_t buf = 68289539;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v45 = 2082;
        *(void *)&void v45[2] = "";
        *(_WORD *)&v45[10] = 2081;
        *(void *)&v45[12] = v27;
        __int16 v46 = 2081;
        unint64_t v47 = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:when appending event to similarity list, model has no similarity list!, ServiceUUID :%{private, location:escape_only}s, ModelUUID:%{private, location:escape_only}s}",  buf,  0x26u);
        operator delete(v29);
        operator delete(v27);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F1A0);
        }
      }

      __int128 v30 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        uint64_t v31 = (char *)operator new(0x28uLL);
        *(void *)(v31 + 29) = 0LL;
        *(_OWORD *)uint64_t v31 = 0u;
        *((_OWORD *)v31 + 1) = 0u;
        sub_10000AE6C((uint64_t)(a1 + 1), v31);
        uint64_t v32 = a1[12];
        uint64_t v33 = (char *)operator new(0x28uLL);
        *(void *)(v33 + 29) = 0LL;
        *(_OWORD *)uint64_t v33 = 0u;
        *((_OWORD *)v33 + 1) = 0u;
        sub_10000AE6C(v32 + 352, v33);
        *(_DWORD *)uint64_t buf = 68289539;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)unint64_t v45 = 2082;
        *(void *)&void v45[2] = "";
        *(_WORD *)&v45[10] = 2081;
        *(void *)&v45[12] = v31;
        __int16 v46 = 2081;
        unint64_t v47 = v33;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v30,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "when appending event to similarity list, model has no similarity list!",  "{msg%{public}.0s:when appending event to similarity list, model has no similarity list!, ServiceUUID :%{private, location:escape_only}s, ModelUUID:%{private, location:escape_only}s}",  buf,  0x26u);
        operator delete(v33);
        operator delete(v31);
      }
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    __int16 v24 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)unint64_t v45 = 2082;
      *(void *)&void v45[2] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:when appending event to similarity list, service has no current model!}",  buf,  0x12u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F1A0);
      }
    }

    uint64_t v25 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)uint64_t buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)unint64_t v45 = 2082;
      *(void *)&void v45[2] = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v25,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "when appending event to similarity list, service has no current model!",  "{msg%{public}.0s:when appending event to similarity list, service has no current model!}",  buf,  0x12u);
    }
  }

void sub_1000F7EF0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, uint64_t a30)
{
}

uint64_t sub_1000F806C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a1[3];
  if ((unint64_t)(v8 - 2) > 2
    || !a1[12]
    || a1[11] == 2LL
    || ((v8 & 0xFFFFFFFFFFFFFFFELL) == 2 ? (BOOL v9 = *(_BYTE *)a1[56] == 0) : (BOOL v9 = 1), v9))
  {
    int v10 = 0;
  }

  else
  {
    unint64_t v21 = (const void *)*a1;
    __int128 v38 = *(_OWORD *)(a1 + 1);
    sub_100060440((const void **)a1 + 5, (uint64_t)&v38, (std::string *)&__p);
    int v22 = (*(uint64_t (**)(const void *, void **, uint64_t, uint64_t, uint64_t))(*(void *)v21 + 80LL))( v21,  &__p,  a3,  a4,  a5);
    int v10 = v22;
    if (SBYTE3(v27) < 0) {
      operator delete(__p);
    }
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  uint64_t v11 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v12 = (char *)operator new(0x28uLL);
    *(void *)(v12 + 29) = 0LL;
    *(_OWORD *)unint64_t v12 = 0u;
    *((_OWORD *)v12 + 1) = 0u;
    sub_10000AE6C((uint64_t)(a1 + 1), v12);
    uint64_t v13 = *((unsigned int *)a1 + 6);
    uint64_t v14 = (char *)operator new(0x28uLL);
    *(void *)(v14 + 29) = 0LL;
    *(_OWORD *)uint64_t v14 = 0u;
    *((_OWORD *)v14 + 1) = 0u;
    sub_10000AE6C(a2, v14);
    uint64_t v15 = (char *)operator new(0x28uLL);
    *(void *)(v15 + 29) = 0LL;
    *(_OWORD *)uint64_t v15 = 0u;
    *((_OWORD *)v15 + 1) = 0u;
    sub_10000AE6C(a3, v15);
    uint64_t v16 = a1[11];
    std::string __p = (void *)68290562;
    __int16 v24 = 2082;
    uint64_t v25 = "";
    __int16 v26 = 2082;
    int v27 = v12;
    __int16 v28 = 2050;
    uint64_t v29 = v13;
    __int16 v30 = 2082;
    uint64_t v31 = v14;
    __int16 v32 = 2082;
    uint64_t v33 = v15;
    __int16 v34 = 1026;
    int v35 = v16;
    __int16 v36 = 1026;
    int v37 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService label observation request Between dates: , ServiceId:%{public, location :escape_only}s, ServiceType:%{public}lu, RequestId:%{public, location:escape_only}s, PlaceId:%{public, location:escape_only}s, State:%{public}u, Success:%{public}hhd}",  (uint8_t *)&__p,  0x46u);
    operator delete(v15);
    operator delete(v14);
    operator delete(v12);
  }

  if (v10) {
    uint64_t v17 = -1LL;
  }
  else {
    uint64_t v17 = 14LL;
  }
  return (*(uint64_t (**)(void, void *, uint64_t, uint64_t))(*(void *)*a1 + 40LL))(*a1, a1 + 1, a2, v17);
}

void sub_1000F82F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000F8348(void *a1, int a2)
{
  if (!*((_BYTE *)a1 + 457)) {
    *((_BYTE *)a1 + 457) = 1;
  }
  *((_BYTE *)a1 + 456) = a2;
  sub_1000F34FC(a1, a2);
}

void sub_1000F8360(_BYTE *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 8);
  (*(void (**)(void, _BYTE *))(**(void **)a1 + 136LL))(*(void *)a1, a1 + 8);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  uint64_t v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
  {
    unint64_t v4 = (char *)operator new(0x28uLL);
    *(_OWORD *)unint64_t v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    *(void *)(v4 + 29) = 0LL;
    sub_10000AE6C(v2, v4);
    v5[0] = 68289283;
    v5[1] = 0;
    __int16 v6 = 2082;
    int v7 = "";
    __int16 v8 = 2081;
    BOOL v9 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Disabling Low Latency updates if exist for Service:, ServiceId:%{private, location:escape_only}s}",  (uint8_t *)v5,  0x1Cu);
    operator delete(v4);
  }

  if (a1[457]) {
    a1[457] = 0;
  }
}

void sub_1000F849C(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F84B0(uint64_t a1)
{
  int v1 = *(void **)a1;
  uint64_t v2 = *(void **)(a1 + 8);
  if (*(void **)a1 == v2) {
    return 0LL;
  }
  uint64_t result = 0LL;
  do
  {
    if (*v1 >= 0x20uLL) {
      sub_10000C918("bitset set argument out of range");
    }
    result |= 1LL << *v1++;
  }

  while (v1 != v2);
  return result;
}

uint64_t sub_1000F850C(void *a1, _OWORD *a2)
{
  if (*((_BYTE *)a1 + 440))
  {
    uint64_t v4 = 31LL;
    (*(void (**)(void))(*(void *)*a1 + 40LL))();
  }

  else
  {
    uint64_t v4 = -1LL;
  }

  unint64_t v5 = a1[11];
  if (v5 >= 2)
  {
    if (v5 == 2)
    {
      uint64_t v4 = 6LL;
      (*(void (**)(void, void *, _OWORD *, uint64_t))(*(void *)*a1 + 40LL))(*a1, a1 + 1, a2, 6LL);
    }

    uint64_t v7 = 0LL;
  }

  else
  {
    int v6 = *((unsigned __int8 *)a1 + 440);
    *(_OWORD *)(a1 + 53) = *a2;
    if (!v6) {
      *((_BYTE *)a1 + 440) = 1;
    }
    (*(void (**)(void))(*(void *)*a1 + 96LL))(*a1);
    uint64_t v7 = 1LL;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  __int16 v8 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v9 = (char *)operator new(0x28uLL);
    *(_OWORD *)BOOL v9 = 0u;
    *((_OWORD *)v9 + 1) = 0u;
    *(void *)(v9 + 29) = 0LL;
    sub_10000AE6C((uint64_t)a2, v9);
    uint64_t v10 = a1[11];
    v12[0] = 68290050;
    v12[1] = 0;
    __int16 v13 = 2082;
    uint64_t v14 = "";
    __int16 v15 = 2082;
    uint64_t v16 = v9;
    __int16 v17 = 1026;
    int v18 = v7;
    __int16 v19 = 1026;
    int v20 = v10;
    __int16 v21 = 2050;
    uint64_t v22 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService::requestMicroLocationLearning, RequestId:%{public, location:escape_only }s, Will Start:%{public}hhd, State:%{public}u, Error Code:%{public}ld}",  (uint8_t *)v12,  0x32u);
    operator delete(v9);
  }

  return v7;
}

void sub_1000F86EC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000F8700(uint64_t result)
{
  if (*(_BYTE *)(result + 440))
  {
    int v1 = (_BYTE *)result;
    uint64_t v2 = result + 424;
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F1A0);
    }
    uint64_t v3 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      if (!v1[440]) {
        sub_100036CD8();
      }
      uint64_t v4 = (char *)operator new(0x28uLL);
      *(_OWORD *)uint64_t v4 = 0u;
      *((_OWORD *)v4 + 1) = 0u;
      *(void *)(v4 + 29) = 0LL;
      sub_10000AE6C(v2, v4);
      v5[0] = 68289538;
      v5[1] = 0;
      __int16 v6 = 2082;
      uint64_t v7 = "";
      __int16 v8 = 2082;
      BOOL v9 = v4;
      __int16 v10 = 2050;
      uint64_t v11 = -1LL;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService::onLearningCompleted send completion to client, RequestId:%{public, l ocation:escape_only}s, Error Code:%{public}ld}",  (uint8_t *)v5,  0x26u);
      operator delete(v4);
    }

    if (!v1[440]) {
      sub_100036CD8();
    }
    uint64_t result = (*(uint64_t (**)(void, _BYTE *, uint64_t, uint64_t))(**(void **)v1 + 40LL))( *(void *)v1,  v1 + 8,  v2,  -1LL);
    if (v1[440]) {
      v1[440] = 0;
    }
  }

  return result;
}

void sub_1000F8874(_Unwind_Exception *a1)
{
}

void sub_1000F8890(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v9[0] = a2;
  v9[1] = a3;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F1A0);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    std::string __p = (void *)68289026;
    LOWORD(v++*(void *)(result + 8) = 2082;
    *(void *)((char *)&v8 + 2) = "";
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:CLMiLoService::onLocalizationStart send event to client}",  (uint8_t *)&__p,  0x12u);
  }

  uint64_t v5 = *a1;
  __int16 v6 = operator new(0x28uLL);
  std::string __p = v6;
  __int128 v8 = xmmword_1012C8460;
  _OWORD *v6 = 0u;
  v6[1] = 0u;
  *(void *)((char *)v6 + 29) = 0LL;
  sub_10000AE6C((uint64_t)v9, v6);
  (*(void (**)(uint64_t, uint64_t *, void, void **))(*(void *)v5 + 56LL))(v5, a1 + 1, 0LL, &__p);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p);
  }
}

void sub_1000F89D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000F8A08(uint64_t *a1)
{
  uint64_t v3 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v6 = (v5 - *a1) >> 6;
  if (v6 < (v3 - *a1) >> 6)
  {
    uint64_t v13 = result;
    if (v5 == v4)
    {
      uint64_t v7 = 0LL;
      uint64_t v8 = 0LL;
    }

    else
    {
      uint64_t v7 = (char *)sub_10001275C(result, v6);
    }

    BOOL v9 = v7;
    __int16 v10 = &v7[64 * v6];
    uint64_t v11 = v10;
    unint64_t v12 = &v7[64 * v8];
    sub_1000126E8(a1, &v9);
    return sub_1000128C0((uint64_t)&v9);
  }

  return result;
}

void sub_1000F8A8C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

void sub_1000F8AB4(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_1000F8AE0(id a1)
{
  qword_1019348E8 = (uint64_t)os_log_create("com.apple.locationd.Position", "MicrolocationQE");
}

__n128 sub_1000F8B0C(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(_BYTE *)(a1 + 24))
    {
      __n128 result = *a2;
      *(void *)(a1 + 16) = a2[1].n128_u64[0];
      *(__n128 *)a1 = result;
      a2[1].n128_u8[7] = 0;
      a2->n128_u8[0] = 0;
    }
  }

  else if (*(_BYTE *)(a1 + 24))
  {
    *(_BYTE *)(a1 + 24) = 0;
  }

  else
  {
    __n128 result = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    *(__n128 *)a1 = result;
    a2->n128_u64[1] = 0LL;
    a2[1].n128_u64[0] = 0LL;
    a2->n128_u64[0] = 0LL;
    *(_BYTE *)(a1 + 24) = 1;
  }

  return result;
}

uint64_t sub_1000F8BA8(uint64_t a1, int a2)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2 < 0x7C) {
    a2 = 1;
  }
  if (v2 < 0xF8) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 124LL;
  }

  return v4 ^ 1u;
}

void sub_1000F8C04(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 184))
  {
    unint64_t v2 = *(void **)(a1 + 144);
    if (v2)
    {
      *(void *)(a1 + 152) = v2;
      operator delete(v2);
    }

    if (*(_BYTE *)(a1 + 128)) {
      sub_10004AD90(a1 + 88);
    }
    uint64_t v3 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + ++*(void *)(result + 8) = v3;
      operator delete(v3);
    }

    *(_BYTE *)(a1 + 184) = 0;
  }

__n128 sub_1000F8C74(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 124 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_1000F8D2C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x7C)) + 33 * (v7 % 0x7C);
  __n128 result = *(__n128 *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 16);
  *(_BYTE *)(v8 + 32) = *(_BYTE *)(a2 + 32);
  *(__n128 *)unint64_t v8 = result;
  *(_OWORD *)(v8 + 16) = v10;
  ++a1[5];
  return result;
}

void sub_1000F8D2C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x7C;
  unint64_t v4 = v2 - 124;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    unint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    BOOL v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      __int16 v34 = (char *)sub_1000071BC(v5, v33);
      int v35 = &v34[8 * (v33 >> 2)];
      int v37 = &v34[8 * v36];
      __int128 v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        __int128 v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)__int128 v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_1000F8FF4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

char *sub_1000F9040(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  BOOL v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0LL;
      *unint64_t v7 = 0LL;
      v7[1] = 0LL;
      _DWORD v7[2] = 0LL;
    }

    if (a4 >> 61) {
      sub_100007008();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = sub_10000717C(v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    BOOL v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      __int16 v19 = __src;
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  uint64_t v12 = (void **)(result + 8);
  BOOL v14 = (_BYTE *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    BOOL v9 = (char *)*v12;
  }

  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    __int16 v19 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v18, v19, v17);
  }

uint64_t sub_1000F9148(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v11 = a4;
  uint64_t v12 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  void v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      sub_10001DDD8(a1, v4, v6);
      v6 += 192LL;
      uint64_t v4 = v12 + 192;
      v12 += 192LL;
    }

    while (v6 != a3);
  }

  char v10 = 1;
  sub_1000F91F0((uint64_t)v9);
  return v4;
}

void sub_1000F91DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1000F91F0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1000F9224((uint64_t *)a1);
  }
  return a1;
}

uint64_t *sub_1000F9224(uint64_t *result)
{
  unint64_t v2 = (uint64_t *)result[1];
  int v1 = (uint64_t *)result[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *result;
    do
    {
      v3 -= 192LL;
      __n128 result = (uint64_t *)sub_10001A9E0(v5, v3);
    }

    while (v3 != v4);
  }

  return result;
}

BOOL sub_1000F9274(os_log_s *a1)
{
  return os_log_type_enabled(a1, OS_LOG_TYPE_FAULT);
}

void sub_1000F927C(uint64_t a1@<X8>)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_101934ED0);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_101934ED0))
  {
    sub_100100530((std::string *)&xmmword_101934EB8);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_101934EB8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101934ED0);
  }

  if (byte_101934ECF < 0)
  {
    sub_1010DD48C((_BYTE *)a1, (void *)xmmword_101934EB8, *((unint64_t *)&xmmword_101934EB8 + 1));
  }

  else
  {
    *(_OWORD *)a1 = xmmword_101934EB8;
    *(void *)(a1 + 16) = unk_101934EC8;
  }

void sub_1000F932C(_Unwind_Exception *a1)
{
}

void sub_1000F9344(uint64_t a1@<X8>)
{
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)&qword_101934EF0);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_101934EF0))
  {
    sub_100100A1C((std::string *)&xmmword_101934ED8);
    __cxa_atexit((void (*)(void *))&std::string::~string, &xmmword_101934ED8, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_101934EF0);
  }

  if (byte_101934EEF < 0)
  {
    sub_1010DD48C((_BYTE *)a1, (void *)xmmword_101934ED8, *((unint64_t *)&xmmword_101934ED8 + 1));
  }

  else
  {
    *(_OWORD *)a1 = xmmword_101934ED8;
    *(void *)(a1 + 16) = unk_101934EE8;
  }

void sub_1000F93F4(_Unwind_Exception *a1)
{
}

void sub_1000F940C(uint64_t *a1)
{
  BOOL v2 = sub_1003C1048(*a1);
  *((_BYTE *)a1 + ++*(void *)(result + 8) = v2;
  if (v2)
  {
    sub_1000F98E4(a1);
    sub_1003B59A0(*a1, "MiLoServices", (const char **)&off_10181F288, 0LL, 0);
    char v3 = sub_1003B747C(*a1, "MiLoServices");
    *((_BYTE *)a1 + ++*(void *)(result + 8) = v3;
    if ((v3 & 1) != 0)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      uint64_t v4 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)uint64_t buf = 136315138;
        uint64_t v12 = "MiLoServices";
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "Sucessfully created table if necessary: %s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F268);
        }
        uint64_t v5 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Sucessfully created table if necessary: %s",  &v9);
LABEL_19:
        unint64_t v7 = (uint8_t *)v5;
        sub_10029211C("Generic", 1LL, 0, 2LL, "void CLMiLoServiceTable::initTable()", "%s\n");
LABEL_29:
        if (v7 != buf) {
          free(v7);
        }
      }
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      uint64_t v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t buf = 136446210;
        uint64_t v12 = "MiLoServices";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "Failed to create table: %{public}s",  buf,  0xCu);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F268);
        }
        int v9 = 136446210;
        char v10 = "MiLoServices";
        unint64_t v7 = (uint8_t *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Failed to create table: %{public}s",  &v9,  12);
        sub_10029211C("Generic", 1LL, 0, 0LL, "void CLMiLoServiceTable::initTable()", "%s\n");
        goto LABEL_29;
      }
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F268);
    }
    uint64_t v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Database is not connected so we can't intialize our table",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      uint64_t v5 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "Database is not connected so we can't intialize our table");
      goto LABEL_19;
    }
  }

uint64_t sub_1000F9800(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(_BYTE *)(a1 + ++*(void *)(result + 8) = 0;
  sub_1000F940C((uint64_t *)a1);
  return a1;
}

uint64_t sub_1000F982C( uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, __int128 *a5, uint64_t a6, __int128 *a7, double a8)
{
  *(void *)a1 = a4;
  *(void *)(a1 + ++*(void *)(result + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(double *)(a1 + 24) = a8;
  if (*((char *)a5 + 23) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 32), *(void **)a5, *((void *)a5 + 1));
  }

  else
  {
    __int128 v11 = *a5;
    *(void *)(a1 + sub_10000AE14(v17 - 48) = *((void *)a5 + 2);
    *(_OWORD *)(a1 + 32) = v11;
  }

  *(void *)(a1 + 56) = a6;
  uint64_t v12 = (_BYTE *)(a1 + 64);
  if (*((char *)a7 + 23) < 0)
  {
    sub_1010DD48C(v12, *(void **)a7, *((void *)a7 + 1));
  }

  else
  {
    __int128 v13 = *a7;
    *(void *)(a1 + 80) = *((void *)a7 + 2);
    *(_OWORD *)uint64_t v12 = v13;
  }

  return a1;
}

void sub_1000F98C4(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1000F98E4(uint64_t *a1)
{
  uint64_t result = sub_1003B747C(*a1, "MiLoServices");
  if ((_DWORD)result) {
    return sub_10000C98C(*a1, (uint64_t)&off_10181F288, 7LL, "MiLoServices");
  }
  return result;
}

void sub_1000F9938(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, std::string *a4@<X8>)
{
  v48.__r_.__value_.__s.__size_ = 15;
  strcpy((char *)&v48, "SELECT * FROM (");
  char v47 = 7;
  strcpy(__s, "SELECT ");
  uint64_t v8 = std::string::append(&v48, __s, 7uLL);
  __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v49.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0LL;
  v8->__r_.__value_.__l.__cap_ = 0LL;
  v8->__r_.__value_.__r.__words[0] = 0LL;
  sub_1000F927C((uint64_t)__p);
  if ((v45 & 0x80u) == 0) {
    char v10 = __p;
  }
  else {
    char v10 = (void **)__p[0];
  }
  if ((v45 & 0x80u) == 0) {
    std::string::size_type v11 = v45;
  }
  else {
    std::string::size_type v11 = (std::string::size_type)__p[1];
  }
  uint64_t v12 = std::string::append(&v49, (const std::string::value_type *)v10, v11);
  __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  v50.__r_.__value_.__l.__cap_ = v12->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0LL;
  v12->__r_.__value_.__l.__cap_ = 0LL;
  v12->__r_.__value_.__r.__words[0] = 0LL;
  BOOL v14 = std::string::append(&v50, " FROM ");
  __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v51.__r_.__value_.__l.__cap_ = v14->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0LL;
  v14->__r_.__value_.__l.__cap_ = 0LL;
  v14->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v16 = std::string::append(&v51, "MiLoServices");
  __int128 v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v52.__r_.__value_.__l.__cap_ = v16->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0LL;
  v16->__r_.__value_.__l.__cap_ = 0LL;
  v16->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v18 = std::string::append(&v52, " ");
  __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v57.__r_.__value_.__l.__cap_ = v18->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0LL;
  v18->__r_.__value_.__l.__cap_ = 0LL;
  v18->__r_.__value_.__r.__words[0] = 0LL;
  int v20 = *(char *)(a2 + 23);
  if (v20 >= 0) {
    uint64_t v21 = (const std::string::value_type *)a2;
  }
  else {
    uint64_t v21 = *(const std::string::value_type **)a2;
  }
  if (v20 >= 0) {
    std::string::size_type v22 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v22 = *(void *)(a2 + 8);
  }
  uint64_t v23 = std::string::append(&v57, v21, v22);
  __int128 v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v58.__r_.__value_.__l.__cap_ = v23->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v58.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0LL;
  v23->__r_.__value_.__l.__cap_ = 0LL;
  v23->__r_.__value_.__r.__words[0] = 0LL;
  char v43 = 7;
  strcpy(v42, " LIMIT ");
  unint64_t v25 = std::string::append(&v58, v42, 7uLL);
  __int128 v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v53.__r_.__value_.__l.__cap_ = v25->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v26;
  v25->__r_.__value_.__l.__size_ = 0LL;
  v25->__r_.__value_.__l.__cap_ = 0LL;
  v25->__r_.__value_.__r.__words[0] = 0LL;
  std::to_string(&v41, a3);
  if ((v41.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int v27 = &v41;
  }
  else {
    int v27 = (std::string *)v41.__r_.__value_.__r.__words[0];
  }
  if ((v41.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type size = v41.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type size = v41.__r_.__value_.__l.__size_;
  }
  uint64_t v29 = std::string::append(&v53, (const std::string::value_type *)v27, size);
  __int128 v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v56.__r_.__value_.__l.__cap_ = v29->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v30;
  v29->__r_.__value_.__l.__size_ = 0LL;
  v29->__r_.__value_.__l.__cap_ = 0LL;
  v29->__r_.__value_.__r.__words[0] = 0LL;
  char v40 = 1;
  strcpy(v39, ")");
  __int128 v31 = std::string::append(&v56, v39, 1uLL);
  __int128 v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  int64_t cap = v31->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 v54 = v32;
  v31->__r_.__value_.__l.__size_ = 0LL;
  v31->__r_.__value_.__l.__cap_ = 0LL;
  v31->__r_.__value_.__r.__words[0] = 0LL;
  if (v40 < 0) {
    operator delete(*(void **)v39);
  }
  if (v43 < 0) {
    operator delete(*(void **)v42);
  }
  if (v47 < 0) {
    operator delete(*(void **)__s);
  }
  if (cap >= 0) {
    unint64_t v33 = (char *)v54;
  }
  else {
    unint64_t v33 = (char *)v54[0];
  }
  sub_1003C0D54(a1, v33, &v56);
  std::string::size_type v34 = v56.__r_.__value_.__r.__words[0];
  int v35 = (sqlite3_stmt *)sub_100019240((uint64_t)v56.__r_.__value_.__l.__data_);
  memset(&v53, 0, sizeof(v53));
  while (j__sqlite3_step(v35) == 100)
  {
    v57.__r_.__value_.__r.__words[0] = sub_100011C2C(v35, 0);
    v57.__r_.__value_.__l.__size_ = v36;
    v52.__r_.__value_.__r.__words[0] = sqlite3_column_double(v35, 1);
    v51.__r_.__value_.__r.__words[0] = sub_1000CC094(v35, 2);
    sub_100011CB8(v35, 3, &v56);
    v50.__r_.__value_.__r.__words[0] = sub_1000CC094(v35, 4);
    sub_100011CB8(v35, 6, &v58);
    std::string::size_type v37 = v53.__r_.__value_.__l.__size_;
    if (v53.__r_.__value_.__l.__size_ >= v53.__r_.__value_.__l.__cap_)
    {
      std::string::size_type v38 = sub_1001000E0( (uint64_t *)&v53,  (uint64_t *)&v57,  (double *)&v52,  (unsigned int *)&v51,  (__int128 *)&v56,  (uint64_t *)&v50,  (__int128 *)&v58);
    }

    else
    {
      sub_1000F982C( v53.__r_.__value_.__l.__size_,  (uint64_t)v57.__r_.__value_.__l.__data_,  v57.__r_.__value_.__l.__size_,  v51.__r_.__value_.__l.__data_,  (__int128 *)&v56,  (uint64_t)v50.__r_.__value_.__l.__data_,  (__int128 *)&v58,  *(double *)&v52.__r_.__value_.__l.__data_);
      std::string::size_type v38 = v37 + 88;
    }

    v53.__r_.__value_.__l.__size_ = v38;
  }

  sqlite3_reset(v35);
  *a4 = v53;
  memset(&v53, 0, sizeof(v53));
  v56.__r_.__value_.__r.__words[0] = (std::string::size_type)&v53;
  sub_1000AA544((void ***)&v56);
  if (v34) {
    (*(void (**)(std::string::size_type))(*(void *)v34 + 8LL))(v34);
  }
  if (SHIBYTE(cap) < 0) {
    operator delete(v54[0]);
  }
}

void sub_1000F9E34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, void *a33, uint64_t a34, uint64_t a35, uint64_t a36, void *a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, void *a45, uint64_t a46, uint64_t a47, uint64_t a48, void *__p, uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,void **buf)
{
  uint64_t buf = &a45;
  sub_1000AA544(&buf);
  if (v56) {
    (*(void (**)(uint64_t))(*(void *)v56 + 8LL))(v56);
  }
  if (a54 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000FA1E0(uint64_t a1, void *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    uint64_t v4 = *(void *)a1;
    if (byte_101993A87 >= 0) {
      uint64_t v5 = (char *)&xmmword_101993A70;
    }
    else {
      uint64_t v5 = (char *)xmmword_101993A70;
    }
    sub_1003C0D54(v4, v5, &v31);
    uint64_t v6 = a2[1];
    if (*a2 != v6)
    {
      uint64_t v7 = *a2 + 88LL;
      while (1)
      {
        uint64_t v8 = (sqlite3_stmt *)sub_100019240(v31);
        memset(&__p, 0, sizeof(__p));
        if ((sub_100013090(v7 - 80, &__p) & 1) == 0)
        {
          std::bad_cast::bad_cast((std::bad_cast *)&buf);
          *(void *)&__int128 buf = &off_101818CB0;
          sub_1000139B0((uint64_t)&buf);
        }

        __int128 v9 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__p : (std::string *)__p.__r_.__value_.__r.__words[0];
        if (!sub_1003BC1F0(v8, 1, (char *)v9)
          || !sub_1003B7480(v8, 2, *(double *)(v7 - 64))
          || !sub_1003C2D24(v8, 3, *(void *)(v7 - 88)))
        {
          break;
        }

        char v10 = (char *)(v7 - 56);
        if (!sub_1003BC1F0(v8, 4, v10) || !sub_1003C2D24(v8, 5, *(void *)(v7 - 32))) {
          break;
        }
        std::string::size_type v11 = (char *)(v7 - 24);
        if (!sub_1003BC1F0(v8, 7, v11)) {
          break;
        }
        if (!sub_1003BB2BC(*(void *)a1, v8))
        {
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181F268);
          }
          uint64_t v16 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
          {
            if (byte_101993A87 >= 0) {
              __int128 v17 = &xmmword_101993A70;
            }
            else {
              __int128 v17 = (__int128 *)xmmword_101993A70;
            }
            LODWORD(buf) = 136446210;
            *(void *)((char *)&buf + 4) = v17;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "Failed to execute statement. %{public}s",  (uint8_t *)&buf,  0xCu);
          }

          if (sub_1002921D0(115, 0))
          {
            bzero(&buf, 0x65CuLL);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181F268);
            }
            if (byte_101993A87 >= 0) {
              uint64_t v18 = &xmmword_101993A70;
            }
            else {
              uint64_t v18 = (__int128 *)xmmword_101993A70;
            }
            int v32 = 136446210;
            unint64_t v33 = v18;
            LODWORD(v29) = 12;
            _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Failed to execute statement. %{public}s",  &v32,  v29);
            int v20 = (char *)v19;
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMiLoServiceTable::insertOrReplace(const std::vector<CLMiLoServiceTable::Entry> &)",  "%s\n",  v19);
          }

void sub_1000FA800( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, std::bad_cast a26)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  if (a23) {
    (*(void (**)(uint64_t))(*(void *)a23 + 8LL))(a23);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000FA864( uint64_t a1@<X0>, std::string::size_type a2@<X1>, uint64_t a3@<X2>, unsigned int a4@<W3>, std::string *a5@<X8>)
{
  if (*(_BYTE *)(a1 + 8))
  {
    v49.__r_.__value_.__s.__size_ = 6;
    strcpy((char *)&v49, "WHERE ");
    char v10 = std::string::append(&v49, "ClientID");
    __int128 v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v50.__r_.__value_.__l.__cap_ = v10->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0LL;
    v10->__r_.__value_.__l.__cap_ = 0LL;
    v10->__r_.__value_.__r.__words[0] = 0LL;
    char v48 = 2;
    strcpy(__s, "=");
    uint64_t v12 = std::string::append(&v50, __s, 2uLL);
    __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v51.__r_.__value_.__l.__cap_ = v12->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v51.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0LL;
    v12->__r_.__value_.__l.__cap_ = 0LL;
    v12->__r_.__value_.__r.__words[0] = 0LL;
    int v14 = *(char *)(a2 + 23);
    if (v14 >= 0) {
      char v15 = (const std::string::value_type *)a2;
    }
    else {
      char v15 = *(const std::string::value_type **)a2;
    }
    if (v14 >= 0) {
      std::string::size_type v16 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      std::string::size_type v16 = *(void *)(a2 + 8);
    }
    __int128 v17 = std::string::append(&v51, v15, v16);
    __int128 v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v52.__r_.__value_.__l.__cap_ = v17->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0LL;
    v17->__r_.__value_.__l.__cap_ = 0LL;
    v17->__r_.__value_.__r.__words[0] = 0LL;
    char v46 = 1;
    strcpy(v45, "");
    __int128 v19 = std::string::append(&v52, v45, 1uLL);
    __int128 v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__l.__cap_ = v19->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v20;
    v19->__r_.__value_.__l.__size_ = 0LL;
    v19->__r_.__value_.__l.__cap_ = 0LL;
    v19->__r_.__value_.__r.__words[0] = 0LL;
    char v44 = 5;
    strcpy(v43, " AND ");
    uint64_t v21 = std::string::append(&v53, v43, 5uLL);
    __int128 v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v54.__r_.__value_.__l.__cap_ = v21->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v54.__r_.__value_.__l.__data_ = v22;
    v21->__r_.__value_.__l.__size_ = 0LL;
    v21->__r_.__value_.__l.__cap_ = 0LL;
    v21->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v23 = std::string::append(&v54, "UserId");
    __int128 v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
    v55.__r_.__value_.__l.__cap_ = v23->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v55.__r_.__value_.__l.__data_ = v24;
    v23->__r_.__value_.__l.__size_ = 0LL;
    v23->__r_.__value_.__l.__cap_ = 0LL;
    v23->__r_.__value_.__r.__words[0] = 0LL;
    char v42 = 2;
    strcpy(v41, "=");
    uint64_t v25 = std::string::append(&v55, v41, 2uLL);
    __int128 v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
    v56.__r_.__value_.__l.__cap_ = v25->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v56.__r_.__value_.__l.__data_ = v26;
    v25->__r_.__value_.__l.__size_ = 0LL;
    v25->__r_.__value_.__l.__cap_ = 0LL;
    v25->__r_.__value_.__r.__words[0] = 0LL;
    int v27 = *(char *)(a3 + 23);
    if (v27 >= 0) {
      uint64_t v28 = (const std::string::value_type *)a3;
    }
    else {
      uint64_t v28 = *(const std::string::value_type **)a3;
    }
    if (v27 >= 0) {
      std::string::size_type v29 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      std::string::size_type v29 = *(void *)(a3 + 8);
    }
    __int128 v30 = std::string::append(&v56, v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v57.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v57.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    char v40 = 1;
    strcpy(v39, "");
    int v32 = std::string::append(&v57, v39, 1uLL);
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    std::string::size_type cap = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)std::string __p = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    if (v40 < 0) {
      operator delete(*(void **)v39);
    }
    if (v42 < 0) {
      operator delete(*(void **)v41);
    }
    if (v44 < 0) {
      operator delete(*(void **)v43);
    }
    if (v46 < 0) {
      operator delete(*(void **)v45);
    }
    if (v48 < 0) {
      operator delete(*(void **)__s);
    }
    sub_1000F9938(*(void *)a1, (uint64_t)__p, a4, a5);
    if (SHIBYTE(cap) < 0) {
      operator delete(__p[0]);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F268);
    }
    std::string::size_type v34 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      else {
        int v35 = *(const std::string::value_type **)a2;
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = (void *)v35;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so we can't get the services for client ID %s",  (uint8_t *)__p,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      else {
        std::string::size_type v36 = *(void *)a2;
      }
      LODWORD(v57.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v57.__r_.__value_.__r.__words + 4) = v36;
      _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Table is not valid so we can't get the services for client ID %s",  (const char *)&v57);
      std::string::size_type v38 = (void **)v37;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getAllServicesForClientAndUserId(const std::string &, const std::string &, uint32_t)",  "%s\n",  v37);
      if (v38 != __p) {
        free(v38);
      }
    }

    a5->__r_.__value_.__r.__words[0] = 0LL;
    a5->__r_.__value_.__l.__size_ = 0LL;
    a5->__r_.__value_.__l.__cap_ = 0LL;
  }

void sub_1000FAD6C(_Unwind_Exception *a1)
{
}

void sub_1000FAEAC()
{
}

void sub_1000FAEB4(uint64_t a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, std::string *a4@<X8>)
{
  if (*(_BYTE *)(a1 + 8))
  {
    v24.__r_.__value_.__s.__size_ = 6;
    strcpy((char *)&v24, "WHERE ");
    uint64_t v8 = std::string::append(&v24, "ServiceType");
    __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0LL;
    v8->__r_.__value_.__l.__cap_ = 0LL;
    v8->__r_.__value_.__r.__words[0] = 0LL;
    char v23 = 2;
    strcpy(__s, "= ");
    char v10 = std::string::append(&v25, __s, 2uLL);
    __int128 v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v26.__r_.__value_.__l.__cap_ = v10->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0LL;
    v10->__r_.__value_.__l.__cap_ = 0LL;
    v10->__r_.__value_.__r.__words[0] = 0LL;
    std::to_string(&v21, a2);
    if ((v21.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v12 = &v21;
    }
    else {
      uint64_t v12 = (std::string *)v21.__r_.__value_.__r.__words[0];
    }
    if ((v21.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = v21.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = v21.__r_.__value_.__l.__size_;
    }
    int v14 = std::string::append(&v26, (const std::string::value_type *)v12, size);
    __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    __p[0].__r_.__value_.__l.__cap_ = v14->__r_.__value_.__l.__cap_;
    *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0LL;
    v14->__r_.__value_.__l.__cap_ = 0LL;
    v14->__r_.__value_.__r.__words[0] = 0LL;
    if (v23 < 0) {
      operator delete(*(void **)__s);
    }
    sub_1000F9938(*(void *)a1, (uint64_t)__p, a3, a4);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F268);
    }
    std::string::size_type v16 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      std::to_string(__p, a2);
      __int128 v17 = (__p[0].__r_.__value_.__s.__size_ & 0x80u) == 0 ? __p : (std::string *)__p[0].__r_.__value_.__r.__words[0];
      LODWORD(v26.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v26.__r_.__value_.__r.__words + 4) = (std::string::size_type)v17;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so we can't get the services for service Type %s",  (uint8_t *)&v26,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      uint64_t v18 = qword_1019348D8;
      std::to_string(&v26, a2);
      if ((v26.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v19 = &v26;
      }
      else {
        __int128 v19 = (std::string *)v26.__r_.__value_.__r.__words[0];
      }
      LODWORD(v25.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = (std::string::size_type)v19;
      __int128 v20 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v18,  0LL,  "#Warning Table is not valid so we can't get the services for service Type %s",  (const char *)&v25);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getAllServicesForServiceType(uint32_t, uint32_t)",  "%s\n",  (const char *)v20);
      if (v20 != __p) {
        free(v20);
      }
    }

    a4->__r_.__value_.__r.__words[0] = 0LL;
    a4->__r_.__value_.__l.__size_ = 0LL;
    a4->__r_.__value_.__l.__cap_ = 0LL;
  }

void sub_1000FB228( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, void *a37, uint64_t a38, int a39, __int16 a40, char a41, char a42, uint64_t a43, void *__p, uint64_t a45, int a46, __int16 a47, char a48, char a49)
{
}

void sub_1000FB2B8(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  v28[0] = a2;
  v28[1] = a3;
  memset(&__p, 0, sizeof(__p));
  if ((sub_100013090((uint64_t)v28, &__p) & 1) == 0)
  {
    std::bad_cast::bad_cast((std::bad_cast *)&buf);
    *(void *)&__int128 buf = &off_101818CB0;
    sub_1000139B0((uint64_t)&buf);
  }

  if (*(_BYTE *)(a1 + 8))
  {
    v21.__r_.__value_.__s.__size_ = 6;
    strcpy((char *)&v21, "WHERE ");
    uint64_t v6 = std::string::append(&v21, "ServiceUUID");
    __int128 v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__l.__cap_ = v6->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0LL;
    v6->__r_.__value_.__l.__cap_ = 0LL;
    v6->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v8 = std::string::append(&v22, "= ");
    __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v23.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0LL;
    v8->__r_.__value_.__l.__cap_ = 0LL;
    v8->__r_.__value_.__r.__words[0] = 0LL;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = __p.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    uint64_t v12 = std::string::append(&v23, (const std::string::value_type *)p_p, size);
    __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__l.__cap_ = v12->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0LL;
    v12->__r_.__value_.__l.__cap_ = 0LL;
    v12->__r_.__value_.__r.__words[0] = 0LL;
    int v14 = std::string::append(&v25, "");
    __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    std::string::size_type cap = (_UNKNOWN **)v14->__r_.__value_.__l.__cap_;
    __int128 buf = v15;
    v14->__r_.__value_.__l.__size_ = 0LL;
    v14->__r_.__value_.__l.__cap_ = 0LL;
    v14->__r_.__value_.__r.__words[0] = 0LL;
    sub_1000F9938(*(void *)a1, (uint64_t)&buf, 1u, &v25);
    if (v25.__r_.__value_.__r.__words[0] == v25.__r_.__value_.__l.__size_)
    {
      *a4 = 0;
      a4[88] = 0;
    }

    else
    {
      sub_100100474((uint64_t)a4, (uint64_t)v25.__r_.__value_.__l.__data_);
    }

    v23.__r_.__value_.__r.__words[0] = (std::string::size_type)&v25;
    sub_1000AA544((void ***)&v23);
    if (SHIBYTE(cap) < 0) {
      operator delete((void *)buf);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F268);
    }
    std::string::size_type v16 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v17 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        __int128 v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so we can't get the services for UUID %s",  (uint8_t *)&buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(&buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      uint64_t v18 = &__p;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v18 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      LODWORD(v25.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v25.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
      _os_log_send_and_compose_impl( 2LL,  0LL,  &buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Table is not valid so we can't get the services for UUID %s",  (const char *)&v25);
      __int128 v20 = (char *)v19;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::optional<CLMiLoServiceTable::Entry> CLMiLoServiceTable::getServiceByUuid(boost::uuids::uuid)",  "%s\n",  v19);
    }

    *a4 = 0;
    a4[88] = 0;
  }

void sub_1000FB670( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30, void *__p, uint64_t a32, int a33, __int16 a34, char a35, char a36, void *a37, uint64_t a38, int a39, __int16 a40, char a41, char a42, uint64_t a43, std::bad_cast a44, uint64_t a45, int a46, __int16 a47, char a48, char a49)
{
  if (a36 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1000FB730(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v48[0] = a2;
  v48[1] = a3;
  if (*(_BYTE *)(a1 + 8))
  {
    v36.__r_.__value_.__s.__size_ = 12;
    strcpy((char *)&v36, "DELETE FROM ");
    uint64_t v4 = std::string::append(&v36, "MiLoServices");
    __int128 v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v37.__r_.__value_.__l.__cap_ = v4->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0LL;
    v4->__r_.__value_.__l.__cap_ = 0LL;
    v4->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v6 = std::string::append(&v37, " WHERE ");
    __int128 v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v38.__r_.__value_.__l.__cap_ = v6->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0LL;
    v6->__r_.__value_.__l.__cap_ = 0LL;
    v6->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v8 = std::string::append(&v38, "ServiceUUID");
    __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v39.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0LL;
    v8->__r_.__value_.__l.__cap_ = 0LL;
    v8->__r_.__value_.__r.__words[0] = 0LL;
    char v35 = 4;
    strcpy(__s, " IN ");
    char v10 = std::string::append(&v39, __s, 4uLL);
    __int128 v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v40.__r_.__value_.__l.__cap_ = v10->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0LL;
    v10->__r_.__value_.__l.__cap_ = 0LL;
    v10->__r_.__value_.__r.__words[0] = 0LL;
    char v33 = 2;
    strcpy(v32, "(");
    uint64_t v12 = std::string::append(&v40, v32, 2uLL);
    __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__l.__cap_ = v12->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0LL;
    v12->__r_.__value_.__l.__cap_ = 0LL;
    v12->__r_.__value_.__r.__words[0] = 0LL;
    memset(&__p, 0, sizeof(__p));
    if ((sub_100013090((uint64_t)v48, &__p) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)v45);
      *(void *)unsigned __int8 v45 = &off_101818CB0;
      sub_1000139B0((uint64_t)v45);
    }

    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = __p.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
    }
    std::string::size_type v16 = std::string::append(&v41, (const std::string::value_type *)p_p, size);
    __int128 v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v42.__r_.__value_.__l.__cap_ = v16->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0LL;
    v16->__r_.__value_.__l.__cap_ = 0LL;
    v16->__r_.__value_.__r.__words[0] = 0LL;
    HIBYTE(v47) = 2;
    strcpy(v45, ")");
    uint64_t v18 = std::string::append(&v42, v45, 2uLL);
    __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    int64_t cap = v18->__r_.__value_.__l.__cap_;
    *(_OWORD *)char v43 = v19;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    if (SHIBYTE(v47) < 0) {
      operator delete(*(void **)v45);
    }
    if (v33 < 0) {
      operator delete(*(void **)v32);
    }
    if (v35 < 0) {
      operator delete(*(void **)__s);
    }
    if (cap >= 0) {
      __int128 v20 = (char *)v43;
    }
    else {
      __int128 v20 = (char *)v43[0];
    }
    sub_1003C0D54(*(void *)a1, v20, v45);
    std::string v21 = *(void **)v45;
    std::string v22 = (sqlite3_stmt *)sub_100019240(*(uint64_t *)v45);
    if (v22)
    {
      BOOL v23 = sub_1003BB2BC(*(void *)a1, v22);
      if (!v21) {
        goto LABEL_37;
      }
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      std::string v26 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)unsigned __int8 v45 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "Error getting a prepared statement",  (uint8_t *)v45,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(v45, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F268);
        }
        LOWORD(v42.__r_.__value_.__l.__data_) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  v45,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Error getting a prepared statement",  &v42,  2);
        __int128 v30 = (std::string::value_type *)v29;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMiLoServiceTable::deleteServiceForUuid(boost::uuids::uuid)",  "%s\n",  v29);
        if (v30 != v45) {
          free(v30);
        }
      }

      BOOL v23 = 0LL;
      if (!v21) {
        goto LABEL_37;
      }
    }

    (*(void (**)(void *))(*(void *)v21 + 8LL))(v21);
LABEL_37:
    if (SHIBYTE(cap) < 0) {
      operator delete(v43[0]);
    }
    return v23;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F268);
  }
  std::string v24 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned __int8 v45 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so we can't Service",  (uint8_t *)v45,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(v45, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F268);
    }
    LOWORD(v43[0]) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  v45,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Table is not valid so we can't Service",  v43,  2);
    uint64_t v28 = (std::string::value_type *)v27;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMiLoServiceTable::deleteServiceForUuid(boost::uuids::uuid)",  "%s\n",  v27);
    if (v28 != v45) {
      free(v28);
    }
  }

  return 0LL;
}

void sub_1000FBD0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, void *a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, uint64_t a37, uint64_t a38, void *a39, uint64_t a40, uint64_t a41, uint64_t a42, void *a43, uint64_t a44, uint64_t a45, uint64_t a46, void *__p, uint64_t a48, int a49, __int16 a50,char a51,char a52)
{
  if (v52) {
    (*(void (**)(uint64_t))(*(void *)v52 + 8LL))(v52);
  }
  if (a52 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1000FBE48(uint64_t a1, uint64_t *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    v42.__r_.__value_.__s.__size_ = 12;
    strcpy((char *)&v42, "DELETE FROM ");
    uint64_t v4 = std::string::append(&v42, "MiLoServices");
    __int128 v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v41.__r_.__value_.__l.__cap_ = v4->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0LL;
    v4->__r_.__value_.__l.__cap_ = 0LL;
    v4->__r_.__value_.__r.__words[0] = 0LL;
    if (a2[1] != *a2)
    {
      v38.__r_.__value_.__s.__size_ = 7;
      strcpy((char *)&v38, " WHERE ");
      uint64_t v6 = std::string::append(&v38, "ClientID");
      __int128 v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
      v39.__r_.__value_.__l.__cap_ = v6->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v7;
      v6->__r_.__value_.__l.__size_ = 0LL;
      v6->__r_.__value_.__l.__cap_ = 0LL;
      v6->__r_.__value_.__r.__words[0] = 0LL;
      char v37 = 8;
      strcpy(__s, " NOT IN ");
      uint64_t v8 = std::string::append(&v39, __s, 8uLL);
      __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v40.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0LL;
      v8->__r_.__value_.__l.__cap_ = 0LL;
      v8->__r_.__value_.__r.__words[0] = 0LL;
      char v35 = 1;
      strcpy(v34, "(");
      char v10 = std::string::append(&v40, v34, 1uLL);
      __int128 v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      v42.__r_.__value_.__l.__cap_ = v10->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v11;
      v10->__r_.__value_.__l.__size_ = 0LL;
      v10->__r_.__value_.__l.__cap_ = 0LL;
      v10->__r_.__value_.__r.__words[0] = 0LL;
      if ((v42.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v12 = &v42;
      }
      else {
        uint64_t v12 = (std::string *)v42.__r_.__value_.__r.__words[0];
      }
      if ((v42.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type size = v42.__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type size = v42.__r_.__value_.__l.__size_;
      }
      std::string::append(&v41, (const std::string::value_type *)v12, size);
      if (v35 < 0) {
        operator delete(*(void **)v34);
      }
      if (v37 < 0) {
        operator delete(*(void **)__s);
      }
      uint64_t v14 = *a2;
      if (a2[1] != *a2)
      {
        uint64_t v15 = 0LL;
        unsigned int v16 = 1;
        do
        {
          std::operator+<char>(&v40, "", v14 + 24 * v15);
          __int128 v17 = std::string::append(&v40, "");
          __int128 v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
          v42.__r_.__value_.__l.__cap_ = v17->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v18;
          v17->__r_.__value_.__l.__size_ = 0LL;
          v17->__r_.__value_.__l.__cap_ = 0LL;
          v17->__r_.__value_.__r.__words[0] = 0LL;
          if ((v42.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            __int128 v19 = &v42;
          }
          else {
            __int128 v19 = (std::string *)v42.__r_.__value_.__r.__words[0];
          }
          if ((v42.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            std::string::size_type v20 = v42.__r_.__value_.__s.__size_;
          }
          else {
            std::string::size_type v20 = v42.__r_.__value_.__l.__size_;
          }
          std::string::append(&v41, (const std::string::value_type *)v19, v20);
          uint64_t v14 = *a2;
          unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3);
          if (v21 - 1 != v15)
          {
            std::string::append(&v41, ", ");
            uint64_t v14 = *a2;
            unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3);
          }

          uint64_t v15 = v16;
        }

        while (v21 > v16++);
      }

      std::string::append(&v41, ")");
    }

    if ((v41.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      BOOL v23 = &v41;
    }
    else {
      BOOL v23 = (std::string *)v41.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)a1, (char *)v23, &v42);
    std::string::size_type v24 = v42.__r_.__value_.__r.__words[0];
    std::string v25 = (sqlite3_stmt *)sub_100019240((uint64_t)v42.__r_.__value_.__l.__data_);
    if (v25)
    {
      BOOL v26 = sub_1003BB2BC(*(void *)a1, v25);
      if (!v24) {
        goto LABEL_45;
      }
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      std::string::size_type v29 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v42.__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "Error getting a prepared statement",  (uint8_t *)&v42,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(&v42, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F268);
        }
        LOWORD(v40.__r_.__value_.__l.__data_) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &v42,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Error getting a prepared statement",  &v40,  2);
        char v33 = (std::string *)v32;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMiLoServiceTable::deleteAllServices(const std::vector<std::string> &)",  "%s\n",  v32);
        if (v33 != &v42) {
          free(v33);
        }
      }

      BOOL v26 = 0LL;
      if (!v24) {
        goto LABEL_45;
      }
    }

    (*(void (**)(std::string::size_type))(*(void *)v24 + 8LL))(v24);
LABEL_45:
    return v26;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F268);
  }
  int v27 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v42.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so all services will not be deleted",  (uint8_t *)&v42,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v42, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F268);
    }
    LOWORD(v41.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v42,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Table is not valid so all services will not be deleted",  &v41,  2);
    __int128 v31 = (std::string *)v30;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMiLoServiceTable::deleteAllServices(const std::vector<std::string> &)",  "%s\n",  v30);
    if (v31 != &v42) {
      free(v31);
    }
  }

  return 0LL;
}

void sub_1000FC460( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, uint64_t a36, void *a37, uint64_t a38, int a39, __int16 a40, char a41, char a42, uint64_t a43, void *__p, uint64_t a45, int a46, __int16 a47, char a48, char a49, uint64_t a50,void *a51,uint64_t a52,int a53,__int16 a54,char a55,char a56)
{
  if (v56) {
    (*(void (**)(uint64_t))(*(void *)v56 + 8LL))(v56);
  }
  if (a49 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000FC570(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8))
  {
    sub_1000FE608((uint64_t *)a1, (uint64_t *)&v187);
    std::string::size_type size = v187.__r_.__value_.__l.__size_;
    std::string::size_type v2 = v187.__r_.__value_.__r.__words[0];
    if (v187.__r_.__value_.__r.__words[0] == v187.__r_.__value_.__l.__size_)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      uint64_t v122 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v122,  OS_LOG_TYPE_DEFAULT,  "Log Pre-Maintenance MiLoServiceTable: no services found.",  (uint8_t *)buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F268);
        }
        LOWORD(__p[0]) = 0;
        uint64_t v129 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Log Pre-Maintenance MiLoServiceTable: no services found.",  __p,  2);
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMiLoServiceTable::deleteOldestsServicesPerClientAboveMaxCount()",  "%s\n",  (const char *)v129);
        if (v129 != buf) {
          free(v129);
        }
      }

      uint64_t v121 = 1LL;
    }

    else
    {
      int v133 = (uint64_t *)a1;
      do
      {
        if (*(char *)(v2 + 23) < 0)
        {
          sub_1010DD48C(__p, *(void **)v2, *(void *)(v2 + 8));
        }

        else
        {
          __int128 v4 = *(_OWORD *)v2;
          uint64_t v171 = *(void *)(v2 + 16);
          *(_OWORD *)std::string __p = v4;
        }

        __int128 v172 = *(_OWORD *)(v2 + 24);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F268);
        }
        __int128 v5 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          if (v171 >= 0) {
            uint64_t v6 = __p;
          }
          else {
            uint64_t v6 = (void **)__p[0];
          }
          LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315650;
          *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v6;
          WORD2(buf[0].__r_.__value_.__r.__words[1]) = 1024;
          *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v172;
          WORD1(buf[0].__r_.__value_.__r.__words[2]) = 2048;
          *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[2] + 4) = *((void *)&v172 + 1);
          _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Log Pre-Maintenance MiLoServiceTable client: %s has: %u services of serviceType: %llU",  (uint8_t *)buf,  0x1Cu);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181F268);
          }
          if (v171 >= 0) {
            __int128 v7 = __p;
          }
          else {
            __int128 v7 = (void **)__p[0];
          }
          *(_DWORD *)int v189 = 136315650;
          *(void *)&v189[4] = v7;
          *(_WORD *)&v189[12] = 1024;
          *(_DWORD *)&v189[14] = v172;
          *(_WORD *)&v189[18] = 2048;
          *(void *)&v189[20] = *((void *)&v172 + 1);
          LODWORD(v132) = 28;
          uint64_t v8 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Log Pre-Maintenance MiLoServiceTable client: %s has: %u services of serviceType: %llU",  v189,  v132);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMiLoServiceTable::deleteOldestsServicesPerClientAboveMaxCount()",  "%s\n",  (const char *)v8);
          if (v8 != buf) {
            free(v8);
          }
        }

        if (SHIBYTE(v171) < 0) {
          operator delete(__p[0]);
        }
        v2 += 40LL;
      }

      while (v2 != size);
      __int128 v186 = 0uLL;
      uint64_t v185 = 0LL;
      std::to_string(&v181, 1u);
      sub_1002F0B04(__p);
      __int128 v9 = (uint64_t *)a1;
      CFStringRef v10 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfCreatedUnsupervisedServicesPerClientAfterMaintenance",  0x8000100u,  kCFAllocatorNull);
      int v11 = sub_1002A77CC((uint64_t)__p[0], (uint64_t)v10, v189);
      CFRelease(v10);
      unint64_t v12 = *(unsigned int *)v189;
      __int128 v13 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        uint64_t v14 = (unint64_t *)((char *)__p[1] + 8);
        do
          unint64_t v15 = __ldaxr(v14);
        while (__stlxr(v15 - 1, v14));
        if (!v15)
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
      }

      if (v11) {
        unint64_t v16 = v12;
      }
      else {
        unint64_t v16 = 1LL;
      }
      std::to_string(&v180, v16);
      sub_1000FEDE8((char *)buf, (__int128 *)&v181, (__int128 *)&v180);
      std::to_string(&v179, 2u);
      sub_1002F0B04(__p);
      CFStringRef v17 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfCreatedBinaryRoiServicesPerClientAfterMaintenance",  0x8000100u,  kCFAllocatorNull);
      int v18 = sub_1002A77CC((uint64_t)__p[0], (uint64_t)v17, v189);
      CFRelease(v17);
      unint64_t v19 = *(unsigned int *)v189;
      std::string::size_type v20 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        unint64_t v21 = (unint64_t *)((char *)__p[1] + 8);
        do
          unint64_t v22 = __ldaxr(v21);
        while (__stlxr(v22 - 1, v21));
        if (!v22)
        {
          ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
          std::__shared_weak_count::__release_weak(v20);
        }
      }

      if (v18) {
        unint64_t v23 = v19;
      }
      else {
        unint64_t v23 = 1LL;
      }
      std::to_string(&v178, v23);
      sub_1000FEDE8(v191, (__int128 *)&v179, (__int128 *)&v178);
      std::to_string(&v177, 3u);
      sub_1002F0B04(__p);
      CFStringRef v24 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfCreatedMulticlassServicesPerClientAfterMaintenance",  0x8000100u,  kCFAllocatorNull);
      int v25 = sub_1002A77CC((uint64_t)__p[0], (uint64_t)v24, v189);
      CFRelease(v24);
      unint64_t v26 = *(unsigned int *)v189;
      int v27 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        uint64_t v28 = (unint64_t *)((char *)__p[1] + 8);
        do
          unint64_t v29 = __ldaxr(v28);
        while (__stlxr(v29 - 1, v28));
        if (!v29)
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
      }

      if (v25) {
        unint64_t v30 = v26;
      }
      else {
        unint64_t v30 = 1LL;
      }
      std::to_string(&v176, v30);
      sub_1000FEDE8(v192, (__int128 *)&v177, (__int128 *)&v176);
      std::to_string(&v175, 4u);
      sub_1002F0B04(__p);
      CFStringRef v31 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaximumNumberOfCreatedSimilarityListServicesPerClientAfterMaintenance",  0x8000100u,  kCFAllocatorNull);
      int v32 = sub_1002A77CC((uint64_t)__p[0], (uint64_t)v31, v189);
      CFRelease(v31);
      unint64_t v33 = *(unsigned int *)v189;
      std::string::size_type v34 = (std::__shared_weak_count *)__p[1];
      if (__p[1])
      {
        char v35 = (unint64_t *)((char *)__p[1] + 8);
        do
          unint64_t v36 = __ldaxr(v35);
        while (__stlxr(v36 - 1, v35));
        if (!v36)
        {
          ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
          std::__shared_weak_count::__release_weak(v34);
        }
      }

      if (v32) {
        unint64_t v37 = v33;
      }
      else {
        unint64_t v37 = 20LL;
      }
      std::to_string(&v174, v37);
      sub_1000FEDE8(v193, (__int128 *)&v175, (__int128 *)&v174);
      __int16 v183 = 0LL;
      int v182 = 0LL;
      int v184 = 0LL;
      __p[0] = &v182;
      LOBYTE(__p[1]) = 0;
      std::string v38 = (char *)operator new(0xC0uLL);
      uint64_t v39 = 0LL;
      int v182 = v38;
      __int16 v183 = v38;
      int v184 = v38 + 192;
      do
      {
        std::string v40 = &v38[v39 * 24];
        std::string v41 = &buf[v39];
        if ((char)buf[v39].__r_.__value_.__s.__size_ < 0)
        {
          sub_1010DD48C(v40, v41->__r_.__value_.__l.__data_, v41->__r_.__value_.__l.__size_);
        }

        else
        {
          *(_OWORD *)std::string v40 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
          *((void *)v40 + 2) = v41->__r_.__value_.__l.__cap_;
        }

        std::string v42 = &v38[v39 * 24 + 24];
        char v43 = &buf[v39 + 1];
        if ((char)buf[v39 + 1].__r_.__value_.__s.__size_ < 0)
        {
          sub_1010DD48C(v42, v43->__r_.__value_.__l.__data_, buf[v39 + 1].__r_.__value_.__l.__size_);
        }

        else
        {
          *(_OWORD *)std::string v42 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
          *(void *)&v38[v39 * 24 + 40] = buf[v39 + 1].__r_.__value_.__l.__cap_;
        }

        v39 += 2LL;
      }

      while (v39 != 8);
      unint64_t v44 = 0LL;
      __int16 v183 = v38 + 192;
      do
      {
        unsigned __int8 v45 = &buf[v44 / 0x18];
        if (v193[v44 + 47] < 0) {
          operator delete(v45[7].__r_.__value_.__l.__data_);
        }
        v44 -= 48LL;
      }

      while (v44 != -192LL);
      char v46 = v182;
      char v134 = v183;
      if (v182 == v183)
      {
LABEL_203:
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F268);
        }
        int v112 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v112,  OS_LOG_TYPE_DEFAULT,  "Maintenance deleted oldest services above max count per client",  (uint8_t *)buf,  2u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181F268);
          }
          LOWORD(__p[0]) = 0;
          LODWORD(v132) = 2;
          __int128 v130 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Maintenance deleted oldest services above max count per client",  __p,  v132);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMiLoServiceTable::deleteOldestsServicesPerClientAboveMaxCount()",  "%s\n",  (const char *)v130);
          if (v130 != buf) {
            free(v130);
          }
          __int128 v9 = v133;
        }

        sub_1000FE608(v9, (uint64_t *)buf);
        sub_100100CB0((uint64_t *)&v187);
        std::string v187 = buf[0];
        memset(buf, 0, 24);
        __p[0] = buf;
        sub_100100B70((void ***)__p);
        std::string::size_type v114 = v187.__r_.__value_.__l.__size_;
        std::string::size_type v113 = v187.__r_.__value_.__r.__words[0];
        if (v187.__r_.__value_.__r.__words[0] == v187.__r_.__value_.__l.__size_)
        {
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181F268);
          }
          __int16 v123 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v123,  OS_LOG_TYPE_DEFAULT,  "Log Post-Maintenance MiLoServiceTable: no services found.",  (uint8_t *)buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181F268);
            }
            LOWORD(__p[0]) = 0;
            LODWORD(v132) = 2;
            uint64_t v131 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Log Post-Maintenance MiLoServiceTable: no services found.",  __p,  v132);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMiLoServiceTable::deleteOldestsServicesPerClientAboveMaxCount()",  "%s\n",  (const char *)v131);
            if (v131 != buf) {
              free(v131);
            }
          }
        }

        else
        {
          do
          {
            if (*(char *)(v113 + 23) < 0)
            {
              sub_1010DD48C(__p, *(void **)v113, *(void *)(v113 + 8));
            }

            else
            {
              __int128 v115 = *(_OWORD *)v113;
              uint64_t v171 = *(void *)(v113 + 16);
              *(_OWORD *)std::string __p = v115;
            }

            __int128 v172 = *(_OWORD *)(v113 + 24);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181F268);
            }
            int v116 = (os_log_s *)qword_1019348D8;
            if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
            {
              if (v171 >= 0) {
                int v117 = __p;
              }
              else {
                int v117 = (void **)__p[0];
              }
              LODWORD(buf[0].__r_.__value_.__l.__data_) = 136315650;
              *(std::string::size_type *)((char *)buf[0].__r_.__value_.__r.__words + 4) = (std::string::size_type)v117;
              WORD2(buf[0].__r_.__value_.__r.__words[1]) = 1024;
              *(_DWORD *)((char *)&buf[0].__r_.__value_.__r.__words[1] + 6) = v172;
              WORD1(buf[0].__r_.__value_.__r.__words[2]) = 2048;
              *(std::string::size_type *)((char *)&buf[0].__r_.__value_.__r.__words[2] + 4) = *((void *)&v172 + 1);
              _os_log_impl( (void *)&_mh_execute_header,  v116,  OS_LOG_TYPE_DEFAULT,  "Log Post-Maintenance MiLoServiceTable client: %s has: %u services of serviceType: %llU",  (uint8_t *)buf,  0x1Cu);
            }

            if (sub_1002921D0(115, 2))
            {
              bzero(buf, 0x65CuLL);
              if (qword_1019348D0 != -1) {
                dispatch_once(&qword_1019348D0, &stru_10181F268);
              }
              if (v171 >= 0) {
                int v118 = __p;
              }
              else {
                int v118 = (void **)__p[0];
              }
              *(_DWORD *)int v189 = 136315650;
              *(void *)&v189[4] = v118;
              *(_WORD *)&v189[12] = 1024;
              *(_DWORD *)&v189[14] = v172;
              *(_WORD *)&v189[18] = 2048;
              *(void *)&v189[20] = *((void *)&v172 + 1);
              LODWORD(v132) = 28;
              int v119 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Log Post-Maintenance MiLoServiceTable client: %s has: %u services of serviceType: %llU",  v189,  v132);
              sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMiLoServiceTable::deleteOldestsServicesPerClientAboveMaxCount()",  "%s\n",  (const char *)v119);
              if (v119 != buf) {
                free(v119);
              }
            }

            if (SHIBYTE(v171) < 0) {
              operator delete(__p[0]);
            }
            v113 += 40LL;
          }

          while (v113 != v114);
        }

        uint64_t v121 = 1LL;
      }

      else
      {
        while (1)
        {
          if (v46[23] < 0)
          {
            sub_1010DD48C(__p, *(void **)v46, *((void *)v46 + 1));
          }

          else
          {
            __int128 v47 = *(_OWORD *)v46;
            uint64_t v171 = *((void *)v46 + 2);
            *(_OWORD *)std::string __p = v47;
          }

          if (v46[47] < 0)
          {
            sub_1010DD48C(&v172, *((void **)v46 + 3), *((void *)v46 + 4));
          }

          else
          {
            __int128 v48 = *(_OWORD *)(v46 + 24);
            uint64_t v173 = *((void *)v46 + 5);
            __int128 v172 = v48;
          }

          v152.__r_.__value_.__s.__size_ = 7;
          strcpy((char *)&v152, "SELECT ");
          std::string v49 = std::string::append(&v152, "ServiceUUID");
          __int128 v50 = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
          v153.__r_.__value_.__l.__cap_ = v49->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v153.__r_.__value_.__l.__data_ = v50;
          v49->__r_.__value_.__l.__size_ = 0LL;
          v49->__r_.__value_.__l.__cap_ = 0LL;
          v49->__r_.__value_.__r.__words[0] = 0LL;
          char v151 = 14;
          strcpy(__s, " FROM (SELECT ");
          std::string v51 = std::string::append(&v153, __s, 0xEuLL);
          __int128 v52 = *(_OWORD *)&v51->__r_.__value_.__l.__data_;
          v154.__r_.__value_.__l.__cap_ = v51->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v52;
          v51->__r_.__value_.__l.__size_ = 0LL;
          v51->__r_.__value_.__l.__cap_ = 0LL;
          v51->__r_.__value_.__r.__words[0] = 0LL;
          std::string v53 = std::string::append(&v154, "ServiceUUID");
          __int128 v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
          v155.__r_.__value_.__l.__cap_ = v53->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v155.__r_.__value_.__l.__data_ = v54;
          v53->__r_.__value_.__l.__size_ = 0LL;
          v53->__r_.__value_.__l.__cap_ = 0LL;
          v53->__r_.__value_.__r.__words[0] = 0LL;
          char v149 = 2;
          strcpy(v148, ", ");
          std::string v55 = std::string::append(&v155, v148, 2uLL);
          __int128 v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
          v156.__r_.__value_.__l.__cap_ = v55->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v156.__r_.__value_.__l.__data_ = v56;
          v55->__r_.__value_.__l.__size_ = 0LL;
          v55->__r_.__value_.__l.__cap_ = 0LL;
          v55->__r_.__value_.__r.__words[0] = 0LL;
          std::string v57 = std::string::append(&v156, "ClientID");
          __int128 v58 = *(_OWORD *)&v57->__r_.__value_.__l.__data_;
          v157.__r_.__value_.__l.__cap_ = v57->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v157.__r_.__value_.__l.__data_ = v58;
          v57->__r_.__value_.__l.__size_ = 0LL;
          v57->__r_.__value_.__l.__cap_ = 0LL;
          v57->__r_.__value_.__r.__words[0] = 0LL;
          char v147 = 2;
          strcpy(v146, ", ");
          uint64_t v59 = std::string::append(&v157, v146, 2uLL);
          __int128 v60 = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
          v158.__r_.__value_.__l.__cap_ = v59->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v158.__r_.__value_.__l.__data_ = v60;
          v59->__r_.__value_.__l.__size_ = 0LL;
          v59->__r_.__value_.__l.__cap_ = 0LL;
          v59->__r_.__value_.__r.__words[0] = 0LL;
          int v61 = std::string::append(&v158, "LastActiveTimestamp");
          __int128 v62 = *(_OWORD *)&v61->__r_.__value_.__l.__data_;
          v159.__r_.__value_.__l.__cap_ = v61->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v159.__r_.__value_.__l.__data_ = v62;
          v61->__r_.__value_.__l.__size_ = 0LL;
          v61->__r_.__value_.__l.__cap_ = 0LL;
          v61->__r_.__value_.__r.__words[0] = 0LL;
          unint64_t v63 = (char *)operator new(0x28uLL);
          strcpy(v63, ", ROW_NUMBER() OVER (PARTITION BY ");
          char v64 = std::string::append(&v159, v63, 0x22uLL);
          __int128 v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
          v160.__r_.__value_.__l.__cap_ = v64->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v160.__r_.__value_.__l.__data_ = v65;
          v64->__r_.__value_.__l.__size_ = 0LL;
          v64->__r_.__value_.__l.__cap_ = 0LL;
          v64->__r_.__value_.__r.__words[0] = 0LL;
          int v66 = std::string::append(&v160, "ClientID");
          __int128 v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
          v161.__r_.__value_.__l.__cap_ = v66->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v161.__r_.__value_.__l.__data_ = v67;
          v66->__r_.__value_.__l.__size_ = 0LL;
          v66->__r_.__value_.__l.__cap_ = 0LL;
          v66->__r_.__value_.__r.__words[0] = 0LL;
          char v145 = 10;
          strcpy((char *)v144, " ORDER BY ");
          unint64_t v68 = std::string::append(&v161, (const std::string::value_type *)v144, 0xAuLL);
          __int128 v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
          v162.__r_.__value_.__l.__cap_ = v68->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v162.__r_.__value_.__l.__data_ = v69;
          v68->__r_.__value_.__l.__size_ = 0LL;
          v68->__r_.__value_.__l.__cap_ = 0LL;
          v68->__r_.__value_.__r.__words[0] = 0LL;
          unint64_t v70 = std::string::append(&v162, "LastActiveTimestamp");
          __int128 v71 = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
          v188.__r_.__value_.__l.__cap_ = v70->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v188.__r_.__value_.__l.__data_ = v71;
          v70->__r_.__value_.__l.__size_ = 0LL;
          v70->__r_.__value_.__l.__cap_ = 0LL;
          v70->__r_.__value_.__r.__words[0] = 0LL;
          HIBYTE(v143[2]) = 18;
          strcpy((char *)v143, " DESC) AS rn FROM ");
          __int16 v72 = std::string::append(&v188, (const std::string::value_type *)v143, 0x12uLL);
          __int128 v73 = *(_OWORD *)&v72->__r_.__value_.__l.__data_;
          v163.__r_.__value_.__l.__cap_ = v72->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v163.__r_.__value_.__l.__data_ = v73;
          v72->__r_.__value_.__l.__size_ = 0LL;
          v72->__r_.__value_.__l.__cap_ = 0LL;
          v72->__r_.__value_.__r.__words[0] = 0LL;
          uint64_t v74 = std::string::append(&v163, "MiLoServices");
          __int128 v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
          v164.__r_.__value_.__l.__cap_ = v74->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v164.__r_.__value_.__l.__data_ = v75;
          v74->__r_.__value_.__l.__size_ = 0LL;
          v74->__r_.__value_.__l.__cap_ = 0LL;
          v74->__r_.__value_.__r.__words[0] = 0LL;
          char v142 = 7;
          strcpy(v141, " WHERE ");
          uint64_t v76 = std::string::append(&v164, v141, 7uLL);
          __int128 v77 = *(_OWORD *)&v76->__r_.__value_.__l.__data_;
          v165.__r_.__value_.__l.__cap_ = v76->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v165.__r_.__value_.__l.__data_ = v77;
          v76->__r_.__value_.__l.__size_ = 0LL;
          v76->__r_.__value_.__l.__cap_ = 0LL;
          v76->__r_.__value_.__r.__words[0] = 0LL;
          int v78 = std::string::append(&v165, "ServiceType");
          __int128 v79 = *(_OWORD *)&v78->__r_.__value_.__l.__data_;
          v166.__r_.__value_.__l.__cap_ = v78->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v166.__r_.__value_.__l.__data_ = v79;
          v78->__r_.__value_.__l.__size_ = 0LL;
          v78->__r_.__value_.__l.__cap_ = 0LL;
          v78->__r_.__value_.__r.__words[0] = 0LL;
          char v140 = 1;
          strcpy(v139, "=");
          std::string v80 = std::string::append(&v166, v139, 1uLL);
          __int128 v81 = *(_OWORD *)&v80->__r_.__value_.__l.__data_;
          v167.__r_.__value_.__l.__cap_ = v80->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v167.__r_.__value_.__l.__data_ = v81;
          v80->__r_.__value_.__l.__size_ = 0LL;
          v80->__r_.__value_.__l.__cap_ = 0LL;
          v80->__r_.__value_.__r.__words[0] = 0LL;
          if (v171 >= 0) {
            uint64_t v82 = __p;
          }
          else {
            uint64_t v82 = (void **)__p[0];
          }
          if (v171 >= 0) {
            std::string::size_type v83 = HIBYTE(v171);
          }
          else {
            std::string::size_type v83 = (std::string::size_type)__p[1];
          }
          uint64_t v84 = std::string::append(&v167, (const std::string::value_type *)v82, v83);
          __int128 v85 = *(_OWORD *)&v84->__r_.__value_.__l.__data_;
          v168.__r_.__value_.__l.__cap_ = v84->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v168.__r_.__value_.__l.__data_ = v85;
          v84->__r_.__value_.__l.__size_ = 0LL;
          v84->__r_.__value_.__l.__cap_ = 0LL;
          v84->__r_.__value_.__r.__words[0] = 0LL;
          char v138 = 4;
          strcpy(v137, ") t ");
          uint64_t v86 = std::string::append(&v168, v137, 4uLL);
          __int128 v87 = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__l.__cap_ = v86->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v87;
          v86->__r_.__value_.__l.__size_ = 0LL;
          v86->__r_.__value_.__l.__cap_ = 0LL;
          v86->__r_.__value_.__r.__words[0] = 0LL;
          char v136 = 11;
          strcpy((char *)v135, "WHERE rn > ");
          uint64_t v88 = std::string::append(&v169, (const std::string::value_type *)v135, 0xBuLL);
          __int128 v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
          buf[0].__r_.__value_.__l.__cap_ = v88->__r_.__value_.__l.__cap_;
          *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v89;
          v88->__r_.__value_.__l.__size_ = 0LL;
          v88->__r_.__value_.__l.__cap_ = 0LL;
          v88->__r_.__value_.__r.__words[0] = 0LL;
          if (v173 >= 0) {
            uint64_t v90 = (const std::string::value_type *)&v172;
          }
          else {
            uint64_t v90 = (const std::string::value_type *)v172;
          }
          if (v173 >= 0) {
            std::string::size_type v91 = HIBYTE(v173);
          }
          else {
            std::string::size_type v91 = *((void *)&v172 + 1);
          }
          uint64_t v92 = std::string::append(buf, v90, v91);
          __int128 v93 = *(_OWORD *)&v92->__r_.__value_.__l.__data_;
          *(void *)&v189[16] = v92->__r_.__value_.__l.__cap_;
          *(_OWORD *)int v189 = v93;
          v92->__r_.__value_.__l.__size_ = 0LL;
          v92->__r_.__value_.__l.__cap_ = 0LL;
          v92->__r_.__value_.__r.__words[0] = 0LL;
          if (v136 < 0) {
            operator delete(v135[0]);
          }
          if (v138 < 0) {
            operator delete(*(void **)v137);
          }
          if (v140 < 0) {
            operator delete(*(void **)v139);
          }
          if (v142 < 0) {
            operator delete(*(void **)v141);
          }
          if (SHIBYTE(v143[2]) < 0) {
            operator delete(v143[0]);
          }
          if (v145 < 0) {
            operator delete(v144[0]);
          }
          operator delete(v63);
          if (v147 < 0) {
            operator delete(*(void **)v146);
          }
          if (v149 < 0) {
            operator delete(*(void **)v148);
          }
          if (v151 < 0) {
            operator delete(*(void **)__s);
          }
          v165.__r_.__value_.__s.__size_ = 12;
          strcpy((char *)&v165, "DELETE FROM ");
          __int128 v94 = std::string::append(&v165, "MiLoServices");
          __int128 v95 = *(_OWORD *)&v94->__r_.__value_.__l.__data_;
          v166.__r_.__value_.__l.__cap_ = v94->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v166.__r_.__value_.__l.__data_ = v95;
          v94->__r_.__value_.__l.__size_ = 0LL;
          v94->__r_.__value_.__l.__cap_ = 0LL;
          v94->__r_.__value_.__r.__words[0] = 0LL;
          v164.__r_.__value_.__s.__size_ = 8;
          strcpy((char *)&v164, " WHERE (");
          std::string v96 = std::string::append(&v166, (const std::string::value_type *)&v164, 8uLL);
          __int128 v97 = *(_OWORD *)&v96->__r_.__value_.__l.__data_;
          v167.__r_.__value_.__l.__cap_ = v96->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v167.__r_.__value_.__l.__data_ = v97;
          v96->__r_.__value_.__l.__size_ = 0LL;
          v96->__r_.__value_.__l.__cap_ = 0LL;
          v96->__r_.__value_.__r.__words[0] = 0LL;
          std::string v98 = std::string::append(&v167, "ServiceUUID");
          __int128 v99 = *(_OWORD *)&v98->__r_.__value_.__l.__data_;
          v168.__r_.__value_.__l.__cap_ = v98->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v168.__r_.__value_.__l.__data_ = v99;
          v98->__r_.__value_.__l.__size_ = 0LL;
          v98->__r_.__value_.__l.__cap_ = 0LL;
          v98->__r_.__value_.__r.__words[0] = 0LL;
          int v100 = std::string::append(&v168, ") IN (");
          __int128 v101 = *(_OWORD *)&v100->__r_.__value_.__l.__data_;
          v169.__r_.__value_.__l.__cap_ = v100->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v169.__r_.__value_.__l.__data_ = v101;
          v100->__r_.__value_.__l.__size_ = 0LL;
          v100->__r_.__value_.__l.__cap_ = 0LL;
          v100->__r_.__value_.__r.__words[0] = 0LL;
          if (v189[23] >= 0) {
            uint64_t v102 = v189;
          }
          else {
            uint64_t v102 = *(const std::string::value_type **)v189;
          }
          if (v189[23] >= 0) {
            std::string::size_type v103 = v189[23];
          }
          else {
            std::string::size_type v103 = *(void *)&v189[8];
          }
          __int128 v104 = std::string::append(&v169, v102, v103);
          __int128 v105 = *(_OWORD *)&v104->__r_.__value_.__l.__data_;
          buf[0].__r_.__value_.__l.__cap_ = v104->__r_.__value_.__l.__cap_;
          *(_OWORD *)&buf[0].__r_.__value_.__l.__data_ = v105;
          v104->__r_.__value_.__l.__size_ = 0LL;
          v104->__r_.__value_.__l.__cap_ = 0LL;
          v104->__r_.__value_.__r.__words[0] = 0LL;
          v163.__r_.__value_.__s.__size_ = 2;
          strcpy((char *)&v163, ");");
          __int128 v106 = std::string::append(buf, (const std::string::value_type *)&v163, 2uLL);
          char v107 = (void *)v106->__r_.__value_.__r.__words[0];
          v188.__r_.__value_.__r.__words[0] = v106->__r_.__value_.__l.__size_;
          *(std::string::size_type *)((char *)v188.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v106->__r_.__value_.__r.__words[1] + 7);
          unsigned __int8 v108 = v106->__r_.__value_.__s.__size_;
          v106->__r_.__value_.__l.__size_ = 0LL;
          v106->__r_.__value_.__l.__cap_ = 0LL;
          v106->__r_.__value_.__r.__words[0] = 0LL;
          if (SHIBYTE(v186) < 0) {
            operator delete(v185);
          }
          uint64_t v185 = v107;
          *(void *)&__int128 v186 = v188.__r_.__value_.__r.__words[0];
          *(void *)((char *)&v186 + 7) = *(std::string::size_type *)((char *)v188.__r_.__value_.__r.__words + 7);
          HIBYTE(v186) = v108;
          char v109 = v186 >= 0 ? (char *)&v185 : (char *)v185;
          sub_1003C0D54(*v133, v109, buf);
          std::string::size_type v110 = buf[0].__r_.__value_.__r.__words[0];
          int v111 = (sqlite3_stmt *)sub_100019240((uint64_t)buf[0].__r_.__value_.__l.__data_);
          if (!v111) {
            break;
          }
          if (!sub_1003BB2BC(*v133, v111))
          {
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181F268);
            }
            char v126 = (os_log_s *)qword_1019348D8;
            if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v126,  OS_LOG_TYPE_ERROR,  "Failed to run services maintenance",  (uint8_t *)buf,  2u);
            }

            if (!sub_1002921D0(115, 0)) {
              goto LABEL_262;
            }
            bzero(buf, 0x65CuLL);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181F268);
            }
            LOWORD(v169.__r_.__value_.__l.__data_) = 0;
            LODWORD(v132) = 2;
            __int16 v125 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Failed to run services maintenance",  &v169,  v132);
            sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMiLoServiceTable::deleteOldestsServicesPerClientAboveMaxCount()",  "%s\n",  (const char *)v125);
LABEL_295:
            if (v125 != buf) {
              free(v125);
            }
            goto LABEL_262;
          }

          if (v110) {
            (*(void (**)(std::string::size_type))(*(void *)v110 + 8LL))(v110);
          }
          if ((v189[23] & 0x80000000) != 0) {
            operator delete(*(void **)v189);
          }
          if (SHIBYTE(v173) < 0) {
            operator delete((void *)v172);
          }
          if (SHIBYTE(v171) < 0) {
            operator delete(__p[0]);
          }
          v46 += 48;
          if (v46 == v134) {
            goto LABEL_203;
          }
        }

        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F268);
        }
        uint64_t v124 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v124,  OS_LOG_TYPE_ERROR,  "Error getting a prepared statement",  (uint8_t *)buf,  2u);
        }

        if (sub_1002921D0(115, 0))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181F268);
          }
          LOWORD(v169.__r_.__value_.__l.__data_) = 0;
          LODWORD(v132) = 2;
          __int16 v125 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Error getting a prepared statement",  &v169,  v132);
          sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMiLoServiceTable::deleteOldestsServicesPerClientAboveMaxCount()",  "%s\n",  (const char *)v125);
          goto LABEL_295;
        }

LABEL_262:
        if (v110) {
          (*(void (**)(std::string::size_type))(*(void *)v110 + 8LL))(v110);
        }
        if ((v189[23] & 0x80000000) != 0) {
          operator delete(*(void **)v189);
        }
        if (SHIBYTE(v173) < 0) {
          operator delete((void *)v172);
        }
        if (SHIBYTE(v171) < 0) {
          operator delete(__p[0]);
        }
        uint64_t v121 = 0LL;
      }

      buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v182;
      sub_100100C40((void ***)buf);
      if (SHIBYTE(v186) < 0) {
        operator delete(v185);
      }
    }

    buf[0].__r_.__value_.__r.__words[0] = (std::string::size_type)&v187;
    sub_100100B70((void ***)buf);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F268);
    }
    int v120 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0].__r_.__value_.__l.__data_) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v120,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so service maintenance will not run and nothing will be deleted",  (uint8_t *)buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      LOWORD(__p[0]) = 0;
      char v128 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Table is not valid so service maintenance will not run and nothing will be deleted",  __p,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMiLoServiceTable::deleteOldestsServicesPerClientAboveMaxCount()",  "%s\n",  (const char *)v128);
      if (v128 != buf) {
        free(v128);
      }
    }

    return 0LL;
  }

  return v121;
}

  __int128 v54 = 0;
LABEL_263:
  sub_100BDC958((uint64_t)v200);
LABEL_264:
  sub_100EB2B00((uint64_t)&v174);
LABEL_135:
  __int128 v58 = (uint64_t **)(a1 + 256);
  sub_1000F2F30((void *)(a1 + 256), (uint64_t *)&v181);
  uint64_t v59 = v184;
  *(_OWORD *)(a1 + 272) = v183;
  *(_OWORD *)(a1 + 28++*(void *)(result + 8) = v59;
  *(double *)(a1 + 304) = v185;
  *(_OWORD *)(a1 + 312) = v186[0];
  *(_OWORD *)(a1 + 321) = *(_OWORD *)((char *)v186 + 9);
  *(_BYTE *)(a1 + 882) = 1;
  __int128 v60 = *(_BYTE *)(v6 + 152);
  if (v60)
  {
    __int128 v60 = *(_BYTE *)(v6 + 153);
    if (v60) {
      __int128 v60 = *(_DWORD *)(v6 + 1044) > (int)(-1227133513 * ((*(void *)(v6 + 1072) - *(void *)(v6 + 1064)) >> 4));
    }
  }

  *(_BYTE *)(a1 + 36++*(void *)(result + 8) = v60;
  if (!*(void *)(a1 + 256))
  {
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_10188A8E0);
    }
    __int128 v93 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134349056;
      *(double *)&uint8_t buf[4] = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v93,  OS_LOG_TYPE_ERROR,  "CLMMPED,%{public}.1lf,Unexpected,best particle road is nullptr",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_216;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_10188A8E0);
    }
    LODWORD(v200[0]) = 134349056;
    *(double *)((char *)v200 + 4) = v2;
    LODWORD(v169) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  16LL,  "CLMMPED,%{public}.1lf,Unexpected,best particle road is nullptr",  v200,  v169);
    __int128 v95 = (uint8_t *)v94;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLParticleMM::MMFilterData::extractSolution(const MMSnapData &)",  "%s\n",  v94);
    goto LABEL_298;
  }

  int v61 = (_OWORD *)(a1 + 376);
  int v170 = (double *)(a1 + 312);
  if (*(_BYTE *)(a1 + 896)
    && (sub_100D5DAC4((uint64_t *)(a1 + 256), (uint64_t)buf),
        __int128 v62 = (uint64_t *)(v6 + 128),
        sub_100BDA328(v6 + 128, (uint64_t)buf)))
  {
    unint64_t v63 = *(_OWORD *)(v6 + 600);
    char v64 = *(_OWORD *)(v6 + 616);
    __int128 v65 = *(_OWORD *)(v6 + 648);
    *(_OWORD *)(a1 + 40++*(void *)(result + 8) = *(_OWORD *)(v6 + 632);
    *(_OWORD *)(a1 + 424) = v65;
    *int v61 = v63;
    *(_OWORD *)(a1 + 392) = v64;
    int v66 = *(_OWORD *)(v6 + 664);
    __int128 v67 = *(_OWORD *)(v6 + 680);
    unint64_t v68 = *(_OWORD *)(v6 + 712);
    *(_OWORD *)(a1 + 472) = *(_OWORD *)(v6 + 696);
    *(_OWORD *)(a1 + 48++*(void *)(result + 8) = v68;
    *(_OWORD *)(a1 + 440) = v66;
    *(_OWORD *)(a1 + 456) = v67;
    std::string::operator=((std::string *)(a1 + 504), (const std::string *)(v6 + 728));
    memcpy((void *)(a1 + 528), (const void *)(v6 + 752), 0x118uLL);
    if (*(void *)(v6 + 8))
    {
      __int128 v69 = (void *)(a1 + 864);
      sub_1000F2F30(v171, v172);
      *(_BYTE *)(a1 + 880) = *(_BYTE *)(v6 + 28);
    }

    else
    {
      if (qword_1019348B0 != -1) {
        dispatch_once(&qword_1019348B0, &stru_10188A8E0);
      }
      std::string v96 = (os_log_s *)qword_1019348B8;
      if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 134349056;
        *(double *)&uint8_t buf[4] = v2;
      }

      __int128 v69 = (void *)(a1 + 864);
      if (sub_1002921D0(115, 0))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348B0 != -1) {
          dispatch_once(&qword_1019348B0, &stru_10188A8E0);
        }
        LODWORD(v200[0]) = 134349056;
        *(double *)((char *)v200 + 4) = v2;
        LODWORD(v169) = 12;
        std::string v160 = (uint8_t *)v159;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLParticleMM::MMFilterData::extractSolution(const MMSnapData &)",  "%s\n",  v159);
        if (v160 != buf) {
          free(v160);
        }
        __int128 v69 = (void *)(a1 + 864);
      }
    }

    if (*v69)
    {
      if (qword_1019348B0 != -1) {
        dispatch_once(&qword_1019348B0, &stru_10188A8E0);
      }
      __int128 v97 = (os_log_s *)qword_1019348B8;
      if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
      {
        std::string v98 = **v171;
        __int128 v99 = *v62;
        int v100 = *(void *)v170;
        *(_DWORD *)__int128 buf = 134349825;
        *(double *)&uint8_t buf[4] = v2;
        *(_WORD *)&buf[12] = 2049;
        *(void *)&buf[14] = v98;
        *(_WORD *)&buf[22] = 2049;
        *(void *)&_BYTE buf[24] = v99;
        *(_WORD *)&uint8_t buf[32] = 2050;
        *(void *)&uint8_t buf[34] = v100;
        _os_log_impl( (void *)&_mh_execute_header,  v97,  OS_LOG_TYPE_DEBUG,  "CLMMPED,%{public}.1lf,Using outgoing,incomingID,%{private}lld,outgoingID,%{private}lld,score,%{public}.8lf",  buf,  0x2Au);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_1019348B0 != -1) {
          dispatch_once(&qword_1019348B0, &stru_10188A8E0);
        }
        std::string v154 = **v171;
        std::string v155 = *v62;
        std::string v156 = *(void *)v170;
        LODWORD(v200[0]) = 134349825;
        *(double *)((char *)v200 + 4) = v2;
        WORD2(v200[1]) = 2049;
        *(void *)((char *)&v200[1] + 6) = v154;
        HIWORD(v200[2]) = 2049;
        *(void *)__int128 v201 = v155;
        *(_WORD *)&v201[8] = 2050;
        *(void *)&v201[10] = v156;
        LODWORD(v169) = 42;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMMPED,%{public}.1lf,Using outgoing,incomingID,%{private}lld,outgoingID,%{private}lld,score,%{public}.8lf",  v200,  v169);
        std::string v158 = (uint8_t *)v157;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMM::MMFilterData::extractSolution(const MMSnapData &)",  "%s\n",  v157);
        if (v158 != buf) {
          free(v158);
        }
      }
    }
  }

  else
  {
    __int128 v87 = *(_OWORD *)(v6 + 168);
    uint64_t v88 = *(_OWORD *)(v6 + 184);
    __int128 v89 = *(_OWORD *)(v6 + 216);
    *(_OWORD *)(a1 + 40++*(void *)(result + 8) = *(_OWORD *)(v6 + 200);
    *(_OWORD *)(a1 + 424) = v89;
    *int v61 = v87;
    *(_OWORD *)(a1 + 392) = v88;
    uint64_t v90 = *(_OWORD *)(v6 + 232);
    std::string::size_type v91 = *(_OWORD *)(v6 + 248);
    uint64_t v92 = *(_OWORD *)(v6 + 280);
    *(_OWORD *)(a1 + 472) = *(_OWORD *)(v6 + 264);
    *(_OWORD *)(a1 + 48++*(void *)(result + 8) = v92;
    *(_OWORD *)(a1 + 440) = v90;
    *(_OWORD *)(a1 + 456) = v91;
    std::string::operator=((std::string *)(a1 + 504), (const std::string *)(v6 + 296));
    memcpy((void *)(a1 + 528), (const void *)(v6 + 320), 0x118uLL);
  }

  *(_BYTE *)(a1 + 881) = 0;
  memset(v227, 0, 64);
  memset(buf, 0, sizeof(buf));
  buf[20] = 1;
  *(_DWORD *)&_BYTE buf[24] = 0;
  sub_10005F550(a1 + 136, (__int128 *)buf);
  __int128 v101 = *(void **)(a1 + 224);
  uint64_t v102 = *(_OWORD *)&buf[32];
  *(_OWORD *)(a1 + 152) = *(_OWORD *)&buf[16];
  *(_OWORD *)(a1 + 16++*(void *)(result + 8) = v102;
  *(void *)(a1 + 184) = *(void *)&v227[0];
  *(_OWORD *)(a1 + 192) = *(_OWORD *)((char *)v227 + 8);
  *(_OWORD *)(a1 + 201) = *(_OWORD *)((char *)&v227[1] + 1);
  if (v101)
  {
    *(void *)(a1 + 232) = v101;
    operator delete(v101);
    *(void *)(a1 + sub_1000A7938(v46 - 224) = 0LL;
    *(void *)(a1 + 232) = 0LL;
    *(void *)(a1 + 240) = 0LL;
  }

  *(_OWORD *)(a1 + sub_1000A7938(v46 - 224) = *(_OWORD *)((char *)&v227[2] + 8);
  std::string::size_type v103 = *(std::__shared_weak_count **)&buf[8];
  *(void *)(a1 + 240) = *((void *)&v227[3] + 1);
  memset((char *)&v227[2] + 8, 0, 24);
  if (v103)
  {
    p_shared_owners = (unint64_t *)&v103->__shared_owners_;
    do
      __int128 v105 = __ldaxr(p_shared_owners);
    while (__stlxr(v105 - 1, p_shared_owners));
    if (!v105)
    {
      ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
      std::__shared_weak_count::__release_weak(v103);
    }
  }

  *(void *)(a1 + 2sub_10000AE14(v17 - 48) = 0xBFF0000000000000LL;
  *(_BYTE *)(a1 + 8sub_10000AE14(v17 - 48) = sub_100EB2B70(a1, (double *)a2) ^ 1;
  *(void *)(a1 + 88++*(void *)(result + 8) = *(void *)(a1 + 96);
  memset(v200, 0, sizeof(v200));
  *(_OWORD *)__int128 v201 = xmmword_1012E0070;
  v201[16] = 0;
  unint64_t v202 = 0u;
  unint64_t v203 = 0u;
  __asm { FMOV            V0.2D, #-1.0 }

  int v204 = _Q0;
  int v205 = _Q0;
  __int128 v206 = _Q0;
  __int128 v207 = _Q0;
  __int128 v208 = 0xBFF0000000000000LL;
  __int128 v209 = 0;
  v210 = _Q0;
  int v211 = _Q0;
  v212 = _Q0;
  sub_100EB27E0((uint64_t)v200, a1 + 376, *(unsigned __int8 *)(a1 + 904), 1.0);
  if (v54)
  {
    *((void *)&v205 + 1) = 0xBFF0000000000000LL;
    *((void *)&v206 + 1) = 0xBFF0000000000000LL;
  }

  std::string v174 = 0LL;
  std::string v175 = 0LL;
  std::string v176 = 0LL;
  std::string v177 = 0x3FF0000000000000LL;
  std::string v178 = 0u;
  std::string v179 = 0u;
  std::string v180 = 0;
  if (!sub_100EAE708((double *)a1, (uint64_t)v200, (double *)(a1 + 256), (uint64_t)&v174))
  {
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_10188A8E0);
    }
    std::string::size_type v113 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 134349056;
      *(double *)&uint8_t buf[4] = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v113,  OS_LOG_TYPE_ERROR,  "CLMMPED,%{public}.1lf,Unexpected,unable to calculate score",  buf,  0xCu);
    }

    if (!sub_1002921D0(115, 0)) {
      goto LABEL_216;
    }
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_10188A8E0);
    }
    *(_DWORD *)v213 = 134349056;
    *(double *)&v213[4] = v2;
    LODWORD(v169) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  16LL,  "CLMMPED,%{public}.1lf,Unexpected,unable to calculate score",  v213,  v169);
    __int128 v95 = (uint8_t *)v114;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLParticleMM::MMFilterData::extractSolution(const MMSnapData &)",  "%s\n",  v114);
    goto LABEL_298;
  }

  std::string v180 = 1;
  std::string v177 = 0x3FF0000000000000LL;
  sub_100EB2834((void *)(a1 + 256), (uint64_t)&v174);
  sub_100D72794((double *)(a1 + 256));
  if (sub_100EA92D8(a1 + 136))
  {
    *(_DWORD *)(a1 + 556) = 0;
    char v107 = sub_100EAC9A8((uint64_t *)(a1 + 104));
    if (v107 > 0.0)
    {
      unsigned __int8 v108 = *(double *)(a1 + 312) / v107;
      if (v108 > 1000000.0) {
        unsigned __int8 v108 = 1000000.0;
      }
      char v109 = v108;
      *(float *)(a1 + 556) = v109;
    }

    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_10188A8E0);
    }
    std::string::size_type v110 = (os_log_s *)qword_1019348B8;
    if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_DEBUG))
    {
      int v111 = **v58;
      int v112 = *(void *)v170;
      *(_DWORD *)__int128 buf = 134349569;
      *(double *)&uint8_t buf[4] = v2;
      *(_WORD *)&buf[12] = 2049;
      *(void *)&buf[14] = v111;
      *(_WORD *)&buf[22] = 2050;
      *(void *)&_BYTE buf[24] = v112;
      _os_log_impl( (void *)&_mh_execute_header,  v110,  OS_LOG_TYPE_DEBUG,  "CLMMPED,%{public}.1lf,bestParticleRoadID,%{private}lld,score,%{public}.8lf",  buf,  0x20u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348B0 != -1) {
        dispatch_once(&qword_1019348B0, &stru_10188A8E0);
      }
      int v150 = **v58;
      char v151 = *v170;
      *(_DWORD *)v213 = 134349569;
      *(double *)&v213[4] = v2;
      *(_WORD *)&v213[12] = 2049;
      *(void *)&v213[14] = v150;
      v214 = 2050;
      unint64_t v215 = v151;
      LODWORD(v169) = 32;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  2LL,  "CLMMPED,%{public}.1lf,bestParticleRoadID,%{private}lld,score,%{public}.8lf",  v213,  v169);
      std::string v153 = (uint8_t *)v152;
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLParticleMM::MMFilterData::extractSolution(const MMSnapData &)",  "%s\n",  v152);
      if (v153 != buf) {
        free(v153);
      }
    }

    int v18 = 1LL;
    goto LABEL_217;
  }

  if (qword_1019348B0 != -1) {
    dispatch_once(&qword_1019348B0, &stru_10188A8E0);
  }
  __int128 v115 = (os_log_s *)qword_1019348B8;
  if (os_log_type_enabled((os_log_t)qword_1019348B8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 134349056;
    *(double *)&uint8_t buf[4] = v2;
    _os_log_impl( (void *)&_mh_execute_header,  v115,  OS_LOG_TYPE_ERROR,  "CLMMPED,%{public}.1lf,Unexpected,unable to fill crumb",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348B0 != -1) {
      dispatch_once(&qword_1019348B0, &stru_10188A8E0);
    }
    *(_DWORD *)v213 = 134349056;
    *(double *)&v213[4] = v2;
    LODWORD(v169) = 12;
    _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348B8,  16LL,  "CLMMPED,%{public}.1lf,Unexpected,unable to fill crumb",  v213,  v169);
    __int128 v95 = (uint8_t *)v149;
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLParticleMM::MMFilterData::extractSolution(const MMSnapData &)",  "%s\n",  v149);
LABEL_298:
    if (v95 != buf) {
      free(v95);
    }
  }

          *(_DWORD *)(a1 + 92) = v66;
          goto LABEL_238;
        case 0xBu:
          *(_DWORD *)(a1 + 152) |= 0x4000u;
          __int128 v69 = *((void *)this + 1);
          unint64_t v70 = *((void *)this + 2);
          __int128 v71 = *(void *)this;
          if (v69 <= 0xFFFFFFFFFFFFFFF5LL && v69 + 10 <= v70)
          {
            __int16 v72 = 0;
            __int128 v73 = 0;
            uint64_t v74 = 0LL;
            do
            {
              __int128 v75 = v69 + 1;
              *((void *)this + 1) = v69 + 1;
              uint64_t v76 = *(_BYTE *)(v71 + v69);
              v74 |= (unint64_t)(v76 & 0x7F) << v72;
              if ((v76 & 0x80) == 0) {
                goto LABEL_266;
              }
              v72 += 7;
              __int128 v69 = v75;
              uint64_t v14 = v73++ > 8;
            }

            while (!v14);
LABEL_200:
            LODWORD(v74) = 0;
            goto LABEL_266;
          }

          char v151 = 0;
          std::string v152 = 0;
          uint64_t v74 = 0LL;
          if (v70 <= v69) {
            unint64_t v70 = *((void *)this + 1);
          }
          while (2)
          {
            if (v70 == v69)
            {
              LODWORD(v74) = 0;
              *((_BYTE *)this + 24) = 1;
            }

            else
            {
              std::string v153 = v69 + 1;
              std::string v154 = *(_BYTE *)(v71 + v69);
              *((void *)this + 1) = v153;
              v74 |= (unint64_t)(v154 & 0x7F) << v151;
              if (v154 < 0)
              {
                v151 += 7;
                __int128 v69 = v153;
                uint64_t v14 = v152++ > 8;
                if (v14) {
                  goto LABEL_200;
                }
                continue;
              }

              if (*((_BYTE *)this + 24)) {
                LODWORD(v74) = 0;
              }
            }

            break;
          }

void sub_1000FE018(_Unwind_Exception *a1)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  if (SLOBYTE(STACK[0x4B7]) < 0) {
    operator delete((void *)STACK[0x4A0]);
  }
  sub_1000A56E8((uint64_t)&STACK[0x340]);
  STACK[0x4C0] = (unint64_t)&STACK[0x430];
  sub_100100C40((void ***)&STACK[0x4C0]);
  if (SLOBYTE(STACK[0x45F]) < 0) {
    operator delete((void *)STACK[0x448]);
  }
  STACK[0x4C0] = (unint64_t)&STACK[0x460];
  sub_100100B70((void ***)&STACK[0x4C0]);
  _Unwind_Resume(a1);
}

void sub_1000FE608(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  v36.__r_.__value_.__s.__size_ = 7;
  strcpy((char *)&v36, "SELECT ");
  __int128 v4 = std::string::append(&v36, "ClientID");
  __int128 v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v37.__r_.__value_.__l.__cap_ = v4->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v37.__r_.__value_.__l.__data_ = v5;
  v4->__r_.__value_.__l.__size_ = 0LL;
  v4->__r_.__value_.__l.__cap_ = 0LL;
  v4->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v6 = std::string::append(&v37, ", ");
  __int128 v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v38.__r_.__value_.__l.__cap_ = v6->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0LL;
  v6->__r_.__value_.__l.__cap_ = 0LL;
  v6->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v8 = std::string::append(&v38, "ServiceType");
  __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v39.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v39.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0LL;
  v8->__r_.__value_.__l.__cap_ = 0LL;
  v8->__r_.__value_.__r.__words[0] = 0LL;
  CFStringRef v10 = std::string::append(&v39, ", ");
  __int128 v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v40.__r_.__value_.__l.__cap_ = v10->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0LL;
  v10->__r_.__value_.__l.__cap_ = 0LL;
  v10->__r_.__value_.__r.__words[0] = 0LL;
  unint64_t v12 = (char *)operator new(0x20uLL);
  strcpy(v12, "COUNT(*) as RowCount FROM ");
  __int128 v13 = std::string::append(&v40, v12, 0x1AuLL);
  __int128 v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v41.__r_.__value_.__l.__cap_ = v13->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v41.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0LL;
  v13->__r_.__value_.__l.__cap_ = 0LL;
  v13->__r_.__value_.__r.__words[0] = 0LL;
  unint64_t v15 = std::string::append(&v41, "MiLoServices");
  __int128 v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__l.__cap_ = v15->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0LL;
  v15->__r_.__value_.__l.__cap_ = 0LL;
  v15->__r_.__value_.__r.__words[0] = 0LL;
  char v35 = 10;
  strcpy(__s, " GROUP BY ");
  CFStringRef v17 = std::string::append(&v42, __s, 0xAuLL);
  __int128 v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v43.__r_.__value_.__l.__cap_ = v17->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0LL;
  v17->__r_.__value_.__l.__cap_ = 0LL;
  v17->__r_.__value_.__r.__words[0] = 0LL;
  unint64_t v19 = std::string::append(&v43, "ClientID");
  __int128 v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v49.__r_.__value_.__l.__cap_ = v19->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v20;
  v19->__r_.__value_.__l.__size_ = 0LL;
  v19->__r_.__value_.__l.__cap_ = 0LL;
  v19->__r_.__value_.__r.__words[0] = 0LL;
  char v33 = 2;
  strcpy(v32, ", ");
  unint64_t v21 = std::string::append(&v49, v32, 2uLL);
  __int128 v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__l.__cap_ = v21->__r_.__value_.__l.__cap_;
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0LL;
  v21->__r_.__value_.__l.__cap_ = 0LL;
  v21->__r_.__value_.__r.__words[0] = 0LL;
  unint64_t v23 = std::string::append(&__dst, "ServiceType");
  __int128 v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  int64_t cap = v23->__r_.__value_.__l.__cap_;
  __int128 __p = v24;
  v23->__r_.__value_.__l.__size_ = 0LL;
  v23->__r_.__value_.__l.__cap_ = 0LL;
  v23->__r_.__value_.__r.__words[0] = 0LL;
  if (v33 < 0) {
    operator delete(*(void **)v32);
  }
  if (v35 < 0) {
    operator delete(*(void **)__s);
  }
  operator delete(v12);
  if (cap >= 0) {
    p_p = (char *)&__p;
  }
  else {
    p_p = (char *)__p;
  }
  sub_1003C0D54(*a1, p_p, &__dst);
  std::string::size_type v26 = __dst.__r_.__value_.__r.__words[0];
  int v27 = (sqlite3_stmt *)sub_100019240((uint64_t)__dst.__r_.__value_.__l.__data_);
  while (j__sqlite3_step(v27) == 100)
  {
    sub_100011CB8(v27, 0, &v49);
    unsigned int v28 = sub_1000CC094(v27, 1);
    int v29 = sub_100054CD8(v27, 2);
    else {
      std::string __dst = v49;
    }
    int v47 = v29;
    uint64_t v48 = v28;
    unint64_t v30 = a2[1];
    if (v30 >= a2[2])
    {
      uint64_t v31 = sub_100100D54(a2, (__int128 *)&__dst);
    }

    else
    {
      sub_100100CE8((uint64_t)a2, (__int128 *)&__dst);
      uint64_t v31 = v30 + 40;
    }

    a2[1] = v31;
  }

  sqlite3_reset(v27);
  if (v26) {
    (*(void (**)(std::string::size_type))(*(void *)v26 + 8LL))(v26);
  }
  if (SHIBYTE(cap) < 0) {
    operator delete((void *)__p);
  }
}

void sub_1000FEA88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, void *a33, uint64_t a34, uint64_t a35, uint64_t a36, void *a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, uint64_t a44, void *a45, uint64_t a46, uint64_t a47, uint64_t a48, void *__p, uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t buf)
{
  if (a54 < 0) {
    operator delete(__p);
  }
  sub_100100B70((void ***)&buf);
  _Unwind_Resume(a1);
}

char *sub_1000FEDE8(char *__dst, __int128 *a2, __int128 *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v5 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }

  uint64_t v6 = __dst + 24;
  if (*((char *)a3 + 23) < 0)
  {
    sub_1010DD48C(v6, *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 v7 = *a3;
    *((void *)__dst + 5) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v6 = v7;
  }

  return __dst;
}

void sub_1000FEE60(_Unwind_Exception *exception_object)
{
}

void sub_1000FEE7C()
{
  if (qword_1019348D0 != -1) {
    goto LABEL_11;
  }
  while (1)
  {
    CFStringRef v0 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__int128 buf = 68289539;
      int v4 = 0;
      __int16 v5 = 2082;
      uint64_t v6 = "";
      __int16 v7 = 2082;
      uint64_t v8 = "assert";
      __int16 v9 = 2081;
      CFStringRef v10 = "false";
      _os_log_impl( (void *)&_mh_execute_header,  v0,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Delete Olders rows in service table. Should never be here!, event:%{public, locatio n:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x26u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
    }

    uint64_t v1 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)__int128 buf = 68289539;
      int v4 = 0;
      __int16 v5 = 2082;
      uint64_t v6 = "";
      __int16 v7 = 2082;
      uint64_t v8 = "assert";
      __int16 v9 = 2081;
      CFStringRef v10 = "false";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v1,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Delete Olders rows in service table. Should never be here!",  "{msg%{public}.0s:Delete Olders rows in service table. Should never be here!, event:%{public, locatio n:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x26u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
    }

    std::string::size_type v2 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 68289539;
      int v4 = 0;
      __int16 v5 = 2082;
      uint64_t v6 = "";
      __int16 v7 = 2082;
      uint64_t v8 = "assert";
      __int16 v9 = 2081;
      CFStringRef v10 = "false";
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Delete Olders rows in service table. Should never be here!, event:%{public, locatio n:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x26u);
    }

    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/ServiceManager/CLMiLoServiceTable.mm",  349,  "deleteOldestRows");
LABEL_11:
    dispatch_once(&qword_1019348D0, &stru_10181F268);
  }

BOOL sub_1000FF09C(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  v54[0] = a2;
  v54[1] = a3;
  if (*(_BYTE *)(a1 + 8))
  {
    memset(&v52, 0, sizeof(v52));
    if ((sub_100013090((uint64_t)v54, &v52) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)&v53);
      v53.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101818CB0;
      sub_1000139B0((uint64_t)&v53);
    }

    v47.__r_.__value_.__s.__size_ = 7;
    strcpy((char *)&v47, " WHERE ");
    uint64_t v6 = std::string::append(&v47, "ServiceUUID");
    __int128 v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v48.__r_.__value_.__l.__cap_ = v6->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0LL;
    v6->__r_.__value_.__l.__cap_ = 0LL;
    v6->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v8 = std::string::append(&v48, "= ");
    __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v49.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0LL;
    v8->__r_.__value_.__l.__cap_ = 0LL;
    v8->__r_.__value_.__r.__words[0] = 0LL;
    if ((v52.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      CFStringRef v10 = &v52;
    }
    else {
      CFStringRef v10 = (std::string *)v52.__r_.__value_.__r.__words[0];
    }
    if ((v52.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = v52.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = v52.__r_.__value_.__l.__size_;
    }
    unint64_t v12 = std::string::append(&v49, (const std::string::value_type *)v10, size);
    __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__l.__cap_ = v12->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0LL;
    v12->__r_.__value_.__l.__cap_ = 0LL;
    v12->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v14 = std::string::append(&v53, "");
    __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    int64_t cap = v14->__r_.__value_.__l.__cap_;
    *(_OWORD *)__int128 __p = v15;
    v14->__r_.__value_.__l.__size_ = 0LL;
    v14->__r_.__value_.__l.__cap_ = 0LL;
    v14->__r_.__value_.__r.__words[0] = 0LL;
    v44.__r_.__value_.__s.__size_ = 7;
    strcpy((char *)&v44, "UPDATE ");
    __int128 v16 = std::string::append(&v44, "MiLoServices");
    __int128 v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v45.__r_.__value_.__l.__cap_ = v16->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0LL;
    v16->__r_.__value_.__l.__cap_ = 0LL;
    v16->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v18 = std::string::append(&v45, " SET ");
    __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__l.__cap_ = v18->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v20 = std::string::append(&v46, "LastActiveTimestamp");
    __int128 v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__l.__cap_ = v20->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0LL;
    v20->__r_.__value_.__l.__cap_ = 0LL;
    v20->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v22 = std::string::append(&v47, "=");
    __int128 v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v48.__r_.__value_.__l.__cap_ = v22->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0LL;
    v22->__r_.__value_.__l.__cap_ = 0LL;
    v22->__r_.__value_.__r.__words[0] = 0LL;
    std::to_string(&v43, a4);
    if ((v43.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v24 = &v43;
    }
    else {
      __int128 v24 = (std::string *)v43.__r_.__value_.__r.__words[0];
    }
    if ((v43.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v25 = v43.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v25 = v43.__r_.__value_.__l.__size_;
    }
    std::string::size_type v26 = std::string::append(&v48, (const std::string::value_type *)v24, v25);
    __int128 v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__l.__cap_ = v26->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v27;
    v26->__r_.__value_.__l.__size_ = 0LL;
    v26->__r_.__value_.__l.__cap_ = 0LL;
    v26->__r_.__value_.__r.__words[0] = 0LL;
    if (cap >= 0) {
      unsigned int v28 = __p;
    }
    else {
      unsigned int v28 = (void **)__p[0];
    }
    if (cap >= 0) {
      std::string::size_type v29 = HIBYTE(cap);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)__p[1];
    }
    unint64_t v30 = std::string::append(&v53, (const std::string::value_type *)v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v49.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    if ((v49.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v32 = &v49;
    }
    else {
      int v32 = (std::string *)v49.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)a1, (char *)v32, &v53);
    std::string::size_type v33 = v53.__r_.__value_.__r.__words[0];
    std::string::size_type v34 = (sqlite3_stmt *)sub_100019240((uint64_t)v53.__r_.__value_.__l.__data_);
    if (v34)
    {
      BOOL v35 = sub_1003BB2BC(*(void *)a1, v34);
      if (!v33)
      {
LABEL_49:
        if (SHIBYTE(cap) < 0) {
          operator delete(__p[0]);
        }
        return v35;
      }
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      std::string v38 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v53.__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_ERROR,  "Error getting a prepared statement",  (uint8_t *)&v53,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(&v53, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F268);
        }
        LOWORD(v48.__r_.__value_.__l.__data_) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &v53,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Error getting a prepared statement",  &v48,  2);
        std::string v42 = (std::string *)v41;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMiLoServiceTable::updateServiceLastActiveTime(boost::uuids::uuid, cl::chrono::CFAbsoluteTimeClock::time_point)",  "%s\n",  v41);
        if (v42 != &v53) {
          free(v42);
        }
      }

      BOOL v35 = 0LL;
      if (!v33) {
        goto LABEL_49;
      }
    }

    (*(void (**)(std::string::size_type))(*(void *)v33 + 8LL))(v33);
    goto LABEL_49;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F268);
  }
  std::string v36 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v53.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so we can't update service",  (uint8_t *)&v53,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v53, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F268);
    }
    LOWORD(v52.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v53,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Table is not valid so we can't update service",  &v52,  2);
    std::string v40 = (std::string *)v39;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMiLoServiceTable::updateServiceLastActiveTime(boost::uuids::uuid, cl::chrono::CFAbsoluteTimeClock::time_point)",  "%s\n",  v39);
    if (v40 != &v53) {
      free(v40);
    }
  }

  return 0LL;
}

void sub_1000FF730( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, void *__p, uint64_t a34, int a35, __int16 a36, char a37, char a38, uint64_t a39, void *a40, uint64_t a41, int a42, __int16 a43, char a44, char a45, uint64_t a46, void *a47, uint64_t a48, int a49, __int16 a50,char a51,char a52)
{
  if (v52) {
    (*(void (**)(uint64_t))(*(void *)v52 + 8LL))(v52);
  }
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1000FF8AC(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v54[0] = a2;
  v54[1] = a3;
  if (*(_BYTE *)(a1 + 8))
  {
    memset(&v52, 0, sizeof(v52));
    if ((sub_100013090((uint64_t)v54, &v52) & 1) == 0)
    {
      std::bad_cast::bad_cast((std::bad_cast *)&v53);
      v53.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_101818CB0;
      sub_1000139B0((uint64_t)&v53);
    }

    v47.__r_.__value_.__s.__size_ = 7;
    strcpy((char *)&v47, " WHERE ");
    uint64_t v6 = std::string::append(&v47, "ServiceUUID");
    __int128 v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v48.__r_.__value_.__l.__cap_ = v6->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0LL;
    v6->__r_.__value_.__l.__cap_ = 0LL;
    v6->__r_.__value_.__r.__words[0] = 0LL;
    uint64_t v8 = std::string::append(&v48, "= ");
    __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v49.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0LL;
    v8->__r_.__value_.__l.__cap_ = 0LL;
    v8->__r_.__value_.__r.__words[0] = 0LL;
    if ((v52.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      CFStringRef v10 = &v52;
    }
    else {
      CFStringRef v10 = (std::string *)v52.__r_.__value_.__r.__words[0];
    }
    if ((v52.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = v52.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = v52.__r_.__value_.__l.__size_;
    }
    unint64_t v12 = std::string::append(&v49, (const std::string::value_type *)v10, size);
    __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__l.__cap_ = v12->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0LL;
    v12->__r_.__value_.__l.__cap_ = 0LL;
    v12->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v14 = std::string::append(&v53, "");
    __int128 v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    int64_t cap = v14->__r_.__value_.__l.__cap_;
    *(_OWORD *)__int128 __p = v15;
    v14->__r_.__value_.__l.__size_ = 0LL;
    v14->__r_.__value_.__l.__cap_ = 0LL;
    v14->__r_.__value_.__r.__words[0] = 0LL;
    v44.__r_.__value_.__s.__size_ = 7;
    strcpy((char *)&v44, "UPDATE ");
    __int128 v16 = std::string::append(&v44, "MiLoServices");
    __int128 v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v45.__r_.__value_.__l.__cap_ = v16->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v45.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0LL;
    v16->__r_.__value_.__l.__cap_ = 0LL;
    v16->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v18 = std::string::append(&v45, " SET ");
    __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
    v46.__r_.__value_.__l.__cap_ = v18->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v46.__r_.__value_.__l.__data_ = v19;
    v18->__r_.__value_.__l.__size_ = 0LL;
    v18->__r_.__value_.__l.__cap_ = 0LL;
    v18->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v20 = std::string::append(&v46, "LocationTypes");
    __int128 v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__l.__cap_ = v20->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0LL;
    v20->__r_.__value_.__l.__cap_ = 0LL;
    v20->__r_.__value_.__r.__words[0] = 0LL;
    __int128 v22 = std::string::append(&v47, "=");
    __int128 v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v48.__r_.__value_.__l.__cap_ = v22->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v23;
    v22->__r_.__value_.__l.__size_ = 0LL;
    v22->__r_.__value_.__l.__cap_ = 0LL;
    v22->__r_.__value_.__r.__words[0] = 0LL;
    std::to_string(&v43, a4);
    if ((v43.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v24 = &v43;
    }
    else {
      __int128 v24 = (std::string *)v43.__r_.__value_.__r.__words[0];
    }
    if ((v43.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v25 = v43.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v25 = v43.__r_.__value_.__l.__size_;
    }
    std::string::size_type v26 = std::string::append(&v48, (const std::string::value_type *)v24, v25);
    __int128 v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
    v53.__r_.__value_.__l.__cap_ = v26->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v53.__r_.__value_.__l.__data_ = v27;
    v26->__r_.__value_.__l.__size_ = 0LL;
    v26->__r_.__value_.__l.__cap_ = 0LL;
    v26->__r_.__value_.__r.__words[0] = 0LL;
    if (cap >= 0) {
      unsigned int v28 = __p;
    }
    else {
      unsigned int v28 = (void **)__p[0];
    }
    if (cap >= 0) {
      std::string::size_type v29 = HIBYTE(cap);
    }
    else {
      std::string::size_type v29 = (std::string::size_type)__p[1];
    }
    unint64_t v30 = std::string::append(&v53, (const std::string::value_type *)v28, v29);
    __int128 v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v49.__r_.__value_.__l.__cap_ = v30->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0LL;
    v30->__r_.__value_.__l.__cap_ = 0LL;
    v30->__r_.__value_.__r.__words[0] = 0LL;
    if ((v49.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int v32 = &v49;
    }
    else {
      int v32 = (std::string *)v49.__r_.__value_.__r.__words[0];
    }
    sub_1003C0D54(*(void *)a1, (char *)v32, &v53);
    std::string::size_type v33 = v53.__r_.__value_.__r.__words[0];
    std::string::size_type v34 = (sqlite3_stmt *)sub_100019240((uint64_t)v53.__r_.__value_.__l.__data_);
    if (v34)
    {
      BOOL v35 = sub_1003BB2BC(*(void *)a1, v34);
      if (!v33)
      {
LABEL_49:
        if (SHIBYTE(cap) < 0) {
          operator delete(__p[0]);
        }
        return v35;
      }
    }

    else
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F268);
      }
      std::string v38 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v53.__r_.__value_.__l.__data_) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_ERROR,  "Error getting a prepared statement",  (uint8_t *)&v53,  2u);
      }

      if (sub_1002921D0(115, 0))
      {
        bzero(&v53, 0x65CuLL);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F268);
        }
        LOWORD(v48.__r_.__value_.__l.__data_) = 0;
        _os_log_send_and_compose_impl( 2LL,  0LL,  &v53,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Error getting a prepared statement",  &v48,  2);
        std::string v42 = (std::string *)v41;
        sub_10029211C( "Generic",  1LL,  0,  0LL,  "BOOL CLMiLoServiceTable::updateServiceLocationTypes(boost::uuids::uuid, uint64_t)",  "%s\n",  v41);
        if (v42 != &v53) {
          free(v42);
        }
      }

      BOOL v35 = 0LL;
      if (!v33) {
        goto LABEL_49;
      }
    }

    (*(void (**)(std::string::size_type))(*(void *)v33 + 8LL))(v33);
    goto LABEL_49;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F268);
  }
  std::string v36 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v53.__r_.__value_.__l.__data_) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "#Warning Table is not valid so we can't update service",  (uint8_t *)&v53,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(&v53, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F268);
    }
    LOWORD(v52.__r_.__value_.__l.__data_) = 0;
    _os_log_send_and_compose_impl( 2LL,  0LL,  &v53,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Table is not valid so we can't update service",  &v52,  2);
    std::string v40 = (std::string *)v39;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMiLoServiceTable::updateServiceLocationTypes(boost::uuids::uuid, uint64_t)",  "%s\n",  v39);
    if (v40 != &v53) {
      free(v40);
    }
  }

  return 0LL;
}

void sub_1000FFF38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, void *__p, uint64_t a34, int a35, __int16 a36, char a37, char a38, uint64_t a39, void *a40, uint64_t a41, int a42, __int16 a43, char a44, char a45, uint64_t a46, void *a47, uint64_t a48, int a49, __int16 a50,char a51,char a52)
{
  if (v52) {
    (*(void (**)(uint64_t))(*(void *)v52 + 8LL))(v52);
  }
  if (a38 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (a52 < 0) {
    operator delete(a47);
  }
  _Unwind_Resume(a1);
}

void sub_1001000B4(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_1001000E0( uint64_t *a1, uint64_t *a2, double *a3, unsigned int *a4, __int128 *a5, uint64_t *a6, __int128 *a7)
{
  uint64_t v8 = *a1;
  uint64_t v9 = 0x2E8BA2E8BA2E8BA3LL * ((a1[1] - *a1) >> 3);
  unint64_t v10 = v9 + 1;
  uint64_t v17 = (uint64_t)(a1 + 2);
  unint64_t v18 = 0x2E8BA2E8BA2E8BA3LL * ((a1[2] - v8) >> 3);
  if (2 * v18 > v10) {
    unint64_t v10 = 2 * v18;
  }
  if (v18 >= 0x1745D1745D1745DLL) {
    unint64_t v19 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v19 = v10;
  }
  __int128 v27 = a1 + 2;
  if (v19) {
    __int128 v20 = (char *)sub_100023598(v17, v19);
  }
  else {
    __int128 v20 = 0LL;
  }
  __int128 v23 = v20;
  __int128 v24 = &v20[88 * v9];
  uint64_t v25 = (uint64_t)v24;
  std::string::size_type v26 = &v20[88 * v19];
  sub_1000F982C((uint64_t)v24, *a2, a2[1], *a4, a5, *a6, a7, *a3);
  uint64_t v25 = (uint64_t)(v24 + 88);
  sub_100100234(a1, &v23);
  uint64_t v21 = a1[1];
  sub_100100400(&v23);
  return v21;
}

void sub_100100220(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100100234(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1001002A8((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1001002A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v17 = a6;
  *((void *)&v17 + 1) = a7;
  __int128 v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  void v14[2] = &v17;
  if (a3 == a5)
  {
    uint64_t v12 = a6;
  }

  else
  {
    uint64_t v8 = a7;
    do
    {
      __int128 v9 = *(_OWORD *)(a3 - 88);
      *(_OWORD *)(v8 - 72) = *(_OWORD *)(a3 - 72);
      *(_OWORD *)(v8 - 8++*(void *)(result + 8) = v9;
      __int128 v10 = *(_OWORD *)(a3 - 56);
      *(void *)(v8 - 40) = *(void *)(a3 - 40);
      *(_OWORD *)(v8 - 56) = v10;
      *(void *)(a3 - sub_10000AE14(v17 - 48) = 0LL;
      *(void *)(a3 - 40) = 0LL;
      *(void *)(a3 - 56) = 0LL;
      *(void *)(v8 - 32) = *(void *)(a3 - 32);
      __int128 v11 = *(_OWORD *)(a3 - 24);
      *(void *)(v8 - ++*(void *)(result + 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v8 - 24) = v11;
      v8 -= 88LL;
      *(void *)(a3 - 16) = 0LL;
      *(void *)(a3 - ++*(void *)(result + 8) = 0LL;
      *(void *)(a3 - 24) = 0LL;
      v7 -= 88LL;
      a3 -= 88LL;
    }

    while (a3 != a5);
    *((void *)&v17 + 1) = v8;
    uint64_t v12 = v17;
  }

  char v15 = 1;
  sub_10010037C((uint64_t)v14);
  return v12;
}

uint64_t sub_10010037C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1001003B0((uint64_t *)a1);
  }
  return a1;
}

void sub_1001003B0(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_1000AA5C8(v3, v1);
      v1 += 88LL;
    }

    while (v1 != v2);
  }

void **sub_100100400(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_100100430(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 88;
    sub_1000AA5C8(v4, i - 88);
  }

uint64_t sub_100100474(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  if (*(char *)(a2 + 55) < 0)
  {
    sub_1010DD48C((_BYTE *)(a1 + 32), *(void **)(a2 + 32), *(void *)(a2 + 40));
  }

  else
  {
    __int128 v5 = *(_OWORD *)(a2 + 32);
    *(void *)(a1 + sub_10000AE14(v17 - 48) = *(void *)(a2 + 48);
    *(_OWORD *)(a1 + 32) = v5;
  }

  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  uint64_t v6 = (_BYTE *)(a1 + 64);
  if (*(char *)(a2 + 87) < 0)
  {
    sub_1010DD48C(v6, *(void **)(a2 + 64), *(void *)(a2 + 72));
  }

  else
  {
    __int128 v7 = *(_OWORD *)(a2 + 64);
    *(void *)(a1 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)uint64_t v6 = v7;
  }

  *(_BYTE *)(a1 + 8++*(void *)(result + 8) = 1;
  return a1;
}

void sub_100100514(_Unwind_Exception *exception_object)
{
}

double sub_100100530@<D0>(std::string *a1@<X8>)
{
  double result = *(double *)&v3.__r_.__value_.__l.__data_;
  *a1 = v3;
  return result;
}

void sub_100100574( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100100590(std::string *a1)
{
  return sub_100100940(a1);
}

uint64_t sub_1001005DC(std::string *a1)
{
  v7.__r_.__value_.__s.__size_ = 0;
  v7.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v2 = std::string::append(&v7, "ServiceUUID");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t cap = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    __int128 v4 = __p;
  }
  else {
    __int128 v4 = (void **)__p[0];
  }
  if (cap >= 0) {
    std::string::size_type v5 = HIBYTE(cap);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_100100678( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1001006AC(std::string *a1)
{
  v7.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "LastActiveTimestamp");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t cap = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    __int128 v4 = __p;
  }
  else {
    __int128 v4 = (void **)__p[0];
  }
  if (cap >= 0) {
    std::string::size_type v5 = HIBYTE(cap);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_100100754( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100100788(std::string *a1)
{
  v7.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "ServiceType");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t cap = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    __int128 v4 = __p;
  }
  else {
    __int128 v4 = (void **)__p[0];
  }
  if (cap >= 0) {
    std::string::size_type v5 = HIBYTE(cap);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_100100830( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100100864(std::string *a1)
{
  v7.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "LocationTypes");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t cap = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    __int128 v4 = __p;
  }
  else {
    __int128 v4 = (void **)__p[0];
  }
  if (cap >= 0) {
    std::string::size_type v5 = HIBYTE(cap);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_10010090C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100100940(std::string *a1)
{
  v7.__r_.__value_.__s.__size_ = 2;
  strcpy((char *)&v7, ", ");
  uint64_t v2 = std::string::append(&v7, "UserId");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  int64_t cap = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)__int128 __p = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  if (cap >= 0) {
    __int128 v4 = __p;
  }
  else {
    __int128 v4 = (void **)__p[0];
  }
  if (cap >= 0) {
    std::string::size_type v5 = HIBYTE(cap);
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  std::string::append(a1, (const std::string::value_type *)v4, v5);
  if (SHIBYTE(cap) < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_1001009E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

double sub_100100A1C@<D0>(std::string *a1@<X8>)
{
  uint64_t v2 = 7LL;
  do
  {
    if (v2 == 7)
    {
      v8.__r_.__value_.__s.__size_ = 0;
      v8.__r_.__value_.__s.__data_[0] = 0;
    }

    else
    {
      v8.__r_.__value_.__s.__size_ = 2;
      strcpy((char *)&v8, ", ");
    }

    __int128 v3 = std::string::append(&v8, "?");
    __int128 v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
    int64_t cap = v3->__r_.__value_.__l.__cap_;
    *(_OWORD *)__int128 __p = v4;
    v3->__r_.__value_.__l.__size_ = 0LL;
    v3->__r_.__value_.__l.__cap_ = 0LL;
    v3->__r_.__value_.__r.__words[0] = 0LL;
    if (cap >= 0) {
      std::string::size_type v5 = __p;
    }
    else {
      std::string::size_type v5 = (void **)__p[0];
    }
    if (cap >= 0) {
      std::string::size_type v6 = HIBYTE(cap);
    }
    else {
      std::string::size_type v6 = (std::string::size_type)__p[1];
    }
    std::string::append(&v11, (const std::string::value_type *)v5, v6);
    if (SHIBYTE(cap) < 0) {
      operator delete(__p[0]);
    }
    --v2;
  }

  while (v2);
  std::string::append(&v11, ")");
  double result = *(double *)&v11.__r_.__value_.__l.__data_;
  *a1 = v11;
  return result;
}

void sub_100100B24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *__p, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100100B70(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100100BB0((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_100100BB0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 40LL)
  {
  }

  a1[1] = v2;
}

void sub_100100BFC(uint64_t a1)
{
}

void sub_100100C40(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    std::string::size_type v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48LL;
        sub_100100BFC(v4);
      }

      while ((void *)v4 != v2);
      std::string::size_type v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_100100CB0(uint64_t *a1)
{
  if (*a1)
  {
    sub_100100BB0(a1);
    operator delete((void *)*a1);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

__n128 sub_100100CE8(uint64_t a1, __int128 *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(*(_BYTE **)(a1 + 8), *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v5 = *a2;
    *(void *)(v4 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v4 = v5;
  }

  __n128 result = *(__n128 *)((char *)a2 + 24);
  *(__n128 *)(v4 + 24) = result;
  *(void *)(a1 + ++*(void *)(result + 8) = v4 + 40;
  return result;
}

void sub_100100D4C(_Unwind_Exception *a1)
{
  *(void *)(v1 + ++*(void *)(result + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_100100D54(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666LL) {
    sub_100007008();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x333333333333333LL) {
    unint64_t v9 = 0x666666666666666LL;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v18 = a1 + 2;
  if (v9) {
    __int128 v10 = (char *)sub_100100EF8(v7, v9);
  }
  else {
    __int128 v10 = 0LL;
  }
  std::string v11 = &v10[40 * v4];
  v15[0] = v10;
  v15[1] = v11;
  __int128 v16 = v11;
  __int128 v17 = &v10[40 * v9];
  if (*((char *)a2 + 23) < 0)
  {
    sub_1010DD48C(v11, *(void **)a2, *((void *)a2 + 1));
    std::string v11 = v16;
  }

  else
  {
    __int128 v12 = *a2;
    *((void *)v11 + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string v11 = v12;
  }

  *(_OWORD *)&v10[40 * v4 + 24] = *(__int128 *)((char *)a2 + 24);
  __int128 v16 = v11 + 40;
  sub_100100E84(a1, v15);
  uint64_t v13 = a1[1];
  sub_10010105C((uint64_t)v15);
  return v13;
}

void sub_100100E70(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100100E84(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100100F3C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_100100EF8(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667LL) {
    sub_1000070D4();
  }
  return operator new(40 * a2);
}

uint64_t sub_100100F3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v14 = a6;
  *((void *)&v14 + 1) = a7;
  __int128 v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  void v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }

  else
  {
    do
    {
      __int128 v8 = *(_OWORD *)(a3 - 40);
      *(void *)(v7 - 24) = *(void *)(a3 - 24);
      *(_OWORD *)(v7 - 40) = v8;
      *(void *)(a3 - 32) = 0LL;
      *(void *)(a3 - 24) = 0LL;
      *(void *)(a3 - 40) = 0LL;
      *(_OWORD *)(v7 - 16) = *(_OWORD *)(a3 - 16);
      uint64_t v7 = *((void *)&v14 + 1) - 40LL;
      *((void *)&v14 + 1) -= 40LL;
      a3 -= 40LL;
    }

    while (a3 != a5);
    uint64_t v9 = v14;
  }

  char v12 = 1;
  sub_100100FE4((uint64_t)v11);
  return v9;
}

uint64_t sub_100100FE4(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100101018(a1);
  }
  return a1;
}

void sub_100101018(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    v1 += 40LL;
  }

uint64_t sub_10010105C(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100101090(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 5;
      *(void *)(a1 + 16) = v2 - 5;
      if (*((char *)v2 - 17) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }

      uint64_t v2 = v5;
    }

    while (v5 != a2);
  }

uint64_t sub_1001010E4()
{
  v19.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x19uLL);
  *(_OWORD *)&v19.__r_.__value_.__r.__words[1] = xmmword_1012C8520;
  strcpy(v19.__r_.__value_.__l.__data_, "INSERT OR REPLACE INTO ");
  CFStringRef v0 = std::string::append(&v19, "MiLoServices");
  __int128 v1 = *(_OWORD *)&v0->__r_.__value_.__l.__data_;
  v20.__r_.__value_.__l.__cap_ = v0->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v1;
  v0->__r_.__value_.__l.__size_ = 0LL;
  v0->__r_.__value_.__l.__cap_ = 0LL;
  v0->__r_.__value_.__r.__words[0] = 0LL;
  uint64_t v2 = std::string::append(&v20, " (");
  __int128 v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v21.__r_.__value_.__l.__cap_ = v2->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v3;
  v2->__r_.__value_.__l.__size_ = 0LL;
  v2->__r_.__value_.__l.__cap_ = 0LL;
  v2->__r_.__value_.__r.__words[0] = 0LL;
  sub_1000F927C((uint64_t)v17);
  if ((v18 & 0x80u) == 0) {
    unint64_t v4 = v17;
  }
  else {
    unint64_t v4 = (void **)v17[0];
  }
  if ((v18 & 0x80u) == 0) {
    std::string::size_type v5 = v18;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)v17[1];
  }
  uint64_t v6 = std::string::append(&v21, (const std::string::value_type *)v4, v5);
  __int128 v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v22.__r_.__value_.__l.__cap_ = v6->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0LL;
  v6->__r_.__value_.__l.__cap_ = 0LL;
  v6->__r_.__value_.__r.__words[0] = 0LL;
  __int128 v8 = std::string::append(&v22, ") ");
  __int128 v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v23.__r_.__value_.__l.__cap_ = v8->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0LL;
  v8->__r_.__value_.__l.__cap_ = 0LL;
  v8->__r_.__value_.__r.__words[0] = 0LL;
  sub_1000F9344((uint64_t)__p);
  if ((v16 & 0x80u) == 0) {
    __int128 v10 = __p;
  }
  else {
    __int128 v10 = (void **)__p[0];
  }
  if ((v16 & 0x80u) == 0) {
    std::string::size_type v11 = v16;
  }
  else {
    std::string::size_type v11 = (std::string::size_type)__p[1];
  }
  char v12 = std::string::append(&v23, (const std::string::value_type *)v10, v11);
  __int128 v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  unk_101993A80 = v12->__r_.__value_.__l.__cap_;
  xmmword_101993A70 = v13;
  v12->__r_.__value_.__l.__size_ = 0LL;
  v12->__r_.__value_.__l.__cap_ = 0LL;
  v12->__r_.__value_.__r.__words[0] = 0LL;
  return __cxa_atexit( (void (*)(void *))&std::string::~string,  &xmmword_101993A70,  (void *)&_mh_execute_header);
}

void sub_1001012D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, void *a35, uint64_t a36, int a37, __int16 a38, char a39, char a40)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a40 < 0) {
    operator delete(a35);
  }
  if (a33 < 0) {
    operator delete(a28);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10010137C@<X0>(_DWORD *a1@<X0>, void *a2@<X8>)
{
  if (*a1) {
    uint64_t v2 = "recording";
  }
  else {
    uint64_t v2 = "localization";
  }
  return sub_1010DDBC0(a2, v2);
}

void *sub_1001013A0@<X0>(int *a1@<X0>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, off_10181F450[*a1]);
}

void *sub_1001013B8@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, off_10181F480[a1 - 1]);
}

void sub_1001013D0(int *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v8 = *((void *)a1 + 7);
  float v4 = (float)a1[8];
  v12 |= 6u;
  float v9 = v4;
  uint64_t v6 = *(void *)a1;
  uint64_t v10 = sub_1005B46E8((uint64_t)&v6);
  int v5 = a1[10];
  v12 |= 0x18u;
  int v11 = v5;
  sub_100064FDC(a2, v7);
  *(_BYTE *)(a2 + sub_10000AE14(v17 - 48) = 1;
  sub_100064FE0((wireless_diagnostics::google::protobuf::MessageLite *)v7);
}

void sub_100101464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10010147C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(unsigned __int8 *)(a1 + 23);
  if ((v3 & 0x80u) == 0LL) {
    float v4 = (unsigned __int8 *)a1;
  }
  else {
    float v4 = *(unsigned __int8 **)a1;
  }
  if ((v3 & 0x80u) != 0LL) {
    uint64_t v3 = *(void *)(a1 + 8);
  }
  uint64_t result = sub_100011CE8((uint64_t)&v7, v4, &v4[v3]);
  *(void *)a2 = result;
  *(void *)(a2 + ++*(void *)(result + 8) = v6;
  *(_BYTE *)(a2 + 16) = 1;
  return result;
}

uint64_t **sub_1001014F0@<X0>(uint64_t **result@<X0>, _BYTE *a2@<X8>)
{
  int v2 = *((char *)result + 23);
  if (v2 < 0)
  {
    if (result[1] != (uint64_t *)16)
    {
LABEL_7:
      char v3 = 0;
      *a2 = 0;
      goto LABEL_8;
    }

    uint64_t result = (uint64_t **)*result;
  }

  else if (v2 != 16)
  {
    goto LABEL_7;
  }

  *(_OWORD *)a2 = *(_OWORD *)result;
  char v3 = 1;
LABEL_8:
  a2[16] = v3;
  return result;
}

id sub_100101534@<X0>(id result@<X0>, uint64_t a2@<X8>)
{
  if (result)
  {
    uint64_t result = [result getUUIDBytes:&v4];
    *(_OWORD *)a2 = v4;
    char v3 = 1;
  }

  else
  {
    char v3 = 0;
    *(_BYTE *)a2 = 0;
  }

  *(_BYTE *)(a2 + 16) = v3;
  return result;
}

void sub_1001015AC(id *a1@<X0>, _BYTE *a2@<X8>)
{
  if (!*a1 || ![*a1 idsDeviceID])
  {
LABEL_17:
    *a2 = 0;
    a2[72] = 0;
    goto LABEL_22;
  }

  [*a1 bleAdvertisementTimestamp];
  v22 |= 2u;
  uint64_t v16 = v4;
  int v5 = [*a1 bleRSSI];
  v22 |= 4u;
  float v17 = (float)v5;
  unsigned int v6 = [*a1 bleChannel];
  v22 |= 0x10u;
  unsigned int v21 = v6;
  id v7 = [*a1 discoveryFlags];
  v22 |= 0x20u;
  id v18 = v7;
  sub_1010DDBC0(__p, (char *)objc_msgSend(objc_msgSend(*a1, "idsDeviceID"), "UTF8String"));
  sub_10010147C((uint64_t)__p, (uint64_t)__s);
  if (v24 < 0) {
    operator delete(__p[0]);
  }
  if (!__s[16])
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F430);
    }
    int v11 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Invalid CBDevice IDS UUID", (uint8_t *)__p, 2u);
    }

    if (sub_1002921D0(115, 0))
    {
      bzero(__p, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F430);
      }
      __int16 v14 = 0;
      __int128 v13 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Invalid CBDevice IDS UUID",  &v14,  2);
      sub_10029211C( "Generic",  1LL,  0,  0LL,  "static std::optional<CLMicroLocationProto::BleLeechedBeacons> CLMicroLocationProtobufHelper::protobufFromNative( const CLMicroLocationBleWrapperForCBDevice &)",  "%s\n",  v13);
    }

    goto LABEL_17;
  }

  v22 |= 0x80u;
  uint64_t v8 = v20;
  if (v20 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
  {
    uint64_t v8 = (std::string *)operator new(0x18uLL);
    v8->__r_.__value_.__r.__words[0] = 0LL;
    v8->__r_.__value_.__l.__size_ = 0LL;
    v8->__r_.__value_.__l.__cap_ = 0LL;
    std::string v20 = v8;
  }

  std::string::assign(v8, __s, 0x10uLL);
  if ([*a1 model])
  {
    float v9 = (const std::string::value_type *)objc_msgSend(objc_msgSend(*a1, "model"), "UTF8String");
    v22 |= 0x40u;
    uint64_t v10 = v19;
    if (v19 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v10 = (std::string *)operator new(0x18uLL);
      v10->__r_.__value_.__r.__words[0] = 0LL;
      v10->__r_.__value_.__l.__size_ = 0LL;
      v10->__r_.__value_.__l.__cap_ = 0LL;
      std::string v19 = v10;
    }

    std::string::assign(v10, v9);
  }

  else
  {
    v22 |= 0x40u;
    int v12 = v19;
    if (v19 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      int v12 = (std::string *)operator new(0x18uLL);
      v12->__r_.__value_.__r.__words[0] = 0LL;
      v12->__r_.__value_.__l.__size_ = 0LL;
      v12->__r_.__value_.__l.__cap_ = 0LL;
      std::string v19 = v12;
    }

    std::string::assign(v12, "Undefined Model");
  }

  sub_10006446C((uint64_t)a2, (uint64_t)v15);
  a2[72] = 1;
LABEL_22:
  sub_100064520((wireless_diagnostics::google::protobuf::MessageLite *)v15);
}

void sub_1001018EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
}

void sub_10010192C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 72) |= 4u;
  char v3 = *(void **)(a1 + 16);
  if (!v3)
  {
    char v3 = operator new(0x30uLL);
    sub_1000632D4((uint64_t)v3);
    *(void *)(a1 + 16) = v3;
  }

  sub_100065518((uint64_t)v3, a2);
}

void sub_100101984(_Unwind_Exception *a1)
{
}

void sub_100101998(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 72) |= 0x40u;
  char v3 = *(void **)(a1 + 48);
  if (!v3)
  {
    char v3 = operator new(0x48uLL);
    sub_1000632A8((uint64_t)v3);
    *(void *)(a1 + sub_10000AE14(v17 - 48) = v3;
  }

  sub_100064DF8((uint64_t)v3, a2);
}

void sub_1001019F0(_Unwind_Exception *a1)
{
}

float sub_100101A04(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 72) |= 0x80u;
  char v3 = *(void **)(a1 + 56);
  if (!v3)
  {
    char v3 = operator new(0x40uLL);
    sub_1000632F8((uint64_t)v3);
    *(void *)(a1 + 56) = v3;
  }

  return sub_1000665BC((uint64_t)v3, a2);
}

void sub_100101A5C(_Unwind_Exception *a1)
{
}

void sub_100101A70(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 8u;
  char v3 = *(void **)(a1 + 24);
  if (!v3)
  {
    char v3 = operator new(0x30uLL);
    sub_1000635A4((uint64_t)v3);
    *(void *)(a1 + 24) = v3;
  }

  sub_100073330((uint64_t)v3, a2);
}

void sub_100101AC8(_Unwind_Exception *a1)
{
}

void sub_100101ADC(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x20u;
  char v3 = *(void **)(a1 + 40);
  if (!v3)
  {
    char v3 = operator new(0x18uLL);
    sub_1000635F8((uint64_t)v3);
    *(void *)(a1 + 40) = v3;
  }

  sub_100073CBC((uint64_t)v3, a2);
}

void sub_100101B34(_Unwind_Exception *a1)
{
}

void sub_100101B48(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 4u;
  char v3 = *(void **)(a1 + 16);
  if (!v3)
  {
    char v3 = operator new(0x30uLL);
    sub_100063550(v3);
    *(void *)(a1 + 16) = v3;
  }

  sub_100071F88((uint64_t)v3, a2);
}

void sub_100101BA0(_Unwind_Exception *a1)
{
}

void sub_100101BB4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x40u;
  char v3 = *(void **)(a1 + 48);
  if (!v3)
  {
    char v3 = operator new(0x18uLL);
    sub_100063644((uint64_t)v3);
    *(void *)(a1 + sub_10000AE14(v17 - 48) = v3;
  }

  sub_1000749E8((uint64_t)v3, a2);
}

void sub_100101C0C(_Unwind_Exception *a1)
{
}

void sub_100101C20(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x80u;
  char v3 = *(void **)(a1 + 56);
  if (!v3)
  {
    char v3 = operator new(0x78uLL);
    sub_100063664((uint64_t)v3);
    *(void *)(a1 + 56) = v3;
  }

  sub_100076314((uint64_t)v3, a2);
}

void sub_100101C78(_Unwind_Exception *a1)
{
}

void sub_100101C8C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x100u;
  char v3 = *(void **)(a1 + 64);
  if (!v3)
  {
    char v3 = operator new(0x58uLL);
    sub_1000636A0((uint64_t)v3);
    *(void *)(a1 + 64) = v3;
  }

  sub_1000775EC((uint64_t)v3, a2);
}

void sub_100101CE4(_Unwind_Exception *a1)
{
}

void sub_100101CF8(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 48) |= 4u;
  char v3 = *(_DWORD **)(a1 + 16);
  if (!v3)
  {
    char v3 = operator new(0x30uLL);
    sub_100063B5C((uint64_t)v3);
    *(void *)(a1 + 16) = v3;
  }

  sub_10008AF68(v3, a2);
}

void sub_100101D50(_Unwind_Exception *a1)
{
}

void sub_100101D64(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 48) |= 8u;
  char v3 = *(void **)(a1 + 24);
  if (!v3)
  {
    char v3 = operator new(0x20uLL);
    sub_100063B7C((uint64_t)v3);
    *(void *)(a1 + 24) = v3;
  }

  sub_10008B59C((uint64_t)v3, a2);
}

void sub_100101DBC(_Unwind_Exception *a1)
{
}

void sub_100101DD0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 48) |= 0x10u;
  char v3 = *(void **)(a1 + 32);
  if (!v3)
  {
    char v3 = operator new(0x28uLL);
    sub_100063B9C((uint64_t)v3);
    *(void *)(a1 + 32) = v3;
  }

  sub_10008BDC4((uint64_t)v3, a2);
}

void sub_100101E28(_Unwind_Exception *a1)
{
}

void sub_100101E3C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x200u;
  char v3 = *(void **)(a1 + 80);
  if (!v3)
  {
    char v3 = operator new(0x48uLL);
    sub_1000636FC((uint64_t)v3);
    *(void *)(a1 + 80) = v3;
  }

  sub_100078A4C((uint64_t)v3, a2);
}

void sub_100101E94(_Unwind_Exception *a1)
{
}

void sub_100101EA8(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x10u;
  char v3 = *(void **)(a1 + 32);
  if (!v3)
  {
    char v3 = operator new(0x20uLL);
    sub_1000635D0((uint64_t)v3);
    *(void *)(a1 + 32) = v3;
  }

  sub_1000738FC((uint64_t)v3, a2);
}

void sub_100101F00(_Unwind_Exception *a1)
{
}

void sub_100101F14(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x400u;
  char v3 = *(void **)(a1 + 88);
  if (!v3)
  {
    char v3 = operator new(0x30uLL);
    sub_100063578(v3);
    *(void *)(a1 + 8++*(void *)(result + 8) = v3;
  }

  sub_100072938((uint64_t)v3, a2);
}

void sub_100101F6C(_Unwind_Exception *a1)
{
}

void sub_100101F80(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) |= 0x1000u;
  char v3 = *(void **)(a1 + 96);
  if (!v3)
  {
    char v3 = operator new(0x30uLL);
    sub_100063618((uint64_t)v3);
    *(void *)(a1 + 96) = v3;
  }

  sub_100074628((uint64_t)v3, a2);
}

void sub_100101FD8(_Unwind_Exception *a1)
{
}

void sub_100101FEC(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 2u;
  char v3 = *(void **)(a1 + 16);
  if (!v3)
  {
    char v3 = operator new(0x30uLL);
    sub_1000635A4((uint64_t)v3);
    *(void *)(a1 + 16) = v3;
  }

  sub_100073330((uint64_t)v3, a2);
}

void sub_100102044(_Unwind_Exception *a1)
{
}

void sub_100102058(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 8u;
  char v3 = *(void **)(a1 + 32);
  if (!v3)
  {
    char v3 = operator new(0x18uLL);
    sub_1000635F8((uint64_t)v3);
    *(void *)(a1 + 32) = v3;
  }

  sub_100073CBC((uint64_t)v3, a2);
}

void sub_1001020B0(_Unwind_Exception *a1)
{
}

void sub_1001020C4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 1u;
  char v3 = *(void **)(a1 + 8);
  if (!v3)
  {
    char v3 = operator new(0x30uLL);
    sub_100063550(v3);
    *(void *)(a1 + ++*(void *)(result + 8) = v3;
  }

  sub_100071F88((uint64_t)v3, a2);
}

void sub_10010211C(_Unwind_Exception *a1)
{
}

void sub_100102130(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x10u;
  char v3 = *(void **)(a1 + 40);
  if (!v3)
  {
    char v3 = operator new(0x18uLL);
    sub_100063644((uint64_t)v3);
    *(void *)(a1 + 40) = v3;
  }

  sub_1000749E8((uint64_t)v3, a2);
}

void sub_100102188(_Unwind_Exception *a1)
{
}

void sub_10010219C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x20u;
  char v3 = *(void **)(a1 + 48);
  if (!v3)
  {
    char v3 = operator new(0x78uLL);
    sub_100063664((uint64_t)v3);
    *(void *)(a1 + sub_10000AE14(v17 - 48) = v3;
  }

  sub_100076314((uint64_t)v3, a2);
}

void sub_1001021F4(_Unwind_Exception *a1)
{
}

void sub_100102208(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x40u;
  char v3 = *(void **)(a1 + 56);
  if (!v3)
  {
    char v3 = operator new(0x58uLL);
    sub_1000636A0((uint64_t)v3);
    *(void *)(a1 + 56) = v3;
  }

  sub_1000775EC((uint64_t)v3, a2);
}

void sub_100102260(_Unwind_Exception *a1)
{
}

void sub_100102274(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x80u;
  char v3 = *(void **)(a1 + 64);
  if (!v3)
  {
    char v3 = operator new(0x48uLL);
    sub_1000636FC((uint64_t)v3);
    *(void *)(a1 + 64) = v3;
  }

  sub_100078A4C((uint64_t)v3, a2);
}

void sub_1001022CC(_Unwind_Exception *a1)
{
}

void sub_1001022E0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 4u;
  char v3 = *(void **)(a1 + 24);
  if (!v3)
  {
    char v3 = operator new(0x20uLL);
    sub_1000635D0((uint64_t)v3);
    *(void *)(a1 + 24) = v3;
  }

  sub_1000738FC((uint64_t)v3, a2);
}

void sub_100102338(_Unwind_Exception *a1)
{
}

void sub_10010234C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x100u;
  char v3 = *(void **)(a1 + 72);
  if (!v3)
  {
    char v3 = operator new(0x30uLL);
    sub_100063578(v3);
    *(void *)(a1 + 72) = v3;
  }

  sub_100072938((uint64_t)v3, a2);
}

void sub_1001023A4(_Unwind_Exception *a1)
{
}

void sub_1001023B8(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x400u;
  char v3 = *(void **)(a1 + 88);
  if (!v3)
  {
    char v3 = operator new(0x18uLL);
    sub_100063730((uint64_t)v3);
    *(void *)(a1 + 8++*(void *)(result + 8) = v3;
  }

  sub_100078E0C((uint64_t)v3, a2);
}

void sub_100102410(_Unwind_Exception *a1)
{
}

void sub_100102424(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x800u;
  char v3 = *(void **)(a1 + 96);
  if (!v3)
  {
    char v3 = operator new(0x18uLL);
    sub_100063750((uint64_t)v3);
    *(void *)(a1 + 96) = v3;
  }

  sub_1000791CC((uint64_t)v3, a2);
}

void sub_10010247C(_Unwind_Exception *a1)
{
}

void sub_100102490(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x1000u;
  char v3 = *(void **)(a1 + 104);
  if (!v3)
  {
    char v3 = operator new(0x18uLL);
    sub_100063770((uint64_t)v3);
    *(void *)(a1 + 104) = v3;
  }

  sub_10007958C((uint64_t)v3, a2);
}

void sub_1001024E8(_Unwind_Exception *a1)
{
}

void sub_1001024FC(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x2000u;
  char v3 = *(void **)(a1 + 112);
  if (!v3)
  {
    char v3 = operator new(0x18uLL);
    sub_100063790((uint64_t)v3);
    *(void *)(a1 + 112) = v3;
  }

  sub_10007994C((uint64_t)v3, a2);
}

void sub_100102554(_Unwind_Exception *a1)
{
}

void sub_100102568(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x4000u;
  char v3 = *(void **)(a1 + 120);
  if (!v3)
  {
    char v3 = operator new(0x18uLL);
    sub_1000637B0((uint64_t)v3);
    *(void *)(a1 + 120) = v3;
  }

  sub_100079D0C((uint64_t)v3, a2);
}

void sub_1001025C0(_Unwind_Exception *a1)
{
}

void sub_1001025D4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x8000u;
  char v3 = *(void **)(a1 + 128);
  if (!v3)
  {
    char v3 = operator new(0x28uLL);
    sub_1000637D0((uint64_t)v3);
    *(void *)(a1 + 12++*(void *)(result + 8) = v3;
  }

  sub_10007A3B8((uint64_t)v3, a2);
}

void sub_10010262C(_Unwind_Exception *a1)
{
}

void sub_100102640(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x10000u;
  char v3 = *(void **)(a1 + 136);
  if (!v3)
  {
    char v3 = operator new(0x28uLL);
    sub_1000637FC((uint64_t)v3);
    *(void *)(a1 + 136) = v3;
  }

  sub_10007AB80((uint64_t)v3, a2);
}

void sub_100102698(_Unwind_Exception *a1)
{
}

void sub_1001026AC(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x20000u;
  char v3 = *(void **)(a1 + 144);
  if (!v3)
  {
    char v3 = operator new(0x28uLL);
    sub_100063828((uint64_t)v3);
    *(void *)(a1 + 144) = v3;
  }

  sub_10007B2C0((uint64_t)v3, a2);
}

void sub_100102704(_Unwind_Exception *a1)
{
}

void sub_100102718(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x40000u;
  char v3 = *(void **)(a1 + 152);
  if (!v3)
  {
    char v3 = operator new(0x28uLL);
    sub_100063854((uint64_t)v3);
    *(void *)(a1 + 152) = v3;
  }

  sub_10007BA00((uint64_t)v3, a2);
}

void sub_100102770(_Unwind_Exception *a1)
{
}

void sub_100102784(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x80000u;
  char v3 = *(void **)(a1 + 160);
  if (!v3)
  {
    char v3 = operator new(0x28uLL);
    sub_100063880((uint64_t)v3);
    *(void *)(a1 + sub_1000A7938(v1 - 160) = v3;
  }

  sub_10007C2A8((uint64_t)v3, a2);
}

void sub_1001027DC(_Unwind_Exception *a1)
{
}

void sub_1001027F0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x100000u;
  char v3 = *(void **)(a1 + 168);
  if (!v3)
  {
    char v3 = operator new(0x28uLL);
    sub_1000638A8((uint64_t)v3);
    *(void *)(a1 + 16++*(void *)(result + 8) = v3;
  }

  sub_10007C9E8((uint64_t)v3, a2);
}

void sub_100102848(_Unwind_Exception *a1)
{
}

void sub_10010285C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x200000u;
  char v3 = *(void **)(a1 + 176);
  if (!v3)
  {
    char v3 = operator new(0x38uLL);
    sub_1000638D4((uint64_t)v3);
    *(void *)(a1 + 176) = v3;
  }

  sub_10007D4E4((uint64_t)v3, a2);
}

void sub_1001028B4(_Unwind_Exception *a1)
{
}

void sub_1001028C8(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x400000u;
  char v3 = *(void **)(a1 + 184);
  if (!v3)
  {
    char v3 = operator new(0x30uLL);
    sub_100063904((uint64_t)v3);
    *(void *)(a1 + 184) = v3;
  }

  sub_10007DDA0((uint64_t)v3, a2);
}

void sub_100102920(_Unwind_Exception *a1)
{
}

void sub_100102934(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x800000u;
  char v3 = *(void **)(a1 + 192);
  if (!v3)
  {
    char v3 = operator new(0x20uLL);
    sub_100063930((uint64_t)v3);
    *(void *)(a1 + 192) = v3;
  }

  sub_10007E36C((uint64_t)v3, a2);
}

void sub_10010298C(_Unwind_Exception *a1)
{
}

void sub_1001029A0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x1000000u;
  char v3 = *(void **)(a1 + 200);
  if (!v3)
  {
    char v3 = operator new(0x30uLL);
    sub_100063958(v3);
    *(void *)(a1 + 200) = v3;
  }

  sub_10007EDA4((uint64_t)v3, a2);
}

void sub_1001029F8(_Unwind_Exception *a1)
{
}

void sub_100102A0C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x2000000u;
  char v3 = *(void **)(a1 + 208);
  if (!v3)
  {
    char v3 = operator new(0x20uLL);
    sub_100063984((uint64_t)v3);
    *(void *)(a1 + 20++*(void *)(result + 8) = v3;
  }

  sub_10007F370((uint64_t)v3, a2);
}

void sub_100102A64(_Unwind_Exception *a1)
{
}

void sub_100102A78(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x4000000u;
  char v3 = *(void **)(a1 + 216);
  if (!v3)
  {
    char v3 = operator new(0x38uLL);
    sub_1000639AC((uint64_t)v3);
    *(void *)(a1 + 216) = v3;
  }

  sub_10007FEB8((uint64_t)v3, a2);
}

void sub_100102AD0(_Unwind_Exception *a1)
{
}

void sub_100102AE4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x8000000u;
  char v3 = *(void **)(a1 + 224);
  if (!v3)
  {
    char v3 = operator new(0x58uLL);
    sub_100063AA8((uint64_t)v3);
    *(void *)(a1 + sub_1000A7938(v46 - 224) = v3;
  }

  sub_100088CA4((uint64_t)v3, a2);
}

void sub_100102B3C(_Unwind_Exception *a1)
{
}

void sub_100102B50(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x10000000u;
  char v3 = *(_DWORD **)(a1 + 232);
  if (!v3)
  {
    char v3 = operator new(0x18uLL);
    sub_100063AEC((uint64_t)v3);
    *(void *)(a1 + 232) = v3;
  }

  sub_1000890A8(v3, a2);
}

void sub_100102BA8(_Unwind_Exception *a1)
{
}

void sub_100102BBC(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x20000000u;
  char v3 = *(void **)(a1 + 240);
  if (!v3)
  {
    char v3 = operator new(0x18uLL);
    sub_100063B08((uint64_t)v3);
    *(void *)(a1 + 240) = v3;
  }

  sub_100089470((uint64_t)v3, a2);
}

void sub_100102C14(_Unwind_Exception *a1)
{
}

void sub_100102C28(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 292) |= 0x40000000u;
  char v3 = *(void **)(a1 + 248);
  if (!v3)
  {
    char v3 = operator new(0x20uLL);
    sub_100063B28((uint64_t)v3);
    *(void *)(a1 + 2sub_10000AE14(v17 - 48) = v3;
  }

  sub_100089B8C((uint64_t)v3, a2);
}

void sub_100102C80(_Unwind_Exception *a1)
{
}

void sub_100102C94(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 296) |= 4u;
  char v3 = *(void **)(a1 + 280);
  if (!v3)
  {
    char v3 = operator new(0x20uLL);
    sub_1000639E0((uint64_t)v3);
    *(void *)(a1 + 280) = v3;
  }

  sub_100080484((uint64_t)v3, a2);
}

void sub_100102CEC(_Unwind_Exception *a1)
{
}

void sub_100102D00(const std::string *a1@<X0>, id a2@<X1>, uint64_t a3@<X8>)
{
  if (a1[1].__r_.__value_.__s.__data_[0])
  {
    unsigned int v6 = (const char *)a1;
    *(_DWORD *)(a3 + 44) |= 4u;
    id v7 = *(std::string **)(a3 + 16);
    if (v7 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      id v7 = (std::string *)operator new(0x18uLL);
      v7->__r_.__value_.__r.__words[0] = 0LL;
      v7->__r_.__value_.__l.__size_ = 0LL;
      v7->__r_.__value_.__l.__cap_ = 0LL;
      *(void *)(a3 + 16) = v7;
    }

    std::string::operator=(v7, a1);
    if (a2) {
      goto LABEL_7;
    }
LABEL_15:
    id v9 = 0LL;
    int v8 = 1;
    goto LABEL_22;
  }

  unsigned int v6 = "";
  if (!a2) {
    goto LABEL_15;
  }
LABEL_7:
  if (objc_msgSend( objc_msgSend(a2, "objectForKey:", @"private.MicroLocation.forced.recordingRequest"),  "BOOLValue")) {
    int v8 = 2;
  }
  else {
    int v8 = 1;
  }
  if ([a2 objectForKey:@"private.MicroLocation.truthtag.identifier"])
  {
    id v9 = [a2 objectForKeyedSubscript:@"private.MicroLocation.truthtag.identifier"];
    [v9 getUUIDBytes:v16];
    *(_DWORD *)(a3 + 44) |= 0x10u;
    uint64_t v10 = *(std::string **)(a3 + 32);
    if (v10 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      uint64_t v10 = (std::string *)operator new(0x18uLL);
      v10->__r_.__value_.__r.__words[0] = 0LL;
      v10->__r_.__value_.__l.__size_ = 0LL;
      v10->__r_.__value_.__l.__cap_ = 0LL;
      *(void *)(a3 + 32) = v10;
    }

    std::string::assign(v10, (const std::string::value_type *)v16, 0x10uLL);
  }

  else
  {
    id v9 = 0LL;
  }

  if ([a2 objectForKey:@"private.MicroLocation.recordingTriggerUUID"])
  {
    a2 = [a2 objectForKeyedSubscript:@"private.MicroLocation.recordingTriggerUUID"];
    [a2 getUUIDBytes:v16];
    *(_DWORD *)(a3 + 44) |= 8u;
    int v11 = *(std::string **)(a3 + 24);
    if (v11 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
    {
      int v11 = (std::string *)operator new(0x18uLL);
      v11->__r_.__value_.__r.__words[0] = 0LL;
      v11->__r_.__value_.__l.__size_ = 0LL;
      v11->__r_.__value_.__l.__cap_ = 0LL;
      *(void *)(a3 + 24) = v11;
    }

    std::string::assign(v11, (const std::string::value_type *)v16, 0x10uLL);
  }

  else
  {
    a2 = 0LL;
  }

void sub_100103030(_Unwind_Exception *a1)
{
}

NSDictionary *sub_100103054(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v17[0] = a2;
  v17[1] = a3;
  unsigned int v6 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v17);
  if (*(_BYTE *)(a4 + 16))
  {
    id v7 = objc_alloc(&OBJC_CLASS___NSUUID);
    if (!*(_BYTE *)(a4 + 16)) {
      sub_100036CD8();
    }
    int v8 = -[NSUUID initWithUUIDBytes:](v7, "initWithUUIDBytes:", a4);
    id v9 = objc_alloc(&OBJC_CLASS___NSDictionary);
    if (a1) {
      uint64_t v10 = &__kCFBooleanTrue;
    }
    else {
      uint64_t v10 = &__kCFBooleanFalse;
    }
    int v11 = -[NSDictionary initWithObjectsAndKeys:]( v9,  "initWithObjectsAndKeys:",  v10,  @"private.MicroLocation.forced.recordingRequest",  v6,  @"private.MicroLocation.recordingTriggerUUID",  v8,  @"private.MicroLocation.truthtag.identifier",  0LL);
  }

  else
  {
    int v12 = objc_alloc(&OBJC_CLASS___NSDictionary);
    if (a1) {
      __int128 v13 = &__kCFBooleanTrue;
    }
    else {
      __int128 v13 = &__kCFBooleanFalse;
    }
    int v11 = -[NSDictionary initWithObjectsAndKeys:]( v12,  "initWithObjectsAndKeys:",  v13,  @"private.MicroLocation.forced.recordingRequest",  v6,  @"private.MicroLocation.recordingTriggerUUID",  0LL,  v15,  v16);
  }

  return v11;
}

uint64_t sub_1001031A0@<X0>(uint64_t result@<X0>, _BYTE *a2@<X8>)
{
  int v2 = *(_DWORD *)(result + 128);
  if ((v2 & 4) == 0) {
    goto LABEL_8;
  }
  uint64_t v3 = *(void *)(result + 16);
  if (!v3) {
    uint64_t v3 = *(void *)(qword_1019A0980 + 16);
  }
  if ((*(_BYTE *)(v3 + 44) & 8) != 0)
  {
    int v5 = *(uint64_t ***)(v3 + 24);
  }

  else
  {
LABEL_8:
    if ((v2 & 0x400) == 0) {
      goto LABEL_17;
    }
    uint64_t v4 = *(void *)(result + 88);
    if (!v4) {
      uint64_t v4 = *(void *)(qword_1019A0980 + 88);
    }
    if ((*(_BYTE *)(v4 + 44) & 8) == 0) {
      goto LABEL_17;
    }
    int v5 = *(uint64_t ***)(v4 + 24);
  }

  int v6 = *((char *)v5 + 23);
  if (v6 < 0)
  {
    if (v5[1] != (uint64_t *)16)
    {
LABEL_17:
      char v7 = 0;
      *a2 = 0;
      goto LABEL_18;
    }

    int v5 = (uint64_t **)*v5;
  }

  else if (v6 != 16)
  {
    goto LABEL_17;
  }

  *(_OWORD *)a2 = *(_OWORD *)v5;
  char v7 = 1;
LABEL_18:
  a2[16] = v7;
  return result;
}

CFAbsoluteTime sub_10010323C(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 128) & 2) != 0) {
    return *(double *)(a1 + 8);
  }
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F430);
  }
  __int128 v1 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Event Received without Timestamp!", buf, 2u);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F430);
    }
    v4[0] = 0;
    uint64_t v3 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "Event Received without Timestamp!",  v4,  2);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "static cl::chrono::CFAbsoluteTimeClock::time_point CLMicroLocationProtobufHelper::getEventReceivedTS(const CLMicro LocationProto::RecordingEvent &)",  "%s\n",  v3);
  }

  return j__CFAbsoluteTimeGetCurrent_1();
}

void sub_1001033D4(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (!sub_100064120(v4)) {
    __assert_rtn("set_datatype", "microlocation.pb.h", 10437, "::CLMicroLocationProto::DataType_IsValid(value)");
  }
  uint64_t v5 = *(void *)(a1 + 8);
  int v7 = v4;
  v8 |= 3u;
  v6[1] = v5;
  sub_10010192C((uint64_t)v6, a1);
  sub_100068220(a2, v6);
  *(_BYTE *)(a2 + 80) = 1;
  sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)v6);
}

void sub_100103480( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double sub_100103494(uint64_t a1)
{
  switch(*(_DWORD *)(a1 + 64))
  {
    case 1:
      uint64_t v1 = *(void *)(a1 + 16);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_1019A0818 + 16);
      }
      goto LABEL_14;
    case 2:
      uint64_t v1 = *(void *)(a1 + 24);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_1019A0818 + 24);
      }
      goto LABEL_14;
    case 3:
      uint64_t v1 = *(void *)(a1 + 32);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_1019A0818 + 32);
      }
      goto LABEL_14;
    case 4:
      uint64_t v1 = *(void *)(a1 + 40);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_1019A0818 + 40);
      }
      goto LABEL_14;
    case 5:
      uint64_t v1 = *(void *)(a1 + 48);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_1019A0818 + 48);
      }
      goto LABEL_14;
    case 6:
      uint64_t v1 = *(void *)(a1 + 56);
      if (!v1) {
        uint64_t v1 = *(void *)(qword_1019A0818 + 56);
      }
LABEL_14:
      double result = *(float *)(v1 + 20);
      break;
    default:
      return result;
  }

  return result;
}

uint64_t sub_100103570@<X0>(uint64_t a1@<X0>, std::stringbuf::string_type *a2@<X8>)
{
  return sub_1007EC1AC(a2);
}

_BYTE *sub_1001035A8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = (char *)operator new(0x28uLL);
  *(void *)a2 = v4;
  *(_OWORD *)(a2 + ++*(void *)(result + 8) = xmmword_1012C8460;
  *(_OWORD *)int v4 = 0u;
  *((_OWORD *)v4 + 1) = 0u;
  *(void *)(v4 + 29) = 0LL;
  return sub_10000AE6C(a1, v4);
}

void sub_100103604(_Unwind_Exception *a1)
{
}

double sub_100103618(int a1)
{
  double result = -110.0;
  if (((a1 - 2) & 0xFFFFFFFB) == 0) {
    return 20.0;
  }
  return result;
}

void *sub_100103634@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  if (((_DWORD)result - 2) >= 2)
  {
    if ((_DWORD)result == 1)
    {
      if ((byte_1019A0A1F & 0x80000000) == 0)
      {
        int v2 = &xmmword_1019A0A08;
        goto LABEL_9;
      }

      uint64_t v3 = &xmmword_1019A0A08;
    }

    else
    {
      if ((byte_1019A0A07 & 0x80000000) == 0)
      {
        int v2 = &xmmword_1019A09F0;
        goto LABEL_9;
      }

      uint64_t v3 = &xmmword_1019A09F0;
    }
  }

  else
  {
    if ((byte_1019A0A4F & 0x80000000) == 0)
    {
      int v2 = &xmmword_1019A0A38;
LABEL_9:
      *(_OWORD *)a2 = *v2;
      *(void *)(a2 + 16) = *((void *)v2 + 2);
      return result;
    }

    uint64_t v3 = &xmmword_1019A0A38;
  }

  return sub_1010DD48C((_BYTE *)a2, *(void **)v3, *((void *)v3 + 1));
}

uint64_t sub_1001036CC(uint64_t *a1)
{
  int v1 = *((unsigned __int8 *)a1 + 23);
  if (*((char *)a1 + 23) < 0)
  {
    uint64_t v7 = a1[1];
    if (v7 != 15) {
      goto LABEL_35;
    }
    int v8 = (uint64_t *)*a1;
    if (*(void *)*a1 == 0x5F4C41434947414DLL && *(void *)(*a1 + 7) == 0x53544E454D4F4D5FLL) {
      return 0LL;
    }
    uint64_t v10 = *v8;
    uint64_t v11 = *(uint64_t *)((char *)v8 + 7);
    if (v10 == 0x5055535F494D4553LL && v11 == 0x4445534956524550LL) {
      return 1LL;
    }
    uint64_t v7 = a1[1];
    if (v7 != 15) {
      goto LABEL_35;
    }
    if (*(void *)*a1 == 0x4952414C494D4953LL && *(void *)(*a1 + 7) == 0x5453494C5F595449LL) {
      return 2LL;
    }
    if ((v1 & 0x80) == 0)
    {
      int v2 = a1;
      if (v1 != 10) {
        goto LABEL_45;
      }
    }

    else
    {
LABEL_35:
      if (v7 != 10) {
        goto LABEL_45;
      }
      int v2 = (uint64_t *)*a1;
    }
  }

  else
  {
    int v2 = a1;
    if (v1 != 10)
    {
      if (v1 != 15) {
        goto LABEL_45;
      }
      if (*a1 != 0x5F4C41434947414DLL || *(uint64_t *)((char *)a1 + 7) != 0x53544E454D4F4D5FLL)
      {
        if (*a1 != 0x5055535F494D4553LL || *(uint64_t *)((char *)a1 + 7) != 0x4445534956524550LL)
        {
          return 2LL;
        }

        return 1LL;
      }

      return 0LL;
    }
  }

  uint64_t v14 = *v2;
  int v15 = *((unsigned __int16 *)v2 + 4);
  if (v14 != 0x4C54415F45554C42LL || v15 != 21313)
  {
LABEL_45:
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F430);
    }
    __int16 v17 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_FAULT))
    {
      id v18 = a1;
      *(_DWORD *)__int128 buf = 68289795;
      int v25 = 0;
      __int16 v26 = 2082;
      __int128 v27 = "";
      __int16 v28 = 2081;
      std::string::size_type v29 = v18;
      __int16 v30 = 2082;
      __int128 v31 = "assert";
      __int16 v32 = 2081;
      std::string::size_type v33 = "false";
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_FAULT,  "{msg%{public}.0s:Can't find a model type that corresponds to string, string:%{private, location:esca pe_only}s, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x30u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F430);
      }
    }

    __int16 v19 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      std::string v20 = a1;
      *(_DWORD *)__int128 buf = 68289795;
      int v25 = 0;
      __int16 v26 = 2082;
      __int128 v27 = "";
      __int16 v28 = 2081;
      std::string::size_type v29 = v20;
      __int16 v30 = 2082;
      __int128 v31 = "assert";
      __int16 v32 = 2081;
      std::string::size_type v33 = "false";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Can't find a model type that corresponds to string",  "{msg%{public}.0s:Can't find a model type that corresponds to string, string:%{private, location:esca pe_only}s, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x30u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F430);
      }
    }

    __int16 v21 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      int v22 = a1;
      *(_DWORD *)__int128 buf = 68289795;
      int v25 = 0;
      __int16 v26 = 2082;
      __int128 v27 = "";
      __int16 v28 = 2081;
      std::string::size_type v29 = v22;
      __int16 v30 = 2082;
      __int128 v31 = "assert";
      __int16 v32 = 2081;
      std::string::size_type v33 = "false";
      _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Can't find a model type that corresponds to string, string:%{private, location:esca pe_only}s, event:%{public, location:escape_only}s, condition:%{private, location:escape_only}s}",  buf,  0x30u);
    }

    abort_report_np( "%s:%d: assertion failure in %s",  "/Library/Caches/com.apple.xbs/Sources/CoreLocation/Daemon/Positioning/MicroLocation/CLMicroLocationProtobufHelper.mm",  988,  "modelTypeFromString");
    __break(1u);
  }

  return 3LL;
}

void *sub_100103B9C@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, off_10181F4D8[a1]);
}

void sub_100103BB0(void *a1, unsigned __int8 **a2, uint64_t a3)
{
  int v4 = a2;
  int v6 = *a2;
  uint64_t v7 = a2[1];
  uint64_t v11 = (const char *)[a1 UTF8String];
  LOBYTE(v4) = sub_10010410C(v6, v7, &v11) != v4[1];
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100103C60;
  block[3] = &unk_10181F410;
  char v10 = (char)v4;
  block[4] = a1;
  block[5] = a3;
  dispatch_async(global_queue, block);
}

void sub_100103C60(uint64_t a1)
{
  *(void *)&double v2 = objc_opt_class(&OBJC_CLASS___AVSystemController).n128_u64[0];
  if (v3)
  {
    unsigned __int8 v4 = objc_msgSend( +[AVSystemController sharedAVSystemController]( AVSystemController,  "sharedAVSystemController",  v2),  "hasRouteSharingPolicyLongFormVideo:",  *(void *)(a1 + 32));
    int v5 = v10 | 1;
    _WORD v9[8] = v4;
  }

  else
  {
    int v5 = v10;
  }

  char v6 = *(_BYTE *)(a1 + 48);
  int v10 = v5 | 2;
  v9[9] = v6;
  uint64_t v7 = *(void *)(a1 + 40);
  sub_100071244(v8, v9);
  (*(void (**)(uint64_t, _BYTE *))(v7 + 16))(v7, v8);
  sub_100071248((wireless_diagnostics::google::protobuf::MessageLite *)v8);
  sub_100071248((wireless_diagnostics::google::protobuf::MessageLite *)v9);
}

void sub_100103D00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

CFStringRef sub_100103D24(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 72);
  double result = @"receivedEventAction";
  switch(v1)
  {
    case 1:
      return result;
    case 2:
      double result = @"appLaunch";
      break;
    case 3:
    case 6:
    case 8:
    case 11:
      goto LABEL_6;
    case 4:
      double result = @"backlightOn";
      break;
    case 5:
      double result = @"batteryChargerConnected";
      break;
    case 7:
      double result = @"forcedRecording";
      break;
    case 9:
      double result = @"homekitAccessory";
      break;
    case 10:
      double result = @"homekitScene";
      break;
    case 12:
      double result = @"nowPlaying";
      break;
    case 13:
      double result = @"recordingRequest";
      break;
    case 14:
      double result = @"truthLabelDonation";
      break;
    default:
      if (v1 == 42)
      {
        double result = @"RequestObservation";
      }

      else if (v1 == 43)
      {
        double result = @"RequestPrediction";
      }

      else
      {
LABEL_6:
        double result = @"triggerInvalid";
      }

      break;
  }

  return result;
}

void *sub_100103DF4@<X0>(int a1@<W0>, void *a2@<X8>)
{
  return sub_1010DDBC0(a2, off_10181F4F8[a1]);
}

uint64_t sub_100103E08(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 64) == 1) {
    return (*(unsigned __int8 *)(a1 + 81) >> 4) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_100103E28(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 64) == 1) {
    return *(unsigned __int8 *)(a1 + 81) >> 7;
  }
  else {
    return 0LL;
  }
}

void sub_100103E48(void *a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  sub_100103F68(a2, 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(a1[1] - *a1) >> 3));
  unsigned __int8 v4 = (int *)a1[1];
  if ((int *)*a1 != v4)
  {
    int v5 = (int *)(*a1 + 48LL);
    do
    {
      sub_1001033D4((uint64_t)(v5 - 12), (uint64_t)v9);
      if (v10)
      {
        unint64_t v6 = a2[1];
        if (v6 >= a2[2])
        {
          uint64_t v7 = sub_100104230(a2, (uint64_t)v9, v5);
        }

        else
        {
          sub_100104354(a2[1], (uint64_t)v9, *v5);
          uint64_t v7 = v6 + 88;
          a2[1] = v6 + 88;
        }

        a2[1] = v7;
        if (v10) {
          sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)v9);
        }
      }

      int v8 = v5 + 2;
      v5 += 14;
    }

    while (v8 != v4);
  }

void sub_100103F28(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100103F68(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x2E8BA2E8BA2E8BA3LL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x2E8BA2E8BA2E8BBLL) {
      sub_100007008();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = sub_100023598(result, a2);
    v7[1] = v7[0] + v5;
    _DWORD v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 88 * v6;
    sub_1001041BC(a1, v7);
    return sub_10004C440((uint64_t)v7);
  }

  return result;
}

void sub_100104010(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100104024(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void *sub_100104050(void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8LL) {
    sub_10000C818();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000LL;
    *std::string __dst = v6;
  }

  else
  {
    *((_BYTE *)__dst + 23) = __len;
    uint64_t v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }

  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

void sub_1001040F8()
{
}

unsigned __int8 *sub_10010410C(unsigned __int8 *a1, unsigned __int8 *a2, const char **a3)
{
  uint64_t v3 = a1;
  if (a1 != a2)
  {
    uint64_t v5 = *a3;
    size_t v6 = strlen(*a3);
    while (1)
    {
      if ((char)v3[23] < 0)
      {
        if (v6 == *((void *)v3 + 1))
        {
          if (v6 == -1LL) {
LABEL_14:
          }
            sub_1001040F8();
          size_t v7 = *(unsigned __int8 **)v3;
LABEL_10:
          if (!memcmp(v7, v5, v6)) {
            return v3;
          }
        }
      }

      else if (v6 == v3[23])
      {
        size_t v7 = v3;
        if (v6 == -1LL) {
          goto LABEL_14;
        }
        goto LABEL_10;
      }

      v3 += 24;
      if (v3 == a2) {
        return a2;
      }
    }
  }

  return v3;
}

uint64_t sub_1001041BC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10004C308((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100104230(uint64_t *a1, uint64_t a2, int *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = 0x2E8BA2E8BA2E8BA3LL * ((a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = 0x2E8BA2E8BA2E8BA3LL * ((a1[2] - v4) >> 3);
  if (2 * v10 > v6) {
    unint64_t v6 = 2 * v10;
  }
  if (v10 >= 0x1745D1745D1745DLL) {
    unint64_t v11 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v11 = v6;
  }
  __int16 v19 = a1 + 2;
  if (v11) {
    int v12 = (char *)sub_100023598(v9, v11);
  }
  else {
    int v12 = 0LL;
  }
  int v15 = v12;
  uint64_t v16 = &v12[88 * v5];
  uint64_t v17 = (uint64_t)v16;
  id v18 = &v12[88 * v11];
  sub_100104354((uint64_t)v16, a2, *a3);
  uint64_t v17 = (uint64_t)(v16 + 88);
  sub_1001041BC(a1, &v15);
  uint64_t v13 = a1[1];
  sub_10004C440((uint64_t)&v15);
  return v13;
}

void sub_100104340(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100104354(uint64_t a1, uint64_t a2, int a3)
{
  *(_DWORD *)(v6 + 80) = a3;
  sub_100069058(v6, a2);
  return a1;
}

void sub_100104394(_Unwind_Exception *a1)
{
}

uint64_t sub_1001043A8()
{
  return __cxa_atexit( (void (*)(void *))&std::string::~string,  &xmmword_1019A0A38,  (void *)&_mh_execute_header);
}

void sub_100104474(uint64_t a1, int a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "not running";
    if (a2) {
      uint64_t v5 = "running";
    }
    *(_DWORD *)__int128 buf = 136446210;
    unint64_t v11 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "BLE spyscan session set to %{public}s",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v6 = "not running";
    if (a2) {
      uint64_t v6 = "running";
    }
    int v8 = 136446210;
    uint64_t v9 = v6;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "BLE spyscan session set to %{public}s",  &v8,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::State::setBleSpyscanSessionRunning(BOOL)",  "%s\n",  v7);
  }

  *(_BYTE *)(a1 + sub_1000A7938(v1 - 160) = a2;
}

void sub_100104654(uint64_t a1, int a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "stopped";
    if (a2) {
      uint64_t v5 = "running";
    }
    *(_DWORD *)__int128 buf = 136446210;
    unint64_t v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Ranging session set to %{public}s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v6 = "stopped";
    if (a2) {
      uint64_t v6 = "running";
    }
    int v8 = 136446210;
    uint64_t v9 = v6;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Ranging session set to %{public}s",  &v8,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::State::setRangingSessionRunning(BOOL)",  "%s\n",  v7);
  }

  *(_BYTE *)(a1 + 161) = a2;
}

uint64_t sub_100104834(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 264);
}

void sub_10010483C(uint64_t a1, int a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  uint64_t v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "stopped";
    if (a2) {
      uint64_t v5 = "running";
    }
    *(_DWORD *)__int128 buf = 136446210;
    unint64_t v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Motion fence set to %{public}s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v6 = "stopped";
    if (a2) {
      uint64_t v6 = "running";
    }
    int v8 = 136446210;
    uint64_t v9 = v6;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Motion fence set to %{public}s",  &v8,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::State::setMotionSessionState(BOOL)",  "%s\n",  v7);
  }

  *(_BYTE *)(a1 + 162) = a2;
}

uint64_t sub_100104A1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = off_10181F550;
  sub_100063A68(a1 + 8);
  *(_BYTE *)(a1 + 145) = 2;
  *(_BYTE *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + sub_1000A7938(v1 - 160) = 0;
  *(_WORD *)(a1 + 16++*(void *)(result + 8) = 0;
  *(_BYTE *)(a1 + 170) = 0;
  sub_1000C6980((_BYTE *)(a1 + 176), (uint64_t)&byte_1019A18B0);
  *(_WORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(void *)(a1 + 28++*(void *)(result + 8) = 0xFFEFFFFFFFFFFFFFLL;
  *(_BYTE *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = a2;
  *(void *)(a1 + 312) = a3;
  sub_1000C468C(a1 + 320, a1);
  *(_DWORD *)(a1 + 592) = 0;
  *(_BYTE *)(a1 + 596) = 0;
  *(void *)(a1 + 600) = a1;
  sub_1002F0B04(&v37);
  CFStringRef v6 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsWifiTimestampJitterThreshold", 0x8000100u, kCFAllocatorNull);
  int v7 = sub_1002A77CC(v37, (uint64_t)v6, &v39);
  CFRelease(v6);
  unsigned int v8 = v39;
  uint64_t v9 = v38;
  if (v38)
  {
    p_shared_owners = (unint64_t *)&v38->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  double v12 = (double)v8 / 1000.0;
  if (!v7) {
    double v12 = 0.04;
  }
  sub_1001137D0(a1 + 608, v12);
  sub_1002F0B04(&v37);
  CFStringRef v13 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBleScanBufferSize", 0x8000100u, kCFAllocatorNull);
  int v14 = sub_1002A77CC(v37, (uint64_t)v13, &v39);
  CFRelease(v13);
  uint64_t v15 = v39;
  uint64_t v16 = v38;
  if (v38)
  {
    uint64_t v17 = (unint64_t *)&v38->__shared_owners_;
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  sub_1010DDBC0(&__p, "Microlocation Ble rssi buffer");
  if (v14) {
    uint64_t v19 = v15;
  }
  else {
    uint64_t v19 = 1024LL;
  }
  sub_10010D93C(a1 + 648, v19, &__p);
  sub_1002F0B04(&v37);
  CFStringRef v20 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsUwbRangeBufferSize", 0x8000100u, kCFAllocatorNull);
  int v21 = sub_1002A77CC(v37, (uint64_t)v20, &v39);
  CFRelease(v20);
  uint64_t v22 = v39;
  __int16 v23 = v38;
  if (v38)
  {
    char v24 = (unint64_t *)&v38->__shared_owners_;
    do
      unint64_t v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }

  sub_1010DDBC0(&__str, "Microlocation Uwb range buffer");
  if (v21) {
    uint64_t v26 = v22;
  }
  else {
    uint64_t v26 = 128LL;
  }
  sub_10010D93C(a1 + 712, v26, &__str);
  *(_OWORD *)(a1 + 816) = 0u;
  *(_OWORD *)(a1 + 832) = 0u;
  *(_WORD *)(a1 + 80++*(void *)(result + 8) = 0;
  *(_OWORD *)(a1 + 776) = 0u;
  *(_OWORD *)(a1 + 792) = 0u;
  *(_DWORD *)(a1 + 8sub_10000AE14(v17 - 48) = 1065353216;
  sub_1002F0B04(&v37);
  CFStringRef v27 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsMaxBleIdentityNumber", 0x8000100u, kCFAllocatorNull);
  int v28 = sub_1002A77CC(v37, (uint64_t)v27, &v39);
  CFRelease(v27);
  uint64_t v29 = v39;
  __int16 v30 = v38;
  if (v38)
  {
    __int128 v31 = (unint64_t *)&v38->__shared_owners_;
    do
      unint64_t v32 = __ldaxr(v31);
    while (__stlxr(v32 - 1, v31));
    if (!v32)
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
  }

  uint64_t v33 = 128LL;
  if (v28) {
    uint64_t v33 = v29;
  }
  *(void *)(a1 + 856) = v33;
  *(_OWORD *)(a1 + 864) = 0u;
  *(_DWORD *)(a1 + 880) = 0;
  return a1;
}

void sub_100104DD8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, char a22, uint64_t a23, uint64_t a24)
{
  a24 = v26 + 784;
  sub_10010DBE0((void ***)&a24);
  sub_100104ED8(v28);
  sub_100104ED8(v27);
  sub_10010DB70((void ***)&a24);
  sub_1000C6B08(v25);
  sub_100104F14(v24);
  _Unwind_Resume(a1);
}

void sub_100104EC0()
{
}

uint64_t sub_100104ED8(uint64_t a1)
{
  return a1;
}

uint64_t sub_100104F14(uint64_t a1)
{
  return sub_100086708(a1);
}

uint64_t sub_100104F50(uint64_t a1)
{
  *(void *)a1 = off_10181F550;
  if (*(_BYTE *)(a1 + 808) == 1 || *(_BYTE *)(a1 + 809) == 1)
  {
    sub_1000C5C34(a1 + 320);
    *(_WORD *)(a1 + 80++*(void *)(result + 8) = 0;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  double v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "CLMicroLocationSensorsLogic: DTOR", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    v5[0] = 0;
    uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "CLMicroLocationSensorsLogic: DTOR",  v5,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual CLMicroLocationSensorsLogic::~CLMicroLocationSensorsLogic()",  "%s\n",  v4);
  }

  sub_10010DC68(a1 + 816);
  *(void *)__int128 buf = a1 + 784;
  sub_10010DBE0((void ***)buf);
  sub_10010D4F0(a1 + 720, *(void **)(a1 + 728));
  sub_10010D4F0(a1 + 656, *(void **)(a1 + 664));
  *(void *)__int128 buf = a1 + 608;
  sub_10010DB70((void ***)buf);
  sub_1000C6B08(a1 + 320);
  sub_100086708(a1 + 8);
  return a1;
}

void sub_10010519C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_100006BB8(a1);
}

void sub_1001051AC(uint64_t a1)
{
  int v1 = (void *)sub_100104F50(a1);
  operator delete(v1);
}

uint64_t sub_1001051C0(uint64_t a1)
{
  return sub_1000C4F48(a1 + 320);
}

uint64_t sub_1001051C8(_BYTE *a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  double v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "cancel a requested Ble and WiFi scan", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    v6[0] = 0;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "cancel a requested Ble and WiFi scan",  v6,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::onRecordingOrLocalizingInterrupted()",  "%s\n",  v5);
  }

  if (a1[809] == 1)
  {
    int v3 = a1[808];
    sub_1000C5C34((uint64_t)(a1 + 320));
    *((_WORD *)a1 + 404) = 0;
    if (v3 == 2) {
      sub_1001053A4((uint64_t)a1);
    }
  }

  uint64_t result = sub_1000C4E00((uint64_t)(a1 + 320));
  if (a1[296])
  {
    uint64_t result = sub_1000C60B0((uint64_t)(a1 + 320));
    a1[296] = 0;
  }

  return result;
}

void sub_1001053A4(uint64_t a1)
{
  char v2 = sub_100105E48(a1);
  memset(v5, 0, sizeof(v5));
  sub_10010DD48( v5,  *(id **)(a1 + 784),  *(id **)(a1 + 792),  (uint64_t)(*(void *)(a1 + 792) - *(void *)(a1 + 784)) >> 3);
  __n128 v3 = 0uLL;
  uint64_t v4 = 0LL;
  sub_1000946C8((uint64_t)v6, 0, 1, v2, (uint64_t)v5, &v3, 0.0);
  uint64_t v9 = &v3;
  sub_1000129D4((void ***)&v9);
  uint64_t v9 = (__n128 *)v5;
  sub_10010DBE0((void ***)&v9);
  sub_100106120(a1, (uint64_t)v6);
  uint64_t v9 = (__n128 *)&v8;
  sub_1000129D4((void ***)&v9);
  uint64_t v9 = (__n128 *)&v7;
  sub_10010DBE0((void ***)&v9);
}

void sub_100105470( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void *sub_1001054A4(void *result, void *a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = result;
    objc_msgSend( a2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:]( NSNumber,  "numberWithUnsignedLong:",  (uint64_t)(v5[99] - v5[98]) >> 3),  @"BleIdentitiesFamilyCount");
    objc_msgSend( a2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", v5[105]),  @"BleIdentitiesSameAccountCount");
    objc_msgSend( a2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithUnsignedLong:]( NSNumber,  "numberWithUnsignedLong:",  v5[105] + ((uint64_t)(v5[99] - v5[98]) >> 3)),  @"BleIdentitiesTotal");
    return objc_msgSend( a2,  "setObject:forKeyedSubscript:",  +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", a3),  @"BleIsScanRequested");
  }

  return result;
}

void sub_100105574(uint64_t a1, void *a2)
{
  *(void *)(a1 + 872) = *a2;
  sub_1002F0B04(&v11);
  CFStringRef v3 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBleActiveScanRate", 0x8000100u, kCFAllocatorNull);
  int v4 = sub_1002A7D20(v11, (uint64_t)v3, &v10);
  CFRelease(v3);
  int v5 = v10;
  CFStringRef v6 = v12;
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  if (v4) {
    int v9 = v5;
  }
  else {
    int v9 = 40;
  }
  *(_DWORD *)(a1 + 880) = v9;
}

void sub_100105644( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_10010568C(uint64_t a1)
{
  char v2 = (uint64_t *)sub_1000C6890(a1 + 320);
  sub_1000219C4((uint64_t)v4, v2);
  CFStringRef v3 = (void *)sub_1000E7908((uint64_t)v4);
  *(double *)(a1 + 864) = *(double *)(a1 + 864) + (double)(unint64_t)((uint64_t)(v3[1] - *v3) >> 2) * 0.11;
  if (v8 < 0) {
    operator delete(__p);
  }
  if (v5)
  {
    CFStringRef v6 = v5;
    operator delete(v5);
  }

void sub_100105714( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100105728(void *a1, uint64_t a2, char a3, uint64_t *a4, void *a5)
{
  *((_BYTE *)a1 + 144) = a3;
  *((_BYTE *)a1 + 145) = 0;
  uint64_t v9 = *a4;
  if (!*((_BYTE *)a1 + 160)) {
    *((_BYTE *)a1 + sub_1000A7938(v1 - 160) = 1;
  }
  a1[19] = v9;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  int v10 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000946B0(a3, &__p);
    if (!*((_BYTE *)a1 + 160)) {
      sub_100036CD8();
    }
    p_p = &__p;
    if (v56 < 0) {
      p_p = __p;
    }
    uint64_t v12 = a1[19];
    *(_DWORD *)__int128 buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)int v61 = 2082;
    *(void *)&v61[2] = "";
    *(_WORD *)&v61[10] = 2082;
    *(void *)&v61[12] = p_p;
    __int16 v62 = 2050;
    uint64_t v63 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:SensorsLogic, started activity, ActivityType:%{public, location:escape_only}s, recO rLocStartTime_s:%{public}.09f}",  buf,  0x26u);
    if (SHIBYTE(v56) < 0) {
      operator delete(__p);
    }
  }

  sub_1002F0B04(buf);
  CFStringRef v13 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsUwbRangeRequestedUpdateRateEnabled",  0x8000100u,  kCFAllocatorNull);
  char v14 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v13, (BOOL *)&__p);
  CFRelease(v13);
  int v15 = __p;
  uint64_t v16 = *(std::__shared_weak_count **)v61;
  if (*(void *)v61)
  {
    uint64_t v17 = (unint64_t *)(*(void *)v61 + 8LL);
    do
      unint64_t v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }

  if (v15) {
    char v19 = 0;
  }
  else {
    char v19 = v14;
  }
  if ((v19 & 1) == 0)
  {
    sub_1002F0B04(buf);
    CFStringRef v20 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsUwbRangeRequestedUpdateRate",  0x8000100u,  kCFAllocatorNull);
    int v21 = sub_1002A7D20(*(uint64_t *)buf, (uint64_t)v20, &__p);
    CFRelease(v20);
    uint64_t v22 = (int)__p;
    __int16 v23 = *(std::__shared_weak_count **)v61;
    if (*(void *)v61)
    {
      uint64_t v24 = (unint64_t *)(*(void *)v61 + 8LL);
      do
        unint64_t v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }

    if (!v21) {
      uint64_t v22 = 1LL;
    }
    sub_1002F0B04(buf);
    CFStringRef v26 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsUwbRangeRequestedUpdateDuration",  0x8000100u,  kCFAllocatorNull);
    int v27 = sub_1002A832C(*(uint64_t *)buf, (uint64_t)v26, &__p);
    CFRelease(v26);
    uint64_t v28 = __p;
    uint64_t v29 = *(std::__shared_weak_count **)v61;
    if (*(void *)v61)
    {
      __int16 v30 = (unint64_t *)(*(void *)v61 + 8LL);
      do
        unint64_t v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }

    double v32 = 2.5;
    if (v27) {
      double v32 = *(double *)&v28;
    }
    *(void *)__int128 buf = v22;
    *(double *)int v61 = v32;
    sub_1000C5F9C((uint64_t)(a1 + 40), (uint64_t *)buf);
    *((_BYTE *)a1 + 296) = 1;
  }

  *(double *)&std::string __p = 0.0;
  std::string v55 = 0LL;
  uint64_t v33 = (void *)a1[104];
  uint64_t v56 = 0LL;
  for (uint64_t i = &__p; v33; v33 = (void *)*v33)
  {
    std::string::size_type v34 = (char *)operator new(0x28uLL);
    *(void *)__int128 buf = v34;
    *(_OWORD *)int v61 = xmmword_1012C8460;
    *(_OWORD *)std::string::size_type v34 = 0u;
    *((_OWORD *)v34 + 1) = 0u;
    *(void *)(v34 + 29) = 0LL;
    sub_10000AE6C((uint64_t)(v33 + 2), v34);
    sub_1000936E8((uint64_t **)&i, (__int128 *)buf);
    if ((v61[15] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

  sub_1002F0B04(&i);
  CFStringRef v35 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBleRequestedScanLength", 0x8000100u, kCFAllocatorNull);
  int v36 = sub_1002A832C((uint64_t)i, (uint64_t)v35, &v59);
  CFRelease(v35);
  double v37 = v59;
  std::string v38 = v58;
  if (v58)
  {
    p_shared_owners = (unint64_t *)&v58->__shared_owners_;
    do
      unint64_t v40 = __ldaxr(p_shared_owners);
    while (__stlxr(v40 - 1, p_shared_owners));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }

  if (!v36) {
    double v37 = 1.6;
  }
  char v41 = sub_100105E48((uint64_t)a1);
  memset(v53, 0, sizeof(v53));
  sub_10010DD48(v53, (id *)a1[98], (id *)a1[99], (uint64_t)(a1[99] - a1[98]) >> 3);
  __n128 v51 = 0uLL;
  uint64_t v52 = 0LL;
  sub_10010DEE0((char *)&v51, (__int128 *)__p, v55, 0xAAAAAAAAAAAAAAABLL * (((char *)v55 - (_BYTE *)__p) >> 3));
  sub_1000946C8((uint64_t)buf, a3, 0, v41, (uint64_t)v53, &v51, v37);
  uint64_t i = (void **)&v51;
  sub_1000129D4(&i);
  uint64_t i = v53;
  sub_10010DBE0(&i);
  int v42 = *((unsigned __int8 *)a1 + 808);
  sub_1002F0B04(&i);
  CFStringRef v43 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBleRequestedScanEnabled", 0x8000100u, kCFAllocatorNull);
  char v44 = sub_1002A6FD4((uint64_t)i, (uint64_t)v43, (BOOL *)&v59);
  CFRelease(v43);
  int v45 = LOBYTE(v59);
  std::string v46 = v58;
  if (v58)
  {
    std::string v47 = (unint64_t *)&v58->__shared_owners_;
    do
      unint64_t v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }

  if (v45) {
    char v49 = 0;
  }
  else {
    char v49 = v44;
  }
  if ((v49 & 1) != 0 || !sub_100105E48((uint64_t)a1) && __p == v55)
  {
    sub_100105F84((uint64_t)a1, v42 == 1);
    (*(void (**)(void *))(*a1 + 64LL))(a1);
    uint64_t v50 = 0LL;
  }

  else
  {
    sub_1000C5C34((uint64_t)(a1 + 40));
    *((_WORD *)a1 + 404) = 0;
    sub_100105F84((uint64_t)a1, v42 == 1);
    sub_100106120((uint64_t)a1, (uint64_t)buf);
    uint64_t v50 = 1LL;
  }

  sub_1001054A4(a1, a5, v50);
  uint64_t i = (void **)&v64;
  sub_1000129D4(&i);
  uint64_t i = (void **)&v61[8];
  sub_10010DBE0(&i);
  *(void *)__int128 buf = &__p;
  sub_1000129D4((void ***)buf);
}

void sub_100105D5C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
}

BOOL sub_100105E48(uint64_t a1)
{
  BOOL v2 = *(void *)(a1 + 784) != *(void *)(a1 + 792) && *(_BYTE *)(a1 + 170) != 0;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  CFStringRef v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = (uint64_t)(*(void *)(a1 + 792) - *(void *)(a1 + 784)) >> 3;
    uint64_t v5 = *(unsigned __int8 *)(a1 + 170);
    v7[0] = 68289794;
    v7[1] = 0;
    __int16 v8 = 2082;
    uint64_t v9 = "";
    __int16 v10 = 1026;
    BOOL v11 = v2;
    __int16 v12 = 2050;
    uint64_t v13 = v4;
    __int16 v14 = 2050;
    uint64_t v15 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:SensorsLogic, shouldScanNearbyInfoV2, should scan?:%{public}hhd, num of entries in oObkey:%{public}lu, is motion session running?:%{public}lu}",  (uint8_t *)v7,  0x2Cu);
  }

  return v2;
}

void sub_100105F84(uint64_t a1, int a2)
{
  if (a2)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    CFStringRef v3 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "setting BLE background-scan session status to paused",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      v5[0] = 0;
      uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "setting BLE background-scan session status to paused",  v5,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::pauseBackgroundBleSessionIfNeeded(const BOOL)",  "%s\n",  v4);
    }

    *(_BYTE *)(a1 + 80++*(void *)(result + 8) = 2;
  }

uint64_t sub_100106120(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 9))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Register for BLE background-scan session",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      v9[0] = 0;
      uint64_t v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Register for BLE background-scan session",  v9,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::startBleRssiSession(const CLMicroLocationUtils::BleScanConfiguration &)",  "%s\n",  v7);
    }

    *(_BYTE *)(a1 + 80++*(void *)(result + 8) = 1;
  }

  else
  {
    sub_100105574(a1, (void *)a2);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v5 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Register for BLE initiated-scan session",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      v9[0] = 0;
      __int16 v8 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Register for BLE initiated-scan session",  v9,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::startBleRssiSession(const CLMicroLocationUtils::BleScanConfiguration &)",  "%s\n",  v8);
    }

    *(_BYTE *)(a1 + 809) = 1;
  }

  return sub_1000C5A70(a1 + 320, a2);
}

uint64_t sub_100106418(uint64_t a1)
{
  CFStringRef v3 = (void **)(a1 + 40);
  sub_1000129D4(&v3);
  CFStringRef v3 = (void **)(a1 + 16);
  sub_10010DBE0(&v3);
  return a1;
}

void sub_100106460(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 296))
  {
    sub_1000C60B0(a1 + 320);
    *(_BYTE *)(a1 + 296) = 0;
  }

  sub_10010652C(a1, v3);
  sub_100127460(*(uint64_t **)(a1 + 304), v3);
  sub_1001074D8(a1, (uint64_t *)v2);
  sub_100127460(*(uint64_t **)(a1 + 304), (uint64_t *)v2);
  if (*(_BYTE *)(a1 + 160)) {
    *(_BYTE *)(a1 + sub_1000A7938(v1 - 160) = 0;
  }
  uint64_t v4 = v2;
  sub_10004AB74((void ***)&v4);
  v2[0] = (void **)v3;
  sub_10004AB74(v2);
}

void sub_1001064F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, char a13)
{
  *(void *)(v14 - 24) = v13;
  sub_10004AB74((void ***)(v14 - 24));
  a10 = (void **)&a13;
  sub_10004AB74(&a10);
  _Unwind_Resume(a1);
}

void sub_10010652C(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  if (!*(_BYTE *)(a1 + 160))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v14 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CLMicroLocationSensorsLogic::getBleMeasurements, fState.fStartTime is nullopt!}",  buf,  0x12u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
    }

    uint64_t v15 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v15,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CLMicroLocationSensorsLogic::getBleMeasurements, fState.fStartTime is nullopt!",  "{msg%{public}.0s:CLMicroLocationSensorsLogic::getBleMeasurements, fState.fStartTime is nullopt!}",  buf,  0x12u);
    }

    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    return;
  }

  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  if (!*(_BYTE *)(a1 + 160)) {
    sub_100036CD8();
  }
  double v5 = Current_1;
  double v6 = Current_1 - *(double *)(a1 + 152);
  sub_100107F6C();
  p_vtable = &OBJC_METACLASS___CLPrivacyManager.vtable;
  uint64_t v9 = &OBJC_METACLASS___CLPrivacyManager.vtable;
  if (v6 < v7)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v16 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289282;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2050;
      *(double *)&buf[20] = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:BLE Scan duration, duration:%{public}.5f}",  buf,  0x1Cu);
    }

    if (!*(_BYTE *)(a1 + 160)) {
      sub_100036CD8();
    }
    sub_1002F0B04(buf);
    CFStringRef v17 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsBleScanMaximalAgeForValidityFromScanStart",  0x8000100u,  kCFAllocatorNull);
    unint64_t v12 = sub_1002A832C(*(uint64_t *)buf, (uint64_t)v17, v104);
    CFRelease(v17);
    double v18 = *(double *)v104;
    char v19 = *(std::__shared_weak_count **)&buf[8];
    if (*(void *)&buf[8])
    {
      CFStringRef v20 = (unint64_t *)(*(void *)&buf[8] + 8LL);
      do
        unint64_t v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }

    double v22 = 1.0;
    if ((_DWORD)v12) {
      double v22 = v18;
    }
    double v13 = *(double *)(a1 + 152) - v22;
  }

  else
  {
    double v10 = v7;
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    BOOL v11 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2050;
      *(double *)&buf[20] = v6;
      __int16 v113 = 2050;
      double v114 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Scan duration is exceeded threshold, duration:%{public}.5f, threshold:%{public}.5f}",  buf,  0x26u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
    }

    unint64_t v12 = qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)__int128 buf = 68289538;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2050;
      *(double *)&buf[20] = v6;
      __int16 v113 = 2050;
      double v114 = v10;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  (os_log_t)v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Scan duration is exceeded threshold",  "{msg%{public}.0s:Scan duration is exceeded threshold, duration:%{public}.5f, threshold:%{public}.5f}",  buf,  0x26u);
    }

    double v13 = v5 - v10;
  }

  double v103 = v13;
  sub_100108044(a1 + 648, &v103, &v102, &v100);
  *(_OWORD *)std::string __p = 0u;
  __int128 v98 = 0u;
  float v99 = 1.0;
  uint64_t v23 = v100;
  uint64_t v24 = v101;
  __int128 v94 = a2;
  if (v100 == v101)
  {
    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    goto LABEL_162;
  }

  do
  {
    if ((*(_BYTE *)(v23 + 72) & 0x40) == 0) {
      goto LABEL_143;
    }
    uint64_t v25 = *(void *)(v23 + 48);
    if (!v25) {
      uint64_t v25 = *(void *)(qword_1019A0818 + 48);
    }
    double v26 = *(double *)(v25 + 8);
    float v27 = *(float *)(v25 + 20);
    unint64_t v28 = sub_10010E2F8((uint64_t)v104, *(char **)(v25 + 48));
    unint64_t v29 = 0xC6A4A7935BD1E995LL * LODWORD(v27);
    if (v27 == 0.0) {
      unint64_t v29 = 0LL;
    }
    unint64_t v30 = 0xC6A4A7935BD1E995LL * (v29 ^ (v29 >> 47));
    unint64_t v31 = 0xC6A4A7935BD1E995LL * *(void *)&v26;
    if (v26 == 0.0) {
      unint64_t v31 = 0LL;
    }
    unint64_t v32 = (0xC6A4A7935BD1E995LL * (v30 ^ (0x35A98F4D286A90B9LL * (v31 ^ (v31 >> 47)) + 3864292196u)) + 3864292196u) ^ (0xC6A4A7935BD1E995LL * ((0xC6A4A7935BD1E995LL * v28) ^ ((0xC6A4A7935BD1E995LL * v28) >> 47)));
    unint64_t v33 = 0xC6A4A7935BD1E995LL * v32 + 3864292196u;
    unint64_t v34 = (unint64_t)__p[1];
    if (__p[1])
    {
      uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
      v35.i16[0] = vaddlv_u8(v35);
      unint64_t v36 = v35.u32[0];
      if (v35.u32[0] > 1uLL)
      {
        unint64_t v12 = 0xC6A4A7935BD1E995LL * v32 + 3864292196u;
      }

      else
      {
        unint64_t v12 = ((unint64_t)__p[1] - 1) & v33;
      }

      double v37 = (void *)*((void *)__p[0] + v12);
      if (v37)
      {
        std::string v38 = (void *)*v37;
        if (*v37)
        {
          uint64_t v39 = qword_1019A0818;
          while (1)
          {
            unint64_t v40 = v38[1];
            if (v40 == v33) {
              break;
            }
            if (v36 > 1)
            {
            }

            else
            {
              v40 &= (unint64_t)__p[1] - 1;
            }

            if (v40 != v12) {
              goto LABEL_87;
            }
LABEL_81:
            std::string v38 = (void *)*v38;
            if (!v38) {
              goto LABEL_87;
            }
          }

          uint64_t v41 = *(void *)(v38[2] + 48LL);
          uint64_t v42 = v41;
          if (!v41) {
            uint64_t v42 = *(void *)(v39 + 48);
          }
          uint64_t v43 = *(void *)(v23 + 48);
          uint64_t v44 = v43;
          if (!v43) {
            uint64_t v44 = *(void *)(v39 + 48);
          }
          uint64_t v45 = *(void *)(v38[2] + 48LL);
          if (!v41) {
            uint64_t v45 = *(void *)(v39 + 48);
          }
          uint64_t v46 = *(void *)(v23 + 48);
          if (!v43) {
            uint64_t v46 = *(void *)(v39 + 48);
          }
          if (v41)
          {
            if (v43) {
              goto LABEL_62;
            }
          }

          else
          {
            uint64_t v41 = *(void *)(v39 + 48);
            if (v43) {
              goto LABEL_62;
            }
          }

          uint64_t v43 = *(void *)(v39 + 48);
LABEL_62:
          std::string v47 = *(unsigned __int8 **)(v41 + 48);
          unint64_t v48 = *(unsigned __int8 **)(v43 + 48);
          uint64_t v49 = v47[23];
          if ((v49 & 0x80u) == 0LL) {
            uint64_t v50 = v47[23];
          }
          else {
            uint64_t v50 = *((void *)v47 + 1);
          }
          uint64_t v51 = v48[23];
          int v52 = (char)v51;
          if ((v51 & 0x80u) != 0LL) {
            uint64_t v51 = *((void *)v48 + 1);
          }
          if (v50 == v51)
          {
            if (v52 >= 0) {
              std::string v53 = v48;
            }
            else {
              std::string v53 = *(unsigned __int8 **)v48;
            }
            if ((v49 & 0x80) != 0)
            {
            }

            else
            {
              if (!v47[23]) {
                goto LABEL_143;
              }
              while (*v47 == *v53)
              {
                ++v47;
                ++v53;
                if (!--v49) {
                  goto LABEL_143;
                }
              }
            }
          }

          goto LABEL_81;
        }
      }
    }

LABEL_142:
    ++*((void *)&v98 + 1);
LABEL_143:
    v23 += 80LL;
  }

  while (v23 != v24);
  __int128 v75 = (void *)v98;
  a2 = v94;
  v94[1] = 0LL;
  v94[2] = 0LL;
  uint64_t *v94 = 0LL;
  uint64_t v9 = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
  p_vtable = (void **)(&OBJC_METACLASS___CLPrivacyManager + 24);
  if (v75)
  {
    unint64_t v76 = 0LL;
    do
    {
      uint64_t v77 = v75[2];
      if (v76 >= v94[2])
      {
        unint64_t v76 = sub_10010E354(v94, v77);
      }

      else
      {
        sub_100068220(v76, v77);
        *(_DWORD *)(v76 + 80) = 0;
        v76 += 88LL;
        v94[1] = v76;
      }

      v94[1] = v76;
      __int128 v75 = (void *)*v75;
    }

    while (v75);
  }

  *(_DWORD *)(a1 + 144) = v5;
  return v5;
}

  *__int128 v87 = v73;
  uint64_t v88 = v116;
  if (v116)
  {
    __int128 v89 = (unint64_t *)&v116->__shared_owners_;
    do
      uint64_t v90 = __ldaxr(v89);
    while (__stlxr(v90 - 1, v89));
    if (!v90)
    {
      ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
      std::__shared_weak_count::__release_weak(v88);
    }
  }

  if (__p)
  {
    int v119 = (float *)__p;
    operator delete(__p);
  }

  return v72;
}

    uint64_t v90 = 0;
    std::string::size_type v91 = (float)(v13 * 4.0) * 13.75;
    uint64_t v92 = *(_DWORD *)(a1 + 228);
    if (*(_BYTE *)(a1 + 24) && v92 >= 2) {
      uint64_t v90 = (*((float *)&v147 + 1) > v91 || *(float *)(a1 + 1224) > 32.0) && *((float *)&v151 + 1) < 1.12499997;
    }
    if (v92 > 40 || (*((float *)&v147 + 1) <= v91 ? (uint64_t v100 = !v90) : (uint64_t v100 = 0), !v100))
    {
      uint64_t v101 = !v90;
      if (*(_BYTE *)(a1 + 24)) {
        uint64_t v101 = 0;
      }
      if (v101
        || (char v102 = *(_DWORD *)(a1 + 236), v103 = *(float *)(a1 + 16), v103 * 0.25 <= (double)v102)
        && ((float)(v103 * 10.0) <= (float)v102
         || v103 >= (float)*(int *)(a1 + 248)
         || v24 >= 78.0
         || *(float *)&v145 >= *((float *)&v145 + 1)))
      {
        sub_1007ADADC(a1);
        *(_DWORD *)(a1 + 22++*(void *)(result + 8) = 0;
        return 1LL;
      }

      if (qword_101934580 != -1) {
        dispatch_once(&qword_101934580, &stru_10184F718);
      }
      __int128 v104 = (os_log_s *)qword_101934588;
      if (os_log_type_enabled((os_log_t)qword_101934588, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v104,  OS_LOG_TYPE_DEBUG,  "Likely bad database lookup. Resetting. ",  buf,  2u);
      }

      if (sub_1002921D0(115, 2))
      {
        bzero(buf, 0x65CuLL);
        if (qword_101934580 != -1) {
          dispatch_once(&qword_101934580, &stru_10184F718);
        }
        LOWORD(v152) = 0;
        LODWORD(v141) = 2;
        _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_101934588,  2LL,  "Likely bad database lookup. Resetting. ",  &v152,  *(void *)&v141);
        char v140 = (uint8_t *)v139;
        sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLAttitudeDependentKFCalibrator::handleInterference(const CLVector3d<float> &, const CLVector3d<float> &, BOOL, BOOL)",  "%s\n",  v139);
        if (v140 != buf) {
          free(v140);
        }
      }

      (*(void (**)(uint64_t))(*(void *)a1 + 24LL))(a1);
    }

  uint64_t v39 = *(void *)(v5 + 280);
  if (!v39) {
    uint64_t v39 = *(void *)(qword_1019A1D38 + 280);
  }
  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteMessage( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x3F,  v39,  a2,  a4);
  unint64_t v36 = *(_DWORD *)(v5 + 400);
  if ((v36 & 0x20) == 0)
  {
LABEL_130:
    if ((v36 & 0x40) == 0) {
      goto LABEL_131;
    }
    goto LABEL_148;
  }

  unint64_t v73 = *(void *)(a1 + 152);
  if (!v73) {
    unint64_t v73 = *(void *)(qword_1019A1D38 + 152);
  }
  uint64_t v74 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100BBF008(v73);
  __int128 v75 = (int)v74;
  else {
    unint64_t v76 = 1;
  }
  v4 += v75 + v76 + 2;
  CFStringRef v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x100000) == 0)
  {
LABEL_118:
    if ((v3 & 0x200000) == 0) {
      goto LABEL_119;
    }
    goto LABEL_156;
  }

  uint64_t result = *(float *)(a2 + 180);
  v5 |= 0x40000000000uLL;
  *BOOL v2 = v5;
  *(_WORD *)(a1 + 28++*(void *)(result + 8) = v6;
  *(float *)(a1 + 180) = result;
  uint64_t v4 = *v3;
  double v7 = *(_WORD *)(a2 + 288);
  if ((*v3 & 0x100000000000LL) == 0)
  {
LABEL_69:
    if ((v4 & 0x200000000000LL) == 0) {
      goto LABEL_70;
    }
    goto LABEL_144;
  }

  PB::TextFormatter::format(this, "maxAccelNormThresholdWithAudio", *(float *)(a1 + 224));
  double v6 = *v5;
  double v7 = *(_WORD *)(a1 + 288);
  if ((*v5 & 0x40000000000000LL) == 0)
  {
LABEL_68:
    if ((v6 & 0x80000000000000LL) == 0) {
      goto LABEL_69;
    }
    goto LABEL_144;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 192), 0x3Fu);
  double v5 = *v4;
  double v6 = *((_WORD *)v4 + 4);
  if ((*v4 & 0x400000000000LL) == 0)
  {
LABEL_68:
    if ((v5 & 0x800000000000LL) == 0) {
      goto LABEL_69;
    }
    goto LABEL_144;
  }

  uint64_t result = *(float *)(a2 + 168);
  v5 |= 0x8000000000uLL;
  *BOOL v2 = v5;
  *(_WORD *)(a1 + 324) = v6;
  *(_BYTE *)(a1 + 326) = BYTE2(v6);
  *(float *)(a1 + 16++*(void *)(result + 8) = result;
  LOWORD(v++*(void *)(result + 8) = *(_WORD *)(a2 + 324);
  uint64_t v4 = *v3;
  if ((*v3 & 0x2000000000LL) == 0)
  {
LABEL_62:
    if ((v4 & 0x20000000000LL) == 0) {
      goto LABEL_63;
    }
    goto LABEL_144;
  }

  PB::TextFormatter::format(this, "lowSenseWithAudioZgtimeThreshold", *(float *)(a1 + 204));
  double v7 = *(unsigned __int16 *)(a1 + 324) | (*(unsigned __int8 *)(a1 + 326) << 16);
  double v6 = *v5;
  if ((*v5 & 0x2000000000000LL) == 0)
  {
LABEL_61:
    if ((v6 & 0x4000000000000LL) == 0) {
      goto LABEL_62;
    }
    goto LABEL_144;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 168), 0xFCu);
  LOWORD(v7) = *((_WORD *)v4 + 4);
  double v5 = *v4;
  if ((*v4 & 0x2000000000LL) == 0)
  {
LABEL_62:
    if ((v5 & 0x20000000000LL) == 0) {
      goto LABEL_63;
    }
    goto LABEL_144;
  }

  unint64_t v31 = *(_BYTE *)(a2 + 330);
  v6 |= 0x80000uLL;
  *BOOL v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(_BYTE *)(a1 + 330) = v31;
  uint64_t v4 = *v3;
  double v7 = *(void *)(a2 + 364);
  if ((v7 & 0x8000000) == 0)
  {
LABEL_37:
    if ((v7 & 0x20000000) == 0) {
      goto LABEL_38;
    }
    goto LABEL_144;
  }

  PB::TextFormatter::format(this, "kIsEventDetectedRO", *(_BYTE *)(a1 + 340));
  double v7 = *v5;
  double v6 = *(void *)(a1 + 364);
  if ((*v5 & 4) == 0)
  {
LABEL_41:
    if ((v7 & 8) == 0) {
      goto LABEL_42;
    }
    goto LABEL_144;
  }

  uint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 330), 0x71u);
  double v5 = *v4;
  double v6 = v4[1];
  if ((v6 & 0x8000000) == 0)
  {
LABEL_37:
    if ((v6 & 0x20000000) == 0) {
      goto LABEL_38;
    }
    goto LABEL_144;
  }

  uint64_t v74 = *(_DWORD *)(a2 + 88);
  v3 |= 0x10000uLL;
  *(void *)(result + 204) = v3;
  *(_WORD *)(result + 212) = v4;
  *(_BYTE *)(result + 214) = BYTE2(v4);
  *(_DWORD *)(result + 8++*(void *)(result + 8) = v74;
  LOWORD(v5) = *(_WORD *)(a2 + 212);
  BOOL v2 = *(void *)(a2 + 204);
  if ((v5 & 1) == 0)
  {
LABEL_64:
    if ((v2 & 0x10000000000000LL) == 0) {
      goto LABEL_65;
    }
    goto LABEL_144;
  }

  PB::TextFormatter::format(this, "maxEnergy", *(float *)(a1 + 108));
  double v6 = *(unsigned __int16 *)(a1 + 212) | (*(unsigned __int8 *)(a1 + 214) << 16);
  double v5 = *(void *)(a1 + 204);
  if ((v5 & 0x400000) == 0)
  {
LABEL_63:
    if ((v5 & 0x800000) == 0) {
      goto LABEL_64;
    }
    goto LABEL_144;
  }

  uint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 178), 0x460u);
  double v5 = *(unsigned __int16 *)(v3 + 212) | (*(unsigned __int8 *)(v3 + 214) << 16);
  uint64_t v4 = *(void *)(v3 + 204);
  if ((v4 & 0x800000000000000LL) == 0)
  {
LABEL_64:
    if ((v5 & 8) == 0) {
      goto LABEL_65;
    }
    goto LABEL_144;
  }

        *(_DWORD *)(a1 + 44) = v35;
        goto LABEL_158;
      case 3u:
        *(_BYTE *)(a1 + 64) |= 1u;
        std::string v38 = *((void *)this + 1);
        uint64_t v39 = *((void *)this + 2);
        unint64_t v40 = *(void *)this;
        if (v38 <= 0xFFFFFFFFFFFFFFF5LL && v38 + 10 <= v39)
        {
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          uint64_t v43 = 0LL;
          do
          {
            uint64_t v44 = v38 + 1;
            *((void *)this + 1) = v38 + 1;
            uint64_t v45 = *(_BYTE *)(v40 + v38);
            v43 |= (unint64_t)(v45 & 0x7F) << v41;
            if ((v45 & 0x80) == 0) {
              goto LABEL_145;
            }
            v41 += 7;
            std::string v38 = v44;
            uint64_t v15 = v42++ > 8;
          }

          while (!v15);
LABEL_99:
          LODWORD(v43) = 0;
          goto LABEL_145;
        }

        __int128 v93 = 0;
        __int128 v94 = 0;
        uint64_t v43 = 0LL;
        if (v39 <= v38) {
          uint64_t v39 = *((void *)this + 1);
        }
        while (2)
        {
          if (v39 == v38)
          {
            LODWORD(v43) = 0;
            *((_BYTE *)this + 24) = 1;
          }

          else
          {
            __int128 v95 = v38 + 1;
            __int128 v96 = *(_BYTE *)(v40 + v38);
            *((void *)this + 1) = v95;
            v43 |= (unint64_t)(v96 & 0x7F) << v93;
            if (v96 < 0)
            {
              v93 += 7;
              std::string v38 = v95;
              uint64_t v15 = v94++ > 8;
              if (v15) {
                goto LABEL_99;
              }
              continue;
            }

            if (*((_BYTE *)this + 24)) {
              LODWORD(v43) = 0;
            }
          }

          break;
        }

LABEL_162:
  int v78 = (os_log_s *)v9[283];
  if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v79 = 0x2E8BA2E8BA2E8BA3LL * ((a2[1] - *a2) >> 3);
    *(_DWORD *)__int128 buf = 134218240;
    *(void *)&uint8_t buf[4] = 0xCCCCCCCCCCCCCCCDLL * ((v101 - v100) >> 4);
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v79;
    _os_log_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_DEFAULT,  "Read BLE spyscan buffer in Logic!. read %lu measurements (%lu unique)",  buf,  0x16u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    std::string::size_type v91 = v9[283];
    uint64_t v92 = 0x2E8BA2E8BA2E8BA3LL * ((a2[1] - *a2) >> 3);
    *(_DWORD *)__int128 v104 = 134218240;
    *(void *)&v104[4] = 0xCCCCCCCCCCCCCCCDLL * ((v101 - v100) >> 4);
    *(_WORD *)&v104[12] = 2048;
    *(void *)&v104[14] = v92;
    __int128 v93 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v91,  0LL,  "Read BLE spyscan buffer in Logic!. read %lu measurements (%lu unique)",  v104,  22);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<CLMiLoProtobufWrapper::Measurement> CLMicroLocationSensorsLogic::getBleMeasurements()",  "%s\n",  v93);
    if (v93 != buf) {
      free(v93);
    }
  }

  if (os_log_type_enabled((os_log_t)v9[283], OS_LOG_TYPE_DEBUG))
  {
    uint64_t v80 = *v94;
    uint64_t v81 = v94[1];
    if (*v94 != v81)
    {
      do
      {
        sub_100068220(buf, v80);
        uint64_t v82 = v115;
        if (!v115) {
          uint64_t v82 = *(void *)(qword_1019A0818 + 48);
        }
        sub_1001014F0(*(uint64_t ***)(v82 + 48), v111);
        if (qword_1019348E0 != -1) {
          dispatch_once(&qword_1019348E0, &stru_10181F638);
        }
        std::string::size_type v83 = (os_log_s *)qword_1019348E8;
        if (os_log_type_enabled((os_log_t)qword_1019348E8, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v84 = v115;
          if (!v115) {
            uint64_t v84 = *(void *)(qword_1019A0818 + 48);
          }
          int v85 = (int)*(float *)(v84 + 20);
          if (v111[16])
          {
            uint64_t v86 = operator new(0x28uLL);
            __int128 v95 = v86;
            __int128 v96 = xmmword_1012C8460;
            *uint64_t v86 = 0u;
            v86[1] = 0u;
            *(void *)((char *)v86 + 29) = 0LL;
            sub_10000AE6C((uint64_t)v111, v86);
            __int128 v87 = (const char *)&v95;
            if (v96 < 0) {
              __int128 v87 = (const char *)v95;
            }
            uint64_t v88 = v115;
            if (!v115) {
              uint64_t v88 = *(void *)(qword_1019A0818 + 48);
            }
            __int128 v89 = *(uint64_t **)(v88 + 40);
            *(_DWORD *)__int128 v104 = 68290051;
            *(_DWORD *)&v104[4] = 0;
            *(_WORD *)&v104[8] = 2082;
            *(void *)&v104[10] = "";
            *(_WORD *)&v104[18] = 1025;
            *(_DWORD *)&v104[20] = v85;
            __int16 v105 = 2081;
            __int128 v106 = v87;
            __int16 v107 = 2081;
            unsigned __int8 v108 = v89;
            __int16 v109 = 2050;
            uint64_t v110 = *(void *)&buf[8];
            _os_log_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:BLE cached scan, rssi:%{private}d, uuid:%{private, location:escape_only}s , model:%{private, location:escape_only}s, time_s:%{public}.09f}",  v104,  0x36u);
            if (SHIBYTE(v96) < 0) {
              operator delete(v95);
            }
          }

          else
          {
            uint64_t v90 = *(uint64_t **)(v84 + 40);
            *(_DWORD *)__int128 v104 = 68290051;
            *(_DWORD *)&v104[4] = 0;
            *(_WORD *)&v104[8] = 2082;
            *(void *)&v104[10] = "";
            *(_WORD *)&v104[18] = 1025;
            *(_DWORD *)&v104[20] = v85;
            __int16 v105 = 2081;
            __int128 v106 = "not available";
            __int16 v107 = 2081;
            unsigned __int8 v108 = v90;
            __int16 v109 = 2050;
            uint64_t v110 = *(void *)&buf[8];
            _os_log_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:BLE cached scan, rssi:%{private}d, uuid:%{private, location:escape_only}s , model:%{private, location:escape_only}s, time_s:%{public}.09f}",  v104,  0x36u);
          }
        }

        sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)buf);
        v80 += 88LL;
      }

      while (v80 != v81);
    }
  }

  if (v102)
  {
    sub_1010DDBC0(buf, "BLE spyscan buffer overflow");
    sub_100133C10((uint64_t *)buf);
    if ((buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

  sub_100019CEC((uint64_t)__p);
  *(void *)__int128 buf = &v100;
  sub_10010E26C((void ***)buf);
}

      __int128 v98 = (void *)v72[1];
      if (v98)
      {
        do
        {
          float v99 = v98;
          __int128 v98 = (void *)*v98;
        }

        while (v98);
      }

      else
      {
        do
        {
          float v99 = (void *)v72[2];
          _ZF = *v99 == (void)v72;
          __int16 v72 = v99;
        }

        while (!_ZF);
      }

      __int16 v72 = v99;
    }

    while (v99 != (void *)(a1 + 824));
  }

  if (v257 && sub_100B58B88((_BYTE *)(a1 + 1312)))
  {
    sub_1002718F0(v328, (__int128 *)v65);
    *(_DWORD *)&v335[24] = sub_100A0D208(a1 + 904, (unsigned __int8 *)v65);
    *(_DWORD *)&v335[20] = sub_100A0D244(a1 + 904);
    __int16 v109 = *(_OWORD *)(a5 + 48);
    v264[2] = *(_OWORD *)(a5 + 32);
    v264[3] = v109;
    v264[4] = *(_OWORD *)(a5 + 64);
    v265 = *(void *)(a5 + 80);
    uint64_t v110 = *(_OWORD *)(a5 + 16);
    v264[0] = *(_OWORD *)a5;
    v264[1] = v110;
    LODWORD(v264[0]) = v272;
    (*(void (**)(CLMotionActivity *__return_ptr))(**(void **)(a1 + 1768) + 128LL))(&v357);
    int v111 = (*(uint64_t (**)(void))(**(void **)(a1 + 1768) + 16LL))(*(void *)(a1 + 1768));
    sub_100B5AD68( (uint64_t)buf,  (uint64_t)v328,  (double *)v264,  (__int128 *)(a1 + 1648),  &v357,  (uint64_t)v320,  a1 + 144,  v111,  a6,  *(_BYTE *)(a1 + 613),  *(_BYTE *)(a1 + 728));
    sub_100B5AD7C((uint64_t)buf);
    *(double *)(a5 + 56) = a6;
    *(_DWORD *)(a5 + 64) = v325;
    if (*((void *)&v381 + 1))
    {
      *(void *)v382 = *((void *)&v381 + 1);
      operator delete(*((void **)&v381 + 1));
    }

    if ((buf[31] & 0x80000000) != 0) {
      operator delete(*(void **)&buf[8]);
    }
    if (*(void *)&v343[12])
    {
      *(void *)v344 = *(void *)&v343[12];
      operator delete(*(void **)&v343[12]);
    }

    if ((v343[3] & 0x80000000) != 0) {
      operator delete(v339);
    }
    if (SHIBYTE(v332) < 0) {
      operator delete(*(void **)&v330[34]);
    }
    if ((v330[33] & 0x80000000) != 0) {
      operator delete(*(void **)&v330[10]);
    }
    if ((v330[9] & 0x80000000) != 0) {
      operator delete(*(void **)v328);
    }
  }

  if (SHIBYTE(cap) < 0) {
    operator delete(__dst[0]);
  }
  __int128 v248 = 0;
  BOOL v56 = 0;
  v257 = 0;
  v251 = 1;
  while (1)
  {
LABEL_211:
    if (qword_101934870 != -1) {
      dispatch_once(&qword_101934870, &stru_101866E28);
    }
    int v118 = qword_101934878;
    if (os_log_type_enabled((os_log_t)qword_101934878, OS_LOG_TYPE_DEFAULT))
    {
      else {
        int v119 = *(void *)(v65 + 24);
      }
      v239 = v119;
      logb = (os_log_s *)v118;
      else {
        int v120 = *(void *)v65;
      }
      unint64_t v235 = v120;
      uint64_t v121 = sub_100832C40(v325);
      uint64_t v122 = *(void *)&v320[4];
      __int16 v123 = *(void *)&v320[12];
      uint64_t v124 = *(void *)&v320[20];
      sub_10083F904(*(_DWORD *)(a5 + 8), (std::string *)v328);
      v247 = v56;
      if (v330[9] >= 0) {
        __int16 v125 = v328;
      }
      else {
        __int16 v125 = *(_BYTE **)v328;
      }
      else {
        char v126 = "-";
      }
      __int16 v127 = *(unsigned __int8 *)(a1 + 623);
      if (__str[9].__r_.__value_.__l.__cap_ == __str[9].__r_.__value_.__l.__size_) {
        char v128 = __str[3].__r_.__value_.__r.__words[0];
      }
      else {
        char v128 = 0xBFF0000000000000LL;
      }
      if (__str[9].__r_.__value_.__l.__cap_ == __str[9].__r_.__value_.__l.__size_) {
        uint64_t v129 = __str[3].__r_.__value_.__l.__size_;
      }
      else {
        uint64_t v129 = 0xBFF0000000000000LL;
      }
      __int128 v130 = sub_1009232CC((uint64_t)__str);
      uint64_t v131 = *(double *)(a5 + 40);
      uint64_t v132 = a6 - v131;
      int v133 = v131 <= 0.0;
      char v134 = -1.0;
      if (!v133) {
        char v134 = v132;
      }
      int v135 = *(_DWORD *)a5 + 1;
      if (v135 > 4) {
        char v136 = "---";
      }
      else {
        char v136 = (&off_101866FF8)[v135];
      }
      std::stringbuf::string_type v137 = v123;
      else {
        char v138 = (&off_101866FF8)[v272 + 1];
      }
      else {
        __int128 v139 = (&off_101867020)[v256];
      }
      char v140 = __str[5].__r_.__value_.__l.__data_;
      uint64_t v141 = *(_DWORD *)(a1 + 684);
      char v142 = *(_DWORD *)(a1 + 688);
      __int128 v143 = *(_DWORD *)(a1 + 704);
      uint64_t v144 = *(_DWORD *)(a1 + 708);
      else {
        char v145 = (&off_101867020)[v254];
      }
      v384 = *(void *)(a5 + 72);
      __int128 v146 = *(_DWORD *)(a5 + 84);
      v386 = *(_DWORD *)(a5 + 80);
      *(void *)&uint8_t buf[4] = v239;
      *(void *)&buf[14] = v235;
      *(void *)&_BYTE buf[24] = v121;
      *(void *)&uint8_t buf[34] = v122;
      *(void *)&buf[44] = v137;
      *(_WORD *)&buf[52] = 2050;
      *(void *)&buf[54] = v124;
      *(void *)&v359[10] = v125;
      *(void *)&v359[20] = v126;
      *(_DWORD *)&v359[42] = v127;
      *(void *)v360 = v128;
      *(void *)&v360[10] = v129;
      v362 = v140;
      v364 = v141;
      v366 = v142;
      v368 = v143;
      v370 = v144;
      v376 = v136;
      v378 = v138;
      *(void *)v380 = v139;
      *(_WORD *)&buf[12] = 2081;
      *(_WORD *)&buf[22] = 2081;
      *(_WORD *)&v359[8] = 2081;
      *(_WORD *)&v359[18] = 2081;
      v375 = 2081;
      v377 = 2081;
      v379 = 2081;
      *(_WORD *)&v380[8] = 2081;
      *(void *)&v380[10] = v145;
      *(_WORD *)&v359[28] = 1025;
      *(_WORD *)&v359[34] = 1025;
      *(_WORD *)&v359[40] = 1025;
      v363 = 1025;
      v365 = 1025;
      v367 = 1025;
      v369 = 1025;
      v373 = 1025;
      *(_WORD *)&v380[18] = 1025;
      *(_WORD *)&uint8_t buf[32] = 2049;
      *(_WORD *)&buf[42] = 2049;
      *(_WORD *)&buf[62] = 2049;
      *(_WORD *)&v359[46] = 2049;
      *(_WORD *)&v360[8] = 2049;
      *(_WORD *)&v360[18] = 2049;
      v361 = 2049;
      v371 = 2049;
      WORD2(v381) = 2049;
      v383 = 2048;
      HIWORD(v381) = 1024;
      *(_WORD *)&v382[4] = 1024;
      v385 = 1024;
      v387 = 1024;
      v388 = v146;
      char v147 = *(double *)(a5 + 56);
      uint64_t v148 = a6 - v147;
      int v133 = v147 <= 0.0;
      char v149 = -1.0;
      if (!v133) {
        char v149 = v148;
      }
      *(_DWORD *)__int128 buf = 136388867;
      *(double *)v359 = v17;
      *(_DWORD *)&v359[30] = v257;
      BOOL v56 = v247;
      *(_DWORD *)&v359[36] = v247;
      *(double *)&v360[20] = v130;
      v372 = v134;
      v374 = v252;
      LODWORD(v381) = v253;
      *(double *)((char *)&v381 + 6) = v149;
      *(_DWORD *)v382 = v248;
      *(_DWORD *)&v382[6] = v251;
      _os_log_impl( (void *)&_mh_execute_header,  logb,  OS_LOG_TYPE_DEFAULT,  "Fence: fenceUpdate, %{private}s, bundle, %{private}s, type, %{private}-16s, loc, %{private}12.7lf, %{private}12. 7lf, acc, %{public}4.0lf, distance, %{private}9.0lf, tech, %{private}4s%{private}s, trans, %{private}d, state, % {private}d, cont, %{private}d, fence, %{private}12.8lf, %{private}12.8lf, %{private}.1lf, %{private}.1lf, sCount , %{private}d, %{private}d, trig, %{private}d, %{private}d, sinceLastLoc, %{private}.1lf, events, 0x%{private}08 x, status, %{private}-10s => %{private}-10s, settled state, %{private}s ==> %{private}s, cantShiftButNeedTo, %{p rivate}d, sinceLastTransition, %{private}.1lf, significant, %d, loi, %d, lastProximityStateTimestamp, %f, lastPr oximityState, %d, lastApproachingState, %d",  buf,  0x118u);
      if ((v330[9] & 0x80000000) != 0) {
        operator delete(*(void **)v328);
      }
    }

    int v150 = sub_1002921D0(115, 2);
    char v151 = v56;
    std::string v152 = v255;
    std::string v153 = v256;
    std::string v154 = v254;
    if (v150)
    {
      bzero(buf, 0x65CuLL);
      if (qword_101934870 != -1) {
        dispatch_once(&qword_101934870, &stru_101866E28);
      }
      logc = (os_log_t)qword_101934878;
      if ((__str[1].__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v171 = __str + 1;
      }
      else {
        uint64_t v171 = (std::string *)__str[1].__r_.__value_.__l.__data_;
      }
      __int128 v240 = v171;
      if ((__str->__r_.__value_.__s.__size_ & 0x80u) == 0) {
        __int128 v172 = __str;
      }
      else {
        __int128 v172 = (std::string *)__str->__r_.__value_.__r.__words[0];
      }
      __int128 v236 = v172;
      __int128 v234 = sub_100832C40(v325);
      uint64_t v173 = *(void *)&v320[4];
      v233 = *(void *)&v320[12];
      std::string v174 = *(void *)&v320[20];
      sub_10083F904(*(_DWORD *)(a5 + 8), (std::string *)&v357);
      if (v357.conservativeMountedState >= 0) {
        std::string v175 = &v357;
      }
      else {
        std::string v175 = *(CLMotionActivity **)&v357.type;
      }
      else {
        std::string v176 = "-";
      }
      std::string v177 = *(unsigned __int8 *)(a1 + 623);
      std::string v178 = __str[3].__r_.__value_.__r.__words[0];
      if (__str[9].__r_.__value_.__l.__cap_ != __str[9].__r_.__value_.__l.__size_) {
        std::string v178 = 0xBFF0000000000000LL;
      }
      v232 = v178;
      if (__str[9].__r_.__value_.__l.__cap_ == __str[9].__r_.__value_.__l.__size_) {
        std::string v179 = __str[3].__r_.__value_.__l.__size_;
      }
      else {
        std::string v179 = 0xBFF0000000000000LL;
      }
      std::string v180 = sub_1009232CC((uint64_t)__str);
      std::string v181 = *(double *)(a5 + 40);
      int v182 = a6 - v181;
      int v133 = v181 <= 0.0;
      __int16 v183 = -1.0;
      if (!v133) {
        __int16 v183 = v182;
      }
      int v184 = *(_DWORD *)a5 + 1;
      if (v184 > 4) {
        uint64_t v185 = "---";
      }
      else {
        uint64_t v185 = (&off_101866FF8)[v184];
      }
      else {
        std::string v188 = (&off_101866FF8)[v272 + 1];
      }
      else {
        int v189 = (&off_101867020)[v256];
      }
      __int128 v190 = __str[5].__r_.__value_.__l.__data_;
      char v191 = *(_DWORD *)(a1 + 684);
      uint64_t v192 = *(_DWORD *)(a1 + 688);
      __int128 v193 = *(_DWORD *)(a1 + 704);
      __int128 v194 = *(_DWORD *)(a1 + 708);
      else {
        __int128 v195 = (&off_101867020)[v254];
      }
      *((void *)&v347 + 1) = *(void *)(a5 + 72);
      uint64_t v196 = *(_DWORD *)(a5 + 84);
      *(_DWORD *)((char *)&v348 + 2) = *(_DWORD *)(a5 + 80);
      *(void *)&v328[4] = v240;
      *(void *)v330 = v236;
      *(void *)&v330[10] = v234;
      *(void *)&v330[20] = v173;
      *(void *)&v330[30] = v233;
      *(_WORD *)&v330[38] = 2050;
      *(void *)&v330[40] = v174;
      *(void *)&v333[2] = v175;
      *(void *)&v333[12] = v176;
      *(_DWORD *)((char *)&v334 + 2) = v177;
      *((void *)&v334 + 1) = v232;
      *(void *)&v335[2] = v179;
      *(void *)&v335[22] = v190;
      LODWORD(v336) = v191;
      *(_DWORD *)((char *)&v336 + 6) = v192;
      HIDWORD(v336) = v193;
      *(_DWORD *)&v337[2] = v194;
      v339 = v185;
      v341 = v188;
      *(void *)v343 = v189;
      v329 = 2081;
      *(_WORD *)&v330[8] = 2081;
      *(_WORD *)v333 = 2081;
      *(_WORD *)&v333[10] = 2081;
      v338 = 2081;
      v340 = 2081;
      v342 = 2081;
      *(_WORD *)&v343[8] = 2081;
      *(void *)&v343[10] = v195;
      *(_WORD *)&v333[20] = 1025;
      *(_WORD *)&v333[26] = 1025;
      LOWORD(v334) = 1025;
      *(_WORD *)&v335[30] = 1025;
      WORD2(v336) = 1025;
      WORD5(v336) = 1025;
      *(_WORD *)v337 = 1025;
      *(_WORD *)&v337[16] = 1025;
      *(_WORD *)&v343[18] = 1025;
      *(_DWORD *)v344 = v253;
      *(_WORD *)&v330[18] = 2049;
      *(_WORD *)&v330[28] = 2049;
      v331 = 2049;
      WORD3(v334) = 2049;
      *(_WORD *)v335 = 2049;
      *(_WORD *)&v335[10] = 2049;
      *(_WORD *)&v335[20] = 2049;
      *(_WORD *)&v337[6] = 2049;
      *(_WORD *)&v344[4] = 2049;
      v346 = v248;
      *(_DWORD *)((char *)&v347 + 2) = v251;
      WORD3(v347) = 2048;
      v345 = 1024;
      LOWORD(v347) = 1024;
      LOWORD(v3sub_10000AE14(v17 - 48) = 1024;
      WORD3(v3sub_10000AE14(v17 - 48) = 1024;
      DWORD2(v3sub_10000AE14(v17 - 48) = v196;
      __int128 v197 = *(double *)(a5 + 56);
      __int16 v198 = a6 - v197;
      int v133 = v197 <= 0.0;
      __int128 v199 = -1.0;
      if (!v133) {
        __int128 v199 = v198;
      }
      *(_DWORD *)v328 = 136388867;
      v332 = v17;
      *(_DWORD *)&v333[22] = v257;
      *(_DWORD *)&v333[28] = v151;
      *(double *)&v335[12] = v180;
      *(double *)&v337[8] = v183;
      *(_DWORD *)&v337[18] = v252;
      *(double *)&v344[6] = v199;
      LODWORD(v231) = 280;
      _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  logc,  0LL,  "Fence: fenceUpdate, %{private}s, bundle, %{private}s, type, %{private}-16s, loc, %{private}12.7lf, %{private}12. 7lf, acc, %{public}4.0lf, distance, %{private}9.0lf, tech, %{private}4s%{private}s, trans, %{private}d, state, % {private}d, cont, %{private}d, fence, %{private}12.8lf, %{private}12.8lf, %{private}.1lf, %{private}.1lf, sCount , %{private}d, %{private}d, trig, %{private}d, %{private}d, sinceLastLoc, %{private}.1lf, events, 0x%{private}08 x, status, %{private}-10s => %{private}-10s, settled state, %{private}s ==> %{private}s, cantShiftButNeedTo, %{p rivate}d, sinceLastTransition, %{private}.1lf, significant, %d, loi, %d, lastProximityStateTimestamp, %f, lastPr oximityState, %d, lastApproachingState, %d",  v328,  v231);
      __int128 v201 = v200;
      if (SHIBYTE(v357.conservativeMountedState) < 0) {
        operator delete(*(void **)&v357.type);
      }
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLFenceMonitor::handleLocationMonitoredFence(const CFAbsoluteTime, const CLDaemonLocation &, const CLDaemon LocationPrivate &, const CLFenceManager_Type::Fence &, CLFenceMonitorLogic::FenceMonitoringStatus &, const BOOL, const BOOL)",  "%s\n",  v201);
      if (v201 != buf) {
        free(v201);
      }
      std::string v152 = v255;
      std::string v153 = v256;
      std::string v154 = v254;
    }

    std::string v155 = v272;
    if (v272 != -1)
    {
      *(_DWORD *)a5 = v272;
      if (v152 == 1 && !v155)
      {
        std::string v154 = 1;
LABEL_258:
        *(_DWORD *)(a5 + 6++*(void *)(result + 8) = v154;
        goto LABEL_259;
      }

      if (!v155 && v153 != 2 && v154 == 2) {
        goto LABEL_258;
      }
    }

  int v85 = *(void *)(a1 + 176);
  if (!v85) {
    int v85 = *(void *)(qword_1019A1D38 + 176);
  }
  uint64_t v86 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100BC3BF4(v85, a2);
  __int128 v87 = (int)v86;
  else {
    uint64_t v88 = 1;
  }
  v4 += v87 + v88 + 2;
  CFStringRef v3 = *(_DWORD *)(a1 + 396);
  if ((v3 & 0x800000) != 0)
  {
LABEL_168:
    __int128 v89 = *(void *)(a1 + 184);
    if (!v89) {
      __int128 v89 = *(void *)(qword_1019A1D38 + 184);
    }
    else {
      uint64_t v90 = 0;
    }
    *(_DWORD *)(v89 + 12) = v90;
    v4 += v90 + 3;
    CFStringRef v3 = *(_DWORD *)(a1 + 396);
  }

  unint64_t v76 = sub_100E72F04((uint64_t)v6, a2);
  uint64_t v77 = (void **)v76;
  double v10 = v8 != (void **)v76;
  if (v8 != (void **)v76)
  {
    int v78 = *(void *)(v76 + 25);
    *(void *)((char *)a3 + 6) = *(void *)(v76 + 31);
    *a3 = v78;
  }

  if (v130) {
    sub_100596A58(a1, (uint64_t)v126);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  uint64_t v79 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BA54((unsigned int *)a2, (std::stringbuf::string_type *)v132);
    uint64_t v80 = v133[9];
    uint64_t v81 = *(_BYTE **)v132;
    sub_100C0BA54((unsigned int *)a3, &v135);
    uint64_t v82 = v132;
    if (v80 < 0) {
      uint64_t v82 = v81;
    }
    if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v83 = &v135;
    }
    else {
      std::string::size_type v83 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string __p = 67109890;
    *(_DWORD *)&__p[4] = v8 != v77;
    *(_WORD *)&__p[8] = 1024;
    *(_DWORD *)&_BYTE __p[10] = v108;
    *(_WORD *)uint64_t v144 = 2080;
    *(void *)&v144[2] = v82;
    *(_WORD *)&_BYTE v144[10] = 2080;
    *(void *)&v144[12] = v83;
    _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_DEBUG,  "TILE: isFound, %d, searchedArea, %u, key, %s, entry, %s",  __p,  0x22u);
    if ((v133[9] & 0x80000000) != 0) {
      operator delete(*(void **)v132);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    std::string::size_type v91 = v8 != v77;
    uint64_t v92 = qword_101934A78;
    sub_100C0BA54((unsigned int *)a2, &v135);
    __int128 v93 = (char)v135.__r_.__value_.__s.__size_;
    __int128 v94 = v135.__r_.__value_.__r.__words[0];
    sub_100C0BA54((unsigned int *)a3, &v114);
    __int128 v95 = &v135;
    if (v93 < 0) {
      __int128 v95 = (std::stringbuf::string_type *)v94;
    }
    if ((v114.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v96 = &v114;
    }
    else {
      __int128 v96 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t v132 = 67109890;
    *(_DWORD *)&v132[4] = v91;
    *(_WORD *)&v132[8] = 1024;
    *(_DWORD *)&v132[10] = v108;
    *(_WORD *)int v133 = 2080;
    *(void *)&v133[2] = v95;
    *(_WORD *)&v133[10] = 2080;
    *(void *)&v133[12] = v96;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v92,  2LL,  "TILE: isFound, %d, searchedArea, %u, key, %s, entry, %s",  v132,  34,  v106,  v107);
    __int128 v98 = v97;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_GSM, CLTilesManager_Type::KeyLatLonE ntry_GSM>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLo nIndexEntry_GSM, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_GSM]",  "%s\n",  v98);
    if (v98 != __p) {
      free(v98);
    }
  }

  unint64_t v76 = sub_100E72F04((uint64_t)v6, a2);
  uint64_t v77 = (void **)v76;
  double v10 = v8 != (void **)v76;
  if (v8 != (void **)v76)
  {
    int v78 = *(void *)(v76 + 25);
    *(void *)((char *)a3 + 6) = *(void *)(v76 + 31);
    *a3 = v78;
  }

  if (v130) {
    sub_100596A58(a1, (uint64_t)v126);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  uint64_t v79 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BF10((unsigned int *)a2, (std::stringbuf::string_type *)v132);
    uint64_t v80 = v133[9];
    uint64_t v81 = *(_BYTE **)v132;
    sub_100C0BF10((unsigned int *)a3, &v135);
    uint64_t v82 = v132;
    if (v80 < 0) {
      uint64_t v82 = v81;
    }
    if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v83 = &v135;
    }
    else {
      std::string::size_type v83 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string __p = 67109890;
    *(_DWORD *)&__p[4] = v8 != v77;
    *(_WORD *)&__p[8] = 1024;
    *(_DWORD *)&_BYTE __p[10] = v108;
    *(_WORD *)uint64_t v144 = 2080;
    *(void *)&v144[2] = v82;
    *(_WORD *)&_BYTE v144[10] = 2080;
    *(void *)&v144[12] = v83;
    _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_DEBUG,  "TILE: isFound, %d, searchedArea, %u, key, %s, entry, %s",  __p,  0x22u);
    if ((v133[9] & 0x80000000) != 0) {
      operator delete(*(void **)v132);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    std::string::size_type v91 = v8 != v77;
    uint64_t v92 = qword_101934A78;
    sub_100C0BF10((unsigned int *)a2, &v135);
    __int128 v93 = (char)v135.__r_.__value_.__s.__size_;
    __int128 v94 = v135.__r_.__value_.__r.__words[0];
    sub_100C0BF10((unsigned int *)a3, &v114);
    __int128 v95 = &v135;
    if (v93 < 0) {
      __int128 v95 = (std::stringbuf::string_type *)v94;
    }
    if ((v114.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v96 = &v114;
    }
    else {
      __int128 v96 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t v132 = 67109890;
    *(_DWORD *)&v132[4] = v91;
    *(_WORD *)&v132[8] = 1024;
    *(_DWORD *)&v132[10] = v108;
    *(_WORD *)int v133 = 2080;
    *(void *)&v133[2] = v95;
    *(_WORD *)&v133[10] = 2080;
    *(void *)&v133[12] = v96;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v92,  2LL,  "TILE: isFound, %d, searchedArea, %u, key, %s, entry, %s",  v132,  34,  v106,  v107);
    __int128 v98 = v97;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CDMA, CLTilesManager_Type::KeyLatLon Entry_CDMA>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLat LonIndexEntry_CDMA, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CDMA]",  "%s\n",  v98);
    if (v98 != __p) {
      free(v98);
    }
  }

  unint64_t v76 = sub_100E72F04((uint64_t)v6, a2);
  uint64_t v77 = (void **)v76;
  double v10 = v8 != (void **)v76;
  if (v8 != (void **)v76)
  {
    int v78 = *(void *)(v76 + 25);
    *(void *)((char *)a3 + 6) = *(void *)(v76 + 31);
    *a3 = v78;
  }

  if (v130) {
    sub_100596A58(a1, (uint64_t)v126);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101888E80);
  }
  uint64_t v79 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0BCC8((unsigned int *)a2, (std::stringbuf::string_type *)v132);
    uint64_t v80 = v133[9];
    uint64_t v81 = *(_BYTE **)v132;
    sub_100C0BCC8((unsigned int *)a3, &v135);
    uint64_t v82 = v132;
    if (v80 < 0) {
      uint64_t v82 = v81;
    }
    if ((v135.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v83 = &v135;
    }
    else {
      std::string::size_type v83 = (std::stringbuf::string_type *)v135.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string __p = 67109890;
    *(_DWORD *)&__p[4] = v8 != v77;
    *(_WORD *)&__p[8] = 1024;
    *(_DWORD *)&_BYTE __p[10] = v108;
    *(_WORD *)uint64_t v144 = 2080;
    *(void *)&v144[2] = v82;
    *(_WORD *)&_BYTE v144[10] = 2080;
    *(void *)&v144[12] = v83;
    _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_DEBUG,  "TILE: isFound, %d, searchedArea, %u, key, %s, entry, %s",  __p,  0x22u);
    if ((v133[9] & 0x80000000) != 0) {
      operator delete(*(void **)v132);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101888E80);
    }
    std::string::size_type v91 = v8 != v77;
    uint64_t v92 = qword_101934A78;
    sub_100C0BCC8((unsigned int *)a2, &v135);
    __int128 v93 = (char)v135.__r_.__value_.__s.__size_;
    __int128 v94 = v135.__r_.__value_.__r.__words[0];
    sub_100C0BCC8((unsigned int *)a3, &v114);
    __int128 v95 = &v135;
    if (v93 < 0) {
      __int128 v95 = (std::stringbuf::string_type *)v94;
    }
    if ((v114.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v96 = &v114;
    }
    else {
      __int128 v96 = (std::stringbuf::string_type *)v114.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t v132 = 67109890;
    *(_DWORD *)&v132[4] = v91;
    *(_WORD *)&v132[8] = 1024;
    *(_DWORD *)&v132[10] = v108;
    *(_WORD *)int v133 = 2080;
    *(void *)&v133[2] = v95;
    *(_WORD *)&v133[10] = 2080;
    *(void *)&v133[12] = v96;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v92,  2LL,  "TILE: isFound, %d, searchedArea, %u, key, %s, entry, %s",  v132,  34,  v106,  v107);
    __int128 v98 = v97;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_LTE, CLTilesManager_Type::KeyLatLonE ntry_LTE>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_Type::KeyLatLo nIndexEntry_LTE, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_LTE]",  "%s\n",  v98);
    if (v98 != __p) {
      free(v98);
    }
  }

  __int128 v75 = sub_10101B080((uint64_t)v6, a2);
  unint64_t v76 = (void **)v75;
  uint64_t v9 = v8 != (void **)v75;
  if (v8 != (void **)v75) {
    *(_OWORD *)a3 = *(_OWORD *)(v75 + 25);
  }
  if (v128) {
    sub_100596A58(a1, (uint64_t)v124);
  }
  if (qword_101934A70 != -1) {
    dispatch_once(&qword_101934A70, &stru_101894A30);
  }
  uint64_t v77 = (os_log_s *)qword_101934A78;
  if (os_log_type_enabled((os_log_t)qword_101934A78, OS_LOG_TYPE_DEBUG))
  {
    sub_100C0B75C(a2, (std::stringbuf::string_type *)v130);
    int v78 = v131[9];
    uint64_t v79 = *(_BYTE **)v130;
    sub_100C0B75C(a3, &v133);
    uint64_t v80 = v130;
    if (v78 < 0) {
      uint64_t v80 = v79;
    }
    if ((v133.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v81 = &v133;
    }
    else {
      uint64_t v81 = (std::stringbuf::string_type *)v133.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)std::string __p = 67109890;
    *(_DWORD *)&__p[4] = v8 != v76;
    *(_WORD *)&__p[8] = 1024;
    *(_DWORD *)&_BYTE __p[10] = v106;
    *(_WORD *)char v142 = 2080;
    *(void *)&v142[2] = v80;
    *(_WORD *)&v142[10] = 2080;
    *(void *)&v142[12] = v81;
    _os_log_impl( (void *)&_mh_execute_header,  v77,  OS_LOG_TYPE_DEBUG,  "TILE: isFound, %d, searchedArea, %u, key, %s, entry, %s",  __p,  0x22u);
    if ((v131[9] & 0x80000000) != 0) {
      operator delete(*(void **)v130);
    }
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(__p, 0x65CuLL);
    if (qword_101934A70 != -1) {
      dispatch_once(&qword_101934A70, &stru_101894A30);
    }
    __int128 v89 = v8 != v76;
    uint64_t v90 = qword_101934A78;
    sub_100C0B75C(a2, &v133);
    std::string::size_type v91 = (char)v133.__r_.__value_.__s.__size_;
    uint64_t v92 = v133.__r_.__value_.__r.__words[0];
    sub_100C0B75C(a3, &v112);
    __int128 v93 = &v133;
    if (v91 < 0) {
      __int128 v93 = (std::stringbuf::string_type *)v92;
    }
    if ((v112.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      __int128 v94 = &v112;
    }
    else {
      __int128 v94 = (std::stringbuf::string_type *)v112.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 v130 = 67109890;
    *(_DWORD *)&v130[4] = v89;
    *(_WORD *)&v130[8] = 1024;
    *(_DWORD *)&v130[10] = v106;
    *(_WORD *)uint64_t v131 = 2080;
    *(void *)&v131[2] = v93;
    *(_WORD *)&v131[10] = 2080;
    *(void *)&v131[12] = v94;
    _os_log_send_and_compose_impl( 2LL,  0LL,  __p,  1628LL,  &_mh_execute_header,  v90,  2LL,  "TILE: isFound, %d, searchedArea, %u, key, %s, entry, %s",  v130,  34,  v104,  v105);
    __int128 v96 = v95;
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual BOOL CLKeyLatLonTileTemplate<CLTilesManager_Type::KeyLatLonIndexEntry_CoarseCell, CLTilesManager_Type::Key LatLonEntry_CoarseCell>::getLocationByKey_mmap(const DataEntry_T &, DataEntry_T &) [IndexEntry_T = CLTilesManager_ Type::KeyLatLonIndexEntry_CoarseCell, DataEntry_T = CLTilesManager_Type::KeyLatLonEntry_CoarseCell]",  "%s\n",  v96);
    if (v96 != __p) {
      free(v96);
    }
  }

          uint64_t v4 = *((void *)this + 1);
          double v5 = *((void *)this + 2);
          double v6 = *((unsigned __int8 *)this + 24);
          if (v4 >= v5 || *((_BYTE *)this + 24)) {
            return v6 == 0;
          }
          break;
        case 5u:
          *(_BYTE *)(a1 + 92) |= 2u;
          __int128 v71 = *((void *)this + 1);
          if (v71 > 0xFFFFFFFFFFFFFFFBLL || v71 + 4 > *((void *)this + 2)) {
            goto LABEL_158;
          }
          *(_DWORD *)(a1 + 8++*(void *)(result + 8) = *(_DWORD *)(*(void *)this + v71);
          goto LABEL_160;
        default:
          if ((PB::Reader::skip(this, v17 >> 3, v17 & 7, 0) & 1) == 0) {
            return 0LL;
          }
          goto LABEL_162;
      }
    }

    unint64_t v21 = 0;
    double v22 = 0;
    CFStringRef v17 = 0LL;
    if (v4 > v5) {
      double v5 = v4;
    }
    while (v5 != v4)
    {
      uint64_t v23 = v4 + 1;
      uint64_t v24 = *(_BYTE *)(v14 + v4);
      *((void *)this + 1) = v23;
      v17 |= (unint64_t)(v24 & 0x7F) << v21;
      if ((v24 & 0x80) == 0) {
        goto LABEL_21;
      }
      v21 += 7;
      uint64_t v4 = v23;
      if (v22++ >= 9)
      {
LABEL_20:
        CFStringRef v17 = 0LL;
        goto LABEL_21;
      }
    }

    double v6 = 1;
    *((_BYTE *)this + 24) = 1;
  }

  return v6 == 0;
}

  uint64_t result = *(float *)(a2 + 236);
  v5 |= 0x100000000000000uLL;
  *BOOL v2 = v5;
  *(_WORD *)(a1 + 324) = v6;
  *(_BYTE *)(a1 + 326) = BYTE2(v6);
  *(float *)(a1 + 236) = result;
  LOWORD(v++*(void *)(result + 8) = *(_WORD *)(a2 + 324);
  uint64_t v4 = *v3;
  if ((*v3 & 0x80000000000000LL) == 0)
  {
LABEL_82:
    if ((v4 & 0x40000000000000LL) == 0) {
      goto LABEL_83;
    }
    goto LABEL_164;
  }

  PB::TextFormatter::format(this, "shortAudioMet", *(_BYTE *)(a1 + 313));
  LOWORD(v7) = *(_WORD *)(a1 + 324);
  double v6 = *v5;
  if ((v7 & 8) == 0)
  {
LABEL_81:
    if ((v7 & 0x10) == 0) {
      goto LABEL_82;
    }
    goto LABEL_164;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 236), 0x110u);
  LOWORD(v7) = *((_WORD *)v4 + 4);
  double v5 = *v4;
  if ((*v4 & 0x80000000000000LL) == 0)
  {
LABEL_82:
    if ((v5 & 0x40000000000000LL) == 0) {
      goto LABEL_83;
    }
    goto LABEL_164;
  }

  uint64_t v51 = *(_BYTE *)(a2 + 352);
  v6 |= 0x20000000000uLL;
  *BOOL v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(_BYTE *)(a1 + 352) = v51;
  uint64_t v4 = *v3;
  double v7 = *(void *)(a2 + 364);
  if ((v7 & 0x100000000LL) == 0)
  {
LABEL_57:
    if ((v7 & 0x80000000) == 0) {
      goto LABEL_58;
    }
    goto LABEL_164;
  }

  PB::TextFormatter::format(this, "numDeescalationTwoLevel", *(_DWORD *)(a1 + 176));
  double v7 = *v5;
  double v6 = *(void *)(a1 + 364);
  if ((*v5 & 0x800000000LL) == 0)
  {
LABEL_61:
    if ((v7 & 0x1000000000LL) == 0) {
      goto LABEL_62;
    }
    goto LABEL_164;
  }

  uint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 352), 0x140u);
  double v5 = *v4;
  double v6 = v4[1];
  if ((v6 & 0x100000000LL) == 0)
  {
LABEL_57:
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_58;
    }
    goto LABEL_164;
  }

  __int128 v98 = *(_BYTE *)(a2 + 192);
  float v99 = v4 >> 16;
  LODWORD(v4) = v4 | 0x20;
  *(void *)(result + 204) = v3;
  *(_BYTE *)(result + 214) = v99;
  *(_WORD *)(result + 212) = v4;
  *(_BYTE *)(result + 192) = v98;
  BOOL v2 = *(void *)(a2 + 204);
  if ((v2 & 0x20000000000000LL) == 0)
  {
LABEL_84:
    if ((v2 & 0x200000000000000LL) == 0) {
      return result;
    }
LABEL_164:
    uint64_t v101 = *(_BYTE *)(a2 + 180);
    *(void *)(result + 204) = v3 | 0x200000000000000LL;
    *(_WORD *)(result + 212) = v4;
    *(_BYTE *)(result + 214) = BYTE2(v4);
    *(_BYTE *)(result + 180) = v101;
    return result;
  }

  PB::TextFormatter::format(this, "timestamp", *(void *)(a1 + 8));
  double v5 = *(void *)(a1 + 204);
  if ((v5 & 2) == 0)
  {
LABEL_83:
    if ((v5 & 4) == 0) {
      goto LABEL_84;
    }
LABEL_164:
    PB::TextFormatter::format(this, "timestamp1", *(void *)(a1 + 24));
    if ((*(void *)(a1 + 204) & 8) == 0) {
      return PB::TextFormatter::endObject(this);
    }
    goto LABEL_85;
  }

  uint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 179), 0x4C4u);
  LOWORD(v5) = *(_WORD *)(v3 + 212);
  if ((*(void *)(v3 + 204) & 0x1000000000000000LL) == 0)
  {
LABEL_84:
    if ((v5 & 0x10) == 0) {
      return result;
    }
    return PB::Writer::write(this, *(_BYTE *)(v3 + 191), 0x4C6u);
  }

void sub_100107414( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char *__p, uint64_t a42, int a43, __int16 a44, char a45, char a46)
{
  std::string __p = a12;
  sub_10004AB74((void ***)&__p);
  sub_100019CEC((uint64_t)&a21);
  std::string __p = &a26;
  sub_10010E26C((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_1001074D8(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  if (*(_BYTE *)(a1 + 160))
  {
    double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
    if (!*(_BYTE *)(a1 + 160)) {
      sub_100036CD8();
    }
    double v5 = Current_1;
    double v6 = Current_1 - *(double *)(a1 + 152);
    sub_100107F6C();
    if (v6 < v7)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      uint64_t v14 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v61 = 2050;
        double v62 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:UWB Scan duration, duration:%{public}.5f}",  buf,  0x1Cu);
      }

      if (!*(_BYTE *)(a1 + 160)) {
        sub_100036CD8();
      }
      sub_1002F0B04(buf);
      CFStringRef v15 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsUwbRangeMaximalAgeForValidityFromScanStart",  0x8000100u,  kCFAllocatorNull);
      int v16 = sub_1002A832C(*(uint64_t *)buf, (uint64_t)v15, v53);
      CFRelease(v15);
      double v17 = *(double *)v53;
      double v18 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        char v19 = (unint64_t *)(*(void *)&buf[8] + 8LL);
        do
          unint64_t v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }

      double v21 = 1.0;
      if (v16) {
        double v21 = v17;
      }
      double v11 = *(double *)(a1 + 152) - v21;
    }

    else
    {
      double v8 = v7;
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      uint64_t v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v61 = 2050;
        double v62 = v6;
        __int16 v63 = 2050;
        CFAbsoluteTime v64 = v8;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Scan duration is exceeded threshold, duration:%{public}.5f, threshold:%{public}.5f}",  buf,  0x26u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F618);
        }
      }

      double v10 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        *(_DWORD *)__int128 buf = 68289538;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        __int16 v61 = 2050;
        double v62 = v6;
        __int16 v63 = 2050;
        CFAbsoluteTime v64 = v8;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Scan duration is exceeded threshold",  "{msg%{public}.0s:Scan duration is exceeded threshold, duration:%{public}.5f, threshold:%{public}.5f}",  buf,  0x26u);
      }

      double v11 = v5 - v8;
    }

    double v52 = v11;
    sub_100108044(a1 + 712, &v52, &v51, &v49);
    if (v51)
    {
      sub_1010DDBC0(buf, "UWB range buffer overflow");
      sub_100133C10((uint64_t *)buf);
      if (SBYTE3(v62) < 0) {
        operator delete(*(void **)buf);
      }
    }

    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    double v22 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 134349056;
      *(void *)&uint8_t buf[4] = 0xCCCCCCCCCCCCCCCDLL * ((v50 - v49) >> 4);
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEBUG,  "uwb cached scan, read %{public}lu measurements",  buf,  0xCu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      *(_DWORD *)std::string v53 = 134349056;
      *(void *)&v53[4] = 0xCCCCCCCCCCCCCCCDLL * ((v50 - v49) >> 4);
      uint64_t v43 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "uwb cached scan, read %{public}lu measurements",  v53,  12);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<CLMiLoProtobufWrapper::Measurement> CLMicroLocationSensorsLogic::getUwbMeasurements()",  "%s\n",  v43);
      if (v43 != buf) {
        free(v43);
      }
    }

    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    BOOL v23 = os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG);
    uint64_t v25 = v49;
    uint64_t v24 = v50;
    if (v23)
    {
      if (v50 == v49)
      {
        *a2 = 0LL;
        a2[1] = 0LL;
        a2[2] = 0LL;
LABEL_82:
        *(void *)__int128 buf = &v49;
        sub_10010E26C((void ***)buf);
        return;
      }

      uint64_t v26 = 0LL;
      unint64_t v27 = 0LL;
      do
      {
        uint64_t v28 = *(void *)(v25 + v26 + 56);
        if (!v28) {
          uint64_t v28 = *(void *)(qword_1019A0818 + 56);
        }
        sub_1001014F0(*(uint64_t ***)(v28 + 32), v58);
        if (qword_1019348E0 != -1) {
          dispatch_once(&qword_1019348E0, &stru_10181F638);
        }
        unint64_t v29 = (os_log_s *)qword_1019348E8;
        if (os_log_type_enabled((os_log_t)qword_1019348E8, OS_LOG_TYPE_DEBUG))
        {
          int v30 = v59;
          if (v59)
          {
            unint64_t v31 = operator new(0x28uLL);
            std::string __p = v31;
            __int128 v48 = xmmword_1012C8460;
            _OWORD *v31 = 0u;
            v31[1] = 0u;
            *(void *)((char *)v31 + 29) = 0LL;
            sub_10000AE6C((uint64_t)v58, v31);
            if (v48 >= 0) {
              p_p = (const char *)&__p;
            }
            else {
              p_p = (const char *)__p;
            }
          }

          else
          {
            p_p = "not available";
          }

          uint64_t v33 = *(void *)(v49 + v26 + 56);
          if (!v33) {
            uint64_t v33 = *(void *)(qword_1019A0818 + 56);
          }
          float v34 = *(float *)(v33 + 20);
          CFAbsoluteTime v35 = CFAbsoluteTimeGetCurrent() - *(double *)(v49 + v26 + 8);
          *(_DWORD *)__int128 buf = 67240963;
          *(_DWORD *)&uint8_t buf[4] = v27;
          *(_WORD *)&uint8_t buf[8] = 2081;
          *(void *)&buf[10] = p_p;
          __int16 v61 = 2049;
          double v62 = v34;
          __int16 v63 = 2050;
          CFAbsoluteTime v64 = v35;
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEBUG,  "meas index: %{public}d, deviceId: %{private}s, range: %{private}f, age: %{public}f",  buf,  0x26u);
          if (v30 && SHIBYTE(v48) < 0) {
            operator delete(__p);
          }
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019348E0 != -1) {
            dispatch_once(&qword_1019348E0, &stru_10181F638);
          }
          uint64_t v36 = qword_1019348E8;
          int v37 = v59;
          if (v59)
          {
            sub_10009FEA0((uint64_t)v58, (uint64_t)v45);
            if (v46 >= 0) {
              std::string v38 = v45;
            }
            else {
              std::string v38 = (void **)v45[0];
            }
          }

          else
          {
            std::string v38 = (void **)"not available";
          }

          uint64_t v39 = *(void *)(v49 + v26 + 56);
          if (!v39) {
            uint64_t v39 = *(void *)(qword_1019A0818 + 56);
          }
          float v40 = *(float *)(v39 + 20);
          CFAbsoluteTime v41 = CFAbsoluteTimeGetCurrent() - *(double *)(v49 + v26 + 8);
          *(_DWORD *)std::string v53 = 67240963;
          *(_DWORD *)&v53[4] = v27;
          *(_WORD *)&v53[8] = 2081;
          *(void *)&v53[10] = v38;
          __int16 v54 = 2049;
          double v55 = v40;
          __int16 v56 = 2050;
          CFAbsoluteTime v57 = v41;
          LODWORD(v44) = 38;
          uint64_t v42 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  v36,  2LL,  "meas index: %{public}d, deviceId: %{private}s, range: %{private}f, age: %{public}f",  v53,  v44);
          if (v37 && v46 < 0) {
            operator delete(v45[0]);
          }
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "std::vector<CLMiLoProtobufWrapper::Measurement> CLMicroLocationSensorsLogic::getUwbMeasurements()",  "%s\n",  v42);
          if (v42 != buf) {
            free(v42);
          }
        }

        ++v27;
        uint64_t v25 = v49;
        uint64_t v24 = v50;
        v26 += 80LL;
      }

      while (0xCCCCCCCCCCCCCCCDLL * ((v50 - v49) >> 4) > v27);
    }

    *a2 = 0LL;
    a2[1] = 0LL;
    a2[2] = 0LL;
    v58[0] = a2;
    while (v25 != v24)
    {
      sub_100068220(buf, v25);
      int v65 = 0;
      sub_10010E47C(v58, (uint64_t)buf);
      sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)buf);
      v25 += 80LL;
    }

    goto LABEL_82;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  unint64_t v12 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CLMicroLocationSensorsLogic::getUwbMeasurements, fState.fStartTime is nullopt!}",  buf,  0x12u);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
  }

  double v13 = (os_log_s *)qword_1019348D8;
  if (os_signpost_enabled((os_log_t)qword_1019348D8))
  {
    *(_DWORD *)__int128 buf = 68289026;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CLMicroLocationSensorsLogic::getUwbMeasurements, fState.fStartTime is nullopt!",  "{msg%{public}.0s:CLMicroLocationSensorsLogic::getUwbMeasurements, fState.fStartTime is nullopt!}",  buf,  0x12u);
  }

  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
}

void sub_100107EA4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, char a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char *a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, int a45, __int16 a46, char a47, char a48)
{
  a35 = &a30;
  sub_10010E26C((void ***)&a35);
  _Unwind_Resume(a1);
}

void sub_100107F6C()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsScanDurationThreshold", 0x8000100u, kCFAllocatorNull);
  sub_1002A832C(v5, (uint64_t)v0, &v4);
  CFRelease(v0);
  int v1 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      unint64_t v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }

void sub_10010802C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void *sub_100108044@<X0>(uint64_t a1@<X0>, double *a2@<X1>, _BYTE *a3@<X2>, void *a4@<X8>)
{
  *a3 = 0;
  double v7 = *(double **)(a1 + 8);
  double v11 = v10;
  v10[1] = 0;
  double v8 = sub_10010DF64(v7, (double *)(a1 + 16), a2);
  return sub_10010E048(a4, v8, (void *)(a1 + 16));
}

void sub_1001080D0(uint64_t a1, double a2)
{
  *(_BYTE *)(a1 + 145) = 2;
  if (*(_BYTE *)(a1 + 272) && *(_BYTE *)(a1 + 273))
  {
    unint64_t v4 = sub_100114150((uint64_t *)(a1 + 608));
    sub_1002F0B04(buf);
    CFStringRef v5 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMinimumWiFiNumberOfMeasurementsForScanExtension",  0x8000100u,  kCFAllocatorNull);
    int v6 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v5, &v14);
    CFRelease(v5);
    unint64_t v7 = v14;
    double v8 = *(std::__shared_weak_count **)v16;
    if (*(void *)v16)
    {
      uint64_t v9 = (unint64_t *)(*(void *)v16 + 8LL);
      do
        unint64_t v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }

    unint64_t v11 = 2LL;
    if (v6) {
      unint64_t v11 = v7;
    }
    if (v4 >= v11)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      unint64_t v12 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
      {
        uint64_t v13 = sub_100114150((uint64_t *)(a1 + 608));
        *(_DWORD *)__int128 buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)int v16 = 2082;
        *(void *)&_DWORD v16[2] = "";
        __int16 v17 = 2050;
        uint64_t v18 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:Received valid scan results, clearing WiFi scan error state, number of APs in scan buffer:%{public}llu}",  buf,  0x1Cu);
      }

      *(_BYTE *)(a1 + 272) = 0;
    }
  }

  sub_1001274FC(*(unsigned __int8 **)(a1 + 304), (os_log_s *)(a1 + 8), a2);
  *(_WORD *)(a1 + 272) = 0;
}

void sub_1001082B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1001082D8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 304);
  unint64_t v4 = sub_100114150((uint64_t *)(a1 + 608));
  return sub_100128670(v3, a2, v4);
}

void sub_10010830C(uint64_t a1)
{
  CFStringRef v2 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsScanBleLeechedBeaconsRSSIEnabled",  0x8000100u,  kCFAllocatorNull);
  char v3 = sub_1002A6FD4(v17, (uint64_t)v2, &v16);
  CFRelease(v2);
  BOOL v4 = v16;
  CFStringRef v5 = v18;
  if (v18)
  {
    p_shared_owners = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  if (v4) {
    char v8 = 0;
  }
  else {
    char v8 = v3;
  }
  if ((v8 & 1) != 0) {
    sub_1001088B0(a1);
  }
  else {
    sub_1001084FC(a1);
  }
  sub_1002F0B04(&v17);
  CFStringRef v9 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsScanUWBRangeEnabled", 0x8000100u, kCFAllocatorNull);
  char v10 = sub_1002A6FD4(v17, (uint64_t)v9, &v16);
  CFRelease(v9);
  BOOL v11 = v16;
  unint64_t v12 = v18;
  if (v18)
  {
    uint64_t v13 = (unint64_t *)&v18->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }

  if (v11) {
    char v15 = 0;
  }
  else {
    char v15 = v10;
  }
  if ((v15 & 1) != 0) {
    sub_100108E94(a1);
  }
  else {
    sub_100108BBC(a1);
  }
}

void sub_10010848C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_1001084FC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 168))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v1 = qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v1,  OS_LOG_TYPE_DEFAULT,  "BLE spyscan session already running",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      LOWORD(v10[0]) = 0;
      uint64_t v2 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "BLE spyscan session already running",  v10,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::startBleSpyscanSessionIfStopped()",  "%s\n",  (const char *)v2);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v4 = qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)v4, OS_LOG_TYPE_DEFAULT, "Start BLE spyscan session", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      LOWORD(v10[0]) = 0;
      uint64_t v6 = _os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Start BLE spyscan session",  v10,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::startBleSpyscanSessionIfStopped()",  "%s\n",  (const char *)v6);
    }

    sub_1001091B0((uint64_t *)a1);
    char v5 = sub_100105E48(a1);
    memset(v9, 0, sizeof(v9));
    sub_10010DD48( v9,  *(id **)(a1 + 784),  *(id **)(a1 + 792),  (uint64_t)(*(void *)(a1 + 792) - *(void *)(a1 + 784)) >> 3);
    __n128 v7 = 0uLL;
    uint64_t v8 = 0LL;
    sub_1000946C8((uint64_t)buf, 0, 1, v5, (uint64_t)v9, &v7, 0.0);
    v10[0] = (void **)&v7;
    sub_1000129D4(v10);
    v10[0] = (void **)v9;
    sub_10010DBE0(v10);
    sub_100106120(a1, (uint64_t)buf);
    sub_100104474(a1 + 8, 1);
    v10[0] = (void **)&v13;
    sub_1000129D4(v10);
    v10[0] = (void **)&v12;
    sub_10010DBE0(v10);
  }

void sub_100108874( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1001088B0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 168))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v2 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Stopping BLE spyscan session", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      v6[0] = 0;
      uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Stopping BLE spyscan session",  v6,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::stopBleSpyscanSessionIfRunning()",  "%s\n",  v4);
    }

    sub_1000C5C34(a1 + 320);
    *(_WORD *)(a1 + 80++*(void *)(result + 8) = 0;
    sub_10010D4F0(a1 + 656, *(void **)(a1 + 664));
    *(void *)(a1 + 656) = a1 + 664;
    *(void *)(a1 + 672) = 0LL;
    *(void *)(a1 + 664) = 0LL;
    sub_1001095A4(a1);
    sub_10010F4B0(a1 + 816);
    sub_100104474(a1 + 8, 0);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    char v3 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "BLE spyscan session already stopped", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      v6[0] = 0;
      char v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "BLE spyscan session already stopped",  v6,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::stopBleSpyscanSessionIfRunning()",  "%s\n",  v5);
    }
  }

void sub_100108BBC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 169))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v1 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "ranging session already running", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      v6[0] = 0;
      uint64_t v2 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "ranging session already running",  v6,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::startRangingSessionIfStopped()",  "%s\n",  v2);
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "start a ranging session", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      v6[0] = 0;
      char v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "start a ranging session",  v6,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::startRangingSessionIfStopped()",  "%s\n",  v5);
    }

    sub_1000C6250(a1 + 320);
    sub_100104654(a1 + 8, 1);
  }

void sub_100108E94(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 169))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v2 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "stop a ranging session", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      v6[0] = 0;
      uint64_t v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "stop a ranging session",  v6,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::stopRangingSessionIfRunning()",  "%s\n",  v4);
    }

    sub_1000C63F0(a1 + 320);
    sub_10010D4F0(a1 + 720, *(void **)(a1 + 728));
    *(void *)(a1 + 720) = a1 + 728;
    *(void *)(a1 + 736) = 0LL;
    *(void *)(a1 + 72++*(void *)(result + 8) = 0LL;
    sub_100104654(a1 + 8, 0);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    char v3 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "ranging session already stopped", buf, 2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      v6[0] = 0;
      char v5 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "ranging session already stopped",  v6,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationSensorsLogic::stopRangingSessionIfRunning()",  "%s\n",  v5);
    }
  }

void sub_10010918C(uint64_t a1)
{
}

void sub_1001091B0(uint64_t *a1)
{
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  char v3 = +[NSDate date](&OBJC_CLASS___NSDate, "date");
  sub_1002F0B04(buf);
  CFStringRef v4 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsNumberDaysToUseBtIdentities", 0x8000100u, kCFAllocatorNull);
  int v5 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v4, __p);
  CFRelease(v4);
  int v6 = (int)__p[0];
  __n128 v7 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    uint64_t v8 = (unint64_t *)(*(void *)&buf[8] + 8LL);
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  if (v5) {
    int v10 = ~v6;
  }
  else {
    int v10 = -29;
  }
  double v11 = sub_10015AFB0((uint64_t)v3, v10);
  std::to_string(&v30, v11);
  std::to_string(&v29, Current_1 + 86400.0);
  sub_10002CDE8(a1[39], (uint64_t)&v30, (uint64_t)&v29, &v27);
  uint64_t v12 = v27;
  for (uint64_t i = v28; v12 != i; v12 += 72LL)
  {
    unint64_t v14 = (void **)(v12 + 16);
    if (*(char *)(v12 + 39) < 0)
    {
      unint64_t v16 = *(void *)(v12 + 24);
      if (v16)
      {
        sub_1010DD48C(buf, *v14, v16);
        goto LABEL_15;
      }
    }

    else if (*(_BYTE *)(v12 + 39))
    {
      __int128 v15 = *(_OWORD *)v14;
      *(void *)&uint8_t buf[16] = *(void *)(v12 + 32);
      *(_OWORD *)__int128 buf = v15;
LABEL_15:
      char v17 = 1;
      goto LABEL_17;
    }

    char v17 = 0;
    buf[0] = 0;
LABEL_17:
    _BYTE buf[24] = v17;
    uint64_t v18 = (void **)(v12 + 40);
    if (*(char *)(v12 + 63) < 0)
    {
      unint64_t v20 = *(void *)(v12 + 48);
      if (v20)
      {
        sub_1010DD48C(__p, *v18, v20);
        goto LABEL_22;
      }
    }

    else if (*(_BYTE *)(v12 + 63))
    {
      __int128 v19 = *(_OWORD *)v18;
      uint64_t v25 = *(void *)(v12 + 56);
      *(_OWORD *)std::string __p = v19;
LABEL_22:
      char v21 = 1;
      goto LABEL_24;
    }

    char v21 = 0;
    LOBYTE(__p[0]) = 0;
LABEL_24:
    char v26 = v21;
    sub_10010F504(a1 + 102, (_OWORD *)v12, (__int128 *)buf, (__int128 *)__p, (uint64_t)"", (void *)(v12 + 64));
    if (v26 && SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
    if (buf[24] && (buf[23] & 0x80000000) != 0) {
      operator delete(*(void **)buf);
    }
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  double v22 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = a1[105];
    *(_DWORD *)__int128 buf = 68289538;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = "";
    *(_WORD *)&_BYTE buf[18] = 2050;
    *(void *)&buf[20] = 0x8E38E38E38E38E39LL * ((v28 - v27) >> 3);
    __int16 v32 = 2050;
    uint64_t v33 = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:SensorsLogic, loadBleIdentitiesFromDb, num of entries loaded:%{public}lu, Total num ber of identities in memory:%{public}lu}",  buf,  0x26u);
  }

  *(void *)__int128 buf = &v27;
  sub_100046550((void ***)buf);
}

void sub_1001094FC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31, void *a32, uint64_t a33, int a34, __int16 a35, char a36, char a37, char a38)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  if (a31 < 0) {
    operator delete(a26);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001095A4(uint64_t a1)
{
  uint64_t v8 = 0LL;
  unint64_t v9 = 0LL;
  unint64_t v10 = 0LL;
  uint64_t v1 = *(uint64_t **)(a1 + 832);
  if (v1)
  {
    do
    {
      if (*((_BYTE *)v1 + 56))
      {
        if (*((char *)v1 + 55) < 0)
        {
          sub_1010DD48C(buf, (void *)v1[4], v1[5]);
        }

        else
        {
          *(_OWORD *)__int128 buf = *((_OWORD *)v1 + 2);
          *(void *)&uint8_t buf[16] = v1[6];
        }
      }

      else
      {
        memset(buf, 0, 24);
      }

      if (*((_BYTE *)v1 + 88))
      {
        if (*((char *)v1 + 87) < 0)
        {
          sub_1010DD48C(__p, (void *)v1[8], v1[9]);
        }

        else
        {
          *(_OWORD *)std::string __p = *((_OWORD *)v1 + 4);
          uint64_t v7 = v1[10];
        }
      }

      else
      {
        __p[0] = 0LL;
        __p[1] = 0LL;
        uint64_t v7 = 0LL;
      }

      unint64_t v3 = v9;
      if (v9 >= v10)
      {
        uint64_t v4 = sub_10010EF98(&v8, v1 + 2, (uint64_t)buf, (uint64_t)__p, (double *)v1 + 16);
      }

      else
      {
        sub_10010F0E4((uint64_t)&v10, v9, v1 + 2, (uint64_t)buf, (uint64_t)__p, (double *)v1 + 16);
        uint64_t v4 = v3 + 72;
      }

      unint64_t v9 = v4;
      if (SHIBYTE(v7) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v1 = (uint64_t *)*v1;
    }

    while (v1);
    if (v9 != v8)
    {
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      int v5 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = "";
        *(_WORD *)&_BYTE buf[18] = 2050;
        *(void *)&buf[20] = 0x8E38E38E38E38E39LL * ((uint64_t)(v9 - v8) >> 3);
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:SensorsLogic, back up BT identities data to DB, Num Entries:%{public}lu}",  buf,  0x1Cu);
      }

      sub_10010BF04(*(void *)(a1 + 312), &v8);
    }
  }

  *(void *)__int128 buf = &v8;
  sub_100046550((void ***)buf);
}

void sub_1001097E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, char *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23)
{
  std::string __p = &a15;
  sub_100046550((void ***)&__p);
  _Unwind_Resume(a1);
}

void sub_100109844(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "stop a motion state-machine",  (uint8_t *)buf,  2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    LOWORD(v12[0]) = 0;
    LODWORD(v11) = 2;
    unint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "stop a motion state-machine",  v12);
    sub_10029211C("Generic", 1LL, 0, 2LL, "void CLMicroLocationSensorsLogic::stopMotionSM()", "%s\n", v9);
  }

  sub_10010C164(a1 + 592, 5, v3, v4, v5, v6, v7, v8, v10, v11, v12[0], v12[1], buf[0], buf[1], buf[2], (void *)buf[3]);
}

void sub_1001099E0(uint64_t a1, int a2)
{
  if (!a2 || !*(_DWORD *)(a1 + 592))
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v3 = a1 + 592;
    int v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "start motion state-machine geofence",  (uint8_t *)buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      LOWORD(v14[0]) = 0;
      LODWORD(v13) = 2;
      uint64_t v11 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "start motion state-machine geofence",  v14);
      sub_10029211C("Generic", 1LL, 0, 2LL, "void CLMicroLocationSensorsLogic::setFence(BOOL)", "%s\n", v11);
    }

    sub_10010C164(v3, 0, v5, v6, v7, v8, v9, v10, v12, v13, v14[0], v14[1], buf[0], buf[1], buf[2], (void *)buf[3]);
  }

void sub_100109B8C(_BYTE *a1)
{
  if (!a1[170])
  {
    sub_100063B08((uint64_t)v5);
    v6 |= 2u;
    v5[12] = 1;
    int v4 = 0;
    sub_100018E34(&v4);
    *(void *)&__int128 v7 = sub_100017338((ssize_t)&v4);
    *((void *)&v7 + 1) = v2;
    double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
    sub_100109CB8(&v7, (uint64_t)v5, (uint64_t)v8, Current_1);
    (*(void (**)(_BYTE *, _BYTE *))(*(void *)a1 + 144LL))(a1, v8);
    sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v9);
    sub_100019D7C((unsigned int *)&v4);
    sub_1000C6800((uint64_t)(a1 + 320));
    sub_10010483C((uint64_t)(a1 + 8), 1);
    sub_100089100((wireless_diagnostics::google::protobuf::MessageLite *)v5);
  }

void sub_100109C78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, unsigned int a11, char a12)
{
}

void sub_100109CB8(_OWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, double a4@<D0>)
{
}

void sub_100109D2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100109D40(_BYTE *a1)
{
  if (a1[170])
  {
    sub_100063B08((uint64_t)v5);
    v6 |= 2u;
    v5[12] = 0;
    int v4 = 0;
    sub_100018E34(&v4);
    *(void *)&__int128 v7 = sub_100017338((ssize_t)&v4);
    *((void *)&v7 + 1) = v2;
    double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
    sub_100109CB8(&v7, (uint64_t)v5, (uint64_t)v8, Current_1);
    (*(void (**)(_BYTE *, _BYTE *))(*(void *)a1 + 144LL))(a1, v8);
    sub_100081760((wireless_diagnostics::google::protobuf::MessageLite *)&v9);
    sub_100019D7C((unsigned int *)&v4);
    sub_1000C6838((uint64_t)(a1 + 320));
    sub_10010483C((uint64_t)(a1 + 8), 0);
    sub_100089100((wireless_diagnostics::google::protobuf::MessageLite *)v5);
  }

void sub_100109E28( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, unsigned int a11, char a12)
{
}

void sub_100109E68(uint64_t a1, uint64_t *a2)
{
  if (*a2 != a2[1])
  {
    *(_BYTE *)(a1 + 273) = 1;
    sub_1001137E0(a1 + 608, a2, v12);
    sub_100103E48(v12, &v10);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v3 = v10;
      for (uint64_t i = v11; v3 != i; v3 += 88LL)
      {
        uint64_t v5 = *(void *)(v3 + 16);
        if (!v5) {
          uint64_t v5 = *(void *)(qword_1019A0818 + 16);
        }
        uint64_t v14 = nullsub_10(*(void *)(v5 + 24));
        if (qword_1019348E0 != -1) {
          dispatch_once(&qword_1019348E0, &stru_10181F638);
        }
        int v6 = (os_log_s *)qword_1019348E8;
        if (os_log_type_enabled((os_log_t)qword_1019348E8, OS_LOG_TYPE_DEBUG))
        {
          float v7 = *(float *)(v5 + 20);
          sub_1007EC360(&__p);
          p_p = &__p;
          if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          int v9 = *(_DWORD *)(v5 + 32);
          *(_DWORD *)__int128 buf = 68289795;
          *(_DWORD *)&uint8_t buf[4] = 0;
          __int16 v16 = 2082;
          char v17 = "";
          __int16 v18 = 1025;
          int v19 = (int)v7;
          __int16 v20 = 2081;
          char v21 = p_p;
          __int16 v22 = 1025;
          int v23 = v9;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Wifi AP received, rssi:%{private}d, mac:%{private, location:escape_only}s, channel:%{private}d}",  buf,  0x28u);
        }
      }
    }

    sub_100127460(*(uint64_t **)(a1 + 304), &v10);
    *(void *)__int128 buf = &v10;
    sub_10004AB74((void ***)buf);
    *(void *)__int128 buf = v12;
    sub_10010DB70((void ***)buf);
  }

void sub_10010A0A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void **a21)
{
  a21 = (void **)&a11;
  sub_10004AB74(&a21);
  a21 = (void **)&a14;
  sub_10010DB70(&a21);
  _Unwind_Resume(a1);
}

void sub_10010A0E8(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 68289026;
    v3[1] = 0;
    __int16 v4 = 2082;
    uint64_t v5 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:sensorLogic, received wifi scan error}",  (uint8_t *)v3,  0x12u);
  }

  *(_BYTE *)(a1 + 272) = 1;
}

void sub_10010A1C8(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  uint64_t v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 68289026;
    v3[1] = 0;
    __int16 v4 = 2082;
    uint64_t v5 = "";
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:sensorLogic, received wifi scan error busy}",  (uint8_t *)v3,  0x12u);
  }

  *(_BYTE *)(a1 + 272) = 1;
}

void sub_10010A2A8(uint64_t a1, uint64_t a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  __int16 v4 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    sub_10099EA10(a2, &__p);
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)__int128 buf = 68289282;
    int v8 = 0;
    __int16 v9 = 2082;
    uint64_t v10 = "";
    __int16 v11 = 2082;
    uint64_t v12 = p_p;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Logic, onAssociatedStateChange, state:%{public, location:escape_only}s}",  buf,  0x1Cu);
  }

  sub_1000C6A74(a1 + 176, a2);
  sub_10012BBD8(*(void *)(a1 + 304), a2);
}

void sub_10010A3E0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 809) != 1)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    uint64_t v2 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      int v3 = *(unsigned __int8 *)(a1 + 809);
      int v7 = 68289282;
      int v8 = 0;
      __int16 v9 = 2082;
      uint64_t v10 = "";
      __int16 v11 = 1026;
      int v12 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Ble requested scan timeout but the session state is not running, fBleSessionStatusReq uested:%{public}u}",  (uint8_t *)&v7,  0x18u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
    }

    __int16 v4 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      int v5 = *(unsigned __int8 *)(a1 + 809);
      int v7 = 68289282;
      int v8 = 0;
      __int16 v9 = 2082;
      uint64_t v10 = "";
      __int16 v11 = 1026;
      int v12 = v5;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Ble requested scan timeout but the session state is not running",  "{msg%{public}.0s:Ble requested scan timeout but the session state is not running, fBleSessionStatusReq uested:%{public}u}",  (uint8_t *)&v7,  0x18u);
    }
  }

  int v6 = *(unsigned __int8 *)(a1 + 808);
  sub_1000C5C34(a1 + 320);
  *(_WORD *)(a1 + 80++*(void *)(result + 8) = 0;
  if (v6 == 2) {
    sub_1001053A4(a1);
  }
  sub_10010A5A0(a1);
}

void sub_10010A5A0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 160))
  {
    double v2 = *(double *)(a1 + 152);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    int v3 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int16 v18 = 2082;
      *(void *)&void v18[2] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:CLMicroLocationSensorsLogic::requestWiFiScan, fState.fStartTime is nullopt!}",  buf,  0x12u);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
    }

    __int16 v4 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)__int16 v18 = 2082;
      *(void *)&void v18[2] = "";
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "CLMicroLocationSensorsLogic::requestWiFiScan, fState.fStartTime is nullopt!",  "{msg%{public}.0s:CLMicroLocationSensorsLogic::requestWiFiScan, fState.fStartTime is nullopt!}",  buf,  0x12u);
    }

    double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
    double v2 = Current_1;
    if (!*(_BYTE *)(a1 + 160)) {
      *(_BYTE *)(a1 + sub_1000A7938(v1 - 160) = 1;
    }
    *(double *)(a1 + 152) = Current_1;
  }

  sub_1002F0B04(buf);
  CFStringRef v6 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsMaximumAgeForValidity", 0x8000100u, kCFAllocatorNull);
  int v7 = sub_1002A832C(*(uint64_t *)buf, (uint64_t)v6, v15);
  CFRelease(v6);
  double v8 = *(double *)v15;
  __int16 v9 = *(std::__shared_weak_count **)v18;
  if (*(void *)v18)
  {
    uint64_t v10 = (unint64_t *)(*(void *)v18 + 8LL);
    do
      unint64_t v11 = __ldaxr(v10);
    while (__stlxr(v11 - 1, v10));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  if (v7) {
    double v12 = v8;
  }
  else {
    double v12 = 1.0;
  }
  sub_100113CFC(a1 + 608, v16, v2, v12);
  *(void *)__int128 buf = v16;
  sub_10010DB70((void ***)buf);
  memset(v15, 0, sizeof(v15));
  sub_10010EE2C( v15,  *(void *)(a1 + 608),  *(void *)(a1 + 616),  0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(*(void *)(a1 + 616) - *(void *)(a1 + 608)) >> 3));
  sub_100103E48(v15, v14);
  buf[0] = *(_BYTE *)(a1 + 144);
  *(void *)__int16 v18 = 0LL;
  sub_1000C4758(a1 + 320, (uint64_t)buf);
  *(_BYTE *)(a1 + 145) = 1;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  uint64_t v13 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 68289282;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)__int16 v18 = 2082;
    *(void *)&void v18[2] = "";
    __int16 v19 = 2050;
    uint64_t v20 = 0x2E8BA2E8BA2E8BA3LL * ((v14[1] - v14[0]) >> 3);
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:SensorsLogic, WiFi scan starts, Num Valid Buffered WiFi APs:%{public}lu}",  buf,  0x1Cu);
  }

  sub_100127460(*(uint64_t **)(a1 + 304), v14);
  *(void *)__int128 buf = v14;
  sub_10004AB74((void ***)buf);
  *(void *)__int128 buf = v15;
  sub_10010DB70((void ***)buf);
}

void sub_10010A93C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void **a19)
{
  a19 = (void **)&a10;
  sub_10004AB74(&a19);
  a19 = (void **)&a13;
  sub_10010DB70(&a19);
  _Unwind_Resume(a1);
}

void sub_10010A990(uint64_t a1, double *a2, uint64_t a3)
{
  CFStringRef v6 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBleScanMaximalAgeForValidity", 0x8000100u, kCFAllocatorNull);
  int v7 = sub_1002A832C(v14, (uint64_t)v6, &v18);
  CFRelease(v6);
  double v8 = v18;
  __int16 v9 = v15;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      unint64_t v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }

  double v12 = 1.0;
  if (v7) {
    double v12 = v8;
  }
  double v17 = v12;
  sub_10010AB08(a3, (uint64_t)&v14);
  if (v16)
  {
    uint64_t v13 = (std::locale::__imp **)sub_100124750(*(void *)(a1 + 304));
    if (sub_100022DCC(a2, (uint64_t)&v14, &v17, v13))
    {
      if (!v16) {
        sub_100036CD8();
      }
      sub_10010E678(a1 + 656, (uint64_t)&v14);
      sub_10010E61C((uint64_t *)(a1 + 648));
    }

    if (v16) {
      sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)&v14);
    }
  }

void sub_10010AAD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10010AB08(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (!sub_100064120(v4)) {
    __assert_rtn("set_datatype", "microlocation.pb.h", 10437, "::CLMicroLocationProto::DataType_IsValid(value)");
  }
  uint64_t v5 = *(void *)(a1 + 8);
  int v7 = v4;
  v8 |= 3u;
  v6[1] = v5;
  sub_100101998((uint64_t)v6, a1);
  sub_100068220(a2, v6);
  *(_BYTE *)(a2 + 80) = 1;
  sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)v6);
}

void sub_10010ABB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_10010ABC8(uint64_t *a1, uint64_t a2)
{
  if (a1[105] >= (unint64_t)a1[107])
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    __int128 v15 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = a1[105];
      int v19 = 68289283;
      int v20 = 0;
      __int16 v21 = 2082;
      __int16 v22 = "";
      __int16 v23 = 2049;
      uint64_t v24 = (char *)v16;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:fSameAccountBleIdentities exceeded max entries, Size:%{private}lu}",  (uint8_t *)&v19,  0x1Cu);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
    }

    double v17 = (os_log_s *)qword_1019348D8;
    if (os_signpost_enabled((os_log_t)qword_1019348D8))
    {
      uint64_t v18 = a1[105];
      int v19 = 68289283;
      int v20 = 0;
      __int16 v21 = 2082;
      __int16 v22 = "";
      __int16 v23 = 2049;
      uint64_t v24 = (char *)v18;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v17,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "fSameAccountBleIdentities exceeded max entries",  "{msg%{public}.0s:fSameAccountBleIdentities exceeded max entries, Size:%{private}lu}",  (uint8_t *)&v19,  0x1Cu);
    }
  }

  else if (*(_BYTE *)(a2 + 104))
  {
    uint64_t v4 = a2 + 80;
    uint64_t v5 = (std::locale::__imp **)sub_100124750(a1[38]);
    if (sub_1000232EC(a2 + 80, v5))
    {
      sub_10010E818((uint64_t)(a1 + 102), a2, a2);
      if ((v6 & 1) != 0)
      {
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F618);
        }
        int v7 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
        {
          int v8 = (char *)operator new(0x28uLL);
          *(_OWORD *)int v8 = 0u;
          *((_OWORD *)v8 + 1) = 0u;
          *(void *)(v8 + 29) = 0LL;
          sub_10000AE6C(a2, v8);
          if (!*(_BYTE *)(a2 + 104)) {
            sub_100036CD8();
          }
          unint64_t v11 = *(const char **)(a2 + 48);
          uint64_t v10 = a2 + 48;
          __int16 v9 = v11;
          if (!*(_BYTE *)(v10 + 24)) {
            __int16 v9 = "";
          }
          else {
            double v12 = *(const char **)(v10 - 32);
          }
          if (!*(_BYTE *)(v10 - 8)) {
            double v12 = "";
          }
          else {
            uint64_t v13 = *(void *)(v10 + 32);
          }
          uint64_t v14 = *(void *)(v10 + 64);
          int v19 = 68290307;
          int v20 = 0;
          __int16 v21 = 2082;
          __int16 v22 = "";
          __int16 v23 = 2081;
          uint64_t v24 = v8;
          __int16 v25 = 2081;
          char v26 = v12;
          __int16 v27 = 2081;
          uint64_t v28 = v9;
          __int16 v29 = 2081;
          uint64_t v30 = v13;
          __int16 v31 = 2050;
          uint64_t v32 = v14;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:buffered a same icloud account BT identity, BT uuid:%{private, location:escape_ only}s, Device name:%{private, location:escape_only}s, Stable identifier:%{private, location:escape_ only}s, device model:%{private, location:escape_only}s, Time stamp_s:%{public}.09f}",  (uint8_t *)&v19,  0x44u);
          operator delete(v8);
        }
      }
    }
  }

void sub_10010AEE8(_Unwind_Exception *a1)
{
}

void sub_10010AF00(uint64_t a1, uint64_t *a2, double a3)
{
  double v16 = a3;
  sub_10010B1B0(a2, (uint64_t)&v14);
  v21[0] = 1.79769313e308;
  *(void *)__int128 buf = 0LL;
  *(void *)uint64_t v18 = 0LL;
  *(void *)&v18[8] = 0LL;
  sub_10002318C(&v16, &v14, v21, (std::locale::__imp **)buf);
  std::stringbuf::string_type __p = buf;
  sub_1000129D4((void ***)&__p);
  sub_10010EBF8(v14, v15, a1 + 720, a1 + 728, (uint64_t *)buf);
  sub_10010E61C((uint64_t *)(a1 + 712));
  uint64_t v4 = v14;
  for (uint64_t i = v15; v4 != i; v4 += 80LL)
  {
    uint64_t v6 = *(void *)(v4 + 56);
    if (!v6) {
      uint64_t v6 = *(void *)(qword_1019A0818 + 56);
    }
    sub_1001014F0(*(uint64_t ***)(v6 + 32), v21);
    if (v22)
    {
      int v7 = operator new(0x28uLL);
      std::stringbuf::string_type __p = v7;
      __int128 v13 = xmmword_1012C8460;
      *int v7 = 0u;
      v7[1] = 0u;
      *(void *)((char *)v7 + 29) = 0LL;
      sub_10000AE6C((uint64_t)v21, v7);
    }

    else
    {
      sub_1010DDBC0(&__p, "");
    }

    if (qword_1019348E0 != -1) {
      dispatch_once(&qword_1019348E0, &stru_10181F638);
    }
    int v8 = (os_log_s *)qword_1019348E8;
    if (os_log_type_enabled((os_log_t)qword_1019348E8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v9 = *(void *)(v4 + 56);
      if (!v9) {
        uint64_t v9 = *(void *)(qword_1019A0818 + 56);
      }
      double v10 = *(float *)(v9 + 20);
      p_p = &__p;
      if (v13 < 0) {
        p_p = __p;
      }
      *(_DWORD *)__int128 buf = 68289539;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)uint64_t v18 = 2082;
      *(void *)&void v18[2] = "";
      *(_WORD *)&_BYTE v18[10] = 2050;
      *(double *)&v18[12] = v10;
      __int16 v19 = 2081;
      int v20 = p_p;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Ingested UWB range measurement, range:%{public}.3f, device ID:%{private, lo cation:escape_only}s}",  buf,  0x26u);
    }

    if (SHIBYTE(v13) < 0) {
      operator delete(__p);
    }
  }

  *(void *)__int128 buf = &v14;
  sub_10010E26C((void ***)buf);
}

void sub_10010B160( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14, uint64_t a15, uint64_t a16, char a17)
{
  a14 = (void **)&a17;
  sub_10010E26C(&a14);
  _Unwind_Resume(a1);
}

void sub_10010B1B0(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v10 = 0uLL;
  unint64_t v11 = 0LL;
  sub_10010D56C((uint64_t *)&v10, (a1[1] - *a1) >> 6);
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  while (v4 != v5)
  {
    sub_10010D61C(v4, (uint64_t)v8);
    if (v9)
    {
      uint64_t v6 = *((void *)&v10 + 1);
      if (*((void *)&v10 + 1) >= v11)
      {
        uint64_t v7 = sub_10010D838((uint64_t *)&v10, (uint64_t)v8);
      }

      else
      {
        sub_100068220(*((void *)&v10 + 1), v8);
        uint64_t v7 = v6 + 80;
      }

      *((void *)&v10 + 1) = v7;
      if (v9) {
        sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)v8);
      }
    }

    v4 += 64LL;
  }

  *(_OWORD *)a2 = v10;
  *(void *)(a2 + 16) = v11;
  unint64_t v11 = 0LL;
  __int128 v10 = 0uLL;
  v8[0] = (void **)&v10;
  sub_10010E26C(v8);
}

void sub_10010B28C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v10 - 64);
  sub_10010E26C(&a10);
  _Unwind_Resume(a1);
}

void sub_10010B2D0( uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
}

void sub_10010B2DC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 592) == 1)
  {
    std::string::assign(&v43, "Restarting Geofence. ");
    sub_10010C164( a1 + 592,  0,  v2,  v3,  v4,  v5,  v6,  v7,  v37,  v38,  (uint64_t)v39.__r_.__value_.__l.__data_,  v39.__r_.__value_.__l.__size_,  v39.__r_.__value_.__l.__cap_,  (uint64_t)v40.__r_.__value_.__l.__data_,  v40.__r_.__value_.__l.__size_,  (void *)v40.__r_.__value_.__l.__cap_);
  }

  else
  {
    std::string::assign(&v43, "Ignoring failure. ");
  }

  sub_1002F0B04(&v47);
  CFStringRef v8 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaxTimeAllowedWithoutFenceStatusReport",  0x8000100u,  kCFAllocatorNull);
  int v9 = sub_1002A832C((uint64_t)v47.__r_.__value_.__l.__data_, (uint64_t)v8, v41);
  CFRelease(v8);
  double v10 = *(double *)v41;
  std::string::size_type size = (std::__shared_weak_count *)v47.__r_.__value_.__l.__size_;
  if (v47.__r_.__value_.__l.__size_)
  {
    double v12 = (unint64_t *)(v47.__r_.__value_.__l.__size_ + 8);
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
      std::__shared_weak_count::__release_weak(size);
    }
  }

  if (!v9) {
    double v10 = 600.0;
  }
  sub_1002F0B04(&v47);
  CFStringRef v14 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaxDelayAfterFenceStatusReportTimerFires",  0x8000100u,  kCFAllocatorNull);
  int v15 = sub_1002A832C((uint64_t)v47.__r_.__value_.__l.__data_, (uint64_t)v14, v41);
  CFRelease(v14);
  double v16 = *(double *)v41;
  double v17 = (std::__shared_weak_count *)v47.__r_.__value_.__l.__size_;
  if (v47.__r_.__value_.__l.__size_)
  {
    uint64_t v18 = (unint64_t *)(v47.__r_.__value_.__l.__size_ + 8);
    do
      unint64_t v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }

  if (!v15) {
    double v16 = 30.0;
  }
  std::to_string(&v40, v10);
  int v20 = std::string::insert(&v40, 0LL, " Running with FenceStatusTimeout: ");
  __int128 v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__l.__cap_ = v20->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = v21;
  v20->__r_.__value_.__l.__size_ = 0LL;
  v20->__r_.__value_.__l.__cap_ = 0LL;
  v20->__r_.__value_.__r.__words[0] = 0LL;
  char v22 = std::string::append(&v48, "and RaceDelayTimeout: ");
  __int128 v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__l.__cap_ = v22->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v23;
  v22->__r_.__value_.__l.__size_ = 0LL;
  v22->__r_.__value_.__l.__cap_ = 0LL;
  v22->__r_.__value_.__r.__words[0] = 0LL;
  std::to_string(&v39, v16);
  if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v24 = &v39;
  }
  else {
    uint64_t v24 = (std::string *)v39.__r_.__value_.__r.__words[0];
  }
  if ((v39.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type v25 = v39.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type v25 = v39.__r_.__value_.__l.__size_;
  }
  char v26 = std::string::append(&v47, (const std::string::value_type *)v24, v25);
  __int128 v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  int64_t cap = v26->__r_.__value_.__l.__cap_;
  *(_OWORD *)CFAbsoluteTime v41 = v27;
  v26->__r_.__value_.__l.__size_ = 0LL;
  v26->__r_.__value_.__l.__cap_ = 0LL;
  v26->__r_.__value_.__r.__words[0] = 0LL;
  sub_10010B8E0((const void **)&__p, (const void **)&v43.__r_.__value_.__l.__data_, (uint64_t)&v47);
  if (cap >= 0) {
    uint64_t v28 = v41;
  }
  else {
    uint64_t v28 = (void **)v41[0];
  }
  if (cap >= 0) {
    std::string::size_type v29 = HIBYTE(cap);
  }
  else {
    std::string::size_type v29 = (std::string::size_type)v41[1];
  }
  uint64_t v30 = std::string::append(&v47, (const std::string::value_type *)v28, v29);
  __int16 v31 = (void *)v30->__r_.__value_.__r.__words[0];
  v48.__r_.__value_.__r.__words[0] = v30->__r_.__value_.__l.__size_;
  *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v30->__r_.__value_.__r.__words[1] + 7);
  unsigned __int8 v32 = v30->__r_.__value_.__s.__size_;
  v30->__r_.__value_.__l.__size_ = 0LL;
  v30->__r_.__value_.__l.__cap_ = 0LL;
  v30->__r_.__value_.__r.__words[0] = 0LL;
  if (v46 < 0) {
    operator delete(__p);
  }
  std::stringbuf::string_type __p = v31;
  *(void *)uint64_t v45 = v48.__r_.__value_.__r.__words[0];
  *(void *)&v45[7] = *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words + 7);
  signed __int8 v46 = v32;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  uint64_t v33 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
  {
    p_p = &__p;
    if (v46 < 0) {
      p_p = __p;
    }
    LODWORD(v47.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v47.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%s", (uint8_t *)&v47, 0xCu);
  }

  if (sub_1002921D0(115, 0))
  {
    bzero(&v47, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    CFAbsoluteTime v35 = &__p;
    if (v46 < 0) {
      CFAbsoluteTime v35 = __p;
    }
    LODWORD(v48.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words + 4) = (std::string::size_type)v35;
    uint64_t v36 = (std::string *)_os_log_send_and_compose_impl( 2LL,  0LL,  &v47,  1628LL,  &_mh_execute_header,  qword_1019348D8,  16LL,  "%s",  (const char *)&v48);
    sub_10029211C( "Generic",  1LL,  0,  0LL,  "virtual void CLMicroLocationSensorsLogic::onFailureToReceiveGeofenceStatusReports()",  "%s\n",  (const char *)v36);
    if (v36 != &v47) {
      free(v36);
    }
  }

  sub_100133C10((uint64_t *)&__p);
  if (SHIBYTE(cap) < 0) {
    operator delete(v41[0]);
  }
  if (v46 < 0) {
    operator delete(__p);
  }
}

void sub_10010B7E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28, uint64_t a29, void *a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, void *a36, uint64_t a37, int a38, __int16 a39, char a40, char a41, void *a42, uint64_t a43, int a44, __int16 a45, char a46, char a47)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a41 < 0) {
    operator delete(a36);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010B8E0@<X0>(const void **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  else {
    size_t v5 = (size_t)a1[1];
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  uint64_t result = sub_1000392EC(a3, v6 + v5);
  else {
    CFStringRef v8 = *(char **)result;
  }
  if (v5)
  {
    else {
      int v9 = *a1;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }

  double v10 = &v8[v5];
  if (v6)
  {
    else {
      unint64_t v11 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v10, v11, v6);
  }

  v10[v6] = 0;
  return result;
}

void sub_10010B9A8( uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
}

uint64_t sub_10010B9B4(uint64_t result, int a2, double a3)
{
  *(double *)(result + 28++*(void *)(result + 8) = a3;
  *(_DWORD *)(result + 280) = a2;
  return result;
}

uint64_t sub_10010B9C0(uint64_t result)
{
  if (*(_BYTE *)(result + 296))
  {
    uint64_t v1 = result;
    uint64_t result = sub_1000C60B0(result + 320);
    *(_BYTE *)(v1 + 296) = 0;
  }

  return result;
}

void sub_10010B9F0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 320;
  std::stringbuf::string_type __p = 0LL;
  int v4 = 0LL;
  uint64_t v5 = 0LL;
  sub_100007590(&__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  sub_1000C5828(v2, &__p);
  if (__p)
  {
    int v4 = __p;
    operator delete(__p);
  }

void sub_10010BA50( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10010BA6C(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 280);
  return j__CFAbsoluteTimeGetCurrent_1() - *(double *)(a1 + 288) < (double)a2 / 1000.0 || v2 != 1;
}

uint64_t sub_10010BABC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_100008BDC();
  }
  uint64_t v4 = a1 + 320;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v3 + 48LL))(&v6, v3, a1 + 320);
  sub_1000C4690(v4, &v6);
  uint64_t result = v6;
  uint64_t v6 = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_10010BB28( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010BB4C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_100008BDC();
  }
  uint64_t v4 = a1 + 320;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v3 + 48LL))(&v6, v3, a1 + 320);
  sub_1000C46B8(v4, &v6);
  uint64_t result = v6;
  uint64_t v6 = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_10010BBB8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010BBDC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_100008BDC();
  }
  uint64_t v4 = a1 + 320;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v3 + 48LL))(&v6, v3, a1 + 320);
  sub_1000C46E0(v4, &v6);
  uint64_t result = v6;
  uint64_t v6 = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_10010BC48( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010BC6C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_100008BDC();
  }
  uint64_t v4 = a1 + 320;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v3 + 48LL))(&v6, v3, a1 + 320);
  sub_1000C4708(v4, &v6);
  uint64_t result = v6;
  uint64_t v6 = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_10010BCD8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010BCFC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (!v3) {
    sub_100008BDC();
  }
  uint64_t v4 = a1 + 320;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v3 + 48LL))(&v6, v3, a1 + 320);
  sub_1000C4730(v4, &v6);
  uint64_t result = v6;
  uint64_t v6 = 0LL;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_10010BD68( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10010BD8C( uint64_t a1, int a2, void *a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  if (a2)
  {
    *(void *)(a1 + 776) = *a3;
    int v16 = 1;
  }

  else
  {
    int v16 = 2;
  }

  sub_10010C164(a1 + 592, v16, (int)a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
}

uint64_t sub_10010BDAC(uint64_t a1)
{
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  if (*(_BYTE *)(a1 + 169)
    && (v3 = Current_1, double v4 = Current_1 - *(double *)(a1 + 776), v4 * 1000.0 < (double)sub_10010BE30()))
  {
    return (uint64_t)((double)sub_10010BE30() + (v3 - *(double *)(a1 + 776)) * -1000.0);
  }

  else
  {
    return 0LL;
  }

uint64_t sub_10010BE30()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsLocalizingBacklightOnInitialScanDelay",  0x8000100u,  kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  uint64_t v2 = v7;
  double v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 0LL;
  }
}

void sub_10010BEEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10010BF04(uint64_t a1, void *a2)
{
  uint64_t v4 = a1 + 72;
  if (sub_1003C1048(a1 + 72))
  {
    unint64_t v5 = *(void **)(a1 + 296);
    if (!v5)
    {
      unint64_t v5 = operator new(0x10uLL);
      sub_10004431C((uint64_t)v5, v4);
      uint64_t v6 = *(void **)(a1 + 296);
      *(void *)(a1 + 296) = v5;
      if (v6)
      {
        operator delete(v6);
        unint64_t v5 = *(void **)(a1 + 296);
      }
    }

    uint64_t v7 = sub_1000443FC((uint64_t)v5, a2);
    sub_10010F1E4(a1);
    return v7;
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    int v9 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "#Warning Can't insert because the database is invalid",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      v11[0] = 0;
      double v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning Can't insert because the database is invalid",  v11,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationDatabase::insertOrReplace(const std::vector<TableEntry> &) [TableEntry = CLMicroLocationBlue toothIdentityTable::Entry]",  "%s\n",  v10);
    }

    return 0LL;
  }

void sub_10010C114(_Unwind_Exception *a1)
{
}

uint64_t sub_10010C130(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 304) + 152LL))(*(void *)(a1 + 304));
}

__n128 sub_10010C140@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  __n128 result = a1[54];
  *a2 = result;
  a2[1].n128_u64[0] = a1[55].n128_u64[0];
  return result;
}

double sub_10010C154(uint64_t a1)
{
  *(_DWORD *)(a1 + 880) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 864) = 0u;
  return result;
}

void sub_10010C164( uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  switch(*(_DWORD *)a1)
  {
    case 0:
      sub_10010C54C(a1, a2);
      char v19 = 0;
      LOBYTE(v1++*(void *)(result + 8) = 0;
      LOBYTE(v17) = 0;
      BOOL v16 = 0;
      break;
    case 1:
      unsigned int v22 = sub_10010C820(a1, a2);
      goto LABEL_5;
    case 2:
      unsigned int v22 = sub_10010CAA0(a1, a2);
LABEL_5:
      BOOL v16 = 0;
      char v19 = v22 & 1;
      int v18 = (v22 >> 8) & 1;
      LOBYTE(v17) = (v22 & 0xFFFF0000) != 0;
      break;
    case 3:
      unsigned int v23 = sub_10010CDC8(a1, a2);
      char v19 = v23 & 1;
      int v18 = (v23 >> 8) & 1;
      int v17 = HIWORD(v23) & 1;
      BOOL v16 = (v23 & 0xFF000000) != 0;
      break;
    default:
      break;
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT)) {
    __asm { BR              X10 }
  }

  if ((v19 & 1) != 0) {
    sub_100127F74(*(void *)(*(void *)(a1 + 8) + 304LL), 0);
  }
  if ((v18 & 1) != 0) {
    sub_100127F74(*(void *)(*(void *)(a1 + 8) + 304LL), 1);
  }
  if ((v17 & 1) != 0) {
    sub_100128210(*(void *)(*(void *)(a1 + 8) + 304LL));
  }
  if (v16) {
    sub_100127F74(*(void *)(*(void *)(a1 + 8) + 304LL), 2);
  }
}

void sub_10010C4EC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (v22 < 0) {
    operator delete(v21);
  }
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10010C54C(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      sub_1000C67E0(*(void *)(a1 + 8) + 320LL);
      *(_DWORD *)a1 = 1;
      break;
    case 1:
      *(_BYTE *)(a1 + 4) = 1;
      break;
    case 2:
      *(_BYTE *)(a1 + 4) = 0;
      break;
    case 3:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      double v3 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        int v9 = 68289026;
        int v10 = 0;
        __int16 v11 = 2082;
        double v12 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MotionSM::transitionLogicIdle, shouldn't receive FenceCross at Idle state}",  (uint8_t *)&v9,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F618);
        }
      }

      uint64_t v4 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        int v9 = 68289026;
        int v10 = 0;
        __int16 v11 = 2082;
        double v12 = "";
        unint64_t v5 = "MotionSM::transitionLogicIdle, shouldn't receive FenceCross at Idle state";
        uint64_t v6 = "{msg%{public}.0s:MotionSM::transitionLogicIdle, shouldn't receive FenceCross at Idle state}";
        goto LABEL_19;
      }

      break;
    case 4:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      uint64_t v7 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        int v9 = 68289026;
        int v10 = 0;
        __int16 v11 = 2082;
        double v12 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MotionSM::transitionLogicIdle, shouldn't receive StopMotion at Idle state}",  (uint8_t *)&v9,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F618);
        }
      }

      uint64_t v4 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        int v9 = 68289026;
        int v10 = 0;
        __int16 v11 = 2082;
        double v12 = "";
        unint64_t v5 = "MotionSM::transitionLogicIdle, shouldn't receive StopMotion at Idle state";
        uint64_t v6 = "{msg%{public}.0s:MotionSM::transitionLogicIdle, shouldn't receive StopMotion at Idle state}";
LABEL_19:
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v5,  v6,  (uint8_t *)&v9,  0x12u);
      }

      break;
    default:
      return 0LL;
  }

  return 0LL;
}

uint64_t sub_10010C820(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      sub_1000C67F0(*(void *)(a1 + 8) + 320LL);
      sub_1000C67E0(*(void *)(a1 + 8) + 320LL);
      int v3 = 0;
      int v4 = 0;
      *(_DWORD *)a1 = 1;
      return v3 & 0x10000 | v4;
    case 1:
      int v3 = 0;
      int v4 = 0;
      *(_BYTE *)(a1 + 4) = 1;
      return v3 & 0x10000 | v4;
    case 2:
      int v3 = 0;
      int v4 = 0;
      *(_BYTE *)(a1 + 4) = 0;
      return v3 & 0x10000 | v4;
    case 3:
      if (!*(_BYTE *)(a1 + 4)) {
        goto LABEL_18;
      }
      if ((sub_10010D3EC() & 1) != 0)
      {
        int v3 = 0;
        int v4 = 1;
        int v5 = 2;
        goto LABEL_21;
      }

      if (*(_BYTE *)(a1 + 4)) {
        goto LABEL_20;
      }
LABEL_18:
      if ((sub_10010D3EC() & 1) != 0)
      {
        int v4 = 0;
        int v3 = 0x10000;
        int v5 = 3;
      }

      else
      {
LABEL_20:
        int v5 = 0;
        int v4 = 0;
        int v3 = 0x10000;
      }

uint64_t sub_10010CAA0(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      int v3 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        __int16 v11 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MotionSM::transitionLogicStopDetection, shouldn't receive SetFence at StopDetection state}",  (uint8_t *)&v8,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F618);
        }
      }

      int v4 = (os_log_s *)qword_1019348D8;
      uint64_t result = os_signpost_enabled((os_log_t)qword_1019348D8);
      if ((_DWORD)result)
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        __int16 v11 = "";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "MotionSM::transitionLogicStopDetection, shouldn't receive SetFence at StopDetection state",  "{msg%{public}.0s:MotionSM::transitionLogicStopDetection, shouldn't receive SetFence at StopDetection state}",  (uint8_t *)&v8,  0x12u);
        goto LABEL_9;
      }

      break;
    case 1:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      uint64_t v6 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        __int16 v11 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MotionSM::transitionLogicStopDetection, shouldn't receive ScreenOn at StopDetection state}",  (uint8_t *)&v8,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F618);
        }
      }

      uint64_t v7 = (os_log_s *)qword_1019348D8;
      if (os_signpost_enabled((os_log_t)qword_1019348D8))
      {
        int v8 = 68289026;
        int v9 = 0;
        __int16 v10 = 2082;
        __int16 v11 = "";
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v7,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "MotionSM::transitionLogicStopDetection, shouldn't receive ScreenOn at StopDetection state",  "{msg%{public}.0s:MotionSM::transitionLogicStopDetection, shouldn't receive ScreenOn at StopDetection state}",  (uint8_t *)&v8,  0x12u);
      }

      uint64_t result = 0LL;
      *(_BYTE *)(a1 + 4) = 1;
      break;
    case 2:
      *(_BYTE *)(a1 + 4) = 0;
      sub_1000C6880(*(void *)(a1 + 8) + 320LL);
      *(_DWORD *)a1 = 3;
      goto LABEL_21;
    case 3:
      uint64_t result = 256LL;
      break;
    case 4:
      sub_1000C6880(*(void *)(a1 + 8) + 320LL);
      *(_DWORD *)a1 = 0;
LABEL_21:
      uint64_t result = 0x10000LL;
      break;
    case 5:
      sub_1000C6880(*(void *)(a1 + 8) + 320LL);
      uint64_t result = 0LL;
      *(_DWORD *)a1 = 0;
      break;
    default:
LABEL_9:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

uint64_t sub_10010CDC8(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      int v3 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        CFStringRef v14 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive SetFence at Pend ingResumeStopDetection state}",  (uint8_t *)&v11,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F618);
        }
      }

      int v4 = (os_log_s *)qword_1019348D8;
      uint64_t result = os_signpost_enabled((os_log_t)qword_1019348D8);
      if ((_DWORD)result)
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        CFStringRef v14 = "";
        uint64_t v6 = "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive SetFence at PendingResumeStopDetection state";
        uint64_t v7 = "{msg%{public}.0s:MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive SetFence at P"
             "endingResumeStopDetection state}";
        goto LABEL_31;
      }

      break;
    case 1:
      *(_BYTE *)(a1 + 4) = 1;
      sub_1000C6870(*(void *)(a1 + 8) + 320LL);
      *(_DWORD *)a1 = 2;
      uint64_t result = 0x1000000LL;
      break;
    case 2:
      *(_BYTE *)(a1 + 4) = 0;
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      int v8 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        CFStringRef v14 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive ScreenOff at Pen dingResumeStopDetection state}",  (uint8_t *)&v11,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F618);
        }
      }

      int v4 = (os_log_s *)qword_1019348D8;
      uint64_t result = os_signpost_enabled((os_log_t)qword_1019348D8);
      if ((_DWORD)result)
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        CFStringRef v14 = "";
        uint64_t v6 = "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive ScreenOff at PendingResumeStopDetection state";
        uint64_t v7 = "{msg%{public}.0s:MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive ScreenOff at "
             "PendingResumeStopDetection state}";
        goto LABEL_31;
      }

      break;
    case 3:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      int v9 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        CFStringRef v14 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive FenceCross at Pe ndingResumeStopDetection state}",  (uint8_t *)&v11,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F618);
        }
      }

      int v4 = (os_log_s *)qword_1019348D8;
      uint64_t result = os_signpost_enabled((os_log_t)qword_1019348D8);
      if ((_DWORD)result)
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        CFStringRef v14 = "";
        uint64_t v6 = "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive FenceCross at PendingResumeStopDetection state";
        uint64_t v7 = "{msg%{public}.0s:MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive FenceCross at"
             " PendingResumeStopDetection state}";
        goto LABEL_31;
      }

      break;
    case 4:
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F618);
      }
      __int16 v10 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        CFStringRef v14 = "";
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive StopMotion at Pe ndingResumeStopDetection state}",  (uint8_t *)&v11,  0x12u);
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F618);
        }
      }

      int v4 = (os_log_s *)qword_1019348D8;
      uint64_t result = os_signpost_enabled((os_log_t)qword_1019348D8);
      if ((_DWORD)result)
      {
        int v11 = 68289026;
        int v12 = 0;
        __int16 v13 = 2082;
        CFStringRef v14 = "";
        uint64_t v6 = "MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive StopMotion at PendingResumeStopDetection state";
        uint64_t v7 = "{msg%{public}.0s:MotionSM::transitionPendingResumeLogicStopDetection, shouldn't receive StopMotion at"
             " PendingResumeStopDetection state}";
LABEL_31:
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v4,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  v6,  v7,  (uint8_t *)&v11,  0x12u);
        goto LABEL_32;
      }

      break;
    case 5:
      uint64_t result = 0LL;
      *(_DWORD *)a1 = 0;
      break;
    default:
LABEL_32:
      uint64_t result = 0LL;
      break;
  }

  return result;
}

void sub_10010D29C(int a1)
{
  __asm { BR              X10 }

void sub_10010D2C8()
{
  v0[23] = 4;
  strcpy(v0, "Idle");
}

uint64_t sub_10010D370(uint64_t result, int a2, int a3)
{
  uint64_t v4 = result;
  if (a2 == 2)
  {
    uint64_t result = sub_1000C6880(*(void *)(result + 8) + 320LL);
  }

  else if (a2 == 1)
  {
    uint64_t result = sub_1000C67F0(*(void *)(result + 8) + 320LL);
  }

  if (a3 == 2)
  {
    uint64_t result = sub_1000C6870(*(void *)(v4 + 8) + 320LL);
  }

  else if (a3 == 1)
  {
    uint64_t result = sub_1000C67E0(*(void *)(v4 + 8) + 320LL);
  }

  *(_DWORD *)uint64_t v4 = a3;
  return result;
}

uint64_t sub_10010D3EC()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMotionStopDetectionModuleEnable",  0x8000100u,  kCFAllocatorNull);
  int v1 = sub_1002A6FD4(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  BOOL v2 = v7;
  int v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v2) {
    return 1LL;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_10010D4AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10010D4C4(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_10010D4F0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10010D4F0(a1, *a2);
    sub_10010D4F0(a1, a2[1]);
    (*(void (**)(void *))a2[4])(a2 + 4);
    operator delete(a2);
  }

void sub_10010D540(id a1)
{
  qword_1019348E8 = (uint64_t)os_log_create("com.apple.locationd.Position", "MicrolocationQE");
}

uint64_t sub_10010D56C(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - *a1) >> 4) < a2)
  {
    if (a2 >= 0x333333333333334LL) {
      sub_100007008();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = sub_10003E20C(result, a2);
    v7[1] = v7[0] + v5;
    _DWORD v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 80 * v6;
    sub_10010D6DC(a1, v7);
    return sub_10010D7E8((uint64_t)v7);
  }

  return result;
}

void sub_10010D608(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10010D61C(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (!sub_100064120(v4)) {
    __assert_rtn("set_datatype", "microlocation.pb.h", 10437, "::CLMicroLocationProto::DataType_IsValid(value)");
  }
  uint64_t v5 = *(void *)(a1 + 8);
  int v7 = v4;
  v8 |= 3u;
  v6[1] = v5;
  sub_100101A04((uint64_t)v6, a1);
  sub_100068220(a2, v6);
  *(_BYTE *)(a2 + 80) = 1;
  sub_1000682D0((wireless_diagnostics::google::protobuf::MessageLite *)v6);
}

void sub_10010D6C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10010D6DC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10010D750((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10010D750(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = a7 - 80;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = v11 + v10;
    v10 -= 80LL;
    sub_100068220(v12, v10 + a3);
  }

  return a6;
}

uint64_t sub_10010D7E8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    int v4 = *(void (***)(void))(i - 80);
    *(void *)(a1 + 16) = i - 80;
    (*v4)();
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_10010D838(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x333333333333333LL) {
    sub_100007008();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 4);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x199999999999999LL) {
    unint64_t v9 = 0x333333333333333LL;
  }
  else {
    unint64_t v9 = v5;
  }
  int v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_10003E20C(v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  __int16 v13 = v10;
  CFStringRef v14 = &v10[80 * v4];
  BOOL v16 = &v10[80 * v9];
  sub_100068220(v14, a2);
  int v15 = v14 + 80;
  sub_10010D6DC(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10010D7E8((uint64_t)&v13);
  return v11;
}

void sub_10010D928(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10010D93C(uint64_t a1, uint64_t a2, std::string *__str)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + ++*(void *)(result + 8) = a1 + 16;
  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 32) = 0LL;
  unint64_t v4 = (void *)(a1 + 32);
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + sub_10000AE14(v17 - 48) = 0LL;
  *(_BYTE *)(a1 + 56) = 0;
  std::string::operator=((std::string *)(a1 + 32), __str);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  unint64_t v5 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = v4;
    *(_DWORD *)__int128 buf = 136315138;
    __int16 v13 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Initialize EventsBuffer %s", buf, 0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    unint64_t v8 = v4;
    int v10 = 136315138;
    uint64_t v11 = v8;
    unint64_t v9 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Initialize EventsBuffer %s",  (const char *)&v10);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "CLEventsBuffer<CLMicroLocationProto::Measurement, double, ProtoMeasurementGetTime>::CLEventsBuffer(size_t, std::st ring) [Event = CLMicroLocationProto::Measurement, Time = double, CallableEventGetTime = ProtoMeasurementGetTime]",  "%s\n",  v9);
  }

  return a1;
}

void sub_10010DB44(_Unwind_Exception *a1)
{
}

void sub_10010DB70(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    unint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        sub_100064FE0((wireless_diagnostics::google::protobuf::MessageLite *)(v4 - 56));
      while (v4 != v2);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_10010DBE0(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_10010DC20((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }

void sub_10010DC20(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 8LL)
  {
    unint64_t v5 = *(void **)(i - 8);
  }

  *(void *)(a1 + ++*(void *)(result + 8) = a2;
}

uint64_t sub_10010DC68(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_10010DCA0(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_10010DCDC((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

void sub_10010DCDC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40))
  {
  }

void *sub_10010DD48(void *result, id *a2, id *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_10000717C(result, a4);
    uint64_t result = sub_10010DDCC((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }

  return result;
}

void sub_10010DDAC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + ++*(void *)(result + 8) = v10;
  sub_10010DBE0(&a9);
  _Unwind_Resume(a1);
}

void *sub_10010DDCC(uint64_t a1, id *a2, id *a3, void *a4)
{
  unint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  _DWORD v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      void *v4 = 0LL;
      void *v4 = *v6++;
      unint64_t v4 = ++v11;
    }

    while (v6 != a3);
  }

  char v9 = 1;
  sub_10010DE70((uint64_t)v8);
  return v4;
}

void sub_10010DE5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_10010DE70(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_10010DEA4(a1);
  }
  return a1;
}

void sub_10010DEA4(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)(v1 - 8);
    v1 -= 8LL;
  }

char *sub_10010DEE0(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_100006E1C(result, a4);
    uint64_t result = sub_100037B94((uint64_t)(v6 + 16), a2, a3, *((char **)v6 + 1));
    *((void *)v6 + 1) = result;
  }

  return result;
}

void sub_10010DF44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + ++*(void *)(result + 8) = v10;
  sub_1000129D4(&a9);
  _Unwind_Resume(a1);
}

double *sub_10010DF64(double *a1, double *a2, double *a3)
{
  uint64_t v3 = a1;
  if (a1 != a2)
  {
    unint64_t v5 = 0LL;
    uint64_t v6 = a1;
    do
    {
      uint64_t v7 = (double *)*((void *)v6 + 1);
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          uint64_t v7 = *(double **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          unint64_t v8 = (double *)*((void *)v6 + 2);
          BOOL v9 = *(void *)v8 == (void)v6;
          uint64_t v6 = v8;
        }

        while (!v9);
      }

      ++v5;
      uint64_t v6 = v8;
    }

    while (v8 != a2);
    do
    {
      unint64_t v10 = v5 >> 1;
      CFStringRef v14 = v3;
      sub_1000F0818((void **)&v14, v5 >> 1);
      uint64_t v11 = v14;
      if (v14[5] < *a3)
      {
        uint64_t v12 = (double *)*((void *)v14 + 1);
        if (v12)
        {
          do
          {
            uint64_t v3 = v12;
            uint64_t v12 = *(double **)v12;
          }

          while (v12);
        }

        else
        {
          do
          {
            uint64_t v3 = (double *)*((void *)v11 + 2);
            BOOL v9 = *(void *)v3 == (void)v11;
            uint64_t v11 = v3;
          }

          while (!v9);
        }

        unint64_t v10 = v5 + ~v10;
      }

      unint64_t v5 = v10;
    }

    while (v10);
  }

  return v3;
}

void *sub_10010E048(void *a1, void *a2, void *a3)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2 == a3)
  {
    unint64_t v4 = 0LL;
  }

  else
  {
    unint64_t v4 = 0LL;
    unint64_t v5 = a2;
    do
    {
      uint64_t v6 = (void *)v5[1];
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = (void *)*v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          uint64_t v7 = (void *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          unint64_t v5 = v7;
        }

        while (!v8);
      }

      ++v4;
      unint64_t v5 = v7;
    }

    while (v7 != a3);
  }

  sub_10010E0CC(a1, a2, a3, v4);
  return a1;
}

void *sub_10010E0CC(void *result, void *a2, void *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_10010E150(result, a4);
    uint64_t result = (void *)sub_10010E1A0((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }

  return result;
}

void sub_10010E130( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + ++*(void *)(result + 8) = v10;
  sub_10010E26C(&a9);
  _Unwind_Resume(a1);
}

char *sub_10010E150(void *a1, unint64_t a2)
{
  if (a2 >= 0x333333333333334LL) {
    sub_100007008();
  }
  uint64_t result = (char *)sub_10003E20C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[80 * v4];
  return result;
}

uint64_t sub_10010E1A0(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (a2 == a3) {
    return a4;
  }
  unint64_t v5 = a2;
  uint64_t v6 = 0LL;
  uint64_t v7 = a4;
  do
  {
    sub_100068220(v7, v5 + 4);
    BOOL v8 = (void *)v5[1];
    if (v8)
    {
      do
      {
        uint64_t v9 = v8;
        BOOL v8 = (void *)*v8;
      }

      while (v8);
    }

    else
    {
      do
      {
        uint64_t v9 = (void *)v5[2];
        BOOL v10 = *v9 == (void)v5;
        unint64_t v5 = v9;
      }

      while (!v10);
    }

    v7 += 80LL;
    v6 += 80LL;
    unint64_t v5 = v9;
  }

  while (v9 != a3);
  return v7;
}

void sub_10010E26C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 80;
      uint64_t v7 = v4 - 80;
      do
      {
        BOOL v8 = *(void (***)(char *))v7;
        v7 -= 80;
        (*v8)(v6);
        BOOL v9 = v6 == v2;
        uint64_t v6 = v7;
      }

      while (!v9);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

unint64_t sub_10010E2F8(uint64_t a1, char *a2)
{
  uint64_t v2 = a2[23];
  if ((v2 & 0x80u) == 0LL) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(char **)a2;
  }
  unint64_t result = 0LL;
  if ((v2 & 0x80u) != 0LL) {
    uint64_t v2 = *((void *)a2 + 1);
  }
  for (; v2; --v2)
  {
    uint64_t v5 = *v3++;
    unint64_t result = 3864292196u
           - 0x395B586CA42E166BLL
           * ((0xC6A4A7935BD1E995LL * ((0xC6A4A7935BD1E995LL * v5) ^ ((0xC6A4A7935BD1E995LL * v5) >> 47))) ^ result);
  }

  return result;
}

uint64_t sub_10010E354(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3LL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3LL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1745D1745D1745DLL) {
    unint64_t v9 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v9 = v5;
  }
  int v17 = a1 + 2;
  if (v9) {
    BOOL v10 = (char *)sub_100023598(v7, v9);
  }
  else {
    BOOL v10 = 0LL;
  }
  __int16 v13 = v10;
  CFStringRef v14 = &v10[88 * v4];
  int v15 = v14;
  BOOL v16 = &v10[88 * v9];
  sub_100068220(v14, a2);
  *((_DWORD *)v14 + 20) = 0;
  v15 += 88;
  sub_1001041BC(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10004C440((uint64_t)&v13);
  return v11;
}

void sub_10010E468(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t **sub_10010E47C(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = (*a1)[1];
  if (v5 >= (*a1)[2])
  {
    uint64_t v6 = sub_10010E4F0(*a1, a2);
  }

  else
  {
    sub_100068220((*a1)[1], a2);
    *(_DWORD *)(v5 + 80) = *(_DWORD *)(a2 + 80);
    uint64_t v6 = v5 + 88;
    v4[1] = v5 + 88;
  }

  v4[1] = v6;
  return a1;
}

void sub_10010E4E8(_Unwind_Exception *a1)
{
  *(void *)(v1 + ++*(void *)(result + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_10010E4F0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x2E8BA2E8BA2E8BA3LL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x2E8BA2E8BA2E8BA3LL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1745D1745D1745DLL) {
    unint64_t v9 = 0x2E8BA2E8BA2E8BALL;
  }
  else {
    unint64_t v9 = v5;
  }
  int v17 = a1 + 2;
  if (v9) {
    BOOL v10 = (char *)sub_100023598(v7, v9);
  }
  else {
    BOOL v10 = 0LL;
  }
  __int16 v13 = v10;
  CFStringRef v14 = &v10[88 * v4];
  int v15 = v14;
  BOOL v16 = &v10[88 * v9];
  sub_100068220(v14, a2);
  *((_DWORD *)v14 + 20) = *(_DWORD *)(a2 + 80);
  v15 += 88;
  sub_1001041BC(a1, &v13);
  uint64_t v11 = a1[1];
  sub_10004C440((uint64_t)&v13);
  return v11;
}

void sub_10010E608(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t *sub_10010E61C(uint64_t *result)
{
  unint64_t v1 = result[3];
  uint64_t v2 = v1 - *result;
  if (v1 > *result)
  {
    *((_BYTE *)result + 56) = 1;
    uint64_t v3 = (uint64_t **)(result + 1);
    uint64_t v4 = (uint64_t *)result[1];
    sub_1000F0818(&v4, v2);
    return sub_10010E7AC(v3, *v3, v4);
  }

  return result;
}

double *sub_10010E678(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t **)(a1 + 8);
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = (uint64_t **)v4;
        uint64_t v4 = (uint64_t *)*v4;
        unint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }

      uint64_t v4 = (uint64_t *)v4[1];
    }

    while (v4);
    unint64_t v5 = v3 + 1;
  }

  else
  {
    unint64_t v5 = (uint64_t **)(a1 + 8);
  }

uint64_t sub_10010E6F8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = (char *)operator new(0x70uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + ++*(void *)(result + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  uint64_t result = sub_100068220(v6 + 32, a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_10010E748(_Unwind_Exception *a1)
{
}

void sub_10010E760(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void (****)(void))a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      (*v2[4])(v2 + 4);
    }
    operator delete(v2);
  }

uint64_t *sub_10010E7AC(uint64_t **a1, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v6 = sub_1000087E8(a1, v4);
      (*(void (**)(uint64_t *))v4[4])(v4 + 4);
      operator delete(v4);
      uint64_t v4 = v6;
    }

    while (v6 != a3);
  }

  return a3;
}

void *sub_10010E818(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = (void *)(a1 + 24);
  unint64_t v8 = sub_100094730(a1 + 24, a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }

    __int16 v13 = *(void **)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      CFStringRef v14 = (void *)*v13;
      if (*v13)
      {
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v9)
          {
          }

          else
          {
            if (v12 > 1)
            {
              if (v15 >= v10) {
                v15 %= v10;
              }
            }

            else
            {
              v15 &= v10 - 1;
            }

            if (v15 != v3) {
              break;
            }
          }

          CFStringRef v14 = (void *)*v14;
        }

        while (v14);
      }
    }
  }

  sub_10010EA98(a1, v9, a3, (uint64_t)v25);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1LL;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }

    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }

  int v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    *(void *)v25[0] = *v22;
    *int v22 = v25[0];
  }

  else
  {
    *(void *)v25[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v25[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v25[0])
    {
      unint64_t v23 = *(void *)(*(void *)v25[0] + 8LL);
      if ((v10 & (v10 - 1)) != 0)
      {
        if (v23 >= v10) {
          v23 %= v10;
        }
      }

      else
      {
        v23 &= v10 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v23) = v25[0];
    }
  }

  CFStringRef v14 = (void *)v25[0];
  v25[0] = 0LL;
  ++*v7;
  sub_10010EBB4((uint64_t)v25, 0LL);
  return v14;
}

void sub_10010EA80(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10010EA98@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x88uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + ++*(void *)(result + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *unint64_t v8 = 0LL;
  v8[1] = a2;
  uint64_t result = sub_10010EB0C(v7, (uint64_t)(v8 + 2), a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_10010EAF4(_Unwind_Exception *a1)
{
}

uint64_t sub_10010EB0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a2 = *(_OWORD *)a3;
  sub_10004B7D4(a2 + 16, (__int128 *)(a3 + 16));
  sub_10004B7D4(a2 + 48, (__int128 *)(a3 + 48));
  uint64_t result = sub_10004B7D4(a2 + 80, (__int128 *)(a3 + 80));
  *(void *)(a2 + 112) = *(void *)(a3 + 112);
  return result;
}

void sub_10010EB70(_Unwind_Exception *exception_object)
{
  if (v1[72] && v1[71] < 0) {
    operator delete(*v3);
  }
  if (v1[40])
  {
    if (v1[39] < 0) {
      operator delete(*v2);
    }
  }

  _Unwind_Resume(exception_object);
}

void sub_10010EBB4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_10010DCDC((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }

uint64_t sub_10010EBF8@<X0>( uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v5 = result;
  uint64_t v8 = a3;
  uint64_t v9 = a4;
  if (result != a2)
  {
    do
    {
      uint64_t result = sub_10010EC60((uint64_t)&v8, v5);
      v5 += 80LL;
    }

    while (v5 != a2);
    a3 = v8;
    a4 = v9;
    uint64_t v5 = a2;
  }

  *a5 = v5;
  a5[1] = a3;
  a5[2] = a4;
  return result;
}

uint64_t sub_10010EC60(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = sub_10010ECC4(*(uint64_t ***)a1, *(double **)(a1 + 8), a2);
  *(void *)(a1 + ++*(void *)(result + 8) = v3;
  uint64_t v4 = (uint64_t *)v3[1];
  if (v4)
  {
    do
    {
      uint64_t v5 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }

    while (v4);
  }

  else
  {
    do
    {
      uint64_t v5 = (uint64_t *)v3[2];
      BOOL v6 = *v5 == (void)v3;
      unint64_t v3 = v5;
    }

    while (!v6);
  }

  *(void *)(a1 + ++*(void *)(result + 8) = v5;
  return a1;
}

uint64_t *sub_10010ECC4(uint64_t **a1, double *a2, uint64_t a3)
{
  uint64_t v5 = sub_10010ED44(a1, a2, &v7, (uint64_t)(v8 + 4));
  sub_1000085FC(a1, (uint64_t)v7, (uint64_t **)v5, v8);
  return v8;
}

void sub_10010ED24( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char *__p)
{
  uint8x8_t v11 = __p;
  std::stringbuf::string_type __p = 0LL;
  if (v11) {
    sub_10122C360((uint64_t)&__p, v11);
  }
  _Unwind_Resume(exception_object);
}

double *sub_10010ED44(void *a1, double *a2, double **a3, uint64_t a4)
{
  uint64_t v4 = (double *)(a1 + 1);
  if (a1 + 1 != (void *)a2)
  {
    double v5 = *(double *)(a4 + 8);
    if (a2[5] < v5)
    {
      while (1)
      {
        uint64_t v6 = *(void *)v4;
        a2 = v4;
        if (!*(void *)v4) {
          break;
        }
        while (1)
        {
          uint64_t v4 = (double *)v6;
          uint64_t v6 = *(void *)(v6 + 8);
          if (!v6) {
            goto LABEL_19;
          }
        }
      }

void *sub_10010EE2C(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_10010EEB0(result, a4);
    uint64_t result = (void *)sub_10010EF04((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }

  return result;
}

void sub_10010EE90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + ++*(void *)(result + 8) = v10;
  sub_10010DB70(&a9);
  _Unwind_Resume(a1);
}

char *sub_10010EEB0(void *a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493LL) {
    sub_100007008();
  }
  uint64_t result = (char *)sub_1000AC8F0((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[56 * v4];
  return result;
}

uint64_t sub_10010EF04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0LL;
    do
    {
      *(_DWORD *)(sub_100064FDC(a4 + v7, a2 + v7) + sub_10000AE14(v17 - 48) = *(_DWORD *)(a2 + v7 + 48);
      v7 += 56LL;
    }

    while (a2 + v7 != a3);
    a4 += v7;
  }

  return a4;
}

void sub_10010EF74(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 56;
    do
    {
      sub_100064FE0((wireless_diagnostics::google::protobuf::MessageLite *)(v4 + v2));
      v2 -= 56LL;
    }

    while (v2);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10010EF98(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, double *a5)
{
  unint64_t v6 = 0x8E38E38E38E38E39LL * ((a1[1] - *a1) >> 3);
  unint64_t v7 = v6 + 1;
  if (v6 + 1 > 0x38E38E38E38E38ELL) {
    sub_100007008();
  }
  if (0x1C71C71C71C71C72LL * ((a1[2] - *a1) >> 3) > v7) {
    unint64_t v7 = 0x1C71C71C71C71C72LL * ((a1[2] - *a1) >> 3);
  }
  if (0x8E38E38E38E38E39LL * ((a1[2] - *a1) >> 3) >= 0x1C71C71C71C71C7LL) {
    unint64_t v12 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v12 = v7;
  }
  unint64_t v20 = a1 + 2;
  if (v12) {
    uint64_t v13 = (char *)sub_100046304((uint64_t)(a1 + 2), v12);
  }
  else {
    uint64_t v13 = 0LL;
  }
  float v16 = v13;
  float v17 = &v13[72 * v6];
  unint64_t v19 = &v13[72 * v12];
  sub_10010F0E4((uint64_t)(a1 + 2), (uint64_t)v17, a2, a3, a4, a5);
  BOOL v18 = v17 + 72;
  sub_100046290(a1, &v16);
  uint64_t v14 = a1[1];
  sub_1000464DC(&v16);
  return v14;
}

void sub_10010F0D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_10010F0E4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, double *a6)
{
  uint64_t v9 = *a3;
  uint64_t v10 = a3[1];
  if (*(char *)(a4 + 23) < 0)
  {
    sub_1010DD48C(__dst, *(void **)a4, *(void *)(a4 + 8));
  }

  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a4;
    uint64_t v14 = *(void *)(a4 + 16);
  }

  if (*(char *)(a5 + 23) < 0)
  {
    sub_1010DD48C(__p, *(void **)a5, *(void *)(a5 + 8));
  }

  else
  {
    *(_OWORD *)std::stringbuf::string_type __p = *(_OWORD *)a5;
    uint64_t v12 = *(void *)(a5 + 16);
  }

  sub_1000443F8(a2, v9, v10, __dst, __p, *a6);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v14) < 0) {
    operator delete(__dst[0]);
  }
}

void sub_10010F1B0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_10010F1E4(uint64_t a1)
{
  unsigned int v2 = sub_10003911C(a1);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F618);
  }
  unint64_t v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v10 = "MicroLocationBluetoothIdentityTable";
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicate s a serious problem",  buf,  0xCu);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F618);
    }
    int v7 = 136446210;
    double v8 = "MicroLocationBluetoothIdentityTable";
    unint64_t v6 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "%{public}s has been written to more than expected. Clearing up disk space. If this log is seen often that indicates a serious problem",  &v7,  12);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "BOOL CLMicroLocationDatabase::freeSpaceIfFull() [Table = CLMicroLocationBluetoothIdentityTable]",  "%s\n",  v6);
  }

  BOOL result = sub_1000315FC(a1);
  if (result)
  {
    else {
      uint64_t v5 = *(void *)(a1 + 160);
    }
    sub_1003C1EC0(a1 + 72, v5);
    return 1LL;
  }

  return result;
}

uint64_t sub_10010F3D8()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBluetoothIdentityTableMaxRows", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A77CC(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  unsigned int v2 = v7;
  unint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 96LL;
  }
}

void sub_10010F498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10010F4B0(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_10010DCA0(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0LL;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0LL; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0LL;
    }

    *(void *)(a1 + 24) = 0LL;
  }

void *sub_10010F504(void *a1, _OWORD *a2, __int128 *a3, __int128 *a4, uint64_t a5, void *a6)
{
  unsigned int v7 = sub_10010F63C(a1, v10[0]);
  if ((v8 & 1) != 0) {
    v10[0] = 0LL;
  }
  sub_10010EBB4((uint64_t)v10, 0LL);
  return v7;
}

void sub_10010F560(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

unint64_t sub_10010F578@<X0>( uint64_t a1@<X0>, _OWORD *a2@<X1>, __int128 *a3@<X2>, __int128 *a4@<X3>, uint64_t a5@<X4>, void *a6@<X5>, uint64_t a7@<X8>)
{
  uint64_t v14 = a1 + 16;
  unint64_t v15 = operator new(0x88uLL);
  *(void *)a7 = v15;
  *(void *)(a7 + ++*(void *)(result + 8) = v14;
  *(_BYTE *)(a7 + 16) = 0;
  void *v15 = 0LL;
  v15[1] = 0LL;
  sub_10010F6AC(v14, (uint64_t)(v15 + 2), a2, a3, a4, a5, a6);
  *(_BYTE *)(a7 + 16) = 1;
  unint64_t result = sub_100094730(a1 + 24, (uint64_t)(v15 + 2));
  v15[1] = result;
  return result;
}

void sub_10010F624(_Unwind_Exception *a1)
{
}

void *sub_10010F63C(void *a1, void *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = (uint64_t)(a2 + 2);
  unint64_t v5 = sub_100094730((uint64_t)(a1 + 3), (uint64_t)(a2 + 2));
  v2[1] = v5;
  unint64_t v6 = sub_10010F7EC((uint64_t)a1, v5, v4);
  if (v6) {
    return v6;
  }
  sub_10010F940(a1, v2);
  return v2;
}

void sub_10010F6AC(uint64_t a1, uint64_t a2, _OWORD *a3, __int128 *a4, __int128 *a5, uint64_t a6, void *a7)
{
  LOBYTE(__p) = 0;
  char v9 = 0;
  sub_10010F730(a2, a3, a4, a5, &__p, a7);
  if (v9)
  {
    if (v8 < 0) {
      operator delete((void *)__p);
    }
  }

void sub_10010F70C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0) {
      operator delete(__p);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10010F730(uint64_t a1, _OWORD *a2, __int128 *a3, __int128 *a4, __int128 *a5, void *a6)
{
  *(_OWORD *)a1 = *a2;
  sub_10004B7D4(a1 + 16, a3);
  sub_10004B7D4(a1 + 48, a4);
  sub_10004B7D4(a1 + 80, a5);
  *(void *)(a1 + 112) = *a6;
  return a1;
}

void sub_10010F7A8(_Unwind_Exception *exception_object)
{
  if (v1[72] && v1[71] < 0) {
    operator delete(*v3);
  }
  if (v1[40])
  {
    if (v1[39] < 0) {
      operator delete(*v2);
    }
  }

  _Unwind_Resume(exception_object);
}

void *sub_10010F7EC(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v4);
    v7.i16[0] = vaddlv_u8(v7);
    unint64_t v8 = v7.u32[0];
    if (v7.u32[0] > 1uLL) {
      uint64_t v9 = v4 <= a2 ? a2 % v4 : a2;
    }
    else {
      uint64_t v9 = (v4 - 1) & a2;
    }
    uint64_t v10 = *(void **)(*(void *)a1 + 8 * v9);
    if (v10)
    {
      BOOL v11 = (void *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == a2)
          {
          }

          else
          {
            if (v8 > 1)
            {
              if (v12 >= v4) {
                v12 %= v4;
              }
            }

            else
            {
              v12 &= v4 - 1;
            }

            if (v12 != v9) {
              break;
            }
          }

          BOOL v11 = (void *)*v11;
        }

        while (v11);
      }
    }
  }

  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v4 || (float)(v14 * (float)v4) < v13)
  {
    BOOL v15 = 1LL;
    if (v4 >= 3) {
      BOOL v15 = (v4 & (v4 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v4);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100019E10(a1, v18);
  }

  return 0LL;
}

void *sub_10010F940(void *result, void *a2)
{
  int8x8_t v2 = (int8x8_t)result[1];
  unint64_t v3 = a2[1];
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *(void *)&v2) {
      v3 %= *(void *)&v2;
    }
  }

  else
  {
    v3 &= *(void *)&v2 - 1LL;
  }

  unint64_t v5 = *(void **)(*result + 8 * v3);
  if (v5)
  {
    *a2 = *v5;
LABEL_13:
    *unint64_t v5 = a2;
    goto LABEL_14;
  }

  *a2 = result[2];
  result[2] = a2;
  *(void *)(*result + 8 * v3) = result + 2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8LL);
    if (v4.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v2) {
        v6 %= *(void *)&v2;
      }
    }

    else
    {
      v6 &= *(void *)&v2 - 1LL;
    }

    unint64_t v5 = (void *)(*result + 8 * v6);
    goto LABEL_13;
  }

void *sub_10010F9F8(void *a1, void *a2, uint64_t a3)
{
  *a1 = off_10181F668;
  a1[1] = 0LL;
  a1[2] = 0LL;
  a1[3] = a2;
  a1[4] = a3;
  a1[5] = 0LL;
  a1[5] = objc_msgSend(objc_msgSend(a2, "silo"), "newTimer");
  return a1;
}

uint64_t sub_10010FA3C(uint64_t a1)
{
  *(void *)a1 = off_10181F668;
  [*(id *)(a1 + 8) invalidate];

  *(void *)(a1 + ++*(void *)(result + 8) = 0LL;
  if (*(void *)(a1 + 16) && sub_10010FAA4())
  {
    [*(id *)(a1 + 16) invalidate];

    *(void *)(a1 + 16) = 0LL;
  }

  return a1;
}

uint64_t sub_10010FAA4()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBleNonLeechingScannerEnabled", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A6FD4(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  BOOL v2 = v7;
  unint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v2) {
    return 1LL;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_10010FB64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_10010FB80(uint64_t a1)
{
  int v1 = (void *)sub_10010FA3C(a1);
  operator delete(v1);
}

uint64_t sub_10010FB94(uint64_t a1)
{
  CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F760);
  }
  unint64_t v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    v5[0] = 68289282;
    v5[1] = 0;
    __int16 v6 = 2082;
    BOOL v7 = "";
    __int16 v8 = 2050;
    CFAbsoluteTime v9 = Current_1;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CBDiscovery, a BLE session timer stopped, now:%{public}.3f}",  (uint8_t *)v5,  0x1Cu);
  }

  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 32LL))(*(void *)(a1 + 32));
}

void sub_10010FCA0(id *a1, uint64_t a2)
{
  if (!*(_BYTE *)(a2 + 9))
  {
    double v4 = *(double *)a2;
    double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F760);
    }
    __int16 v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = (uint64_t)v4;
      double v8 = v4 + Current_1;
      *(_DWORD *)__int128 buf = 68289794;
      int v11 = 0;
      __int16 v12 = 2082;
      float v13 = "";
      __int16 v14 = 2050;
      double v15 = Current_1;
      __int16 v16 = 2050;
      uint64_t v17 = v7;
      __int16 v18 = 2050;
      double v19 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CBDiscovery, Starting BLE scan timer, now:%{public}.3f, durationInMs:%{publ ic}lld, expected end time:%{public}.3f}",  buf,  0x30u);
    }

    else
    {
      double v8 = v4 + Current_1;
    }

    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    void v9[2] = sub_10010FF38;
    void v9[3] = &unk_10181D3D0;
    void v9[4] = a1;
    [a1[5] setHandler:v9];
    [a1[5] setNextFireTime:v8];
  }

void sub_10010FE24(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 16) && sub_10010FAA4())
  {
    if (*(_BYTE *)(a2 + 10)) {
      goto LABEL_13;
    }
    sub_1002F0B04(&v12);
    CFStringRef v4 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBleForceScanNearbyInfoV2", 0x8000100u, kCFAllocatorNull);
    int v5 = sub_1002A6FD4(v12, (uint64_t)v4, &v11);
    CFRelease(v4);
    BOOL v6 = v11;
    uint64_t v7 = v13;
    if (v13)
    {
      p_shared_owners = (unint64_t *)&v13->__shared_owners_;
      do
        unint64_t v9 = __ldaxr(p_shared_owners);
      while (__stlxr(v9 - 1, p_shared_owners));
      if (!v9)
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }

    int v10 = v6 ? v5 : 0;
    if (v10 == 1) {
LABEL_13:
    }
      sub_100110C10(a1, a2);
  }

void sub_10010FF20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10010FF38(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24LL))(*(void *)(a1 + 32));
}

id sub_10010FF48(uint64_t a1)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F760);
  }
  BOOL v2 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Unregister all BLE scan sessions", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F760);
    }
    v5[0] = 0;
    CFStringRef v4 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "Unregister all BLE scan sessions",  v5,  2);
    sub_10029211C("Generic", 1LL, 0, 2LL, "virtual void CLMicroLocationBLERssiBridge::stopBleRssiSession()", "%s\n", v4);
  }

  [*(id *)(a1 + 40) invalidate];
  return sub_1001100E8(a1);
}

id sub_1001100E8(uint64_t a1)
{
  id result = (id)sub_10010FAA4();
  if ((_DWORD)result)
  {
    [*(id *)(a1 + 16) removeAllDiscoveryTypes];
    [*(id *)(a1 + 16) setDiscoveryFlags:0];
    [*(id *)(a1 + 16) setDeviceFilter:0];
    return [*(id *)(a1 + 16) setOobKeys:0];
  }

  return result;
}

void sub_100110160(uint64_t a1, void *a2)
{
  uint64_t v3 = a1;
  [*(id *)(a1 + 24) silo];
  unint64_t v4 = (unint64_t)[a2 deviceFlags] & 0x180;
  unsigned __int8 v5 = [a2 nearbyInfoV2DecryptedFlags];
  if (v4 || (v5 & 4) != 0)
  {
    unsigned int v6 = [a2 discoveryFlags];
    unsigned __int8 v7 = [a2 deviceFlags];
    unsigned __int16 v8 = (unsigned __int16)[a2 deviceFlags];
    if (qword_1019348E0 != -1) {
      dispatch_once(&qword_1019348E0, &stru_10181F780);
    }
    uint64_t v9 = *(void *)&v6 & 0x80040LL;
    unint64_t v10 = v7 & 0x80;
    unint64_t v11 = v8 & 0x8000;
    uint64_t v12 = (os_log_s *)qword_1019348E8;
    if (os_log_type_enabled((os_log_t)qword_1019348E8, OS_LOG_TYPE_DEBUG))
    {
      unint64_t v18 = v11 >> 15;
      unint64_t v19 = v8 & 0x8000;
      id v13 = objc_msgSend(objc_msgSend(a2, "idsDeviceID"), "UTF8String");
      id v14 = objc_msgSend(objc_msgSend(a2, "identifier"), "UTF8String");
      uint64_t v15 = v3;
      id v16 = objc_msgSend(objc_msgSend(a2, "model"), "UTF8String");
      [a2 bleAdvertisementTimestamp];
      *(_DWORD *)__int128 buf = 68291075;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = "";
      *(_WORD *)&_BYTE buf[18] = 2081;
      *(void *)&buf[20] = v13;
      __int16 v35 = 2081;
      id v36 = v14;
      __int16 v37 = 2081;
      id v38 = v16;
      uint64_t v3 = v15;
      LOWORD(v39) = 1025;
      *(_DWORD *)((char *)&v39 + 2) = v9 != 0;
      HIWORD(v39) = 1025;
      int v40 = v10 >> 7;
      __int16 v41 = 1025;
      unint64_t v11 = v19;
      int v42 = v18;
      __int16 v43 = 2050;
      uint64_t v44 = v17;
      __int16 v45 = 1026;
      *(_DWORD *)signed __int8 v46 = [a2 rssi];
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Ble Beacon Received, IDS ID:%{private, location:escape_only}s, BT identifier:%{ private, location:escape_only}s, Model:%{private, location:escape_only}s, is device nearbyInfo or nearbyAc tion type?:%{private}hhd, is device same account?:%{private}hhd, is device cloud paired?:%{private}hhd , AdvertisementTimestamp:%{public}.3f, RSSI:%{public}d}",  buf,  0x52u);
    }

    CFAbsoluteTime Current_1 = j__CFAbsoluteTimeGetCurrent_1();
    id v32 = a2;
    sub_1001015AC(&v32, v30);
    if (v31) {
      (*(void (**)(void, CFAbsoluteTime *, _BYTE *))(**(void **)(v3 + 32) + 16LL))( *(void *)(v3 + 32),  &Current_1,  v30);
    }
    if ([a2 identifier] && v9 && v10 && v11)
    {
      sub_1010DDBC0(buf, (char *)objc_msgSend(objc_msgSend(a2, "identifier"), "UTF8String"));
      sub_10010147C((uint64_t)buf, (uint64_t)&v49);
      if ((buf[23] & 0x80000000) != 0) {
        operator delete(*(void **)buf);
      }
      if (v50)
      {
        if ([a2 name])
        {
          sub_1010DDBC0(buf, (char *)objc_msgSend(objc_msgSend(a2, "name"), "UTF8String"));
          *(_OWORD *)__int128 v27 = *(_OWORD *)buf;
          uint64_t v28 = *(void *)&buf[16];
          char v29 = 1;
        }

        else
        {
          LOBYTE(v27[0]) = 0;
          char v29 = 0;
        }

        if ([a2 stableIdentifier])
        {
          sub_1010DDBC0(buf, (char *)objc_msgSend(objc_msgSend(a2, "stableIdentifier"), "UTF8String"));
          *(_OWORD *)uint64_t v24 = *(_OWORD *)buf;
          uint64_t v25 = *(void *)&buf[16];
          char v26 = 1;
        }

        else
        {
          LOBYTE(v24[0]) = 0;
          char v26 = 0;
        }

        if ([a2 model])
        {
          sub_1010DDBC0(buf, (char *)objc_msgSend(objc_msgSend(a2, "model"), "UTF8String"));
          *(_OWORD *)size_t v21 = *(_OWORD *)buf;
          uint64_t v22 = *(void *)&buf[16];
          char v23 = 1;
        }

        else
        {
          LOBYTE(v21[0]) = 0;
          char v23 = 0;
        }

        CFAbsoluteTime v20 = j__CFAbsoluteTimeGetCurrent_1();
        sub_10010F730((uint64_t)buf, &v49, (__int128 *)v27, (__int128 *)v24, (__int128 *)v21, &v20);
        (*(void (**)(void, _BYTE *))(**(void **)(v3 + 32) + 24LL))(*(void *)(v3 + 32), buf);
        if (v48 && v47 < 0) {
          operator delete(*(void **)&v46[2]);
        }
        if (BYTE4(v44) && SBYTE3(v44) < 0) {
          operator delete(v39);
        }
        if ((_BYTE)v38 && SHIBYTE(v37) < 0) {
          operator delete(*(void **)&buf[16]);
        }
        if (v23 && SHIBYTE(v22) < 0) {
          operator delete(v21[0]);
        }
        if (v26 && SHIBYTE(v25) < 0) {
          operator delete(v24[0]);
        }
        if (v29 && SHIBYTE(v28) < 0) {
          operator delete(v27[0]);
        }
      }
    }

    if (v31) {
      sub_100064520((wireless_diagnostics::google::protobuf::MessageLite *)v30);
    }
  }

void sub_1001105C4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25, char a26, void *a27, uint64_t a28, int a29, __int16 a30, char a31, char a32, char a33, int a34, __int16 a35, char a36, char a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, char a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,int a51,__int16 a52,char a53,char a54)
{
  if (a19 && a18 < 0) {
    operator delete(__p);
  }
  if (a26 && a25 < 0) {
    operator delete(a20);
  }
  if (a33 && a32 < 0) {
    operator delete(a27);
  }
  if (a46) {
    sub_100064520((wireless_diagnostics::google::protobuf::MessageLite *)&a35);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100110680(uint64_t a1)
{
  return a1;
}

void sub_1001106E8(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 9) || *(void *)(a2 + 40) != *(void *)(a2 + 48)) {
    goto LABEL_12;
  }
  sub_1002F0B04(buf);
  CFStringRef v4 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsBleForceRequestedType15Type16ScanWhenDeviceFilterIsEmpty",  0x8000100u,  kCFAllocatorNull);
  char v5 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v4, &v29);
  CFRelease(v4);
  BOOL v6 = v29;
  unsigned __int8 v7 = *(std::__shared_weak_count **)v31;
  if (*(void *)v31)
  {
    unsigned __int16 v8 = (unint64_t *)(*(void *)v31 + 8LL);
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  char v10 = v6 ? v5 : 0;
  if ((v10 & 1) != 0)
  {
LABEL_12:
    [*(id *)(a1 + 8) setDiscoveryFlags:524352];
    [*(id *)(a1 + 8) setLabel:@"CLMiLoLeeching"];
    BOOL v11 = *(_BYTE *)(a2 + 9) == 0;
    unint64_t v12 = (unint64_t)[*(id *)(a1 + 8) discoveryFlags];
    id v13 = *(void **)(a1 + 8);
    if (v11)
    {
      [v13 setDiscoveryFlags:v12 | 0x1000000000];
      [*(id *)(a1 + 8) setUseCase:524290];
      sub_1002F0B04(buf);
      CFStringRef v14 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsBleType15andType16DeviceFilterIsSet",  0x8000100u,  kCFAllocatorNull);
      char v15 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v14, &v29);
      CFRelease(v14);
      BOOL v16 = v29;
      uint64_t v17 = *(std::__shared_weak_count **)v31;
      if (*(void *)v31)
      {
        unint64_t v18 = (unint64_t *)(*(void *)v31 + 8LL);
        do
          unint64_t v19 = __ldaxr(v18);
        while (__stlxr(v19 - 1, v18));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }

      if (v16) {
        char v20 = 0;
      }
      else {
        char v20 = v15;
      }
      if ((v20 & 1) == 0)
      {
        if (*(void *)(a2 + 40) == *(void *)(a2 + 48))
        {
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181F760);
          }
          __int128 v27 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 68289026;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)char v31 = 2082;
            *(void *)&void v31[2] = "";
            _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:scanner type 15, 16 deviceFilter is empty for initiated scan}",  buf,  0x12u);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181F760);
            }
          }

          uint64_t v28 = (os_log_s *)qword_1019348D8;
          if (os_signpost_enabled((os_log_t)qword_1019348D8))
          {
            *(_DWORD *)__int128 buf = 68289026;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)char v31 = 2082;
            *(void *)&void v31[2] = "";
            _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v28,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "scanner type 15, 16 deviceFilter is empty for initiated scan",  "{msg%{public}.0s:scanner type 15, 16 deviceFilter is empty for initiated scan}",  buf,  0x12u);
          }
        }

        else
        {
          id v21 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
          char v23 = *(uint64_t **)(a2 + 40);
          for (uint64_t i = *(uint64_t **)(a2 + 48); v23 != i; v23 += 3)
          {
            uint64_t v24 = v23;
            objc_msgSend( v21,  "addObject:",  +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v24));
          }

          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181F760);
          }
          uint64_t v25 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)char v31 = 2082;
            *(void *)&void v31[2] = "";
            __int16 v32 = 2114;
            id v33 = v21;
            _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:scanner type 15, 16 deviceFilter is, deviceFilter:%{public, location:escape_only}@}",  buf,  0x1Cu);
          }

          [*(id *)(a1 + 8) setDeviceFilter:v21];
        }
      }

      if (sub_100111904()) {
        objc_msgSend( *(id *)(a1 + 8),  "setDiscoveryFlags:",  (unint64_t)objc_msgSend(*(id *)(a1 + 8), "discoveryFlags") | 0x200000000);
      }
      [*(id *)(a1 + 8) setBleScanRate:sub_1001119DC()];
    }

    else
    {
      [v13 setDiscoveryFlags:v12 | 0x100200000000];
      [*(id *)(a1 + 8) setUseCase:524291];
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F760);
    }
    char v26 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)char v31 = 2082;
      *(void *)&void v31[2] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:will not conduct nearbyAction, nearbyInfo requested scan because device filter is empty}",  buf,  0x12u);
    }
  }

void sub_100110BE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

id sub_100110C10(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a2 + 9)) {
    goto LABEL_61;
  }
  sub_1002F0B04(buf);
  CFStringRef v2 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsBleNonLeechingBackgroundScanEnabled",  0x8000100u,  kCFAllocatorNull);
  char v3 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v2, (BOOL *)&v45);
  CFRelease(v2);
  int v4 = v45;
  char v5 = *(std::__shared_weak_count **)v47;
  if (*(void *)v47)
  {
    BOOL v6 = (unint64_t *)(*(void *)v47 + 8LL);
    do
      unint64_t v7 = __ldaxr(v6);
    while (__stlxr(v7 - 1, v6));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }

  char v8 = v4 ? v3 : 0;
  if ((v8 & 1) == 0)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F760);
    }
    int v40 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 68289026;
      *(_DWORD *)&uint8_t buf[4] = 0;
      *(_WORD *)char v47 = 2082;
      *(void *)&v47[2] = "";
      _os_log_impl( (void *)&_mh_execute_header,  v40,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:BleNonLeechingBackgroundScanEnabled is disabled}",  buf,  0x12u);
    }

    __int16 v41 = *(void **)(a1 + 16);
    uint64_t v44 = (id *)(a1 + 16);
    [v41 removeAllDiscoveryTypes];
    [*v44 setDiscoveryFlags:0];
    [*v44 setDeviceFilter:0];
    return [*v44 setOobKeys:0];
  }

  else
  {
LABEL_61:
    [*(id *)(a1 + 16) addDiscoveryType:19];
    sub_1002F0B04(buf);
    CFStringRef v9 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBleType22DeviceFilterIsSet", 0x8000100u, kCFAllocatorNull);
    char v10 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v9, (BOOL *)&v45);
    CFRelease(v9);
    int v11 = v45;
    unint64_t v12 = *(std::__shared_weak_count **)v47;
    if (*(void *)v47)
    {
      id v13 = (unint64_t *)(*(void *)v47 + 8LL);
      do
        unint64_t v14 = __ldaxr(v13);
      while (__stlxr(v14 - 1, v13));
      if (!v14)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }

    if (v11) {
      char v15 = 0;
    }
    else {
      char v15 = v10;
    }
    if ((v15 & 1) == 0)
    {
      id v16 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
      id v17 = +[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array");
      unint64_t v19 = *(id **)(a2 + 16);
      for (uint64_t i = *(id **)(a2 + 24); v19 != i; ++v19)
      {
        id v20 = *v19;
        id v21 = [*v19 btAddressData];
        if ([v21 length] == (id)7)
        {
          uint64_t v22 = [v21 bytes];
          char v23 = objc_alloc(&OBJC_CLASS___NSString);
          uint64_t v24 = "Random";
          if ((*v22 & 1) == 0) {
            uint64_t v24 = "Public";
          }
          uint64_t v25 =  -[NSString initWithFormat:]( v23,  "initWithFormat:",  @"%s %02X:%02X:%02X:%02X:%02X:%02X",  v24,  v22[1],  v22[2],  v22[3],  v22[4],  v22[5],  v22[6]);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181F760);
          }
          char v26 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
          {
            __int128 v27 = -[NSString UTF8String](v25, "UTF8String");
            *(_DWORD *)__int128 buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)char v47 = 2082;
            *(void *)&v47[2] = "";
            __int16 v48 = 2082;
            __int128 v49 = v27;
            _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:_nsDataToBTAddressString, address:%{public, location:escape_only}s}",  buf,  0x1Cu);
          }
        }

        else
        {
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181F760);
          }
          uint64_t v28 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)char v47 = 2082;
            *(void *)&v47[2] = "";
            __int16 v48 = 2114;
            __int128 v49 = (const char *)v21;
            _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "{msg%{public}.0s:Invalid Address data, address:%{public, location:escape_only}@}",  buf,  0x1Cu);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181F760);
            }
          }

          BOOL v29 = (os_log_s *)qword_1019348D8;
          if (os_signpost_enabled((os_log_t)qword_1019348D8))
          {
            *(_DWORD *)__int128 buf = 68289282;
            *(_DWORD *)&uint8_t buf[4] = 0;
            *(_WORD *)char v47 = 2082;
            *(void *)&v47[2] = "";
            __int16 v48 = 2114;
            __int128 v49 = (const char *)v21;
            _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v29,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Invalid Address data",  "{msg%{public}.0s:Invalid Address data, address:%{public, location:escape_only}@}",  buf,  0x1Cu);
          }

          uint64_t v25 = 0LL;
        }

        [v16 addObject:v25];
        [v17 addObject:v20];
      }

      [*(id *)(a1 + 16) setOobKeys:v17];
      [*(id *)(a1 + 16) setDeviceFilter:v16];
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F760);
      }
      uint64_t v30 = (os_log_s *)qword_1019348D8;
      if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 68289282;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(_WORD *)char v47 = 2082;
        *(void *)&v47[2] = "";
        __int16 v48 = 2114;
        __int128 v49 = (const char *)v16;
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:scanner type 22 deviceFilter is, deviceFilter:%{public, location:escape_only}@}",  buf,  0x1Cu);
      }
    }

    [*(id *)(a1 + 16) setLabel:@"CLMiLoNonLeeching"];
    char v31 = *(void **)(a1 + 16);
    if (*(_BYTE *)(a2 + 9))
    {
      sub_1002F0B04(buf);
      CFStringRef v32 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBleBackgroundScanRate", 0x8000100u, kCFAllocatorNull);
      int v33 = sub_1002A7D20(*(uint64_t *)buf, (uint64_t)v32, &v45);
      CFRelease(v32);
      unsigned int v34 = v45;
      __int16 v35 = *(std::__shared_weak_count **)v47;
      if (*(void *)v47)
      {
        id v36 = (unint64_t *)(*(void *)v47 + 8LL);
        do
          unint64_t v37 = __ldaxr(v36);
        while (__stlxr(v37 - 1, v36));
        if (!v37)
        {
          ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
          std::__shared_weak_count::__release_weak(v35);
        }
      }

      if (v33) {
        uint64_t v38 = v34;
      }
      else {
        uint64_t v38 = 30LL;
      }
      return [v31 setBleScanRate:v38];
    }

    else
    {
      return [v31 setBleScanRate:sub_1001119DC()];
    }
  }

void sub_1001112D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

id *sub_100111308(id *result)
{
  int v1 = result;
  if (!result[1])
  {
    result[1] = objc_alloc_init(&OBJC_CLASS___CBDiscovery);
    objc_msgSend(v1[1], "setDispatchQueue:", objc_msgSend(objc_msgSend(v1[3], "silo"), "queue"));
    [v1[1] setDiscoveryFlags:0];
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    _DWORD v7[2] = sub_1001114B4;
    v7[3] = &unk_10181F698;
    void v7[4] = v1;
    [v1[1] setDeviceFoundHandler:v7];
    [v1[1] setDeviceLostHandler:&stru_10181F6D8];
    id v2 = v1[1];
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472LL;
    _DWORD v6[2] = sub_1001115A0;
    void v6[3] = &unk_10181F6F8;
    void v6[4] = v1;
    id result = (id *)[v2 activateWithCompletion:v6];
  }

  if (!v1[2])
  {
    id result = (id *)sub_10010FAA4();
    if ((_DWORD)result)
    {
      v1[2] = objc_alloc_init(&OBJC_CLASS___CBDiscovery);
      objc_msgSend(v1[2], "setDispatchQueue:", objc_msgSend(objc_msgSend(v1[3], "silo"), "queue"));
      [v1[2] setDiscoveryFlags:0];
      [v1[2] setUseCase:524290];
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 3221225472LL;
      _DWORD v5[2] = sub_1001116DC;
      void v5[3] = &unk_10181F698;
      v5[4] = v1;
      [v1[2] setDeviceFoundHandler:v5];
      [v1[2] setDeviceLostHandler:&stru_10181F718];
      id v3 = v1[2];
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 3221225472LL;
      _DWORD v4[2] = sub_1001117C8;
      void v4[3] = &unk_10181F6F8;
      v4[4] = v1;
      return (id *)[v3 activateWithCompletion:v4];
    }
  }

  return result;
}

void sub_1001114B4(uint64_t a1, void *a2)
{
}

void sub_1001114BC(id a1, CBDevice *a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F760);
  }
  id v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    v4[0] = 68289282;
    v4[1] = 0;
    __int16 v5 = 2082;
    BOOL v6 = "";
    __int16 v7 = 2114;
    char v8 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Device lost, device::%{public, location:escape_only}@}",  (uint8_t *)v4,  0x1Cu);
  }

void sub_1001115A0(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    [*(id *)(v3 + 8) invalidate];

    *(void *)(v3 + ++*(void *)(result + 8) = 0LL;
    sub_100133F84((uint64_t)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@ %@",  @"CBDiscovery activation error:",  a2));
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F760);
    }
    int v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)__int128 buf = 68289026;
      int v6 = 0;
      __int16 v7 = 2082;
      char v8 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "{msg%{public}.0s:CBDiscovery leeching supported activated successfully}",  buf,  0x12u);
    }
  }

void sub_1001116DC(uint64_t a1, void *a2)
{
}

void sub_1001116E4(id a1, CBDevice *a2)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F760);
  }
  uint64_t v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    v4[0] = 68289282;
    v4[1] = 0;
    __int16 v5 = 2082;
    int v6 = "";
    __int16 v7 = 2114;
    char v8 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Device lost, device::%{public, location:escape_only}@}",  (uint8_t *)v4,  0x1Cu);
  }

void sub_1001117C8(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    [*(id *)(v3 + 16) invalidate];

    *(void *)(v3 + 16) = 0LL;
    sub_100133F84((uint64_t)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@ %@",  @"CBDiscovery activation error:",  a2));
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F760);
    }
    int v4 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289026;
      int v6 = 0;
      __int16 v7 = 2082;
      char v8 = "";
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:CBDiscovery leeching not supported activated successfully}",  buf,  0x12u);
    }
  }

uint64_t sub_100111904()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBleScanFlagRssiIsSet", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A6FD4(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  BOOL v2 = v7;
  uint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v2) {
    return 1LL;
  }
  else {
    return v1 ^ 1u;
  }
}

void sub_1001119C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_1001119DC()
{
  CFStringRef v0 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsBleActiveScanRate", 0x8000100u, kCFAllocatorNull);
  int v1 = sub_1002A7D20(v8, (uint64_t)v0, &v7);
  CFRelease(v0);
  unsigned int v2 = v7;
  uint64_t v3 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  if (v1) {
    return v2;
  }
  else {
    return 40LL;
  }
}

void sub_100111A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

void sub_100111AB4(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

void sub_100111AE0(id a1)
{
  qword_1019348E8 = (uint64_t)os_log_create("com.apple.locationd.Position", "MicrolocationQE");
}

void sub_100111B0C(_BYTE *a1@<X0>, int a2@<W1>, double *a3@<X2>, _BYTE *a4@<X8>)
{
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F7A0);
  }
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v8 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 68289282;
      int v16 = 0;
      __int16 v17 = 2082;
      unint64_t v18 = "";
      __int16 v19 = 1026;
      int v20 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:displayState, isDisplayOn:%{public}hhd}",  buf,  0x18u);
    }
  }

  *a1 = a2;
  sub_1000635D0((uint64_t)v12);
  if (a2) {
    CFStringRef v9 = "BackLightSwitchedOn";
  }
  else {
    CFStringRef v9 = "BackLightSwitchedOff";
  }
  v14 |= 2u;
  char v10 = v13;
  if (v13 == (std::string *)&wireless_diagnostics::google::protobuf::internal::kEmptyString)
  {
    char v10 = (std::string *)operator new(0x18uLL);
    v10->__r_.__value_.__r.__words[0] = 0LL;
    v10->__r_.__value_.__l.__size_ = 0LL;
    v10->__r_.__value_.__l.__cap_ = 0LL;
    id v13 = v10;
  }

  std::string::assign(v10, v9);
  sub_100111D1C((uint64_t)v12, 0, 0, 3u, (uint64_t)v11, *a3);
  buf[0] = a2;
  sub_1000865CC(&v17);
  *a4 = buf[0];
  sub_1000865CC(a4 + 8);
  sub_100086708(&v17);
  sub_100086708(v11);
  sub_1000734A0((wireless_diagnostics::google::protobuf::MessageLite *)v12);
}

void sub_100111CDC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_100111D1C( uint64_t a1@<X0>, char a2@<W1>, char a3@<W2>, unsigned int a4@<W3>, uint64_t a5@<X8>, double a6@<D0>)
{
  unsigned int v12 = *(_DWORD *)(a1 + 16);
  if (!sub_100064160(v12))
  {
    int v14 = "::CLMicroLocationProto::EventType_IsValid(value)";
    int v15 = 19803;
    int v16 = "set_eventtype";
    goto LABEL_6;
  }

  int v13 = *(_DWORD *)(a5 + 128);
  *(_DWORD *)(a5 + 72) = v12;
  *(double *)(a5 + ++*(void *)(result + 8) = a6;
  *(_BYTE *)(a5 + 77) = a2;
  *(_DWORD *)(a5 + 12++*(void *)(result + 8) = v13 | 0x2803;
  *(_BYTE *)(a5 + 76) = a3;
  if ((sub_100064130(a4) & 1) == 0)
  {
    int v14 = "::CLMicroLocationProto::ConfidenceLevel_IsValid(value)";
    int v15 = 20312;
    int v16 = "set_confidencelevel";
LABEL_6:
    __assert_rtn(v16, "microlocation.pb.h", v15, v14);
  }

  *(_DWORD *)(a5 + 128) |= 0x4000u;
  *(_DWORD *)(a5 + 120) = a4;
  sub_100101EA8(a5, a1);
}

void sub_100111E00(_Unwind_Exception *a1)
{
}

uint64_t sub_100111E14(unsigned __int8 *a1)
{
  return *a1;
}

void sub_100111E1C(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_100111E48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = off_10181F7D0;
  *(void *)(a1 + ++*(void *)(result + 8) = a3;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = 0LL;
  uint64_t v5 = a1 + 32;
  int v6 = operator new(0x20uLL);
  void *v6 = &off_10181F860;
  v6[1] = sub_100112BE0;
  _DWORD v6[2] = 0LL;
  void v6[3] = a1;
  uint64_t v30 = v6;
  sub_101023E00(v5, a2, v29);
  unsigned int v7 = v30;
  if (v30 == v29)
  {
    uint64_t v8 = 4LL;
    unsigned int v7 = v29;
    goto LABEL_5;
  }

  if (v30)
  {
    uint64_t v8 = 5LL;
LABEL_5:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }

  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  sub_100AD558C(a1 + 216, (uint64_t)"CLMicroLocationSensors", a1, 60.0);
  *(void *)(a1 + 264) = 0LL;
  *(void *)(a1 + 184) = objc_msgSend(objc_msgSend(*(id *)(a1 + 16), "silo"), "newTimer");
  (*(void (**)(__int128 *__return_ptr))(**(void **)(a1 + 8) + 80LL))(&v27);
  CFStringRef v9 = operator new(0x68uLL);
  uint64_t v10 = *(void *)(a1 + 16);
  __int128 v28 = v27;
  __int128 v27 = 0uLL;
  sub_100C5DE74(v9, v10, &v28);
  int v11 = (std::__shared_weak_count *)*((void *)&v28 + 1);
  if (*((void *)&v28 + 1))
  {
    unsigned int v12 = (unint64_t *)(*((void *)&v28 + 1) + 8LL);
    do
      unint64_t v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }

  sub_100112260((uint64_t *)(a1 + 208), (uint64_t)v9);
  int v14 = (std::__shared_weak_count *)*((void *)&v27 + 1);
  if (*((void *)&v27 + 1))
  {
    int v15 = (unint64_t *)(*((void *)&v27 + 1) + 8LL);
    do
      unint64_t v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  (*(void (**)(__int128 *__return_ptr))(**(void **)(a1 + 8) + 72LL))(&v27);
  __int16 v17 = operator new(0x68uLL);
  uint64_t v18 = *(void *)(a1 + 16);
  __int128 v28 = v27;
  __int128 v27 = 0uLL;
  sub_100C5DE74(v17, v18, &v28);
  __int16 v19 = (std::__shared_weak_count *)*((void *)&v28 + 1);
  if (*((void *)&v28 + 1))
  {
    int v20 = (unint64_t *)(*((void *)&v28 + 1) + 8LL);
    do
      unint64_t v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }

  sub_100112260((uint64_t *)(a1 + 200), (uint64_t)v17);
  uint64_t v22 = (std::__shared_weak_count *)*((void *)&v27 + 1);
  if (*((void *)&v27 + 1))
  {
    char v23 = (unint64_t *)(*((void *)&v27 + 1) + 8LL);
    do
      unint64_t v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
  }

  *(void *)(a1 + 192) = 0x7FEFFFFFFFFFFFFFLL;
  id v25 = objc_msgSend(objc_msgSend(*(id *)(a1 + 16), "vendor"), "proxyForService:", @"CLWifiService");
  *(void *)(a1 + 24) = v25;
  [v25 setDelegateEntityName:"CLMicroLocationSensorDriver"];
  return a1;
}

void sub_100112114( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_1001121C0(uint64_t a1)
{
  *(void *)a1 = off_10181F7D0;
  [*(id *)(a1 + 184) invalidate];

  *(void *)(a1 + 184) = 0LL;
  sub_100112260((uint64_t *)(a1 + 208), 0LL);
  sub_100112260((uint64_t *)(a1 + 200), 0LL);

  *(void *)(a1 + 24) = 0LL;
  sub_100AD5650(a1 + 216);
  sub_100112260((uint64_t *)(a1 + 208), 0LL);
  sub_100112260((uint64_t *)(a1 + 200), 0LL);
  sub_1010240A0(a1 + 32);
  return a1;
}

void sub_100112260(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    int v4 = (void *)sub_100C5E104();
    operator delete(v4);
  }

void sub_100112290(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1001121C0(a1);
  operator delete(v1);
}

void sub_1001122A4(uint64_t a1, int a2)
{
  uint64_t v4 = a1 + 32;
  if ((sub_101024128(a1 + 32) & 1) != 0)
  {
    *(_DWORD *)__int128 buf = 3;
    sub_1010240A4(v4, (unsigned int *)buf);
    *(_DWORD *)__int128 buf = 4;
    sub_1010240A4(v4, (unsigned int *)buf);
    *(_DWORD *)__int128 buf = 5;
    sub_1010240A4(v4, (unsigned int *)buf);
    uint64_t v5 = sub_100112490(a1, a2);
    sub_100C5E108(v5);
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F830);
    }
    int v6 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "WifiBridge, Wifi is powered off - not scanning",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F830);
      }
      v8[0] = 0;
      unsigned int v7 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  2LL,  "WifiBridge, Wifi is powered off - not scanning",  v8,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationWifiBridge::startWifiRssiScanning(CLMicroLocationUtils::ScanActivity)",  "%s\n",  v7);
    }
  }

uint64_t sub_100112490(uint64_t result, int a2)
{
  uint64_t v2 = result;
  switch(a2)
  {
    case 1:
      (*(void (**)(void))(**(void **)(result + 8) + 64LL))(*(void *)(result + 8));
      uint64_t v3 = v2 + 200;
      return *(void *)v3;
    case 2:
      (*(void (**)(void))(**(void **)(result + 8) + 64LL))(*(void *)(result + 8));
      uint64_t v3 = v2 + 208;
      return *(void *)v3;
    case 0:
      sub_10122C39C();
  }

  return result;
}

uint64_t sub_1001124F4(uint64_t a1, int a2)
{
  uint64_t v4 = sub_100112490(a1, a2);
  sub_100C5DF04(v4);
  *(_DWORD *)__int128 buf = 3;
  sub_1010240E8(a1 + 32, (int *)buf);
  *(_DWORD *)__int128 buf = 4;
  sub_1010240E8(a1 + 32, (int *)buf);
  *(_DWORD *)__int128 buf = 5;
  sub_1010240E8(a1 + 32, (int *)buf);
  [*(id *)(a1 + 184) invalidate];
  *(void *)(a1 + 192) = 0x7FEFFFFFFFFFFFFFLL;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F830);
  }
  uint64_t v5 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "WifiBridge, wifi, stop scanning", buf, 2u);
  }

  if (sub_1002921D0(115, 2))
  {
    bzero(buf, 0x65CuLL);
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F830);
    }
    v11[0] = 0;
    uint64_t v10 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "WifiBridge, wifi, stop scanning",  v11,  2);
    sub_10029211C( "Generic",  1LL,  0,  2LL,  "virtual void CLMicroLocationWifiBridge::stopWifiRssiScanning(CLMicroLocationUtils::ScanActivity)",  "%s\n",  v10);
  }

  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  double v7 = *(double *)(a1 + 264);
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F830);
  }
  uint64_t v8 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 68289538;
    int v13 = 0;
    __int16 v14 = 2082;
    int v15 = "";
    __int16 v16 = 2050;
    double v17 = Current_1 - v7;
    __int16 v18 = 1026;
    int v19 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:WifiBridge, scan complete, scanDurationInMs:%{public}.4f, scanActivity:%{public}d}",  buf,  0x22u);
  }

  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48LL))(*(void *)(a1 + 8));
}

id sub_1001127C0(uint64_t a1, uint64_t a2)
{
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  *(double *)(a1 + 192) = (Current_1 * 1000.0 + (double)a2) / 1000.0;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F830);
  }
  uint64_t v5 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v6 = *(void *)(a1 + 192);
    *(_DWORD *)__int128 buf = 68289794;
    int v13 = 0;
    __int16 v14 = 2082;
    int v15 = "";
    __int16 v16 = 2050;
    double v17 = Current_1;
    __int16 v18 = 2050;
    uint64_t v19 = a2;
    __int16 v20 = 2050;
    uint64_t v21 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:WifiBridge, RecordingStarted, now:%{public}.3f, durationInMs:%{public}lld,  expected end time:%{public}.3f}",  buf,  0x30u);
  }

  double v7 = *(void **)(a1 + 184);
  *(double *)(a1 + 264) = Current_1;
  [v7 setNextFireTime:*(double *)(a1 + 192)];
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  void v9[2] = sub_100112998;
  void v9[3] = &unk_10181D3D0;
  void v9[4] = a1;
  return [*(id *)(a1 + 184) setHandler:v9];
}

void sub_100112974( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100112998(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48LL))(*(void *)(a1 + 32));
}

id sub_1001129A8(uint64_t a1, uint64_t a2)
{
  double v2 = *(double *)(a1 + 192);
  if (v2 == 1.79769313e308) {
    sub_10122C508();
  }
  *(double *)(a1 + 192) = (v2 * 1000.0 + (double)a2) / 1000.0;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F830);
  }
  uint64_t v5 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    v7[0] = 68289282;
    v7[1] = 0;
    __int16 v8 = 2082;
    CFStringRef v9 = "";
    __int16 v10 = 2050;
    uint64_t v11 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:WifiBridge, RecordingExtended, by durationInMs:%{public}lld}",  (uint8_t *)v7,  0x1Cu);
  }

  return [*(id *)(a1 + 184) setNextFireTime:*(double *)(a1 + 192)];
}

uint64_t sub_100112AD8(uint64_t a1)
{
  double Current_1 = j__CFAbsoluteTimeGetCurrent_1();
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F830);
  }
  uint64_t v3 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
  {
    v5[0] = 68289282;
    v5[1] = 0;
    __int16 v6 = 2082;
    double v7 = "";
    __int16 v8 = 2050;
    double v9 = Current_1;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:WifiBridge, wifi scan timer stopped, now:%{public}.3f}",  (uint8_t *)v5,  0x1Cu);
  }

  return (*(uint64_t (**)(void, double))(**(void **)(a1 + 8) + 56LL))(*(void *)(a1 + 8), Current_1);
}

void sub_100112BE0(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  if (sub_1002958AC() == 1)
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F830);
    }
    double v7 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *a3;
      int v9 = *(char *)(a4 + 1);
      *(_DWORD *)__int128 buf = 67240448;
      *(_DWORD *)&uint8_t buf[4] = v8;
      *(_WORD *)unsigned int v34 = 1026;
      *(_DWORD *)&v34[2] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "WifiBridge, Received wifi notification %{public}d with scan type %{public}d",  buf,  0xEu);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F830);
      }
      int v24 = *a3;
      int v25 = *(char *)(a4 + 1);
      LODWORD(__p.__r_.__value_.__l.__data_) = 67240448;
      HIDWORD(__p.__r_.__value_.__r.__words[0]) = v24;
      LOWORD(__p.__r_.__value_.__r.__words[1]) = 1026;
      *(_DWORD *)((char *)&__p.__r_.__value_.__r.__words[1] + 2) = v25;
      char v26 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "WifiBridge, Received wifi notification %{public}d with scan type %{public}d",  &__p,  14);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationWifiBridge::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiSe rvice_Type::NotificationData &)",  "%s\n",  v26);
    }

    switch(*a3)
    {
      case 3:
        if (*(_BYTE *)(a4 + 1) == 11)
        {
          sub_100022AC8((uint64_t *)(a4 + 112), (uint64_t *)&__p);
          uint64_t v28 = 0LL;
          unint64_t v29 = 0LL;
          unint64_t v30 = 0LL;
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
          for (uint64_t i = (int *)__p.__r_.__value_.__r.__words[0]; i != (int *)size; i += 22)
          {
            sub_1001013D0(i, (uint64_t)buf);
            if (v38)
            {
              int v12 = i[17];
              int v31 = v12;
              unint64_t v13 = v29;
              if (v29 >= v30)
              {
                uint64_t v14 = sub_1001134F4(&v28, (uint64_t)buf, &v31);
              }

              else
              {
                sub_100113618(v29, (uint64_t)buf, v12);
                uint64_t v14 = v13 + 56;
              }

              unint64_t v29 = v14;
              if (v38) {
                sub_100064FE0((wireless_diagnostics::google::protobuf::MessageLite *)buf);
              }
            }
          }

          (*(void (**)(void, uint64_t *, double))(**(void **)(a1 + 8) + 16LL))( *(void *)(a1 + 8),  &v28,  *(double *)(a4 + 104));
          *(void *)__int128 buf = &v28;
          sub_10010DB70((void ***)buf);
          *(void *)__int128 buf = &__p;
          sub_100023498((void ***)buf);
        }

        else
        {
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181F830);
          }
          char v23 = (os_log_s *)qword_1019348D8;
          if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_INFO,  "WifiBridge, Received a wifi scan result that is not requested by MiLo, ignore this scan result",  buf,  2u);
          }

          if (sub_1002921D0(115, 2))
          {
            bzero(buf, 0x65CuLL);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181F830);
            }
            LOWORD(__p.__r_.__value_.__l.__data_) = 0;
            LODWORD(v27) = 2;
            uint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  1LL,  "WifiBridge, Received a wifi scan result that is not requested by MiLo, ignore this scan result",  &__p,  v27);
            sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationWifiBridge::onWifiNotification(int, const CLWifiService_Type::Notification &, const CL WifiService_Type::NotificationData &)",  "%s\n",  v19);
            goto LABEL_61;
          }
        }

        break;
      case 4:
        (*(void (**)(void))(**(void **)(a1 + 8) + 32LL))(*(void *)(a1 + 8));
        break;
      case 5:
        (*(void (**)(void))(**(void **)(a1 + 8) + 40LL))(*(void *)(a1 + 8));
        break;
      case 6:
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F830);
        }
        __int16 v20 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
        {
          sub_10099EA10(a4 + 8, &__p);
          uint64_t v21 = (__p.__r_.__value_.__s.__size_ & 0x80u) == 0
              ? &__p
              : (std::stringbuf::string_type *)__p.__r_.__value_.__r.__words[0];
          *(_DWORD *)__int128 buf = 68289283;
          *(_DWORD *)&uint8_t buf[4] = 0;
          *(_WORD *)unsigned int v34 = 2082;
          *(void *)&v34[2] = "";
          __int16 v35 = 2081;
          id v36 = v21;
          _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:Received link status notification, associatedState:%{private, location:escape_only}s}",  buf,  0x1Cu);
        }

        uint64_t v22 = *(void *)(a1 + 8);
        sub_10099F24C(a4 + 8, (uint64_t)buf);
        (*(void (**)(uint64_t, uint8_t *))(*(void *)v22 + 24LL))(v22, buf);
        if (v39 && v37 < 0) {
          operator delete(*(void **)v34);
        }
        break;
      default:
        if (qword_1019348D0 != -1) {
          dispatch_once(&qword_1019348D0, &stru_10181F830);
        }
        __int16 v16 = (os_log_s *)qword_1019348D8;
        if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
        {
          int v17 = *a3;
          *(_DWORD *)__int128 buf = 67240192;
          *(_DWORD *)&uint8_t buf[4] = v17;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "#Warning WifiBridge, Received unknown wifi service notification %{public}d",  buf,  8u);
        }

        if (sub_1002921D0(115, 2))
        {
          bzero(buf, 0x65CuLL);
          if (qword_1019348D0 != -1) {
            dispatch_once(&qword_1019348D0, &stru_10181F830);
          }
          int v18 = *a3;
          LODWORD(__p.__r_.__value_.__l.__data_) = 67240192;
          HIDWORD(__p.__r_.__value_.__r.__words[0]) = v18;
          LODWORD(v27) = 8;
          uint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "#Warning WifiBridge, Received unknown wifi service notification %{public}d",  &__p,  v27);
          sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationWifiBridge::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWi fiService_Type::NotificationData &)",  "%s\n",  v19);
          goto LABEL_61;
        }

        break;
    }
  }

  else
  {
    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F830);
    }
    int v15 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "WifiBridge, Location services are disabled, ignore WiFi scan result",  buf,  2u);
    }

    if (sub_1002921D0(115, 2))
    {
      bzero(buf, 0x65CuLL);
      if (qword_1019348D0 != -1) {
        dispatch_once(&qword_1019348D0, &stru_10181F830);
      }
      LOWORD(__p.__r_.__value_.__l.__data_) = 0;
      uint64_t v19 = (char *)_os_log_send_and_compose_impl( 2LL,  0LL,  buf,  1628LL,  &_mh_execute_header,  qword_1019348D8,  0LL,  "WifiBridge, Location services are disabled, ignore WiFi scan result",  &__p,  2);
      sub_10029211C( "Generic",  1LL,  0,  2LL,  "void CLMicroLocationWifiBridge::onWifiNotification(int, const CLWifiService_Type::Notification &, const CLWifiSe rvice_Type::NotificationData &)",  "%s\n",  v19);
LABEL_61:
    }
  }

void sub_100113364( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char *a11, uint64_t a12, uint64_t a13, uint64_t *a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, uint64_t a26, uint64_t a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
  a14 = (uint64_t *)&a11;
  sub_10010DB70((void ***)&a14);
  a11 = &a15;
  sub_100023498((void ***)&a11);
  _Unwind_Resume(a1);
}

void sub_1001133F0(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

__n128 sub_10011341C(uint64_t a1)
{
  double v2 = (char *)operator new(0x20uLL);
  *(void *)double v2 = &off_10181F860;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + ++*(void *)(result + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_100113460(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_10181F860;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + ++*(void *)(result + 8) = result;
  return result;
}

uint64_t sub_10011348C(void *a1, unsigned int *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = (uint64_t (*)(void *, void))a1[1];
  uint64_t v4 = (void *)(a1[3] + (v2 >> 1));
  if ((v2 & 1) != 0) {
    uint64_t v3 = *(uint64_t (**)(void *, void))(*v4 + v3);
  }
  return v3(v4, *a2);
}

uint64_t sub_1001134AC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_1001134E8()
{
}

uint64_t sub_1001134F4(uint64_t *a1, uint64_t a2, int *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = 0x6DB6DB6DB6DB6DB7LL * ((a1[2] - v4) >> 3);
  if (2 * v10 > v6) {
    unint64_t v6 = 2 * v10;
  }
  if (v10 >= 0x249249249249249LL) {
    unint64_t v11 = 0x492492492492492LL;
  }
  else {
    unint64_t v11 = v6;
  }
  uint64_t v19 = a1 + 2;
  if (v11) {
    int v12 = (char *)sub_1000AC8F0(v9, v11);
  }
  else {
    int v12 = 0LL;
  }
  int v15 = v12;
  __int16 v16 = &v12[56 * v5];
  uint64_t v17 = (uint64_t)v16;
  int v18 = &v12[56 * v11];
  sub_100113618((uint64_t)v16, a2, *a3);
  uint64_t v17 = (uint64_t)(v16 + 56);
  sub_10011366C(a1, &v15);
  uint64_t v13 = a1[1];
  sub_100113784((uint64_t)&v15);
  return v13;
}

void sub_100113604(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100113618(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = sub_1000632D4(a1);
  *(_DWORD *)(v6 + sub_10000AE14(v17 - 48) = a3;
  sub_100065560(v6, a2);
  return a1;
}

void sub_100113658(_Unwind_Exception *a1)
{
}

uint64_t sub_10011366C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1001136E0((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1001136E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0LL;
    do
    {
      sub_100064FDC(a7 + v11 - 56, a3 + v11 - 56);
      *(_DWORD *)(a7 + v11 - ++*(void *)(result + 8) = *(_DWORD *)(a3 + v11 - 8);
      v11 -= 56LL;
    }

    while (a3 + v11 != a5);
  }

  return a6;
}

void sub_100113764(_Unwind_Exception *exception_object)
{
  for (; v2; v2 += 56LL)
    sub_100064FE0((wireless_diagnostics::google::protobuf::MessageLite *)(v1 + v2));
  _Unwind_Resume(exception_object);
}

uint64_t sub_100113784(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 56;
    sub_100064FE0((wireless_diagnostics::google::protobuf::MessageLite *)(i - 56));
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1001137D0(uint64_t result, double a2)
{
  *(_OWORD *)uint64_t result = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(double *)(result + 32) = a2;
  return result;
}

void sub_1001137E0(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if (*a2 == v6)
  {
    uint64_t v28 = 0LL;
    uint64_t v7 = 0LL;
  }

  else
  {
    uint64_t v7 = 0LL;
    uint64_t v28 = 0LL;
    do
    {
      sub_100064FDC(v30, v5);
      double v8 = *(double *)&v31[4];
      if (*(double *)&v31[4] >= *(double *)(a1 + 24))
      {
        uint64_t v9 = *(void *)a1;
        uint64_t v10 = *(void *)(a1 + 8);
        while (v9 != v10)
        {
          uint64_t v11 = (wireless_diagnostics::google::protobuf::MessageLite *)sub_100064FDC(&v39, v9);
          if (v41 == v32)
          {
            double v12 = *(double *)&v40[4] - v8;
            if (v12 < *(double *)(a1 + 32))
            {
              if (v42[0] == v33[0]
                && *(float *)&v40[16] == *(float *)&v31[16]
                && *(_DWORD *)(v9 + 48) == *(_DWORD *)(v5 + 48))
              {
                ++v28;
                sub_100064FE0(v11);
                goto LABEL_29;
              }

              if (qword_1019348D0 != -1) {
                dispatch_once(&qword_1019348D0, &stru_10181F8F8);
              }
              uint64_t v13 = (os_log_s *)qword_1019348D8;
              if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
              {
                nullsub_10(v32);
                sub_1007EC454(&__p);
                p_p = &__p;
                if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                }
                uint64_t buf = 68289282LL;
                __int16 v35 = 2082;
                id v36 = "";
                __int16 v37 = 2082;
                char v38 = p_p;
                _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:#Warning AP matches timestamp and mac in buffer, but values are not same, m ac address:%{public, location:escape_only}s}",  (uint8_t *)&buf,  0x1Cu);
              }
            }
          }

          sub_100064FE0((wireless_diagnostics::google::protobuf::MessageLite *)&v39);
          v9 += 56LL;
        }

        int v15 = (int *)(v5 + 48);
        unint64_t v16 = a3[1];
        if (v16 >= a3[2])
        {
          uint64_t v18 = sub_100114210(a3, (uint64_t)v30, (int *)(v5 + 48));
        }

        else
        {
          int v17 = *v15;
          sub_100064FDC(a3[1], v30);
          *(_DWORD *)(v16 + sub_10000AE14(v17 - 48) = v17;
          uint64_t v18 = v16 + 56;
          a3[1] = v16 + 56;
        }

        a3[1] = v18;
        unint64_t v19 = *(void *)(a1 + 8);
        if (v19 >= *(void *)(a1 + 16))
        {
          uint64_t v21 = sub_100114210((uint64_t *)a1, (uint64_t)v30, (int *)(v5 + 48));
        }

        else
        {
          int v20 = *v15;
          sub_100064FDC(*(void *)(a1 + 8), v30);
          *(_DWORD *)(v19 + sub_10000AE14(v17 - 48) = v20;
          uint64_t v21 = v19 + 56;
          *(void *)(a1 + ++*(void *)(result + 8) = v19 + 56;
        }

        *(void *)(a1 + ++*(void *)(result + 8) = v21;
      }

      else
      {
        ++v7;
      }

void sub_100113CA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100113CFC(uint64_t a1@<X0>, uint64_t *a2@<X8>, double a3@<D0>, double a4@<D1>)
{
  *(double *)(a1 + 24) = a3 - a4;
  a2[1] = 0LL;
  a2[2] = 0LL;
  *a2 = 0LL;
  sub_100114028(a2, 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3));
  uint64_t v6 = *(void *)a1;
  uint64_t v7 = *(void *)(a1 + 8);
  if (*(void *)a1 == v7)
  {
    uint64_t v7 = *(void *)a1;
  }

  else
  {
    double v8 = *(double *)(a1 + 24);
    while (*(double *)(v6 + 8) >= v8)
    {
      v6 += 56LL;
      if (v6 == v7)
      {
        uint64_t v6 = *(void *)(a1 + 8);
        goto LABEL_13;
      }
    }

    if (v6 != v7)
    {
      uint64_t v9 = v6 + 56;
      if (v6 + 56 != v7)
      {
        do
        {
          if (*(double *)(v9 + 8) >= v8)
          {
            sub_100065518(v6, v9);
            *(_DWORD *)(v6 + sub_10000AE14(v17 - 48) = *(_DWORD *)(v9 + 48);
            v6 += 56LL;
          }

          v9 += 56LL;
        }

        while (v9 != v7);
        uint64_t v7 = *(void *)(a1 + 8);
      }
    }
  }

void sub_100114000( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_100114028(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0x6DB6DB6DB6DB6DB7LL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0x492492492492493LL) {
      sub_100007008();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = sub_1000AC8F0(result, a2);
    v7[1] = v7[0] + v5;
    _DWORD v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 56 * v6;
    sub_10011366C(a1, v7);
    return sub_100113784((uint64_t)v7);
  }

  return result;
}

void sub_1001140D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1001140E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    sub_100114548(a3, *(void *)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
        sub_100064FE0((wireless_diagnostics::google::protobuf::MessageLite *)(v7 - 56));
      while (v7 != v6);
    }

    *(void *)(a1 + ++*(void *)(result + 8) = v6;
  }

  return a2;
}

uint64_t sub_100114150(uint64_t *a1)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  uint64_t v6 = (uint64_t *)&v7;
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  if (*a1 == v2)
  {
    uint64_t v3 = 0LL;
    uint64_t v4 = 0LL;
  }

  else
  {
    do
    {
      uint64_t v9 = *(void *)(v1 + 24);
      sub_1001145B0(&v6, (unint64_t *)&v9, &v9);
      v1 += 56LL;
    }

    while (v1 != v2);
    uint64_t v3 = v7;
    uint64_t v4 = v8;
  }

  sub_100008390((uint64_t)&v6, v3);
  return v4;
}

void sub_1001141CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void sub_1001141E4(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_100114210(uint64_t *a1, uint64_t a2, int *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = 0x6DB6DB6DB6DB6DB7LL * ((a1[2] - v4) >> 3);
  if (2 * v10 > v6) {
    unint64_t v6 = 2 * v10;
  }
  if (v10 >= 0x249249249249249LL) {
    unint64_t v11 = 0x492492492492492LL;
  }
  else {
    unint64_t v11 = v6;
  }
  int v20 = a1 + 2;
  if (v11) {
    uint64_t v12 = (char *)sub_1000AC8F0(v9, v11);
  }
  else {
    uint64_t v12 = 0LL;
  }
  int v16 = v12;
  uint64_t v17 = &v12[56 * v5];
  __int16 v18 = v17;
  uint64_t v19 = &v12[56 * v11];
  int v13 = *a3;
  sub_100064FDC(v17, a2);
  *((_DWORD *)v17 + 12) = v13;
  v18 += 56;
  sub_10011366C(a1, &v16);
  uint64_t v14 = a1[1];
  sub_100113784((uint64_t)&v16);
  return v14;
}

void sub_100114334(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100114348(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = a1;
  unint64_t v6 = a3;
  if (a1 == a2) {
    return a1;
  }
  uint64_t v4 = a2;
  do
  {
    sub_1001143A8(&v6, v3);
    v3 += 56LL;
  }

  while (v3 != v4);
  return v4;
}

uint64_t **sub_1001143A8(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = (*a1)[1];
  if (v5 >= (*a1)[2])
  {
    uint64_t v6 = sub_10011441C(*a1, a2);
  }

  else
  {
    sub_100064FDC((*a1)[1], a2);
    *(_DWORD *)(v5 + sub_10000AE14(v17 - 48) = *(_DWORD *)(a2 + 48);
    uint64_t v6 = v5 + 56;
    v4[1] = v5 + 56;
  }

  v4[1] = v6;
  return a1;
}

void sub_100114414(_Unwind_Exception *a1)
{
  *(void *)(v1 + ++*(void *)(result + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_10011441C(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7LL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7LL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x249249249249249LL) {
    unint64_t v9 = 0x492492492492492LL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)sub_1000AC8F0(v7, v9);
  }
  else {
    unint64_t v10 = 0LL;
  }
  int v13 = v10;
  uint64_t v14 = &v10[56 * v4];
  int v15 = v14;
  int v16 = &v10[56 * v9];
  sub_100064FDC(v14, a2);
  *((_DWORD *)v14 + 12) = *(_DWORD *)(a2 + 48);
  v15 += 56;
  sub_10011366C(a1, &v13);
  uint64_t v11 = a1[1];
  sub_100113784((uint64_t)&v13);
  return v11;
}

void sub_100114534(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100114548(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  uint64_t v5 = a2;
  do
  {
    sub_100065518(a3, v4);
    *(_DWORD *)(a3 + sub_10000AE14(v17 - 48) = *(_DWORD *)(v4 + 48);
    a3 += 56LL;
    v4 += 56LL;
  }

  while (v4 != v5);
  return v5;
}

uint64_t *sub_1001145B0(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    unint64_t v8 = a1 + 1;
LABEL_10:
    unint64_t v10 = (uint64_t *)operator new(0x28uLL);
    void v10[4] = *a3;
    sub_1000085FC(a1, (uint64_t)v8, v6, v10);
    return v10;
  }

  return (uint64_t *)v8;
}

uint64_t sub_100114668@<X0>( void *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, char **a5@<X8>)
{
  if (!sub_100097CA8((uint64_t)a1))
  {
    sub_10122C7E0();
    goto LABEL_66;
  }

  if (!*(_BYTE *)(a3 + 32))
  {
    sub_10122C674();
LABEL_66:
    __break(1u);
  }

  __int128 v74 = 0u;
  __int128 v75 = 0u;
  int v76 = 1065353216;
  unint64_t v10 = (void *)a1[29];
  for (uint64_t i = (void *)a1[30]; v10 != i; v10 += 4)
  {
    *(void *)uint64_t buf = v10 + 2;
    uint64_t v12 = (uint64_t **)sub_1001150BC((uint64_t)&v74, v10 + 2, (uint64_t)&unk_1012CF090, (_OWORD **)buf);
    uint64_t v13 = *(void *)(a3 + 24);
    if (!v13) {
      sub_100008BDC();
    }
    *(void *)uint64_t buf = (*(double (**)(uint64_t, void, uint64_t))(*(void *)v13 + 48LL))(v13, *v10, a2);
    sub_1000F0468(v12 + 4, (double *)buf);
  }

  sub_10009773C(a1, (uint64_t)v72);
  int v14 = *(_DWORD *)(a2 + 160);
  *a5 = 0LL;
  a5[1] = 0LL;
  a5[2] = 0LL;
  *((_DWORD *)a5 + 6) = 3;
  *((_BYTE *)a5 + 80) = 0;
  a5[5] = 0LL;
  a5[6] = 0LL;
  a5[4] = 0LL;
  *((_BYTE *)a5 + 56) = 0;
  int v15 = (char *)sub_10000835C((uint64_t)(a5 + 2), 1uLL);
  uint64_t v17 = &v15[32 * v16];
  *(void *)int v15 = 0LL;
  *((void *)v15 + 1) = 0LL;
  *((void *)v15 + 2) = 0LL;
  int v61 = v14;
  *((_DWORD *)v15 + 6) = v14;
  __int16 v18 = v15 + 32;
  int v20 = *a5;
  uint64_t v19 = a5[1];
  if (v19 != *a5)
  {
    do
    {
      __int128 v21 = *((_OWORD *)v19 - 2);
      *(_OWORD *)(v15 - 20) = *(_OWORD *)(v19 - 20);
      *((_OWORD *)v15 - 2) = v21;
      v15 -= 32;
      v19 -= 32;
    }

    while (v19 != v20);
    uint64_t v19 = *a5;
  }

  *a5 = v15;
  a5[1] = v18;
  a5[2] = v17;
  if (v19) {
    operator delete(v19);
  }
  a5[1] = v18;
  sub_100114D1C((uint64_t)v15, a4);
  uint64_t v23 = v73;
  if (v73)
  {
    double v24 = v22;
    do
    {
      if ((v23[2] & v23[3]) != -1LL)
      {
        memset(v70, 0, sizeof(v70));
        int v71 = 1065353216;
        for (unsigned int j = (uint64_t *)v75; j; unsigned int j = (uint64_t *)*j)
        {
          if (j[2] == v23[2] && j[3] == v23[3])
          {
            *(void *)uint64_t buf = j + 2;
            uint64_t v28 = (uint64_t **)sub_1001150BC((uint64_t)v70, j + 2, (uint64_t)&unk_1012CF090, (_OWORD **)buf);
          }

          else
          {
            *(void *)uint64_t buf = qword_1012CEF30;
            uint64_t v27 = (char *)sub_1001150BC((uint64_t)v70, qword_1012CEF30, (uint64_t)&unk_1012CF090, (_OWORD **)buf);
            sub_1000F0AA0(v27 + 32, (void *)j[4], j + 5);
          }
        }

        sub_100114D6C((uint64_t)v70, a4, (uint64_t)v68);
        __int128 v65 = 0u;
        __int128 v66 = 0u;
        int v67 = 1065353216;
        sub_10000C75C(a4, buf);
        sub_1000410B8((uint64_t)buf, &v64);
        sub_1002A5554(buf);
        for (k = v69; k; k = *(double **)k)
        {
          double v30 = (*(double (**)(double *, double))(*(void *)v64 + 24LL))(v64, k[4]);
          if (v30 >= 0.0)
          {
            *(void *)uint64_t buf = k + 2;
            *((double *)sub_10005C6F8((uint64_t)&v65, (void *)k + 2, (uint64_t)&unk_1012CF090, (_OWORD **)buf) + 4) = v30 / (1.0 - v30);
            if (qword_1019348D0 != -1) {
              dispatch_once(&qword_1019348D0, &stru_10181F958);
            }
            int v31 = (os_log_s *)qword_1019348D8;
            if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v32 = operator new(0x28uLL);
              std::string __p = v32;
              __int128 v63 = xmmword_1012C8460;
              _OWORD *v32 = 0u;
              v32[1] = 0u;
              *(void *)((char *)v32 + 29) = 0LL;
              sub_10000AE6C((uint64_t)(k + 2), v32);
              p_p = &__p;
              if (v63 < 0) {
                p_p = __p;
              }
              uint64_t v35 = *((void *)k + 4);
              uint64_t v34 = *((void *)k + 5);
              *(void *)uint64_t buf = 68290051LL;
              __int16 v78 = 2082;
              uint64_t v79 = "";
              __int16 v80 = 2081;
              uint64_t v81 = p_p;
              __int16 v82 = 2049;
              uint64_t v83 = v34;
              __int16 v84 = 2049;
              double v85 = v30;
              __int16 v86 = 2049;
              uint64_t v87 = v35;
              _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:nullspace, identifier:%{private, location:escape_only}s, weight:%{pri vate}f, phat:%{private}f, reducedDistance:%{private}f}",  buf,  0x3Au);
              if (SHIBYTE(v63) < 0) {
                operator delete(__p);
              }
            }
          }
        }

        id v36 = (double *)v66;
        if ((void)v66)
        {
          double v37 = 1.0;
          char v38 = (double *)v66;
          do
          {
            double v37 = v37 + v38[4];
            char v38 = *(double **)v38;
          }

          while (v38);
          double v39 = 1.0 / v37;
          do
          {
            if (*((void *)v36 + 2) == v23[2] && *((void *)v36 + 3) == v23[3])
            {
              uint64_t v42 = *((void *)v36 + 2);
              uint64_t v41 = *((void *)v36 + 3);
              double v43 = pow(v39 * v36[4], v24);
              double v44 = v43;
              unsigned int v45 = a5[1];
              signed __int8 v46 = a5[2];
              if (v45 >= v46)
              {
                uint64_t v48 = (v45 - *a5) >> 5;
                unint64_t v49 = v48 + 1;
                uint64_t v50 = v46 - *a5;
                if (v50 >> 4 > v49) {
                  unint64_t v49 = v50 >> 4;
                }
                else {
                  unint64_t v51 = v49;
                }
                double v52 = (char *)sub_10000835C((uint64_t)(a5 + 2), v51);
                __int16 v54 = &v52[32 * v48];
                *(void *)__int16 v54 = v42;
                *((void *)v54 + 1) = v41;
                *((double *)v54 + 2) = v44;
                *((_DWORD *)v54 + 6) = v61;
                __int16 v56 = *a5;
                double v55 = a5[1];
                CFAbsoluteTime v57 = v54;
                if (v55 != *a5)
                {
                  do
                  {
                    __int128 v58 = *((_OWORD *)v55 - 2);
                    *(_OWORD *)(v57 - 20) = *(_OWORD *)(v55 - 20);
                    *((_OWORD *)v57 - 2) = v58;
                    v57 -= 32;
                    v55 -= 32;
                  }

                  while (v55 != v56);
                  double v55 = *a5;
                }

                char v47 = v54 + 32;
                *a5 = v57;
                a5[1] = v54 + 32;
                a5[2] = &v52[32 * v53];
                if (v55) {
                  operator delete(v55);
                }
              }

              else
              {
                *(void *)unsigned int v45 = v42;
                *((void *)v45 + 1) = v41;
                *((double *)v45 + 2) = v43;
                char v47 = v45 + 32;
                *((_DWORD *)v45 + 6) = v61;
              }

              a5[1] = v47;
            }

            id v36 = *(double **)v36;
          }

          while (v36);
        }

        unsigned __int8 v59 = v64;
        CFAbsoluteTime v64 = 0LL;
        if (v59) {
          (*(void (**)(double *))(*(void *)v59 + 8LL))(v59);
        }
        sub_100019CEC((uint64_t)&v65);
        sub_100019CEC((uint64_t)v68);
        sub_100115044((uint64_t)v70);
      }

      uint64_t v23 = (void *)*v23;
    }

    while (v23);
  }

  sub_100019CEC((uint64_t)v72);
  return sub_100115044((uint64_t)&v74);
}

void sub_100114C5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, char a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41)
{
}

void sub_100114D1C(uint64_t a1, uint64_t a2)
{
  double v2 = COERCE_DOUBLE(sub_10000C79C(a2));
  if (v4)
  {
    v3.n128_f64[0] = v2;
    if (v2 > 0.0 && v2 < 1.0)
    {
      log(v2);
    }

    else
    {
      uint64_t v6 = sub_10122C94C(v3);
      sub_100114D6C(v6);
    }
  }

uint64_t *sub_100114D6C@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if (v6)
  {
    int v7 = 0;
    do
    {
      v7 += *((_DWORD *)v6 + 12);
      uint64_t v6 = (uint64_t *)*v6;
    }

    while (v6);
  }

  else
  {
    int v7 = 0;
  }

  uint64_t v8 = nullsub_10(a2);
  unint64_t v9 = *(uint64_t **)(v8 + 8);
  if (v9)
  {
    uint64_t v3 = v8;
    unint64_t v10 = *(uint64_t **)(v8 + 8);
    do
    {
      int v11 = *((_DWORD *)v10 + 8);
      if (v11 <= 2)
      {
        if (v11 == 2) {
          goto LABEL_15;
        }
        ++v10;
      }

      unint64_t v10 = (uint64_t *)*v10;
    }

    while (v10);
  }

  uint64_t v8 = sub_10122CAB0();
  do
  {
    ++v9;
    do
    {
      unint64_t v9 = (uint64_t *)*v9;
      if (!v9)
      {
        double v22 = (_Unwind_Exception *)sub_10122CC1C(v8);
        sub_100019CEC(a3);
        _Unwind_Resume(v22);
      }

void **sub_100114EF8(void **result, double a2)
{
  double v2 = result[2];
  if (!v2) {
    sub_10122CD88();
  }
  if (a2 < 0.0 || a2 > 1.0) {
    sub_10122CDB0();
  }
  BOOL v4 = a2 == 0.0 || v2 == (void *)1;
  if (!v4)
  {
    if (a2 == 1.0)
    {
      uint64_t v6 = result[1];
      ++result;
      uint64_t v5 = v6;
      if (v6)
      {
        do
          uint64_t v5 = (void *)v5[1];
        while (v5);
      }

      else
      {
        do
        {
          BOOL v4 = *result[2] == (void)result;
          uint64_t result = (void **)result[2];
        }

        while (v4);
      }
    }

    else
    {
      double v7 = (double)((unint64_t)v2 - 1);
      double v8 = v7 * a2;
      if (v8 < 0.0) {
        double v8 = 0.0;
      }
      if (v8 <= v7) {
        double v9 = v8;
      }
      else {
        double v9 = (double)((unint64_t)v2 - 1);
      }
      uint64_t v10 = llround(floor(v9));
      double v13 = *result;
      uint64_t result = sub_1000F0818(&v13, v10);
      int v11 = v13;
      int v12 = (void *)v13[1];
      if (v12)
      {
        do
          int v12 = (void *)*v12;
        while (v12);
      }

      else
      {
        do
        {
          BOOL v4 = *(void *)v11[2] == (void)v11;
          int v11 = (void *)v11[2];
        }

        while (!v4);
      }
    }
  }

  return result;
}

void sub_100115018(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_100115044(uint64_t a1)
{
  double v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_10011507C(uint64_t a1, void **a2)
{
  if (a2)
  {
    double v2 = a2;
    do
    {
      uint64_t v3 = *v2;
      sub_100008390((uint64_t)(v2 + 4), v2[5]);
      operator delete(v2);
      double v2 = (void **)v3;
    }

    while (v3);
  }

void *sub_1001150BC(uint64_t a1, void *a2, uint64_t a3, _OWORD **a4)
{
  unint64_t v7 = 0LL;
  for (uint64_t i = 0LL; i != 16; ++i)
    v7 ^= (v7 << 6) + (v7 >> 2) + 2654435769u + *((unsigned __int8 *)a2 + i);
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = v7;
      if (v7 >= v9) {
        unint64_t v4 = v7 % v9;
      }
    }

    else
    {
      unint64_t v4 = (v9 - 1) & v7;
    }

    int v11 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      for (unsigned int j = *v11; j; unsigned int j = (void *)*j)
      {
        unint64_t v13 = j[1];
        if (v13 == v7)
        {
          if (j[2] == *a2 && j[3] == a2[1]) {
            return j;
          }
        }

        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }

          else
          {
            v13 &= v9 - 1;
          }

          if (v13 != v4) {
            break;
          }
        }
      }
    }
  }

  double v15 = (void *)(a1 + 16);
  unsigned int j = operator new(0x38uLL);
  void *j = 0LL;
  j[1] = v7;
  *((_OWORD *)j + 1) = **a4;
  j[6] = 0LL;
  j[5] = 0LL;
  j[4] = j + 5;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    BOOL v18 = 1LL;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    sub_100019E10(a1, v21);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v7 >= v9) {
        unint64_t v4 = v7 % v9;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = (v9 - 1) & v7;
    }
  }

  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    void *j = *v23;
LABEL_44:
    *uint64_t v23 = j;
    goto LABEL_45;
  }

  void *j = *v15;
  void *v15 = j;
  *(void *)(v22 + 8 * v4) = v15;
  if (*j)
  {
    unint64_t v24 = *(void *)(*j + 8LL);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v24 >= v9) {
        v24 %= v9;
      }
    }

    else
    {
      v24 &= v9 - 1;
    }

    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_44;
  }

void sub_100115330(_Unwind_Exception *a1)
{
}

void sub_10011534C(uint64_t a1, void **a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    sub_100008390((uint64_t)(a2 + 4), a2[5]);
  }

  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

uint64_t **sub_100115394(uint64_t **result, void *a2, void *a3)
{
  uint64_t v5 = result;
  if (result[2])
  {
    uint64_t v6 = *result;
    unint64_t v7 = result[1];
    uint64_t *result = (uint64_t *)(result + 1);
    _DWORD v7[2] = 0LL;
    result[1] = 0LL;
    result[2] = 0LL;
    if (v6[1]) {
      double v8 = (uint64_t *)v6[1];
    }
    else {
      double v8 = v6;
    }
    int v14 = result;
    double v15 = v8;
    float v16 = v8;
    if (v8)
    {
      double v15 = sub_100115560((uint64_t)v8);
      if (a2 != a3)
      {
        unint64_t v9 = a2;
        do
        {
          v8[4] = v9[4];
          sub_1001154F4(v5, (uint64_t)v8);
          double v8 = v15;
          float v16 = v15;
          if (v15) {
            double v15 = sub_100115560((uint64_t)v15);
          }
          uint8x8_t v10 = (void *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              uint8x8_t v10 = (void *)*v10;
            }

            while (v10);
          }

          else
          {
            do
            {
              a2 = (void *)v9[2];
              BOOL v11 = *a2 == (void)v9;
              unint64_t v9 = a2;
            }

            while (!v11);
          }

          if (!v8) {
            break;
          }
          unint64_t v9 = a2;
        }

        while (a2 != a3);
      }
    }

    uint64_t result = (uint64_t **)sub_1001155B4((uint64_t)&v14);
  }

  if (a2 != a3)
  {
    do
    {
      uint64_t result = (uint64_t **)sub_1000F0468(v5, (double *)a2 + 4);
      int v12 = (void *)a2[1];
      if (v12)
      {
        do
        {
          unint64_t v13 = v12;
          int v12 = (void *)*v12;
        }

        while (v12);
      }

      else
      {
        do
        {
          unint64_t v13 = (void *)a2[2];
          BOOL v11 = *v13 == (void)a2;
          a2 = v13;
        }

        while (!v11);
      }

      a2 = v13;
    }

    while (v13 != a3);
  }

  return result;
}

void sub_1001154E0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1001154F4(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = a1 + 1;
  unint64_t v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v3 = (uint64_t **)v4;
        unint64_t v4 = (uint64_t *)*v4;
        uint64_t v5 = v3;
        if (!*v3) {
          goto LABEL_8;
        }
      }

      unint64_t v4 = (uint64_t *)v4[1];
    }

    while (v4);
    uint64_t v5 = v3 + 1;
  }

  else
  {
    uint64_t v5 = a1 + 1;
  }

void *sub_100115560(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 16);
  if (result)
  {
    uint64_t v3 = (void *)*result;
    if (*result == a1)
    {
      void *result = 0LL;
      while (1)
      {
        unint64_t v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          uint64_t result = v4;
          unint64_t v4 = (void *)*v4;
        }

        while (v4);
      }
    }

    else
    {
      for (result[1] = 0LL; v3; uint64_t v3 = (void *)result[1])
      {
        do
        {
          uint64_t result = v3;
          uint64_t v3 = (void *)*v3;
        }

        while (v3);
      }
    }
  }

  return result;
}

uint64_t sub_1001155B4(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (void *)v2[2];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        uint64_t v3 = (void *)v3[2];
      }

      while (v3);
      *(void *)(a1 + ++*(void *)(result + 8) = v2;
    }

    sub_100008390(*(void *)a1, v2);
  }

  return a1;
}

uint64_t sub_100115608@<X0>( uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, char **a6@<X8>)
{
  if (!sub_100097CA8(a2))
  {
    sub_10122CF6C();
    goto LABEL_85;
  }

  if (!*(_BYTE *)(a4 + 32))
  {
    sub_10122CE00();
LABEL_85:
    __break(1u);
  }

  memset(v94, 0, sizeof(v94));
  int v95 = 1065353216;
  int v12 = *(void **)(a2 + 232);
  for (uint64_t i = *(void **)(a2 + 240); v12 != i; v12 += 4)
  {
    *(void *)uint64_t buf = v12 + 2;
    int v14 = (uint64_t **)sub_1001150BC((uint64_t)v94, v12 + 2, (uint64_t)&unk_1012CF090, (_OWORD **)buf);
    uint64_t v15 = *(void *)(a4 + 24);
    if (!v15) {
      sub_100008BDC();
    }
    *(void *)uint64_t buf = (*(double (**)(uint64_t, void, uint64_t))(*(void *)v15 + 48LL))(v15, *v12, a3);
    sub_1000F0468(v14 + 4, (double *)buf);
  }

  (*(void (**)(void *__return_ptr, uint64_t, _BYTE *, uint64_t))(*(void *)a1 + 24LL))(v92, a1, v94, a5);
  __int128 v89 = 0u;
  __int128 v90 = 0u;
  int v91 = 1065353216;
  __int16 v86 = 0LL;
  uint64_t v87 = 0LL;
  uint64_t v88 = 0LL;
  sub_10000C75C(a5, buf);
  sub_1000410B8((uint64_t)buf, &v85);
  sub_1002A5554(buf);
  for (unsigned int j = v93; j; unsigned int j = (uint64_t *)*j)
  {
    double v17 = (*(double (**)(double *, double))(*(void *)v85 + 24LL))(v85, *((double *)j + 4));
    double v18 = v17;
    unint64_t v19 = j + 2;
    if (v17 >= 0.0)
    {
      if (v17 >= 0.999)
      {
        unint64_t v20 = v87;
        if (v87 >= v88)
        {
          uint64_t v22 = (v87 - (_BYTE *)v86) >> 4;
          unint64_t v23 = v22 + 1;
          uint64_t v24 = v88 - (_BYTE *)v86;
          if ((v88 - (_BYTE *)v86) >> 3 > v23) {
            unint64_t v23 = v24 >> 3;
          }
          else {
            unint64_t v25 = v23;
          }
          if (v25) {
            uint64_t v26 = (char *)sub_100037038((uint64_t)&v88, v25);
          }
          else {
            uint64_t v26 = 0LL;
          }
          uint64_t v27 = &v26[16 * v22];
          *(_OWORD *)uint64_t v27 = *v19;
          unint64_t v29 = (char *)v86;
          uint64_t v28 = v87;
          double v30 = v27;
          if (v87 != v86)
          {
            do
            {
              *((_OWORD *)v30 - 1) = *((_OWORD *)v28 - 1);
              v30 -= 16;
              v28 -= 16;
            }

            while (v28 != v29);
            uint64_t v28 = (char *)v86;
          }

          size_t v21 = v27 + 16;
          __int16 v86 = v30;
          uint64_t v87 = v27 + 16;
          uint64_t v88 = &v26[16 * v25];
          if (v28) {
            operator delete(v28);
          }
        }

        else
        {
          *(_OWORD *)uint64_t v87 = *v19;
          size_t v21 = v20 + 16;
        }

        uint64_t v87 = v21;
      }

      else
      {
        *(void *)uint64_t buf = j + 2;
        *((double *)sub_10005C6F8((uint64_t)&v89, j + 2, (uint64_t)&unk_1012CF090, (_OWORD **)buf) + 4) = v17 / (1.0 - v17);
      }
    }

    if (qword_1019348D0 != -1) {
      dispatch_once(&qword_1019348D0, &stru_10181F9C0);
    }
    int v31 = (os_log_s *)qword_1019348D8;
    if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v32 = operator new(0x28uLL);
      std::string __p = v32;
      __int128 v84 = xmmword_1012C8460;
      _OWORD *v32 = 0u;
      v32[1] = 0u;
      *(void *)((char *)v32 + 29) = 0LL;
      sub_10000AE6C((uint64_t)(j + 2), v32);
      p_p = &__p;
      if (v84 < 0) {
        p_p = __p;
      }
      uint64_t v35 = j[4];
      uint64_t v34 = j[5];
      *(void *)uint64_t buf = 68290051LL;
      __int16 v97 = 2082;
      __int128 v98 = "";
      __int16 v99 = 2081;
      uint64_t v100 = p_p;
      __int16 v101 = 2049;
      uint64_t v102 = v34;
      __int16 v103 = 2049;
      double v104 = v18;
      __int16 v105 = 2049;
      uint64_t v106 = v35;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEBUG,  "{msg%{public}.0s:nullspace, identifier:%{private, location:escape_only}s, weight:%{private}f , phat:%{private}f, reducedDistance:%{private}f}",  buf,  0x3Au);
      if (SHIBYTE(v84) < 0) {
        operator delete(__p);
      }
    }
  }

  int v36 = *(_DWORD *)(a3 + 160);
  a6[1] = 0LL;
  a6[2] = 0LL;
  *a6 = 0LL;
  *((_DWORD *)a6 + 6) = 3;
  *((_BYTE *)a6 + 80) = 0;
  a6[5] = 0LL;
  a6[6] = 0LL;
  a6[4] = 0LL;
  *((_BYTE *)a6 + 56) = 0;
  double v37 = (char *)v86;
  char v38 = v87;
  if (v86 == v87)
  {
    double v55 = (double *)v90;
    CFAbsoluteTime v57 = a6 + 2;
    __int128 v58 = (char *)sub_10000835C((uint64_t)(a6 + 2), 1uLL);
    double v59 = 1.0 / k;
    int v61 = &v58[32 * v60];
    *(void *)__int128 v58 = 0LL;
    *((void *)v58 + 1) = 0LL;
    *((double *)v58 + 2) = 1.0 / k;
    *((_DWORD *)v58 + 6) = v36;
    double v62 = v58 + 32;
    CFAbsoluteTime v64 = *a6;
    __int128 v63 = a6[1];
    if (v63 != *a6)
    {
      do
      {
        __int128 v65 = *((_OWORD *)v63 - 2);
        *(_OWORD *)(v58 - 20) = *(_OWORD *)(v63 - 20);
        *((_OWORD *)v58 - 2) = v65;
        v58 -= 32;
        v63 -= 32;
      }

      while (v63 != v64);
      __int128 v63 = *a6;
    }

    *a6 = v58;
    a6[1] = v62;
    a6[2] = v61;
    if (v63) {
      operator delete(v63);
    }
    a6[1] = v62;
    for (m = (double *)v90; m; m = *(double **)m)
    {
      uint64_t v68 = *((void *)m + 2);
      uint64_t v67 = *((void *)m + 3);
      double v69 = v59 * m[4];
      if ((unint64_t)v62 >= *v57)
      {
        uint64_t v70 = (v62 - *a6) >> 5;
        uint64_t v71 = *v57 - (void)*a6;
        uint64_t v72 = v71 >> 4;
        else {
          unint64_t v73 = v72;
        }
        __int128 v74 = (char *)sub_10000835C((uint64_t)(a6 + 2), v73);
        int v76 = &v74[32 * v70];
        *(void *)int v76 = v68;
        *((void *)v76 + 1) = v67;
        *((double *)v76 + 2) = v69;
        *((_DWORD *)v76 + 6) = v36;
        __int16 v78 = *a6;
        uint64_t v77 = a6[1];
        uint64_t v79 = v76;
        if (v77 != *a6)
        {
          do
          {
            __int128 v80 = *((_OWORD *)v77 - 2);
            *(_OWORD *)(v79 - 20) = *(_OWORD *)(v77 - 20);
            *((_OWORD *)v79 - 2) = v80;
            v79 -= 32;
            v77 -= 32;
          }

          while (v77 != v78);
          uint64_t v77 = *a6;
        }

        double v62 = v76 + 32;
        *a6 = v79;
        a6[1] = v76 + 32;
        a6[2] = &v74[32 * v75];
        if (v77) {
          operator delete(v77);
        }
      }

      else
      {
        *(void *)double v62 = v68;
        *((void *)v62 + 1) = v67;
        *((double *)v62 + 2) = v69;
        *((_DWORD *)v62 + 6) = v36;
        v62 += 32;
      }

      a6[1] = v62;
    }
  }

  else
  {
    double v39 = 0LL;
    double v40 = 1.0 / (double)(unint64_t)((v87 - (_BYTE *)v86) >> 4);
    uint64_t v41 = a6 + 2;
    do
    {
      uint64_t v43 = *(void *)v37;
      uint64_t v42 = *((void *)v37 + 1);
      if ((unint64_t)v39 >= *v41)
      {
        uint64_t v44 = (v39 - *a6) >> 5;
        uint64_t v45 = *v41 - (void)*a6;
        uint64_t v46 = v45 >> 4;
        else {
          unint64_t v47 = v46;
        }
        uint64_t v48 = (char *)sub_10000835C((uint64_t)(a6 + 2), v47);
        uint64_t v50 = &v48[32 * v44];
        *(void *)uint64_t v50 = v43;
        *((void *)v50 + 1) = v42;
        *((double *)v50 + 2) = v40;
        *((_DWORD *)v50 + 6) = v36;
        double v52 = *a6;
        unint64_t v51 = a6[1];
        uint64_t v53 = v50;
        if (v51 != *a6)
        {
          do
          {
            __int128 v54 = *((_OWORD *)v51 - 2);
            *(_OWORD *)(v53 - 20) = *(_OWORD *)(v51 - 20);
            *((_OWORD *)v53 - 2) = v54;
            v53 -= 32;
            v51 -= 32;
          }

          while (v51 != v52);
          unint64_t v51 = *a6;
        }

        double v39 = v50 + 32;
        *a6 = v53;
        a6[1] = v50 + 32;
        a6[2] = &v48[32 * v49];
        if (v51) {
          operator delete(v51);
        }
      }

      else
      {
        *(void *)double v39 = v43;
        *((void *)v39 + 1) = v42;
        *((double *)v39 + 2) = v40;
        *((_DWORD *)v39 + 6) = v36;
        v39 += 32;
      }

      a6[1] = v39;
      v37 += 16;
    }

    while (v37 != v38);
  }

  uint64_t v81 = v85;
  double v85 = 0LL;
  if (v81) {
    (*(void (**)(double *))(*(void *)v81 + 8LL))(v81);
  }
  if (v86)
  {
    uint64_t v87 = (char *)v86;
    operator delete(v86);
  }

  sub_100019CEC((uint64_t)&v89);
  sub_100019CEC((uint64_t)v92);
  return sub_100115044((uint64_t)v94);
}

void sub_100115D08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, char a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
  if (a19) {
    (*(void (**)(uint64_t))(*(void *)a19 + 8LL))(a19);
  }
  if (__p) {
    operator delete(__p);
  }
  sub_100019CEC((uint64_t)&a23);
  sub_100019CEC((uint64_t)&a28);
  sub_100115044((uint64_t)&a33);
  _Unwind_Resume(a1);
}

uint64_t *sub_100115DC0@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(uint64_t **)(a1 + 16);
  if (v6)
  {
    int v7 = 0;
    do
    {
      v7 += *((_DWORD *)v6 + 12);
      uint64_t v6 = (uint64_t *)*v6;
    }

    while (v6);
    double v8 = (double)v7;
  }

  else
  {
    double v8 = 0.0;
  }

  double v9 = sub_10000C6B4(a2);
  double v10 = sub_10000C730(a2);
  sub_1002F0B04(&v26);
  CFStringRef v11 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsNullSpaceDistanceReductionFunction",  0x8000100u,  kCFAllocatorNull);
  int v12 = sub_1002A77CC(v26, (uint64_t)v11, &v25);
  CFRelease(v11);
  unsigned int v13 = v25;
  int v14 = v27;
  if (v27)
  {
    p_shared_owners = (unint64_t *)&v27->__shared_owners_;
    do
      unint64_t v16 = __ldaxr(p_shared_owners);
    while (__stlxr(v16 - 1, p_shared_owners));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }

  if (v12) {
    uint64_t v17 = v13;
  }
  else {
    uint64_t v17 = 5LL;
  }
  sub_1000F02F0(v17, 0, (uint64_t)&v26, v9, v10);
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  for (uint64_t i = *(uint64_t **)(a1 + 16); i; uint64_t i = (uint64_t *)*i)
  {
    sub_1000F0A4C((uint64_t)v24, (uint64_t)(i + 4));
    if (!v28) {
      sub_100008BDC();
    }
    double v19 = (*(double (**)(uint64_t *, void **))(*v28 + 48))(v28, v24);
    unint64_t v20 = i[6];
    unint64_t v25 = i + 2;
    size_t v21 = (double *)sub_10001D174(a3, i + 2, (uint64_t)&unk_1012CF090, &v25);
    v21[4] = v19;
    v21[5] = (double)v20 / v8;
    sub_100008390((uint64_t)v24, v24[1]);
  }

  uint64_t result = v28;
  if (v28 == &v26)
  {
    uint64_t v23 = 4LL;
    uint64_t result = &v26;
  }

  else
  {
    if (!v28) {
      return result;
    }
    uint64_t v23 = 5LL;
  }

  return (uint64_t *)(*(uint64_t (**)(void))(*result + 8 * v23))();
}

void sub_100115FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_10011605C(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_100116088(void *a1)
{
  if (sub_1000EFCD4(a1))
  {
    unint64_t v2 = 0LL;
    while (2)
    {
      uint64_t v3 = sub_1000EFC84(a1, v2) + 16;
      while (1)
      {
        uint64_t v3 = *(void *)v3;
        if (!v3) {
          break;
        }
        if (*(_DWORD *)(v3 + 24) == 5)
        {
          sub_1002F0B04(buf);
          CFStringRef v12 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsModelQualityNumFingerprintsWiFiBleThreshold",  0x8000100u,  kCFAllocatorNull);
          int v13 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v12, &v22);
          CFRelease(v12);
          unsigned int v14 = v22;
          uint64_t v15 = *(std::__shared_weak_count **)v24;
          if (*(void *)v24)
          {
            unint64_t v16 = (unint64_t *)(*(void *)v24 + 8LL);
            do
              unint64_t v17 = __ldaxr(v16);
            while (__stlxr(v17 - 1, v16));
            if (!v17)
            {
              ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
              std::__shared_weak_count::__release_weak(v15);
            }
          }

          if (v13) {
            unsigned int v11 = v14;
          }
          else {
            unsigned int v11 = 150;
          }
          int v10 = 1;
          goto LABEL_25;
        }
      }

      if (++v2 < sub_1000EFCD4(a1)) {
        continue;
      }
      break;
    }
  }

  sub_1002F0B04(buf);
  CFStringRef v4 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsModelQualityNumFingerprintsWiFiOnlyThreshold",  0x8000100u,  kCFAllocatorNull);
  int v5 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v4, &v22);
  CFRelease(v4);
  unsigned int v6 = v22;
  int v7 = *(std::__shared_weak_count **)v24;
  if (*(void *)v24)
  {
    double v8 = (unint64_t *)(*(void *)v24 + 8LL);
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  int v10 = 0;
  if (v5) {
    unsigned int v11 = v6;
  }
  else {
    unsigned int v11 = 200;
  }
LABEL_25:
  unint64_t v18 = v11;
  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F9E0);
  }
  double v19 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = sub_1000EFCD4(a1);
    *(_DWORD *)uint64_t buf = 68289794;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)uint64_t v24 = 2082;
    *(void *)&__n128 v24[2] = "";
    __int16 v25 = 2050;
    uint64_t v26 = v20;
    __int16 v27 = 1026;
    int v28 = v10;
    __int16 v29 = 2050;
    unint64_t v30 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:evaluateQualityWithNumFingerprints, Num fingerprints (unpruned):%{public}lu, Has BL E:%{public}hhd, Threshold:%{public}lu}",  buf,  0x2Cu);
  }

  if (sub_1000EFCD4(a1) < v18) {
    return 1LL;
  }
  else {
    return 3LL;
  }
}

void sub_100116334( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12)
  {
    p_shared_owners = (unint64_t *)&a12->__shared_owners_;
    do
      unint64_t v14 = __ldaxr(p_shared_owners);
    while (__stlxr(v14 - 1, p_shared_owners));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))a12->__on_zero_shared)(a12);
      std::__shared_weak_count::__release_weak(a12);
    }
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_1001163AC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = a2;
  *(void *)(a2 + ++*(void *)(result + 8) = 0LL;
  *(void *)(a2 + 16) = 0LL;
  *(void *)(a2 + 24) = 0LL;
  __int16 v99 = (void **)(a2 + 8);
  sub_10004C5F8((char *)(a2 + 8), 0LL, 0LL, 0LL);
  sub_1002F0B04(buf);
  CFStringRef v4 = CFStringCreateWithCStringNoCopy(0LL, "MicroLocationsAdaptiveSensorsEnable", 0x8000100u, kCFAllocatorNull);
  char v5 = sub_1002A6FD4(*(uint64_t *)buf, (uint64_t)v4, (BOOL *)&v106);
  CFRelease(v4);
  int v6 = v106;
  int v7 = *(std::__shared_weak_count **)v116;
  if (*(void *)v116)
  {
    double v8 = (unint64_t *)(*(void *)v116 + 8LL);
    do
      unint64_t v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  int v111 = &stru_1018A4B00;
  uint64_t v10 = sub_100093AE4(1, 1, 1);
  char v11 = v5 ^ 1;
  if (v6) {
    char v11 = 1;
  }
  uint64_t v112 = v10;
  char v113 = v11;
  sub_1000BC648(a1, v109);
  if (sub_1000954B4(a1) == 1)
  {
    v109[3] = 0.0;
    float v110 = 0.0;
  }

  __int128 v106 = 0u;
  __int128 v107 = 0u;
  int v108 = 1065353216;
  double v104 = 0LL;
  unint64_t v105 = 0LL;
  uint64_t v102 = 0LL;
  __int16 v103 = &v104;
  uint64_t v100 = &v101;
  __int16 v101 = 0LL;
  uint64_t v13 = *(void *)(a1 + 232);
  uint64_t v12 = *(void *)(a1 + 240);
  unint64_t v14 = (v12 - v13) >> 5;
  if (v12 == v13)
  {
    unsigned int v24 = 0;
    *(_DWORD *)(v3 + 32) = 0;
    unsigned int v22 = (int *)(v3 + 32);
    *(_DWORD *)(v3 + 36) = 0;
    uint64_t v33 = (int *)(v3 + 36);
    *(_DWORD *)(v3 + 40) = 0;
    uint64_t v23 = (int *)(v3 + 40);
  }

  else
  {
    do
    {
      for (uint64_t i = *(uint64_t **)(*(void *)v13 + 16LL); i; uint64_t i = (uint64_t *)*i)
      {
        int v16 = *((_DWORD *)i + 6);
        if (v16 == 6)
        {
          unint64_t v18 = (uint64_t **)&v100;
        }

        else
        {
          if (v16 != 5)
          {
            if (v16 == 1)
            {
              *(void *)uint64_t buf = i + 4;
              unint64_t v17 = sub_100116E48((uint64_t)&v106, (uint64_t)(i + 4), (uint64_t)&unk_1012CF090, (uint64_t *)buf);
              ++*((_DWORD *)v17 + 12);
            }

            continue;
          }

          unint64_t v18 = (uint64_t **)&v103;
        }

        sub_100117344(v18, (uint64_t)(i + 4), (uint64_t)(i + 4));
      }

      v13 += 32LL;
    }

    while (v13 != v12);
    int v19 = v105;
    int v20 = v102;
    size_t v21 = (uint64_t **)v107;
    *(_DWORD *)(v3 + 32) = DWORD2(v107);
    unsigned int v22 = (int *)(v3 + 32);
    *(_DWORD *)(v3 + 36) = v19;
    __int128 v98 = (int *)(v3 + 36);
    *(_DWORD *)(v3 + 40) = v20;
    uint64_t v23 = (int *)(v3 + 40);
    if (v21)
    {
      uint64_t v97 = v3;
      unsigned int v24 = 0;
      do
      {
        unint64_t v25 = *((int *)v21 + 12);
        sub_1002F0B04(buf);
        CFStringRef v26 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsRobustWiFiMinARDecisionTreeFeatureThreshold",  0x8000100u,  kCFAllocatorNull);
        int v27 = sub_1002A832C(*(uint64_t *)buf, (uint64_t)v26, &v114);
        CFRelease(v26);
        double v28 = v114;
        __int16 v29 = *(std::__shared_weak_count **)v116;
        if (*(void *)v116)
        {
          unint64_t v30 = (unint64_t *)(*(void *)v116 + 8LL);
          do
            unint64_t v31 = __ldaxr(v30);
          while (__stlxr(v31 - 1, v30));
          if (!v31)
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v29);
          }
        }

        if (v27) {
          double v32 = v28;
        }
        else {
          double v32 = 0.05;
        }
        size_t v21 = (uint64_t **)*v21;
      }

      while (v21);
      uint64_t v3 = v97;
      uint64_t v33 = v98;
    }

    else
    {
      unsigned int v24 = 0;
      uint64_t v33 = (int *)(v3 + 36);
    }
  }

  if (qword_1019348D0 != -1) {
    dispatch_once(&qword_1019348D0, &stru_10181F9E0);
  }
  uint64_t v34 = (os_log_s *)qword_1019348D8;
  if (os_log_type_enabled((os_log_t)qword_1019348D8, OS_LOG_TYPE_DEFAULT))
  {
    int v35 = *v22;
    int v36 = *v33;
    int v37 = *v23;
    *(_DWORD *)uint64_t buf = 68290562;
    *(_DWORD *)&uint8_t buf[4] = 0;
    *(_WORD *)int v116 = 2082;
    *(void *)&v116[2] = "";
    __int16 v117 = 2050;
    unint64_t v118 = v14;
    __int16 v119 = 2050;
    uint64_t v120 = v24;
    __int16 v121 = 1026;
    int v122 = v35;
    __int16 v123 = 1026;
    int v124 = v36;
    __int16 v125 = 1026;
    int v126 = v37;
    __int16 v127 = 2050;
    double v128 = v110;
    _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "{msg%{public}.0s:evaluateQualityTreeBased, Num fingerprints (post-pruning):%{public}lu, NumRobustWif iSources:%{public}lu, NumWiFiSources:%{public}u, NumBLESources:%{public}u, NumUWBSources:%{public}u, maxClusterRfDistance:%{public}f}",  buf,  0x42u);
  }

  sub_1002F0B04(buf);
  CFStringRef v38 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsNumMinFingerprintsPostPruningTreeBasedThreshold",  0x8000100u,  kCFAllocatorNull);
  int v39 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v38, &v114);
  CFRelease(v38);
  unint64_t v40 = LODWORD(v114);
  uint64_t v41 = *(std::__shared_weak_count **)v116;
  if (*(void *)v116)
  {
    uint64_t v42 = (unint64_t *)(*(void *)v116 + 8LL);
    do
      unint64_t v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }

  unint64_t v44 = 130LL;
  if (v39) {
    unint64_t v44 = v40;
  }
  if (v14 < v44)
  {
    unint64_t v45 = *(void *)(v3 + 24);
    uint64_t v46 = *(int **)(v3 + 16);
    if ((unint64_t)v46 < v45)
    {
      int v47 = 5;
LABEL_89:
      int *v46 = v47;
      __int128 v80 = v46 + 1;
LABEL_121:
      *(void *)(v3 + 16) = v80;
      int v70 = 1;
      goto LABEL_122;
    }

    unint64_t v73 = (int *)*v99;
    uint64_t v74 = ((char *)v46 - (_BYTE *)*v99) >> 2;
    unint64_t v75 = v74 + 1;
    uint64_t v76 = v45 - (void)v73;
    if (v76 >> 1 > v75) {
      unint64_t v75 = v76 >> 1;
    }
    else {
      unint64_t v77 = v75;
    }
    if (v77)
    {
      __int16 v78 = (char *)sub_10000956C(v3 + 24, v77);
      unint64_t v73 = *(int **)(v3 + 8);
      uint64_t v46 = *(int **)(v3 + 16);
    }

    else
    {
      __int16 v78 = 0LL;
    }

    __int16 v86 = &v78[4 * v74];
    uint64_t v87 = &v78[4 * v77];
    *(_DWORD *)__int16 v86 = 5;
    __int128 v80 = v86 + 4;
    while (v46 != v73)
    {
      int v88 = *--v46;
      *((_DWORD *)v86 - 1) = v88;
      v86 -= 4;
    }

    goto LABEL_119;
  }

  float v48 = v110;
  sub_1002F0B04(buf);
  CFStringRef v49 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsMaxClusterRFDistanceDecisionTreeNodeThreshold",  0x8000100u,  kCFAllocatorNull);
  int v50 = sub_1002A832C(*(uint64_t *)buf, (uint64_t)v49, &v114);
  CFRelease(v49);
  double v51 = v114;
  double v52 = *(std::__shared_weak_count **)v116;
  if (*(void *)v116)
  {
    uint64_t v53 = (unint64_t *)(*(void *)v116 + 8LL);
    do
      unint64_t v54 = __ldaxr(v53);
    while (__stlxr(v54 - 1, v53));
    if (!v54)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }

  double v55 = 0.49;
  if (v50) {
    double v55 = v51;
  }
  if (v55 >= v48)
  {
    unint64_t v79 = *(void *)(v3 + 24);
    uint64_t v46 = *(int **)(v3 + 16);
    if ((unint64_t)v46 < v79)
    {
      int v47 = 6;
      goto LABEL_89;
    }

    unint64_t v73 = (int *)*v99;
    uint64_t v81 = ((char *)v46 - (_BYTE *)*v99) >> 2;
    unint64_t v82 = v81 + 1;
    uint64_t v83 = v79 - (void)v73;
    if (v83 >> 1 > v82) {
      unint64_t v82 = v83 >> 1;
    }
    else {
      unint64_t v84 = v82;
    }
    if (v84)
    {
      double v85 = (char *)sub_10000956C(v3 + 24, v84);
      unint64_t v73 = *(int **)(v3 + 8);
      uint64_t v46 = *(int **)(v3 + 16);
    }

    else
    {
      double v85 = 0LL;
    }

    __int16 v86 = &v85[4 * v81];
    uint64_t v87 = &v85[4 * v84];
    *(_DWORD *)__int16 v86 = 6;
    __int128 v80 = v86 + 4;
    while (v46 != v73)
    {
      int v89 = *--v46;
      *((_DWORD *)v86 - 1) = v89;
      v86 -= 4;
    }

    goto LABEL_119;
  }

  sub_1002F0B04(buf);
  CFStringRef v56 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsNumRobustWifiSourcesDecisionTreeNodeThreshold",  0x8000100u,  kCFAllocatorNull);
  int v57 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v56, &v114);
  CFRelease(v56);
  unsigned int v58 = LODWORD(v114);
  double v59 = *(std::__shared_weak_count **)v116;
  if (*(void *)v116)
  {
    uint64_t v60 = (unint64_t *)(*(void *)v116 + 8LL);
    do
      unint64_t v61 = __ldaxr(v60);
    while (__stlxr(v61 - 1, v60));
    if (!v61)
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
  }

  if (v57) {
    unsigned int v62 = v58;
  }
  else {
    unsigned int v62 = 42;
  }
  if (v24 >= v62)
  {
    int v70 = 3;
  }

  else
  {
    unint64_t v63 = v105;
    sub_1002F0B04(buf);
    CFStringRef v64 = CFStringCreateWithCStringNoCopy( 0LL,  "MicroLocationsNumBLESourcesDecisionTreeNodeThreshold",  0x8000100u,  kCFAllocatorNull);
    int v65 = sub_1002A77CC(*(uint64_t *)buf, (uint64_t)v64, &v114);
    CFRelease(v64);
    unint64_t v66 = LODWORD(v114);
    uint64_t v67 = *(std::__shared_weak_count **)v116;
    if (*(void *)v116)
    {
      uint64_t v68 = (unint64_t *)(*(void *)v116 + 8LL);
      do
        unint64_t v69 = __ldaxr(v68);
      while (__stlxr(v69 - 1, v68));
      if (!v69)
      {
        ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
        std::__shared_weak_count::__release_weak(v67);
      }
    }

    int v70 = 3;
    if (v65) {
      unint64_t v71 = v66;
    }
    else {
      unint64_t v71 = 3LL;
    }
    if (v63 < v71)
    {
      unint64_t v72 = *(void *)(v3 + 24);
      uint64_t v46 = *(int **)(v3 + 16);
      if ((unint64_t)v46 < v72)
      {
        int v47 = 7;
        goto LABEL_89;
      }

      unint64_t v73 = (int *)*v99;
      uint64_t v90 = ((char *)v46 - (_BYTE *)*v99) >> 2;
      unint64_t v91 = v90 + 1;
      uint64_t v92 = v72 - (void)v73;
      if (v92 >> 1 > v91) {
        unint64_t v91 = v92 >> 1;
      }
      else {
        unint64_t v93 = v91;
      }
      if (v93)
      {
        __int128 v94 = (char *)sub_10000956C(v3 + 24, v93);
        unint64_t v73 = *(int **)(v3 + 8);
        uint64_t v46 = *(int **)(v3 + 16);
      }

      else
      {
        __int128 v94 = 0LL;
      }

      __int16 v86 = &v94[4 * v90];
      uint64_t v87 = &v94[4 * v93];
      *(_DWORD *)__int16 v86 = 7;
      __int128 v80 = v86 + 4;
      while (v46 != v73)
      {
        int v95 = *--v46;
        *((_DWORD *)v86 - 1) = v95;
        v86 -= 4;
      }

LABEL_122:
  *(_DWORD *)uint64_t v3 = v70;
  sub_100116E00((uint64_t)&v100, v101);
  sub_100116E00((uint64_t)&v103, v104);
  return sub_100116D8C((uint64_t)&v106);
}

  int v50 = *(void *)(a2 + 224);
  *(_DWORD *)(a1 + 368) |= 0x20u;
  *(void *)(a1 + sub_1000A7938(v46 - 224) = v50;
  int v36 = *(_DWORD *)(a2 + 368);
  if ((v36 & 0x40) == 0)
  {
LABEL_90:
    if ((v36 & 0x80) == 0) {
      goto LABEL_92;
    }
    goto LABEL_91;
  }

  uint64_t result = wireless_diagnostics::google::protobuf::internal::WireFormatLite::WriteDouble( (wireless_diagnostics::google::protobuf::internal::WireFormatLite *)0x32,  (int)a2,  *(double *)(v5 + 328),  a3);
  unint64_t v9 = *(_DWORD *)(v5 + 368);
  if ((v9 & 0x40000) == 0)
  {
LABEL_55:
    if ((v9 & 0x80000) == 0) {
      goto LABEL_56;
    }
    goto LABEL_124;
  }

    unint64_t v45 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)*(unsigned int *)(a1 + 124);
    if (v45 >= 0x80)
    {
      uint64_t v46 = wireless_diagnostics::google::protobuf::io::CodedOutputStream::VarintSize32Fallback(v45, a2) + 2;
      uint64_t v3 = *(_DWORD *)(a1 + 148);
    }

    else
    {
      uint64_t v46 = 3;
    }

    char v5 = (v46 + v5);
    if ((v3 & 0x200000) == 0)
    {
LABEL_103:
      if ((v3 & 0x400000) == 0) {
        goto LABEL_104;
      }
      goto LABEL_130;
    }

  unint64_t v9 = self->_onsetReason + 1;
  if (v9 >= 5) {
    uint64_t v10 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"(unknown: %i)",  self->_onsetReason);
  }
  else {
    uint64_t v10 = off_10183ECA0[v9];
  }
  [v3 setObject:v10 forKey:@"onsetReason"];
  has = self->_has;
  if ((*(_DWORD *)&has & 0x20000) == 0)
  {
LABEL_100:
    if ((*(_DWORD *)&has & 0x200000) == 0) {
      goto LABEL_101;
    }
LABEL_127:
    *(float *)&int v6 = self->_userMaxCatherine;
    objc_msgSend( v3,  "setObject:forKey:",  +[NSNumber numberWithFloat:](NSNumber, "numberWithFloat:", v6),  @"userMaxCatherine");
    if ((*(_DWORD *)&self->_has & 0x80000) == 0) {
      return v3;
    }
    goto LABEL_102;
  }

  unint64_t v40 = *(_DWORD *)(a1 + 32);
  uint64_t v41 = v40 + v5;
  if (v40 >= 1)
  {
    uint64_t v42 = 0LL;
    do
    {
      unint64_t v43 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100A4FBE8(*(void *)(*(void *)(a1 + 24) + 8 * v42));
      unint64_t v44 = (int)v43;
      else {
        unint64_t v45 = 1;
      }
      v41 += v44 + v45;
      ++v42;
    }

    while (v42 < *(int *)(a1 + 32));
  }

  uint64_t v46 = *(_DWORD *)(a1 + 112);
  int v47 = (v46 + v41);
  if (v46 >= 1)
  {
    float v48 = 0LL;
    do
    {
      CFStringRef v49 = (wireless_diagnostics::google::protobuf::io::CodedOutputStream *)sub_100A4F684( *(void *)(*(void *)(a1 + 104)
                                                                                         + 8 * v48),
                                                                               a2);
      int v50 = (int)v49;
      else {
        double v51 = 1;
      }
      int v47 = (v50 + v47 + v51);
      ++v48;
    }

    while (v48 < *(int *)(a1 + 112));
  }

  *(_DWORD *)(a1 + 16++*(void *)(result + 8) = v47;
  return v47;
}

  unint64_t v63 = 1;
  a6 = v61;
LABEL_123:
  *(void *)uint64_t buf = v80;
  sub_100EECC8C((void ***)buf);
  objc_autoreleasePoolPop(v12);
  if (v63) {
    LOBYTE(v13) = sub_100EEA1AC(a1, a2, a3, (a4 - 1), v31, a6);
  }
  return v13 & 1;
}

  uint64_t result = *(float *)(a2 + 192);
  v5 |= 0x2000000000uLL;
  *unint64_t v2 = v5;
  *(_BYTE *)(a1 + 324) = v6;
  *(float *)(a1 + 192) = result;
  int v7 = *v3;
  if ((*v3 & 0x40000000) == 0)
  {
LABEL_57:
    if ((v7 & 0x100000000000LL) == 0) {
      goto LABEL_58;
    }
    goto LABEL_124;
  }

  PB::TextFormatter::format(this, "lgDeltaVXYBiggestImpact", *(float *)(a1 + 256));
  int v6 = *v5;
  int v7 = *(_BYTE *)(a1 + 324);
  if ((*v5 & 0x40000000000000LL) == 0)
  {
LABEL_56:
    if ((v6 & 0x80000000000000LL) == 0) {
      goto LABEL_57;
    }
    goto LABEL_124;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 192), 0x34u);
  int v6 = *v4;
  if ((*v4 & 0x40000000) == 0)
  {
LABEL_57:
    if ((v6 & 0x100000000000LL) == 0) {
      goto LABEL_58;
    }
    goto LABEL_124;
  }

  uint64_t result = *(float *)(a2 + 56);
  v5 |= 0x800uLL;
  *unint64_t v2 = v5;
  *(_WORD *)(a1 + 28++*(void *)(result + 8) = v6;
  *(float *)(a1 + 56) = result;
  CFStringRef v4 = *v3;
  int v7 = *(_WORD *)(a2 + 288);
  if ((*v3 & 0x4000) == 0)
  {
LABEL_49:
    if ((v4 & 0x2000) == 0) {
      goto LABEL_50;
    }
    goto LABEL_124;
  }

  PB::TextFormatter::format(this, "isFreeFall", *(_BYTE *)(a1 + 274));
  int v6 = *v5;
  int v7 = *(_WORD *)(a1 + 288);
  if ((v7 & 0x80) == 0)
  {
LABEL_48:
    if ((v7 & 0x100) == 0) {
      goto LABEL_49;
    }
    goto LABEL_124;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 64), 0x2Bu);
  char v5 = *v4;
  int v6 = *((_WORD *)v4 + 4);
  if ((*v4 & 0x1000) == 0)
  {
LABEL_48:
    if ((v5 & 0x2000000) == 0) {
      goto LABEL_49;
    }
    goto LABEL_124;
  }

  uint64_t result = *(float *)(a2 + 140);
  v5 |= (unint64_t)&_mh_execute_header;
  *unint64_t v2 = v5;
  *(_WORD *)(a1 + 324) = v6;
  *(_BYTE *)(a1 + 326) = BYTE2(v6);
  *(float *)(a1 + 140) = result;
  LOWORD(v++*(void *)(result + 8) = *(_WORD *)(a2 + 324);
  CFStringRef v4 = *v3;
  if ((*v3 & 0x10) == 0)
  {
LABEL_42:
    if ((v4 & 0x4000000000000000LL) == 0) {
      goto LABEL_43;
    }
    goto LABEL_124;
  }

  PB::TextFormatter::format(this, "kRegimeDeltaVThreshold1ROWOA", *(float *)(a1 + 128));
  int v7 = *(unsigned __int16 *)(a1 + 324) | (*(unsigned __int8 *)(a1 + 326) << 16);
  int v6 = *v5;
  if ((*v5 & 0x40000000) == 0)
  {
LABEL_41:
    if ((v6 & 0x80000000) == 0) {
      goto LABEL_42;
    }
    goto LABEL_124;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 140), 0xE8u);
  LOWORD(v7) = *((_WORD *)v4 + 4);
  char v5 = *v4;
  if ((*v4 & 0x10) == 0)
  {
LABEL_42:
    if ((v5 & 0x4000000000000000LL) == 0) {
      goto LABEL_43;
    }
    goto LABEL_124;
  }

  uint64_t result = *(float *)(a2 + 104);
  v5 |= 0x10000uLL;
  *unint64_t v2 = v5;
  *(void *)(a1 + 364) = v6;
  *(float *)(a1 + 104) = result;
  CFStringRef v4 = *v3;
  int v7 = *(void *)(a2 + 364);
  if ((v7 & 8) == 0)
  {
LABEL_17:
    if ((v7 & 0x10) == 0) {
      goto LABEL_18;
    }
    goto LABEL_124;
  }

  PB::TextFormatter::format(this, "isAutocorrelationDecided", *(_BYTE *)(a1 + 320));
  int v7 = *v5;
  int v6 = *(void *)(a1 + 364);
  if ((v6 & 0x400) == 0)
  {
LABEL_21:
    if ((v6 & 0x800) == 0) {
      goto LABEL_22;
    }
    goto LABEL_124;
  }

  uint64_t result = PB::Writer::write(this, *(float *)(v3 + 104), 0xCu);
  char v5 = *v4;
  int v6 = v4[1];
  if ((v6 & 8) == 0)
  {
LABEL_17:
    if ((v6 & 0x10) == 0) {
      goto LABEL_18;
    }
    goto LABEL_124;
  }

  double v51 = *(_DWORD *)(a2 + 84);
  v3 |= 0x8000uLL;
  *(void *)(result + 204) = v3;
  *(_WORD *)(result + 212) = v4;
  *(_BYTE *)(result + 214) = BYTE2(v4);
  *(_DWORD *)(result + 84) = v51;
  char v5 = *(unsigned __int16 *)(a2 + 212) | (*(unsigned __int8 *)(a2 + 214) << 16);
  unint64_t v2 = *(void *)(a2 + 204);
  if ((v2 & 0x8000000000000000LL) == 0)
  {
LABEL_44:
    if ((v2 & 0x8000000000000LL) == 0) {
      goto LABEL_45;
    }
    goto LABEL_124;
  }

  PB::TextFormatter::format(this, "kMaxEnergyRO", *(float *)(a1 + 60));
  int v6 = *(unsigned __int16 *)(a1 + 212) | (*(unsigned __int8 *)(a1 + 214) << 16);
  char v5 = *(void *)(a1 + 204);
  if ((v5 & 0x400) == 0)
  {
LABEL_43:
    if ((v5 & 0x800) == 0) {
      goto LABEL_44;
    }
    goto LABEL_124;
  }

  uint64_t result = PB::Writer::write(this, *(_BYTE *)(v3 + 177), 0x3FCu);
  char v5 = *(unsigned __int16 *)(v3 + 212) | (*(unsigned __int8 *)(v3 + 214) << 16);
  CFStringRef v4 = *(void *)(v3 + 204);
  if ((v4 & 0x400000000000000LL) == 0)
  {
LABEL_44:
    if ((v5 & 4) == 0) {
      goto LABEL_45;
    }
    goto LABEL_124;
  }

void sub_100116C9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void **a5, ...)
{
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void *);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v12 = va_arg(va2, void);
  unint64_t v14 = va_arg(va2, void *);
  uint64_t v15 = va_arg(va2, void);
  sub_100116E00((uint64_t)va, v10);
  sub_100116E00((uint64_t)va1, v14);
  sub_100116D8C((uint64_t)va2);
  int v7 = *a5;
  if (*a5)
  {
    *(void *)(v5 + 16) = v7;
    operator delete(v7);
  }

  _Unwind_Resume(a1);
}

void sub_100116D60(id a1)
{
  qword_1019348D8 = (uint64_t)os_log_create("com.apple.locationd.Position", "Microlocation");
}

uint64_t sub_100116D8C(uint64_t a1)
{
  unint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100116DC4(uint64_t a1, void *a2)
{
  if (a2)
  {
    unint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_10001AAD4((uint64_t)(v2 + 2));
      operator delete(v2);
      unint64_t v2 = v3;
    }

    while (v3);
  }

void sub_100116E00(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_100116E00(a1, *a2);
    sub_100116E00(a1, a2[1]);
    sub_10001AAD4((uint64_t)(a2 + 4));
    operator delete(a2);
  }

void *sub_100116E48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = (void *)(a1 + 24);
  unint64_t v9 = sub_100117154(a1 + 24, a2);
  unint64_t v10 = v9;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v4 = v9;
      if (v9 >= v11) {
        unint64_t v4 = v9 % v11;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v9;
    }

    unint64_t v14 = *(void **)(*(void *)a1 + 8 * v4);
    if (v14)
    {
      CFStringRef v26 = a4;
      uint64_t v15 = (void *)*v14;
      if (*v14)
      {
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v10)
          {
          }

          else
          {
            if (v13 > 1)
            {
              if (v16 >= v11) {
                v16 %= v11;
              }
            }

            else
            {
              v16 &= v11 - 1;
            }

            if (v16 != v4) {
              break;
            }
          }

          uint64_t v15 = (void *)*v15;
        }

        while (v15);
      }

      a4 = v26;
    }
  }

  sub_1001170D8(a1, v10, a4, (uint64_t)v27);
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v18 = *(float *)(a1 + 32);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1LL;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_100019E10(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v4 = v10 % v11;
      }
      else {
        unint64_t v4 = v10;
      }
    }

    else
    {
      unint64_t v4 = (v11 - 1) & v10;
    }
  }

  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)v27[0] = *v23;
    *uint64_t v23 = v27[0];
  }

  else
  {
    *(void *)v27[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v27[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v27[0])
    {
      unint64_t v24 = *(void *)(*(void *)v27[0] + 8LL);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v24 >= v11) {
          v24 %= v11;
        }
      }

      else
      {
        v24 &= v11 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v24) = v27[0];
    }
  }

  uint64_t v15 = (void *)v27[0];
  v27[0] = 0LL;
  ++*v8;
  sub_100117300((uint64_t)v27, 0LL);
  return v15;
}

void sub_1001170C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
}

uint64_t sub_1001170D8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint64_t v8 = operator new(0x38uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + ++*(void *)(result + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *uint64_t v8 = 0LL;
  v8[1] = a2;
  uint64_t result = sub_10001B0AC((uint64_t)(v8 + 2), *a3);
  *((_DWORD *)v8 + 12) = 0;
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_10011713C(_Unwind_Exception *a1)
{
}

unint64_t sub_100117154(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 24);
  if ((_DWORD)v2 == -1)
  {
    uint64_t v4 = 299792458LL;
LABEL_5:
    uint64_t v5 = -1LL;
    goto LABEL_6;
  }

  uint64_t v4 = ((uint64_t (*)(char *))*(&off_10181FA00 + v2))(&v9);
  uint64_t v5 = *(unsigned int *)(a2 + 24);
  if ((_DWORD)v5 == -1) {
    goto LABEL_5;
  }
LABEL_6:
  unint64_t v6 = 0x9DDFEA08EB382D69LL * (v4 ^ __ROR8__(v5 + 16, 16));
  unint64_t v7 = __ROR8__(v5 + 16, 16) ^ (v6 >> 47);
  return (0x9DDFEA08EB382D69LL * ((0x9DDFEA08EB382D69LL * (v7 ^ v6)) ^ ((0x9DDFEA08EB382D69LL * (v7 ^ v6)) >> 47))) ^ v5;
}

uint64_t sub_1001171EC(uint64_t a1, uint64_t a2)
{
  return *(void *)a2;
}

unint64_t sub_1001171F4(uint64_t a1, uint64_t a2)
{
  unint64_t result = 0LL;
  for (uint64_t i = 0LL; i != 16; ++i)
    result ^= (result << 6) + (result >> 2) + 2654435769u + *(unsigned __int8 *)(a2 + i);
  return result;
}

unint64_t sub_10011722C(uint64_t a1, uint64_t a2)
{
  return sub_10004B1A4((uint64_t)&v3, a2);
}

uint64_t sub_10011724C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 24);
  int v5 = *(_DWORD *)(a2 + 24);
  BOOL v6 = v5 == v4;
  BOOL v9 = v5 == -1;
  BOOL v7 = v5 == -1;
  if (v9) {
    BOOL v6 = 0;
  }
  if ((_DWORD)v4 == -1) {
    uint64_t result = v7;
  }
  else {
    uint64_t result = v6;
  }
  BOOL v9 = (_DWORD)v4 == -1 || !v6;
  if (!v9)
  {
    unint64_t v11 = &v10;
    return ((uint64_t (*)(char **, uint64_t))*(&off_10181FA18 + v4))(&v11, a1);
  }

  return result;
}

BOOL sub_1001172B4(uint64_t a1, void *a2, void *a3)
{
  return *a2 == *a3;
}

BOOL sub_1001172C8(uint64_t a1, void *a2, void *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

uint64_t sub_1001172E0(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  return sub_100022A24((uint64_t)&v4, a2, a3);
}

void sub_100117300(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_10001AAD4((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }

uint64_t *sub_100117344(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  int v5 = (uint64_t **)sub_1001173D4((uint64_t)a1, &v10, a2);
  BOOL v6 = *v5;
  if (!*v5)
  {
    BOOL v7 = v5;
    sub_100117464((uint64_t)a1, a3, (uint64_t)v9);
    sub_1000085FC(a1, v10, v7, v9[0]);
    BOOL v6 = v9[0];
    v9[0] = 0LL;
    sub_10001B1C0((uint64_t)v9, 0LL);
  }

  return v6;
}

void *sub_1001173D4(uint64_t a1, void *a2, uint64_t a3)
{
  int v5 = (void *)(a1 + 8);
  char v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        BOOL v7 = v4;
        uint64_t v8 = (uint64_t)(v4 + 4);
        char v4 = (void *)*v7;
        int v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }

      int v5 = v7 + 1;
      char v4 = (void *)v7[1];
    }

    while (v4);
  }

  else
  {
    BOOL v7 = (void *)(a1 + 8);
  }

uint64_t sub_100117464@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  BOOL v6 = operator new(0x40uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + ++*(void *)(result + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  uint64_t result = sub_10001B0AC((uint64_t)v6 + 32, a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1001174B4(_Unwind_Exception *a1)
{
}

uint64_t sub_1001174CC(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 24);
  if (v2 == -1) {
    return 0LL;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 24);
  BOOL v6 = &v5;
  return ((uint64_t (*)(char **, uint64_t, uint64_t))*(&off_10181FA30 + v3))(&v6, a1, a2);
}